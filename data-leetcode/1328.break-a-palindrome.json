[
    {
        "title": "Cat and Mouse",
        "question_content": "A game on an undirected graph is played by two players, Mouse and Cat, who alternate turns.\nThe graph is given as follows: graph[a] is a list of all nodes b such that ab is an edge of the graph.\nThe mouse starts at node 1 and goes first, the cat starts at node 2 and goes second, and there is a hole at node 0.\nDuring each player's turn, they must travel along one&nbsp;edge of the graph that meets where they are.&nbsp; For example, if the Mouse is at node 1, it must travel to any node in graph[1].\nAdditionally, it is not allowed for the Cat to travel to the Hole (node 0.)\nThen, the game can end in three&nbsp;ways:\n\n\tIf ever the Cat occupies the same node as the Mouse, the Cat wins.\n\tIf ever the Mouse reaches the Hole, the Mouse wins.\n\tIf ever a position is repeated (i.e., the players are in the same position as a previous turn, and&nbsp;it is the same player's turn to move), the game is a draw.\n\nGiven a graph, and assuming both players play optimally, return\n\n\t1&nbsp;if the mouse wins the game,\n\t2&nbsp;if the cat wins the game, or\n\t0&nbsp;if the game is a draw.\n\n&nbsp;\nExample 1:\n\nInput: graph = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]\nOutput: 0\n\nExample 2:\n\nInput: graph = [[1,3],[0],[3],[0,2]]\nOutput: 1\n\n&nbsp;\nConstraints:\n\n\t3 <= graph.length <= 50\n\t1&nbsp;<= graph[i].length < graph.length\n\t0 <= graph[i][j] < graph.length\n\tgraph[i][j] != i\n\tgraph[i] is unique.\n\tThe mouse and the cat can always move.&nbsp;",
        "solutions": [
            {
                "id": 176177,
                "title": "most-of-the-dfs-solutions-are-wrong-check-this-case",
                "content": "Basically the DFS with memo solutions generate status nodes like `(cat, mouse, turn)`. Before DFS to next level, we mark current node to `0` which means `Draw`. However, there might be **cycles** in the `status graph`.\\n\\ni.e, We mark current node to `Draw`. Then we go into the cycle and mark all nodes in the cycle to `Draw`. However, the right answer to current node could be `Cat` or `Mouse`, this can only be figured out in the later DFS. But the nodes in the cycle have already been marked to `Draw` mistakenly.\\n\\nCheck this case:\\n[[6],[4],[9],[5],[1,5],[3,4,6],[0,5,10],[8,9,10],[7],[2,7],[6,7]]\\n![image](https://assets.leetcode.com/users/wangzi6147/image_1538335324.png)\\n\\nWe will first get a `Draw` in node `(7, 5, mouse)` then later we use this information to mark `(9, 5, cat)` to `Draw`. However `(9, 5, cat)` should be `Mouse`.\\n\\nI believe the right solution should be using Topological traversal and coloring like the post in [solution](https://leetcode.com/problems/cat-and-mouse/solution/) to solve the cycle problem. Also I noticed that many people used DP to solve this problem correctly but I don\\'t understand those solutions. Can anyone help?\\n\\nThis test case was generated manually. Correct me if I\\'m wrong.\\n\\nThe idea of Topological traversal is start from each ending status, topologically traversal to color the previous status.\\n\\nSimilar to the solution, my code for reference:\\n\\n```\\nclass Solution {\\n    public int catMouseGame(int[][] graph) {\\n        int n = graph.length;\\n        // (cat, mouse, mouseMove = 0)\\n        int[][][] color = new int[n][n][2];\\n        int[][][] outdegree = new int[n][n][2];\\n        for (int i = 0; i < n; i++) { // cat\\n            for (int j = 0; j < n; j++) { // mouse\\n                outdegree[i][j][0] = graph[j].length;\\n                outdegree[i][j][1] = graph[i].length;\\n                for (int k : graph[i]) {\\n                    if (k == 0) {\\n                        outdegree[i][j][1]--;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        Queue<int[]> q = new LinkedList<>();\\n        for (int k = 1; k < n; k++) {\\n            for (int m = 0; m < 2; m++) {\\n                color[k][0][m] = 1;\\n                q.offer(new int[]{k, 0, m, 1});\\n                color[k][k][m] = 2;\\n                q.offer(new int[]{k, k, m, 2});\\n            }\\n        }\\n        while (!q.isEmpty()) {\\n            int[] cur = q.poll();\\n            int cat = cur[0], mouse = cur[1], mouseMove = cur[2], c = cur[3];\\n            if (cat == 2 && mouse == 1 && mouseMove == 0) {\\n                return c;\\n            }\\n            int prevMouseMove = 1 - mouseMove;\\n            for (int prev : graph[prevMouseMove == 1 ? cat : mouse]) {\\n                int prevCat = prevMouseMove == 1 ? prev : cat;\\n                int prevMouse = prevMouseMove == 1 ? mouse : prev;\\n                if (prevCat == 0) {\\n                    continue;\\n                }\\n                if (color[prevCat][prevMouse][prevMouseMove] > 0) {\\n                    continue;\\n                }\\n                if (prevMouseMove == 1 && c == 2 || prevMouseMove == 0 && c == 1\\n                    || --outdegree[prevCat][prevMouse][prevMouseMove] == 0) {\\n                    color[prevCat][prevMouse][prevMouseMove] = c;\\n                    q.offer(new int[]{prevCat, prevMouse, prevMouseMove, c});\\n                }\\n            }\\n        }\\n        return color[2][1][0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int catMouseGame(int[][] graph) {\\n        int n = graph.length;\\n        // (cat, mouse, mouseMove = 0)\\n        int[][][] color = new int[n][n][2];\\n        int[][][] outdegree = new int[n][n][2];\\n        for (int i = 0; i < n; i++) { // cat\\n            for (int j = 0; j < n; j++) { // mouse\\n                outdegree[i][j][0] = graph[j].length;\\n                outdegree[i][j][1] = graph[i].length;\\n                for (int k : graph[i]) {\\n                    if (k == 0) {\\n                        outdegree[i][j][1]--;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        Queue<int[]> q = new LinkedList<>();\\n        for (int k = 1; k < n; k++) {\\n            for (int m = 0; m < 2; m++) {\\n                color[k][0][m] = 1;\\n                q.offer(new int[]{k, 0, m, 1});\\n                color[k][k][m] = 2;\\n                q.offer(new int[]{k, k, m, 2});\\n            }\\n        }\\n        while (!q.isEmpty()) {\\n            int[] cur = q.poll();\\n            int cat = cur[0], mouse = cur[1], mouseMove = cur[2], c = cur[3];\\n            if (cat == 2 && mouse == 1 && mouseMove == 0) {\\n                return c;\\n            }\\n            int prevMouseMove = 1 - mouseMove;\\n            for (int prev : graph[prevMouseMove == 1 ? cat : mouse]) {\\n                int prevCat = prevMouseMove == 1 ? prev : cat;\\n                int prevMouse = prevMouseMove == 1 ? mouse : prev;\\n                if (prevCat == 0) {\\n                    continue;\\n                }\\n                if (color[prevCat][prevMouse][prevMouseMove] > 0) {\\n                    continue;\\n                }\\n                if (prevMouseMove == 1 && c == 2 || prevMouseMove == 0 && c == 1\\n                    || --outdegree[prevCat][prevMouse][prevMouseMove] == 0) {\\n                    color[prevCat][prevMouse][prevMouseMove] = c;\\n                    q.offer(new int[]{prevCat, prevMouse, prevMouseMove, c});\\n                }\\n            }\\n        }\\n        return color[2][1][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 298937,
                "title": "dp-memory-status-search-search-strait-forward-and-easy-to-understand",
                "content": "```\\n/*The idea is from MR wang\\'s blog:  https://www.acwing.com/solution/leetcode/content/556\\nHe did it in C++, i just transform it to JAVA\\n\\nThe basic idea is the memory cache search.\\nThere are 3 dimensions: The time t, mouse position x, and cat position y.\\nso at any time and any position   f(t, x, y) should have a value.\\nvalue       0       1                   2\\nresult      draw   mouse win            cat win\\n\\nThere are  n nodes, so when after 2n steps if we still can\\'t decide who wins, the chase game will continue for ever and return 0\\n\\nThere are totally 2n* n * n = 2n^3 status, we may not reach every position. because we only can move along the graph\\'s edges\\n\\nFor all those 2*n^3 status, some position we already know who will win.\\nthat is 1# f(*, 0,*)=1, when mouse go to position, mouse win.\\n        2# f(*, y,y)=2, when mouse and cat get ot the same position, then cat win.\\n        3# f(2*n,*,*) return 0, because after this, there will repeat for ever\\n         \\ninitially, we set all the status to -1.\\nbase case is above 3 plus #4 that, we already have this position or dp[t][x][y]!=-1\\n\\nwhen mouse\\'t turn, \\nwe check the 4 base cases, if don\\'t meet those 4 base cases, we need move furthre\\nf(t+1,i,y) i in graph[x]. if any of those next status is 1 we return 1 \\n                          if all those next satus is 2  we return  2\\n                          otherwise we reutrn 0\\nonce you understand the idea, the code is very easy\\nAnd time is also, easy to see which is o(n^3)\\n*/\\n```\\n```\\nclass Solution {\\n    int[][][] dp;\\n    public int catMouseGame(int[][] graph) {\\n        int n = graph.length;\\n        dp = new int[2*n][n][n];\\n        for(int i=0; i<dp.length; i++) for(int j=0;  j<dp[0].length; j++) Arrays.fill(dp[i][j],-1);\\n        return seach(graph, 0, 1,2);\\n    }\\n    // t is which step, x is mouse location, y is cat location\\n    int seach(int[][] graph, int t, int x, int y){\\n        if (t == graph.length * 2) return 0;\\n        if (x == y) return dp[t][x][y] = 2;\\n        if (x == 0) return dp[t][x][y] = 1;\\n        if (dp[t][x][y] != -1) return dp[t][x][y];\\n         int who = t % 2;\\n         boolean flag;\\n        if (who == 0) { // mouse\\'s turn\\n            flag = true; // by default, is cat win\\n            for (int i = 0; i < graph[x].length; i++) {\\n                int nxt = seach(graph, t + 1, graph[x][i], y);\\n                if (nxt == 1) return dp[t][x][y] = 1;\\n                else if (nxt != 2) flag = false;\\n            }\\n            if (flag) return dp[t][x][y] = 2;\\n            else return dp[t][x][y] = 0;\\n        }\\n        else { // cat\\'s turn\\n            flag = true; // by default is mouse win\\n            for (int i = 0; i < graph[y].length; i++)\\n                if (graph[y][i] != 0) {\\n                    int nxt = seach(graph, t + 1, x, graph[y][i]);\\n                    if (nxt == 2) return dp[t][x][y] = 2;\\n                    else if (nxt != 1) flag = false;\\n                }\\n            if (flag) return dp[t][x][y] = 1;\\n            else return dp[t][x][y] = 0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*The idea is from MR wang\\'s blog:  https://www.acwing.com/solution/leetcode/content/556\\nHe did it in C++, i just transform it to JAVA\\n\\nThe basic idea is the memory cache search.\\nThere are 3 dimensions: The time t, mouse position x, and cat position y.\\nso at any time and any position   f(t, x, y) should have a value.\\nvalue       0       1                   2\\nresult      draw   mouse win            cat win\\n\\nThere are  n nodes, so when after 2n steps if we still can\\'t decide who wins, the chase game will continue for ever and return 0\\n\\nThere are totally 2n* n * n = 2n^3 status, we may not reach every position. because we only can move along the graph\\'s edges\\n\\nFor all those 2*n^3 status, some position we already know who will win.\\nthat is 1# f(*, 0,*)=1, when mouse go to position, mouse win.\\n        2# f(*, y,y)=2, when mouse and cat get ot the same position, then cat win.\\n        3# f(2*n,*,*) return 0, because after this, there will repeat for ever\\n         \\ninitially, we set all the status to -1.\\nbase case is above 3 plus #4 that, we already have this position or dp[t][x][y]!=-1\\n\\nwhen mouse\\'t turn, \\nwe check the 4 base cases, if don\\'t meet those 4 base cases, we need move furthre\\nf(t+1,i,y) i in graph[x]. if any of those next status is 1 we return 1 \\n                          if all those next satus is 2  we return  2\\n                          otherwise we reutrn 0\\nonce you understand the idea, the code is very easy\\nAnd time is also, easy to see which is o(n^3)\\n*/\\n```\n```\\nclass Solution {\\n    int[][][] dp;\\n    public int catMouseGame(int[][] graph) {\\n        int n = graph.length;\\n        dp = new int[2*n][n][n];\\n        for(int i=0; i<dp.length; i++) for(int j=0;  j<dp[0].length; j++) Arrays.fill(dp[i][j],-1);\\n        return seach(graph, 0, 1,2);\\n    }\\n    // t is which step, x is mouse location, y is cat location\\n    int seach(int[][] graph, int t, int x, int y){\\n        if (t == graph.length * 2) return 0;\\n        if (x == y) return dp[t][x][y] = 2;\\n        if (x == 0) return dp[t][x][y] = 1;\\n        if (dp[t][x][y] != -1) return dp[t][x][y];\\n         int who = t % 2;\\n         boolean flag;\\n        if (who == 0) { // mouse\\'s turn\\n            flag = true; // by default, is cat win\\n            for (int i = 0; i < graph[x].length; i++) {\\n                int nxt = seach(graph, t + 1, graph[x][i], y);\\n                if (nxt == 1) return dp[t][x][y] = 1;\\n                else if (nxt != 2) flag = false;\\n            }\\n            if (flag) return dp[t][x][y] = 2;\\n            else return dp[t][x][y] = 0;\\n        }\\n        else { // cat\\'s turn\\n            flag = true; // by default is mouse win\\n            for (int i = 0; i < graph[y].length; i++)\\n                if (graph[y][i] != 0) {\\n                    int nxt = seach(graph, t + 1, x, graph[y][i]);\\n                    if (nxt == 2) return dp[t][x][y] = 2;\\n                    else if (nxt != 1) flag = false;\\n                }\\n            if (flag) return dp[t][x][y] = 1;\\n            else return dp[t][x][y] = 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 181681,
                "title": "java-solution-with-bug-updated-on-02-02-2019",
                "content": "Updated on 02/02/2019.\\nThanks for @sguaaa pointting out bug.   If there are two cycles on both end, the code failed on: [[6],[4,11],[9,12],[5],[1,5,11],[3,4,6],[0,5,10],[8,9,10],[7],[2,7,12],[6,7],[1,4],[2,9]]. \\nI guess the problem is I preallocate ```dp[mouse][cat] = 0``` at the beginning of each iteration, which may not right. \\n\\nI feel exhausted after spending hours on investigating this problem but still no conclution.  Anyone has idea on how to fix the code?   \\nThank you for discussion!\\n```\\nclass Solution {\\n    public int catMouseGame(int[][] graph) {\\n        int size = graph.length;\\n        int dp[][] = new int[size][size];\\n        for (int i = 0; i < size; i++)\\n            Arrays.fill(dp[i], -1);  // unvisited\\n\\n        for (int i = 1; i < size; ++i) {\\n            dp[0][i] = 1;   // mouse reached home, m win\\n            dp[i][i] = 2;   // cat met mouse, cat win\\n        }\\n\\n        return helper(graph, 1, 2, dp);\\n    }\\n\\n    public int helper(int[][] graph, int mouse, int cat, int dp[][]) {\\n\\n        if (dp[mouse][cat] != -1)\\n            return dp[mouse][cat];  // use cached value\\n\\n        dp[mouse][cat] = 0;  // if there is a cycle, draw\\n        int mouseDefault = 2;  //  default cat win, try to update this number to 1 or 0\\n        int[] mouseGoList = graph[mouse], catGoList = graph[cat];\\n\\n        for (int mouseGo : mouseGoList) {\\n            if (mouseGo == cat)\\n                continue;   // I\\'m a mouse, why go for a cat?\\n\\n            int catDefault = 1;  //  default mouse win, try to update this number to 2 or 0\\n            for (int catGo : catGoList) {\\n                if (catGo == 0)\\n                    continue;  // cannot go to hole\\n                int next = helper(graph, mouseGo, catGo, dp);\\n                if (next == 2) {   // if cat win in this path, no need to continue\\n                    catDefault = 2;\\n                    break;\\n                }\\n                if (next == 0) {   // at least it\\'s a draw\\n                    catDefault = 0;\\n                }\\n            }\\n\\n            if (catDefault == 1) {  // if mouse can win in this path, no need to continue\\n                mouseDefault = 1;\\n                break;\\n            }\\n            if (catDefault == 0) {  // at least it\\'s a draw\\n                mouseDefault = 0;\\n            }\\n        }\\n        dp[mouse][cat] = mouseDefault;\\n        return dp[mouse][cat];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```dp[mouse][cat] = 0```\n```\\nclass Solution {\\n    public int catMouseGame(int[][] graph) {\\n        int size = graph.length;\\n        int dp[][] = new int[size][size];\\n        for (int i = 0; i < size; i++)\\n            Arrays.fill(dp[i], -1);  // unvisited\\n\\n        for (int i = 1; i < size; ++i) {\\n            dp[0][i] = 1;   // mouse reached home, m win\\n            dp[i][i] = 2;   // cat met mouse, cat win\\n        }\\n\\n        return helper(graph, 1, 2, dp);\\n    }\\n\\n    public int helper(int[][] graph, int mouse, int cat, int dp[][]) {\\n\\n        if (dp[mouse][cat] != -1)\\n            return dp[mouse][cat];  // use cached value\\n\\n        dp[mouse][cat] = 0;  // if there is a cycle, draw\\n        int mouseDefault = 2;  //  default cat win, try to update this number to 1 or 0\\n        int[] mouseGoList = graph[mouse], catGoList = graph[cat];\\n\\n        for (int mouseGo : mouseGoList) {\\n            if (mouseGo == cat)\\n                continue;   // I\\'m a mouse, why go for a cat?\\n\\n            int catDefault = 1;  //  default mouse win, try to update this number to 2 or 0\\n            for (int catGo : catGoList) {\\n                if (catGo == 0)\\n                    continue;  // cannot go to hole\\n                int next = helper(graph, mouseGo, catGo, dp);\\n                if (next == 2) {   // if cat win in this path, no need to continue\\n                    catDefault = 2;\\n                    break;\\n                }\\n                if (next == 0) {   // at least it\\'s a draw\\n                    catDefault = 0;\\n                }\\n            }\\n\\n            if (catDefault == 1) {  // if mouse can win in this path, no need to continue\\n                mouseDefault = 1;\\n                break;\\n            }\\n            if (catDefault == 0) {  // at least it\\'s a draw\\n                mouseDefault = 0;\\n            }\\n        }\\n        dp[mouse][cat] = mouseDefault;\\n        return dp[mouse][cat];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 176268,
                "title": "perfect-wrong-dfs-dp-code-explained-in-detail-revised",
                "content": "**The original is clean but wrong. I\\'ll explain why it is wrong and give the correct answer and the right thinking.**\\n\\n![\\u770Blog\\u627EBug](https://i.imgur.com/2WfskGM.jpg) \\n-----\\n# 1. clean and wrong solution \\n\\n > Step 1 How to recognize a DP problem\\n\\nConsider using DP whenever you have to **make choices** to arrive at the solution, specifically, when the solution relates to subproblems.\\n\\nIn *<7 Steps to Solve any DP Interview Problem>*, the second step is \\n\\n> Step 2 Identify problems variables \\n\\nWe come to identify a unique problem by defining three variable: when `cat_position` is 2, `mouse_position` is 1, and it is the `mouse\\'s_turn` to move, what is the answer to the current state `(2, 1, True)`?\\n\\nWe use `(cat, mouse, m_turn)` to represent them.\\n\\nThe next step is: \\n\\n> step 3 Clearly express the recurrence relation\\n```\\n4---3---1\\n|   |\\n2---5\\n \\\\ /\\n  0\\n```\\n\\t\\nRemember: `0` means a tie, `2` means the cat win, `1` means the mouse win.\\n\\t\\nAssume we know the answers to the states `(2, 3, False)` is 0 (We don\\'t care how do we know), thus we can know `(2, 1, True)` is 0, cause there is only one way from `(2, 1, True)` to its next move. \\n\\t\\nAnd by the same logic, if we want to know the answer to `(2, 3, False)`, which means the current cat position is 2, the current mouse position is 3, and it is the cat\\'s turn to move, we need to know the answer to `(4, 3, True)`, `(5, 3, True)`. (In question, the cat cannot go to 0). \\n\\nOne question may occur to us: what\\'s **optimal** in the context?\\n\\nAns: when it is the cat\\'s turn to move, if the cat plays optimally (win `2` > draw `0` > lose `1`),the cat will choose the next move state that returns `2` as long as there exists such one next move that returns `2`(the cat wins). If not, he will the next move state that returns `0`. Eventually, the cat will be faced with `lose` if all next moves that return `1`.\\n\\nBy the same logic, the mouse will do the same choice. \\n\\t\\nQuestion is when do we get `0`?\\n\\t\\nAns: If we come to the next move that be visited before, which means we need a `memo` to record the visited state.\\n\\t\\nNow we got the recurrence relation. The next step is \\n\\t\\n> Step 4: Identify the base cases  \\n\\nFor the cat, the result will be 2 when the cat\\'s next move position is the mouse\\'s current position. Otherwise, the result come from its next move states.\\n\\t\\nFor the mouse, the result will be 1 when the mouse\\'s next move position is the hole `0`. Otherwise, the result comes from its next move states.\\n\\t\\nNow we got the base cases. The next step is\\n\\n> Step 5: Decide if you want to implement it iteratively or recursively\\n\\t\\nNormally, recursive is more intuitive and easier to implement. For this problem, recursive way is easier to reason about, just as explained as above.\\nTo make it more efficient, the next step is \\n\\n> Step 6: Add memoization  \\n\\nThus we don\\'t have to calculate again when we encounter the same subproblems with memoization. Those repetitions very often lead to exponential time complexities.\\n\\t\\nThe last step is \\n\\n> Step 7: Determine the time Complexity \\n\\t\\nTime Complexity: O(N^3), where N is the number of nodes in the graph. There are O(N^2) states, and each state has an outdegree of N, as there are at most N different moves.\\n\\nSpace Complexity: O(N^2). There are O(N^2) at most that we need to record.\\n\\t\\nNote: \\n- check [my notes in both English and Chinese](https://github.com/willwang-x/algorithms-with-illustrations/blob/master/leetcode/916-cat-and-mouse.md)\\n- [Dynamic Programming \\u2013 7 Steps to Solve any DP Interview Problem](http://blog.refdash.com/dynamic-programming-tutorial-example/)\\n\\n------\\n\\n```\\n\\nclass Solution:\\n    def catMouseGame(self, graph):\\n        \"\"\"\\n        :type graph: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        self.graph = graph \\n        self.memo = {}\\n        return self.move(2, 1, True)\\n        \\n    def move(self, cat, mouse, m_turn):\\n        key = (cat, mouse, m_turn)\\n        if key in self.memo:\\n            return self.memo[key]\\n        self.memo[key] = 0\\n        \\n        if m_turn:\\n            return self.mouse_play(key, cat, mouse, m_turn)\\n        else:\\n            return self.cat_play(key, cat, mouse, m_turn)\\n        \\n    def mouse_play(self, key, cat, turn, m_turn):\\n        # base case \\n        for nxt in self.graph[turn]:\\n            if nxt == 0:\\n                self.memo[key] = 1\\n                return 1\\n        \\n        res = 2\\n        for nxt in self.graph[turn]:\\n            if nxt == cat:\\n                continue \\n            tmp = self.move(cat, nxt, False)\\n            if tmp == 1:\\n                res = 1\\n                break\\n            if tmp == 0:\\n                res = 0\\n        self.memo[key] = res \\n        return res \\n    \\n    def cat_play(self, key, turn, mouse, m_turn):\\n        # base case \\n        for nxt in self.graph[turn]:\\n            if nxt == mouse:\\n                self.memo[key] = 2\\n                return 2\\n            \\n        res = 1 \\n        for nxt in self.graph[turn]:\\n            if nxt ==0:\\n                continue \\n            tmp = self.move(nxt, mouse, True)\\n            if tmp == 2:\\n                res = 2\\n                break \\n            if tmp == 0:\\n                res = 0\\n        self.memo[key] = res \\n        return res \\n```\\n\\n## 2. Why it is wrong?\\n\\n>  For example, if mouse is one step away from the hole, and dfs picks another root before the hole root, if that root is a loop and return to this node again, dfs would think that\\'s a draw(return to previous state) instead of mouse win.  \\u2014\\u2014 Unicorn\\n\\nDebug process\\uFF1Ahttps://repl.it/@WillWang42/cat-and-mouse-debug/\\n\\n![](https://i.imgur.com/SoaTYNA.png)\\n![detail1](https://i.imgur.com/fhJwL66.png)\\n![detail2](https://i.imgur.com/H5tN79m.png)\\n\\n## 3. possible right code (no prove)\\n\\n```\\n# revised version  provided by a friend\\nclass Solution:\\n    def catMouseGame(self, graph):\\n        \"\"\"\\n        :type graph: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(graph)\\n        state = [[-1]*n for _ in range(n)]\\n        return self.search(state, graph, 1, 2)\\n    \\n    def search(self, state, graph, m_pos, c_pos):\\n        if state[m_pos][c_pos] != -1:\\n            return state[m_pos][c_pos]\\n        if m_pos == c_pos:\\n            state[m_pos][c_pos] = 2\\n            return 2\\n        if m_pos == 0:\\n            state[m_pos][c_pos] = 1\\n            return 1\\n        state[m_pos][c_pos] = 0\\n        \\n        all_cat_win = True \\n        for nxt_mouse in graph[m_pos]:\\n            if nxt_mouse != c_pos:\\n                all_mouse_win = True \\n                exist_cat_win = False \\n                for nxt_cat in graph[c_pos]:\\n                    if nxt_cat != 0:\\n                        nxt_state = self.search(state, graph, nxt_mouse, nxt_cat)\\n                        if nxt_state != 1:\\n                            all_mouse_win = False \\n                            if nxt_state == 2:\\n                                exist_cat_win = True \\n                    if not all_mouse_win and exist_cat_win:\\n                        break \\n                if all_mouse_win:\\n                    state[m_pos][c_pos] = 1\\n                    return 1\\n                if not exist_cat_win:\\n                    all_cat_win = False \\n        state[m_pos][c_pos] = 2 if all_cat_win else 0\\n        return state[m_pos][c_pos]\\n```\\n\\n## 4. Better solution \\n\\ncheck the officical solution.",
                "solutionTags": [],
                "code": "```\\n4---3---1\\n|   |\\n2---5\\n \\\\ /\\n  0\\n```\n```\\n\\nclass Solution:\\n    def catMouseGame(self, graph):\\n        \"\"\"\\n        :type graph: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        self.graph = graph \\n        self.memo = {}\\n        return self.move(2, 1, True)\\n        \\n    def move(self, cat, mouse, m_turn):\\n        key = (cat, mouse, m_turn)\\n        if key in self.memo:\\n            return self.memo[key]\\n        self.memo[key] = 0\\n        \\n        if m_turn:\\n            return self.mouse_play(key, cat, mouse, m_turn)\\n        else:\\n            return self.cat_play(key, cat, mouse, m_turn)\\n        \\n    def mouse_play(self, key, cat, turn, m_turn):\\n        # base case \\n        for nxt in self.graph[turn]:\\n            if nxt == 0:\\n                self.memo[key] = 1\\n                return 1\\n        \\n        res = 2\\n        for nxt in self.graph[turn]:\\n            if nxt == cat:\\n                continue \\n            tmp = self.move(cat, nxt, False)\\n            if tmp == 1:\\n                res = 1\\n                break\\n            if tmp == 0:\\n                res = 0\\n        self.memo[key] = res \\n        return res \\n    \\n    def cat_play(self, key, turn, mouse, m_turn):\\n        # base case \\n        for nxt in self.graph[turn]:\\n            if nxt == mouse:\\n                self.memo[key] = 2\\n                return 2\\n            \\n        res = 1 \\n        for nxt in self.graph[turn]:\\n            if nxt ==0:\\n                continue \\n            tmp = self.move(nxt, mouse, True)\\n            if tmp == 2:\\n                res = 2\\n                break \\n            if tmp == 0:\\n                res = 0\\n        self.memo[key] = res \\n        return res \\n```\n```\\n# revised version  provided by a friend\\nclass Solution:\\n    def catMouseGame(self, graph):\\n        \"\"\"\\n        :type graph: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(graph)\\n        state = [[-1]*n for _ in range(n)]\\n        return self.search(state, graph, 1, 2)\\n    \\n    def search(self, state, graph, m_pos, c_pos):\\n        if state[m_pos][c_pos] != -1:\\n            return state[m_pos][c_pos]\\n        if m_pos == c_pos:\\n            state[m_pos][c_pos] = 2\\n            return 2\\n        if m_pos == 0:\\n            state[m_pos][c_pos] = 1\\n            return 1\\n        state[m_pos][c_pos] = 0\\n        \\n        all_cat_win = True \\n        for nxt_mouse in graph[m_pos]:\\n            if nxt_mouse != c_pos:\\n                all_mouse_win = True \\n                exist_cat_win = False \\n                for nxt_cat in graph[c_pos]:\\n                    if nxt_cat != 0:\\n                        nxt_state = self.search(state, graph, nxt_mouse, nxt_cat)\\n                        if nxt_state != 1:\\n                            all_mouse_win = False \\n                            if nxt_state == 2:\\n                                exist_cat_win = True \\n                    if not all_mouse_win and exist_cat_win:\\n                        break \\n                if all_mouse_win:\\n                    state[m_pos][c_pos] = 1\\n                    return 1\\n                if not exist_cat_win:\\n                    all_cat_win = False \\n        state[m_pos][c_pos] = 2 if all_cat_win else 0\\n        return state[m_pos][c_pos]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 399346,
                "title": "c-solution-with-super-detailed-explanation-topological-sort",
                "content": "First you need understand the N position and P postion from Combinatorial Game Theory.\\nP-Position is previous player win, N-Position is next player (current player) win.\\nA position is a N-Position as long as one of its following positions is P-Position, i.e. if current player take this move, in next turn he as the previous player is guaranteed to win.\\nA position is a P-Position only if all its following positions are N-Position, i.e. no matter how current player move, the previous player is guaranteed to win in next turn.\\n\\nThe algorithm:\\n1.  Initalize cat win or mouse win final states:\\n    Mouse Win: mouse is at the hole.\\n    Cat Win: cat is over mouse.\\n    Push them into a queue.\\n2.  Pop out a known state from queue:\\n    a. N-positon. If it\\'s a mouse win, mark the connected neighbor node\\'s mouse turn as mouse win.\\n       If it\\'s a cat win, mark the connected neighbor node\\'s cat turn as cat win.\\n    b. P-position, topological sort. Since current node as a child of the neighbor has been check, we reduce the indegree of the other turn of the neighbor by 1.\\n       By \"other turn of the neighbor\", it means if it\\'s mouse win, reduce indegree of cat turn of neighbor by 1. If the indegree of the other turn of the neighbor becomes 0, means the neighbor in this state has no choice (P position).\\n       How about draw? Because in every step, we only count into definite winning state (cat or mouse win), so if a node\\'s degree reduced to 0, all it\\'s children  must be in a definite winning state, that\\'s why above P position assertion is correct.\\n\\n\\n```C++\\nclass Solution{\\npublic:\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        vector<vector<vector<char>>> states(n, vector<vector<char>>(n, vector<char>(2, Draw)));\\n        vector<vector<vector<int>>> indegree(n, vector<vector<int>>(n, vector<int>(2)));\\n        queue<vector<int>> q;\\n        for(int i = 0; i < n; i++){\\n            if(0 != i){\\n                states[0][i][MTurn] = states[0][i][CTurn] = MWin;\\n                q.emplace(vector<int>{0, i, MTurn, (int)MWin});\\n                q.emplace(vector<int>{0, i, CTurn, (int)MWin});\\n                states[i][i][MTurn] = states[i][i][CTurn] = CWin;\\n                q.emplace(vector<int>{i, i, MTurn, (int)CWin});\\n                q.emplace(vector<int>{i, i, CTurn, (int)CWin});\\n            }\\n            for(int j = 0; j < n; j++){\\n                indegree[i][j][MTurn] = graph[i].size(); // when the mouse is at i, the cat is at j, and it\\'s mouse\\'s turn, how many routes the mouse can go.\\n                indegree[i][j][CTurn] = graph[j].size(); // when the mouse is at i, the cat is at j, and it\\'s cat\\'s turn, how many routes the cat can go.\\n                if(find(graph[j].begin(), graph[j].end(), 0) != graph[j].end()) indegree[i][j][CTurn]--; // cat cannot move to the hole, so 0 cannot be considered as a route for cat.\\n            }\\n\\n        }\\n\\n        while(!q.empty()){\\n            int m_pos = q.front()[0], c_pos = q.front()[1], turn = q.front()[2], result = q.front()[3];\\n            q.pop();\\n            int prev_turn = !turn;\\n            if(MTurn == prev_turn) { // previous turn is mouse\\'s turn\\n                for(auto &i : graph[m_pos]) {\\n                    if(Draw == states[i][c_pos][prev_turn]) {\\n                        if(MWin == result){ // N-position, the mouse found a way to escape\\n                             states[i][c_pos][prev_turn] = MWin;\\n                        } else { \\n                            indegree[i][c_pos][prev_turn]--; // this way is blocked by the cat\\n                            if(0 == indegree[i][c_pos][prev_turn]) states[i][c_pos][prev_turn] = CWin; // P-position, the mouse has no choices\\n                        }\\n                        if(Draw != states[i][c_pos][prev_turn]) {\\n                            q.emplace(vector<int>{i, c_pos, prev_turn, (int)states[i][c_pos][prev_turn]});\\n                        }\\n                    }\\n                }\\n            } else { // previous turn is cat\\'s turn\\n                for(auto &i : graph[c_pos]) {\\n                    if(0 == i) continue; // cat cannot be at the hole!!\\n                    if(Draw == states[m_pos][i][prev_turn]) {\\n                        if(CWin == result){ // N-position, the cat is guaranteed to catch the mouse in next step\\n                            states[m_pos][i][prev_turn] = CWin;\\n                        } else {\\n                            indegree[m_pos][i][prev_turn]--; // the mouse can escape if the cat take this move\\n                            if(0 == indegree[m_pos][i][prev_turn]) states[m_pos][i][prev_turn] = MWin;  // P-position, the cat has no choices\\n                        }\\n                        if(Draw != states[m_pos][i][prev_turn]) {\\n                            q.emplace(vector<int>{m_pos, i, prev_turn, (int)states[m_pos][i][prev_turn]});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return states[1][2][MTurn];\\n    }\\nprivate:\\n    const int MTurn = 0;\\n    const int CTurn = 1;\\n    const char Draw = 0;\\n    const char MWin = 1;\\n    const char CWin = 2;\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```C++\\nclass Solution{\\npublic:\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        vector<vector<vector<char>>> states(n, vector<vector<char>>(n, vector<char>(2, Draw)));\\n        vector<vector<vector<int>>> indegree(n, vector<vector<int>>(n, vector<int>(2)));\\n        queue<vector<int>> q;\\n        for(int i = 0; i < n; i++){\\n            if(0 != i){\\n                states[0][i][MTurn] = states[0][i][CTurn] = MWin;\\n                q.emplace(vector<int>{0, i, MTurn, (int)MWin});\\n                q.emplace(vector<int>{0, i, CTurn, (int)MWin});\\n                states[i][i][MTurn] = states[i][i][CTurn] = CWin;\\n                q.emplace(vector<int>{i, i, MTurn, (int)CWin});\\n                q.emplace(vector<int>{i, i, CTurn, (int)CWin});\\n            }\\n            for(int j = 0; j < n; j++){\\n                indegree[i][j][MTurn] = graph[i].size(); // when the mouse is at i, the cat is at j, and it\\'s mouse\\'s turn, how many routes the mouse can go.\\n                indegree[i][j][CTurn] = graph[j].size(); // when the mouse is at i, the cat is at j, and it\\'s cat\\'s turn, how many routes the cat can go.\\n                if(find(graph[j].begin(), graph[j].end(), 0) != graph[j].end()) indegree[i][j][CTurn]--; // cat cannot move to the hole, so 0 cannot be considered as a route for cat.\\n            }\\n\\n        }\\n\\n        while(!q.empty()){\\n            int m_pos = q.front()[0], c_pos = q.front()[1], turn = q.front()[2], result = q.front()[3];\\n            q.pop();\\n            int prev_turn = !turn;\\n            if(MTurn == prev_turn) { // previous turn is mouse\\'s turn\\n                for(auto &i : graph[m_pos]) {\\n                    if(Draw == states[i][c_pos][prev_turn]) {\\n                        if(MWin == result){ // N-position, the mouse found a way to escape\\n                             states[i][c_pos][prev_turn] = MWin;\\n                        } else { \\n                            indegree[i][c_pos][prev_turn]--; // this way is blocked by the cat\\n                            if(0 == indegree[i][c_pos][prev_turn]) states[i][c_pos][prev_turn] = CWin; // P-position, the mouse has no choices\\n                        }\\n                        if(Draw != states[i][c_pos][prev_turn]) {\\n                            q.emplace(vector<int>{i, c_pos, prev_turn, (int)states[i][c_pos][prev_turn]});\\n                        }\\n                    }\\n                }\\n            } else { // previous turn is cat\\'s turn\\n                for(auto &i : graph[c_pos]) {\\n                    if(0 == i) continue; // cat cannot be at the hole!!\\n                    if(Draw == states[m_pos][i][prev_turn]) {\\n                        if(CWin == result){ // N-position, the cat is guaranteed to catch the mouse in next step\\n                            states[m_pos][i][prev_turn] = CWin;\\n                        } else {\\n                            indegree[m_pos][i][prev_turn]--; // the mouse can escape if the cat take this move\\n                            if(0 == indegree[m_pos][i][prev_turn]) states[m_pos][i][prev_turn] = MWin;  // P-position, the cat has no choices\\n                        }\\n                        if(Draw != states[m_pos][i][prev_turn]) {\\n                            q.emplace(vector<int>{m_pos, i, prev_turn, (int)states[m_pos][i][prev_turn]});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return states[1][2][MTurn];\\n    }\\nprivate:\\n    const int MTurn = 0;\\n    const int CTurn = 1;\\n    const char Draw = 0;\\n    const char MWin = 1;\\n    const char CWin = 2;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 507706,
                "title": "c-map-solution-in-o-n-m-log-n",
                "content": "I did this live on stream at https://www.twitch.tv/errichto\\nYou can get rid of logarithm easily by changing map to array.\\n\\n```\\nstruct State {\\n    int cat, mouse, who;\\n    bool operator <(const State& b) const {\\n        return tie(cat, mouse, who)\\n            <  tie(b.cat, b.mouse, b.who);\\n    }\\n};\\n\\nconst int CAT = 0;\\nconst int MOUSE = 1;\\nmap<State, bool> winner; // arr[n][n][2]\\nmap<State, int> out;\\n\\nvector<vector<int>> graph;\\nvector<int> cat_degree;\\n\\nbool decided(State state) {\\n    return state.mouse == state.cat || state.mouse == 0 || state.cat == 0;\\n}\\n\\n//O(N^2 * N * log(N))\\n//O(N * M * log(N))\\n\\nvoid rec(State state, bool result) {\\n    // printf(\"cat=%d mouse=%d turn=%c result=%c\\\\n\", state.cat, state.mouse, (state.who == MOUSE ? \\'M\\' : \\'C\\'), (result == MOUSE ? \\'M\\' : \\'C\\'));\\n    if(winner.count(state)) {\\n        assert(winner[state] == result);\\n        return;\\n    }\\n    winner[state] = result;\\n    if(state.who == MOUSE) {\\n        // CAT moved previously\\n        for(int prev_cat : graph[state.cat]) {\\n            //if(prev_cat == 0) {\\n            //    continue;\\n            //}\\n            State prev_state{prev_cat, state.mouse, CAT};\\n            if(decided(prev_state)) {\\n                continue;\\n            }\\n            if(result == CAT) {\\n                rec(prev_state, CAT);\\n            }\\n            else {\\n                if(++out[prev_state] == cat_degree[prev_cat]) {\\n                    rec(prev_state, MOUSE);\\n                }\\n            }\\n        }\\n    }\\n    else {\\n        // MOUSE moved previously\\n        for(int prev_mouse : graph[state.mouse]) {\\n            State prev_state{state.cat, prev_mouse, MOUSE};\\n            if(decided(prev_state)) {\\n                continue;\\n            }\\n            if(result == MOUSE) {\\n                rec(prev_state, MOUSE);\\n            }\\n            else {\\n                if(++out[prev_state] == (int) graph[prev_mouse].size()) {\\n                    rec(prev_state, CAT);\\n                }\\n            }\\n        }\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    int catMouseGame(vector<vector<int>>& _graph) {\\n        winner.clear();\\n        out.clear();\\n        graph = _graph;\\n        int n = graph.size();\\n        cat_degree = vector<int>(n);\\n        for(int a = 0; a < n; ++a) {\\n            cat_degree[a] = graph[a].size();\\n            for(int b : graph[a]) {\\n                if(b == 0) {\\n                    cat_degree[a]--;\\n                }\\n            }\\n        }\\n        for(int cat = 1; cat < n; cat++) {\\n            for(int who : {0, 1}) {\\n                rec({cat, 0, who}, MOUSE);\\n                rec({cat, cat, who}, CAT);\\n            }\\n        }\\n        State start{2, 1, MOUSE};\\n        if(winner.count(start)) {\\n            if(winner[start] == MOUSE) {\\n                return 1;\\n            }\\n            return 2;\\n        }\\n        return 0;\\n    }\\n};\\n\\n/*\\nstate: (cat, mouse, who)\\n\\nmouse = 0 -> win for mouse\\ncat = mouse -> win for cat\\n    \\nif mouse can move to something where mouse wins -> win\\nif all outgoing edges go to mouse winning -> mouse wins\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nstruct State {\\n    int cat, mouse, who;\\n    bool operator <(const State& b) const {\\n        return tie(cat, mouse, who)\\n            <  tie(b.cat, b.mouse, b.who);\\n    }\\n};\\n\\nconst int CAT = 0;\\nconst int MOUSE = 1;\\nmap<State, bool> winner; // arr[n][n][2]\\nmap<State, int> out;\\n\\nvector<vector<int>> graph;\\nvector<int> cat_degree;\\n\\nbool decided(State state) {\\n    return state.mouse == state.cat || state.mouse == 0 || state.cat == 0;\\n}\\n\\n//O(N^2 * N * log(N))\\n//O(N * M * log(N))\\n\\nvoid rec(State state, bool result) {\\n    // printf(\"cat=%d mouse=%d turn=%c result=%c\\\\n\", state.cat, state.mouse, (state.who == MOUSE ? \\'M\\' : \\'C\\'), (result == MOUSE ? \\'M\\' : \\'C\\'));\\n    if(winner.count(state)) {\\n        assert(winner[state] == result);\\n        return;\\n    }\\n    winner[state] = result;\\n    if(state.who == MOUSE) {\\n        // CAT moved previously\\n        for(int prev_cat : graph[state.cat]) {\\n            //if(prev_cat == 0) {\\n            //    continue;\\n            //}\\n            State prev_state{prev_cat, state.mouse, CAT};\\n            if(decided(prev_state)) {\\n                continue;\\n            }\\n            if(result == CAT) {\\n                rec(prev_state, CAT);\\n            }\\n            else {\\n                if(++out[prev_state] == cat_degree[prev_cat]) {\\n                    rec(prev_state, MOUSE);\\n                }\\n            }\\n        }\\n    }\\n    else {\\n        // MOUSE moved previously\\n        for(int prev_mouse : graph[state.mouse]) {\\n            State prev_state{state.cat, prev_mouse, MOUSE};\\n            if(decided(prev_state)) {\\n                continue;\\n            }\\n            if(result == MOUSE) {\\n                rec(prev_state, MOUSE);\\n            }\\n            else {\\n                if(++out[prev_state] == (int) graph[prev_mouse].size()) {\\n                    rec(prev_state, CAT);\\n                }\\n            }\\n        }\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    int catMouseGame(vector<vector<int>>& _graph) {\\n        winner.clear();\\n        out.clear();\\n        graph = _graph;\\n        int n = graph.size();\\n        cat_degree = vector<int>(n);\\n        for(int a = 0; a < n; ++a) {\\n            cat_degree[a] = graph[a].size();\\n            for(int b : graph[a]) {\\n                if(b == 0) {\\n                    cat_degree[a]--;\\n                }\\n            }\\n        }\\n        for(int cat = 1; cat < n; cat++) {\\n            for(int who : {0, 1}) {\\n                rec({cat, 0, who}, MOUSE);\\n                rec({cat, cat, who}, CAT);\\n            }\\n        }\\n        State start{2, 1, MOUSE};\\n        if(winner.count(start)) {\\n            if(winner[start] == MOUSE) {\\n                return 1;\\n            }\\n            return 2;\\n        }\\n        return 0;\\n    }\\n};\\n\\n/*\\nstate: (cat, mouse, who)\\n\\nmouse = 0 -> win for mouse\\ncat = mouse -> win for cat\\n    \\nif mouse can move to something where mouse wins -> win\\nif all outgoing edges go to mouse winning -> mouse wins\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1132576,
                "title": "bellman-ford-relaxation-simple-clear-code-with-analysis-beats-100-100",
                "content": "The following algorithm is characterized by its simplicity of both underlying idea and implementation. It is based on the technique of relaxation, which is also used in shortest path and maximum flow problems. In particular, the idea is extremely close to Bellman-Ford algorithm. Unlike the potentially incorrect DFS or DP solutions or tedious BFS solutions, here we introduce a conceptually simple alternative approach.\\n\\n## Essential Difficulties\\nThis problem is a combination of graph and sequential game. Two players with perfect information play optimally against each other in finite steps, since the game comes to a draw once a previous state is repeated.\\n\\nFrom the description of draw, it is straightforward to extract the definition of a state:\\n1. cat\\'s position\\n2. mouse\\'s position\\n3. whether cat or mouse moves next\\n\\nThey\\'re reminiscent of dynamic programming.\\nLet\\'s denote the result of the game by a function `game(next mover, i, j)`, where `i` is cat\\'s position, `j` is mouse\\'s position, and `next mover` can either be cat or mouse. For example, the value `game(mouse, 3, 4)` is the final result of game when cat is at node 3, mouse is at node 4, and mouse moves next. The result can be `CAT` (cat wins), `MOUSE` (mouse wins) or `DRAW`.\\n\\nIt is straightforward to obtain a recursive definition\\n```\\ngame(cat, i, j) =\\n\\t2 if there exists v that game(mouse, v, j) == 2,\\n\\t0 if there exists v that game(mouse, v, j) == 0, but no v that game(mouse, v, j) == 2,\\n\\t1 otherwise.\\n```\\nwhere `v` is one of the adjacent nodes to `i`. It\\'s symmetric for mouse.\\n\\nThe problem seems to have optimal substructures and overlapping problems, which are desirable properties. Some other solutions even ignore overlapping problems and perform a recursive DFS, hoping that the algorithm would sooner or later terminate.\\n\\n### Why DFS and DP solutions are incorrect\\n\\nSome DFS and DP solutions don\\'t notice that the subproblems may be \"interwined.\" That is, they\\'re not independent. From the definition above, `game(cat, i, j)` relies on `game(mouse, v, j)` where `v` is adjacent to `i`. In turn, `game(mouse, v, j)` might also be dependent on `game(cat, v, u)` where `u` is adjacent to `j`, which may be dependent on `game(mouse, i, u)` and eventually dependent on `game(cat, i, j)` itself!\\n\\nOthers try to circumvent this problem by marking the initial state before solving other subproblems to break the loop. However, it\\'s actually solving a completely different subproblem as the available state set shrinks. (See the following section *Naive try to fix DP*.)\\n\\nThe difficulty is that there may be such circular dependency, because in such an undirected graph where adjacency is commutative, the subproblems are not independent. Solving one of the subproblems will require solving another, which in turn requires solving the initial problem.\\n\\n## Intuition\\n\\nIf the subproblems depend on each others, how would it be possible to solve them? After all, we\\'re now in an endless loop to evaluate the result `game(cat/mouse, i, j)`.\\n\\n### Naive try to fix DP\\n\\nIt is feasible to define another state to avoid this problem. We\\'re not allowed to reach a previous state for a second time, so why not add another parameter indicating the available states at present (or equivalently, previously visited states)? Thus the subproblem can be defined as `game(cat/mouse, i, j, set of available states)`.\\n\\nUnfortunately, the single modification would raise the number of states to a prohibitively large scale. In the original problem, denote the set (and its cardinality) of nodes by `V` and edges by `E`, then there\\'re `V * V * 2` states in total (though not all of them are legal, as cat can\\'t reach the hole and mouse need not take further move from the hole). After including the additional parameter, there\\'re `2^(V^2 * 2)` possible combinations, at most `2^5000` in our problem.\\n\\n### BFS: back to the recursive formula\\n\\nObserve that the condition in our recursive definition is *greedy*: sometimes we can determine the result of a subproblem even if we only know for sure part of its dependent subproblems\\u2014namely, if there **exists** a `v` that satisfies `game(mouse, v, j) == 2` \\u2014we can say `game(cat, i, j) = 2` (symmetric for mouse).\\n\\nThis is why we can still solve some of the subproblems even in light of the existence of interdependency. Note that we have certain states in which we already know the result, namely\\n- Mouse wins: `game(cat, i, 0), i != 0`, in which mouse has just reached the hole while the cat is elsewhere\\n- Cat wins: `game(cat/mouse, i, i), i != 0`, in which mouse and cat meet outside the hole and thus mouse is caught\\n\\nSo from the known states, we\\'re able to obtain **some** of the results to other subproblems, which might include our goal `game(mouse, 2, 1)`. In case we fail to determine the value, we consider it to be a `DRAW`\\u2014none of the players can achieve a better result than a draw. Unless the opponent can force a win, a player can always choose the \"safe\" state until a draw.\\n\\nOur idea should be clear now: from the known states, we try our best to infer the result of other subproblems (sub-games). If we\\'re able to determine the result of `game(mouse, 2, 1)`, then everything goes well. If not, there will be a tie.\\n\\nBFS can accomplish this task well. We put those initial states into a queue, examine the consequent possible changes to results of other subproblems, and add the triggered subproblems into the queue. To track the states of adjencent nodes, we need to maintain a table to record the number of subproblems \"colored\" by a certain result.\\n\\n## Bellman-Ford Relaxation\\n\\nBut why bothering with the cumbersomeness of maintaining such a table? Code should convey the programmer\\'s idea clearly and succinctly, and in many situations code simplicity outweighs efficiency. BFS is great, but it is an overkill for the problem.\\n\\nLet\\'s think of this problem in a more straightforward way. We want to expand the set of decidable subproblems as much as possible. To see whether there is any other subproblem that can be determined but yet to be discovered, we simply examine the entire set of states. If we don\\'t find any decidable subproblems besides the known ones, we say the set has converged and thus the algorithm terminates. If any subproblem is newly determined (i.e., relaxed), then we\\'ll scan all states again in the next round.\\n\\nThis procedure is ensured to terminate after `O(V^2)` iterations. The proof is similar to Bellman-Ford algorithm. Any shortest path is simple, which implies there can\\'t be duplicate vertices on the shortest path. There can be at most `V` vertices on a shortest path, so if each scan increments the path by one, we need `|V| - 1` iterations in the worst case.\\n\\nLikewise, we expand our decidable state set by at least one per iteration. Once a state (or the corresponding game) is determined, i.e. converted from `DRAW` state to some other one, it cannot be reverted. Therefore, we need `V^2 * 2` iterations at most.\\n\\n### Running time analysis\\n\\nEach iteration examines every state once in the entire set as well as its adjacent states. Each edge is examined for `O(V)` times (there\\'re `O(V)` incident states for an edge), therefore the computing time is `O(V^2 + VE)` in total. Assuming the graph is connected (`V = O(E)`), the time complexity is `O(VE)` per iteration.\\n\\nSumming up the running times of iterations gives the total time `O(V^3 * E)`.\\n\\n### Implementation in Java\\n```java\\nclass Solution {    \\n    /**\\n     * Definition of state[k][i][j]\\n     * k: 0 for cat first, 1 for mouse first\\n     * i: cat position\\n     * j: mouse position\\n     */\\n    public int catMouseGame(int[][] graph) {\\n        int n = graph.length;\\n        State[][][] state = new State[2][n][n];\\n        Arrays.fill(state[0][0], State.ILLEGAL);\\n        Arrays.fill(state[1][0], State.ILLEGAL);\\n        for (int i = 1; i < n; i++) {\\n            state[0][i][0] = State.MOUSE;\\n            state[1][i][0] = State.ILLEGAL;\\n            for (int j = 1; j < n; j++) {\\n                state[0][i][j] = j == i ? State.CAT : State.DRAW;\\n                state[1][i][j] = j == i ? State.CAT : State.DRAW;\\n            }\\n        }\\n\\n        while (true) {\\n            boolean isChanged = false;\\n            for (int i = 1; i < n; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    for (int k = 0; k < 2; k++) {\\n                        if (state[k][i][j] != State.DRAW) {\\n                            continue;\\n                        }\\n                        int record = 0;\\n                        if (k == 0) {\\n                            for (int u : graph[i]) {\\n                                record = state[1 - k][u][j].set(record);\\n                            }\\n                        } else {\\n                            for (int v : graph[j]) {\\n                                record = state[1 - k][i][v].set(record);\\n                            }\\n                        }\\n                        \\n                        State newState = State.of(record, k == 0);\\n                        if (newState != state[k][i][j]) {\\n                            isChanged = true;\\n                        }\\n                        state[k][i][j] = newState;\\n                    }\\n                }\\n            }\\n            // Terminate if the target state is determined or no state ever changed\\n            if (state[1][2][1] != State.DRAW || !isChanged) {\\n                return state[1][2][1].getCode();\\n            }\\n        }\\n    }\\n    \\n    enum State {\\n        DRAW(0),\\n        MOUSE(1),\\n        CAT(2),\\n        ILLEGAL(3);\\n        \\n        private final int code;\\n        State(int code) { this.code = code; }\\n        public int getCode() { return this.code; }\\n        \\n        // Test whether a state occurs by checking corresponding bit\\n        public boolean test(int record) {\\n            return (record & (1 << this.code)) != 0;\\n        }\\n        \\n        // Set the corresponding bit if the state occurs\\n        public int set(int record) {\\n            return record | (1 << this.code);\\n        }\\n        \\n        // Return appropriate state by the adjacent states and the next mover\\n        public static State of(int record, boolean isCat) {\\n            if (isCat) {\\n                return CAT.test(record) ? CAT : (DRAW.test(record) ? DRAW : MOUSE);\\n            } else {\\n                return MOUSE.test(record) ? MOUSE : (DRAW.test(record) ? DRAW : CAT);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ngame(cat, i, j) =\\n\\t2 if there exists v that game(mouse, v, j) == 2,\\n\\t0 if there exists v that game(mouse, v, j) == 0, but no v that game(mouse, v, j) == 2,\\n\\t1 otherwise.\\n```\n```java\\nclass Solution {    \\n    /**\\n     * Definition of state[k][i][j]\\n     * k: 0 for cat first, 1 for mouse first\\n     * i: cat position\\n     * j: mouse position\\n     */\\n    public int catMouseGame(int[][] graph) {\\n        int n = graph.length;\\n        State[][][] state = new State[2][n][n];\\n        Arrays.fill(state[0][0], State.ILLEGAL);\\n        Arrays.fill(state[1][0], State.ILLEGAL);\\n        for (int i = 1; i < n; i++) {\\n            state[0][i][0] = State.MOUSE;\\n            state[1][i][0] = State.ILLEGAL;\\n            for (int j = 1; j < n; j++) {\\n                state[0][i][j] = j == i ? State.CAT : State.DRAW;\\n                state[1][i][j] = j == i ? State.CAT : State.DRAW;\\n            }\\n        }\\n\\n        while (true) {\\n            boolean isChanged = false;\\n            for (int i = 1; i < n; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    for (int k = 0; k < 2; k++) {\\n                        if (state[k][i][j] != State.DRAW) {\\n                            continue;\\n                        }\\n                        int record = 0;\\n                        if (k == 0) {\\n                            for (int u : graph[i]) {\\n                                record = state[1 - k][u][j].set(record);\\n                            }\\n                        } else {\\n                            for (int v : graph[j]) {\\n                                record = state[1 - k][i][v].set(record);\\n                            }\\n                        }\\n                        \\n                        State newState = State.of(record, k == 0);\\n                        if (newState != state[k][i][j]) {\\n                            isChanged = true;\\n                        }\\n                        state[k][i][j] = newState;\\n                    }\\n                }\\n            }\\n            // Terminate if the target state is determined or no state ever changed\\n            if (state[1][2][1] != State.DRAW || !isChanged) {\\n                return state[1][2][1].getCode();\\n            }\\n        }\\n    }\\n    \\n    enum State {\\n        DRAW(0),\\n        MOUSE(1),\\n        CAT(2),\\n        ILLEGAL(3);\\n        \\n        private final int code;\\n        State(int code) { this.code = code; }\\n        public int getCode() { return this.code; }\\n        \\n        // Test whether a state occurs by checking corresponding bit\\n        public boolean test(int record) {\\n            return (record & (1 << this.code)) != 0;\\n        }\\n        \\n        // Set the corresponding bit if the state occurs\\n        public int set(int record) {\\n            return record | (1 << this.code);\\n        }\\n        \\n        // Return appropriate state by the adjacent states and the next mover\\n        public static State of(int record, boolean isCat) {\\n            if (isCat) {\\n                return CAT.test(record) ? CAT : (DRAW.test(record) ? DRAW : MOUSE);\\n            } else {\\n                return MOUSE.test(record) ? MOUSE : (DRAW.test(record) ? DRAW : CAT);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 377549,
                "title": "java-dfs",
                "content": "```\\nclass Solution \\n{\\n    public int catMouseGame(int[][] graph) \\n    {\\n        int n = graph.length;\\n        int[][][] f = new int[n + n][n][n];\\n        fill(f, -1);\\n        \\n        return find(graph, f, 0, 1, 2);\\n    }\\n    \\n    int find(int[][] graph, int[][][] f, int t, int x /* mouse */, int y /* cat */)\\n    {\\n        if (t == graph.length * 2) return 0; // draw\\n        if (x == 0) return 1; // mouse wins\\n        if (x == y) return 2; // cat wins\\n        if (f[t][x][y] != -1) return f[t][x][y];\\n        \\n        if (t % 2 == 0)\\n        {\\n            // mouse moves\\n            // for the next position that mouse gonna move to,\\n            // if all possibilities lead to cat-win, then it is\\n            // surely the cat will win. \\n            // otherwise, if any 1 possibility leads to mouse-win,\\n            // the mouse should move to that position and then the \\n            // mouse will win. \\n            // otherwise, it is a draw.\\n            boolean cat_win = true;\\n            for (int next : graph[x])\\n            {\\n                int r = find(graph, f, t + 1, next, y);\\n                if (r == 1)\\n                {\\n                    return f[t][x][y] = 1;\\n                }\\n                if (r == 0)\\n                {\\n                    cat_win = false;\\n                }\\n            }\\n            if (cat_win) return f[t][x][y] = 2;\\n            else return f[t][x][y] = 0;\\n        }\\n        else\\n        {\\n            // cat moves\\n            // the analysis is similar as above.\\n            boolean mouse_win = true;\\n            for (int next : graph[y])\\n            {\\n                if (next == 0) continue; // cat cannot go to hole\\n                int r = find(graph, f, t + 1, x, next);\\n                if (r == 2)\\n                {\\n                    return f[t][x][y] = 2;\\n                }\\n                if (r == 0)\\n                {\\n                    mouse_win = false;\\n                }\\n            }\\n            if (mouse_win) return f[t][x][y] = 1;\\n            else return f[t][x][y] = 0;\\n        }\\n    }\\n    \\n    void fill(int[][][] f, int val)\\n    {\\n        for (int i = 0; i < f.length; ++i)\\n        {\\n            for (int j = 0; j < f[i].length; ++j)\\n            {\\n                Arrays.fill(f[i][j], val);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public int catMouseGame(int[][] graph) \\n    {\\n        int n = graph.length;\\n        int[][][] f = new int[n + n][n][n];\\n        fill(f, -1);\\n        \\n        return find(graph, f, 0, 1, 2);\\n    }\\n    \\n    int find(int[][] graph, int[][][] f, int t, int x /* mouse */, int y /* cat */)\\n    {\\n        if (t == graph.length * 2) return 0; // draw\\n        if (x == 0) return 1; // mouse wins\\n        if (x == y) return 2; // cat wins\\n        if (f[t][x][y] != -1) return f[t][x][y];\\n        \\n        if (t % 2 == 0)\\n        {\\n            // mouse moves\\n            // for the next position that mouse gonna move to,\\n            // if all possibilities lead to cat-win, then it is\\n            // surely the cat will win. \\n            // otherwise, if any 1 possibility leads to mouse-win,\\n            // the mouse should move to that position and then the \\n            // mouse will win. \\n            // otherwise, it is a draw.\\n            boolean cat_win = true;\\n            for (int next : graph[x])\\n            {\\n                int r = find(graph, f, t + 1, next, y);\\n                if (r == 1)\\n                {\\n                    return f[t][x][y] = 1;\\n                }\\n                if (r == 0)\\n                {\\n                    cat_win = false;\\n                }\\n            }\\n            if (cat_win) return f[t][x][y] = 2;\\n            else return f[t][x][y] = 0;\\n        }\\n        else\\n        {\\n            // cat moves\\n            // the analysis is similar as above.\\n            boolean mouse_win = true;\\n            for (int next : graph[y])\\n            {\\n                if (next == 0) continue; // cat cannot go to hole\\n                int r = find(graph, f, t + 1, x, next);\\n                if (r == 2)\\n                {\\n                    return f[t][x][y] = 2;\\n                }\\n                if (r == 0)\\n                {\\n                    mouse_win = false;\\n                }\\n            }\\n            if (mouse_win) return f[t][x][y] = 1;\\n            else return f[t][x][y] = 0;\\n        }\\n    }\\n    \\n    void fill(int[][][] f, int val)\\n    {\\n        for (int i = 0; i < f.length; ++i)\\n        {\\n            for (int j = 0; j < f[i].length; ++j)\\n            {\\n                Arrays.fill(f[i][j], val);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 450609,
                "title": "short-correct-and-easy-to-understand-python-translated-from-c-java-solution",
                "content": "In case you are looking for short python solution. Here is a translated one from a java solution.\\nThe explanation and original java code can be found here.\\nhttps://leetcode.com/problems/cat-and-mouse/discuss/298937/DP-memory-status-search-search-strait-forward-and-easy-to-understand\\n\\n\\nModify the code based on @aaardvark commet to make it more concise.\\n```python\\nfrom functools import lru_cache\\nclass Solution:\\n    def catMouseGame(self, graph: List[List[int]]) -> int:\\n        @lru_cache(None)\\n        def search(t, x, y):\\n            if t == len(graph) * 2: return 0\\n            if x == y: return 2\\n            if x == 0:return 1\\n            if (t%2==0):# mouse\\'s turn. Mouse will win if the mouse can find any winable node for the next step. If all the next step is winable for cats, then mouse lose.\\n                if any(search(t+1, x_nxt, y)==1 for x_nxt in graph[x]):return 1\\n                if all(search(t+1, x_nxt, y)==2 for x_nxt in graph[x]):return 2\\n                return 0\\n            else:# cat\\'s turn\\n                if any(search(t+1, x, y_nxt)==2 for y_nxt in graph[y] if y_nxt!=0):return 2\\n                if all(search(t+1, x, y_nxt)==1 for y_nxt in graph[y] if y_nxt!=0):return 1\\n                return 0\\n        return search(0, 1, 2)\\n```\\nThanks.",
                "solutionTags": [],
                "code": "```python\\nfrom functools import lru_cache\\nclass Solution:\\n    def catMouseGame(self, graph: List[List[int]]) -> int:\\n        @lru_cache(None)\\n        def search(t, x, y):\\n            if t == len(graph) * 2: return 0\\n            if x == y: return 2\\n            if x == 0:return 1\\n            if (t%2==0):# mouse\\'s turn. Mouse will win if the mouse can find any winable node for the next step. If all the next step is winable for cats, then mouse lose.\\n                if any(search(t+1, x_nxt, y)==1 for x_nxt in graph[x]):return 1\\n                if all(search(t+1, x_nxt, y)==2 for x_nxt in graph[x]):return 2\\n                return 0\\n            else:# cat\\'s turn\\n                if any(search(t+1, x, y_nxt)==2 for y_nxt in graph[y] if y_nxt!=0):return 2\\n                if all(search(t+1, x, y_nxt)==1 for y_nxt in graph[y] if y_nxt!=0):return 1\\n                return 0\\n        return search(0, 1, 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 465791,
                "title": "many-people-don-t-really-understand-dfs-well-like-this-question",
                "content": "Not only for this question, any quesiton if you are using DFS in this manner:\\n``` result of A depends on all results of A\\'s neighbors, so we firstly check A\\'s all neighbor\\'s results, and then conclude A\\'s result based on all A\\'s neighbors\\' result.```\\n\\nThen you are wrong because this can possibly introduce mutual dependence.\\nsolution of this is\\n1. search reversely from all nodes which have defined result, and flood back to nodes you need to figure the result.\\n2. give extra marking to A, when from A to check all its neighbors, mark A as ```pending``` or whatever you like, but not from the result set.\\n\\n",
                "solutionTags": [],
                "code": "``` result of A depends on all results of A\\'s neighbors, so we firstly check A\\'s all neighbor\\'s results, and then conclude A\\'s result based on all A\\'s neighbors\\' result.```\n```pending```",
                "codeTag": "Unknown"
            },
            {
                "id": 750715,
                "title": "java-dfs-dp-minimax-straightforward-solution",
                "content": "Let\\'s say that if mouse succeeds we return 1.\\nIf cat succeds we return -1.\\nIf we have draw, then 0.\\n\\nSo we can apply this knowledge to minimax approach.\\nIf it\\'s mouse turn -> we\\'re trying to maximize, otherwise we\\'re trying to minimize.\\nSmall trick is that we return 0, when number of turns == graph.length * 2, since we have graph.length positions and each position visited twice (by cat or mouse).\\n\\n```\\npublic int catMouseGame(int[][] graph) {\\n\\tint n = graph.length;\\n\\tint res = helper(graph, 2, 1, 0, new Integer[n][n][n * 2]);\\n\\treturn res == -1 ? 2 : res;\\n}\\n\\nprivate int helper(int[][] graph, int cat, int mouse, int turn, Integer[][][] dp) {\\n\\tif (cat == mouse) return -1;\\n\\tif (mouse == 0) return 1;\\n\\tif (turn == graph.length * 2) return 0;\\n\\n\\tif (dp[cat][mouse][turn] != null) return dp[cat][mouse][turn];\\n\\tint res = turn % 2 == 0 ? -1 : 1;\\n\\tif (turn % 2 == 0) {\\n\\t\\tfor(int i = 0; i < graph[mouse].length; i++) {\\n\\t\\t    // mouse is trying to maximize\\n\\t\\t\\tres = Math.max(helper(graph, cat, graph[mouse][i], turn + 1, dp), res);\\n\\t\\t}\\n\\t} else {\\n\\t\\tfor(int i = 0; i < graph[cat].length; i++) {\\n\\t\\t\\tif (graph[cat][i] == 0) continue;\\n\\t\\t\\t// cat is trying to minimize\\n\\t\\t\\tres = Math.min(helper(graph, graph[cat][i], mouse, turn + 1, dp), res);\\n\\t\\t}\\n\\t}\\n\\tdp[cat][mouse][turn] = res;\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int catMouseGame(int[][] graph) {\\n\\tint n = graph.length;\\n\\tint res = helper(graph, 2, 1, 0, new Integer[n][n][n * 2]);\\n\\treturn res == -1 ? 2 : res;\\n}\\n\\nprivate int helper(int[][] graph, int cat, int mouse, int turn, Integer[][][] dp) {\\n\\tif (cat == mouse) return -1;\\n\\tif (mouse == 0) return 1;\\n\\tif (turn == graph.length * 2) return 0;\\n\\n\\tif (dp[cat][mouse][turn] != null) return dp[cat][mouse][turn];\\n\\tint res = turn % 2 == 0 ? -1 : 1;\\n\\tif (turn % 2 == 0) {\\n\\t\\tfor(int i = 0; i < graph[mouse].length; i++) {\\n\\t\\t    // mouse is trying to maximize\\n\\t\\t\\tres = Math.max(helper(graph, cat, graph[mouse][i], turn + 1, dp), res);\\n\\t\\t}\\n\\t} else {\\n\\t\\tfor(int i = 0; i < graph[cat].length; i++) {\\n\\t\\t\\tif (graph[cat][i] == 0) continue;\\n\\t\\t\\t// cat is trying to minimize\\n\\t\\t\\tres = Math.min(helper(graph, graph[cat][i], mouse, turn + 1, dp), res);\\n\\t\\t}\\n\\t}\\n\\tdp[cat][mouse][turn] = res;\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 222837,
                "title": "c-12ms-perfect-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int m_turn=0,c_turn=1,M_win=1,C_win=2,draw=0;\\n    struct Q{\\n          int m;\\n          int c;\\n          int turn;\\n          int res;\\n    };\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        int n=graph.size();\\n        vector<vector<vector<int>>>dp(n,vector<vector<int>>(n,vector<int>(2,0)));\\n         vector<vector<vector<int>>>child(n,vector<vector<int>>(n,vector<int>(2,0)));\\n         for(int m=0;m<n;m++)\\n         {\\n             for(int c=0;c<n;c++)\\n             {\\n                  child[m][c][m_turn]=graph[m].size();  //number of possible next positions for mouse\\n                  child[m][c][c_turn]=graph[c].size();    //number of possible next positions for cat\\n                  for(auto &i : graph[c])\\n                  {\\n                      if(i==0)\\n                      {\\n                          child[m][c][c_turn]--;       // cat will not able to fit inside the hole hence obviously can\\'t risk her life and will not go to the hole\\n                          break;\\n                      }   \\n                  }\\n             }\\n         }\\n        // push all the nodes that will definately win\\n        queue<Q>q;\\n        for(int c=0;c<n;c++)\\n        {\\n            for(int turn=0;turn<=1;turn++)\\n            {\\n                dp[0][c][turn]=M_win;  // see mouse want to the hole he will win this time poor hungry cat\\n                q.push({0,c,turn,M_win}); \\n                if(c)     // if not hole \\n                {\\n                    dp[c][c][turn]=C_win;  // cat caught the mouse yipee !!\\n                    q.push({c,c,turn,C_win});\\n                }\\n            }\\n        }\\n        while(!q.empty())\\n        {\\n            auto &p=q.front();\\n            q.pop();\\n            if(p.m==1 && p.c==2 && p.turn==0)  //we have the result \\n                return p.res;\\n            int pre_turn=1-p.turn;    //previous turn = 1- cur_turn\\n            for(auto &prev : graph[pre_turn==0?p.m:p.c])\\n            {\\n\\t\\t\\t     // we know the result of cur state let\\'s find the result for prev turn\\n                  int pre_m=pre_turn==0?prev:p.m;   //prev mouse position \\n                  int pre_c=pre_turn==1?prev:p.c;     // prev cat position\\n                  if(!pre_c) continue;  //cat can\\'t be in the hole\\n                  if(!dp[pre_m][pre_c][pre_turn])  //don\\'t know who wins in prev turn let\\'s find it out\\n                  {\\n                      if((p.res==1 && pre_turn==0) || (p.res==2 && pre_turn==1))  //whoever has prev_turn will wins\\n                      {\\n                          dp[pre_m][pre_c][pre_turn]=p.res;\\n                          q.push({pre_m,pre_c,pre_turn,p.res});\\n                      }\\n                      else        //whoever has prev_turn will lose\\n                      {\\n                          //this child can\\'t let help us win delete him\\n                          child[pre_m][pre_c][pre_turn]--;\\n                          if(!child[pre_m][pre_c][pre_turn])   // no child can help us to win\\n                          {\\n                              //whoever has prev turn defeat guaranteed for him/her \\n                              int result=pre_turn==0 ? 2 : 1;\\n                              dp[pre_m][pre_c][pre_turn]=result;   //store the result for prev turn\\n                              q.push({pre_m,pre_c,pre_turn,result});\\n                          }\\n                      }\\n                  }\\n            }\\n        }\\n        return dp[1][2][0];   // return result\\n    }\\n};\\n\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int m_turn=0,c_turn=1,M_win=1,C_win=2,draw=0;\\n    struct Q{\\n          int m;\\n          int c;\\n          int turn;\\n          int res;\\n    };\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        int n=graph.size();\\n        vector<vector<vector<int>>>dp(n,vector<vector<int>>(n,vector<int>(2,0)));\\n         vector<vector<vector<int>>>child(n,vector<vector<int>>(n,vector<int>(2,0)));\\n         for(int m=0;m<n;m++)\\n         {\\n             for(int c=0;c<n;c++)\\n             {\\n                  child[m][c][m_turn]=graph[m].size();  //number of possible next positions for mouse\\n                  child[m][c][c_turn]=graph[c].size();    //number of possible next positions for cat\\n                  for(auto &i : graph[c])\\n                  {\\n                      if(i==0)\\n                      {\\n                          child[m][c][c_turn]--;       // cat will not able to fit inside the hole hence obviously can\\'t risk her life and will not go to the hole\\n                          break;\\n                      }   \\n                  }\\n             }\\n         }\\n        // push all the nodes that will definately win\\n        queue<Q>q;\\n        for(int c=0;c<n;c++)\\n        {\\n            for(int turn=0;turn<=1;turn++)\\n            {\\n                dp[0][c][turn]=M_win;  // see mouse want to the hole he will win this time poor hungry cat\\n                q.push({0,c,turn,M_win}); \\n                if(c)     // if not hole \\n                {\\n                    dp[c][c][turn]=C_win;  // cat caught the mouse yipee !!\\n                    q.push({c,c,turn,C_win});\\n                }\\n            }\\n        }\\n        while(!q.empty())\\n        {\\n            auto &p=q.front();\\n            q.pop();\\n            if(p.m==1 && p.c==2 && p.turn==0)  //we have the result \\n                return p.res;\\n            int pre_turn=1-p.turn;    //previous turn = 1- cur_turn\\n            for(auto &prev : graph[pre_turn==0?p.m:p.c])\\n            {\\n\\t\\t\\t     // we know the result of cur state let\\'s find the result for prev turn\\n                  int pre_m=pre_turn==0?prev:p.m;   //prev mouse position \\n                  int pre_c=pre_turn==1?prev:p.c;     // prev cat position\\n                  if(!pre_c) continue;  //cat can\\'t be in the hole\\n                  if(!dp[pre_m][pre_c][pre_turn])  //don\\'t know who wins in prev turn let\\'s find it out\\n                  {\\n                      if((p.res==1 && pre_turn==0) || (p.res==2 && pre_turn==1))  //whoever has prev_turn will wins\\n                      {\\n                          dp[pre_m][pre_c][pre_turn]=p.res;\\n                          q.push({pre_m,pre_c,pre_turn,p.res});\\n                      }\\n                      else        //whoever has prev_turn will lose\\n                      {\\n                          //this child can\\'t let help us win delete him\\n                          child[pre_m][pre_c][pre_turn]--;\\n                          if(!child[pre_m][pre_c][pre_turn])   // no child can help us to win\\n                          {\\n                              //whoever has prev turn defeat guaranteed for him/her \\n                              int result=pre_turn==0 ? 2 : 1;\\n                              dp[pre_m][pre_c][pre_turn]=result;   //store the result for prev turn\\n                              q.push({pre_m,pre_c,pre_turn,result});\\n                          }\\n                      }\\n                  }\\n            }\\n        }\\n        return dp[1][2][0];   // return result\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 371528,
                "title": "improved-standard-solution-bfs-early-stop-beats-92",
                "content": "Standard solution only beats 45%. Early stopping boosts the performance.\\n\\n```\\n    def catMouseGame(self, graph: List[List[int]]) -> int:\\n        DRAW, MOUSE, CAT = 0, 1, 2\\n        def gen_parent(mouse, cat, turn):\\n            if turn == MOUSE:\\n                for p in graph[cat]:\\n                    if p != 0:\\n                        yield mouse, p, CAT\\n            else:\\n                for p in graph[mouse]:\\n                    yield p, cat, MOUSE\\n        degree = dict()\\n        for i in range(len(graph)):\\n            for j in range(len(graph)):\\n                degree[i, j, MOUSE] = len(graph[i])\\n                degree[i, j, CAT] = len(graph[j]) - (0 in graph[j])\\n\\n        from collections import defaultdict, deque\\n        color = defaultdict(lambda: DRAW)\\n        queue = deque()\\n        for i in range(len(graph)):\\n            color[0, i, MOUSE] = MOUSE\\n            queue.append((0, i, MOUSE, MOUSE))\\n            color[0, i, CAT] = MOUSE\\n            queue.append((0, i, CAT, MOUSE))\\n            if i != 0:\\n                color[i, i, CAT] = CAT\\n                queue.append((i, i, CAT, CAT))\\n                color[i, i, MOUSE] = CAT\\n                queue.append((i, i, MOUSE, CAT))\\n\\n        while queue:\\n            mouse, cat, turn, c = queue.popleft()\\n            for x, y, t in gen_parent(mouse, cat, turn):\\n                if color[x, y, t] == DRAW:\\n                    if t == c:\\n                        color[x, y, t] = c\\n                        if x == 1 and y == 2 and t == 1: return c\\n                        queue.append((x, y, t, c))\\n                    else:\\n                        degree[x, y, t] -= 1\\n                        if degree[x, y, t] == 0:\\n                            color[x, y, t] = 3 - t\\n                            if x == 1 and y == 2 and t == 1: return c\\n                            queue.append((x, y, t, 3 - t))\\n        return color[1, 2, 1]\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    def catMouseGame(self, graph: List[List[int]]) -> int:\\n        DRAW, MOUSE, CAT = 0, 1, 2\\n        def gen_parent(mouse, cat, turn):\\n            if turn == MOUSE:\\n                for p in graph[cat]:\\n                    if p != 0:\\n                        yield mouse, p, CAT\\n            else:\\n                for p in graph[mouse]:\\n                    yield p, cat, MOUSE\\n        degree = dict()\\n        for i in range(len(graph)):\\n            for j in range(len(graph)):\\n                degree[i, j, MOUSE] = len(graph[i])\\n                degree[i, j, CAT] = len(graph[j]) - (0 in graph[j])\\n\\n        from collections import defaultdict, deque\\n        color = defaultdict(lambda: DRAW)\\n        queue = deque()\\n        for i in range(len(graph)):\\n            color[0, i, MOUSE] = MOUSE\\n            queue.append((0, i, MOUSE, MOUSE))\\n            color[0, i, CAT] = MOUSE\\n            queue.append((0, i, CAT, MOUSE))\\n            if i != 0:\\n                color[i, i, CAT] = CAT\\n                queue.append((i, i, CAT, CAT))\\n                color[i, i, MOUSE] = CAT\\n                queue.append((i, i, MOUSE, CAT))\\n\\n        while queue:\\n            mouse, cat, turn, c = queue.popleft()\\n            for x, y, t in gen_parent(mouse, cat, turn):\\n                if color[x, y, t] == DRAW:\\n                    if t == c:\\n                        color[x, y, t] = c\\n                        if x == 1 and y == 2 and t == 1: return c\\n                        queue.append((x, y, t, c))\\n                    else:\\n                        degree[x, y, t] -= 1\\n                        if degree[x, y, t] == 0:\\n                            color[x, y, t] = 3 - t\\n                            if x == 1 and y == 2 and t == 1: return c\\n                            queue.append((x, y, t, 3 - t))\\n        return color[1, 2, 1]\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 176038,
                "title": "so-confusing-the-last-case-can-t-believe-it",
                "content": "The code below can pass 43 test cases, and if I uncomment the line `for(int i = 0;i<graph[c].size();i++) if(graph[c][i]==m) {memo[m][c][turn]=2;return 2;}` it could pass all test cases. I think this is very confusing since this line shouldn\\'t matter too much. Can someone help explain why?\\n```\\nclass Solution {\\npublic:\\n    \\n    int helper(vector<vector<int>>& graph,vector<vector<vector<int>>>& memo,int m,int c,int turn){\\n        if(m==c) return 2;\\n        if(m==0) return 1;\\n        if(memo[m][c][turn]!=-1) return memo[m][c][turn];\\n        memo[m][c][turn]=0;\\n        if(turn==0){\\n            bool canDraw=false;\\n            for(int i = 0;i<graph[m].size();i++){\\n                int res = helper(graph,memo,graph[m][i],c,1);\\n                if(res==1) {memo[m][c][turn]=1;return 1;}\\n                if(res==0) canDraw=true;\\n            }\\n            if(canDraw) return 0;\\n            else {memo[m][c][turn]=2;return 2;}\\n        }\\n        else{\\n//            for(int i = 0;i<graph[c].size();i++) if(graph[c][i]==m && graph[c][i]!=0) {memo[m][c][turn]=2;return 2;}\\n            bool canDraw=false;\\n            for(int i = 0;i<graph[c].size();i++){\\n                if(graph[c][i]==m) {memo[m][c][turn]=2;return 2;}\\n                if(graph[c][i]!=0){\\n                    if(graph[c][i]==m) {memo[m][c][turn]=2;return 2;}\\n                    int res = helper(graph,memo,m,graph[c][i],0);\\n                    if(res==2) {memo[m][c][turn]=2;return 2;}\\n                    if(res==0) canDraw=true;  \\n                }\\n            }\\n            if(canDraw) return 0;\\n            else {memo[m][c][turn]=1;return 1;}\\n        }\\n        \\n    }\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        int count = 0;\\n        vector<vector<vector<int>>> memo(n,vector<vector<int>>(n,vector<int>(2,-1)));\\n        int res = helper(graph,memo,1,2,0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int helper(vector<vector<int>>& graph,vector<vector<vector<int>>>& memo,int m,int c,int turn){\\n        if(m==c) return 2;\\n        if(m==0) return 1;\\n        if(memo[m][c][turn]!=-1) return memo[m][c][turn];\\n        memo[m][c][turn]=0;\\n        if(turn==0){\\n            bool canDraw=false;\\n            for(int i = 0;i<graph[m].size();i++){\\n                int res = helper(graph,memo,graph[m][i],c,1);\\n                if(res==1) {memo[m][c][turn]=1;return 1;}\\n                if(res==0) canDraw=true;\\n            }\\n            if(canDraw) return 0;\\n            else {memo[m][c][turn]=2;return 2;}\\n        }\\n        else{\\n//            for(int i = 0;i<graph[c].size();i++) if(graph[c][i]==m && graph[c][i]!=0) {memo[m][c][turn]=2;return 2;}\\n            bool canDraw=false;\\n            for(int i = 0;i<graph[c].size();i++){\\n                if(graph[c][i]==m) {memo[m][c][turn]=2;return 2;}\\n                if(graph[c][i]!=0){\\n                    if(graph[c][i]==m) {memo[m][c][turn]=2;return 2;}\\n                    int res = helper(graph,memo,m,graph[c][i],0);\\n                    if(res==2) {memo[m][c][turn]=2;return 2;}\\n                    if(res==0) canDraw=true;  \\n                }\\n            }\\n            if(canDraw) return 0;\\n            else {memo[m][c][turn]=1;return 1;}\\n        }\\n        \\n    }\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        int count = 0;\\n        vector<vector<vector<int>>> memo(n,vector<vector<int>>(n,vector<int>(2,-1)));\\n        int res = helper(graph,memo,1,2,0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2339958,
                "title": "python-solution-practically-the-official-bfs-solution-but-a-little-more-approachable-i-think",
                "content": "I learned a lot from this problem. It\\'s more like learning how to code game theory problems than preparing for interviews. Overall this problem is very troublesome to troubleshoot as I found it already hard to visualize how would the mouse and cat move on the graph!\\n\\nI think the official solution code and thoughts are both elegant. I just dislike its phrasing for being too technical. If you are a novice like me who is unfamiliar with game theory, you\\'ll probably get really annoyed by that \"proof of correctness\". I hope my writing can help understand the algorithm better.\\n\\nThe main difference I made to the code is I skipped that parent function and directly asks for neighbours from the graph (I don\\'t really like to use yield here). Also I used array instead of dictionary to avoid calling on nonexistent keys\\n\\n```\\nclass Solution:\\n    # Complicated problem which requires understanding of game theory\\n    # Ridiculous if you are expected to solve it in an interview\\n    # First key idea:\\n    # We soon see that we need 3 variables to describe the states:\\n    # (m, c, t)\\n    # m = mouse\\'s position (0:N-1)\\n    # c = cat\\'s position (0:N-1)\\n    # t = whose turn (1: mouse; 2: cat)\\n    # We know the final state of game:\\n    # (i, i, t) = 2\\n    # (0, i, t) = 1\\n    # All else we need to find out\\n    # The second key point is we can BFS in the reverse direction\\n    # As we have well-defined final state, we can breadth-first search into its parents\\n    # We actually know well about which state can lead to the current state\\n    # For example if graph = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]\\n    # we know (0, i, 2) = 1. we then know from the graph,\\n    # (2, i, 1) = 1, (5, i, 1) = 1, because it\\'s the mouse\\'s turn and it is going to pick the winning move. \\n\\t# We can label these nodes and put into the queue to further BFS\\n    # On the other hand, we also know (2,2,2) = 2. We then know that at (4,2,1), the mouse would never visit 2 because it will get caught. \\n\\t# It might visit (3,2,2) instead to avoid getting caught\\n    # To account for that game strategy, we record the outgoing degree for all states for both mouse and cat. \\n\\t# Each time we arrive at scenario in which a parent has a losing child, we decrease the degree of that state by 1. \\n\\t# If the outgoing degree becomes 0, it means a mouse / cat getting into this state must lose (all paths outward leads to loss)\\n    # When the BFS is finished we just return the win state of mouse\\n    \\n    def catMouseGame(self, graph: List[List[int]]) -> int:\\n        n = len(graph)\\n\\n        degree = [[[0 for k in range(3)] for j in range(n)] for i in range(n)]\\n        for i in range(n):\\n            for j in range(n):\\n                degree[i][j][1] += len(graph[i])\\n                degree[i][j][2] += len(graph[j])\\n                if 0 in graph[j]:\\n                    degree[i][j][2] -= 1 # cat cannot go to the hole 0!\\n        # Push the winning state into the queue, and look for their parents\\n        dq = deque()\\n        win = [[[0 for k in range(3)] for j in range(n)] for i in range(n)]\\n        for i in range(1, n):\\n            for k in range(1,3):\\n                win[0][i][k] = 1\\n                dq.append([0,i,k,1])\\n                win[i][i][k] = 2\\n                dq.append([i,i,k,2])\\n\\n        while dq:\\n            m, c, t, w = dq.popleft()\\n            parents = []\\n            if t == 1:\\n                for parent in graph[c]:\\n                    if parent != 0:\\n                        parents.append([m, parent, 2]) # cat cannot come from the hole 0!\\n            else:\\n                for parent in graph[m]:\\n                    parents.append([parent, c, 1])\\n            for mp, cp, tp in parents:\\n                # we are only interested in dealing with the potential draws\\n                if win[mp][cp][tp] == 0:\\n                    # it\\'s mouse turn and mouse would win if it makes the move; same for cat\\n                    if tp == w: \\n                        win[mp][cp][tp] = w\\n                        dq.append([mp, cp, tp, w])\\n                    else:\\n                        degree[mp][cp][tp] -= 1\\n                        if degree[mp][cp][tp] == 0:\\n                            win[mp][cp][tp] = w\\n                            dq.append([mp, cp, tp, w])\\n        #print(win)\\n        return win[1][2][1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # Complicated problem which requires understanding of game theory\\n    # Ridiculous if you are expected to solve it in an interview\\n    # First key idea:\\n    # We soon see that we need 3 variables to describe the states:\\n    # (m, c, t)\\n    # m = mouse\\'s position (0:N-1)\\n    # c = cat\\'s position (0:N-1)\\n    # t = whose turn (1: mouse; 2: cat)\\n    # We know the final state of game:\\n    # (i, i, t) = 2\\n    # (0, i, t) = 1\\n    # All else we need to find out\\n    # The second key point is we can BFS in the reverse direction\\n    # As we have well-defined final state, we can breadth-first search into its parents\\n    # We actually know well about which state can lead to the current state\\n    # For example if graph = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]\\n    # we know (0, i, 2) = 1. we then know from the graph,\\n    # (2, i, 1) = 1, (5, i, 1) = 1, because it\\'s the mouse\\'s turn and it is going to pick the winning move. \\n\\t# We can label these nodes and put into the queue to further BFS\\n    # On the other hand, we also know (2,2,2) = 2. We then know that at (4,2,1), the mouse would never visit 2 because it will get caught. \\n\\t# It might visit (3,2,2) instead to avoid getting caught\\n    # To account for that game strategy, we record the outgoing degree for all states for both mouse and cat. \\n\\t# Each time we arrive at scenario in which a parent has a losing child, we decrease the degree of that state by 1. \\n\\t# If the outgoing degree becomes 0, it means a mouse / cat getting into this state must lose (all paths outward leads to loss)\\n    # When the BFS is finished we just return the win state of mouse\\n    \\n    def catMouseGame(self, graph: List[List[int]]) -> int:\\n        n = len(graph)\\n\\n        degree = [[[0 for k in range(3)] for j in range(n)] for i in range(n)]\\n        for i in range(n):\\n            for j in range(n):\\n                degree[i][j][1] += len(graph[i])\\n                degree[i][j][2] += len(graph[j])\\n                if 0 in graph[j]:\\n                    degree[i][j][2] -= 1 # cat cannot go to the hole 0!\\n        # Push the winning state into the queue, and look for their parents\\n        dq = deque()\\n        win = [[[0 for k in range(3)] for j in range(n)] for i in range(n)]\\n        for i in range(1, n):\\n            for k in range(1,3):\\n                win[0][i][k] = 1\\n                dq.append([0,i,k,1])\\n                win[i][i][k] = 2\\n                dq.append([i,i,k,2])\\n\\n        while dq:\\n            m, c, t, w = dq.popleft()\\n            parents = []\\n            if t == 1:\\n                for parent in graph[c]:\\n                    if parent != 0:\\n                        parents.append([m, parent, 2]) # cat cannot come from the hole 0!\\n            else:\\n                for parent in graph[m]:\\n                    parents.append([parent, c, 1])\\n            for mp, cp, tp in parents:\\n                # we are only interested in dealing with the potential draws\\n                if win[mp][cp][tp] == 0:\\n                    # it\\'s mouse turn and mouse would win if it makes the move; same for cat\\n                    if tp == w: \\n                        win[mp][cp][tp] = w\\n                        dq.append([mp, cp, tp, w])\\n                    else:\\n                        degree[mp][cp][tp] -= 1\\n                        if degree[mp][cp][tp] == 0:\\n                            win[mp][cp][tp] = w\\n                            dq.append([mp, cp, tp, w])\\n        #print(win)\\n        return win[1][2][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 236775,
                "title": "python-dfs-dp-faster-than-95-88-less-than-100-easy-to-understand-provide-by-a-rookie",
                "content": "Decompose the problem into a judgment whether the mouse will win or not, and whether the cat will win. If both does not win, it is a draw.\\nWhen judging whether the mouse will win, the route of the mouse must not have a ring, because the ring only makes sense if it can\\'t win and wants result draw. the same as judge whether the cat will win. time cost O(n^2) and space cost O(n^2)\\n\\u628A\\u95EE\\u9898\\u5206\\u89E3\\u6210\\uFF0C\\u5224\\u65AD\\u8001\\u9F20\\u662F\\u5426\\u4F1A\\u8D62\\uFF0C\\u5224\\u65AD\\u732B\\u662F\\u5426\\u4F1A\\u8D62\\uFF0C\\u5982\\u679C\\u90FD\\u4E0D\\u8D62\\u90A3\\u5C31\\u662F\\u5E73\\u5C40\\u3002\\n\\u5176\\u4E2D\\u5224\\u65AD\\u8001\\u9F20\\u662F\\u5426\\u4F1A\\u8D62\\u65F6\\uFF0C\\u8001\\u9F20\\u8D70\\u7684\\u8DEF\\u7EBF\\u5FC5\\u7136\\u4E0D\\u80FD\\u6709\\u73AF\\uFF0C\\u56E0\\u4E3A\\u8D70\\u73AF\\u53EA\\u6709\\u5728\\u8D62\\u4E0D\\u4E86\\u60F3\\u8981\\u6253\\u5E73\\u7684\\u60C5\\u51B5\\u4E0B\\u624D\\u6709\\u610F\\u4E49\\uFF0C\\u5224\\u65AD\\u732B\\u662F\\u5426\\u4F1A\\u8D62\\u5219\\u732B\\u8D70\\u7684\\u8DEF\\u7EBF\\u4E0D\\u80FD\\u6709\\u73AF\\u3002\\u901A\\u8FC7dfs\\u904D\\u5386\\u8001\\u9F20\\u548C\\u732B\\u7684\\u8DEF\\u5F84\\u901A\\u8FC7dp\\u8BB0\\u5F55\\u4E0B\\u8001\\u9F20\\u548C\\u732B\\u7684\\u5728\\u67D0\\u4E2A\\u4F4D\\u7F6E\\u7684\\u7ED3\\u679C\\uFF0C\\u56E0\\u4E3A\\u732B\\u548C\\u8001\\u9F20\\u7684\\u4F4D\\u7F6E\\u5404\\u81EA\\u6709n\\u79CD\\uFF0C\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\u5E94\\u4E3AO(n^2)\\uFF0C\\u7A7A\\u95F4\\u590D\\u6742\\u5EA6\\u4E5F\\u662FO(n^2)\\n\\u5177\\u4F53\\u4EE3\\u7801\\u5982\\u4E0B:\\n\\n    def catMouseGame(self, graph: \\'List[List[int]]\\') -> \\'int\\':\\n        mouse_visited = [False] * len(graph)\\n        mouse_win_map = [[None for column in range(len(graph))] for row in range(len(graph))]\\n        cat_visited = [False] * len(graph)\\n        cat_win_map = [[None for column in range(len(graph))] for row in range(len(graph))]\\n        if self.isMouseWin(graph, 1, 2, mouse_visited, mouse_win_map):\\n            return 1\\n        elif self.isCatWin(graph, 1, 2, cat_visited, cat_win_map):\\n            return 2\\n        else:\\n            return 0\\n\\n    def isMouseWin(self, graph, mouse, cat, mouse_visited, mouse_win_map):\\n        if mouse == 0:\\n            return True\\n        if mouse_win_map[mouse][cat] is not None:\\n            return mouse_win_map[mouse][cat]\\n        mouse_visited[mouse] = True\\n        for mouseMove in graph[mouse]:\\n            if mouseMove == 0 or (mouseMove not in graph[cat] and  mouseMove != cat):\\n                if not mouse_visited[mouseMove]:\\n                    mouseWinFlag = True\\n                    for catMove in graph[cat]:\\n                        if catMove != 0 and not self.isMouseWin(graph, mouseMove, catMove, mouse_visited, mouse_win_map):\\n                            mouseWinFlag = False\\n                            break\\n                    if mouseWinFlag:\\n                        mouse_visited[mouse] = False\\n                        mouse_win_map[mouse][cat] = True\\n                        return True\\n        mouse_visited[mouse] = False\\n        mouse_win_map[mouse][cat] = False\\n        return False\\n    \\n    def isCatWin(self, graph, mouse, cat, cat_visited, cat_win_map):\\n        if mouse == 0:\\n            return False\\n        if cat_win_map[mouse][cat] is not None:\\n            return cat_win_map[mouse][cat]\\n        cat_visited[cat] = True\\n        for mouseMove in graph[mouse]:\\n            if mouseMove == 0 or (mouseMove not in graph[cat] and  mouseMove != cat):\\n                catWinFlag = True\\n                for catMove in graph[cat]:\\n                    if catMove != 0 and not cat_visited[catMove] and not self.isCatWin(graph, mouseMove, catMove,\\n                                                                                       cat_visited, cat_win_map):\\n                        catWinFlag = False\\n                        break\\n                if not catWinFlag:\\n                    cat_visited[cat] = False\\n                    cat_win_map[mouse][cat] = False\\n                    return False\\n        cat_visited[cat] = False\\n        cat_win_map[mouse][cat] = True\\n        return True",
                "solutionTags": [],
                "code": "Decompose the problem into a judgment whether the mouse will win or not, and whether the cat will win. If both does not win, it is a draw.\\nWhen judging whether the mouse will win, the route of the mouse must not have a ring, because the ring only makes sense if it can\\'t win and wants result draw. the same as judge whether the cat will win. time cost O(n^2) and space cost O(n^2)\\n\\u628A\\u95EE\\u9898\\u5206\\u89E3\\u6210\\uFF0C\\u5224\\u65AD\\u8001\\u9F20\\u662F\\u5426\\u4F1A\\u8D62\\uFF0C\\u5224\\u65AD\\u732B\\u662F\\u5426\\u4F1A\\u8D62\\uFF0C\\u5982\\u679C\\u90FD\\u4E0D\\u8D62\\u90A3\\u5C31\\u662F\\u5E73\\u5C40\\u3002\\n\\u5176\\u4E2D\\u5224\\u65AD\\u8001\\u9F20\\u662F\\u5426\\u4F1A\\u8D62\\u65F6\\uFF0C\\u8001\\u9F20\\u8D70\\u7684\\u8DEF\\u7EBF\\u5FC5\\u7136\\u4E0D\\u80FD\\u6709\\u73AF\\uFF0C\\u56E0\\u4E3A\\u8D70\\u73AF\\u53EA\\u6709\\u5728\\u8D62\\u4E0D\\u4E86\\u60F3\\u8981\\u6253\\u5E73\\u7684\\u60C5\\u51B5\\u4E0B\\u624D\\u6709\\u610F\\u4E49\\uFF0C\\u5224\\u65AD\\u732B\\u662F\\u5426\\u4F1A\\u8D62\\u5219\\u732B\\u8D70\\u7684\\u8DEF\\u7EBF\\u4E0D\\u80FD\\u6709\\u73AF\\u3002\\u901A\\u8FC7dfs\\u904D\\u5386\\u8001\\u9F20\\u548C\\u732B\\u7684\\u8DEF\\u5F84\\u901A\\u8FC7dp\\u8BB0\\u5F55\\u4E0B\\u8001\\u9F20\\u548C\\u732B\\u7684\\u5728\\u67D0\\u4E2A\\u4F4D\\u7F6E\\u7684\\u7ED3\\u679C\\uFF0C\\u56E0\\u4E3A\\u732B\\u548C\\u8001\\u9F20\\u7684\\u4F4D\\u7F6E\\u5404\\u81EA\\u6709n\\u79CD\\uFF0C\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\u5E94\\u4E3AO(n^2)\\uFF0C\\u7A7A\\u95F4\\u590D\\u6742\\u5EA6\\u4E5F\\u662FO(n^2)\\n\\u5177\\u4F53\\u4EE3\\u7801\\u5982\\u4E0B:\\n\\n    def catMouseGame(self, graph: \\'List[List[int]]\\') -> \\'int\\':\\n        mouse_visited = [False] * len(graph)\\n        mouse_win_map = [[None for column in range(len(graph))] for row in range(len(graph))]\\n        cat_visited = [False] * len(graph)\\n        cat_win_map = [[None for column in range(len(graph))] for row in range(len(graph))]\\n        if self.isMouseWin(graph, 1, 2, mouse_visited, mouse_win_map):\\n            return 1\\n        elif self.isCatWin(graph, 1, 2, cat_visited, cat_win_map):\\n            return 2\\n        else:\\n            return 0\\n\\n    def isMouseWin(self, graph, mouse, cat, mouse_visited, mouse_win_map):\\n        if mouse == 0:\\n            return True\\n        if mouse_win_map[mouse][cat] is not None:\\n            return mouse_win_map[mouse][cat]\\n        mouse_visited[mouse] = True\\n        for mouseMove in graph[mouse]:\\n            if mouseMove == 0 or (mouseMove not in graph[cat] and  mouseMove != cat):\\n                if not mouse_visited[mouseMove]:\\n                    mouseWinFlag = True\\n                    for catMove in graph[cat]:\\n                        if catMove != 0 and not self.isMouseWin(graph, mouseMove, catMove, mouse_visited, mouse_win_map):\\n                            mouseWinFlag = False\\n                            break\\n                    if mouseWinFlag:\\n                        mouse_visited[mouse] = False\\n                        mouse_win_map[mouse][cat] = True\\n                        return True\\n        mouse_visited[mouse] = False\\n        mouse_win_map[mouse][cat] = False\\n        return False\\n    \\n    def isCatWin(self, graph, mouse, cat, cat_visited, cat_win_map):\\n        if mouse == 0:\\n            return False\\n        if cat_win_map[mouse][cat] is not None:\\n            return cat_win_map[mouse][cat]\\n        cat_visited[cat] = True\\n        for mouseMove in graph[mouse]:\\n            if mouseMove == 0 or (mouseMove not in graph[cat] and  mouseMove != cat):\\n                catWinFlag = True\\n                for catMove in graph[cat]:\\n                    if catMove != 0 and not cat_visited[catMove] and not self.isCatWin(graph, mouseMove, catMove,\\n                                                                                       cat_visited, cat_win_map):\\n                        catWinFlag = False\\n                        break\\n                if not catWinFlag:\\n                    cat_visited[cat] = False\\n                    cat_win_map[mouse][cat] = False\\n                    return False\\n        cat_visited[cat] = False\\n        cat_win_map[mouse][cat] = True\\n        return True",
                "codeTag": "Python3"
            },
            {
                "id": 1023914,
                "title": "python-top-down-dp-beats-99",
                "content": "Questions are welcome.  \\n\\n**Key Insight:**\\n\\nThe cat and mouse would rather win than draw and would rather draw than lose.\\nSince both play optimally, they will never enter a cycle unless a draw is the best option.\\nSo **if the cat or the mouse will win, they will do so in less than 2&middot;n plies** where n is the number of nodes.\\n*Note: a ply is half of a turn. i.e. one mouse move **or** one cat move*\\n\\n**Approach:**\\n\\n1. Start with n turns with the cat at node 2 and the mouse at node 1; make sure n is even.\\n\\n2. On the cat\\'s turn (```turn&1```), if the cat is on or can reach the mouse, it wins.\\nOtherwise, try all possible moves for the cat.\\n**If any move results in the cat winning, return 2.**\\nOtherwise the only choices are a draw (0) or a mouse win (1).\\nReturn ```min(options)``` to select a draw if any option results in a draw since this is better than losing to a mouse.\\n\\n3. On the mouse\\'s turn, if the mouse can reach the hole, return 1.  Mouse wins!\\nOtherwise, try all possible moves for the mouse.\\n**If any option results in the mouse winning, return 1.**\\nOtherwise, the only choices are draw (0) or a cat win (1).\\nReturn ```min(options)``` to select draw if any option results in a draw since this is better than getting eaten by the cat.\\n\\n<br>\\n\\n```python\\nclass Solution:\\n    def catMouseGame(self, graph: List[List[int]]) -> int:\\n        \\n        @functools.lru_cache(None)\\n        def helper(turn, cat, mouse):\\n            \\n            if turn == 0: return 0\\n            options = set()\\n            \\n            # Cat\\'s turn\\n            if turn & 1:\\n                if mouse in graph[cat] or cat == mouse: return 2\\n                for c in graph[cat] - {0}:\\n                    options.add(helper(turn - 1, c, mouse))\\n                    if 2 in options: return 2\\n                return min(options)\\n            \\n            # Mouse\\'s turn\\n            if 0 in graph[mouse]: return 1\\n            for m in graph[mouse]:\\n                options.add(helper(turn - 1, cat, m))\\n                if 1 in options: return 1\\n            return min(options)\\n        \\n        n = len(graph) + (len(graph)&1)\\n        graph = {i: set(g) for i,g in enumerate(graph)}\\n        return helper(n, 2, 1)\\n```\\n\\n<img src=\"https://assets.leetcode.com/users/images/2da5fcf5-54d8-44e7-a276-744609c9fb2d_1611025156.92209.png\" width=\"50%\">\\n\\n*Note: 2&middot;n is sufficient for **all** test cases, but n is sufficient for **all current** test cases.  \\nIncrease n to 2&middot;n if the code fails a future test case.*\\n",
                "solutionTags": [],
                "code": "```turn&1```\n```min(options)```\n```min(options)```\n```python\\nclass Solution:\\n    def catMouseGame(self, graph: List[List[int]]) -> int:\\n        \\n        @functools.lru_cache(None)\\n        def helper(turn, cat, mouse):\\n            \\n            if turn == 0: return 0\\n            options = set()\\n            \\n            # Cat\\'s turn\\n            if turn & 1:\\n                if mouse in graph[cat] or cat == mouse: return 2\\n                for c in graph[cat] - {0}:\\n                    options.add(helper(turn - 1, c, mouse))\\n                    if 2 in options: return 2\\n                return min(options)\\n            \\n            # Mouse\\'s turn\\n            if 0 in graph[mouse]: return 1\\n            for m in graph[mouse]:\\n                options.add(helper(turn - 1, cat, m))\\n                if 1 in options: return 1\\n            return min(options)\\n        \\n        n = len(graph) + (len(graph)&1)\\n        graph = {i: set(g) for i,g in enumerate(graph)}\\n        return helper(n, 2, 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328248,
                "title": "explanation-without-code",
                "content": "```\\nUse 3 dimentional status & child array as below\\nstatus[mouseLocation][catLocation][mouseOrCatTurn]\\nchild[mouseLocation][catLocation][mouseOrCatTurn]\\n            \\nchild array stores number of possible moves for a given state \\nfor e.g. \\nfrom mouseLocation = 1\\nfrom catLocation = 3\\n& mouseTurn \\nchild[mouseLocation][catLocation][mouseTurn] = graph(mouseLocation).length\\n\\nSimilarly\\nfrom mouseLocation = 1\\nfrom catLocation = 3\\n& catTurn \\nchild[mouseLocation][catLocation][catTurn] = graph(catLocation).length\\n            \\nNow comes the obivious wining states \\nif mouseLocation = 0 then mouse is Winner\\nstatus[0][catLocation][mouseTurn] = MOUSE_WIN\\nstatus[0][catLocation][catTurn] = MOUSE_WIN\\n            \\nSimilarly if catLocation == mouseLocation then cat is Winner & mouseLocation > 0\\nstatus[mouseLocation][mouseLocation][mouseTurn] = CatWin\\nstatus[mouseLocation][mouseLocation][catTurn] = CatWin\\n                \\nNow that we know obvious wining status values add those state in queue and start a BFS \\n            \\nBFS should work as follow \\n1. if current status == MOUSE_WIN check all it\\'s parent. \\nFor each parent with mouseTurn set value as Mouse_WIN\\nstatus[mouseLocation_parent_location][catLocation_parent_location][mouseTurn] = Mouse_WIN\\n2. if current status == CAT_WIN check all it\\'s parent. \\nFor each parent with catTurn set value as CAT_WIN\\nstatus[mouseLocation_parent_location][catLocation_parent_location][mouseTurn] = CAT_WIN\\n\\nAnd at the end return status[1][2][0] \\n1 because mouse starts at 1 \\n2 because cat starts at 2 \\n0 because mouse starts first\\n```",
                "solutionTags": [],
                "code": "```\\nUse 3 dimentional status & child array as below\\nstatus[mouseLocation][catLocation][mouseOrCatTurn]\\nchild[mouseLocation][catLocation][mouseOrCatTurn]\\n            \\nchild array stores number of possible moves for a given state \\nfor e.g. \\nfrom mouseLocation = 1\\nfrom catLocation = 3\\n& mouseTurn \\nchild[mouseLocation][catLocation][mouseTurn] = graph(mouseLocation).length\\n\\nSimilarly\\nfrom mouseLocation = 1\\nfrom catLocation = 3\\n& catTurn \\nchild[mouseLocation][catLocation][catTurn] = graph(catLocation).length\\n            \\nNow comes the obivious wining states \\nif mouseLocation = 0 then mouse is Winner\\nstatus[0][catLocation][mouseTurn] = MOUSE_WIN\\nstatus[0][catLocation][catTurn] = MOUSE_WIN\\n            \\nSimilarly if catLocation == mouseLocation then cat is Winner & mouseLocation > 0\\nstatus[mouseLocation][mouseLocation][mouseTurn] = CatWin\\nstatus[mouseLocation][mouseLocation][catTurn] = CatWin\\n                \\nNow that we know obvious wining status values add those state in queue and start a BFS \\n            \\nBFS should work as follow \\n1. if current status == MOUSE_WIN check all it\\'s parent. \\nFor each parent with mouseTurn set value as Mouse_WIN\\nstatus[mouseLocation_parent_location][catLocation_parent_location][mouseTurn] = Mouse_WIN\\n2. if current status == CAT_WIN check all it\\'s parent. \\nFor each parent with catTurn set value as CAT_WIN\\nstatus[mouseLocation_parent_location][catLocation_parent_location][mouseTurn] = CAT_WIN\\n\\nAnd at the end return status[1][2][0] \\n1 because mouse starts at 1 \\n2 because cat starts at 2 \\n0 because mouse starts first\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3224728,
                "title": "java-easy-top-down-dp",
                "content": "# Complexity\\n- Time complexity:\\nO(n^3)\\n\\n- Space complexity:\\nO(n^3)\\n\\n# Code\\n```\\nclass Solution {\\n    private int M;\\n    Integer memo[][][];\\n    public int catMouseGame(int[][] graph) {\\n        int n = graph.length;\\n        M = 4*n + 200; // randomly chosen max move\\n        memo = new Integer[n+1][n+1][M+1];\\n        return dp(1, 2, 0, graph);\\n    }\\n\\n    int dp(int m, int c, int moves, int[][] graph) {\\n        if(moves > M) return 0;\\n        if(c == m) return 2;\\n        if(m == 0) return 1;\\n        if(memo[m][c][moves] != null) return memo[m][c][moves];\\n        if(moves % 2 == 0){\\n            boolean draw = false;\\n            for(int nei : graph[m]) {\\n                int ans = dp(nei, c, moves+1, graph);\\n                if(ans == 1) return memo[m][c][moves] = 1;\\n                if(ans == 0)draw = true;\\n            }\\n            return memo[m][c][moves] = draw ? 0 : 2;\\n        }else {\\n            boolean draw = false;\\n            for(int nei : graph[c]) {\\n                if(nei == 0) continue;\\n                int ans = dp(m, nei, moves+1, graph);\\n                if(ans == 2) return memo[m][c][moves] = 2;\\n                if(ans == 0)draw = true;\\n            }\\n            return memo[m][c][moves] = draw ? 0 : 1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    private int M;\\n    Integer memo[][][];\\n    public int catMouseGame(int[][] graph) {\\n        int n = graph.length;\\n        M = 4*n + 200; // randomly chosen max move\\n        memo = new Integer[n+1][n+1][M+1];\\n        return dp(1, 2, 0, graph);\\n    }\\n\\n    int dp(int m, int c, int moves, int[][] graph) {\\n        if(moves > M) return 0;\\n        if(c == m) return 2;\\n        if(m == 0) return 1;\\n        if(memo[m][c][moves] != null) return memo[m][c][moves];\\n        if(moves % 2 == 0){\\n            boolean draw = false;\\n            for(int nei : graph[m]) {\\n                int ans = dp(nei, c, moves+1, graph);\\n                if(ans == 1) return memo[m][c][moves] = 1;\\n                if(ans == 0)draw = true;\\n            }\\n            return memo[m][c][moves] = draw ? 0 : 2;\\n        }else {\\n            boolean draw = false;\\n            for(int nei : graph[c]) {\\n                if(nei == 0) continue;\\n                int ans = dp(m, nei, moves+1, graph);\\n                if(ans == 2) return memo[m][c][moves] = 2;\\n                if(ans == 0)draw = true;\\n            }\\n            return memo[m][c][moves] = draw ? 0 : 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148098,
                "title": "c-working-intuitive-dfs-solution-with-detailed-explanation",
                "content": "The typical DFS solution would determine each node\\'s result according to its children\\'s result - meaning your opppnent\\'s best choice. If the game falls into an infinite loop (cycle), it means a draw.\\nHowever, if we determine the draw position by detecting a cycle, the result would be wrong in the situation when a winning route is discovered after the draw route, causing previous return value / detected cycle to be incorrect. (full explanation & visualization in the link in the comment)\\nAs a quick fix, we can rerun a DFS for all the draw positions after each DFS, so that the draw position will be re-evaluated based on the new optimal route we discovered. If the amount of draw positions couldn\\'t be reduced further after a re-run, we determine it as a real draw position. As we will revisit many of the nodes, this solution is not as efficient as the official answer, but it\\'s a working DFS solution :)\\nPlease upvote if this walkaround helps. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<vector<int>>> state; //mouse position, cat position, whose turn\\n        /*  0 means mouse\\'s turn, 1 means cat turn.  result   \\n        mouse 0 <cat 0 <res_m,res_c>>\\n                <cat 1 <res_m,res_c>>\\n        mouse 1\\n        mouse 2\\n        */\\n        //cat win position - mouse == cat\\n        //mouse win position - mouse == 0\\n    int dfs(vector<vector<int>>& graph, int mouse, int cat, int turn){\\n        //cout << \" pos \" << mouse << \",\" << cat << \" next turn: \" << turn << endl; \\n        if (state[mouse][cat][turn] !=-1){\\n            return state[mouse][cat][turn];\\n        }  \\n        if (mouse ==0){\\n            state[mouse][cat][turn] =1;\\n            return 1;\\n        }\\n        if (mouse == cat){\\n            state[mouse][cat][turn] =2;\\n            return 2;\\n        }\\n        state[mouse][cat][turn] = 0;\\n        /*\\n        if (step == drawlimit){\\n            state[mouse][cat][turn] =0;\\n            return 0;\\n        }*/\\n\\n        if (!turn){//mouse\\'s turn\\n            bool isDraw=false;\\n            for (int i=0; i< graph[mouse].size();i++){\\n                int nextturn = dfs(graph,graph[mouse][i],cat,turn+1);\\n                if(nextturn==1){\\n                    isDraw = false;\\n                    return state[mouse][cat][turn] = 1;\\n                }\\n                if(nextturn==0){\\n                    isDraw=true;\\n                }\\n            }\\n            //because draw is better than loss\\n            if(isDraw){\\n                return state[mouse][cat][turn] = 0;\\n            }\\n            return state[mouse][cat][turn] = 2;\\n        } else{\\n            bool isDraw=false;\\n            for (int i=0; i< graph[cat].size();i++){\\n                if (graph[cat][i] !=0){\\n                    int nextturn = dfs(graph,mouse,graph[cat][i],turn-1);\\n                    if(nextturn==2){\\n                        isDraw = false;\\n                        return state[mouse][cat][turn] = 2;\\n                    }\\n                    if(nextturn==0){\\n                        isDraw=true;\\n                    }\\n                }\\n            }\\n            if(isDraw){\\n                return state[mouse][cat][turn] = 0;\\n            }\\n            return state[mouse][cat][turn] = 1;\\n        }\\n\\n\\n        return state[mouse][cat][turn];\\n    }\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        \\n        int n = graph.size();\\n        for (int i=0; i< n;i++){     \\n            vector<vector<int>> cat_p;      \\n            for (int j=0; j< n;j++){               \\n                vector<int> v;\\n                v.push_back(-1);\\n                v.push_back(-1);\\n                cat_p.push_back(v);                               \\n            }\\n            state.push_back(cat_p);           \\n        }\\n        \\n        dfs(graph,1,2,0);\\n        //revisit 0\\n        vector<vector<int>> revisit;\\n        int lastround = -1;\\n        for (int i=0; i< n;i++){\\n            for (int j=0; j< n;j++){\\n                for (int k=0; k<2;k++){\\n                    if (state[i][j][k] ==0){\\n                        vector<int> v= {i,j,k};\\n                        revisit.push_back(v);                        \\n                    }\\n                    //cout << \"mouse \" << i << \" cat \" << j \\n                    //<< \" turn res\" <<state[i][j][k] <<endl;\\n                }               \\n            }\\n        }\\n        while (lastround != revisit.size() && revisit.size()!=0){\\n            //cout << lastround << \\',\\'<< revisit.size() << endl;\\n            lastround = revisit.size();\\n            for (int i=0; i< revisit.size();i++){\\n                state[revisit[i][0]][revisit[i][1]][revisit[i][2]] = -1;\\n                dfs(graph,revisit[i][0],revisit[i][1],revisit[i][2]);\\n            }\\n            revisit.clear();\\n            for (int i=0; i< n;i++){\\n                for (int j=0; j< n;j++){\\n                    for (int k=0; k<2;k++){\\n                        if (state[i][j][k] ==0){\\n                            vector<int> v= {i,j,k};\\n                            revisit.push_back(v);                        \\n                        }\\n                    }               \\n                }\\n            }\\n\\n        }\\n\\n        if (state[1][2][0] == -1){\\n            return 0;\\n        } else{\\n            return state[1][2][0];\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<vector<int>>> state; //mouse position, cat position, whose turn\\n        /*  0 means mouse\\'s turn, 1 means cat turn.  result   \\n        mouse 0 <cat 0 <res_m,res_c>>\\n                <cat 1 <res_m,res_c>>\\n        mouse 1\\n        mouse 2\\n        */\\n        //cat win position - mouse == cat\\n        //mouse win position - mouse == 0\\n    int dfs(vector<vector<int>>& graph, int mouse, int cat, int turn){\\n        //cout << \" pos \" << mouse << \",\" << cat << \" next turn: \" << turn << endl; \\n        if (state[mouse][cat][turn] !=-1){\\n            return state[mouse][cat][turn];\\n        }  \\n        if (mouse ==0){\\n            state[mouse][cat][turn] =1;\\n            return 1;\\n        }\\n        if (mouse == cat){\\n            state[mouse][cat][turn] =2;\\n            return 2;\\n        }\\n        state[mouse][cat][turn] = 0;\\n        /*\\n        if (step == drawlimit){\\n            state[mouse][cat][turn] =0;\\n            return 0;\\n        }*/\\n\\n        if (!turn){//mouse\\'s turn\\n            bool isDraw=false;\\n            for (int i=0; i< graph[mouse].size();i++){\\n                int nextturn = dfs(graph,graph[mouse][i],cat,turn+1);\\n                if(nextturn==1){\\n                    isDraw = false;\\n                    return state[mouse][cat][turn] = 1;\\n                }\\n                if(nextturn==0){\\n                    isDraw=true;\\n                }\\n            }\\n            //because draw is better than loss\\n            if(isDraw){\\n                return state[mouse][cat][turn] = 0;\\n            }\\n            return state[mouse][cat][turn] = 2;\\n        } else{\\n            bool isDraw=false;\\n            for (int i=0; i< graph[cat].size();i++){\\n                if (graph[cat][i] !=0){\\n                    int nextturn = dfs(graph,mouse,graph[cat][i],turn-1);\\n                    if(nextturn==2){\\n                        isDraw = false;\\n                        return state[mouse][cat][turn] = 2;\\n                    }\\n                    if(nextturn==0){\\n                        isDraw=true;\\n                    }\\n                }\\n            }\\n            if(isDraw){\\n                return state[mouse][cat][turn] = 0;\\n            }\\n            return state[mouse][cat][turn] = 1;\\n        }\\n\\n\\n        return state[mouse][cat][turn];\\n    }\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        \\n        int n = graph.size();\\n        for (int i=0; i< n;i++){     \\n            vector<vector<int>> cat_p;      \\n            for (int j=0; j< n;j++){               \\n                vector<int> v;\\n                v.push_back(-1);\\n                v.push_back(-1);\\n                cat_p.push_back(v);                               \\n            }\\n            state.push_back(cat_p);           \\n        }\\n        \\n        dfs(graph,1,2,0);\\n        //revisit 0\\n        vector<vector<int>> revisit;\\n        int lastround = -1;\\n        for (int i=0; i< n;i++){\\n            for (int j=0; j< n;j++){\\n                for (int k=0; k<2;k++){\\n                    if (state[i][j][k] ==0){\\n                        vector<int> v= {i,j,k};\\n                        revisit.push_back(v);                        \\n                    }\\n                    //cout << \"mouse \" << i << \" cat \" << j \\n                    //<< \" turn res\" <<state[i][j][k] <<endl;\\n                }               \\n            }\\n        }\\n        while (lastround != revisit.size() && revisit.size()!=0){\\n            //cout << lastround << \\',\\'<< revisit.size() << endl;\\n            lastround = revisit.size();\\n            for (int i=0; i< revisit.size();i++){\\n                state[revisit[i][0]][revisit[i][1]][revisit[i][2]] = -1;\\n                dfs(graph,revisit[i][0],revisit[i][1],revisit[i][2]);\\n            }\\n            revisit.clear();\\n            for (int i=0; i< n;i++){\\n                for (int j=0; j< n;j++){\\n                    for (int k=0; k<2;k++){\\n                        if (state[i][j][k] ==0){\\n                            vector<int> v= {i,j,k};\\n                            revisit.push_back(v);                        \\n                        }\\n                    }               \\n                }\\n            }\\n\\n        }\\n\\n        if (state[1][2][0] == -1){\\n            return 0;\\n        } else{\\n            return state[1][2][0];\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2146977,
                "title": "why-using-dp-to-determine-draw-does-not-work-here-bfs-solution-provided",
                "content": "When using dynamic programming, there is one condition: \"Subproblem dependency should be acyclic\".\\nIn this problem, draw condition form a circle in graph. When DP enconter this case, there is no way to determine a draw. Fake draw will appear. \\n\\nProvid this game is a perfect information game. We can use the following features:\\n1. In a perfect information game, once the starting state is fixed, if everyone take optimal strategy, the result of the game will be deterministic. \\n2. The final cat win or mouse win status is already defined. We can find all the other cat win and mouse win statuse base on it. The rest wil be draw.\\n3. DP can be used as long as subproblem dependency is acyclic.\\n\\nNow let\\'s get into the detail on this problem. The state can be determined by mouse position, cat position and whose turn to move. Once in a state, if cat and mouse take optimal strategy, the final result is deterministic(cat win/mouse win/draw). Based on the given graph, we can build a status graph (the status graph is directional).\\nFor easy understanding, we will seperate cat win and mouse win. After we get all the cat win and mouse win status, the rest will be draw. We will asume all the player use optimal strategy.\\n\\nCat win case:\\n1. Final cat win cases are defined by the problem. Cat and mouse are at the same position. Cat cannot be at 0. \\n2. If current state is cat win, and it\\'s mouse\\'s turn to move. The previous state will be cat\\'s turn to move. If cat can move to this state (connected in the state graph) , he will move. \\n3. If current state is cat win, and it\\'s cat\\'s turn to move. The previous state will be mouse\\'s turn to move. Mouse will not choose to move to this state, if mouse have better choice. Base on this point, a state is mouse\\'s turn to move, and all the possible choices lead to cat win. Then the state will be cat win. We can deal with this case(cat win, cat\\'s turn) with the following method: if the edge pointing to this case, we can cut off the edge and look at the parent state (where the edge come from); if there is no other edge coming out from the parent edge (parent state do not have other choice), the parent state can be determined and it is cat win.\\n\\nMouse win case:\\n1. Final mouse win case is defined. Mouse is at position 0.\\n2. If current state is mouse win, and it\\'s cat\\'s turn to move. The previous state is mouse\\'s turn to move. If mouse can move to this state (connected in the state graph) , he will move.\\n3. If current state is mouse win, and it\\'s mouse\\'s turn to move. The previous state will be cat\\'s turn to move. Cat will not choose to move to this state, if cat have better choice. Base on this point, a state is cat\\'s turn to move, and all the possible choices lead to mouse win. Then the state will be mouse win.\\n\\nFurther optimization: we only use small portion information of the state graph. The information needed can be reduced to 3 dimension array.\\n```\\n        public int CatMouseGame(int[][] graph)\\n        {\\n            //mouse win 1\\n            //cat win 2\\n            //draw 0\\n            //[mousePosition,catPosition, whoesturn],whoesturn:  0-> mouse;   1-> cat\\n            int len = graph.Length;\\n\\n            int[,,] dp = new int[len, len, 2];\\n            int[,,] reducedStateGraph = new int[len, len, 2];\\n\\n            //mouse move->simulate mouse move edge in state graph\\n            for (int mousePo = 0; mousePo < len; mousePo++)\\n            {\\n                for (int catPo = 1; catPo < len; catPo++)//cat is not allowed to reach 0\\n                {\\n                    reducedStateGraph[mousePo, catPo, 0] = graph[mousePo].Length;\\n                }\\n            }\\n            //cat move-> simulate cat move edge in state graph\\n            for (int catPo = 1; catPo < len; catPo++)\\n            {\\n                bool contains0 = graph[catPo].Contains(0);\\n                for (int mousePo = 0; mousePo < len; mousePo++)\\n                {\\n                    reducedStateGraph[mousePo, catPo, 1] = graph[catPo].Length;\\n\\n                    //cat is not allowed to reach 0.\\n                    if (contains0)\\n                    {\\n                        reducedStateGraph[mousePo, catPo, 1]--;\\n                    }\\n                }\\n            }\\n\\n            Queue<int[]> catWinQ = new Queue<int[]>();\\n            //init cat win\\n            for (int i = 1; i < len; i++)\\n            {\\n                dp[i, i, 0] = 2;\\n                dp[i, i, 1] = 2;\\n                catWinQ.Enqueue(new int[] { i, i, 0 });\\n                catWinQ.Enqueue(new int[] { i, i, 1 });\\n            }\\n\\n            Queue<int[]> mouseWinQ = new Queue<int[]>();\\n            //init mouse win\\n            for (int i = 1; i < len; i++)\\n            {\\n                dp[0, i, 0] = 1; \\n                dp[0, i, 1] = 1;\\n                mouseWinQ.Enqueue(new int[] { 0, i, 0 });\\n                mouseWinQ.Enqueue(new int[] { 0, i, 1 });\\n            }\\n\\n            //bfs cat win ->2\\n            while (catWinQ.Count > 0)\\n            {\\n                int[] po = catWinQ.Dequeue();\\n                int currentMousePo = po[0];\\n                int currentCatPo = po[1];\\n                if (po[2] == 0) //mouse move\\n                {\\n                    //parent state is cat move, cat will choose to move to this po\\n                    foreach (int preCatPo in graph[currentCatPo])\\n                    {\\n                        if (preCatPo != 0 && dp[currentMousePo, preCatPo, 1] == 0)\\n                        {\\n                            dp[currentMousePo, preCatPo, 1] = 2;\\n                            catWinQ.Enqueue(new int[] { currentMousePo, preCatPo, 1 });\\n                        }\\n                    }\\n                }\\n                else  //cat move\\n                {\\n                    //parent state is mouse move, mouse will try to avoid move here\\n                    foreach (int preMousePo in graph[currentMousePo])\\n                    {\\n                        if (dp[preMousePo, currentCatPo, 0] == 0)\\n                        {\\n                            reducedStateGraph[preMousePo, currentCatPo, 0]--;\\n                            if (reducedStateGraph[preMousePo, currentCatPo, 0] == 0)\\n                            {\\n                                dp[preMousePo, currentCatPo, 0] = 2;\\n                                catWinQ.Enqueue(new int[] { preMousePo, currentCatPo, 0 });\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n\\n            //bfs mouse win -> 1\\n            while (mouseWinQ.Count > 0)\\n            {\\n                int[] po = mouseWinQ.Dequeue();\\n                int currentMousePo = po[0];\\n                int currentCatPo = po[1];\\n\\n                if (po[2] == 0)//mouse move\\n                {\\n                    //parent move is cat move, cat will try to avoid it\\n                    foreach (int preCatPo in graph[currentCatPo])\\n                    {\\n                        if (preCatPo != 0 && dp[currentMousePo, preCatPo, 1] == 0)\\n                        {\\n                            reducedStateGraph[currentMousePo, preCatPo, 1]--;\\n                            if (reducedStateGraph[currentMousePo, preCatPo, 1] == 0)\\n                            {\\n                                dp[currentMousePo, preCatPo, 1] = 1;\\n                                mouseWinQ.Enqueue(new int[] { currentMousePo, preCatPo, 1 });\\n                            }\\n                        }\\n                    }\\n                }\\n                else//cat move\\n                {\\n                    //parent move is mouse move, mouse will choose to move here\\n                    foreach (int preMousePo in graph[currentMousePo])\\n                    {\\n                        if (dp[preMousePo, currentCatPo, 0] == 0)\\n                        {\\n                            dp[preMousePo, currentCatPo, 0] = 1;\\n                            mouseWinQ.Enqueue(new int[] { preMousePo, currentCatPo, 0 });\\n                        }\\n                    }\\n                }\\n\\n            }\\n\\n            return dp[1, 2, 0];\\n        }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\n        public int CatMouseGame(int[][] graph)\\n        {\\n            //mouse win 1\\n            //cat win 2\\n            //draw 0\\n            //[mousePosition,catPosition, whoesturn],whoesturn:  0-> mouse;   1-> cat\\n            int len = graph.Length;\\n\\n            int[,,] dp = new int[len, len, 2];\\n            int[,,] reducedStateGraph = new int[len, len, 2];\\n\\n            //mouse move->simulate mouse move edge in state graph\\n            for (int mousePo = 0; mousePo < len; mousePo++)\\n            {\\n                for (int catPo = 1; catPo < len; catPo++)//cat is not allowed to reach 0\\n                {\\n                    reducedStateGraph[mousePo, catPo, 0] = graph[mousePo].Length;\\n                }\\n            }\\n            //cat move-> simulate cat move edge in state graph\\n            for (int catPo = 1; catPo < len; catPo++)\\n            {\\n                bool contains0 = graph[catPo].Contains(0);\\n                for (int mousePo = 0; mousePo < len; mousePo++)\\n                {\\n                    reducedStateGraph[mousePo, catPo, 1] = graph[catPo].Length;\\n\\n                    //cat is not allowed to reach 0.\\n                    if (contains0)\\n                    {\\n                        reducedStateGraph[mousePo, catPo, 1]--;\\n                    }\\n                }\\n            }\\n\\n            Queue<int[]> catWinQ = new Queue<int[]>();\\n            //init cat win\\n            for (int i = 1; i < len; i++)\\n            {\\n                dp[i, i, 0] = 2;\\n                dp[i, i, 1] = 2;\\n                catWinQ.Enqueue(new int[] { i, i, 0 });\\n                catWinQ.Enqueue(new int[] { i, i, 1 });\\n            }\\n\\n            Queue<int[]> mouseWinQ = new Queue<int[]>();\\n            //init mouse win\\n            for (int i = 1; i < len; i++)\\n            {\\n                dp[0, i, 0] = 1; \\n                dp[0, i, 1] = 1;\\n                mouseWinQ.Enqueue(new int[] { 0, i, 0 });\\n                mouseWinQ.Enqueue(new int[] { 0, i, 1 });\\n            }\\n\\n            //bfs cat win ->2\\n            while (catWinQ.Count > 0)\\n            {\\n                int[] po = catWinQ.Dequeue();\\n                int currentMousePo = po[0];\\n                int currentCatPo = po[1];\\n                if (po[2] == 0) //mouse move\\n                {\\n                    //parent state is cat move, cat will choose to move to this po\\n                    foreach (int preCatPo in graph[currentCatPo])\\n                    {\\n                        if (preCatPo != 0 && dp[currentMousePo, preCatPo, 1] == 0)\\n                        {\\n                            dp[currentMousePo, preCatPo, 1] = 2;\\n                            catWinQ.Enqueue(new int[] { currentMousePo, preCatPo, 1 });\\n                        }\\n                    }\\n                }\\n                else  //cat move\\n                {\\n                    //parent state is mouse move, mouse will try to avoid move here\\n                    foreach (int preMousePo in graph[currentMousePo])\\n                    {\\n                        if (dp[preMousePo, currentCatPo, 0] == 0)\\n                        {\\n                            reducedStateGraph[preMousePo, currentCatPo, 0]--;\\n                            if (reducedStateGraph[preMousePo, currentCatPo, 0] == 0)\\n                            {\\n                                dp[preMousePo, currentCatPo, 0] = 2;\\n                                catWinQ.Enqueue(new int[] { preMousePo, currentCatPo, 0 });\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n\\n            //bfs mouse win -> 1\\n            while (mouseWinQ.Count > 0)\\n            {\\n                int[] po = mouseWinQ.Dequeue();\\n                int currentMousePo = po[0];\\n                int currentCatPo = po[1];\\n\\n                if (po[2] == 0)//mouse move\\n                {\\n                    //parent move is cat move, cat will try to avoid it\\n                    foreach (int preCatPo in graph[currentCatPo])\\n                    {\\n                        if (preCatPo != 0 && dp[currentMousePo, preCatPo, 1] == 0)\\n                        {\\n                            reducedStateGraph[currentMousePo, preCatPo, 1]--;\\n                            if (reducedStateGraph[currentMousePo, preCatPo, 1] == 0)\\n                            {\\n                                dp[currentMousePo, preCatPo, 1] = 1;\\n                                mouseWinQ.Enqueue(new int[] { currentMousePo, preCatPo, 1 });\\n                            }\\n                        }\\n                    }\\n                }\\n                else//cat move\\n                {\\n                    //parent move is mouse move, mouse will choose to move here\\n                    foreach (int preMousePo in graph[currentMousePo])\\n                    {\\n                        if (dp[preMousePo, currentCatPo, 0] == 0)\\n                        {\\n                            dp[preMousePo, currentCatPo, 0] = 1;\\n                            mouseWinQ.Enqueue(new int[] { preMousePo, currentCatPo, 0 });\\n                        }\\n                    }\\n                }\\n\\n            }\\n\\n            return dp[1, 2, 0];\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1166918,
                "title": "java-solution-88-faster-and-88-space-using-dfs-and-3d-memo",
                "content": "\\n```\\nclass Solution {\\n    int MOUSE = 1;\\n    int CAT = 2;\\n    int DRAW = 0;\\n    int len;\\n    public int catMouseGame(int[][] graph) {\\n        len = graph.length;\\n        return dfs(1,2,0,graph,new Integer[len][len][2*len]);\\n    }\\n    \\n    public int dfs(int m,int c,int turn,int[][] graph,Integer[][][] dp) {\\n        \\n        \\n        if(m==0) return MOUSE;\\n        if(m==c) return CAT;\\n        \\n        if(turn >= 2*len) return DRAW;\\n        \\n        if(dp[m][c][turn] != null) return dp[m][c][turn];\\n        \\n        //MOUSE turn\\n        if(turn%2 == 0) {\\n            \\n            boolean isThereDrawState = false;\\n            for(int neigh:graph[m]) {\\n                int temp = dfs(neigh,c,turn+1,graph,dp);\\n                if(temp == MOUSE) {\\n                    dp[m][c][turn] = MOUSE;\\n                    return MOUSE;\\n                } else if(temp == DRAW) {\\n                    isThereDrawState = true;\\n                }\\n            } \\n            \\n            if(isThereDrawState)  {\\n                dp[m][c][turn] = DRAW;\\n                return DRAW;\\n            }\\n            else  {\\n                dp[m][c][turn] = CAT;\\n                return CAT;\\n            }\\n        } else {\\n            boolean isThereDrawState = false;\\n            for(int neigh:graph[c]) {\\n                if(neigh == 0) continue;\\n                int temp = dfs(m,neigh,turn+1,graph,dp);\\n                if(temp == CAT)  {\\n                    dp[m][c][turn] = CAT;\\n                    return CAT;\\n                }\\n                else if(temp == DRAW) isThereDrawState = true;\\n            }\\n            if(isThereDrawState)  {\\n                dp[m][c][turn] = DRAW;\\n                return DRAW;\\n            }\\n            else  {\\n                dp[m][c][turn] = MOUSE;\\n                return MOUSE;\\n            }\\n        }\\n    }\\n}\\n``",
                "solutionTags": [],
                "code": "class Solution {\\n    int MOUSE = 1;\\n    int CAT = 2;\\n    int DRAW = 0;\\n    int len;\\n    public int catMouseGame(int[][] graph) {\\n        len = graph.length;\\n        return dfs(1,2,0,graph,new Integer[len][len][2*len]);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 973483,
                "title": "python3-bottom-up-dp-bfs-beats-95-mathematical-formulation-of-minimax",
                "content": "**Bottom up, BFS**\\nA node is denoted as (x, y, t). Starting from (x, y), if t==0 it is mouse\\'s turn to move else cat\\'s turn to move. (y>0)\\n\\ndp(x, y, t) is the profit gain of the mouse:\\nMouse node: dp = +1, Cat node: dp = -1, Draw node: dp = 0.\\ndp(x, y) = max_{mouse} min_{cat} dp(mouse(x), cat(y)), where x\\' = mouse(x), y\\' = cat(y) are respectively a possible movement of mouse and cat from (x, y).\\n\\nTotally N^2*2 nodes represented as\\n```\\nt=0\\n  y\\nx * * * * \\n  * * * *\\n  * * * *\\n  * * * *\\nt=1\\n  y\\nx * * * * \\n  * * * *\\n  * * * *\\n  * * * * \\n```\\n\\ndp(x, y) = max_{mouse} min_{cat} dp(mouse(x), cat(y))\\n\\n**Definitions and proof:**\\nA Mouse t=0 node (x, y, t=0) is defined: there exist x\\'=mouse(x), s.t. (x\\', y, t=1) is Mouse node, i.e. for any y\\'=cat(y), (x\\', y\\', t=0) is Mouse node. [dp(x, y, t=0) = +1.]\\nA Cat t=0 node is defined: (x, y, t=0) any x\\'=mouse(x), s.t. (x\\', y, t=1) is Cat node (max({-1,-1...}) = -1), i.e. exist y\\' = cat(y), s.t. (x\\', y\\', t=0) is Cat node. [dp(x, y, t=0) = -1.]\\n\\nIf (x, y, t=0) is not Mouse, max{m}min{c} < 1, any x\\', exist y\\', s.t. dp(x\\', y\\', t=0) < 1.  \\nIf (x, y, t=0) is not Cat, max{m}min{c} > -1, exist x\\', s.t. any y\\', dp(x\\', y\\', t=0) > -1.\\nSo -1 < max{m}min{c} < 1, so dp(x, y, t=0) = 0 is surely Draw.\\n**QED**\\n\\nAlong bottom up, the base are\\n(0, y, t) = Mouse\\n(y, y, t) = Cat (y>0)\\n\\nThe relation above defines a bipartite graph between t=0 nodes and t=1 nodes. The edges are along the reversed movement direction. For example,\\n*\"A t=1 Mouse node is defined: for any y\\', (x\\', y\\', t=0) is Mouse.\"*\\nA t=1 node is Mouse if all incoming t=1 nodes are Mouse. Indeg is used.\\nSo once (x, y, t=0) is Mouse -> (x, y\\' = nei(y), t=1) has one less indeg.\\n*\"A t=0 Mouse node is defined: (x, y, t=0) exist x\\' s.t. (x\\', y, t=1) is Mouse\"*\\nA t=0 node is Mouse if exist an incoming t=1 node which is Mouse.\\nSo once (x, y, t=1) is Mouse -> (x\\'=nei(x), y, t=0) is Mouse.\\n\\nEnque the already known Mouse or Cat nodes.\\n\\n**Algo.**\\nSearch for Mouse t=0 nodes.\\nFor t=1 node, if all the incoming t=0 nodes by movement of y are Mouse nodes, then n(t=1) = Mouse. So when indeg_y[n(t=1)] = 0, n(t=1) = Mouse.\\nFor t=0 node, if exist incoming t=1 node by movement of x, then n(t=0) = Mouse.\\n\\nSimilarly search for Cat t=0 nodes.\\nFor t=0 node, if all the incoming t=0 nodes by movement of y are Cat nodes, then n(t=0) = Mouse. So when indeg_y[n(t=0)] = 0, n(t=0) = Cat.\\nFor t=1 node, if exist incoming t=0 node by movement of x, then n(t=1) = Cat.\\n\\nBFS bottom-up, mark all the Mouse and Cat nodes. The leftovers are surely Draw nodes.\\n\\nStore the result in hashmap, which is initialized to be Draw nodes. \\n{0: Draw, 1: Mouse, -1: Cat}\\n{t=0: Mouse move, t=1: Cat move}\\n\\n```\\nclass Solution:\\n    def catMouseGame(self, graph):\\n        N = len(graph)\\n        state = (1, 2, 0) # not in the initial queue\\n        Mouse, Cat, Draw = 1, 2, 0\\n        hashmap = defaultdict(int) # store the final result and deduplicate\\n        q = deque()\\n        q2 = deque()\\n        for n in range(1, N):\\n            hashmap[n,n,0] = Cat\\n            hashmap[n,n,1] = Cat\\n            hashmap[0,n,0] = Mouse\\n            hashmap[0,n,1] = Mouse\\n            q.append((0, n, 0)) # Mouse nodes\\n            q.append((0, n, 1)) # Mouse nodes\\n            q2.append((n, n, 0)) # Cat nodes\\n            q2.append((n, n, 1)) # Cat nodes\\n\\n        def nei(vertex, ismouse):\\n            return tuple(v for v in graph[vertex] if ismouse or v != 0)\\n\\n        indeg = defaultdict(int) # used for search of Mouse nodes\\n        for x in range(N):\\n            for y in range(1, N):\\n                t = 1\\n                indeg[x, y, t] = len(nei(y, False))\\n                \\n        indeg2 = defaultdict(int) # used for search of Cat nodes\\n        for x in range(N):\\n            for y in range(1, N):\\n                t = 0\\n                indeg2[x, y, t] = len(nei(x, True))\\n        \\n\\t\\t# Search for Mouse nodes\\n        while q:\\n            qsize = len(q)\\n            for _ in range(qsize):\\n                x, y, t = q.popleft()\\n\\n                if t == 1:\\n                    # x movement t=0 neighbors\\n                    for x_next in nei(x, True):\\n                        node = (x_next, y, 0)\\n                        if hashmap[node] == Draw:\\n                            hashmap[node] = Mouse\\n                            q.append(node)\\n                            if state == node:\\n                                return Mouse\\n                        \\n                elif t == 0:\\n                    # y movement t=1 neighbors\\n                    for y_next in nei(y, False):\\n                        node = (x, y_next, 1)\\n                        indeg[node] -= 1\\n                        if indeg[node] == 0 and hashmap[node] == Draw:\\n                            hashmap[node] = Mouse\\n                            q.append(node)\\n                            if state == node:\\n                                return Mouse\\n\\t\\t\\n\\t\\t# Search for Cat nodes.\\n        q = q2\\n        indeg = indeg2\\n        while q:\\n            qsize = len(q)\\n            for _ in range(qsize):\\n                x, y, t = q.popleft()\\n\\n                if t == 0:\\n                    # y movement t=1 neighbors\\n                    for y_next in nei(y, False):\\n                        node = (x, y_next, 1)\\n                        if hashmap[node] == Draw:\\n                            hashmap[node] = Cat\\n                            q.append(node) \\n                            if state == node:\\n                                return Cat\\n                            \\n                elif t == 1:\\n                    # x movement t=0 neighbors\\n                    for x_next in nei(x, True):\\n                        node = (x_next, y, 0)\\n                        indeg[node] -= 1\\n                        if indeg[node] == 0 and hashmap[node] == Draw:\\n                            hashmap[node] = Cat\\n                            q.append(node)\\n                            if state == node:\\n                                return Cat\\n                                \\n        return Draw\\n```\\n\\nT = O(N^2) nodes * O(N) neighbors = O(N^3)\\nS = O(N^2)\\n\\n",
                "solutionTags": [],
                "code": "```\\nt=0\\n  y\\nx * * * * \\n  * * * *\\n  * * * *\\n  * * * *\\nt=1\\n  y\\nx * * * * \\n  * * * *\\n  * * * *\\n  * * * * \\n```\n```\\nclass Solution:\\n    def catMouseGame(self, graph):\\n        N = len(graph)\\n        state = (1, 2, 0) # not in the initial queue\\n        Mouse, Cat, Draw = 1, 2, 0\\n        hashmap = defaultdict(int) # store the final result and deduplicate\\n        q = deque()\\n        q2 = deque()\\n        for n in range(1, N):\\n            hashmap[n,n,0] = Cat\\n            hashmap[n,n,1] = Cat\\n            hashmap[0,n,0] = Mouse\\n            hashmap[0,n,1] = Mouse\\n            q.append((0, n, 0)) # Mouse nodes\\n            q.append((0, n, 1)) # Mouse nodes\\n            q2.append((n, n, 0)) # Cat nodes\\n            q2.append((n, n, 1)) # Cat nodes\\n\\n        def nei(vertex, ismouse):\\n            return tuple(v for v in graph[vertex] if ismouse or v != 0)\\n\\n        indeg = defaultdict(int) # used for search of Mouse nodes\\n        for x in range(N):\\n            for y in range(1, N):\\n                t = 1\\n                indeg[x, y, t] = len(nei(y, False))\\n                \\n        indeg2 = defaultdict(int) # used for search of Cat nodes\\n        for x in range(N):\\n            for y in range(1, N):\\n                t = 0\\n                indeg2[x, y, t] = len(nei(x, True))\\n        \\n\\t\\t# Search for Mouse nodes\\n        while q:\\n            qsize = len(q)\\n            for _ in range(qsize):\\n                x, y, t = q.popleft()\\n\\n                if t == 1:\\n                    # x movement t=0 neighbors\\n                    for x_next in nei(x, True):\\n                        node = (x_next, y, 0)\\n                        if hashmap[node] == Draw:\\n                            hashmap[node] = Mouse\\n                            q.append(node)\\n                            if state == node:\\n                                return Mouse\\n                        \\n                elif t == 0:\\n                    # y movement t=1 neighbors\\n                    for y_next in nei(y, False):\\n                        node = (x, y_next, 1)\\n                        indeg[node] -= 1\\n                        if indeg[node] == 0 and hashmap[node] == Draw:\\n                            hashmap[node] = Mouse\\n                            q.append(node)\\n                            if state == node:\\n                                return Mouse\\n\\t\\t\\n\\t\\t# Search for Cat nodes.\\n        q = q2\\n        indeg = indeg2\\n        while q:\\n            qsize = len(q)\\n            for _ in range(qsize):\\n                x, y, t = q.popleft()\\n\\n                if t == 0:\\n                    # y movement t=1 neighbors\\n                    for y_next in nei(y, False):\\n                        node = (x, y_next, 1)\\n                        if hashmap[node] == Draw:\\n                            hashmap[node] = Cat\\n                            q.append(node) \\n                            if state == node:\\n                                return Cat\\n                            \\n                elif t == 1:\\n                    # x movement t=0 neighbors\\n                    for x_next in nei(x, True):\\n                        node = (x_next, y, 0)\\n                        indeg[node] -= 1\\n                        if indeg[node] == 0 and hashmap[node] == Draw:\\n                            hashmap[node] = Cat\\n                            q.append(node)\\n                            if state == node:\\n                                return Cat\\n                                \\n        return Draw\\n```",
                "codeTag": "Java"
            },
            {
                "id": 559977,
                "title": "python-bfs-solution",
                "content": "```\\nclass Solution:\\n    def catMouseGame(self, graph: List[List[int]]) -> int:\\n        n = len(graph)\\n\\t\\t\\n\\t\\t# dp[mouse_loc][cat_loc][which_one_moves_first]\\n        # third index 0 mouse moves first\\n        # third index 1 cat moves first\\n        dp = [[[None,None] for j in range(n)] for i in range(n)]\\n        \\n\\t\\t# same structure as dp to count the neighboring moves that makes current player lose\\n        # if count down goes to 0, then we can decide current move to be a lose for certain\\n        cd = [[[len(graph[i]),len(graph[j])] for j in range(n)] for i in range(n)]\\n        \\n        \\n        q = deque()\\n        \\n        # if a mouse arrives at hole, win for mouse\\n        for cat_index in range(1,n):\\n            dp[0][cat_index][0] = \\'M\\'\\n            q.append((0,cat_index,0))\\n            dp[0][cat_index][1] = \\'M\\'\\n            q.append((0,cat_index,1))\\n        \\n        # if a cat catches a mouse, win for cat\\n        for index in range(1,n):\\n            dp[index][index][0] = \\'C\\'\\n            q.append((index,index,0))\\n            dp[index][index][1] = \\'C\\'\\n            q.append((index,index,1))\\n        \\n        # cat can\\'t go in at hole, regard it as lose for cat\\n        for mouse_index in range(1,n):\\n            dp[mouse_index][0][0] = \\'M\\'\\n            q.append((mouse_index,0,0))\\n            dp[mouse_index][0][1] = \\'M\\'\\n            q.append((mouse_index,0,1))\\n        \\n        \\n        while q:\\n            #print(q)\\n            mouse_loc,cat_loc,move = q.popleft()\\n            cur_move = \\'mouse\\' if move == 0 else \\'cat\\'\\n            \\n            # if previous move is mouse and current state is a win for mouse\\n            if cur_move == \\'cat\\' and dp[mouse_loc][cat_loc][move] == \\'M\\':\\n                for mouse_prev in graph[mouse_loc]:\\n                    if dp[mouse_prev][cat_loc][0] == None:\\n                        dp[mouse_prev][cat_loc][0] = \\'M\\'\\n                        q.append((mouse_prev,cat_loc,0))\\n            \\n            # if previous move is mouse and current state is a lose for mouse\\n            elif cur_move == \\'cat\\' and dp[mouse_loc][cat_loc][move] == \\'C\\':\\n                for mouse_prev in graph[mouse_loc]:\\n                    cd[mouse_prev][cat_loc][0] -=1\\n                    if cd[mouse_prev][cat_loc][0] == 0 and dp[mouse_prev][cat_loc][0] == None:\\n                        dp[mouse_prev][cat_loc][0] = \\'C\\'\\n                        q.append((mouse_prev,cat_loc,0))\\n            \\n            # if previous move is cat and current state is a win for cat\\n            elif cur_move == \\'mouse\\' and dp[mouse_loc][cat_loc][move] == \\'C\\':\\n                for cat_prev in graph[cat_loc]:\\n                    if dp[mouse_loc][cat_prev][1] == None:\\n                        dp[mouse_loc][cat_prev][1] = \\'C\\'\\n                        q.append((mouse_loc,cat_prev, 1))\\n            \\n            # if previous move is car and current state is a lose for cat\\n            elif cur_move == \\'mouse\\' and dp[mouse_loc][cat_loc][move] == \\'M\\':\\n                for cat_prev in graph[cat_loc]:\\n                    cd[mouse_loc][cat_prev][1] -=1\\n                    if cd[mouse_loc][cat_prev][1] == 0 and dp[mouse_loc][cat_prev][1] == None:\\n                        dp[mouse_loc][cat_prev][1] = \\'M\\'\\n                        q.append((mouse_loc,cat_prev,1))\\n                        \\n        \\n        if dp[1][2][0] == \\'C\\':\\n            return 2\\n        elif dp[1][2][0] == \\'M\\':\\n            return 1\\n        elif dp[1][2][0] == None:\\n            return 0\\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def catMouseGame(self, graph: List[List[int]]) -> int:\\n        n = len(graph)\\n\\t\\t\\n\\t\\t# dp[mouse_loc][cat_loc][which_one_moves_first]\\n        # third index 0 mouse moves first\\n        # third index 1 cat moves first\\n        dp = [[[None,None] for j in range(n)] for i in range(n)]\\n        \\n\\t\\t# same structure as dp to count the neighboring moves that makes current player lose\\n        # if count down goes to 0, then we can decide current move to be a lose for certain\\n        cd = [[[len(graph[i]),len(graph[j])] for j in range(n)] for i in range(n)]\\n        \\n        \\n        q = deque()\\n        \\n        # if a mouse arrives at hole, win for mouse\\n        for cat_index in range(1,n):\\n            dp[0][cat_index][0] = \\'M\\'\\n            q.append((0,cat_index,0))\\n            dp[0][cat_index][1] = \\'M\\'\\n            q.append((0,cat_index,1))\\n        \\n        # if a cat catches a mouse, win for cat\\n        for index in range(1,n):\\n            dp[index][index][0] = \\'C\\'\\n            q.append((index,index,0))\\n            dp[index][index][1] = \\'C\\'\\n            q.append((index,index,1))\\n        \\n        # cat can\\'t go in at hole, regard it as lose for cat\\n        for mouse_index in range(1,n):\\n            dp[mouse_index][0][0] = \\'M\\'\\n            q.append((mouse_index,0,0))\\n            dp[mouse_index][0][1] = \\'M\\'\\n            q.append((mouse_index,0,1))\\n        \\n        \\n        while q:\\n            #print(q)\\n            mouse_loc,cat_loc,move = q.popleft()\\n            cur_move = \\'mouse\\' if move == 0 else \\'cat\\'\\n            \\n            # if previous move is mouse and current state is a win for mouse\\n            if cur_move == \\'cat\\' and dp[mouse_loc][cat_loc][move] == \\'M\\':\\n                for mouse_prev in graph[mouse_loc]:\\n                    if dp[mouse_prev][cat_loc][0] == None:\\n                        dp[mouse_prev][cat_loc][0] = \\'M\\'\\n                        q.append((mouse_prev,cat_loc,0))\\n            \\n            # if previous move is mouse and current state is a lose for mouse\\n            elif cur_move == \\'cat\\' and dp[mouse_loc][cat_loc][move] == \\'C\\':\\n                for mouse_prev in graph[mouse_loc]:\\n                    cd[mouse_prev][cat_loc][0] -=1\\n                    if cd[mouse_prev][cat_loc][0] == 0 and dp[mouse_prev][cat_loc][0] == None:\\n                        dp[mouse_prev][cat_loc][0] = \\'C\\'\\n                        q.append((mouse_prev,cat_loc,0))\\n            \\n            # if previous move is cat and current state is a win for cat\\n            elif cur_move == \\'mouse\\' and dp[mouse_loc][cat_loc][move] == \\'C\\':\\n                for cat_prev in graph[cat_loc]:\\n                    if dp[mouse_loc][cat_prev][1] == None:\\n                        dp[mouse_loc][cat_prev][1] = \\'C\\'\\n                        q.append((mouse_loc,cat_prev, 1))\\n            \\n            # if previous move is car and current state is a lose for cat\\n            elif cur_move == \\'mouse\\' and dp[mouse_loc][cat_loc][move] == \\'M\\':\\n                for cat_prev in graph[cat_loc]:\\n                    cd[mouse_loc][cat_prev][1] -=1\\n                    if cd[mouse_loc][cat_prev][1] == 0 and dp[mouse_loc][cat_prev][1] == None:\\n                        dp[mouse_loc][cat_prev][1] = \\'M\\'\\n                        q.append((mouse_loc,cat_prev,1))\\n                        \\n        \\n        if dp[1][2][0] == \\'C\\':\\n            return 2\\n        elif dp[1][2][0] == \\'M\\':\\n            return 1\\n        elif dp[1][2][0] == None:\\n            return 0\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 178113,
                "title": "dfs-thoughts",
                "content": "most of the DFS in the discussion here seems wrong, however this one looks valid, at least among the test cases I\\'ve seen. \\nhttps://www.acwing.com/solution/leetcode/content/556/\\nI also did a java translation for it, it seems correct for the cases I\\'ve tested. \\n```\\nclass Solution {\\n   private static int DRAW = 1, MOUSE_WIN = 2, CAT_WIN = 3;\\n    public int catMouseGame(int[][] graph) {\\n        return dfs(new int[graph.length+1][graph.length][graph.length], 0, graph, 1, 2)-1;\\n    }\\n\\n    public int dfs(int[][][] alltable, int level, int[][] graph, int mousepos, int catpos) {\\n        if(level == graph.length + 1) {\\n            return DRAW;\\n        }\\n\\n        if(alltable[level][mousepos][catpos] != 0) return alltable[level][mousepos][catpos];\\n        if(catpos == mousepos) {\\n            alltable[level][mousepos][catpos] = CAT_WIN;\\n            return CAT_WIN;\\n        }\\n        if(mousepos == 0) {\\n            alltable[level][mousepos][catpos] = MOUSE_WIN;\\n            return MOUSE_WIN;\\n        }\\n        if(level%2 == 0) {\\n            boolean hasdraw = false;\\n            for(int next: graph[mousepos]) {\\n                int oneret = dfs(alltable, level+1, graph, next, catpos);\\n                if(oneret == MOUSE_WIN) {\\n                    alltable[level][mousepos][catpos] = MOUSE_WIN;\\n                    return MOUSE_WIN;\\n                }\\n                else if(oneret == DRAW) {\\n                    hasdraw = true;\\n                }\\n            }\\n            int ret = hasdraw ? DRAW : CAT_WIN;\\n            alltable[level][mousepos][catpos] = ret;\\n            return ret;\\n        }\\n        else {\\n            boolean hasdraw = false;\\n            for(int next: graph[catpos]) {\\n                if(next == 0) continue;\\n                int oneret = dfs(alltable, level+1, graph, mousepos, next);\\n                if(oneret == CAT_WIN) {\\n                    alltable[level][mousepos][catpos] = CAT_WIN;\\n                    return CAT_WIN;\\n                }\\n                else if(oneret == DRAW) {\\n                    hasdraw = true;\\n                }\\n            }\\n            int ret = hasdraw ? DRAW: MOUSE_WIN;\\n            alltable[level][mousepos][catpos] = ret;\\n            return ret;\\n        }\\n    }\\n}\\n```\\n\\nHowever I am still confused why the table needs to be at each level, my understanding is that <turn, mousepos, catpos> will decide the result anyway, it doesn\\'t matter which level it is, \\nbut when I change the code to below, it will fail some test cases. my understanding is even though the recursion may re-visit a parent node, for any node, it will not set the value unless all possible next steps are searched.  \\nwhy would there be a difference? \\n\\n```\\nclass Solution {\\n   private static int DRAW = 1, MOUSE_WIN = 2, CAT_WIN = 3;\\n    public int catMouseGame(int[][] graph) {\\n        return dfs(new int[2][graph.length][graph.length], 0, graph, 1, 2)-1;\\n    }\\n\\n    public int dfs(int[][][] alltable, int level, int[][] graph, int mousepos, int catpos) {\\n        if(level == graph.length + 1) {\\n            return DRAW;\\n        }\\n\\n        int[][] table = alltable[level%2];\\n\\n        if(table[mousepos][catpos] != 0) return table[mousepos][catpos];\\n        if(catpos == mousepos) {\\n            table[mousepos][catpos] = CAT_WIN;\\n            return CAT_WIN;\\n        }\\n        if(mousepos == 0) {\\n            table[mousepos][catpos] = MOUSE_WIN;\\n            return MOUSE_WIN;\\n        }\\n        if(level%2 == 0) {\\n            boolean hasdraw = false;\\n            for(int next: graph[mousepos]) {\\n                int oneret = dfs(alltable, level+1, graph, next, catpos);\\n                if(oneret == MOUSE_WIN) {\\n                    table[mousepos][catpos] = MOUSE_WIN;\\n                    return MOUSE_WIN;\\n                }\\n                else if(oneret == DRAW) {\\n                    hasdraw = true;\\n                }\\n            }\\n            int ret = hasdraw ? DRAW : CAT_WIN;\\n            table[mousepos][catpos] = ret;\\n            return ret;\\n        }\\n        else {\\n            boolean hasdraw = false;\\n            for(int next: graph[catpos]) {\\n                if(next == 0) continue;\\n                int oneret = dfs(alltable, level+1, graph, mousepos, next);\\n                if(oneret == CAT_WIN) {\\n                    table[mousepos][catpos] = CAT_WIN;\\n                    return CAT_WIN;\\n                }\\n                else if(oneret == DRAW) {\\n                    hasdraw = true;\\n                }\\n            }\\n            int ret = hasdraw ? DRAW: MOUSE_WIN;\\n            table[mousepos][catpos] = ret;\\n            return ret;\\n\\n        }\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   private static int DRAW = 1, MOUSE_WIN = 2, CAT_WIN = 3;\\n    public int catMouseGame(int[][] graph) {\\n        return dfs(new int[graph.length+1][graph.length][graph.length], 0, graph, 1, 2)-1;\\n    }\\n\\n    public int dfs(int[][][] alltable, int level, int[][] graph, int mousepos, int catpos) {\\n        if(level == graph.length + 1) {\\n            return DRAW;\\n        }\\n\\n        if(alltable[level][mousepos][catpos] != 0) return alltable[level][mousepos][catpos];\\n        if(catpos == mousepos) {\\n            alltable[level][mousepos][catpos] = CAT_WIN;\\n            return CAT_WIN;\\n        }\\n        if(mousepos == 0) {\\n            alltable[level][mousepos][catpos] = MOUSE_WIN;\\n            return MOUSE_WIN;\\n        }\\n        if(level%2 == 0) {\\n            boolean hasdraw = false;\\n            for(int next: graph[mousepos]) {\\n                int oneret = dfs(alltable, level+1, graph, next, catpos);\\n                if(oneret == MOUSE_WIN) {\\n                    alltable[level][mousepos][catpos] = MOUSE_WIN;\\n                    return MOUSE_WIN;\\n                }\\n                else if(oneret == DRAW) {\\n                    hasdraw = true;\\n                }\\n            }\\n            int ret = hasdraw ? DRAW : CAT_WIN;\\n            alltable[level][mousepos][catpos] = ret;\\n            return ret;\\n        }\\n        else {\\n            boolean hasdraw = false;\\n            for(int next: graph[catpos]) {\\n                if(next == 0) continue;\\n                int oneret = dfs(alltable, level+1, graph, mousepos, next);\\n                if(oneret == CAT_WIN) {\\n                    alltable[level][mousepos][catpos] = CAT_WIN;\\n                    return CAT_WIN;\\n                }\\n                else if(oneret == DRAW) {\\n                    hasdraw = true;\\n                }\\n            }\\n            int ret = hasdraw ? DRAW: MOUSE_WIN;\\n            alltable[level][mousepos][catpos] = ret;\\n            return ret;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n   private static int DRAW = 1, MOUSE_WIN = 2, CAT_WIN = 3;\\n    public int catMouseGame(int[][] graph) {\\n        return dfs(new int[2][graph.length][graph.length], 0, graph, 1, 2)-1;\\n    }\\n\\n    public int dfs(int[][][] alltable, int level, int[][] graph, int mousepos, int catpos) {\\n        if(level == graph.length + 1) {\\n            return DRAW;\\n        }\\n\\n        int[][] table = alltable[level%2];\\n\\n        if(table[mousepos][catpos] != 0) return table[mousepos][catpos];\\n        if(catpos == mousepos) {\\n            table[mousepos][catpos] = CAT_WIN;\\n            return CAT_WIN;\\n        }\\n        if(mousepos == 0) {\\n            table[mousepos][catpos] = MOUSE_WIN;\\n            return MOUSE_WIN;\\n        }\\n        if(level%2 == 0) {\\n            boolean hasdraw = false;\\n            for(int next: graph[mousepos]) {\\n                int oneret = dfs(alltable, level+1, graph, next, catpos);\\n                if(oneret == MOUSE_WIN) {\\n                    table[mousepos][catpos] = MOUSE_WIN;\\n                    return MOUSE_WIN;\\n                }\\n                else if(oneret == DRAW) {\\n                    hasdraw = true;\\n                }\\n            }\\n            int ret = hasdraw ? DRAW : CAT_WIN;\\n            table[mousepos][catpos] = ret;\\n            return ret;\\n        }\\n        else {\\n            boolean hasdraw = false;\\n            for(int next: graph[catpos]) {\\n                if(next == 0) continue;\\n                int oneret = dfs(alltable, level+1, graph, mousepos, next);\\n                if(oneret == CAT_WIN) {\\n                    table[mousepos][catpos] = CAT_WIN;\\n                    return CAT_WIN;\\n                }\\n                else if(oneret == DRAW) {\\n                    hasdraw = true;\\n                }\\n            }\\n            int ret = hasdraw ? DRAW: MOUSE_WIN;\\n            table[mousepos][catpos] = ret;\\n            return ret;\\n\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 175961,
                "title": "4ms-c-self-explanatory-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int calc(int curM, int curC, int isM, vector<vector<vector<int>>>& dp, vector<vector<int>>& graph) {\\n        if(curC==0 || curM==0)\\n            return 1;\\n        if(curC==curM)\\n            return 2;\\n        if(dp[curM][curC][isM]!=-1) {\\n            return dp[curM][curC][isM];\\n        }\\n        dp[curM][curC][isM]=0;\\n        bool canDraw=false;\\n        if(isM) {\\n            for(int i=0;i<graph[curM].size();i++) {     //If any neigbor is 0 return 1\\n                if(graph[curM][i]==0) {\\n                    dp[curM][curC][isM]=1;\\n                    return 1;\\n                }\\n            }\\n            for(int i=0;i<graph[curM].size();i++) {\\n                int temp=calc(graph[curM][i], curC, 0, dp, graph);\\n                if(temp==1) {\\n                    dp[curM][curC][isM]=1;\\n                    return 1;\\n                }\\n                else if(temp==0) {\\n                    canDraw=true;\\n                }\\n            }\\n            if(!canDraw)\\n                dp[curM][curC][isM]=2;\\n        }\\n        else {\\n            for(int i=0;i<graph[curC].size();i++) {     //If any neighbor is current pos of mouse return 2\\n                if(graph[curC][i]==curM) {\\n                    dp[curM][curC][isM]=2;\\n                    return 2;\\n                }\\n            }\\n            for(int i=0;i<graph[curC].size();i++) {\\n                int temp=calc(curM, graph[curC][i], 1, dp, graph);\\n                if(temp==2) {\\n                    dp[curM][curC][isM]=2;\\n                    return 2;\\n                }\\n                else if(temp==0) {\\n                    canDraw=true;\\n                }\\n            }\\n            if(!canDraw)\\n                dp[curM][curC][isM]=1;\\n        }\\n        return dp[curM][curC][isM];\\n    }\\n    \\n    int catMouseGame(vector<vector<int>>& graph) {\\n        int n=graph.size();\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>(2, -1)));\\n        return calc(1, 2, 1, dp, graph);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int calc(int curM, int curC, int isM, vector<vector<vector<int>>>& dp, vector<vector<int>>& graph) {\\n        if(curC==0 || curM==0)\\n            return 1;\\n        if(curC==curM)\\n            return 2;\\n        if(dp[curM][curC][isM]!=-1) {\\n            return dp[curM][curC][isM];\\n        }\\n        dp[curM][curC][isM]=0;\\n        bool canDraw=false;\\n        if(isM) {\\n            for(int i=0;i<graph[curM].size();i++) {     //If any neigbor is 0 return 1\\n                if(graph[curM][i]==0) {\\n                    dp[curM][curC][isM]=1;\\n                    return 1;\\n                }\\n            }\\n            for(int i=0;i<graph[curM].size();i++) {\\n                int temp=calc(graph[curM][i], curC, 0, dp, graph);\\n                if(temp==1) {\\n                    dp[curM][curC][isM]=1;\\n                    return 1;\\n                }\\n                else if(temp==0) {\\n                    canDraw=true;\\n                }\\n            }\\n            if(!canDraw)\\n                dp[curM][curC][isM]=2;\\n        }\\n        else {\\n            for(int i=0;i<graph[curC].size();i++) {     //If any neighbor is current pos of mouse return 2\\n                if(graph[curC][i]==curM) {\\n                    dp[curM][curC][isM]=2;\\n                    return 2;\\n                }\\n            }\\n            for(int i=0;i<graph[curC].size();i++) {\\n                int temp=calc(curM, graph[curC][i], 1, dp, graph);\\n                if(temp==2) {\\n                    dp[curM][curC][isM]=2;\\n                    return 2;\\n                }\\n                else if(temp==0) {\\n                    canDraw=true;\\n                }\\n            }\\n            if(!canDraw)\\n                dp[curM][curC][isM]=1;\\n        }\\n        return dp[curM][curC][isM];\\n    }\\n    \\n    int catMouseGame(vector<vector<int>>& graph) {\\n        int n=graph.size();\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>(2, -1)));\\n        return calc(1, 2, 1, dp, graph);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 175959,
                "title": "share-my-thoughts-and-code-so-confused-by-the-last-case",
                "content": "In the analysis I wrote earlier, I solve this problem by two steps:\\n1. using bfs to compare the distance to the hole, if mouse are closer than cat, we return 1\\n2. if not, I think it will be a draw if mouse can escape in a circle. \\n\\nBoth of two steps need to consider many detail problem, maybe I have to admit that this is not a good idea.\\n\\nFirstly, I use l1[i] to store the distance between 1 to i, and l2[i] to store the distance between 2 to i. However, cat cannot go through the hole `0`, so `l2[0] = inf`. In this way, we can\\'t directly compare the distance to 0, otherwise it will always be `l1[0] < l2[0]`. So I choose to compare the node in graph[0]. For some nodes, the cat may be cannot arrive because of the hole, so these l2[node] should all be inf.(same as the mouse) \\n```python\\ndef bfs(root,l,flag):\\n    Q = collections.deque([root])\\n    visited = set([root])\\n    dis = 0\\n    while Q:\\n        for i in range(len(Q)):\\n            node = Q.popleft()\\n            l[node] = dis\\n            for v in graph[node]:\\n                # cat cannot go through 0\\n                if flag == 2 and v == 0: continue\\n                # mouse cannot go through 2\\n                if flag == 1 and v == 2: continue\\n                if v not in visited:\\n                    Q.append(v)\\n                    visited.add(v)\\n        dis += 1\\nn = len(graph)\\nl1 = [float(\\'inf\\')] * n\\nl2 = [float(\\'inf\\')] * n\\nbfs(1,l1,1)\\nbfs(2,l2,2)\\nif any(l1[val]<l2[val] for val in graph[0]): return 1\\n```\\n\\nIf mouse cannot escape, it should find a circle. for each node in circle, if any l1[node] < l2[node], it will be draw!\\nbut the node in circle cannot include the hole `0`(cat cannot arrive) and itself `1`(mouse must move).\\nI use dfs to get all nodes in circle, last time I got TLE because I forgot to jump the node which is already in circle.\\n```python\\ncircle = [] # len(circle) < 50\\ndef dfs(node,path,circle):\\n    for v in graph[node]:\\n        if v in circle: continue\\n        if v in path: # maybe a circle\\n            if v == path[-2]: # circle cannot be length 2\\n                continue\\n            else:\\n                index = path.index(v)\\n                circle.extend(path[index:])\\n        else:\\n            dfs(v, path+[v], circle)\\n\\nfor i in range(len(graph)):\\n    if i in circle: continue\\n    dfs(i,[i],circle)\\n    circle = list(set(circle)) # ganrantee len(circle) < 50\\n# escape to a circle\\nif any(l1[val] < l2[val] for val in circle if val != 1 and val != 0): return 0\\n# be catched\\nreturn 2\\n```\\n\\nNow, my code is 43/44 passed. For the test case, I got a WA, expected 1, my answer is 0\\n[[3,4,6,7,9,15,16,18],[4,5,8,19],[4,5,6,7,9,18],[0,10,11,15],[0,1,2,6,10,12,14,16],[1,2,7,9,15,17,18],[0,2,4,7,9,10,11,12,13,14,15,17,19],[0,2,5,6,9,16,17],[1,9,14,15,16,19],[0,2,5,6,7,8,10,11,13,15,16,17,18],[3,4,6,9,17,18],[3,6,9,12,19],[4,6,11,15,17,19],[6,9,15,17,18,19],[4,6,8,15,19],[0,3,5,6,8,9,12,13,14,16,19],[0,4,7,8,9,15,17,18,19],[5,6,7,9,10,12,13,16],[0,2,5,9,10,13,16],[1,6,8,11,12,13,14,15,16]]\\n\\nI print l1 and l2. I didn\\'t find out the path from which the mouse can escape to the hole. Can anyone help me?\\nl1 = [2, 0, inf, 3, 1, 1, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1]\\nl2 = [inf, 2, 0, 3, 1, 1, 1, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2]\\n",
                "solutionTags": [],
                "code": "```python\\ndef bfs(root,l,flag):\\n    Q = collections.deque([root])\\n    visited = set([root])\\n    dis = 0\\n    while Q:\\n        for i in range(len(Q)):\\n            node = Q.popleft()\\n            l[node] = dis\\n            for v in graph[node]:\\n                # cat cannot go through 0\\n                if flag == 2 and v == 0: continue\\n                # mouse cannot go through 2\\n                if flag == 1 and v == 2: continue\\n                if v not in visited:\\n                    Q.append(v)\\n                    visited.add(v)\\n        dis += 1\\nn = len(graph)\\nl1 = [float(\\'inf\\')] * n\\nl2 = [float(\\'inf\\')] * n\\nbfs(1,l1,1)\\nbfs(2,l2,2)\\nif any(l1[val]<l2[val] for val in graph[0]): return 1\\n```\n```python\\ncircle = [] # len(circle) < 50\\ndef dfs(node,path,circle):\\n    for v in graph[node]:\\n        if v in circle: continue\\n        if v in path: # maybe a circle\\n            if v == path[-2]: # circle cannot be length 2\\n                continue\\n            else:\\n                index = path.index(v)\\n                circle.extend(path[index:])\\n        else:\\n            dfs(v, path+[v], circle)\\n\\nfor i in range(len(graph)):\\n    if i in circle: continue\\n    dfs(i,[i],circle)\\n    circle = list(set(circle)) # ganrantee len(circle) < 50\\n# escape to a circle\\nif any(l1[val] < l2[val] for val in circle if val != 1 and val != 0): return 0\\n# be catched\\nreturn 2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2936339,
                "title": "913-cat-and-mouse-memoization-java-working-at-1400ms",
                "content": "Working approach at 1500ms with 6.17% performance usind 4d DP.\\n1. We will try to solve this problem using recursion, later on we can add memoization to reduce complexity.\\n2. For each state, we have 4 dimensions i.e mouse for mouse location node, cat is the node at which cat is present, turn is either 0 or 1 if the it is mouse or cat\\'s turn respectively and totalTurns represent the total numbers of turns taken till now. For 1 movement of mouse and then its cat, we have 1 complete turn.\\n3. If current turn is of mouse, then it will try to win or return 1, it that is not possible then it will atleast try to draw the game. But if draw is also not possible then it will let cat win.\\n4. If current turn is of cat, then it will try to win the game or return 2, if that is not possible, then it will try to draw the game if that is also not possible, then let mouse win.\\n5. Now, discuss end cases to end the recursion.\\n    5.1. If all the nodes of graph are visited by both mouse or cat, and still result is not found, then we can draw the game. I know it is not easy to get this test case but we have to add it otherwise it will fail for some cases. I have used 3*graph.length which is working fine. For values greater than 3, code is working but it is taking more time and for 2 it has failed for a test case.\\n    5.2. When mouse is at node 1, and cat is at node 2 and it is mouse turn just like beginning and totalTurns is greater than 0, then we can return 0 as everything is same as beginning.\\n    5.3. If mouse is at node 0 and it is cat\\'s turn, then mouse is already won. So, return 1.\\n    5.4. If it is mouse turn and cat is already at mouse location. Cat has eaten the mouse and cat has won.\\n6. Finally, we can add memoization to make the code work for lengthy testcases.\\n\\nNote - This problem is based on minimax principle and we can also refer a better problem (link - https://cp-algorithms.com/game_theory/games_on_graphs.html) it is very famouse problem.\\n\\nAs, we can notice, that is a graph problem and end condition is not much defined if we use DP or DFS. But what if we start from the winning, loosing and draw conditions using some other approach as discussed in LeetCode official solution. Please refer that solution as it is much faster and better but not intuitive untill we have solved some problems like that.\\n\\n``` java\\nclass Solution {\\n    private Integer[][][][] dp;\\n    public int catMouseGame(int[][] graph) {\\n        int n = graph.length;\\n        dp = new Integer[n+1][n+1][2][3*n+1];\\n        return catMouseBothMove(graph, 1, 2, 0, 0);        \\n    }\\n    /*\\n    @turn : 0 - mouse, 1 - cat\\n    */\\n    private int catMouseBothMove(int[][] graph, int mouse, int cat, int turn, int totalTurns){\\n        // End Case - 1\\n        if(totalTurns == graph.length*3) return 0;\\n        // Check for draw, End case - 2\\n        if(mouse == 1 && cat == 2 && turn == 0 && totalTurns > 0) return 0;\\n        \\n        // Check if mouse wins or not, End case - 3\\n        if(mouse == 0 && turn == 1) return 1;\\n        \\n        // Check if cat wins or not, End case - 4\\n        if(turn == 0 && cat == mouse) return 2;\\n        if(dp[mouse][cat][turn][totalTurns] != null) return dp[mouse][cat][turn][totalTurns];\\n        int result;\\n        // If current turn is of mouse\\n        if(turn == 0){\\n            result = 2;\\n            for(int v : graph[mouse]){\\n                if(v != cat){\\n                    int res = catMouseBothMove(graph, v, cat, 1, totalTurns);\\n                    if(res == 1){\\n                        result = 1;\\n                        break;\\n                    }\\n                    if(res == 0){\\n                        result = 0;\\n                    } \\n                }\\n            }\\n        }\\n        // cat\\'s turn or turn is equal to 1\\n        else{\\n            result = 1;\\n            for(int v : graph[cat]){\\n                if(v != 0){\\n                    int res = catMouseBothMove(graph, mouse, v, 0, totalTurns+1);\\n                    if(res == 2){\\n                        result = 2;\\n                        break;\\n                    }\\n                    if(res == 0){\\n                        result = 0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[mouse][cat][turn][totalTurns] = result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Graph",
                    "Memoization"
                ],
                "code": "``` java\\nclass Solution {\\n    private Integer[][][][] dp;\\n    public int catMouseGame(int[][] graph) {\\n        int n = graph.length;\\n        dp = new Integer[n+1][n+1][2][3*n+1];\\n        return catMouseBothMove(graph, 1, 2, 0, 0);        \\n    }\\n    /*\\n    @turn : 0 - mouse, 1 - cat\\n    */\\n    private int catMouseBothMove(int[][] graph, int mouse, int cat, int turn, int totalTurns){\\n        // End Case - 1\\n        if(totalTurns == graph.length*3) return 0;\\n        // Check for draw, End case - 2\\n        if(mouse == 1 && cat == 2 && turn == 0 && totalTurns > 0) return 0;\\n        \\n        // Check if mouse wins or not, End case - 3\\n        if(mouse == 0 && turn == 1) return 1;\\n        \\n        // Check if cat wins or not, End case - 4\\n        if(turn == 0 && cat == mouse) return 2;\\n        if(dp[mouse][cat][turn][totalTurns] != null) return dp[mouse][cat][turn][totalTurns];\\n        int result;\\n        // If current turn is of mouse\\n        if(turn == 0){\\n            result = 2;\\n            for(int v : graph[mouse]){\\n                if(v != cat){\\n                    int res = catMouseBothMove(graph, v, cat, 1, totalTurns);\\n                    if(res == 1){\\n                        result = 1;\\n                        break;\\n                    }\\n                    if(res == 0){\\n                        result = 0;\\n                    } \\n                }\\n            }\\n        }\\n        // cat\\'s turn or turn is equal to 1\\n        else{\\n            result = 1;\\n            for(int v : graph[cat]){\\n                if(v != 0){\\n                    int res = catMouseBothMove(graph, mouse, v, 0, totalTurns+1);\\n                    if(res == 2){\\n                        result = 2;\\n                        break;\\n                    }\\n                    if(res == 0){\\n                        result = 0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[mouse][cat][turn][totalTurns] = result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2217351,
                "title": "solution-for-wrong-test-cases-the-post-you-are-searching-for-accepted",
                "content": "If you change your base condition to \\n```if(steps>=5*graph.size()) return dp[steps][mouse_pos][cat_pos]=0;```\\nand make sure to increase the 3d dp array size to approx. dp[505][60][60] , then it would work and pass all test cases( including new ones ).\\n\\nWhy It works?\\n\\nActually due to dfs cycles, your function returns that, answer is draw after searching for around 2 * nodes. However their is a winner which it can\\'t find due to early execution of the base case.\\n\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization",
                    "Game Theory"
                ],
                "code": "```if(steps>=5*graph.size()) return dp[steps][mouse_pos][cat_pos]=0;```",
                "codeTag": "Unknown"
            },
            {
                "id": 867013,
                "title": "javascript-minimax-percolate-solution-more-readable-comments-100-100",
                "content": "This is my Javascript translation of the official minimax/percolate solution from resolved states, with more descriptive variable names and comments. Time: `O(N^3)`, Memory: `O(N^2)`\\n\\nFaster than 100% and less memory than 100% of submitted Javascript solutions at time of posting.\\n\\n```\\nconst DRAW = 0;\\nconst MOUSE_TURN = 1;\\nconst CAT_TURN = 2;\\nconst MOUSE_WIN = 1;\\nconst CAT_WIN = 2;\\nconst HOLE_POS = 0;\\nconst MOUSE_START_POS = 1;\\nconst CAT_START_POS = 2;\\nconst MAX_GRAPH_SIZE = 50;\\n\\nvar catMouseGame = function (graph) {\\n  // winner[mouse][cat][turn] - Given game state, will return winner. Initializes to 0, or DRAW\\n  const winner = create3dArray(MAX_GRAPH_SIZE, MAX_GRAPH_SIZE, 3);\\n  // Given game state, returns number of child states (ie. subsequent game states) left to check\\n  const numChildren = create3dArray(MAX_GRAPH_SIZE, MAX_GRAPH_SIZE, 3);\\n\\n  // Initialize numChildren\\n  for (let mouse = 0; mouse < graph.length; mouse++) {\\n    for (let cat = 0; cat < graph.length; cat++) {\\n      numChildren[mouse][cat][MOUSE_TURN] = graph[mouse].length;\\n      numChildren[mouse][cat][CAT_TURN] = graph[cat].length;\\n\\n      // Cat cannot move to hole, so decrement # of cat moves by 1 if there\\'s a hole adjacent\\n      for (const node of graph[cat]) {\\n        if (node === HOLE_POS) {\\n          numChildren[mouse][cat][CAT_TURN]--;\\n          break;\\n        }\\n      }\\n    }\\n  }\\n\\n  // All nodes where we know who will win in the end (no draws). node = [mouse][cat][turn][winner]\\n  let queue = [];\\n\\n  // Initialize winner + queue\\n  for (let i = 1; i < graph.length; i++) {\\n    for (let turn = MOUSE_TURN; turn <= CAT_TURN; turn++) {\\n      winner[HOLE_POS][i][turn] = MOUSE_WIN;\\n      queue.push([HOLE_POS, i, turn, MOUSE_WIN]);\\n      winner[i][i][turn] = CAT_WIN;\\n      queue.push([i, i, turn, CAT_WIN]);\\n    }\\n  }\\n\\n  // Percolate\\n  while (queue.length) {\\n    const node = queue.shift();\\n    // const [childMousePos, childCatPos, childTurn, childWinner] = node;\\n    // Note: childWinner will never be DRAW since we only add winners/losers to stack\\n    const childWinner = node[3];\\n\\n    const parents = getParents(graph, node);\\n\\n    for (parent of parents) {\\n      const [parentMousePos, parentCatPos, parentTurn] = parent;\\n      // since we\\'re trying to discover parent winner, we only care if parent winner\\n      // hasn\\'t been determined yet (ie. is set to DRAW since it\\'s initialized to 0 = DRAW)\\n      if (winner[parentMousePos][parentCatPos][parentTurn] === DRAW) {\\n        if (childWinner === parentTurn) {\\n          // guaranteed victory\\n          winner[parentMousePos][parentCatPos][parentTurn] = childWinner;\\n          queue.push([parentMousePos, parentCatPos, parentTurn, childWinner]);\\n        } else {\\n          // Decrement count of parents\\' neutral children\\n          if (--numChildren[parentMousePos][parentCatPos][parentTurn] === 0) {\\n            // Parent is loser\\n            winner[parentMousePos][parentCatPos][parentTurn] = childWinner;\\n            queue.push([parentMousePos, parentCatPos, parentTurn, childWinner]);\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  return winner[MOUSE_START_POS][CAT_START_POS][MOUSE_TURN];\\n};\\n\\n/**\\n * Returns all parent nodes, ie. any potential previous state of the game\\n * @param {[mousePos, catPos, turn]} node\\n * @returns {[[mousePos, catPos, turn]]}\\n */\\nfunction getParents(graph, node) {\\n  const [mousePos, catPos, turn] = node;\\n  const result = [];\\n\\n  if (turn === CAT_TURN) {\\n    for (const m of graph[mousePos]) {\\n      result.push([m, catPos, MOUSE_TURN]);\\n    }\\n  } else {\\n    for (const c of graph[catPos]) {\\n      if (c !== HOLE_POS) {\\n        result.push([mousePos, c, CAT_TURN]);\\n      }\\n    }\\n  }\\n\\n  return result;\\n}\\n\\nfunction create3dArray(x, y, z) {\\n  return Array.from(Array(x), () =>\\n    Array.from(Array(y), () => Array(z).fill(0))\\n  );\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nconst DRAW = 0;\\nconst MOUSE_TURN = 1;\\nconst CAT_TURN = 2;\\nconst MOUSE_WIN = 1;\\nconst CAT_WIN = 2;\\nconst HOLE_POS = 0;\\nconst MOUSE_START_POS = 1;\\nconst CAT_START_POS = 2;\\nconst MAX_GRAPH_SIZE = 50;\\n\\nvar catMouseGame = function (graph) {\\n  // winner[mouse][cat][turn] - Given game state, will return winner. Initializes to 0, or DRAW\\n  const winner = create3dArray(MAX_GRAPH_SIZE, MAX_GRAPH_SIZE, 3);\\n  // Given game state, returns number of child states (ie. subsequent game states) left to check\\n  const numChildren = create3dArray(MAX_GRAPH_SIZE, MAX_GRAPH_SIZE, 3);\\n\\n  // Initialize numChildren\\n  for (let mouse = 0; mouse < graph.length; mouse++) {\\n    for (let cat = 0; cat < graph.length; cat++) {\\n      numChildren[mouse][cat][MOUSE_TURN] = graph[mouse].length;\\n      numChildren[mouse][cat][CAT_TURN] = graph[cat].length;\\n\\n      // Cat cannot move to hole, so decrement # of cat moves by 1 if there\\'s a hole adjacent\\n      for (const node of graph[cat]) {\\n        if (node === HOLE_POS) {\\n          numChildren[mouse][cat][CAT_TURN]--;\\n          break;\\n        }\\n      }\\n    }\\n  }\\n\\n  // All nodes where we know who will win in the end (no draws). node = [mouse][cat][turn][winner]\\n  let queue = [];\\n\\n  // Initialize winner + queue\\n  for (let i = 1; i < graph.length; i++) {\\n    for (let turn = MOUSE_TURN; turn <= CAT_TURN; turn++) {\\n      winner[HOLE_POS][i][turn] = MOUSE_WIN;\\n      queue.push([HOLE_POS, i, turn, MOUSE_WIN]);\\n      winner[i][i][turn] = CAT_WIN;\\n      queue.push([i, i, turn, CAT_WIN]);\\n    }\\n  }\\n\\n  // Percolate\\n  while (queue.length) {\\n    const node = queue.shift();\\n    // const [childMousePos, childCatPos, childTurn, childWinner] = node;\\n    // Note: childWinner will never be DRAW since we only add winners/losers to stack\\n    const childWinner = node[3];\\n\\n    const parents = getParents(graph, node);\\n\\n    for (parent of parents) {\\n      const [parentMousePos, parentCatPos, parentTurn] = parent;\\n      // since we\\'re trying to discover parent winner, we only care if parent winner\\n      // hasn\\'t been determined yet (ie. is set to DRAW since it\\'s initialized to 0 = DRAW)\\n      if (winner[parentMousePos][parentCatPos][parentTurn] === DRAW) {\\n        if (childWinner === parentTurn) {\\n          // guaranteed victory\\n          winner[parentMousePos][parentCatPos][parentTurn] = childWinner;\\n          queue.push([parentMousePos, parentCatPos, parentTurn, childWinner]);\\n        } else {\\n          // Decrement count of parents\\' neutral children\\n          if (--numChildren[parentMousePos][parentCatPos][parentTurn] === 0) {\\n            // Parent is loser\\n            winner[parentMousePos][parentCatPos][parentTurn] = childWinner;\\n            queue.push([parentMousePos, parentCatPos, parentTurn, childWinner]);\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  return winner[MOUSE_START_POS][CAT_START_POS][MOUSE_TURN];\\n};\\n\\n/**\\n * Returns all parent nodes, ie. any potential previous state of the game\\n * @param {[mousePos, catPos, turn]} node\\n * @returns {[[mousePos, catPos, turn]]}\\n */\\nfunction getParents(graph, node) {\\n  const [mousePos, catPos, turn] = node;\\n  const result = [];\\n\\n  if (turn === CAT_TURN) {\\n    for (const m of graph[mousePos]) {\\n      result.push([m, catPos, MOUSE_TURN]);\\n    }\\n  } else {\\n    for (const c of graph[catPos]) {\\n      if (c !== HOLE_POS) {\\n        result.push([mousePos, c, CAT_TURN]);\\n      }\\n    }\\n  }\\n\\n  return result;\\n}\\n\\nfunction create3dArray(x, y, z) {\\n  return Array.from(Array(x), () =>\\n    Array.from(Array(y), () => Array(z).fill(0))\\n  );\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 307392,
                "title": "c-retrograde-bfs-with-comments-100-94-14",
                "content": "I believe this is the algorithm used to build endgame tablebases in chess :)\\n\\nRuntime: 8 ms, faster than 100.00% of C++ online submissions for Cat and Mouse.\\nMemory Usage: 9.7 MB, less than 94.14% of C++ online submissions for Cat and Mouse.\\n```\\nclass Solution {\\npublic:\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        auto n = graph.size();\\n        vector<vector<array<char,2>>> adj_cnt(n,vector<array<char,2>>(n));\\n        // adj_cnt[mouse position][cat position][0/1 = mouse/cat to move]\\n        // is the number of possibly non-losing moves for current player\\n        // (if zero, means the state has been solved)\\n        for (auto i = 0; i < n; ++i) for (auto j = 0; j < n; ++j)\\n            adj_cnt[i][j] = {graph[i].size(), graph[j].size()};\\n        deque<pair<array<char,2>,pair<bool,bool>>> q;\\n        // {{mouse pos, cat pos}, {0/1 = mouse/cat, 0/1 = current/previous player wins}}\\n        for (auto i = 1; i < n; ++i) {\\n            q.push_back({{i,i},{0,1}});\\n            q.push_back({{i,i},{1,0}});\\n            q.push_back({{0,i},{1,1}}); // if mouse reaches 0, it\\'s cat\\'s turn to move and it loses\\n            q.push_back({{i,0},{0,0}}); // if cat reaches 0 (invalid move), it\\'s mouse\\'s turn to move and it wins\\n            adj_cnt[i][i] = {0,0};\\n            adj_cnt[0][i] = adj_cnt[i][0] = {0,0};\\n            // mark all these states as solved\\n        }\\n        while (!q.empty()) {\\n            auto sz = q.size();\\n            for (auto i = 0; i < sz; ++i) {\\n                auto entry = q[0];\\n                q.pop_front();\\n                bool curr_player, prev_win;\\n                tie(curr_player,prev_win) = entry.second;\\n                \\n                entry.second.first ^= true, entry.second.second ^= true; // considering last move, switch player and winning side\\n                auto& lpp_ref = entry.first[!curr_player]; // location of previous player\\n                auto lpp = lpp_ref;\\n                for (auto j : graph[lpp]) {\\n                    // retrograde expansion, generate all possible previous state\\n                    lpp_ref = j;\\n                    auto& table_entry = adj_cnt[entry.first[0]][entry.first[1]][!curr_player];\\n                    if (table_entry) {\\n                        if (prev_win || --table_entry == 0) { // found one winning move, or all moves have been marked losing\\n                            table_entry = 0, q.push_back(entry);\\n                            if (curr_player && entry.first[0] == 1 && entry.first[1] == 2) // initial state is marked\\n                                return prev_win ? 1 : 2;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return 0; // the initial state belongs to the set of states that are never marked as solved.\\n        // For each state in this set, the current player can either choose a losing move, or a move that again lands in a state in this set.\\n        // So the best outcome is a draw.\\n        // (After making a losing move, the winning strategy of the other player won\\'t make use of any state in the never-marked set.)\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        auto n = graph.size();\\n        vector<vector<array<char,2>>> adj_cnt(n,vector<array<char,2>>(n));\\n        // adj_cnt[mouse position][cat position][0/1 = mouse/cat to move]\\n        // is the number of possibly non-losing moves for current player\\n        // (if zero, means the state has been solved)\\n        for (auto i = 0; i < n; ++i) for (auto j = 0; j < n; ++j)\\n            adj_cnt[i][j] = {graph[i].size(), graph[j].size()};\\n        deque<pair<array<char,2>,pair<bool,bool>>> q;\\n        // {{mouse pos, cat pos}, {0/1 = mouse/cat, 0/1 = current/previous player wins}}\\n        for (auto i = 1; i < n; ++i) {\\n            q.push_back({{i,i},{0,1}});\\n            q.push_back({{i,i},{1,0}});\\n            q.push_back({{0,i},{1,1}}); // if mouse reaches 0, it\\'s cat\\'s turn to move and it loses\\n            q.push_back({{i,0},{0,0}}); // if cat reaches 0 (invalid move), it\\'s mouse\\'s turn to move and it wins\\n            adj_cnt[i][i] = {0,0};\\n            adj_cnt[0][i] = adj_cnt[i][0] = {0,0};\\n            // mark all these states as solved\\n        }\\n        while (!q.empty()) {\\n            auto sz = q.size();\\n            for (auto i = 0; i < sz; ++i) {\\n                auto entry = q[0];\\n                q.pop_front();\\n                bool curr_player, prev_win;\\n                tie(curr_player,prev_win) = entry.second;\\n                \\n                entry.second.first ^= true, entry.second.second ^= true; // considering last move, switch player and winning side\\n                auto& lpp_ref = entry.first[!curr_player]; // location of previous player\\n                auto lpp = lpp_ref;\\n                for (auto j : graph[lpp]) {\\n                    // retrograde expansion, generate all possible previous state\\n                    lpp_ref = j;\\n                    auto& table_entry = adj_cnt[entry.first[0]][entry.first[1]][!curr_player];\\n                    if (table_entry) {\\n                        if (prev_win || --table_entry == 0) { // found one winning move, or all moves have been marked losing\\n                            table_entry = 0, q.push_back(entry);\\n                            if (curr_player && entry.first[0] == 1 && entry.first[1] == 2) // initial state is marked\\n                                return prev_win ? 1 : 2;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return 0; // the initial state belongs to the set of states that are never marked as solved.\\n        // For each state in this set, the current player can either choose a losing move, or a move that again lands in a state in this set.\\n        // So the best outcome is a draw.\\n        // (After making a losing move, the winning strategy of the other player won\\'t make use of any state in the never-marked set.)\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 176324,
                "title": "python-bfs-solution",
                "content": "I read some solutions from the contest and rewrote the bfs one in python.\\nThe key idea is that:\\n* if it\\'s the cat\\'s turn, and the mouse can win, then in all the possible previous turns (i.e., the mouse\\'s turn), the mouse can win;\\n* if it\\'s the cat\\'s turn, and the cat can win, then the cat can win in a previous turn (the mouse\\'s turn) if the cat can win in all the next turns of that previous turn;\\n* if it\\'s the mouse\\'s turn, and the cat can win, then in all the possible previous turns (i.e., the cat\\'s turn), the cat can win;\\n* if it\\'s the mouse\\'s turn, and the mouse can win, then the mouse can win in a previous turn (the cat\\'s turn) if the mouse can win in all the next turns of that previous turn.\\n\\n```\\nfrom collections import deque\\nclass Solution:\\n    def catMouseGame(self, graph):\\n        \"\"\"\\n        :type graph: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        arr = [[[0]*2 for j in range(55)] for i in range(55)]\\n        q=deque()\\n        for i in range(1,len(graph)):\\n            arr[i][i][0],arr[i][i][1]=2,2\\n            arr[i][0][0],arr[i][0][1]=1,1\\n            q.append((i,0,0))\\n            q.append((i,0,1))\\n            q.append((i,i,0))\\n            q.append((i,i,1))\\n        while q:\\n            c,m,turn = q.popleft()\\n            s = arr[c][m][turn]\\n            if turn==0:\\n                # cat\\'s move; find previous move of mouse\\n                for pre_move in graph[m]:\\n                    if arr[c][pre_move][1]!=0:\\n                        continue\\n                    if s==1:\\n                        arr[c][pre_move][1]=1\\n                        q.append((c,pre_move,1))\\n                    elif s==2:\\n                        cat_win=True\\n                        for nex_move in graph[pre_move]:\\n                            if arr[c][nex_move][0]!=2:\\n                                cat_win=False\\n                                break\\n                        if cat_win:\\n                            arr[c][pre_move][1]=2\\n                            q.append((c,pre_move,1))\\n            else:\\n                for pre_move in graph[c]:\\n                    if arr[pre_move][m][0]!=0:\\n                        continue\\n                    if pre_move!=0:\\n                        if s==2:\\n                            arr[pre_move][m][0]=2\\n                            q.append((pre_move,m,0))\\n                        elif s==1:\\n                            mouse_win=True\\n                            for nex_move in graph[pre_move]:\\n                                if nex_move!=0:\\n                                    if arr[nex_move][m][1]!=1:\\n                                        mouse_win=False\\n                                        break\\n                            if mouse_win:\\n                                arr[pre_move][m][0]=1\\n                                q.append((pre_move,m,0))\\n        return arr[2][1][1]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def catMouseGame(self, graph):\\n        \"\"\"\\n        :type graph: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        arr = [[[0]*2 for j in range(55)] for i in range(55)]\\n        q=deque()\\n        for i in range(1,len(graph)):\\n            arr[i][i][0],arr[i][i][1]=2,2\\n            arr[i][0][0],arr[i][0][1]=1,1\\n            q.append((i,0,0))\\n            q.append((i,0,1))\\n            q.append((i,i,0))\\n            q.append((i,i,1))\\n        while q:\\n            c,m,turn = q.popleft()\\n            s = arr[c][m][turn]\\n            if turn==0:\\n                # cat\\'s move; find previous move of mouse\\n                for pre_move in graph[m]:\\n                    if arr[c][pre_move][1]!=0:\\n                        continue\\n                    if s==1:\\n                        arr[c][pre_move][1]=1\\n                        q.append((c,pre_move,1))\\n                    elif s==2:\\n                        cat_win=True\\n                        for nex_move in graph[pre_move]:\\n                            if arr[c][nex_move][0]!=2:\\n                                cat_win=False\\n                                break\\n                        if cat_win:\\n                            arr[c][pre_move][1]=2\\n                            q.append((c,pre_move,1))\\n            else:\\n                for pre_move in graph[c]:\\n                    if arr[pre_move][m][0]!=0:\\n                        continue\\n                    if pre_move!=0:\\n                        if s==2:\\n                            arr[pre_move][m][0]=2\\n                            q.append((pre_move,m,0))\\n                        elif s==1:\\n                            mouse_win=True\\n                            for nex_move in graph[pre_move]:\\n                                if nex_move!=0:\\n                                    if arr[nex_move][m][1]!=1:\\n                                        mouse_win=False\\n                                        break\\n                            if mouse_win:\\n                                arr[pre_move][m][0]=1\\n                                q.append((pre_move,m,0))\\n        return arr[2][1][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 176147,
                "title": "minimax-memorization-but-cannot-solve-3-4-6-7-9-15-16-18-case",
                "content": "Hi, I use MiniMax to solve this problem. Since it allows visiting node again, I add memorization to avoid TLE. However, it cannot solve this test case (which expects `1` but my solution returns `0`):\\n```\\n[[3,4,6,7,9,15,16,18],[4,5,8,19],[4,5,6,7,9,18],[0,10,11,15],[0,1,2,6,10,12,14,16],[1,2,7,9,15,17,18],[0,2,4,7,9,10,11,12,13,14,15,17,19],[0,2,5,6,9,16,17],[1,9,14,15,16,19],[0,2,5,6,7,8,10,11,13,15,16,17,18],[3,4,6,9,17,18],[3,6,9,12,19],[4,6,11,15,17,19],[6,9,15,17,18,19],[4,6,8,15,19],[0,3,5,6,8,9,12,13,14,16,19],[0,4,7,8,9,15,17,18,19],[5,6,7,9,10,12,13,16],[0,2,5,9,10,13,16],[1,6,8,11,12,13,14,15,16]]\\n```\\n\\n\\n```\\nclass Solution {\\n  Map<Integer, Set<Integer>> edge = new HashMap<>();\\n  Set<String> visitedStates = new HashSet<>();\\n  Map<String, Integer> sol = new HashMap<>();\\n  \\n  public int catMouseGame(int[][] graph) {\\n    for (int i = 0; i < graph.length; i++) {\\n      for (int to : graph[i]) {\\n        if (to != i) {\\n          edge.computeIfAbsent(i, k -> new HashSet<>()).add(to);\\n          edge.computeIfAbsent(to, k -> new HashSet<>()).add(i);\\n        }\\n      }\\n    }\\n    \\n    int ans = max(/* catNode= */ 2, /* mouseNode= */ 1);\\n    return ans == -1 ? 2 : ans;\\n  }\\n  \\n  // Mouse Move\\n  int max(int catNode, int mouseNode) {\\n    if (edge.get(mouseNode).contains(0)) return 1;\\n    \\n    String key = catNode + \"_mouse_\" + mouseNode;\\n    if (!visitedStates.add(key)) return 0;\\n    if (sol.containsKey(key)) {\\n      visitedStates.remove(key);\\n      return sol.get(key);\\n    }\\n    \\n    int max = Integer.MIN_VALUE;\\n    for (int i : edge.get(mouseNode)) {\\n      max = Math.max(max, min(catNode, i));\\n      if (max == 1) break;\\n    }\\n    \\n    visitedStates.remove(key);\\n    sol.put(key, max);\\n    return max;\\n  }\\n  \\n  // Cat Move\\n  int min(int catNode, int mouseNode) {\\n    if (catNode == mouseNode) return -1;\\n    if (edge.get(catNode).contains(mouseNode)) return -1;\\n    \\n    String key = catNode + \"_cat_\" + mouseNode;\\n    if (!visitedStates.add(key)) return 0;\\n    if (sol.containsKey(key)) {\\n      visitedStates.remove(key);\\n      return sol.get(key);\\n    }\\n    \\n    int min = Integer.MAX_VALUE;\\n    for (int i : edge.get(catNode)) {\\n      if (i == 0) continue;\\n      min = Math.min(min, max(i, mouseNode));\\n      if (min == -1) break;\\n    }\\n    \\n    visitedStates.remove(key);\\n    sol.put(key, min);\\n    return min;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n[[3,4,6,7,9,15,16,18],[4,5,8,19],[4,5,6,7,9,18],[0,10,11,15],[0,1,2,6,10,12,14,16],[1,2,7,9,15,17,18],[0,2,4,7,9,10,11,12,13,14,15,17,19],[0,2,5,6,9,16,17],[1,9,14,15,16,19],[0,2,5,6,7,8,10,11,13,15,16,17,18],[3,4,6,9,17,18],[3,6,9,12,19],[4,6,11,15,17,19],[6,9,15,17,18,19],[4,6,8,15,19],[0,3,5,6,8,9,12,13,14,16,19],[0,4,7,8,9,15,17,18,19],[5,6,7,9,10,12,13,16],[0,2,5,9,10,13,16],[1,6,8,11,12,13,14,15,16]]\\n```\n```\\nclass Solution {\\n  Map<Integer, Set<Integer>> edge = new HashMap<>();\\n  Set<String> visitedStates = new HashSet<>();\\n  Map<String, Integer> sol = new HashMap<>();\\n  \\n  public int catMouseGame(int[][] graph) {\\n    for (int i = 0; i < graph.length; i++) {\\n      for (int to : graph[i]) {\\n        if (to != i) {\\n          edge.computeIfAbsent(i, k -> new HashSet<>()).add(to);\\n          edge.computeIfAbsent(to, k -> new HashSet<>()).add(i);\\n        }\\n      }\\n    }\\n    \\n    int ans = max(/* catNode= */ 2, /* mouseNode= */ 1);\\n    return ans == -1 ? 2 : ans;\\n  }\\n  \\n  // Mouse Move\\n  int max(int catNode, int mouseNode) {\\n    if (edge.get(mouseNode).contains(0)) return 1;\\n    \\n    String key = catNode + \"_mouse_\" + mouseNode;\\n    if (!visitedStates.add(key)) return 0;\\n    if (sol.containsKey(key)) {\\n      visitedStates.remove(key);\\n      return sol.get(key);\\n    }\\n    \\n    int max = Integer.MIN_VALUE;\\n    for (int i : edge.get(mouseNode)) {\\n      max = Math.max(max, min(catNode, i));\\n      if (max == 1) break;\\n    }\\n    \\n    visitedStates.remove(key);\\n    sol.put(key, max);\\n    return max;\\n  }\\n  \\n  // Cat Move\\n  int min(int catNode, int mouseNode) {\\n    if (catNode == mouseNode) return -1;\\n    if (edge.get(catNode).contains(mouseNode)) return -1;\\n    \\n    String key = catNode + \"_cat_\" + mouseNode;\\n    if (!visitedStates.add(key)) return 0;\\n    if (sol.containsKey(key)) {\\n      visitedStates.remove(key);\\n      return sol.get(key);\\n    }\\n    \\n    int min = Integer.MAX_VALUE;\\n    for (int i : edge.get(catNode)) {\\n      if (i == 0) continue;\\n      min = Math.min(min, max(i, mouseNode));\\n      if (min == -1) break;\\n    }\\n    \\n    visitedStates.remove(key);\\n    sol.put(key, min);\\n    return min;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 176123,
                "title": "explain-why-the-last-case-failed-and-how-to-fix-it",
                "content": "The key to pass the last test case is to **check whether the current state can win at first** and then move to the next state. \\nSince we set the state to **DRAW**  at first and then move to next state, you can see the case that [@nguyen_hoanh](https://leetcode.com/nguyen_hoanh) said in  [here](https://leetcode.com/problems/cat-and-mouse/discuss/176029/Why-this-solution-did-not-work/) will fail.\\nHere is the **incorrect** code that check the cat turn\\'s state inside the next for loop:\\n```java\\n// cat turn\\nresult = 1;\\nfor (int i = 0; i < graph[cat].length; i++) {\\n    // cat can\\'t travel to the hole\\n    if (graph[cat][i] == 0) {\\n        continue;\\n    }\\n    // NOTE: check inside will fail!\\n    if (graph[cat][i] == mouse) {\\n        dp[mouse][cat][who] = 2;\\n        return 2;\\n    }\\n    int res = dfs(graph, dp, mouse, graph[cat][i], who ^ 1);\\n    // cat win\\n    if (res == 2) {\\n        dp[mouse][cat][who] = 2;\\n        return 2;\\n    // draw\\n    } else if (res == 0) {\\n        result = 0;\\n    }\\n}\\n```\\nHere is the AC code:\\n```java\\nclass Solution {\\n    public int catMouseGame(int[][] graph) {\\n        int[][][] dp = new int[graph.length][graph.length][2];\\n        for (int i = 0; i < graph.length; i++) {           \\n            for (int j = 0; j < graph.length; j++) {\\n                Arrays.fill(dp[i][j], -1);             \\n            }          \\n        }\\n        int ans = dfs(graph, dp, 1, 2, 0);\\n        return ans;\\n    }\\n\\n    public int dfs(int[][] graph, int[][][] dp, int mouse, int cat, int who) {\\n        if (dp[mouse][cat][who] != -1) {\\n            return dp[mouse][cat][who];\\n        }\\n        // set the status to draw\\n        dp[mouse][cat][who] = 0;        \\n        int result;\\n        // mouse turn\\t\\t\\t\\t\\n        if (who == 0) {\\n            // check if mouse can win\\n            // NOTE: this must be done before the next for loop rather than during it.\\n            for (int i = 0; i < graph[mouse].length; i++) {\\n                if (graph[mouse][i] == 0) {\\n                    dp[mouse][cat][who] = 1;\\n                    return 1;\\n                }\\n            }\\n            // next move\\n            result = 2;\\n            for (int i = 0; i < graph[mouse].length; i++) {  \\n                if (graph[mouse][i] != cat) {\\n                    int res = dfs(graph, dp, graph[mouse][i], cat, who ^ 1);\\n                    // cat win\\n                    if (res == 1) {\\n                        dp[mouse][cat][who] = 1;\\n                        return 1;\\n                    // draw\\n                    } else if (res == 0) {\\n                        result = 0;\\n                    }\\n                }\\n            }\\n        // cat turn\\n        } else {\\n            // check if cat can win\\n            // NOTE: this must be done before the next for loop rather than during it.\\t\\t\\t\\t\\t\\t\\n            for (int i = 0; i < graph[cat].length; i++) {\\n                if (graph[cat][i] == mouse) {\\n                    dp[mouse][cat][who] = 2;\\n                    return 2;\\n                }\\n            }\\n            // next move\\n            result = 1;\\n            for (int i = 0; i < graph[cat].length; i++) {\\n                // cat can\\'t travel to the hole\\n                if (graph[cat][i] == 0) {\\n                    continue;\\n                }                \\n                int res = dfs(graph, dp, mouse, graph[cat][i], who ^ 1);\\n                // cat win\\n                if (res == 2) {\\n                    dp[mouse][cat][who] = 2;\\n                    return 2;\\n                // draw\\n                } else if (res == 0) {\\n                    result = 0;\\n                }\\n            }\\n        }\\n        dp[mouse][cat][who] = result;\\n        return dp[mouse][cat][who];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n// cat turn\\nresult = 1;\\nfor (int i = 0; i < graph[cat].length; i++) {\\n    // cat can\\'t travel to the hole\\n    if (graph[cat][i] == 0) {\\n        continue;\\n    }\\n    // NOTE: check inside will fail!\\n    if (graph[cat][i] == mouse) {\\n        dp[mouse][cat][who] = 2;\\n        return 2;\\n    }\\n    int res = dfs(graph, dp, mouse, graph[cat][i], who ^ 1);\\n    // cat win\\n    if (res == 2) {\\n        dp[mouse][cat][who] = 2;\\n        return 2;\\n    // draw\\n    } else if (res == 0) {\\n        result = 0;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int catMouseGame(int[][] graph) {\\n        int[][][] dp = new int[graph.length][graph.length][2];\\n        for (int i = 0; i < graph.length; i++) {           \\n            for (int j = 0; j < graph.length; j++) {\\n                Arrays.fill(dp[i][j], -1);             \\n            }          \\n        }\\n        int ans = dfs(graph, dp, 1, 2, 0);\\n        return ans;\\n    }\\n\\n    public int dfs(int[][] graph, int[][][] dp, int mouse, int cat, int who) {\\n        if (dp[mouse][cat][who] != -1) {\\n            return dp[mouse][cat][who];\\n        }\\n        // set the status to draw\\n        dp[mouse][cat][who] = 0;        \\n        int result;\\n        // mouse turn\\t\\t\\t\\t\\n        if (who == 0) {\\n            // check if mouse can win\\n            // NOTE: this must be done before the next for loop rather than during it.\\n            for (int i = 0; i < graph[mouse].length; i++) {\\n                if (graph[mouse][i] == 0) {\\n                    dp[mouse][cat][who] = 1;\\n                    return 1;\\n                }\\n            }\\n            // next move\\n            result = 2;\\n            for (int i = 0; i < graph[mouse].length; i++) {  \\n                if (graph[mouse][i] != cat) {\\n                    int res = dfs(graph, dp, graph[mouse][i], cat, who ^ 1);\\n                    // cat win\\n                    if (res == 1) {\\n                        dp[mouse][cat][who] = 1;\\n                        return 1;\\n                    // draw\\n                    } else if (res == 0) {\\n                        result = 0;\\n                    }\\n                }\\n            }\\n        // cat turn\\n        } else {\\n            // check if cat can win\\n            // NOTE: this must be done before the next for loop rather than during it.\\t\\t\\t\\t\\t\\t\\n            for (int i = 0; i < graph[cat].length; i++) {\\n                if (graph[cat][i] == mouse) {\\n                    dp[mouse][cat][who] = 2;\\n                    return 2;\\n                }\\n            }\\n            // next move\\n            result = 1;\\n            for (int i = 0; i < graph[cat].length; i++) {\\n                // cat can\\'t travel to the hole\\n                if (graph[cat][i] == 0) {\\n                    continue;\\n                }                \\n                int res = dfs(graph, dp, mouse, graph[cat][i], who ^ 1);\\n                // cat win\\n                if (res == 2) {\\n                    dp[mouse][cat][who] = 2;\\n                    return 2;\\n                // draw\\n                } else if (res == 0) {\\n                    result = 0;\\n                }\\n            }\\n        }\\n        dp[mouse][cat][who] = result;\\n        return dp[mouse][cat][who];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 175892,
                "title": "recursion-memorization-84ms-python",
                "content": "Just follow the game rule and do a recursion with memorization. It\\'s pretty straightforward.\\nThe following code can be optimized but I didn\\'t have a chance in the contest.\\n\\n```\\n\\nclass Solution:\\n    def catMouseGame(self, graph):\\n        \"\"\"\\n        :type graph: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        memo = {}\\n        def move(ci, mi, mt):\\n            key = (ci, mi, mt)\\n            if key in memo:\\n                return memo[key]\\n            memo[key] = 0\\n\\t\\t\\t\\t\\t\\t\\n            if not mt:  #cat turn \\n                for nxtmove in graph[ci]:\\n                    if nxtmove == mi:\\n                        memo[key] = 2\\n                        return 2\\n                res = 1\\n                for nxtmove in graph[ci]:\\n                    if nxtmove == 0:\\n                        continue\\n                    tmp = move(nxtmove, mi, True)\\n                    if tmp == 2:\\n                        res =2\\n                        break\\n                    if tmp == 0:\\n                        res = 0\\n                memo[key] = res\\n                return res\\n            #mouse turn\\n            for nxtmove in graph[mi]:\\n                if nxtmove == 0:\\n                    memo[key] = 1\\n                    return 1\\n            res = 2\\n            for nxtmove in graph[mi]:                \\n                if nxtmove != ci:\\n                    tmp = move(ci, nxtmove, False)\\n                    if tmp == 1:\\n                        res = 1\\n                        break\\n                    if tmp == 0:\\n                        res = 0\\n            memo[key] = res\\n            return res\\n        return move(2, 1, True)\\n                    \\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def catMouseGame(self, graph):\\n        \"\"\"\\n        :type graph: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        memo = {}\\n        def move(ci, mi, mt):\\n            key = (ci, mi, mt)\\n            if key in memo:\\n                return memo[key]\\n            memo[key] = 0\\n\\t\\t\\t\\t\\t\\t\\n            if not mt:  #cat turn \\n                for nxtmove in graph[ci]:\\n                    if nxtmove == mi:\\n                        memo[key] = 2\\n                        return 2\\n                res = 1\\n                for nxtmove in graph[ci]:\\n                    if nxtmove == 0:\\n                        continue\\n                    tmp = move(nxtmove, mi, True)\\n                    if tmp == 2:\\n                        res =2\\n                        break\\n                    if tmp == 0:\\n                        res = 0\\n                memo[key] = res\\n                return res\\n            #mouse turn\\n            for nxtmove in graph[mi]:\\n                if nxtmove == 0:\\n                    memo[key] = 1\\n                    return 1\\n            res = 2\\n            for nxtmove in graph[mi]:                \\n                if nxtmove != ci:\\n                    tmp = move(ci, nxtmove, False)\\n                    if tmp == 1:\\n                        res = 1\\n                        break\\n                    if tmp == 0:\\n                        res = 0\\n            memo[key] = res\\n            return res\\n        return move(2, 1, True)\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514720,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        enum class State { Draw, MouseWin, CatWin };\\n        const int n = static_cast<int>(graph.size());\\n        State states[50][50][2];\\n        int out_degree[50][50][2] = {};\\n        std::memset(states, 0, sizeof(states));\\n        std::queue<std::tuple<int, int, int, State> > q;\\n        for (int cat = 0; cat < n; ++cat)\\n        {\\n            for (int mouse = 0; mouse < n; ++mouse)\\n            {\\n                auto hole = std::count(graph[cat].begin(), graph[cat].end(), 0);\\n                out_degree[cat][mouse][0] = static_cast<int>(graph[mouse].size());\\n                out_degree[cat][mouse][1] = static_cast<int>(graph[cat].size())\\n                                        - static_cast<int>(hole);\\n            }\\n        }\\n        for (int cat = 1; cat < n; ++cat)\\n            for (int move = 0; move < 2; ++move)\\n                q.emplace(cat, 0, move, states[cat][0][move] = State::MouseWin),\\n                q.emplace(cat, cat, move, states[cat][cat][move] = State::CatWin);\\n        while (!q.empty())\\n        {\\n            const auto [cat, mouse, move, state] = q.front();\\n            q.pop();\\n            if ((cat == 2) && (mouse == 1) && (move == 0))\\n                return static_cast<int>(state);\\n            const int prevMove = move ^ 1;\\n            for (const int prev : graph[prevMove?cat:mouse])\\n            {\\n                const int prevCat = prevMove?prev:cat;\\n                if (prevCat == 0) continue;\\n                const int prevMouse = prevMove?mouse:prev;\\n                if (states[prevCat][prevMouse][prevMove] != State::Draw) continue;\\n                if (((prevMove == 0) && (state == State::MouseWin))\\n                ||  ((prevMove == 1) && (state == State::CatWin))\\n                || (--out_degree[prevCat][prevMouse][prevMove] == 0))\\n                    states[prevCat][prevMouse][prevMove] = state,\\n                    q.emplace(prevCat, prevMouse, prevMove, state);\\n            }\\n        }\\n        return static_cast<int>(states[2][1][0]);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def catMouseGame(self, graph: List[List[int]]) -> int:\\n        n = len(graph)\\n        dp = [ [{\"c\":0, \"m\":0} for j in range(n)] for i in range(n) ]\\n        outdegree = [ [{\"c\":len(graph[j])-(0 in graph[j]), \"m\":len(graph[i])} for j in range(n)] for i in range(n) ]\\n        nodes = []\\n        for j in range(1,n):\\n            dp[0][j][\"m\"] = dp[0][j][\"c\"] = 1\\n            nodes.extend( [(0,j,\"m\",1), (0,j,\"c\",1)] )\\n            dp[j][j][\"m\"] =  dp[j][j][\"c\"] = 2\\n            nodes.extend( [(j,j,\"m\",2), (j,j,\"c\",2)])\\n        \\n        while nodes:\\n            nodes_new = []\\n            for i, j, move, result in nodes:\\n                if i==1 and j==2 and move==\"m\": return result\\n                premove = \"c\" if move==\"m\" else \"m\"\\n                if premove==\"c\":\\n                    for j_ in graph[j]:\\n                        if j_==0: continue\\n                        if dp[i][j_][\"c\"]: continue\\n                        if result==2:\\n                            dp[i][j_][\"c\"] = 2; nodes_new.append((i,j_,\"c\",2))\\n                        else:\\n                            outdegree[i][j_][\"c\"]-=1\\n                            if outdegree[i][j_][\"c\"]==0:\\n                                dp[i][j_][\"c\"] = 1; nodes_new.append((i,j_,\"c\",1))\\n                else: # premove==\"m\"\\n                    for i_ in graph[i]:\\n                        if dp[i_][j][\"m\"]: continue\\n                        if result==1:\\n                            dp[i_][j][\"m\"] = 1; nodes_new.append((i_,j,\"m\",1))\\n                        else:\\n                            outdegree[i_][j][\"m\"]-=1\\n                            if outdegree[i_][j][\"m\"]==0:\\n                                dp[i_][j][\"m\"] = 2; nodes_new.append((i_,j,\"m\",2))\\n            nodes = nodes_new\\n        return dp[1][2][\"m\"]\\n```\\n\\n```Java []\\nclass Solution {\\n    public int catMouseGame(int[][] graph) {\\n        int n = graph.length;\\n\\n        int[] nonZeroNeighbor = new int[n];\\n        for(int i = 0; i < n; i++){\\n            nonZeroNeighbor[i] = graph[i].length;\\n            for(int neighbor : graph[i]){\\n                if(neighbor == 0){\\n                    nonZeroNeighbor[i]--;\\n                    break;\\n                }\\n            }\\n        }\\n        int[][][] nextStateCount = new int[n][n][2];\\n        for(int mousePos = 0; mousePos < n; mousePos++){\\n            for(int catPos = 0; catPos < n; catPos++){\\n                nextStateCount[mousePos][catPos][0] = graph[mousePos].length;\\n                nextStateCount[mousePos][catPos][1] = nonZeroNeighbor[catPos];\\n            }\\n        }\\n        int[][][] dp = new int[n][n][2];\\n        Queue<int[]> queue = new ArrayDeque<>();\\n        for(int catPos = 1; catPos < n; catPos++){\\n            for(int turn = 0; turn <= 1; turn++){\\n                dp[0][catPos][turn] = 1;\\n                queue.offer(new int[]{0, catPos, turn, 1});\\n                dp[catPos][catPos][turn] = 2;\\n                queue.offer(new int[]{catPos, catPos, turn, 2});\\n            }\\n        }\\n        while(!queue.isEmpty()){\\n            int[] curr = queue.poll();\\n            int mousePos = curr[0], catPos = curr[1], turn = curr[2], result = curr[3];\\n            if(turn == 0){\\n                if(mousePos == 1 && catPos == 2)\\n                    return result;\\n                for(int prev : graph[catPos]){\\n                    if(prev == 0 || dp[mousePos][prev][1] != 0)\\n                        continue;\\n                    if(result == 2 || --nextStateCount[mousePos][prev][1] == 0){\\n                        dp[mousePos][prev][1] = result;\\n                        queue.offer(new int[]{mousePos, prev, 1, result});\\n                    }\\n                }\\n            } else {\\n                for(int prev : graph[mousePos]){\\n                    if(dp[prev][catPos][0] != 0)\\n                        continue;\\n                    if(result == 1 || --nextStateCount[prev][catPos][0] == 0){\\n                        dp[prev][catPos][0] = result;\\n                        queue.offer(new int[]{prev, catPos, 0, result});\\n                    }\\n                }\\n            }\\n        }\\n        return dp[1][2][0];\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        enum class State { Draw, MouseWin, CatWin };\\n        const int n = static_cast<int>(graph.size());\\n        State states[50][50][2];\\n        int out_degree[50][50][2] = {};\\n        std::memset(states, 0, sizeof(states));\\n        std::queue<std::tuple<int, int, int, State> > q;\\n        for (int cat = 0; cat < n; ++cat)\\n        {\\n            for (int mouse = 0; mouse < n; ++mouse)\\n            {\\n                auto hole = std::count(graph[cat].begin(), graph[cat].end(), 0);\\n                out_degree[cat][mouse][0] = static_cast<int>(graph[mouse].size());\\n                out_degree[cat][mouse][1] = static_cast<int>(graph[cat].size())\\n                                        - static_cast<int>(hole);\\n            }\\n        }\\n        for (int cat = 1; cat < n; ++cat)\\n            for (int move = 0; move < 2; ++move)\\n                q.emplace(cat, 0, move, states[cat][0][move] = State::MouseWin),\\n                q.emplace(cat, cat, move, states[cat][cat][move] = State::CatWin);\\n        while (!q.empty())\\n        {\\n            const auto [cat, mouse, move, state] = q.front();\\n            q.pop();\\n            if ((cat == 2) && (mouse == 1) && (move == 0))\\n                return static_cast<int>(state);\\n            const int prevMove = move ^ 1;\\n            for (const int prev : graph[prevMove?cat:mouse])\\n            {\\n                const int prevCat = prevMove?prev:cat;\\n                if (prevCat == 0) continue;\\n                const int prevMouse = prevMove?mouse:prev;\\n                if (states[prevCat][prevMouse][prevMove] != State::Draw) continue;\\n                if (((prevMove == 0) && (state == State::MouseWin))\\n                ||  ((prevMove == 1) && (state == State::CatWin))\\n                || (--out_degree[prevCat][prevMouse][prevMove] == 0))\\n                    states[prevCat][prevMouse][prevMove] = state,\\n                    q.emplace(prevCat, prevMouse, prevMove, state);\\n            }\\n        }\\n        return static_cast<int>(states[2][1][0]);\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def catMouseGame(self, graph: List[List[int]]) -> int:\\n        n = len(graph)\\n        dp = [ [{\"c\":0, \"m\":0} for j in range(n)] for i in range(n) ]\\n        outdegree = [ [{\"c\":len(graph[j])-(0 in graph[j]), \"m\":len(graph[i])} for j in range(n)] for i in range(n) ]\\n        nodes = []\\n        for j in range(1,n):\\n            dp[0][j][\"m\"] = dp[0][j][\"c\"] = 1\\n            nodes.extend( [(0,j,\"m\",1), (0,j,\"c\",1)] )\\n            dp[j][j][\"m\"] =  dp[j][j][\"c\"] = 2\\n            nodes.extend( [(j,j,\"m\",2), (j,j,\"c\",2)])\\n        \\n        while nodes:\\n            nodes_new = []\\n            for i, j, move, result in nodes:\\n                if i==1 and j==2 and move==\"m\": return result\\n                premove = \"c\" if move==\"m\" else \"m\"\\n                if premove==\"c\":\\n                    for j_ in graph[j]:\\n                        if j_==0: continue\\n                        if dp[i][j_][\"c\"]: continue\\n                        if result==2:\\n                            dp[i][j_][\"c\"] = 2; nodes_new.append((i,j_,\"c\",2))\\n                        else:\\n                            outdegree[i][j_][\"c\"]-=1\\n                            if outdegree[i][j_][\"c\"]==0:\\n                                dp[i][j_][\"c\"] = 1; nodes_new.append((i,j_,\"c\",1))\\n                else: # premove==\"m\"\\n                    for i_ in graph[i]:\\n                        if dp[i_][j][\"m\"]: continue\\n                        if result==1:\\n                            dp[i_][j][\"m\"] = 1; nodes_new.append((i_,j,\"m\",1))\\n                        else:\\n                            outdegree[i_][j][\"m\"]-=1\\n                            if outdegree[i_][j][\"m\"]==0:\\n                                dp[i_][j][\"m\"] = 2; nodes_new.append((i_,j,\"m\",2))\\n            nodes = nodes_new\\n        return dp[1][2][\"m\"]\\n```\n```Java []\\nclass Solution {\\n    public int catMouseGame(int[][] graph) {\\n        int n = graph.length;\\n\\n        int[] nonZeroNeighbor = new int[n];\\n        for(int i = 0; i < n; i++){\\n            nonZeroNeighbor[i] = graph[i].length;\\n            for(int neighbor : graph[i]){\\n                if(neighbor == 0){\\n                    nonZeroNeighbor[i]--;\\n                    break;\\n                }\\n            }\\n        }\\n        int[][][] nextStateCount = new int[n][n][2];\\n        for(int mousePos = 0; mousePos < n; mousePos++){\\n            for(int catPos = 0; catPos < n; catPos++){\\n                nextStateCount[mousePos][catPos][0] = graph[mousePos].length;\\n                nextStateCount[mousePos][catPos][1] = nonZeroNeighbor[catPos];\\n            }\\n        }\\n        int[][][] dp = new int[n][n][2];\\n        Queue<int[]> queue = new ArrayDeque<>();\\n        for(int catPos = 1; catPos < n; catPos++){\\n            for(int turn = 0; turn <= 1; turn++){\\n                dp[0][catPos][turn] = 1;\\n                queue.offer(new int[]{0, catPos, turn, 1});\\n                dp[catPos][catPos][turn] = 2;\\n                queue.offer(new int[]{catPos, catPos, turn, 2});\\n            }\\n        }\\n        while(!queue.isEmpty()){\\n            int[] curr = queue.poll();\\n            int mousePos = curr[0], catPos = curr[1], turn = curr[2], result = curr[3];\\n            if(turn == 0){\\n                if(mousePos == 1 && catPos == 2)\\n                    return result;\\n                for(int prev : graph[catPos]){\\n                    if(prev == 0 || dp[mousePos][prev][1] != 0)\\n                        continue;\\n                    if(result == 2 || --nextStateCount[mousePos][prev][1] == 0){\\n                        dp[mousePos][prev][1] = result;\\n                        queue.offer(new int[]{mousePos, prev, 1, result});\\n                    }\\n                }\\n            } else {\\n                for(int prev : graph[mousePos]){\\n                    if(dp[prev][catPos][0] != 0)\\n                        continue;\\n                    if(result == 1 || --nextStateCount[prev][catPos][0] == 0){\\n                        dp[prev][catPos][0] = result;\\n                        queue.offer(new int[]{prev, catPos, 0, result});\\n                    }\\n                }\\n            }\\n        }\\n        return dp[1][2][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2603656,
                "title": "75-faster-than-all-c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        int N = graph.size();\\n        vector<vector<int>> dp[2];\\n        vector<vector<int>> outdegree[2];\\n        queue<vector<int>> q; // q of {turn, mouse position, cat position} for topological sort\\n\\n        dp[0] = vector<vector<int>>(N, vector<int>(N));\\n        dp[1] = vector<vector<int>>(N, vector<int>(N));\\n        outdegree[0] = vector<vector<int>>(N, vector<int>(N));\\n        outdegree[1] = vector<vector<int>>(N, vector<int>(N));\\n\\n        // init dp and queue\\n        for (int j = 0; j < N; ++j) {\\n            dp[0][0][j] = dp[1][0][j] = 1;\\n            q.push({0, 0, j});\\n            q.push({1, 0, j});\\n        }\\n        for (int j = 1; j < N; ++j) {\\n            dp[0][j][j] = dp[1][j][j] = 2;\\n            q.push({0, j, j});\\n            q.push({1, j, j});\\n        }\\n        // init outdegree\\n        for (int i = 0; i < N; ++i) {\\n            for (int j = 1; j < N; ++j) {\\n                outdegree[0][i][j] = graph[i].size();\\n                outdegree[1][i][j] = graph[j].size();\\n            }\\n        }\\n        for (auto &v : graph[0]) {\\n            for (int i = 0; i < N; ++i) {\\n                outdegree[1][i][v]--;\\n            }\\n        }\\n        // run the topological sort from queue\\n        while (q.size()) {\\n            auto turn = q.front()[0];\\n            auto mouse = q.front()[1];\\n            auto cat = q.front()[2];\\n            q.pop();\\n\\n            if (turn == 0 && mouse == 1 && cat == 2) {\\n                // the result has been inferenced\\n                break;\\n            }\\n\\n            if (turn == 0) { // mouse\\'s turn\\n                // v is the prev position of cat\\n                for (auto &v : graph[cat]) {\\n                    if (v == 0) {\\n                        continue;\\n                    }\\n\\n                    if (dp[1][mouse][v] > 0) {\\n                        continue;\\n                    }\\n\\n                    if (dp[turn][mouse][cat] == 2) {\\n                        // cat wants to move from v to `cat` position, and thus cat wins\\n                        dp[1][mouse][v] = 2;\\n                        q.push({1, mouse, v});\\n                        continue;\\n                    }\\n\\n                    outdegree[1][mouse][v]--;\\n                    if (outdegree[1][mouse][v] == 0) {\\n                        dp[1][mouse][v] = 1;\\n                        q.push({1, mouse, v});\\n                    }\\n                }\\n            } else { // cat\\'s turn\\n\\t\\t\\t\\t// v is the prev position of mouse\\n                for (auto &v : graph[mouse]) {\\n                    if (dp[0][v][cat] > 0) {\\n                        continue;\\n                    }\\n\\n                    if (dp[turn][mouse][cat] == 1) {\\n                        // mouse wants to move from v to `mouse` position and thus mouse wins\\n                        dp[0][v][cat] = 1;\\n                        q.push({0, v, cat});\\n                        continue;\\n                    }\\n\\n                    outdegree[0][v][cat]--;\\n                    if (outdegree[0][v][cat] == 0) {\\n                        dp[0][v][cat] = 2;\\n                        q.push({0, v, cat});\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[0][1][2];\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        int N = graph.size();\\n        vector<vector<int>> dp[2];\\n        vector<vector<int>> outdegree[2];\\n        queue<vector<int>> q; // q of {turn, mouse position, cat position}",
                "codeTag": "Java"
            },
            {
                "id": 2295680,
                "title": "c-96ms-dp-topological-sort-with-explanation-by-my-words",
                "content": "OK, let me say that, what a hell-level problem!!\\n\\nAfter looking others discussion, I finally cooked up my version.\\nHope my explanation would be helpful for you.\\n\\nLike other discussion thread, we need to define a 3-dimentional array for `dp[turn][mouse][cat]`\\nSo, obviously from my naming, \\n`dp[0][i][j]` means that mouse is on i and cat is on j and it is now mouse turn\\n`dp[0][i][j]` could be **1=mouse win**, **2=cat win**, **0=undefined/draw**\\n\\nThe game is that,\\nAssuming `dp[0][i][j]` is 1, which menas when mouse is on vertex i, cat is on vertex j, and now is mouse\\'s turn, mouse will win by definition. Then for the previous step, ie. cat\\'s turn, cat don\\'t want it happen, and cat will not move from any vertex v (adjacent to j) to j. So the possible path from vertex v to j disappears. \\n\\nFor example, if the graph be [[3],[3],[3],[0,1,2]\\n\\n\\t0 -- 3 -- 2\\n\\t      \\\\ \\n            1\\n\\nWe knew that `dp[0][0][3] = 1` (since mouse is already in hole), so if cat is on vertex 2 (adjacent to 3), it doesn\\'t want to go to vertex 3, and thus the possible path go from vertex 2 (when cat is on 0) minus by 1. This fact will be represented by `outdegree` variable, where `outdegree[turn][mouse][cat]` means the remaining number of possbile path for cat to win when cat is on `cat` and mouse is on `mouse` and it is cat\\'s turn (when `turn=1`). \\n\\nTherefore, if all possible path from vertex v to adjacent vertex u are disappeared, `dp[1][mouse][v]` should be marked 1 because there is no any chance for cats on vertex v to win if mouse is already on `mouse`.\\n\\nSimilarly, assuming `dp[0][i][j]` is 2, then for the previous step. ie. cat\\'s turn, cat really wants to move from v to j because that leads to `dp[0][i][j]=2` which means cat wins. So for any vertex v adjacent to j, `dp[1][i][v]` could be marked 2.\\n\\nFor `dp[1][i][j]`, the logic is the same.\\n\\nObviously, initial conditions are `dp[*][0][j] = 1` and `dp[*][i][j] = 2 if i==j and i!=0`\\nThus, the topologic sort process would begin from the firmed initial conditions. You can refer the code below.\\n\\n```\\nclass Solution {\\npublic:\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        int N = graph.size();\\n        vector<vector<int>> dp[2];\\n        vector<vector<int>> outdegree[2];\\n        queue<vector<int>> q; // q of {turn, mouse position, cat position} for topological sort\\n\\n        dp[0] = vector<vector<int>>(N, vector<int>(N));\\n        dp[1] = vector<vector<int>>(N, vector<int>(N));\\n        outdegree[0] = vector<vector<int>>(N, vector<int>(N));\\n        outdegree[1] = vector<vector<int>>(N, vector<int>(N));\\n\\n        // init dp and queue\\n        for (int j = 0; j < N; ++j) {\\n            dp[0][0][j] = dp[1][0][j] = 1;\\n            q.push({0, 0, j});\\n            q.push({1, 0, j});\\n        }\\n        for (int j = 1; j < N; ++j) {\\n            dp[0][j][j] = dp[1][j][j] = 2;\\n            q.push({0, j, j});\\n            q.push({1, j, j});\\n        }\\n        // init outdegree\\n        for (int i = 0; i < N; ++i) {\\n            for (int j = 1; j < N; ++j) {\\n                outdegree[0][i][j] = graph[i].size();\\n                outdegree[1][i][j] = graph[j].size();\\n            }\\n        }\\n        for (auto &v : graph[0]) {\\n            for (int i = 0; i < N; ++i) {\\n                outdegree[1][i][v]--;\\n            }\\n        }\\n        // run the topological sort from queue\\n        while (q.size()) {\\n            auto turn = q.front()[0];\\n            auto mouse = q.front()[1];\\n            auto cat = q.front()[2];\\n            q.pop();\\n\\n            if (turn == 0 && mouse == 1 && cat == 2) {\\n                // the result has been inferenced\\n                break;\\n            }\\n\\n            if (turn == 0) { // mouse\\'s turn\\n                // v is the prev position of cat\\n                for (auto &v : graph[cat]) {\\n                    if (v == 0) {\\n                        continue;\\n                    }\\n\\n                    if (dp[1][mouse][v] > 0) {\\n                        continue;\\n                    }\\n\\n                    if (dp[turn][mouse][cat] == 2) {\\n                        // cat wants to move from v to `cat` position, and thus cat wins\\n                        dp[1][mouse][v] = 2;\\n                        q.push({1, mouse, v});\\n                        continue;\\n                    }\\n\\n                    outdegree[1][mouse][v]--;\\n                    if (outdegree[1][mouse][v] == 0) {\\n                        dp[1][mouse][v] = 1;\\n                        q.push({1, mouse, v});\\n                    }\\n                }\\n            } else { // cat\\'s turn\\n\\t\\t\\t\\t// v is the prev position of mouse\\n                for (auto &v : graph[mouse]) {\\n                    if (dp[0][v][cat] > 0) {\\n                        continue;\\n                    }\\n\\n                    if (dp[turn][mouse][cat] == 1) {\\n                        // mouse wants to move from v to `mouse` position and thus mouse wins\\n                        dp[0][v][cat] = 1;\\n                        q.push({0, v, cat});\\n                        continue;\\n                    }\\n\\n                    outdegree[0][v][cat]--;\\n                    if (outdegree[0][v][cat] == 0) {\\n                        dp[0][v][cat] = 2;\\n                        q.push({0, v, cat});\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[0][1][2];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        int N = graph.size();\\n        vector<vector<int>> dp[2];\\n        vector<vector<int>> outdegree[2];\\n        queue<vector<int>> q; // q of {turn, mouse position, cat position} for topological sort\\n\\n        dp[0] = vector<vector<int>>(N, vector<int>(N));\\n        dp[1] = vector<vector<int>>(N, vector<int>(N));\\n        outdegree[0] = vector<vector<int>>(N, vector<int>(N));\\n        outdegree[1] = vector<vector<int>>(N, vector<int>(N));\\n\\n        // init dp and queue\\n        for (int j = 0; j < N; ++j) {\\n            dp[0][0][j] = dp[1][0][j] = 1;\\n            q.push({0, 0, j});\\n            q.push({1, 0, j});\\n        }\\n        for (int j = 1; j < N; ++j) {\\n            dp[0][j][j] = dp[1][j][j] = 2;\\n            q.push({0, j, j});\\n            q.push({1, j, j});\\n        }\\n        // init outdegree\\n        for (int i = 0; i < N; ++i) {\\n            for (int j = 1; j < N; ++j) {\\n                outdegree[0][i][j] = graph[i].size();\\n                outdegree[1][i][j] = graph[j].size();\\n            }\\n        }\\n        for (auto &v : graph[0]) {\\n            for (int i = 0; i < N; ++i) {\\n                outdegree[1][i][v]--;\\n            }\\n        }\\n        // run the topological sort from queue\\n        while (q.size()) {\\n            auto turn = q.front()[0];\\n            auto mouse = q.front()[1];\\n            auto cat = q.front()[2];\\n            q.pop();\\n\\n            if (turn == 0 && mouse == 1 && cat == 2) {\\n                // the result has been inferenced\\n                break;\\n            }\\n\\n            if (turn == 0) { // mouse\\'s turn\\n                // v is the prev position of cat\\n                for (auto &v : graph[cat]) {\\n                    if (v == 0) {\\n                        continue;\\n                    }\\n\\n                    if (dp[1][mouse][v] > 0) {\\n                        continue;\\n                    }\\n\\n                    if (dp[turn][mouse][cat] == 2) {\\n                        // cat wants to move from v to `cat` position, and thus cat wins\\n                        dp[1][mouse][v] = 2;\\n                        q.push({1, mouse, v});\\n                        continue;\\n                    }\\n\\n                    outdegree[1][mouse][v]--;\\n                    if (outdegree[1][mouse][v] == 0) {\\n                        dp[1][mouse][v] = 1;\\n                        q.push({1, mouse, v});\\n                    }\\n                }\\n            } else { // cat\\'s turn\\n\\t\\t\\t\\t// v is the prev position of mouse\\n                for (auto &v : graph[mouse]) {\\n                    if (dp[0][v][cat] > 0) {\\n                        continue;\\n                    }\\n\\n                    if (dp[turn][mouse][cat] == 1) {\\n                        // mouse wants to move from v to `mouse` position and thus mouse wins\\n                        dp[0][v][cat] = 1;\\n                        q.push({0, v, cat});\\n                        continue;\\n                    }\\n\\n                    outdegree[0][v][cat]--;\\n                    if (outdegree[0][v][cat] == 0) {\\n                        dp[0][v][cat] = 2;\\n                        q.push({0, v, cat});\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[0][1][2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2233488,
                "title": "bfs-and-dfs-both-approach-discussed",
                "content": "Approach 1 : approximation solution DFS\\n```\\nclass Solution {\\npublic:\\n\\n   int dp[501][51][51];\\n\\tint solver(int t,int m,int c,vector<vector<int>>&graph,int n){\\n  \\n    if(t==5*n) \\n        dp[t][m][c]=0;\\n   \\n    if(m==0) \\n        return dp[t][m][c]=1;\\n    \\n    if(m==c) \\n        return dp[t][m][c]=2;\\n    \\n    \\n    \\n    if(dp[t][m][c]!=-1)\\n        return dp[t][m][c];\\n    \\n    int turn=t%2;\\n        \\n    if(turn==0){\\n        \\n        int ans[3];\\n        memset(ans,0,sizeof(ans));\\n        \\n      \\n        \\n        for(int i=0;i<graph[m].size();i++){\\n            \\n            int win=solver(t+1,graph[m][i],c,graph,n);\\n            \\n            ans[win]++;\\n            \\n            if(ans[1])\\n            return dp[t][m][c]=1;\\n           \\n        }\\n       \\n        \\n        if(ans[0])\\n            return dp[t][m][c]=0;\\n        else\\n            return dp[t][m][c]=2;\\n            \\n         \\n    }\\n    else\\n    {\\n      \\n        int ans[3];\\n        memset(ans,0,sizeof(ans));\\n        \\n        \\n        for(int i=0;i<graph[c].size();i++)\\n        {\\n            if(graph[c][i]!=0)\\n            {\\n                \\n                int win=solver(t+1,m,graph[c][i],graph,n);\\n                \\n                ans[win]++;\\n                \\n               if(ans[2])\\n                  return dp[t][m][c]=2;\\n            }\\n        }\\n        \\n        \\n        if(ans[0])\\n            return dp[t][m][c]=0;\\n        else\\n             return dp[t][m][c]=1;\\n       \\n    }\\n   \\n}\\nint catMouseGame(vector<vector<int>>& graph) {\\n    int n=graph.size();\\n    memset(dp,-1,sizeof(dp));\\n    return solver(0,1,2,graph,n);\\n}\\n};\\n```\\n\\nAprroach 2: BFS Graph coloring\\n\\n\\n\\n\\ngraph colouring\\neach state (m,c,t)  -> represent a node\\nthere will be 3 colors  M-->1    C-->2    D-->0  each node will be colored in one of these color\\n\\nif node (m,c,t) have color M-> this mean that if cat and mouse reach this state the mouse win\\nif node (m,c,t) have color C-> this mean that if cat and mouse reach this state the cat win\\n\\nbut initially we know the color of some nodes\\n\\n```\\nfor(int c=1;c<n;c++)\\n       {\\n           col[0][c][1] = 1;\\n           col[0][c][2] = 1;\\n           \\n           q.push({0,c,1,1});\\n           q.push({0,c,2,1});\\n       }\\n        \\n       for(int m=1;m<n;m++)\\n       {\\n           col[m][m][1] = 2;\\n           col[m][m][2] = 2;\\n           \\n           q.push({m,m,1,2});\\n           q.push({m,m,2,2});\\n       }\\n```\\n\\nwe try to color the parent using child node \\n**How to color ?**\\nWe will color each node we will see all its parent that are  marked DRAW (not colored) according to the following rule. (We\\'ll suppose the node has parent.turn =Mouse ( parent.t = Mouse))\\n\\n(\"Immediate coloring\"): If there is a child that is colored MOUSE, then this node will also be colored MOUSE.\\n\\n(\"Eventual coloring\"): If all children are colored CAT, then this node will also be colored CAT.( if all the child of this node is traversed and still the node is not colored this mean that all its child are colored CAT (none of its child is colored MOUSE))\\n\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>par[51][51][3]; \\n    //  our new graph\\n    // t==1 -> mouse chance\\n    // t==2 -> cat chance\\n    \\n    // \\n    int catMouseGame(vector<vector<int>>& ed) {\\n      \\n        int n=ed.size();\\n        \\n        int col[51][51][3];\\n        int deg[51][51][3];\\n        \\n        memset(col,0,sizeof(col));\\n        memset(deg,0,sizeof(deg));\\n        \\n        \\n        for(int m=0;m<n;m++)\\n        {\\n            for(int c=1;c<n;c++)  // c is starting from 1 as c cant be zero\\n            {\\n                \\n                for(int i=0;i<ed[m].size();i++)\\n                {\\n                    par[ed[m][i]][c][2].push_back({m,c,1});\\n                    deg[m][c][1]++; // Collecting the degree of each node\\n                        \\n                  \\n                    // m c 1 -> child -> ed[m][i] c 2 --->\\n                    // ed[m][i] c 2   -> parent -> m c 1\\n                }\\n                \\n                for(int i=0;i<ed[c].size();i++)\\n                {\\n                    if(ed[c][i]!=0) //  cat can,t reach zero node\\n                    {\\n                        par[m][ed[c][i]][1].push_back({m,c,2});\\n                        deg[m][c][2]++; //// Collecting the degree of each node\\n                            \\n                      \\n                        \\n                    }\\n                }\\n            }\\n        }\\n        \\n        queue<vector<int>>q;\\n        \\n       for(int c=1;c<n;c++)\\n       {\\n           col[0][c][1] = 1;\\n           col[0][c][2] = 1;\\n           \\n           q.push({0,c,1,1});\\n           q.push({0,c,2,1});\\n       }\\n        \\n       for(int m=1;m<n;m++)\\n       {\\n           col[m][m][1] = 2;\\n           col[m][m][2] = 2;\\n           \\n           q.push({m,m,1,2});\\n           q.push({m,m,2,2});\\n       }\\n        \\n        \\n        while(!q.empty())\\n        {\\n            vector<int>node=q.front();\\n            q.pop();\\n            \\n            int m=node[0];\\n            int c=node[1];\\n            int t=node[2];\\n            int s=node[3]; // ->> color of the node\\n         \\n            for(int i=0;i<par[m][c][t].size();i++)\\n            {\\n               int u=par[m][c][t][i][0];\\n               int v=par[m][c][t][i][1];\\n               int w=par[m][c][t][i][2]; //->> turn  of parent \\n              \\n               \\n                if(!col[u][v][w])\\n                {\\n                    if(w==s) // child is colored s AND parent of this node have turn of s --> (\"Immediate coloring\")\\n                    {\\n                        col[u][v][w]=w; \\n                       \\n                        q.push({u,v,w,w});\\n                    }\\n                    else \\n                    {\\n                        deg[u][v][w]--;\\n                        \\n                        if(deg[u][v][w]==0) // All children are traversed and still parent is uncolored  -> eventual coloring\\n                        {\\n                            col[u][v][w]=3-w;\\n                            q.push({u,v,w,3-w});\\n                        }\\n                    }\\n                }\\n              \\n            }\\n            \\n        }\\n        return col[1][2][1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n   int dp[501][51][51];\\n\\tint solver(int t,int m,int c,vector<vector<int>>&graph,int n){\\n  \\n    if(t==5*n) \\n        dp[t][m][c]=0;\\n   \\n    if(m==0) \\n        return dp[t][m][c]=1;\\n    \\n    if(m==c) \\n        return dp[t][m][c]=2;\\n    \\n    \\n    \\n    if(dp[t][m][c]!=-1)\\n        return dp[t][m][c];\\n    \\n    int turn=t%2;\\n        \\n    if(turn==0){\\n        \\n        int ans[3];\\n        memset(ans,0,sizeof(ans));\\n        \\n      \\n        \\n        for(int i=0;i<graph[m].size();i++){\\n            \\n            int win=solver(t+1,graph[m][i],c,graph,n);\\n            \\n            ans[win]++;\\n            \\n            if(ans[1])\\n            return dp[t][m][c]=1;\\n           \\n        }\\n       \\n        \\n        if(ans[0])\\n            return dp[t][m][c]=0;\\n        else\\n            return dp[t][m][c]=2;\\n            \\n         \\n    }\\n    else\\n    {\\n      \\n        int ans[3];\\n        memset(ans,0,sizeof(ans));\\n        \\n        \\n        for(int i=0;i<graph[c].size();i++)\\n        {\\n            if(graph[c][i]!=0)\\n            {\\n                \\n                int win=solver(t+1,m,graph[c][i],graph,n);\\n                \\n                ans[win]++;\\n                \\n               if(ans[2])\\n                  return dp[t][m][c]=2;\\n            }\\n        }\\n        \\n        \\n        if(ans[0])\\n            return dp[t][m][c]=0;\\n        else\\n             return dp[t][m][c]=1;\\n       \\n    }\\n   \\n}\\nint catMouseGame(vector<vector<int>>& graph) {\\n    int n=graph.size();\\n    memset(dp,-1,sizeof(dp));\\n    return solver(0,1,2,graph,n);\\n}\\n};\\n```\n```\\nfor(int c=1;c<n;c++)\\n       {\\n           col[0][c][1] = 1;\\n           col[0][c][2] = 1;\\n           \\n           q.push({0,c,1,1});\\n           q.push({0,c,2,1});\\n       }\\n        \\n       for(int m=1;m<n;m++)\\n       {\\n           col[m][m][1] = 2;\\n           col[m][m][2] = 2;\\n           \\n           q.push({m,m,1,2});\\n           q.push({m,m,2,2});\\n       }\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>par[51][51][3]; \\n    //  our new graph\\n    // t==1 -> mouse chance\\n    // t==2 -> cat chance\\n    \\n    // \\n    int catMouseGame(vector<vector<int>>& ed) {\\n      \\n        int n=ed.size();\\n        \\n        int col[51][51][3];\\n        int deg[51][51][3];\\n        \\n        memset(col,0,sizeof(col));\\n        memset(deg,0,sizeof(deg));\\n        \\n        \\n        for(int m=0;m<n;m++)\\n        {\\n            for(int c=1;c<n;c++)  // c is starting from 1 as c cant be zero\\n            {\\n                \\n                for(int i=0;i<ed[m].size();i++)\\n                {\\n                    par[ed[m][i]][c][2].push_back({m,c,1});\\n                    deg[m][c][1]++; // Collecting the degree of each node\\n                        \\n                  \\n                    // m c 1 -> child -> ed[m][i] c 2 --->\\n                    // ed[m][i] c 2   -> parent -> m c 1\\n                }\\n                \\n                for(int i=0;i<ed[c].size();i++)\\n                {\\n                    if(ed[c][i]!=0) //  cat can,t reach zero node\\n                    {\\n                        par[m][ed[c][i]][1].push_back({m,c,2});\\n                        deg[m][c][2]++; //// Collecting the degree of each node\\n                            \\n                      \\n                        \\n                    }\\n                }\\n            }\\n        }\\n        \\n        queue<vector<int>>q;\\n        \\n       for(int c=1;c<n;c++)\\n       {\\n           col[0][c][1] = 1;\\n           col[0][c][2] = 1;\\n           \\n           q.push({0,c,1,1});\\n           q.push({0,c,2,1});\\n       }\\n        \\n       for(int m=1;m<n;m++)\\n       {\\n           col[m][m][1] = 2;\\n           col[m][m][2] = 2;\\n           \\n           q.push({m,m,1,2});\\n           q.push({m,m,2,2});\\n       }\\n        \\n        \\n        while(!q.empty())\\n        {\\n            vector<int>node=q.front();\\n            q.pop();\\n            \\n            int m=node[0];\\n            int c=node[1];\\n            int t=node[2];\\n            int s=node[3]; // ->> color of the node\\n         \\n            for(int i=0;i<par[m][c][t].size();i++)\\n            {\\n               int u=par[m][c][t][i][0];\\n               int v=par[m][c][t][i][1];\\n               int w=par[m][c][t][i][2]; //->> turn  of parent \\n              \\n               \\n                if(!col[u][v][w])\\n                {\\n                    if(w==s) // child is colored s AND parent of this node have turn of s --> (\"Immediate coloring\")\\n                    {\\n                        col[u][v][w]=w; \\n                       \\n                        q.push({u,v,w,w});\\n                    }\\n                    else \\n                    {\\n                        deg[u][v][w]--;\\n                        \\n                        if(deg[u][v][w]==0) // All children are traversed and still parent is uncolored  -> eventual coloring\\n                        {\\n                            col[u][v][w]=3-w;\\n                            q.push({u,v,w,3-w});\\n                        }\\n                    }\\n                }\\n              \\n            }\\n            \\n        }\\n        return col[1][2][1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2161866,
                "title": "dp-memo-draw-condition",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    //The draw condition is not appropriate though we can make such a graph which can have endless cycles and \\n    // moves can be different though on those cycles \\n    //so the draw codition will expand with the number of test cases i personally feel that\\n\\t   int dp[501][51][51];\\n\\t\\tint util(int t,int m,int c,vector<vector<int>>&graph,int n){\\n        //base cases\\n        if(t==5*n) dp[t][m][c]=0;\\n        //case 2 if mouse ever reaches the 0 whatever the moves or whatever the cat\\'s pos mouse will win\\n        if(m==0) return dp[t][m][c]=1;\\n        //case 3 if mouse is caught by cat than he cant win,cat will win\\n        if(m==c) return dp[t][m][c]=2;\\n        \\n        //if state is reapeated\\n        if(dp[t][m][c]!=-1)\\n            return dp[t][m][c];\\n        //The mouse take first step so he will always going to have turn when step will be even\\n        int turn=t%2;\\n        if(turn==0){\\n            //if its turn of mouse than he wants to win so he can only win if the cat will lose on \\n            //one of the next move he is going to take\\n            //the flag tells us about the draw condition\\n            //if none of them can win it will be a draw\\n            bool flag=true;\\n            for(int i=0;i<graph[m].size();i++){\\n                int winner=util(t+1,graph[m][i],c,graph,n);\\n                if(winner==1)\\n                    return dp[t][m][c]=1;\\n                //this is a tricky part i.e every player wants to play optimally \\n                //so either they want a win or if not possible  a draw \\n                else if(winner!=2)\\n                    flag=false;\\n            }\\n            //if we are out of that means mouse cant win so he will look for a draw next\\n            if(!flag)\\n               return dp[t][m][c]=0;\\n            else \\n                 return dp[t][m][c]=2;      \\n        }\\n        else{\\n            bool flag=true;\\n            for(int i=0;i<graph[c].size();i++){\\n                if(graph[c][i]!=0){\\n                int winner=util(t+1,m,graph[c][i],graph,n);\\n                if(winner==2)\\n                return dp[t][m][c]=2;\\n                else if(winner!=1)\\n                    flag=false;\\n                }\\n            }\\n            if(!flag)\\n                return dp[t][m][c]=0;\\n            else\\n                return dp[t][m][c]=1;\\n        }\\n        //because c++ want a return \\n        return dp[t][m][c];\\n      \\n    }\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        int n=graph.size();\\n        memset(dp,-1,sizeof(dp));\\n        return util(0,1,2,graph,n);\\n    }\\n\\t};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    //The draw condition is not appropriate though we can make such a graph which can have endless cycles and \\n    // moves can be different though on those cycles \\n    //so the draw codition will expand with the number of test cases i personally feel that\\n\\t   int dp[501][51][51];\\n\\t\\tint util(int t,int m,int c,vector<vector<int>>&graph,int n){\\n        //base cases\\n        if(t==5*n) dp[t][m][c]=0;\\n        //case 2 if mouse ever reaches the 0 whatever the moves or whatever the cat\\'s pos mouse will win\\n        if(m==0) return dp[t][m][c]=1;\\n        //case 3 if mouse is caught by cat than he cant win,cat will win\\n        if(m==c) return dp[t][m][c]=2;\\n        \\n        //if state is reapeated\\n        if(dp[t][m][c]!=-1)\\n            return dp[t][m][c];\\n        //The mouse take first step so he will always going to have turn when step will be even\\n        int turn=t%2;\\n        if(turn==0){\\n            //if its turn of mouse than he wants to win so he can only win if the cat will lose on \\n            //one of the next move he is going to take\\n            //the flag tells us about the draw condition\\n            //if none of them can win it will be a draw\\n            bool flag=true;\\n            for(int i=0;i<graph[m].size();i++){\\n                int winner=util(t+1,graph[m][i],c,graph,n);\\n                if(winner==1)\\n                    return dp[t][m][c]=1;\\n                //this is a tricky part i.e every player wants to play optimally \\n                //so either they want a win or if not possible  a draw \\n                else if(winner!=2)\\n                    flag=false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2155161,
                "title": "working-dfs-javascript-solution",
                "content": "I want to preface this with the fact that I still don\\'t fully understand it despite the solution I\\'ve posted below. I had to piece this together from the other discussion solutions and this one does work but it seems it will probably fail in future if extra test cases are added.\\n\\nThis solution is flawed, it\\'s slow but it makes the most sense to me. The flaw with it is that it only solves the problem as the length of state is increased. Reducing state length below n * 5 will make it fail for the 89 test cases seen since this was posted.\\n\\nI\\'m not entirely sure how to fix it and I\\'m open to suggestions. But hey at least we know why all the DFS solutions posted have been failing. Just don\\'t know exactly what\\'s wrong with the algorithm below.\\n\\n```\\nvar catMouseGame = function (graph) {\\n\\tconst n = graph.length;\\n\\t//using anything less than n * 5 won\\'t pass the 89 test cases since the June 2022. As test cases get harder will need to increase this value or fix this algorithm\\n\\tconst state = new Array(n * 5)\\n\\t\\t.fill(0)\\n\\t\\t.map((el, i) => new Array(n).fill(0).map((el, i) => new Array(n).fill(-1)));\\n\\n\\tfunction updateState(step, cat, mouse, value) {\\n\\t\\tstate[step][cat][mouse] = value;\\n\\t\\treturn state[step][cat][mouse];\\n\\t}\\n\\n\\tfunction dfs(step, cat, mouse) {\\n\\t\\tif (step >= state.length) return 0;\\n\\t\\tif (state[step][cat][mouse] !== -1) {\\n\\t\\t\\treturn state[step][cat][mouse];\\n\\t\\t}\\n\\t\\tlet finalResult = -1;\\n\\t\\tif (step & 1) {\\n\\t\\t\\t//cat\\'s turn\\n\\t\\t\\tif (graph[cat].includes(mouse)) {\\n\\t\\t\\t\\treturn (state[step][cat][mouse] = 2);\\n\\t\\t\\t}\\n\\t\\t\\tfor (const node of graph[cat]) {\\n\\t\\t\\t\\tif (node !== 0) {\\n\\t\\t\\t\\t\\tlet nextResult = dfs(step + 1, node, mouse, 0);\\n\\t\\t\\t\\t\\tif (nextResult === 2) {\\n\\t\\t\\t\\t\\t\\treturn (state[step][cat][mouse] = 2);\\n\\t\\t\\t\\t\\t} else if (nextResult === 1) {\\n\\t\\t\\t\\t\\t\\tif (finalResult === -1) {\\n\\t\\t\\t\\t\\t\\t\\tfinalResult = 1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t} else if (nextResult === 0) {\\n\\t\\t\\t\\t\\t\\tfinalResult = 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (finalResult === -1) {\\n\\t\\t\\t\\tfinalResult = 1;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t//mouse\\'s turn\\n\\t\\t\\tif (graph[mouse].includes(0)) {\\n\\t\\t\\t\\treturn (state[step][cat][mouse] = 1);\\n\\t\\t\\t}\\n\\t\\t\\tfor (const node of graph[mouse]) {\\n\\t\\t\\t\\tif (node !== cat && !graph[node].includes(cat)) {\\n\\t\\t\\t\\t\\tlet nextResult = dfs(step + 1, cat, node, 1);\\n\\t\\t\\t\\t\\tif (nextResult === 1) {\\n\\t\\t\\t\\t\\t\\treturn (state[step][cat][mouse] = 1);\\n\\t\\t\\t\\t\\t} else if (nextResult === 2) {\\n\\t\\t\\t\\t\\t\\tif (finalResult === -1) {\\n\\t\\t\\t\\t\\t\\t\\tfinalResult = 2;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t} else if (nextResult === 0) {\\n\\t\\t\\t\\t\\t\\tfinalResult = 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (finalResult === -1) {\\n\\t\\t\\t\\tfinalResult = 2;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn (state[step][cat][mouse] = finalResult);\\n\\t}\\n\\treturn dfs(0, 2, 1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar catMouseGame = function (graph) {\\n\\tconst n = graph.length;\\n\\t//using anything less than n * 5 won\\'t pass the 89 test cases since the June 2022. As test cases get harder will need to increase this value or fix this algorithm\\n\\tconst state = new Array(n * 5)\\n\\t\\t.fill(0)\\n\\t\\t.map((el, i) => new Array(n).fill(0).map((el, i) => new Array(n).fill(-1)));\\n\\n\\tfunction updateState(step, cat, mouse, value) {\\n\\t\\tstate[step][cat][mouse] = value;\\n\\t\\treturn state[step][cat][mouse];\\n\\t}\\n\\n\\tfunction dfs(step, cat, mouse) {\\n\\t\\tif (step >= state.length) return 0;\\n\\t\\tif (state[step][cat][mouse] !== -1) {\\n\\t\\t\\treturn state[step][cat][mouse];\\n\\t\\t}\\n\\t\\tlet finalResult = -1;\\n\\t\\tif (step & 1) {\\n\\t\\t\\t//cat\\'s turn\\n\\t\\t\\tif (graph[cat].includes(mouse)) {\\n\\t\\t\\t\\treturn (state[step][cat][mouse] = 2);\\n\\t\\t\\t}\\n\\t\\t\\tfor (const node of graph[cat]) {\\n\\t\\t\\t\\tif (node !== 0) {\\n\\t\\t\\t\\t\\tlet nextResult = dfs(step + 1, node, mouse, 0);\\n\\t\\t\\t\\t\\tif (nextResult === 2) {\\n\\t\\t\\t\\t\\t\\treturn (state[step][cat][mouse] = 2);\\n\\t\\t\\t\\t\\t} else if (nextResult === 1) {\\n\\t\\t\\t\\t\\t\\tif (finalResult === -1) {\\n\\t\\t\\t\\t\\t\\t\\tfinalResult = 1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t} else if (nextResult === 0) {\\n\\t\\t\\t\\t\\t\\tfinalResult = 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (finalResult === -1) {\\n\\t\\t\\t\\tfinalResult = 1;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t//mouse\\'s turn\\n\\t\\t\\tif (graph[mouse].includes(0)) {\\n\\t\\t\\t\\treturn (state[step][cat][mouse] = 1);\\n\\t\\t\\t}\\n\\t\\t\\tfor (const node of graph[mouse]) {\\n\\t\\t\\t\\tif (node !== cat && !graph[node].includes(cat)) {\\n\\t\\t\\t\\t\\tlet nextResult = dfs(step + 1, cat, node, 1);\\n\\t\\t\\t\\t\\tif (nextResult === 1) {\\n\\t\\t\\t\\t\\t\\treturn (state[step][cat][mouse] = 1);\\n\\t\\t\\t\\t\\t} else if (nextResult === 2) {\\n\\t\\t\\t\\t\\t\\tif (finalResult === -1) {\\n\\t\\t\\t\\t\\t\\t\\tfinalResult = 2;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t} else if (nextResult === 0) {\\n\\t\\t\\t\\t\\t\\tfinalResult = 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (finalResult === -1) {\\n\\t\\t\\t\\tfinalResult = 2;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn (state[step][cat][mouse] = finalResult);\\n\\t}\\n\\treturn dfs(0, 2, 1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2012196,
                "title": "clear-explanation-along-with-assertions-heavily-commented",
                "content": "```\\nclass Solution {\\nprivate:\\n     const int DRAW = 0;\\n     const int MOUSE = 1;\\n     const int CAT = 2;\\npublic:\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        // mouse, cat, turn\\n        int res[n][n][3]; // 3 just to make results and turns consistent\\n        int deg[n][n][3];\\n        memset(res, DRAW, sizeof(res)); // mark all states neutral as FINALLY DRAWN STATEs are never pushed in the queue\\n                                        // and thus all unpushed states will be FINALLY DRAWN\\n        for (int mouse = 0; mouse < n; mouse++) {\\n            for (int cat = 1; cat < n; cat++) {\\n                deg[mouse][cat][MOUSE] = (int)graph[mouse].size(); // no of children of this state, where all can we go from this state\\n                deg[mouse][cat][CAT] = (int)graph[cat].size(); // no of children of this state, where all can we go from this state\\n                for (auto &x : graph[cat]) {\\n                    if (x == 0) {\\n                        deg[mouse][cat][CAT]--; // note we can\\'t go to 0 from some node for cat\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        queue<tuple<int, int, int>>q;\\n        for (int both = 1; both < n; both++) {\\n            res[both][both][CAT] = CAT; // both are at the same node, cat wins\\n            res[both][both][MOUSE] = CAT; // both are at the same node, cat wins\\n            q.push({both, both, CAT});\\n            q.push({both, both, MOUSE});\\n        }\\n        for (int cat = 1; cat < n; cat++) {\\n            res[0][cat][CAT] = MOUSE; // mouse is at 0 mouse wins\\n            q.push(make_tuple(0, cat, CAT));\\n        }\\n        while (!q.empty()) {\\n            auto [mouse, cat, turn] = q.front();\\n            int curRes = res[mouse][cat][turn];\\n            assert(curRes != DRAW); // we NEVER push in a FINALLY DRAWN STATE to the queue\\n            // cout << mouse << \" \" << cat << \" \" << turn << \" \" << curRes << endl;\\n            q.pop();\\n            if (turn == MOUSE) {\\n                for (auto &neigh : graph[cat]) { // all nodes from where we can arrive at the popped node, \\n                                                 // as the present turn is MOUSE the previous turn must have been CAT, \\n                                                 // therefore cat made a move from some node to \\'cat\\'\\n                    if (neigh == 0) continue; // not possible for cat to have come from 0\\n                    if (res[mouse][neigh][CAT] == DRAW) { // we try to resolve the unresolved states\\n                        if (curRes == CAT) {\\n                            res[mouse][neigh][CAT] = CAT;\\n                            q.push(make_tuple(mouse, neigh, CAT));\\n                        } else {\\n                            // because we are not pushing any node in the queue for which curRes is DRAW\\n                            // that means all the children which subtracted the degree must have been the loosing states\\n                            // if there are some FINALLY DRAWN STATES still attached to this node that means the degree will never become 0\\n                            deg[mouse][neigh][CAT]--;\\n                            if (!deg[mouse][neigh][CAT]) {\\n                                res[mouse][neigh][CAT] = MOUSE;\\n                                q.push(make_tuple(mouse, neigh, CAT));\\n                            }\\n                            \\n                        }\\n                    }\\n                } \\n            }\\n            else {\\n                for (auto &neigh : graph[mouse]) { // all nodes from where we can arrive at the popped node\\n                    if (res[neigh][cat][MOUSE] == DRAW) {\\n                        if (curRes == MOUSE) {\\n                            res[neigh][cat][MOUSE] = MOUSE;\\n                            q.push(make_tuple(neigh, cat, MOUSE));\\n                        } else {\\n                            deg[neigh][cat][MOUSE]--;\\n                            if (!deg[neigh][cat][MOUSE]) {\\n                                res[neigh][cat][MOUSE] = CAT;\\n                                q.push(make_tuple(neigh, cat, MOUSE));\\n                            }\\n\\n                        }\\n                    }\\n                }\\n                \\n            }   \\n        }\\n        return res[1][2][MOUSE];\\n    }\\n};\\n```\\nPlease upvote if found helpful, thanks !",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n     const int DRAW = 0;\\n     const int MOUSE = 1;\\n     const int CAT = 2;\\npublic:\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        // mouse, cat, turn\\n        int res[n][n][3]; // 3 just to make results and turns consistent\\n        int deg[n][n][3];\\n        memset(res, DRAW, sizeof(res)); // mark all states neutral as FINALLY DRAWN STATEs are never pushed in the queue\\n                                        // and thus all unpushed states will be FINALLY DRAWN\\n        for (int mouse = 0; mouse < n; mouse++) {\\n            for (int cat = 1; cat < n; cat++) {\\n                deg[mouse][cat][MOUSE] = (int)graph[mouse].size(); // no of children of this state, where all can we go from this state\\n                deg[mouse][cat][CAT] = (int)graph[cat].size(); // no of children of this state, where all can we go from this state\\n                for (auto &x : graph[cat]) {\\n                    if (x == 0) {\\n                        deg[mouse][cat][CAT]--; // note we can\\'t go to 0 from some node for cat\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        queue<tuple<int, int, int>>q;\\n        for (int both = 1; both < n; both++) {\\n            res[both][both][CAT] = CAT; // both are at the same node, cat wins\\n            res[both][both][MOUSE] = CAT; // both are at the same node, cat wins\\n            q.push({both, both, CAT});\\n            q.push({both, both, MOUSE});\\n        }\\n        for (int cat = 1; cat < n; cat++) {\\n            res[0][cat][CAT] = MOUSE; // mouse is at 0 mouse wins\\n            q.push(make_tuple(0, cat, CAT));\\n        }\\n        while (!q.empty()) {\\n            auto [mouse, cat, turn] = q.front();\\n            int curRes = res[mouse][cat][turn];\\n            assert(curRes != DRAW); // we NEVER push in a FINALLY DRAWN STATE to the queue\\n            // cout << mouse << \" \" << cat << \" \" << turn << \" \" << curRes << endl;\\n            q.pop();\\n            if (turn == MOUSE) {\\n                for (auto &neigh : graph[cat]) { // all nodes from where we can arrive at the popped node, \\n                                                 // as the present turn is MOUSE the previous turn must have been CAT, \\n                                                 // therefore cat made a move from some node to \\'cat\\'\\n                    if (neigh == 0) continue; // not possible for cat to have come from 0\\n                    if (res[mouse][neigh][CAT] == DRAW) { // we try to resolve the unresolved states\\n                        if (curRes == CAT) {\\n                            res[mouse][neigh][CAT] = CAT;\\n                            q.push(make_tuple(mouse, neigh, CAT));\\n                        } else {\\n                            // because we are not pushing any node in the queue for which curRes is DRAW\\n                            // that means all the children which subtracted the degree must have been the loosing states\\n                            // if there are some FINALLY DRAWN STATES still attached to this node that means the degree will never become 0\\n                            deg[mouse][neigh][CAT]--;\\n                            if (!deg[mouse][neigh][CAT]) {\\n                                res[mouse][neigh][CAT] = MOUSE;\\n                                q.push(make_tuple(mouse, neigh, CAT));\\n                            }\\n                            \\n                        }\\n                    }\\n                } \\n            }\\n            else {\\n                for (auto &neigh : graph[mouse]) { // all nodes from where we can arrive at the popped node\\n                    if (res[neigh][cat][MOUSE] == DRAW) {\\n                        if (curRes == MOUSE) {\\n                            res[neigh][cat][MOUSE] = MOUSE;\\n                            q.push(make_tuple(neigh, cat, MOUSE));\\n                        } else {\\n                            deg[neigh][cat][MOUSE]--;\\n                            if (!deg[neigh][cat][MOUSE]) {\\n                                res[neigh][cat][MOUSE] = CAT;\\n                                q.push(make_tuple(neigh, cat, MOUSE));\\n                            }\\n\\n                        }\\n                    }\\n                }\\n                \\n            }   \\n        }\\n        return res[1][2][MOUSE];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1987561,
                "title": "c-3ms-iterative-minimax-beats-100-time-and-98-space",
                "content": "edit1 :: Testcases were updated, not quite as fast anymore :( \\nchanging line 88 to ```for (int i = 0; i < 6 && answer == 1; ++i)```\\nwill still yield very good performance, but this is not guarenteed to be correct for all possible inputs\\n\\n```\\nclass Solution {\\npublic:\\n    array<array<int,50>,50> visited1,visited0;\\n    \\n    //boring functions not important\\n    void initialize(){\\n        for (int i = 0; i < 50; ++i){\\n            for (int j = 0; j < 50; ++j){\\n                visited1[i][j] = -1;\\n                visited0[i][j] = -1;\\n            }\\n        }\\n    }  \\n    void clear_array(){\\n        for (int i = 0; i < 50; ++i){\\n            for (int j = 0; j < 50; ++j){\\n                if (visited1[i][j] == 1)\\n                    visited1[i][j] = -1;\\n                if (visited0[i][j] == 1)\\n                    visited0[i][j] = -1;\\n            }\\n        }\\n    }\\n    // cat wants to minimize outputs, mouse wants to maximize, use memoization to keep track whether a given node is a win, loss, or draw\\n    int minicat(vector<vector<int>> &graph, int mouse, int cat){\\n        if (visited1[mouse][cat] != -1)\\n            return visited1[mouse][cat];\\n        \\n        if (mouse == 0){\\n            visited1[mouse][cat] = 2;\\n            return 2;\\n        }\\n        if (mouse == cat){\\n            visited1[mouse][cat] = 0;\\n            return 0;\\n        }\\n\\t\\t//assume its a draw until proven otherwise, any mismatching from this will be corrected during iteration\\n        visited1[mouse][cat] = 1;\\n        \\n        int output = 2;\\n        for (auto i : graph[cat]){\\n            if (i == 0){\\n                continue;\\n            }\\n            output = min(output,maximouse(graph,mouse,i));\\n            if (output == 0){\\n                break;\\n            }\\n        }\\n        visited1[mouse][cat] = output;\\n        return output;\\n    }\\n    \\n    //identical to above function, but checks for maximums rather than minimums, and allows mouse to enter 0 node\\n    int maximouse(vector<vector<int>> &graph, int mouse, int cat){\\n        \\n        if (visited0[mouse][cat] != -1){\\n            return visited0[mouse][cat];\\n        }\\n        \\n        if (mouse == 0){\\n            visited0[mouse][cat] = 2;\\n            return 2;\\n        }\\n        if (mouse == cat){\\n            visited0[mouse][cat] = 0;\\n            return 0;\\n        }\\n        visited0[mouse][cat] = 1;\\n        int output = 0;\\n        for (auto i: graph[mouse]){\\n            output = max(output,minicat(graph,i,cat));\\n            if (output == 2){\\n                break;\\n            }\\n        }\\n        visited0[mouse][cat] = output;\\n        return output;\\n    }\\n    \\n    \\n    \\n    int catMouseGame(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        initialize();\\n        int answer = maximouse(graph,1,2);\\n        //inital output is usually correct, but in some edge cases it can return a draw, to fix this we can simply reapply the function after resetting any nodes which claim to be draws\\n        for (int i = 0; i < n && answer == 1; ++i){\\n            clear_array();\\n            answer = maximouse(graph,1,2);\\n        }\\n        \\n        //seems more intuitive that draws should be 1 but leetcode wants draws to be 0\\n        const int correct_output[3] = {2,0,1};\\n        return correct_output[answer];\\n    }\\n};\\n```\\nEDIT2\\nHere\\'s a slight modification to deal with new testcases, best performance I saw was 10 ms and 9.0 MB\\nThis time during iteration we simply make a copy of the previous matrix and check for cycles by comparing the two, this uses a bit more memory unfortunately, but it can be mitigated by switching from int arrays to char arrays\\n```\\nclass Solution {\\npublic:\\n    array<array<char,50>,50> visited1,visited0;\\n    \\n    //boring functions not important\\n    void initialize(){\\n        for (int i = 0; i < 50; ++i){\\n            for (int j = 0; j < 50; ++j){\\n                visited1[i][j] = -1;\\n                visited0[i][j] = -1;\\n            }\\n        }\\n    }  \\n    void clear_array(){\\n        for (int i = 0; i < 50; ++i){\\n            for (int j = 0; j < 50; ++j){\\n                if (visited1[i][j] == 1)\\n                    visited1[i][j] = -1;\\n                if (visited0[i][j] == 1)\\n                    visited0[i][j] = -1;\\n            }\\n        }\\n    }\\n    // cat wants to minimize outputs, mouse wants to maximize, use memoization to keep track whether a given node is a win, loss, or draw\\n    int minicat(vector<vector<int>> &graph, int mouse, int cat){\\n        if (visited1[mouse][cat] != -1)\\n            return visited1[mouse][cat];\\n        \\n        if (mouse == 0){\\n            visited1[mouse][cat] = 2;\\n            return 2;\\n        }\\n        if (mouse == cat){\\n            visited1[mouse][cat] = 0;\\n            return 0;\\n        }\\n\\t\\t//assume its a draw until proven otherwise, any mismatching from this will be corrected during iteration\\n        visited1[mouse][cat] = 1;\\n        \\n        int output = 2;\\n        for (auto i : graph[cat]){\\n            if (i == 0){\\n                continue;\\n            }\\n            output = min(output,maximouse(graph,mouse,i));\\n            if (output == 0){\\n                break;\\n            }\\n        }\\n        visited1[mouse][cat] = output;\\n        return output;\\n    }\\n    \\n    //identical to above function, but checks for maximums rather than minimums, and allows mouse to enter 0 node\\n    int maximouse(vector<vector<int>> &graph, int mouse, int cat){\\n        \\n        if (visited0[mouse][cat] != -1){\\n            return visited0[mouse][cat];\\n        }\\n        \\n        if (mouse == 0){\\n            visited0[mouse][cat] = 2;\\n            return 2;\\n        }\\n        if (mouse == cat){\\n            visited0[mouse][cat] = 0;\\n            return 0;\\n        }\\n        visited0[mouse][cat] = 1;\\n        int output = 0;\\n        for (auto i: graph[mouse]){\\n            output = max(output,minicat(graph,i,cat));\\n            if (output == 2){\\n                break;\\n            }\\n        }\\n        visited0[mouse][cat] = output;\\n        return output;\\n    }\\n    \\n    \\n    \\n    int catMouseGame(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        initialize();\\n        int answer = maximouse(graph,1,2);\\n        //inital output is usually correct, but in some edge cases it can return a draw, to fix this we can simply reapply the function after resetting any nodes which claim to be draws\\n        if (answer == 1){\\n            array<array<char,50>,50> copy;\\n            do {\\n                copy = visited0;\\n                clear_array();\\n                answer = maximouse(graph,1,2);\\n            }while (answer == 1 && (copy != visited0));\\n        }\\n        \\n        //seems more intuitive that draws should be 1 but leetcode wants draws to be 0\\n        const int correct_output[3] = {2,0,1};\\n        return correct_output[answer];\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```for (int i = 0; i < 6 && answer == 1; ++i)```\n```\\nclass Solution {\\npublic:\\n    array<array<int,50>,50> visited1,visited0;\\n    \\n    //boring functions not important\\n    void initialize(){\\n        for (int i = 0; i < 50; ++i){\\n            for (int j = 0; j < 50; ++j){\\n                visited1[i][j] = -1;\\n                visited0[i][j] = -1;\\n            }\\n        }\\n    }  \\n    void clear_array(){\\n        for (int i = 0; i < 50; ++i){\\n            for (int j = 0; j < 50; ++j){\\n                if (visited1[i][j] == 1)\\n                    visited1[i][j] = -1;\\n                if (visited0[i][j] == 1)\\n                    visited0[i][j] = -1;\\n            }\\n        }\\n    }\\n    // cat wants to minimize outputs, mouse wants to maximize, use memoization to keep track whether a given node is a win, loss, or draw\\n    int minicat(vector<vector<int>> &graph, int mouse, int cat){\\n        if (visited1[mouse][cat] != -1)\\n            return visited1[mouse][cat];\\n        \\n        if (mouse == 0){\\n            visited1[mouse][cat] = 2;\\n            return 2;\\n        }\\n        if (mouse == cat){\\n            visited1[mouse][cat] = 0;\\n            return 0;\\n        }\\n\\t\\t//assume its a draw until proven otherwise, any mismatching from this will be corrected during iteration\\n        visited1[mouse][cat] = 1;\\n        \\n        int output = 2;\\n        for (auto i : graph[cat]){\\n            if (i == 0){\\n                continue;\\n            }\\n            output = min(output,maximouse(graph,mouse,i));\\n            if (output == 0){\\n                break;\\n            }\\n        }\\n        visited1[mouse][cat] = output;\\n        return output;\\n    }\\n    \\n    //identical to above function, but checks for maximums rather than minimums, and allows mouse to enter 0 node\\n    int maximouse(vector<vector<int>> &graph, int mouse, int cat){\\n        \\n        if (visited0[mouse][cat] != -1){\\n            return visited0[mouse][cat];\\n        }\\n        \\n        if (mouse == 0){\\n            visited0[mouse][cat] = 2;\\n            return 2;\\n        }\\n        if (mouse == cat){\\n            visited0[mouse][cat] = 0;\\n            return 0;\\n        }\\n        visited0[mouse][cat] = 1;\\n        int output = 0;\\n        for (auto i: graph[mouse]){\\n            output = max(output,minicat(graph,i,cat));\\n            if (output == 2){\\n                break;\\n            }\\n        }\\n        visited0[mouse][cat] = output;\\n        return output;\\n    }\\n    \\n    \\n    \\n    int catMouseGame(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        initialize();\\n        int answer = maximouse(graph,1,2);\\n        //inital output is usually correct, but in some edge cases it can return a draw, to fix this we can simply reapply the function after resetting any nodes which claim to be draws\\n        for (int i = 0; i < n && answer == 1; ++i){\\n            clear_array();\\n            answer = maximouse(graph,1,2);\\n        }\\n        \\n        //seems more intuitive that draws should be 1 but leetcode wants draws to be 0\\n        const int correct_output[3] = {2,0,1};\\n        return correct_output[answer];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    array<array<char,50>,50> visited1,visited0;\\n    \\n    //boring functions not important\\n    void initialize(){\\n        for (int i = 0; i < 50; ++i){\\n            for (int j = 0; j < 50; ++j){\\n                visited1[i][j] = -1;\\n                visited0[i][j] = -1;\\n            }\\n        }\\n    }  \\n    void clear_array(){\\n        for (int i = 0; i < 50; ++i){\\n            for (int j = 0; j < 50; ++j){\\n                if (visited1[i][j] == 1)\\n                    visited1[i][j] = -1;\\n                if (visited0[i][j] == 1)\\n                    visited0[i][j] = -1;\\n            }\\n        }\\n    }\\n    // cat wants to minimize outputs, mouse wants to maximize, use memoization to keep track whether a given node is a win, loss, or draw\\n    int minicat(vector<vector<int>> &graph, int mouse, int cat){\\n        if (visited1[mouse][cat] != -1)\\n            return visited1[mouse][cat];\\n        \\n        if (mouse == 0){\\n            visited1[mouse][cat] = 2;\\n            return 2;\\n        }\\n        if (mouse == cat){\\n            visited1[mouse][cat] = 0;\\n            return 0;\\n        }\\n\\t\\t//assume its a draw until proven otherwise, any mismatching from this will be corrected during iteration\\n        visited1[mouse][cat] = 1;\\n        \\n        int output = 2;\\n        for (auto i : graph[cat]){\\n            if (i == 0){\\n                continue;\\n            }\\n            output = min(output,maximouse(graph,mouse,i));\\n            if (output == 0){\\n                break;\\n            }\\n        }\\n        visited1[mouse][cat] = output;\\n        return output;\\n    }\\n    \\n    //identical to above function, but checks for maximums rather than minimums, and allows mouse to enter 0 node\\n    int maximouse(vector<vector<int>> &graph, int mouse, int cat){\\n        \\n        if (visited0[mouse][cat] != -1){\\n            return visited0[mouse][cat];\\n        }\\n        \\n        if (mouse == 0){\\n            visited0[mouse][cat] = 2;\\n            return 2;\\n        }\\n        if (mouse == cat){\\n            visited0[mouse][cat] = 0;\\n            return 0;\\n        }\\n        visited0[mouse][cat] = 1;\\n        int output = 0;\\n        for (auto i: graph[mouse]){\\n            output = max(output,minicat(graph,i,cat));\\n            if (output == 2){\\n                break;\\n            }\\n        }\\n        visited0[mouse][cat] = output;\\n        return output;\\n    }\\n    \\n    \\n    \\n    int catMouseGame(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        initialize();\\n        int answer = maximouse(graph,1,2);\\n        //inital output is usually correct, but in some edge cases it can return a draw, to fix this we can simply reapply the function after resetting any nodes which claim to be draws\\n        if (answer == 1){\\n            array<array<char,50>,50> copy;\\n            do {\\n                copy = visited0;\\n                clear_array();\\n                answer = maximouse(graph,1,2);\\n            }while (answer == 1 && (copy != visited0));\\n        }\\n        \\n        //seems more intuitive that draws should be 1 but leetcode wants draws to be 0\\n        const int correct_output[3] = {2,0,1};\\n        return correct_output[answer];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1869936,
                "title": "python-solution-memoization-bottom-up-dp",
                "content": "```\\nclass Solution:\\n    def catMouseGame(self, graph: List[List[int]]) -> int:\\n        def getPreStates(m,c,t):\\n            ans = []\\n            if t == 1:\\n                for c2 in graph[c]:\\n                    if c2 == 0:continue\\n                    ans.append((m,c2,2))\\n            else:\\n                for m2 in graph[m]:\\n                    ans.append((m2,c,1))\\n            return ans\\n        \\n        def ifAllNextMovesFailed(m,c,t):\\n            if t == 1:\\n                for m2 in graph[m]:\\n                    if result[(m2,c,2)] != 2:return False\\n            else:\\n                for c2 in graph[c]:\\n                    if c2 == 0:continue\\n                    if result[(m,c2,1)] != 1:return False\\n            return True\\n        \\n        result = defaultdict(lambda:0) \\n        # key = (m,c,turn) value = (0/1/2)\\n        n = len(graph)\\n        queue = deque()\\n        \\n        for t in range(1,3):\\n            for i in range(1,n):\\n                # mouse win \\n                result[(0,i,t)] = 1\\n                queue.append((0,i,t))\\n                # cat win\\n                result[(i,i,t)] = 2\\n                queue.append((i,i,t))\\n        \\n        while queue:\\n            m,c,t = queue.popleft()\\n            r = result[(m,c,t)]\\n            for m2,c2,t2 in getPreStates(m,c,t):\\n                r2 = result[(m2,c2,t2)]\\n                if r2 > 0:continue\\n                # populate prestate\\n                if r == 3-t: # can always win\\n                    result[(m2,c2,t2)] = r\\n                    queue.append((m2,c2,t2))\\n                elif ifAllNextMovesFailed(m2,c2,t2):\\n                    result[(m2,c2,t2)] =3-t2\\n                    queue.append((m2,c2,t2))\\n        return result[(1,2,1)]\\n                    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Game Theory"
                ],
                "code": "```\\nclass Solution:\\n    def catMouseGame(self, graph: List[List[int]]) -> int:\\n        def getPreStates(m,c,t):\\n            ans = []\\n            if t == 1:\\n                for c2 in graph[c]:\\n                    if c2 == 0:continue\\n                    ans.append((m,c2,2))\\n            else:\\n                for m2 in graph[m]:\\n                    ans.append((m2,c,1))\\n            return ans\\n        \\n        def ifAllNextMovesFailed(m,c,t):\\n            if t == 1:\\n                for m2 in graph[m]:\\n                    if result[(m2,c,2)] != 2:return False\\n            else:\\n                for c2 in graph[c]:\\n                    if c2 == 0:continue\\n                    if result[(m,c2,1)] != 1:return False\\n            return True\\n        \\n        result = defaultdict(lambda:0) \\n        # key = (m,c,turn) value = (0/1/2)\\n        n = len(graph)\\n        queue = deque()\\n        \\n        for t in range(1,3):\\n            for i in range(1,n):\\n                # mouse win \\n                result[(0,i,t)] = 1\\n                queue.append((0,i,t))\\n                # cat win\\n                result[(i,i,t)] = 2\\n                queue.append((i,i,t))\\n        \\n        while queue:\\n            m,c,t = queue.popleft()\\n            r = result[(m,c,t)]\\n            for m2,c2,t2 in getPreStates(m,c,t):\\n                r2 = result[(m2,c2,t2)]\\n                if r2 > 0:continue\\n                # populate prestate\\n                if r == 3-t: # can always win\\n                    result[(m2,c2,t2)] = r\\n                    queue.append((m2,c2,t2))\\n                elif ifAllNextMovesFailed(m2,c2,t2):\\n                    result[(m2,c2,t2)] =3-t2\\n                    queue.append((m2,c2,t2))\\n        return result[(1,2,1)]\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1587124,
                "title": "javascript-dfs-memo-144ms-100",
                "content": "```\\nconst initialize3DArray = (n, m, p) => { let res = []; for (let i = 0; i < n; i++) { let data = []; for (let j = 0; j < m; j++) { let tmp = Array(p).fill(-1); data.push(tmp); } res.push(data); } return res; };\\n\\nlet memo, g, n;\\nconst catMouseGame = (graph) => {\\n    g = graph, n = g.length, memo = initialize3DArray(2 * n, n, n);\\n    return dfs(0, 1, 2);\\n};\\n\\nconst dfs = (step, mouse, cat) => {\\n    if (step == 2 * n) return 0;\\n    if (mouse == cat) return memo[step][mouse][cat] = 2; // mouse be caught\\n    if (mouse == 0) return memo[step][mouse][cat] = 1; // mouse reach the hole\\n    if (memo[step][mouse][cat] != -1) return memo[step][mouse][cat]; // visited\\n    let catWin = true, mouseWin = true;\\n    if (step & 1) { // cat\\'s turn\\n        for (let i = 0; i < g[cat].length; i++) {\\n            if (g[cat][i] == 0) continue;\\n            let next = dfs(step + 1, mouse, g[cat][i]);\\n            if (next == 2) {\\n                return memo[step][mouse][cat] = 2;\\n            } else if (next != 1) {\\n                mouseWin = false;\\n            }\\n        }\\n        return mouseWin ? memo[step][mouse][cat] = 1 : memo[step][mouse][cat] = 0;\\n    } else { // mouse\\'s turn\\n        for (let i = 0; i < g[mouse].length; i++) {\\n            let next = dfs(step + 1, g[mouse][i], cat);\\n            if (next == 1) {\\n                return memo[step][mouse][cat] = 1;\\n            } else if (next != 2) {\\n                catWin = false;\\n            }\\n        }\\n        return catWin ? memo[step][mouse][cat] = 2 : memo[step][mouse][cat] = 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nconst initialize3DArray = (n, m, p) => { let res = []; for (let i = 0; i < n; i++) { let data = []; for (let j = 0; j < m; j++) { let tmp = Array(p).fill(-1); data.push(tmp); } res.push(data); } return res; };\\n\\nlet memo, g, n;\\nconst catMouseGame = (graph) => {\\n    g = graph, n = g.length, memo = initialize3DArray(2 * n, n, n);\\n    return dfs(0, 1, 2);\\n};\\n\\nconst dfs = (step, mouse, cat) => {\\n    if (step == 2 * n) return 0;\\n    if (mouse == cat) return memo[step][mouse][cat] = 2; // mouse be caught\\n    if (mouse == 0) return memo[step][mouse][cat] = 1; // mouse reach the hole\\n    if (memo[step][mouse][cat] != -1) return memo[step][mouse][cat]; // visited\\n    let catWin = true, mouseWin = true;\\n    if (step & 1) { // cat\\'s turn\\n        for (let i = 0; i < g[cat].length; i++) {\\n            if (g[cat][i] == 0) continue;\\n            let next = dfs(step + 1, mouse, g[cat][i]);\\n            if (next == 2) {\\n                return memo[step][mouse][cat] = 2;\\n            } else if (next != 1) {\\n                mouseWin = false;\\n            }\\n        }\\n        return mouseWin ? memo[step][mouse][cat] = 1 : memo[step][mouse][cat] = 0;\\n    } else { // mouse\\'s turn\\n        for (let i = 0; i < g[mouse].length; i++) {\\n            let next = dfs(step + 1, g[mouse][i], cat);\\n            if (next == 1) {\\n                return memo[step][mouse][cat] = 1;\\n            } else if (next != 2) {\\n                catWin = false;\\n            }\\n        }\\n        return catWin ? memo[step][mouse][cat] = 2 : memo[step][mouse][cat] = 0;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1190911,
                "title": "67-49-python-game-theory",
                "content": "A game can be represented in the form of a graph with winning and losing positions (often called N and P positions in combinatorial game theory). A vertex in such a graph would represent the current state of the game (in this case, the mouse\\'s position, the cat\\'s position and the current player). A vertex is winning if it\\'s atleast connected to one losing vertex. If not, then\\'s it\\'s a losing vertex. To elaborate, a vertex would be winning for the mouse if it\\'s connected to atlleast one losing vertex for the cat and vice-versa. A simple BFS traversal from terminal positions would do the trick.\\n\\n```\\nclass Solution:\\n    def generateMoves(self, graph, start, cat_moves):\\n        return graph[start] if not cat_moves else set(graph[start]) - set([0])\\n    \\n    def catMouseGame(self, graph: List[List[int]]) -> int:\\n        result, degree_mouse, degree_cat = dict(), dict(), dict()\\n        processed_queue = []\\n        \\n        for i in range(len(graph)):\\n            for j in range(1, len(graph)):\\n                result[(i, j, 0)] = -1\\n                result[(i, j, 1)] = -1\\n                \\n                if i == 0:\\n                    result[(i, j, 0)] = 1\\n                    result[(i, j, 1)] = 0\\n                    \\n                    processed_queue.append((i, j, 0, 1))\\n                    processed_queue.append((i, j, 1, 0))\\n                \\n                if i == j:\\n                    result[(i, j, 0)] = 0\\n                    result[(i, j, 1)] = 1\\n                    \\n                    processed_queue.append((i, j, 0, 0))\\n                    processed_queue.append((i, j, 1, 1))\\n                \\n                degree_mouse[(i, j)] = len(self.generateMoves(graph, i, 0))\\n                degree_cat[(i, j)] = len(self.generateMoves(graph, j, 1))\\n        \\n        while processed_queue:\\n            mouse_node, cat_node, cat_moves, res = processed_queue.pop(0)\\n            if not cat_moves:\\n                for next_node in self.generateMoves(graph, cat_node, 1):\\n                    if not res:\\n                        if result[(mouse_node, next_node, 1)] == -1:\\n                            result[(mouse_node, next_node, 1)] = 1\\n                            processed_queue.append((mouse_node, next_node, 1, 1))\\n                    else:\\n                        degree_cat[(mouse_node, next_node)] -= 1\\n                        if degree_cat[(mouse_node, next_node)] == 0:\\n                            if result[(mouse_node, next_node, 1)] == -1:\\n                                result[(mouse_node, next_node, 1)] = 0\\n                                processed_queue.append((mouse_node, next_node, 1, 0))\\n            else:\\n                for next_node in self.generateMoves(graph, mouse_node, 0):\\n                    if not res:\\n                        if result[(next_node, cat_node, 0)] == -1:\\n                            result[(next_node, cat_node, 0)] = 1\\n                            processed_queue.append((next_node, cat_node, 0, 1))\\n                    else:\\n                        degree_mouse[(next_node, cat_node)] -= 1\\n                        if degree_mouse[(next_node, cat_node)] == 0:\\n                            if result[(next_node, cat_node, 0)] == -1:\\n                                result[(next_node, cat_node, 0)] = 0\\n                                processed_queue.append((next_node, cat_node, 0, 0))\\n        \\n        if result[(1, 2, 0)] == -1:\\n            return 0\\n        elif not result[(1, 2, 0)]:\\n            return 2\\n        else:\\n            return 1\\n                    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def generateMoves(self, graph, start, cat_moves):\\n        return graph[start] if not cat_moves else set(graph[start]) - set([0])\\n    \\n    def catMouseGame(self, graph: List[List[int]]) -> int:\\n        result, degree_mouse, degree_cat = dict(), dict(), dict()\\n        processed_queue = []\\n        \\n        for i in range(len(graph)):\\n            for j in range(1, len(graph)):\\n                result[(i, j, 0)] = -1\\n                result[(i, j, 1)] = -1\\n                \\n                if i == 0:\\n                    result[(i, j, 0)] = 1\\n                    result[(i, j, 1)] = 0\\n                    \\n                    processed_queue.append((i, j, 0, 1))\\n                    processed_queue.append((i, j, 1, 0))\\n                \\n                if i == j:\\n                    result[(i, j, 0)] = 0\\n                    result[(i, j, 1)] = 1\\n                    \\n                    processed_queue.append((i, j, 0, 0))\\n                    processed_queue.append((i, j, 1, 1))\\n                \\n                degree_mouse[(i, j)] = len(self.generateMoves(graph, i, 0))\\n                degree_cat[(i, j)] = len(self.generateMoves(graph, j, 1))\\n        \\n        while processed_queue:\\n            mouse_node, cat_node, cat_moves, res = processed_queue.pop(0)\\n            if not cat_moves:\\n                for next_node in self.generateMoves(graph, cat_node, 1):\\n                    if not res:\\n                        if result[(mouse_node, next_node, 1)] == -1:\\n                            result[(mouse_node, next_node, 1)] = 1\\n                            processed_queue.append((mouse_node, next_node, 1, 1))\\n                    else:\\n                        degree_cat[(mouse_node, next_node)] -= 1\\n                        if degree_cat[(mouse_node, next_node)] == 0:\\n                            if result[(mouse_node, next_node, 1)] == -1:\\n                                result[(mouse_node, next_node, 1)] = 0\\n                                processed_queue.append((mouse_node, next_node, 1, 0))\\n            else:\\n                for next_node in self.generateMoves(graph, mouse_node, 0):\\n                    if not res:\\n                        if result[(next_node, cat_node, 0)] == -1:\\n                            result[(next_node, cat_node, 0)] = 1\\n                            processed_queue.append((next_node, cat_node, 0, 1))\\n                    else:\\n                        degree_mouse[(next_node, cat_node)] -= 1\\n                        if degree_mouse[(next_node, cat_node)] == 0:\\n                            if result[(next_node, cat_node, 0)] == -1:\\n                                result[(next_node, cat_node, 0)] = 0\\n                                processed_queue.append((next_node, cat_node, 0, 0))\\n        \\n        if result[(1, 2, 0)] == -1:\\n            return 0\\n        elif not result[(1, 2, 0)]:\\n            return 2\\n        else:\\n            return 1\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1099303,
                "title": "python-3-o-n-3-propagation-of-resolved-states",
                "content": "```\\nclass Solution:\\n    def catMouseGame(self, G: List[List[int]]) -> int:\\n        \\n        n = len(G)\\n        \\n        START = (1, 2, True)\\n        \\n        # state = (mouse_pos, cat_pos, turn)\\n        degree = Counter()\\n        inv = defaultdict(list)\\n        g = defaultdict(list)\\n        \\n        q = []\\n        \\n        for mouse in range(n):\\n            # cat cannot be on hole\\n            for cat in range(1,n):\\n                for mouse_turn in True,False:\\n                    state = (mouse, cat, mouse_turn)\\n                    \\n                    # check terminal\\n                    if mouse == 0 or mouse == cat:\\n                        q.append(state)\\n                    \\n                    # register transitions\\n                    if mouse_turn:\\n                        # cat cannot transition from hole\\n                        predecessors = [(mouse,v,False) for v in G[cat] if v]\\n                    else:\\n                        predecessors = [(u,cat, True) for u in G[mouse]]\\n                    \\n                    for pred in predecessors:\\n                        degree[pred] += 1\\n                        inv[state].append(pred)\\n                        g[pred].append(state)\\n        \\n        \\n        # state -> result\\n        ret = {}\\n        \\n        # process states\\n        for state in q:\\n            mouse,cat,mouse_turn = state\\n            \\n            if state in ret:\\n                continue\\n            \\n            # resolve state\\n            if mouse == 0:\\n                ret[state] = mouse_turn\\n            elif mouse == cat:\\n                ret[state] = not mouse_turn\\n            else:\\n                ret[state] = any(succ in ret and not ret[succ] for succ in g[state])\\n            \\n            # propagate resolution\\n            if not ret[state]:\\n                q.extend(inv[state])\\n            else:\\n                for pred in inv[state]:\\n                    degree[pred] -= 1\\n                    \\n                    if degree[pred] == 0:\\n                        q.append(pred)\\n        \\n        \\n        return 0 if START not in ret else 1 if ret[START] else 2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def catMouseGame(self, G: List[List[int]]) -> int:\\n        \\n        n = len(G)\\n        \\n        START = (1, 2, True)\\n        \\n        # state = (mouse_pos, cat_pos, turn)\\n        degree = Counter()\\n        inv = defaultdict(list)\\n        g = defaultdict(list)\\n        \\n        q = []\\n        \\n        for mouse in range(n):\\n            # cat cannot be on hole\\n            for cat in range(1,n):\\n                for mouse_turn in True,False:\\n                    state = (mouse, cat, mouse_turn)\\n                    \\n                    # check terminal\\n                    if mouse == 0 or mouse == cat:\\n                        q.append(state)\\n                    \\n                    # register transitions\\n                    if mouse_turn:\\n                        # cat cannot transition from hole\\n                        predecessors = [(mouse,v,False) for v in G[cat] if v]\\n                    else:\\n                        predecessors = [(u,cat, True) for u in G[mouse]]\\n                    \\n                    for pred in predecessors:\\n                        degree[pred] += 1\\n                        inv[state].append(pred)\\n                        g[pred].append(state)\\n        \\n        \\n        # state -> result\\n        ret = {}\\n        \\n        # process states\\n        for state in q:\\n            mouse,cat,mouse_turn = state\\n            \\n            if state in ret:\\n                continue\\n            \\n            # resolve state\\n            if mouse == 0:\\n                ret[state] = mouse_turn\\n            elif mouse == cat:\\n                ret[state] = not mouse_turn\\n            else:\\n                ret[state] = any(succ in ret and not ret[succ] for succ in g[state])\\n            \\n            # propagate resolution\\n            if not ret[state]:\\n                q.extend(inv[state])\\n            else:\\n                for pred in inv[state]:\\n                    degree[pred] -= 1\\n                    \\n                    if degree[pred] == 0:\\n                        q.append(pred)\\n        \\n        \\n        return 0 if START not in ret else 1 if ret[START] else 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1029377,
                "title": "javascript-dfs-dp-minimax-solution-comments",
                "content": "We follow the minimax approach, but we use 2 caches to properly handle the states:\\n*   The first cache, `seen`, tracks the states that we ve already seen on the current game being played. We use backtracking\\'s logic to efficiently keep track of said states and these states do not need the \"level\", but rather whose turn it is.\\n\\n*   The 2nd cache, `memo`, is used to store states for dynamic programming logic.\\n    These states need the current level, to avoid further redundant computations that have already occured in the past.\\n```\\nvar catMouseGame = function(graph) {\\n    let n=graph.length,\\n        memo=[...Array(n+1)].map(d=>[...Array(n+1)].map(d=>[...Array(2*n+1)])),\\n        seen=[...Array(n+1)].map(d=>[...Array(n+1)].map(d=>[...Array(2)]))\\n    //dfs returns 0 1 2, whether the current player loses,wins, or draws respectively\\n    let dfs=(M,C,level)=>{\\n        let turn=level%2,curr=turn?C:M,draw=0,res=0\\n        //draw when we ve seen the state before or cycles\\n        if(seen[M][C][turn]!==undefined||level>=2*n) \\n            return memo[M][C][level]=2 \\n        if(M==0)// win for mouse if it reaches the hole, loss for cat\\n            memo[M][C][level]=turn^1\\n        if(M==C)// win for cat if it reaches the mouse, loss for mouse\\n            memo[M][C][level]=turn \\n        if(memo[M][C][level]===undefined){\\n            seen[M][C][turn]=0 //set this state as visited\\n            for(let i=0;i<graph[curr].length&&!res;i++) //traverse for the available edges\\n                if( !(turn&&(!graph[curr][i]))){ //The cat cant move into the hole\\n                    let val=turn?\\n                            dfs(M,graph[curr][i],level+1):\\n                            dfs(graph[curr][i],C,level+1)\\n                    if(val===2) \\n                        draw=1 //set draw as an available option\\n                    else\\n                        res|=(1^val) //minimax logic, always prefer the losing state of the opponent\\n                }\\n            memo[M][C][level]=res||(2*draw) // set in this order 1->2->0 \\n        }\\n        seen[M][C][turn]=undefined;// de-set the state for the current game,as it concluded\\n        return memo[M][C][level]\\n    }\\n    return [2,1,0][dfs(1,2,0)] //js eye candy\\n};\\n```\\n\\nAnd here\\'s the condensed version\\n```\\n//condensed as thicc milk \\nvar catMouseGame = function(graph,memo={}) {\\n    return [2,1,0][(function dfs(M,C,level){\\n        let turn=level%2,curr=turn?C:M,draw=0,res=0,next,state=(M*graph.length+C)+0.37*level\\n        if(level>=2*graph.length) return memo[state]=2 \\n        if(M==0||M==C)return memo[state]=turn^Number(M==0)\\n        for(let i=0;i<graph[curr].length&&!res&&memo[state]===undefined;i++) \\n            if( !(turn&&(!graph[curr][i]))) \\n                next=turn?dfs(M,graph[curr][i],level+1):dfs(graph[curr][i],C,level+1),\\n                next==2?draw=1:res|=(1^next) \\n        return memo[state]=memo[state]||(res||(2*draw))\\n    })(1,2,0)]\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nvar catMouseGame = function(graph) {\\n    let n=graph.length,\\n        memo=[...Array(n+1)].map(d=>[...Array(n+1)].map(d=>[...Array(2*n+1)])),\\n        seen=[...Array(n+1)].map(d=>[...Array(n+1)].map(d=>[...Array(2)]))\\n    //dfs returns 0 1 2, whether the current player loses,wins, or draws respectively\\n    let dfs=(M,C,level)=>{\\n        let turn=level%2,curr=turn?C:M,draw=0,res=0\\n        //draw when we ve seen the state before or cycles\\n        if(seen[M][C][turn]!==undefined||level>=2*n) \\n            return memo[M][C][level]=2 \\n        if(M==0)// win for mouse if it reaches the hole, loss for cat\\n            memo[M][C][level]=turn^1\\n        if(M==C)// win for cat if it reaches the mouse, loss for mouse\\n            memo[M][C][level]=turn \\n        if(memo[M][C][level]===undefined){\\n            seen[M][C][turn]=0 //set this state as visited\\n            for(let i=0;i<graph[curr].length&&!res;i++) //traverse for the available edges\\n                if( !(turn&&(!graph[curr][i]))){ //The cat cant move into the hole\\n                    let val=turn?\\n                            dfs(M,graph[curr][i],level+1):\\n                            dfs(graph[curr][i],C,level+1)\\n                    if(val===2) \\n                        draw=1 //set draw as an available option\\n                    else\\n                        res|=(1^val) //minimax logic, always prefer the losing state of the opponent\\n                }\\n            memo[M][C][level]=res||(2*draw) // set in this order 1->2->0 \\n        }\\n        seen[M][C][turn]=undefined;// de-set the state for the current game,as it concluded\\n        return memo[M][C][level]\\n    }\\n    return [2,1,0][dfs(1,2,0)] //js eye candy\\n};\\n```\n```\\n//condensed as thicc milk \\nvar catMouseGame = function(graph,memo={}) {\\n    return [2,1,0][(function dfs(M,C,level){\\n        let turn=level%2,curr=turn?C:M,draw=0,res=0,next,state=(M*graph.length+C)+0.37*level\\n        if(level>=2*graph.length) return memo[state]=2 \\n        if(M==0||M==C)return memo[state]=turn^Number(M==0)\\n        for(let i=0;i<graph[curr].length&&!res&&memo[state]===undefined;i++) \\n            if( !(turn&&(!graph[curr][i]))) \\n                next=turn?dfs(M,graph[curr][i],level+1):dfs(graph[curr][i],C,level+1),\\n                next==2?draw=1:res|=(1^next) \\n        return memo[state]=memo[state]||(res||(2*draw))\\n    })(1,2,0)]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1025409,
                "title": "python3-minimax-solution-78-time",
                "content": "```\\nclass Solution:\\n    def catMouseGame(self, graph: List[List[int]]) -> int:\\n        \"\"\"\\n        Given\\n        Mouse starts at node 1\\n        Cat starts t node 2\\n        \\n        Graph, no ring, bi-direction..\\n        \\n        Brainstorm\\n        1. minimax algorithm. mouse takes the action to maximize the output, cat takes the action to minimize the output\\n            state: i, j (location of mouse, location of cat)\\n            rewards, 1 mouse win, -1 cat win, 0 draw\\n\\n        2. use visited (set) to record visited state \\n        \"\"\"\\n                \\n        @lru_cache(None)\\n        def step_forward(i, j, flag_mouse_move=True, turn=0):\\n            if i == 0:\\n                return 1\\n            if i == j:\\n                return -1\\n            if turn >= 50:\\n                return 0\\n            \\n            if flag_mouse_move:\\n                output = -1\\n                for i_next in graph[i]:\\n                    output = max(output, step_forward(i_next, j, False, turn + 1))\\n                    if output == 1:\\n                        return output\\n                return output\\n            else:\\n                output = 1\\n                for j_next in graph[j]:\\n                    if j_next != 0:\\n                        output = min(output, step_forward(i, j_next, True, turn + 1))\\n                        if output == -1:\\n                            return output\\n                return output\\n        \\n        op = step_forward(1, 2, True)\\n        return op if op >= 0 else 2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def catMouseGame(self, graph: List[List[int]]) -> int:\\n        \"\"\"\\n        Given\\n        Mouse starts at node 1\\n        Cat starts t node 2\\n        \\n        Graph, no ring, bi-direction..\\n        \\n        Brainstorm\\n        1. minimax algorithm. mouse takes the action to maximize the output, cat takes the action to minimize the output\\n            state: i, j (location of mouse, location of cat)\\n            rewards, 1 mouse win, -1 cat win, 0 draw\\n\\n        2. use visited (set) to record visited state \\n        \"\"\"\\n                \\n        @lru_cache(None)\\n        def step_forward(i, j, flag_mouse_move=True, turn=0):\\n            if i == 0:\\n                return 1\\n            if i == j:\\n                return -1\\n            if turn >= 50:\\n                return 0\\n            \\n            if flag_mouse_move:\\n                output = -1\\n                for i_next in graph[i]:\\n                    output = max(output, step_forward(i_next, j, False, turn + 1))\\n                    if output == 1:\\n                        return output\\n                return output\\n            else:\\n                output = 1\\n                for j_next in graph[j]:\\n                    if j_next != 0:\\n                        output = min(output, step_forward(i, j_next, True, turn + 1))\\n                        if output == -1:\\n                            return output\\n                return output\\n        \\n        op = step_forward(1, 2, True)\\n        return op if op >= 0 else 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 962343,
                "title": "java-path-color-coding-bottom-up-bfs",
                "content": "The idea is to go backward from the final states in which mice and cats emerged as the victors.\\n```\\nclass Solution {\\n    public int catMouseGame(int[][] graph) {\\n        int n = graph.length;\\n        int[][][] color = new int[n][n][3];\\n        Queue<int[]> qu = new ArrayDeque<>();\\n        for (int i = 1; i <= 2; i++) {\\n            for (int j = 1; j < n; j++) {\\n                color[j][j][i] = 2;\\n                qu.offer(new int[]{j, j, i});\\n            }\\n            for (int j = 1; j < n; j++) {\\n                color[0][j][i] = 1;\\n                qu.offer(new int[]{0, j, i});\\n            }\\n        }\\n        while (!qu.isEmpty()) {\\n            int[] cur = qu.poll();\\n            int mouse = cur[0];\\n            int cat = cur[1];\\n            int turn = cur[2];\\n            int status = color[mouse][cat][turn];\\n            for (int[] last : findLastStates(graph, mouse, cat, turn)) {\\n                int mouseLast = last[0];\\n                int catLast = last[1];\\n                int turnLast = last[2];\\n                if (color[mouseLast][catLast][turnLast] != 0) {\\n                    continue;\\n                }\\n                if (turnLast == status || deadMove(graph, mouseLast, catLast, turnLast, color)) {\\n                    color[mouseLast][catLast][turnLast] = status;\\n                    qu.offer(new int[]{mouseLast, catLast, turnLast});\\n                }\\n            }\\n        }\\n        return color[1][2][1];\\n    }\\n    \\n    private List<int[]> findLastStates(int[][] graph, int mouse, int cat, int turn) {\\n        List<int[]> res = new ArrayList<>();\\n        if (turn == 1) {\\n            for (int neighbor : graph[cat]) {\\n                if (neighbor != 0) {\\n                    res.add(new int[]{mouse, neighbor, 2});\\n                }\\n            }\\n        }\\n        else {\\n            for (int neighbor : graph[mouse]) {\\n                res.add(new int[]{neighbor, cat, 1});\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private boolean deadMove(int[][] graph, int mouse, int cat, int turn, int[][][] color) {\\n        if (turn == 2) {\\n            for (int neighbor : graph[cat]) {\\n                if (neighbor != 0) {\\n                    if (color[mouse][neighbor][1] != 1) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        else {\\n            for (int neighbor : graph[mouse]) {\\n                if (color[neighbor][cat][2] != 2) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int catMouseGame(int[][] graph) {\\n        int n = graph.length;\\n        int[][][] color = new int[n][n][3];\\n        Queue<int[]> qu = new ArrayDeque<>();\\n        for (int i = 1; i <= 2; i++) {\\n            for (int j = 1; j < n; j++) {\\n                color[j][j][i] = 2;\\n                qu.offer(new int[]{j, j, i});\\n            }\\n            for (int j = 1; j < n; j++) {\\n                color[0][j][i] = 1;\\n                qu.offer(new int[]{0, j, i});\\n            }\\n        }\\n        while (!qu.isEmpty()) {\\n            int[] cur = qu.poll();\\n            int mouse = cur[0];\\n            int cat = cur[1];\\n            int turn = cur[2];\\n            int status = color[mouse][cat][turn];\\n            for (int[] last : findLastStates(graph, mouse, cat, turn)) {\\n                int mouseLast = last[0];\\n                int catLast = last[1];\\n                int turnLast = last[2];\\n                if (color[mouseLast][catLast][turnLast] != 0) {\\n                    continue;\\n                }\\n                if (turnLast == status || deadMove(graph, mouseLast, catLast, turnLast, color)) {\\n                    color[mouseLast][catLast][turnLast] = status;\\n                    qu.offer(new int[]{mouseLast, catLast, turnLast});\\n                }\\n            }\\n        }\\n        return color[1][2][1];\\n    }\\n    \\n    private List<int[]> findLastStates(int[][] graph, int mouse, int cat, int turn) {\\n        List<int[]> res = new ArrayList<>();\\n        if (turn == 1) {\\n            for (int neighbor : graph[cat]) {\\n                if (neighbor != 0) {\\n                    res.add(new int[]{mouse, neighbor, 2});\\n                }\\n            }\\n        }\\n        else {\\n            for (int neighbor : graph[mouse]) {\\n                res.add(new int[]{neighbor, cat, 1});\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private boolean deadMove(int[][] graph, int mouse, int cat, int turn, int[][][] color) {\\n        if (turn == 2) {\\n            for (int neighbor : graph[cat]) {\\n                if (neighbor != 0) {\\n                    if (color[mouse][neighbor][1] != 1) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        else {\\n            for (int neighbor : graph[mouse]) {\\n                if (color[neighbor][cat][2] != 2) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941068,
                "title": "c-using-dfs-to-simulate-optimal-playing-strategy-memorization-to-speedup",
                "content": "The difficulty is to understand what it means by both players play optimally. \\nThis means three rules in turn based games: \\n* if current player A\\'s has at least one choice of all possible moves which will lead to A\\'s win.  A will make that choice and win\\n* if at least one choice will lead to a draw. A will make that choice and have a draw\\n* other cases: all choices lead to player B\\'s win:  this status means a win for B. \\n \\nWe just then using recursion to simulate the play by bother players and return optimal outcome. \\n\\n```\\nclass Solution {\\n    int node_count;\\n    vector <vector<vector<int >>> dp;\\n        // -1: unvisited,\\n        //  0 draw\\n        // 1: mouse winds, 2: cat wins,\\n    int play (vector<vector<int>>& graph, int step, int mouse_pos, int cat_pos)\\n    {\\n        //3 stop conditions:\\n        if (step==2*node_count) return 0;\\n\\n        if (mouse_pos==0) return dp[step][mouse_pos][cat_pos]=1;\\n\\n        if (mouse_pos == cat_pos)  return dp[step][mouse_pos][cat_pos]=2;\\n\\n        if (dp[step][mouse_pos][cat_pos]!=-1)  return dp [step][mouse_pos][cat_pos];\\n\\n        // now play optimally for each side    // mouse vs. cat: different values\\n        int playerid=step%2; // 0-mouse or 1-cat\\n        int player_pos= (playerid==0?mouse_pos: cat_pos);\\n        bool hasDraw=false; // default no draw:\\n\\n            for (auto next: graph[player_pos])\\n            {\\n                // mistake: a special case: cat cannot go into 0\\n                if (playerid==1 && next==0) continue;\\n                int next_res;\\n                if (playerid==0) // mouse\\'s turn\\n                {\\n                    next_res = play (graph, step+1, next, cat_pos);\\n                }\\n                else\\n                    next_res = play (graph, step+1, mouse_pos, next);\\n\\n                if (next_res==playerid+1) // at least one choice will lead to mouse win\\n                    return dp[step][mouse_pos][cat_pos]=playerid+1;\\n                else if (next_res==0) // at least one draw\\n                    hasDraw=true;\\n            }\\n\\n            if(!hasDraw)\\n               return dp[step][mouse_pos][cat_pos]=(3- (playerid+1));   // 1 vs. 2  : each is id+1\\n            else\\n              return dp[step][mouse_pos][cat_pos]=0;        \\n    }\\npublic:\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        node_count = graph.size();\\n        dp.resize (node_count*2, vector<vector<int>> (node_count, vector<int>(node_count, -1)  ));\\n        return play(graph, 0, 1, 2);\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int node_count;\\n    vector <vector<vector<int >>> dp;\\n        // -1: unvisited,\\n        //  0 draw\\n        // 1: mouse winds, 2: cat wins,\\n    int play (vector<vector<int>>& graph, int step, int mouse_pos, int cat_pos)\\n    {\\n        //3 stop conditions:\\n        if (step==2*node_count) return 0;\\n\\n        if (mouse_pos==0) return dp[step][mouse_pos][cat_pos]=1;\\n\\n        if (mouse_pos == cat_pos)  return dp[step][mouse_pos][cat_pos]=2;\\n\\n        if (dp[step][mouse_pos][cat_pos]!=-1)  return dp [step][mouse_pos][cat_pos];\\n\\n        // now play optimally for each side    // mouse vs. cat: different values\\n        int playerid=step%2; // 0-mouse or 1-cat\\n        int player_pos= (playerid==0?mouse_pos: cat_pos);\\n        bool hasDraw=false; // default no draw:\\n\\n            for (auto next: graph[player_pos])\\n            {\\n                // mistake: a special case: cat cannot go into 0\\n                if (playerid==1 && next==0) continue;\\n                int next_res;\\n                if (playerid==0) // mouse\\'s turn\\n                {\\n                    next_res = play (graph, step+1, next, cat_pos);\\n                }\\n                else\\n                    next_res = play (graph, step+1, mouse_pos, next);\\n\\n                if (next_res==playerid+1) // at least one choice will lead to mouse win\\n                    return dp[step][mouse_pos][cat_pos]=playerid+1;\\n                else if (next_res==0) // at least one draw\\n                    hasDraw=true;\\n            }\\n\\n            if(!hasDraw)\\n               return dp[step][mouse_pos][cat_pos]=(3- (playerid+1));   // 1 vs. 2  : each is id+1\\n            else\\n              return dp[step][mouse_pos][cat_pos]=0;        \\n    }\\npublic:\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        node_count = graph.size();\\n        dp.resize (node_count*2, vector<vector<int>> (node_count, vector<int>(node_count, -1)  ));\\n        return play(graph, 0, 1, 2);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928604,
                "title": "java-minmax-10-ms-faster-than-95-96-39-4-mb-less-than-5-56",
                "content": "```\\nclass Solution {\\n    private static final int DRAW = 0;\\n    private static final int MOUSE_WIN = 1;\\n    private static final int CAT_WIN = 2;\\n    private static final int MOUSE = 0;\\n    private static final int CAT = 1;\\n\\n    public int catMouseGame(int[][] graph) {\\n        int n = graph.length;\\n        int[][][] states = new int[n][n][2];\\n        int[][][] degree = new int[n][n][2];\\n        for (int m = 0; m < n; ++m) {\\n            for (int c = 0; c < n; ++c) {\\n                degree[m][c][MOUSE] = graph[m].length;\\n                degree[m][c][CAT] = graph[c].length;\\n                for (int node : graph[c]) {\\n                    if (node == 0) {\\n                        --degree[m][c][CAT];\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        Queue<int[]> q = new LinkedList<>();\\n        for (int i = 1; i < n; ++i) {\\n            states[0][i][MOUSE] = MOUSE_WIN;\\n            states[0][i][CAT] = MOUSE_WIN;\\n            states[i][i][MOUSE] = CAT_WIN;\\n            states[i][i][CAT] = CAT_WIN;\\n            q.offer(new int[]{0, i, MOUSE, MOUSE_WIN});\\n            q.offer(new int[]{i, i, MOUSE, CAT_WIN});\\n            q.offer(new int[]{0, i, CAT, MOUSE_WIN});\\n            q.offer(new int[]{i, i, CAT, CAT_WIN});\\n        }\\n        while (!q.isEmpty()) {\\n            int[] state = q.poll();\\n            int mouse = state[0];\\n            int cat = state[1];\\n            int turn = state[2];\\n            int result = state[3];\\n            if (mouse == 1 && cat == 2 && turn == MOUSE) {\\n                return result;\\n            }\\n            int prevTurn = 1 - turn;\\n            for (int prev : graph[prevTurn == MOUSE ? mouse : cat]) {\\n                int prevMouse = prevTurn == MOUSE ? prev : mouse;\\n                int prevCat = prevTurn == CAT ? prev : cat;\\n                if (prevCat != 0 && states[prevMouse][prevCat][prevTurn] == DRAW && (prevTurn == MOUSE && result == MOUSE_WIN || prevTurn == CAT && result == CAT_WIN || --degree[prevMouse][prevCat][prevTurn] == 0)) {\\n                    states[prevMouse][prevCat][prevTurn] = result;\\n                    q.offer(new int[]{prevMouse, prevCat, prevTurn, result});\\n                }\\n            }\\n        }\\n        return DRAW;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final int DRAW = 0;\\n    private static final int MOUSE_WIN = 1;\\n    private static final int CAT_WIN = 2;\\n    private static final int MOUSE = 0;\\n    private static final int CAT = 1;\\n\\n    public int catMouseGame(int[][] graph) {\\n        int n = graph.length;\\n        int[][][] states = new int[n][n][2];\\n        int[][][] degree = new int[n][n][2];\\n        for (int m = 0; m < n; ++m) {\\n            for (int c = 0; c < n; ++c) {\\n                degree[m][c][MOUSE] = graph[m].length;\\n                degree[m][c][CAT] = graph[c].length;\\n                for (int node : graph[c]) {\\n                    if (node == 0) {\\n                        --degree[m][c][CAT];\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        Queue<int[]> q = new LinkedList<>();\\n        for (int i = 1; i < n; ++i) {\\n            states[0][i][MOUSE] = MOUSE_WIN;\\n            states[0][i][CAT] = MOUSE_WIN;\\n            states[i][i][MOUSE] = CAT_WIN;\\n            states[i][i][CAT] = CAT_WIN;\\n            q.offer(new int[]{0, i, MOUSE, MOUSE_WIN});\\n            q.offer(new int[]{i, i, MOUSE, CAT_WIN});\\n            q.offer(new int[]{0, i, CAT, MOUSE_WIN});\\n            q.offer(new int[]{i, i, CAT, CAT_WIN});\\n        }\\n        while (!q.isEmpty()) {\\n            int[] state = q.poll();\\n            int mouse = state[0];\\n            int cat = state[1];\\n            int turn = state[2];\\n            int result = state[3];\\n            if (mouse == 1 && cat == 2 && turn == MOUSE) {\\n                return result;\\n            }\\n            int prevTurn = 1 - turn;\\n            for (int prev : graph[prevTurn == MOUSE ? mouse : cat]) {\\n                int prevMouse = prevTurn == MOUSE ? prev : mouse;\\n                int prevCat = prevTurn == CAT ? prev : cat;\\n                if (prevCat != 0 && states[prevMouse][prevCat][prevTurn] == DRAW && (prevTurn == MOUSE && result == MOUSE_WIN || prevTurn == CAT && result == CAT_WIN || --degree[prevMouse][prevCat][prevTurn] == 0)) {\\n                    states[prevMouse][prevCat][prevTurn] = result;\\n                    q.offer(new int[]{prevMouse, prevCat, prevTurn, result});\\n                }\\n            }\\n        }\\n        return DRAW;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 912656,
                "title": "c-concise-and-short-30-lines-code-of-memorized-recursion-with-explanation-o-n-3",
                "content": "Since there exists only (2 * n) * n * n states in this game, we can use memorized recursion.\\n\\n[Reference](https://leetcode.com/problems/cat-and-mouse/discuss/298937/DP-memory-status-search-search-strait-forward-and-easy-to-understand)\\n\\nI defined the vector as follows:\\n`memo[iteration][the position of mouse][the position of cat] := 0 (if draw) or 1 (if mouse will win) or 2 (if cat will win)` \\nIn other words, we can know which player will win by referring to this vector when we have the situation where the mouse is at `x` and the cat is at `y` at the `t` (0 round is the initial state) round.\\n\\nNow, I will move to the detail of the algorithm.\\n1. I will set all the values of vector to `-1 `, which implies unknown region.\\n2. Then, we will set `(x, y, t) = (1, 2, 0)` and start recursion.\\n3. Each iteration, both player will try to find out which player can win when it takes each possible node.\\n4. If the currenct player could find the next action leading to winning, it will just take this action immediately.\\n5. If it could not find any ways to win, then it will try to take the way to not lose. If there is no way to avoid losing, then this state will record as losing.\\n6. In the end, both players can know which player will win when they try to take the way to win or the way to not lose.\\n\\nIf you stop using `pair<int, int>`, then you can speed up the code.\\n\\n**NOTE**: I checked the test case [here](https://leetcode.com/problems/cat-and-mouse/discuss/176177/Most-of-the-DFS-solutions-are-WRONG-check-this-case) as well.\\n\\n```\\nclass Solution {\\npublic:\\n    int catMouseGame(vector<vector<int>>& graph){\\n        int n = graph.size();\\n        vector<pair<int, int>> player = {{1, 2}, {2, 1}}; // {{mouse, cat}, {cat, mouse}}\\n        vector<vector<vector<int>>> memo(2 * n, vector<vector<int>>(n, vector<int>(n, -1)));\\n\\n        auto rec = [&](auto rec, int itr, int mouse, int cat)->int{\\n            if (itr == 2 * n) return 0; // termination criterion (no where to go next)\\n            int& result = memo[itr][mouse][cat]; int cur_player, nxt_player; bool lose = true;\\n            if (!mouse) return result = 1; // the mouse is at the hole\\n            if (cat == mouse) return result = 2; // the cat catches the mouse\\n            if (result != -1) return result; // if we already know the answer of this state, return the value\\n\\n            tie(cur_player, nxt_player) = player[itr % 2];\\n            auto update = [&](int mouse_nxt, int cat_nxt)->bool{\\n                if (!cat_nxt) return false; // the cat cannot go into the hole.\\n                int winner = rec(rec, itr + 1, mouse_nxt, cat_nxt); // the winner of this state.\\n                if (winner == cur_player) result = cur_player; // This state leads to winning.\\n                else if (winner != nxt_player) lose = false; // In the worst case, the current player can take this strategy to avoid losing.\\n                return winner == cur_player; // If result is updated, return true, otherwise false.\\n            };\\n\\n            if (itr % 2) for (auto& nxt: graph[cat]) {if (update(mouse, nxt)) return cur_player;}\\n            else for (auto& nxt: graph[mouse]) {if (update(nxt, cat)) return cur_player;}\\n            return result = (lose ? nxt_player : 0); // if there is no way to win, the current player will take the strategy not to lose.\\n        };\\n        return rec(rec, 0, 1, 2);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int catMouseGame(vector<vector<int>>& graph){\\n        int n = graph.size();\\n        vector<pair<int, int>> player = {{1, 2}, {2, 1}}; // {{mouse, cat}, {cat, mouse}}\\n        vector<vector<vector<int>>> memo(2 * n, vector<vector<int>>(n, vector<int>(n, -1)));\\n\\n        auto rec = [&](auto rec, int itr, int mouse, int cat)->int{\\n            if (itr == 2 * n) return 0; // termination criterion (no where to go next)\\n            int& result = memo[itr][mouse][cat]; int cur_player, nxt_player; bool lose = true;\\n            if (!mouse) return result = 1; // the mouse is at the hole\\n            if (cat == mouse) return result = 2; // the cat catches the mouse\\n            if (result != -1) return result; // if we already know the answer of this state, return the value\\n\\n            tie(cur_player, nxt_player) = player[itr % 2];\\n            auto update = [&](int mouse_nxt, int cat_nxt)->bool{\\n                if (!cat_nxt) return false; // the cat cannot go into the hole.\\n                int winner = rec(rec, itr + 1, mouse_nxt, cat_nxt); // the winner of this state.\\n                if (winner == cur_player) result = cur_player; // This state leads to winning.\\n                else if (winner != nxt_player) lose = false; // In the worst case, the current player can take this strategy to avoid losing.\\n                return winner == cur_player; // If result is updated, return true, otherwise false.\\n            };\\n\\n            if (itr % 2) for (auto& nxt: graph[cat]) {if (update(mouse, nxt)) return cur_player;}\\n            else for (auto& nxt: graph[mouse]) {if (update(nxt, cat)) return cur_player;}\\n            return result = (lose ? nxt_player : 0); // if there is no way to win, the current player will take the strategy not to lose.\\n        };\\n        return rec(rec, 0, 1, 2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 761402,
                "title": "java-clean-solution-with-comments",
                "content": "Note: I didn\\'t come up with the solution. I just tried to understand it and write it in a way that\\'s easier to understand.\\n```\\nclass Solution {\\n    int n;\\n    public int catMouseGame(int[][] graph) {\\n        n = graph.length;\\n        int[][][] dp = new int[2*n][n][n];\\n        fill(dp);\\n        return whoWon(graph, dp, 0, 1, 2);\\n    }\\n    \\n    public int whoWon(int[][] graph, int[][][] dp, int turn, int mouse, int cat) {\\n        if(turn == 2*n) return 0; // endless game, draw\\n        if(mouse == cat) return dp[turn][mouse][cat] = 2; // cat win\\n        if(mouse == 0) return dp[turn][mouse][cat] = 1; // mouse win\\n        if(dp[turn][mouse][cat] != -1) return dp[turn][mouse][cat];\\n        \\n        int chance = turn%2;\\n        // if chance is 0, it\\'s mouse turn to play\\n        if(chance == 0) {\\n            boolean catWin = true; \\n            // Mouse playing nextMove\\n            for(int nextMove: graph[mouse]) {\\n                int res = whoWon(graph, dp, turn + 1, nextMove, cat);\\n                // mouse win in next step, so return mouse win in this step.\\n                if(res == 1) return dp[turn][mouse][cat] = 1;\\n                else if(res == 0) catWin = false; // it\\'s a draw;\\n            }\\n            if(catWin) return dp[turn][mouse][cat] = 2;\\n            else return dp[turn][mouse][cat] = 0;\\n        } else {\\n            boolean mouseWin = true; \\n            // Cat playing nextMove\\n            for(int nextMove: graph[cat]) {\\n                // Cat can\\'t move to 0\\n                if(nextMove == 0) continue;\\n                int res = whoWon(graph, dp, turn + 1, mouse, nextMove);\\n                // cat win in next step, so return cat win in this step.\\n                if(res == 2) return dp[turn][mouse][cat] = 2;\\n                else if(res == 0) mouseWin = false; // it\\'s a draw;\\n            }\\n            if(mouseWin) return dp[turn][mouse][cat] = 1;\\n            else return dp[turn][mouse][cat] = 0;\\n        }\\n    }\\n    \\n    \\n    // DP = {turn/steps, mouse, cat}\\n    // steps/turns can be max 2 * n, think about it, if you traverse all the nodes twice that\\n    // means you already entered a loop and the game will never end\\n    // int[][][] dp = new int[2*n][n][n];\\n    // let\\'s fill the matrix with -1\\n    // this matrix will store result: 0(draw), 1(mouse win), 2(cat win)\\n    public void fill(int[][][] dp) {\\n        for(int i = 0; i < 2*n; i++) {\\n            for(int j = 0; j < n; j++) {\\n                Arrays.fill(dp[i][j], -1);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int n;\\n    public int catMouseGame(int[][] graph) {\\n        n = graph.length;\\n        int[][][] dp = new int[2*n][n][n];\\n        fill(dp);\\n        return whoWon(graph, dp, 0, 1, 2);\\n    }\\n    \\n    public int whoWon(int[][] graph, int[][][] dp, int turn, int mouse, int cat) {\\n        if(turn == 2*n) return 0; // endless game, draw\\n        if(mouse == cat) return dp[turn][mouse][cat] = 2; // cat win\\n        if(mouse == 0) return dp[turn][mouse][cat] = 1; // mouse win\\n        if(dp[turn][mouse][cat] != -1) return dp[turn][mouse][cat];\\n        \\n        int chance = turn%2;\\n        // if chance is 0, it\\'s mouse turn to play\\n        if(chance == 0) {\\n            boolean catWin = true; \\n            // Mouse playing nextMove\\n            for(int nextMove: graph[mouse]) {\\n                int res = whoWon(graph, dp, turn + 1, nextMove, cat);\\n                // mouse win in next step, so return mouse win in this step.\\n                if(res == 1) return dp[turn][mouse][cat] = 1;\\n                else if(res == 0) catWin = false; // it\\'s a draw;\\n            }\\n            if(catWin) return dp[turn][mouse][cat] = 2;\\n            else return dp[turn][mouse][cat] = 0;\\n        } else {\\n            boolean mouseWin = true; \\n            // Cat playing nextMove\\n            for(int nextMove: graph[cat]) {\\n                // Cat can\\'t move to 0\\n                if(nextMove == 0) continue;\\n                int res = whoWon(graph, dp, turn + 1, mouse, nextMove);\\n                // cat win in next step, so return cat win in this step.\\n                if(res == 2) return dp[turn][mouse][cat] = 2;\\n                else if(res == 0) mouseWin = false; // it\\'s a draw;\\n            }\\n            if(mouseWin) return dp[turn][mouse][cat] = 1;\\n            else return dp[turn][mouse][cat] = 0;\\n        }\\n    }\\n    \\n    \\n    // DP = {turn/steps, mouse, cat}\\n    // steps/turns can be max 2 * n, think about it, if you traverse all the nodes twice that\\n    // means you already entered a loop and the game will never end\\n    // int[][][] dp = new int[2*n][n][n];\\n    // let\\'s fill the matrix with -1\\n    // this matrix will store result: 0(draw), 1(mouse win), 2(cat win)\\n    public void fill(int[][][] dp) {\\n        for(int i = 0; i < 2*n; i++) {\\n            for(int j = 0; j < n; j++) {\\n                Arrays.fill(dp[i][j], -1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 534862,
                "title": "python-bfs-in-o-n-2",
                "content": "We record all the results in which case we know cat wins or mouse wins. Note that if a cat arrives at hole, we assume that cat loses so that cat won\\'t get to the hole.\\nWe use cnt to record how many ways left for a cat/mouse so that it won\\'t lose. If there is no way left, it loses.\\nIf a cat or a mouse can arrive at a point where it wins, the winner of the previous point is the same as this point. \\nIf a cat or a mouse can arrive at a point where it loses, `cnt[the previous point] -= 1` and we check whether there is no way left for the previous point.\\n```\\nclass Solution:\\n    def catMouseGame(self, graph):\\n        CAT, MOUSE, n = 2, 1, len(graph)\\n        queue = []          # (cat, mouse, turn, winner)\\n        result = {}\\n        for i in range(n):\\n            for j in range(2):\\n                queue.append((i, 0, j, 1))\\n                result[(i, 0, j)] = 1\\n                if i > 0:\\n                    queue.append((i, i, j, 2))\\n                    result[(i, i, j)] = 2\\n                    queue.append((0, i, j, 1))\\n                    result[(0, i, j)] = 1\\n\\n        cnt = {}\\n        for i in range(n):\\n            for j in range(n):\\n                cnt[(i, j, 0)] = len(graph[j])\\n                cnt[(i, j, 1)] = len(graph[i])\\n\\n        while queue:\\n            cat, mouse, turn, winner = queue.pop()\\n            if turn == 1:   # cat move for next step, mouse move for last step\\n                if winner == 1:\\n                    for next_step in graph[mouse]:\\n                        if (cat, next_step, 1 - turn) not in result:\\n                            result[(cat, next_step, 1 - turn)] = winner\\n                            queue.append((cat, next_step, 1 - turn, winner))\\n                else:\\n                    for next_step in graph[mouse]:\\n                        if (cat, next_step, 1 - turn) not in result:\\n                            cnt[(cat, next_step, 1 - turn)] -= 1\\n                            if cnt[(cat, next_step, 1 - turn)] == 0:\\n                                result[(cat, next_step, 1 - turn)] = winner\\n                                queue.append((cat, next_step, 1 - turn, winner))\\n            else:\\n                if winner == 2:\\n                    for next_step in graph[cat]:\\n                        if next_step == 0:\\n                            continue\\n                        if (next_step, mouse, 1 - turn) not in result:\\n                            result[(next_step, mouse, 1 - turn)] = winner\\n                            queue.append((next_step, mouse, 1 - turn, winner))\\n                else:\\n                    for next_step in graph[cat]:\\n                        if next_step == 0:\\n                            continue\\n                        if (next_step, mouse, 1 - turn) not in result:\\n                            cnt[(next_step, mouse, 1 - turn)] -= 1\\n                            if cnt[(next_step, mouse, 1 - turn)] == 0:\\n                                result[(next_step, mouse, 1 - turn)] = winner\\n                                queue.append((next_step, mouse, 1 - turn, winner))\\n        if (2, 1, 0) in result:\\n            return result[(2, 1, 0)]\\n        return 0\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def catMouseGame(self, graph):\\n        CAT, MOUSE, n = 2, 1, len(graph)\\n        queue = []          # (cat, mouse, turn, winner)\\n        result = {}\\n        for i in range(n):\\n            for j in range(2):\\n                queue.append((i, 0, j, 1))\\n                result[(i, 0, j)] = 1\\n                if i > 0:\\n                    queue.append((i, i, j, 2))\\n                    result[(i, i, j)] = 2\\n                    queue.append((0, i, j, 1))\\n                    result[(0, i, j)] = 1\\n\\n        cnt = {}\\n        for i in range(n):\\n            for j in range(n):\\n                cnt[(i, j, 0)] = len(graph[j])\\n                cnt[(i, j, 1)] = len(graph[i])\\n\\n        while queue:\\n            cat, mouse, turn, winner = queue.pop()\\n            if turn == 1:   # cat move for next step, mouse move for last step\\n                if winner == 1:\\n                    for next_step in graph[mouse]:\\n                        if (cat, next_step, 1 - turn) not in result:\\n                            result[(cat, next_step, 1 - turn)] = winner\\n                            queue.append((cat, next_step, 1 - turn, winner))\\n                else:\\n                    for next_step in graph[mouse]:\\n                        if (cat, next_step, 1 - turn) not in result:\\n                            cnt[(cat, next_step, 1 - turn)] -= 1\\n                            if cnt[(cat, next_step, 1 - turn)] == 0:\\n                                result[(cat, next_step, 1 - turn)] = winner\\n                                queue.append((cat, next_step, 1 - turn, winner))\\n            else:\\n                if winner == 2:\\n                    for next_step in graph[cat]:\\n                        if next_step == 0:\\n                            continue\\n                        if (next_step, mouse, 1 - turn) not in result:\\n                            result[(next_step, mouse, 1 - turn)] = winner\\n                            queue.append((next_step, mouse, 1 - turn, winner))\\n                else:\\n                    for next_step in graph[cat]:\\n                        if next_step == 0:\\n                            continue\\n                        if (next_step, mouse, 1 - turn) not in result:\\n                            cnt[(next_step, mouse, 1 - turn)] -= 1\\n                            if cnt[(next_step, mouse, 1 - turn)] == 0:\\n                                result[(next_step, mouse, 1 - turn)] = winner\\n                                queue.append((next_step, mouse, 1 - turn, winner))\\n        if (2, 1, 0) in result:\\n            return result[(2, 1, 0)]\\n        return 0\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 256225,
                "title": "java-solution-so-hard",
                "content": "```\\n    int[][][] color;\\n    public int catMouseGame(int[][] g) {\\n        int N = g.length;\\n        color = new int[N][N][3];\\n        Queue<int[]> q = new LinkedList<>();\\n        for(int i = 0; i < N; i++) {\\n            for(int t = 1; t <= 2; t++) {\\n                color[0][i][t] = 1; // mouse wins\\n                q.offer(new int[]{0, i, t});\\n                \\n                if(i == 0) continue;\\n                color[i][i][t] = 2; // cat wins\\n                q.offer(new int[]{i, i, t});\\n            }\\n        }\\n        \\n        while(!q.isEmpty()) {\\n            int[] tmp = q.poll();\\n            int m = tmp[0], c = tmp[1], t = tmp[2], state = color[m][c][t];\\n            for(int[] p : findParents(g, m, c, t)) {\\n                if(color[p[0]][p[1]][p[2]] != 0) continue;\\n                \\n                if(p[2] == state) {\\n                    color[p[0]][p[1]][p[2]] = state;\\n                    q.offer(new int[]{p[0], p[1], p[2]});\\n                } else if(allChildWin(g, p[0], p[1], p[2])){\\n                    color[p[0]][p[1]][p[2]] = 3 - p[2];\\n                    q.offer(new int[]{p[0], p[1], p[2]});                    \\n                }             \\n                \\n            }\\n\\n        }\\n        return color[1][2][1];\\n    }\\n    \\n    boolean allChildWin(int[][] g, int m, int c, int t) {\\n        if(t == 1) {\\n            for(int mc : g[m]) if(color[mc][c][3-t] != 2) return false;\\n        } else {\\n            for(int cc : g[c]) if(cc != 0 && color[m][cc][3-t] != 1) return false;\\n        }\\n        return true;\\n    }\\n    \\n    \\n    List<int[]> findParents(int[][] g, int m, int c, int t) {\\n        List<int[]> res = new ArrayList<>();\\n        if(t == 1) {// current mouse move, previouse cat move\\n            for(int cp : g[c]) if(cp != 0) res.add(new int[]{m, cp, 3 - t});\\n        } else {   // current cat move, previouse mouse move\\n            for(int mp : g[m]) res.add(new int[]{mp, c, 3 - t});\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int[][][] color;\\n    public int catMouseGame(int[][] g) {\\n        int N = g.length;\\n        color = new int[N][N][3];\\n        Queue<int[]> q = new LinkedList<>();\\n        for(int i = 0; i < N; i++) {\\n            for(int t = 1; t <= 2; t++) {\\n                color[0][i][t] = 1; // mouse wins\\n                q.offer(new int[]{0, i, t});\\n                \\n                if(i == 0) continue;\\n                color[i][i][t] = 2; // cat wins\\n                q.offer(new int[]{i, i, t});\\n            }\\n        }\\n        \\n        while(!q.isEmpty()) {\\n            int[] tmp = q.poll();\\n            int m = tmp[0], c = tmp[1], t = tmp[2], state = color[m][c][t];\\n            for(int[] p : findParents(g, m, c, t)) {\\n                if(color[p[0]][p[1]][p[2]] != 0) continue;\\n                \\n                if(p[2] == state) {\\n                    color[p[0]][p[1]][p[2]] = state;\\n                    q.offer(new int[]{p[0], p[1], p[2]});\\n                } else if(allChildWin(g, p[0], p[1], p[2])){\\n                    color[p[0]][p[1]][p[2]] = 3 - p[2];\\n                    q.offer(new int[]{p[0], p[1], p[2]});                    \\n                }             \\n                \\n            }\\n\\n        }\\n        return color[1][2][1];\\n    }\\n    \\n    boolean allChildWin(int[][] g, int m, int c, int t) {\\n        if(t == 1) {\\n            for(int mc : g[m]) if(color[mc][c][3-t] != 2) return false;\\n        } else {\\n            for(int cc : g[c]) if(cc != 0 && color[m][cc][3-t] != 1) return false;\\n        }\\n        return true;\\n    }\\n    \\n    \\n    List<int[]> findParents(int[][] g, int m, int c, int t) {\\n        List<int[]> res = new ArrayList<>();\\n        if(t == 1) {// current mouse move, previouse cat move\\n            for(int cp : g[c]) if(cp != 0) res.add(new int[]{m, cp, 3 - t});\\n        } else {   // current cat move, previouse mouse move\\n            for(int mp : g[m]) res.add(new int[]{mp, c, 3 - t});\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 178749,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int catMouseGame(int[][] graph) {\\n        if (graph == null) {\\n            return 0;\\n        }\\n        int[][][] dp = new int[graph.length][graph.length][2];\\n        for (int i = 0; i < dp.length; i++) {\\n            for (int j = 0; j < dp[0].length; j++) {\\n                Arrays.fill(dp[i][j], -1);\\n            }\\n        }\\n        return helper(graph, dp, 1, 2, 0);\\n    }\\n    private int helper(int[][] graph, int[][][] dp, int mouse, int cat, int state) {\\n        if (dp[mouse][cat][state] != -1) {\\n            return dp[mouse][cat][state];\\n        }\\n        dp[mouse][cat][state] = 0;\\n        int result;\\n        if (state == 0) {\\n            // mouse\\n            for (int i : graph[mouse]) {\\n                if (i == 0) {\\n                    dp[mouse][cat][state] = 1;\\n                    return 1;\\n                }\\n            }\\n            result = 2;\\n            for (int i : graph[mouse]) {\\n                if (i == cat) {\\n                    continue;\\n                }\\n                int res = helper(graph, dp, i, cat, state ^ 1);\\n                if (res == 1) {\\n                    dp[mouse][cat][state] = 1;\\n                    return 1;\\n                } else if (res == 0) {\\n                    result = 0;\\n                }\\n            }\\n        } else {\\n            for (int i : graph[cat]) {\\n                if (mouse == i) {\\n                    dp[mouse][cat][state] = 2;\\n                    return 2;\\n                }\\n            }\\n            result = 1;\\n            for (int i : graph[cat]) {\\n                if (i == 0) {\\n                    continue;\\n                }\\n                int res = helper(graph, dp, mouse, i, state ^ 1);\\n                if (res == 2) {\\n                    dp[mouse][cat][state] = 2;\\n                    return 2;\\n                } else if (res == 0) {\\n                    result = 0;\\n                }\\n            }\\n        }\\n        dp[mouse][cat][state] = result;\\n        return dp[mouse][cat][state];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int catMouseGame(int[][] graph) {\\n        if (graph == null) {\\n            return 0;\\n        }\\n        int[][][] dp = new int[graph.length][graph.length][2];\\n        for (int i = 0; i < dp.length; i++) {\\n            for (int j = 0; j < dp[0].length; j++) {\\n                Arrays.fill(dp[i][j], -1);\\n            }\\n        }\\n        return helper(graph, dp, 1, 2, 0);\\n    }\\n    private int helper(int[][] graph, int[][][] dp, int mouse, int cat, int state) {\\n        if (dp[mouse][cat][state] != -1) {\\n            return dp[mouse][cat][state];\\n        }\\n        dp[mouse][cat][state] = 0;\\n        int result;\\n        if (state == 0) {\\n            // mouse\\n            for (int i : graph[mouse]) {\\n                if (i == 0) {\\n                    dp[mouse][cat][state] = 1;\\n                    return 1;\\n                }\\n            }\\n            result = 2;\\n            for (int i : graph[mouse]) {\\n                if (i == cat) {\\n                    continue;\\n                }\\n                int res = helper(graph, dp, i, cat, state ^ 1);\\n                if (res == 1) {\\n                    dp[mouse][cat][state] = 1;\\n                    return 1;\\n                } else if (res == 0) {\\n                    result = 0;\\n                }\\n            }\\n        } else {\\n            for (int i : graph[cat]) {\\n                if (mouse == i) {\\n                    dp[mouse][cat][state] = 2;\\n                    return 2;\\n                }\\n            }\\n            result = 1;\\n            for (int i : graph[cat]) {\\n                if (i == 0) {\\n                    continue;\\n                }\\n                int res = helper(graph, dp, mouse, i, state ^ 1);\\n                if (res == 2) {\\n                    dp[mouse][cat][state] = 2;\\n                    return 2;\\n                } else if (res == 0) {\\n                    result = 0;\\n                }\\n            }\\n        }\\n        dp[mouse][cat][state] = result;\\n        return dp[mouse][cat][state];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 176560,
                "title": "java-10ms-dfs-minmax",
                "content": "Making so many mistakes when trying to solve this problem, finally accepted. The idea is using DFS and MinMax. \\nAt first I used a HashSet to judge whether it is a **Draw**, but it was wrong. The reason can be found in this [link](https://leetcode.com/problems/cat-and-mouse/discuss/176177/Most-of-the-DFS-solutions-are-WRONG-check-this-case). So I changed the HashSet to a 3D array **dp** and finally solved this problem (now I think a HashMap may be better).\\n\\n```\\nclass Solution {\\n    \\n    int[][] G;\\n    int[][][] dp;\\n    \\n    public int catMouseGame(int[][] graph) {\\n        G = graph;\\n        dp = new int[graph.length][graph.length][3];\\n        \\n        int res = helper(new int[] {1,2,0});\\n        if(res == 1)\\n            return 2;\\n        else if(res == 2)\\n            return 0;\\n        return 1;\\n    }\\n    \\n    public int helper (int[] status){\\n        \\n        int mouse = status[0], cat = status[1], flag = status[2];\\n        // System.out.print(mouse + \" \" + cat + \" \" + flag + \" \");\\n        // System.out.println();\\n        if(dp[mouse][cat][flag] > 0)\\n            return dp[mouse][cat][flag];\\n        dp[mouse][cat][flag] = 2;\\n        if(mouse == 0)\\n            return 3;\\n        if(mouse == cat)\\n            return 1;\\n        if(flag == 0){\\n            int max = 0;\\n            for(int next : G[mouse]){\\n                if(next == 0){\\n                    dp[mouse][cat][flag] = 3;\\n                    return 3;\\n                }\\n                    \\n            }\\n            for(int next : G[mouse]){\\n                int cur = helper(new int[] {next,cat,1});\\n                max = Math.max(max,cur);\\n                if(max == 3){\\n                    dp[mouse][cat][flag] = max;\\n                    return max;\\n                }\\n                    \\n            }\\n            dp[mouse][cat][flag] = max;\\n            return max;\\n        } else{\\n            int min = 4;\\n            for(int next : G[cat]){\\n                if(next == mouse){\\n                    dp[mouse][cat][flag] = 1;\\n                    return 1;\\n                }\\n            }\\n            for(int next : G[cat]){\\n                if(next != 0){\\n                    int cur = helper(new int[] {mouse,next,0});\\n                    min = Math.min(min,cur);\\n                }\\n                    \\n                if(min == 1){\\n                    dp[mouse][cat][flag] = 1;\\n                    return 1;\\n                }\\n                    \\n            }\\n            dp[mouse][cat][flag] = min;\\n            return min;\\n        }\\n    }\\n}\\n```\\nIt is the original code, of course it could be simplified.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int[][] G;\\n    int[][][] dp;\\n    \\n    public int catMouseGame(int[][] graph) {\\n        G = graph;\\n        dp = new int[graph.length][graph.length][3];\\n        \\n        int res = helper(new int[] {1,2,0});\\n        if(res == 1)\\n            return 2;\\n        else if(res == 2)\\n            return 0;\\n        return 1;\\n    }\\n    \\n    public int helper (int[] status){\\n        \\n        int mouse = status[0], cat = status[1], flag = status[2];\\n        // System.out.print(mouse + \" \" + cat + \" \" + flag + \" \");\\n        // System.out.println();\\n        if(dp[mouse][cat][flag] > 0)\\n            return dp[mouse][cat][flag];\\n        dp[mouse][cat][flag] = 2;\\n        if(mouse == 0)\\n            return 3;\\n        if(mouse == cat)\\n            return 1;\\n        if(flag == 0){\\n            int max = 0;\\n            for(int next : G[mouse]){\\n                if(next == 0){\\n                    dp[mouse][cat][flag] = 3;\\n                    return 3;\\n                }\\n                    \\n            }\\n            for(int next : G[mouse]){\\n                int cur = helper(new int[] {next,cat,1});\\n                max = Math.max(max,cur);\\n                if(max == 3){\\n                    dp[mouse][cat][flag] = max;\\n                    return max;\\n                }\\n                    \\n            }\\n            dp[mouse][cat][flag] = max;\\n            return max;\\n        } else{\\n            int min = 4;\\n            for(int next : G[cat]){\\n                if(next == mouse){\\n                    dp[mouse][cat][flag] = 1;\\n                    return 1;\\n                }\\n            }\\n            for(int next : G[cat]){\\n                if(next != 0){\\n                    int cur = helper(new int[] {mouse,next,0});\\n                    min = Math.min(min,cur);\\n                }\\n                    \\n                if(min == 1){\\n                    dp[mouse][cat][flag] = 1;\\n                    return 1;\\n                }\\n                    \\n            }\\n            dp[mouse][cat][flag] = min;\\n            return min;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054886,
                "title": "python3-ft-90-basically-spfa-to-address-the-pitfalls-of-naive-dfs",
                "content": "# Intro\\n\\nThis problem took me FOREVER to solve, but it really clarified a lot of things about how game problems, DFS, and SPFA relate to each other. And what assumptions must hold to use DFS to solve problems in general. So I hope it helps.\\n\\nHopefully this solution helps. As a TLDR/summary:\\n* DFS doesn\\'t work because of draws (infinite loops of repeating moves) and because the graph has cycles (so there are no obvious base cases in top-down DFS in general)\\n* so instead we use what is basically SPFA to solve the problem from the bottom up\\n  * we label game states that result in a mouse or cat victory with their winner, the base cases of DFS\\n  * then we enqueue all \"adjacent\" states, i.e. those where a player can make a move that results in the base case\\n  * then we keep popping elements from the queue and processing them. if we now know the solution, then we enqueue their neighbors\\n* eventually for every state we end up with\\n  * a known winner for that state\\n  * or we *still* don\\'t know the answer - this means neither player was able to force a win from that state, so optimal play means they draw.\\n\\n# Intuition\\n\\nThe basic pattern behind all \"who wins if both players play optimally\" problems is this:\\n* let the state of the game be `s`, in this case coordinates `(m, c, player)` that tell us where the mouse and cat are, and who\\'s going next. I use `p` instead of `player` to keep things shorter\\n  * many game problems on LC don\\'t need `p` because both players can make the same moves. But in this game, the cat can\\'t move to 0 so we need to know who\\'s playing when iterating over moves (see below)\\n* conceptually (and often literally, but not in this case) we have a function `result(s)` that tells the result of the game starting from state `s` if both players play optimally\\n* to play optimally from state `s`, the player looks at all possible moves they can make, each resulting in a new state `s\\'`\\n  * if `result(s\\')` is `p` winning for ANY of the `s\\'`, then this means `p` can force a win by making that play. So the `result(s) == p wins`\\n  * otherwise `p` can\\'t win starting at `s`. If at least one `result(s\\')` is a draw, then `p` can avoid losing though. So `result(s) == draw`\\n  * otherwise, `p` loses no matter what move they make. `result(s) == p\\' wins`\\n\\nDefinitely check out some easier game problems first if this is confusing - you\\'ll find that all of the straightforward Nim game solutions follow this pattern! (some have fancy math solutions, which is great for speed but terrible for understanding how to approach these problems in general).\\n\\n**Usually** you can use top-down DFS with caching to solve the problem.\\n* write your `result(s)` function\\n* add caching so you only compute `result(s)` once for each state `s`\\n* and then you\\'re done!\\n\\n**But there\\'s a catch:** in most game theory problems, the sequences of moves `s -> s\\' -> s\\'\\' -> ...` never forms a loop. That\\'s because some player is removing an element from a pile, moving forward toward a goal, etc.\\n\\nBut in this problem, the players move on a graph. And that graph can have loops.\\n\\nSo if you try the usual DFS+caching, you\\'ll end up with an infinite loop. The reason for this is the players draw by repeating moves forever in a cycle `s -> s\\' -> s\\'\\' -> .. -> s`. In the DFS approach, that means `s` calls `result(s\\')`. Which calls `result(s\\'\\')`, etc.\\n\\nAnother problem you get with the DFS approach is that the graph has loops, so as you apply DFS, you\\'ll call `result(s\\')` for some state you haven\\'t solved yet.\\n* if you mark it as a draw, it might be wrong. It might be a draw, or it might be a win for either play but you just don\\'t know that yet because you haven\\'t explored the whole graph\\n* if you leave it as \"unknown\" (`UNK` in the code) then DFS may not return to that node later, after more states have been solved, to see if it has an answer yet.\\n\\n# Approach\\n\\nThe problems with DFS are\\n* you can end up in an infinite loop\\n* `result(s)` depends on the `result(s\\')` for each next state `s\\'`. If the states for some `s\\'` aren\\'t known yet, then we can\\'t know `result(s)` yet. But we have to make sure we revisit `result(s)` when we learn more of the `result(s)`\\n\\nTo address both of these we basically apply DFS \"backwards:\"\\n* we start with the base cases: situations where the cat and mouse win. So we\\'ll set `cache(s\\')` to the result\\n* we\\'ll also mark some situations as `BAD`, i.e. where the cat is at the hole, so they are ignored\\n* then we\\'ll enqueue `s` such that there is a valid move `s -> s\\'` and `s\\'` is our base case. This is the \"backwards\" part of \"apply DFS backwards\"\\n* each time we pop a state with unknown `result(s\\')` we check if we can now determine who wins (we look at all moves `s\\' -> s\\'\\'` as explained above)\\n  * if we find out that someone can win, we set `cache(s\\')` to the result, and enqueue all `s` where `s -> s\\'` is a valid move to the queue if we don\\'t already know `result(s)`\\n  * otherwise we do nothing. if later iterations discover someone wins or loses from a next state we need, then this will be re-enqueued. If not, then we\\'ll reach the end of the algorithm without determining a winner. This means there is a draw.\\n\\nSo in other words, the idea is to start with our base cases `s\\'`, then see which \"adjacent\" states `s` where `s -> s\\'` we can solve. Each time we solve a new state, we enqueue *its* adjacent states to solve them, and so on.\\n\\n**The connection to SPFA:** suprisingly it\\'s almost identical. In SPFA we \\n* start with the distance to the source node being 0 (the base case),* then iterate over all possible edges (the possible moves).\\n* if an edge results in a new shortest path to the other node (or in this case, a known winner for the next state), then we enqueue it to revisit that node to discover shorter paths (or in this case, revisit adjacent states to see if either player can force a win from that state).\\n* repeat this process forever until the queue is exhausted\\n\\nTo summarize, the algorithm has the following:\\n* a queue of unsolved states `(m, c, p)` that has the mouse and cat coordinates `m` and `c`, and the current player `p`\\n* a set that lets us check in `O(1)` if some state is already enqueued\\n* a table `W[p][m][c]` that contains the winner if known, otherwise `UNK`\\n* a helper method `updateNeighbors` that handles enqueuing things\\n* and a main SPFA-like loop that checks if we now know the solution for each unknown state `s\\'`, and if so, enqueing the neighbors `s` that depend on it - now that we solved `s\\'`, we may be able to solve `s` now.\\n\\n# Complexity\\n\\nTC for the base cases is $O(V+E)$ for $V$ nodes and $E$ edges. The main loop is basically SPFA, which has a worst-case running time of $O(V E)$.\\n\\n$V$ and $E$ are the nodes and edges in the state graph, not the number of nodes in the input graph. $V = 2 N^2$ because for each node in the input, there are two players and all pairwise combinations of those nodes for the state. Same thing I think for the edges, for each input edge we have all possible other nodes and edges for the other player.\\n\\nSo in terms of the input values I think the complexity is $O(N^2 E^2)$ for $N$ input nodes and $E$ input edges.\\n\\nSC is mainly the giant cache/table we make, with all `2 N^2` states. So $O(N^2)$.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def catMouseGame(self, adj: List[List[int]]) -> int:\\n        # What I tried:\\n        # BFS/DFS (considered only) - we need to play optimally, not explore all paths. NEXT.\\n        # \"dual DFS,\" a mouseResult(m, c) and catResult(m, c) function that call each other.\\n        # If we encounter a state that we\\'ve already seen that means it\\'s a draw***.\\n\\n        # Spoiler alert: *** is WRONG. If we\\'ve seen the state in DFS, it means that we don\\'t\\n        # have an answer yet. NOT that it\\'s necessarily a loop.\\n\\n        # Example: suppose the state is (m, c, player) where\\n        #    m, c are the mouse and cat locations\\n        #    player is whose turn it is to play\\n\\n        # Some states are easy, like (m, c, mouse) where m is adjacent to zero.\\n        #    Mouse moves to 0 and wins.\\n\\n        # Or anything of the form (m, c, cat) where m is adjacent to cat\\n\\n        # For DP we have a table and fill it out deterministically in a known pattern\\n        # For DFS we automatically fill in the table (the code determines the recurrence rel.)\\n        # but we know that all the calls will terminate in a base case.\\n\\n        # But in this case we can have loops, or things where we don\\'t know the result for (m, c, p) *yet*,\\n        # but will know later as we fill in more of the graph\\n\\n        UNK = 0 # for easy \"if not state: <fill in that state>\"\\n        MOUSE_WINS = 1\\n        CAT_WINS = 2\\n        BAD = 3 # mainly for cat-is-at-0 stuff\\n\\n        MOUSE = 0\\n        CAT = 1\\n\\n        # we\\'ll use BFS in SPFA style, basically graph coloring/relaxation\\n        #   1. we\\'ll fill in some easy base cases: mouse victory and cat victory, and the illegal states\\n        #   2. queue adjacent nodes\\n        #   3. then process the queue - if a state\\'s result (mouse/cat/draw) is known, we fill it in an enqueue\\n        #      its neighbors. otherwise just drop it - either we\\'ll enqueue it again when we learn more, or discard it\\n\\n        n = len(adj)\\n        q = deque()\\n        enq = set()\\n        W = [[[UNK]*n for _ in range(n)] for _ in range(2)] # W[p][m][c]; p==0 is mouse, p == 1 is cat\\n        \\n        def updateNeighbors(m, c, p):\\n            \"\"\"Enqueues unsolved problems (m\\', c\\', 1-p) that depend on the result of m,c,p.\"\"\"\\n            if p == MOUSE:\\n                # things depending on this are states (m, c\\', CAT): after the cat moves from c\\' to c,\\n                # the result is W[p][m][c]                \\n                for c2 in adj[c]:\\n                    if c2 == 0:\\n                        continue\\n\\n                    if W[CAT][m][c2] == UNK:\\n                        state = (m, c2, CAT)\\n                        if state not in enq:\\n                            enq.add(state)\\n                            q.append(state)\\n            else:\\n                for m2 in adj[m]:\\n                    if W[MOUSE][m2][c] == UNK:\\n                        state = (m2, c, MOUSE)\\n                        if state not in enq:\\n                            enq.add(state)\\n                            q.append(state)\\n\\n        # set results for base cases and enqueue neighbors\\n\\n        # if the mouse reaches the hole it wins\\n        for c in range(1, n):\\n            for p in [MOUSE, CAT]: # BUG 1: NEED TO ADD ALL BASE CASES, before was just mouse. Need to make sure mouse knows moving to (c, c, cat) is a loss\\n                W[p][0][c] = MOUSE_WINS # ..[CAT] because it\\'s the cat\\'s turn after the mouse moves to the hole\\n                updateNeighbors(0, c, p)\\n\\n        # if the cat reaches the mouse, the cat wins\\n        for m in range(1, n):\\n            for p in [MOUSE, CAT]: # BUG 1: same thing\\n                W[p][m][m] = CAT_WINS\\n                updateNeighbors(m, m, p)\\n\\n        # cat isn\\'t allowed to be at the hole node on anyone\\'s turn\\n        for m in range(1, n):\\n            for p in [MOUSE, CAT]:\\n                W[p][m][0] = BAD\\n\\n        # and now for the heavy lifting\\n        while q:\\n            state = q.popleft()\\n            enq.remove(state)\\n            m, c, p = state\\n\\n            if W[p][m][c]:\\n                # this can occur at the beginning when we enqueue neighbors of\\n                # the base cases - those neighbors themselves may also be base cases\\n                continue\\n\\n            if m == c:\\n                raise RuntimeError(\"m == c: (m, c, p) =\", (m, c, p))\\n\\n            if p == MOUSE:\\n                # consider all moves, and the result of the game from there\\n                #   if any of those states is MOUSE_WINS, then the mouse can force a win\\n                #   if all valid adj states are CAT_WINS, then the cat wins\\n                #   otherwise either\\n                #      - it\\'s a draw: cat and mouse can repeat moves forever\\n                #      - or we still don\\'t know enough. this state will be re-enqueued if/when we learn more\\n                foundUnk = False\\n                for m2 in adj[m]:\\n                    if W[CAT][m2][c] == MOUSE_WINS:\\n                        if m == 1 and c == 2:\\n                            return MOUSE_WINS\\n                        W[MOUSE][m][c] = MOUSE_WINS\\n                        updateNeighbors(m, c, MOUSE) # BUG 2: FORGOT TO UPDATE NEIGHBORS\\n\\n                        break\\n                    elif W[CAT][m2][c] == UNK:\\n                        foundUnk = True # record that there\\'s at least one state we don\\'t know\\n                        # can\\'t mark it as a draw or CAT_WINS yet because we don\\'t know this\\n                        # node. We may determine its value later as we keep relaxing/coloring\\n                        # the graph\\n                    # else: CAT_WINS or BAD\\n\\n                if W[MOUSE][m][c] == UNK and not foundUnk:\\n                    # we visited all neighbors of this node, and all valid neighbors were CAT_WINS. So CAT_WINS\\n                    if m == 1 and c == 2:\\n                        return CAT_WINS\\n                    W[MOUSE][m][c] = CAT_WINS\\n                    updateNeighbors(m, c, MOUSE)\\n                # else: need to know 1+ neighbor before we know this state. So\\n                # hold off until this state is re-enqueued via learning the result\\n                # of a neighbor\\n            else: # p == CAT:\\n                foundUnk = False\\n                for c2 in adj[c]:\\n                    if c2 == 0:\\n                        continue\\n                    elif W[MOUSE][m][c2] == CAT_WINS:\\n                        W[CAT][m][c] = CAT_WINS # cat can force a win by moving here\\n                        updateNeighbors(m, c, CAT)\\n                        break\\n                    elif W[MOUSE][m][c2] == UNK:\\n                        foundUnk = True\\n\\n                if W[CAT][m][c] == UNK and not foundUnk:\\n                    W[CAT][m][c] = MOUSE_WINS\\n                    updateNeighbors(m, c, CAT)\\n\\n        for p in [MOUSE, CAT]:\\n            for m in range(n):\\n                for c in range(n):\\n                    if W[p][m][c] in [MOUSE_WINS, CAT_WINS]:\\n                        print(m, c, \\'cat\\' if p else \\'mouse\\', \\'->\\', \\'MOUSE\\' if W[p][m][c] == MOUSE_WINS else \\'CAT\\')\\n\\n        # we solved all states we can solve. the rest are states where neither player can force\\n        # a win, i.e. a draw\\n        return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def catMouseGame(self, adj: List[List[int]]) -> int:\\n        # What I tried:\\n        # BFS/DFS (considered only) - we need to play optimally, not explore all paths. NEXT.\\n        # \"dual DFS,\" a mouseResult(m, c) and catResult(m, c) function that call each other.\\n        # If we encounter a state that we\\'ve already seen that means it\\'s a draw***.\\n\\n        # Spoiler alert: *** is WRONG. If we\\'ve seen the state in DFS, it means that we don\\'t\\n        # have an answer yet. NOT that it\\'s necessarily a loop.\\n\\n        # Example: suppose the state is (m, c, player) where\\n        #    m, c are the mouse and cat locations\\n        #    player is whose turn it is to play\\n\\n        # Some states are easy, like (m, c, mouse) where m is adjacent to zero.\\n        #    Mouse moves to 0 and wins.\\n\\n        # Or anything of the form (m, c, cat) where m is adjacent to cat\\n\\n        # For DP we have a table and fill it out deterministically in a known pattern\\n        # For DFS we automatically fill in the table (the code determines the recurrence rel.)\\n        # but we know that all the calls will terminate in a base case.\\n\\n        # But in this case we can have loops, or things where we don\\'t know the result for (m, c, p) *yet*,\\n        # but will know later as we fill in more of the graph\\n\\n        UNK = 0 # for easy \"if not state: <fill in that state>\"\\n        MOUSE_WINS = 1\\n        CAT_WINS = 2\\n        BAD = 3 # mainly for cat-is-at-0 stuff\\n\\n        MOUSE = 0\\n        CAT = 1\\n\\n        # we\\'ll use BFS in SPFA style, basically graph coloring/relaxation\\n        #   1. we\\'ll fill in some easy base cases: mouse victory and cat victory, and the illegal states\\n        #   2. queue adjacent nodes\\n        #   3. then process the queue - if a state\\'s result (mouse/cat/draw) is known, we fill it in an enqueue\\n        #      its neighbors. otherwise just drop it - either we\\'ll enqueue it again when we learn more, or discard it\\n\\n        n = len(adj)\\n        q = deque()\\n        enq = set()\\n        W = [[[UNK]*n for _ in range(n)] for _ in range(2)] # W[p][m][c]; p==0 is mouse, p == 1 is cat\\n        \\n        def updateNeighbors(m, c, p):\\n            \"\"\"Enqueues unsolved problems (m\\', c\\', 1-p) that depend on the result of m,c,p.\"\"\"\\n            if p == MOUSE:\\n                # things depending on this are states (m, c\\', CAT): after the cat moves from c\\' to c,\\n                # the result is W[p][m][c]                \\n                for c2 in adj[c]:\\n                    if c2 == 0:\\n                        continue\\n\\n                    if W[CAT][m][c2] == UNK:\\n                        state = (m, c2, CAT)\\n                        if state not in enq:\\n                            enq.add(state)\\n                            q.append(state)\\n            else:\\n                for m2 in adj[m]:\\n                    if W[MOUSE][m2][c] == UNK:\\n                        state = (m2, c, MOUSE)\\n                        if state not in enq:\\n                            enq.add(state)\\n                            q.append(state)\\n\\n        # set results for base cases and enqueue neighbors\\n\\n        # if the mouse reaches the hole it wins\\n        for c in range(1, n):\\n            for p in [MOUSE, CAT]: # BUG 1: NEED TO ADD ALL BASE CASES, before was just mouse. Need to make sure mouse knows moving to (c, c, cat) is a loss\\n                W[p][0][c] = MOUSE_WINS # ..[CAT] because it\\'s the cat\\'s turn after the mouse moves to the hole\\n                updateNeighbors(0, c, p)\\n\\n        # if the cat reaches the mouse, the cat wins\\n        for m in range(1, n):\\n            for p in [MOUSE, CAT]: # BUG 1: same thing\\n                W[p][m][m] = CAT_WINS\\n                updateNeighbors(m, m, p)\\n\\n        # cat isn\\'t allowed to be at the hole node on anyone\\'s turn\\n        for m in range(1, n):\\n            for p in [MOUSE, CAT]:\\n                W[p][m][0] = BAD\\n\\n        # and now for the heavy lifting\\n        while q:\\n            state = q.popleft()\\n            enq.remove(state)\\n            m, c, p = state\\n\\n            if W[p][m][c]:\\n                # this can occur at the beginning when we enqueue neighbors of\\n                # the base cases - those neighbors themselves may also be base cases\\n                continue\\n\\n            if m == c:\\n                raise RuntimeError(\"m == c: (m, c, p) =\", (m, c, p))\\n\\n            if p == MOUSE:\\n                # consider all moves, and the result of the game from there\\n                #   if any of those states is MOUSE_WINS, then the mouse can force a win\\n                #   if all valid adj states are CAT_WINS, then the cat wins\\n                #   otherwise either\\n                #      - it\\'s a draw: cat and mouse can repeat moves forever\\n                #      - or we still don\\'t know enough. this state will be re-enqueued if/when we learn more\\n                foundUnk = False\\n                for m2 in adj[m]:\\n                    if W[CAT][m2][c] == MOUSE_WINS:\\n                        if m == 1 and c == 2:\\n                            return MOUSE_WINS\\n                        W[MOUSE][m][c] = MOUSE_WINS\\n                        updateNeighbors(m, c, MOUSE) # BUG 2: FORGOT TO UPDATE NEIGHBORS\\n\\n                        break\\n                    elif W[CAT][m2][c] == UNK:\\n                        foundUnk = True # record that there\\'s at least one state we don\\'t know\\n                        # can\\'t mark it as a draw or CAT_WINS yet because we don\\'t know this\\n                        # node. We may determine its value later as we keep relaxing/coloring\\n                        # the graph\\n                    # else: CAT_WINS or BAD\\n\\n                if W[MOUSE][m][c] == UNK and not foundUnk:\\n                    # we visited all neighbors of this node, and all valid neighbors were CAT_WINS. So CAT_WINS\\n                    if m == 1 and c == 2:\\n                        return CAT_WINS\\n                    W[MOUSE][m][c] = CAT_WINS\\n                    updateNeighbors(m, c, MOUSE)\\n                # else: need to know 1+ neighbor before we know this state. So\\n                # hold off until this state is re-enqueued via learning the result\\n                # of a neighbor\\n            else: # p == CAT:\\n                foundUnk = False\\n                for c2 in adj[c]:\\n                    if c2 == 0:\\n                        continue\\n                    elif W[MOUSE][m][c2] == CAT_WINS:\\n                        W[CAT][m][c] = CAT_WINS # cat can force a win by moving here\\n                        updateNeighbors(m, c, CAT)\\n                        break\\n                    elif W[MOUSE][m][c2] == UNK:\\n                        foundUnk = True\\n\\n                if W[CAT][m][c] == UNK and not foundUnk:\\n                    W[CAT][m][c] = MOUSE_WINS\\n                    updateNeighbors(m, c, CAT)\\n\\n        for p in [MOUSE, CAT]:\\n            for m in range(n):\\n                for c in range(n):\\n                    if W[p][m][c] in [MOUSE_WINS, CAT_WINS]:\\n                        print(m, c, \\'cat\\' if p else \\'mouse\\', \\'->\\', \\'MOUSE\\' if W[p][m][c] == MOUSE_WINS else \\'CAT\\')\\n\\n        # we solved all states we can solve. the rest are states where neither player can force\\n        # a win, i.e. a draw\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859991,
                "title": "iterative-dp-no-recursion-slow-solution",
                "content": "\\n```\\nclass Solution {\\n    public int catMouseGame(int[][] graph) {\\n        int n = graph.length;\\n        int [][][][] dp = new int[5*n][n][n][2];\\n        for(int i = 0; i<n; i++){\\n            dp[0][0][i] = new int[]{1, 1};\\n        }\\n        for(int i = 0; i<n; i++){\\n            dp[0][i][0] = new int[]{1, 1};\\n        }\\n        for(int i = 1; i<n; i++){\\n            dp[0][i][i] = new int[]{2, 2};\\n        }\\n        for(int i = 1; i<5*n; i++){\\n            for(int j = 0; j<n; j++){\\n                for(int k = 0; k<n; k++){\\n                    if(j==0 || k==0){\\n                        dp[i][j][k][0] = 1;\\n                        continue;\\n                    }\\n                    if(j==k){\\n                        dp[i][j][k][0] = 2;\\n                        continue;\\n                    }\\n                    int zero = 0;\\n                    int one = 0;\\n                    for(int v : graph[j]){\\n                        if(dp[i-1][v][k][1]==0)    zero++;\\n                        if(dp[i-1][v][k][1]==1)    one++;\\n                    }\\n                    if(one>0)   dp[i][j][k][0] = 1;\\n                    else if(zero==0)    dp[i][j][k][0] = 2;\\n                }\\n                for(int k = 0; k<n; k++){\\n                    if(j==0 || k==0){\\n                        dp[i][k][j][1] = 1;\\n                        continue;\\n                    }\\n                    if(j==k){\\n                        dp[i][k][j][1] = 2;\\n                        continue;\\n                    }\\n                    int zero = 0;\\n                    int two = 0;\\n                    for(int v : graph[j]){\\n                        if(dp[i-1][k][v][0]==0)    zero++;\\n                        if(dp[i-1][k][v][0]==2)    two++;\\n                    }\\n                    if(two>0)   dp[i][k][j][1] = 2;\\n                    else if(zero==0)    dp[i][k][j][1] = 1;\\n                }\\n            }\\n        }\\n        for(int i = 1; i<5*n; i++){\\n            if(dp[i][1][2][0]!=0)   return dp[i][1][2][0];\\n        }\\n        return 0;\\n    }\\n}\\n```\\n\\n**Don\\'t ask me why I had taken 5\\\\*n ;) (It should be n\\\\*n, because there are total n\\\\*n states. Yes it will give TLE so I had taken 5\\\\*n)**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int catMouseGame(int[][] graph) {\\n        int n = graph.length;\\n        int [][][][] dp = new int[5*n][n][n][2];\\n        for(int i = 0; i<n; i++){\\n            dp[0][0][i] = new int[]{1, 1};\\n        }\\n        for(int i = 0; i<n; i++){\\n            dp[0][i][0] = new int[]{1, 1};\\n        }\\n        for(int i = 1; i<n; i++){\\n            dp[0][i][i] = new int[]{2, 2};\\n        }\\n        for(int i = 1; i<5*n; i++){\\n            for(int j = 0; j<n; j++){\\n                for(int k = 0; k<n; k++){\\n                    if(j==0 || k==0){\\n                        dp[i][j][k][0] = 1;\\n                        continue;\\n                    }\\n                    if(j==k){\\n                        dp[i][j][k][0] = 2;\\n                        continue;\\n                    }\\n                    int zero = 0;\\n                    int one = 0;\\n                    for(int v : graph[j]){\\n                        if(dp[i-1][v][k][1]==0)    zero++;\\n                        if(dp[i-1][v][k][1]==1)    one++;\\n                    }\\n                    if(one>0)   dp[i][j][k][0] = 1;\\n                    else if(zero==0)    dp[i][j][k][0] = 2;\\n                }\\n                for(int k = 0; k<n; k++){\\n                    if(j==0 || k==0){\\n                        dp[i][k][j][1] = 1;\\n                        continue;\\n                    }\\n                    if(j==k){\\n                        dp[i][k][j][1] = 2;\\n                        continue;\\n                    }\\n                    int zero = 0;\\n                    int two = 0;\\n                    for(int v : graph[j]){\\n                        if(dp[i-1][k][v][0]==0)    zero++;\\n                        if(dp[i-1][k][v][0]==2)    two++;\\n                    }\\n                    if(two>0)   dp[i][k][j][1] = 2;\\n                    else if(zero==0)    dp[i][k][j][1] = 1;\\n                }\\n            }\\n        }\\n        for(int i = 1; i<5*n; i++){\\n            if(dp[i][1][2][0]!=0)   return dp[i][1][2][0];\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606518,
                "title": "java-solution-with-approach-beats-80",
                "content": "# Intuition\\nThe code efficiently solves the \"Cat and Mouse\" game problem using a DFS approach and dynamic programming to avoid redundant computations.\\n\\n# Approach\\n1. The game is modeled as a graph, where each node represents a state of the game with the mouse\\'s position, the cat\\'s position, and the current turn.\\n2. The goal is for the mouse to reach the hole (position 0) before the cat catches it.\\n3. The code uses a depth-first search (DFS) approach to explore all possible states of the game and determine the outcome for each state.\\n4. The DFS function takes as input the current mouse position, cat position, and turn. It returns the outcome of the game for that state.\\n5. The DFS function uses memoization to avoid redundant computations. It checks if the outcome for the current state has already been computed and stored in the `state` array. If so, it returns the stored outcome.\\n6. The DFS function handles three base cases:\\n   - If the mouse reaches the hole (position 0), it marks the state as a mouse win and returns 1.\\n   - If the cat catches the mouse (mouse == cat), it marks the state as a cat win and returns 2.\\n   - If the current state is a draw (no immediate winner but the game is not over), it marks the state as a draw and returns 0.\\n7. If the current turn is the mouse\\'s turn:\\n   - The DFS function explores all possible moves from the current mouse position and recursively calls itself for each move, considering it as the cat\\'s turn.\\n   - If there is a move that leads to a mouse win, the current state is marked as a mouse win and 1 is returned.\\n   - If there is no mouse win but at least one move results in a draw, the current state is marked as a draw and 0 is returned.\\n   - If all moves result in a cat win, the current state is marked as a cat win and 2 is returned.\\n8. If the current turn is the cat\\'s turn:\\n   - The DFS function explores all possible moves from the current cat position (excluding position 0) and recursively calls itself for each move, considering it as the mouse\\'s turn.\\n   - If there is a move that leads to a cat win, the current state is marked as a cat win and 2 is returned.\\n   - If there is no cat win but at least one move results in a draw, the current state is marked as a draw and 0 is returned.\\n   - If all moves result in a mouse win, the current state is marked as a mouse win and 1 is returned.\\n9. The `catMouseGame` function initializes the `state` array and starts the game by calling the DFS function with the initial positions (mouse=1, cat=2) and the starting turn (0 for mouse).\\n10. After the initial state is computed, the code checks if there are any positions marked as a draw and tries to revisit those positions.\\n11. It continues revisiting the positions until no new positions are marked as draws or until all positions have been revisited.\\n12. Finally, the code checks the state of the initial position (1, 2, 0) in the `state` array. If it is marked as a cat win, it returns 0 (indicating a draw). Otherwise, it returns the state of the initial position (mouse win or draw).\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the provided code is O(n^3 * k).d\\n\\n- Space complexity:\\nThe space complexity of the provided code is O(n^3), where n is the number of positions in the graph.\\n\\n# Code\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    private int[][][] state;\\n\\n    public int catMouseGame(int[][] graph) {\\n        int n = graph.length;\\n        state = new int[n][n][2];\\n        for (int[][] arr : state) {\\n            for (int[] subArr : arr) {\\n                Arrays.fill(subArr, -1);\\n            }\\n        }\\n        \\n        dfs(graph, 1, 2, 0);\\n\\n        List<int[]> revisit = new ArrayList<>();\\n        int lastRound = -1;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                for (int k = 0; k < 2; k++) {\\n                    if (state[i][j][k] == 0) {\\n                        int[] v = {i, j, k};\\n                        revisit.add(v);\\n                    }\\n                }\\n            }\\n        }\\n\\n        while (lastRound != revisit.size() && revisit.size() != 0) {\\n            lastRound = revisit.size();\\n            for (int[] v : revisit) {\\n                state[v[0]][v[1]][v[2]] = -1;\\n                dfs(graph, v[0], v[1], v[2]);\\n            }\\n            revisit.clear();\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    for (int k = 0; k < 2; k++) {\\n                        if (state[i][j][k] == 0) {\\n                            int[] v = {i, j, k};\\n                            revisit.add(v);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (state[1][2][0] == -1) {\\n            return 0;\\n        } else {\\n            return state[1][2][0];\\n        }\\n    }\\n\\n    private int dfs(int[][] graph, int mouse, int cat, int turn) {\\n        if (state[mouse][cat][turn] != -1) {\\n            return state[mouse][cat][turn];\\n        }\\n        if (mouse == 0) {\\n            state[mouse][cat][turn] = 1;\\n            return 1;\\n        }\\n        if (mouse == cat) {\\n            state[mouse][cat][turn] = 2;\\n            return 2;\\n        }\\n        state[mouse][cat][turn] = 0;\\n\\n        if (turn == 0) { // Mouse\\'s turn\\n            boolean isDraw = false;\\n            for (int i = 0; i < graph[mouse].length; i++) {\\n                int nextTurn = dfs(graph, graph[mouse][i], cat, turn + 1);\\n                if (nextTurn == 1) {\\n                    isDraw = false;\\n                    state[mouse][cat][turn] = 1;\\n                    return 1;\\n                }\\n                if (nextTurn == 0) {\\n                    isDraw = true;\\n                }\\n            }\\n            if (isDraw) {\\n                state[mouse][cat][turn] = 0;\\n                return 0;\\n            }\\n            state[mouse][cat][turn] = 2;\\n            return 2;\\n        } else { // Cat\\'s turn\\n            boolean isDraw = false;\\n            for (int i = 0; i < graph[cat].length; i++) {\\n                if (graph[cat][i] != 0) {\\n                    int nextTurn = dfs(graph, mouse, graph[cat][i], turn - 1);\\n                    if (nextTurn == 2) {\\n                        isDraw = false;\\n                        state[mouse][cat][turn] = 2;\\n                        return 2;\\n                    }\\n                    if (nextTurn == 0) {\\n                        isDraw = true;\\n                    }\\n                }\\n            }\\n            if (isDraw) {\\n                state[mouse][cat][turn] = 0;\\n                return 0;\\n            }\\n            state[mouse][cat][turn] = 1;\\n            return 1;\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    private int[][][] state;\\n\\n    public int catMouseGame(int[][] graph) {\\n        int n = graph.length;\\n        state = new int[n][n][2];\\n        for (int[][] arr : state) {\\n            for (int[] subArr : arr) {\\n                Arrays.fill(subArr, -1);\\n            }\\n        }\\n        \\n        dfs(graph, 1, 2, 0);\\n\\n        List<int[]> revisit = new ArrayList<>();\\n        int lastRound = -1;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                for (int k = 0; k < 2; k++) {\\n                    if (state[i][j][k] == 0) {\\n                        int[] v = {i, j, k};\\n                        revisit.add(v);\\n                    }\\n                }\\n            }\\n        }\\n\\n        while (lastRound != revisit.size() && revisit.size() != 0) {\\n            lastRound = revisit.size();\\n            for (int[] v : revisit) {\\n                state[v[0]][v[1]][v[2]] = -1;\\n                dfs(graph, v[0], v[1], v[2]);\\n            }\\n            revisit.clear();\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    for (int k = 0; k < 2; k++) {\\n                        if (state[i][j][k] == 0) {\\n                            int[] v = {i, j, k};\\n                            revisit.add(v);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (state[1][2][0] == -1) {\\n            return 0;\\n        } else {\\n            return state[1][2][0];\\n        }\\n    }\\n\\n    private int dfs(int[][] graph, int mouse, int cat, int turn) {\\n        if (state[mouse][cat][turn] != -1) {\\n            return state[mouse][cat][turn];\\n        }\\n        if (mouse == 0) {\\n            state[mouse][cat][turn] = 1;\\n            return 1;\\n        }\\n        if (mouse == cat) {\\n            state[mouse][cat][turn] = 2;\\n            return 2;\\n        }\\n        state[mouse][cat][turn] = 0;\\n\\n        if (turn == 0) { // Mouse\\'s turn\\n            boolean isDraw = false;\\n            for (int i = 0; i < graph[mouse].length; i++) {\\n                int nextTurn = dfs(graph, graph[mouse][i], cat, turn + 1);\\n                if (nextTurn == 1) {\\n                    isDraw = false;\\n                    state[mouse][cat][turn] = 1;\\n                    return 1;\\n                }\\n                if (nextTurn == 0) {\\n                    isDraw = true;\\n                }\\n            }\\n            if (isDraw) {\\n                state[mouse][cat][turn] = 0;\\n                return 0;\\n            }\\n            state[mouse][cat][turn] = 2;\\n            return 2;\\n        } else { // Cat\\'s turn\\n            boolean isDraw = false;\\n            for (int i = 0; i < graph[cat].length; i++) {\\n                if (graph[cat][i] != 0) {\\n                    int nextTurn = dfs(graph, mouse, graph[cat][i], turn - 1);\\n                    if (nextTurn == 2) {\\n                        isDraw = false;\\n                        state[mouse][cat][turn] = 2;\\n                        return 2;\\n                    }\\n                    if (nextTurn == 0) {\\n                        isDraw = true;\\n                    }\\n                }\\n            }\\n            if (isDraw) {\\n                state[mouse][cat][turn] = 0;\\n                return 0;\\n            }\\n            state[mouse][cat][turn] = 1;\\n            return 1;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512317,
                "title": "java-solution-with",
                "content": "Draw is tricky because if we only memo on mouse position, cat position, and whose turn it is,\\nthen, say, the current turn is mouse, and it sees that going upward can lead to a draw and nowhere else can lead to its win, so\\nit will take that and conclude the best play is a draw, but it is not the case because going upward can lead to a deadend and then go back down, and it so happens that it is mouse\\'s turn again and cat\\'s position is the same, then it will mistakenly think it is a draw when in fact it should have been cat win.\\n\\nTo address this problem, we have to let it run loooooooooong enough, memo on time, so that all possible moves that can lead to a cat win or mouse win has been revealed, and if there is still no path to either of them wins by TIME_MAX, then it is a draw.\\n\\nI\\'ve chosen TIME_MAX to be 200 turns, and it works fine.\\n\\n# Code\\n```\\n\\n\\nclass Solution {\\n    int TIME_MAX = 200;\\n    int DRAW = 0;\\n    int MOUSE_WIN = 1;\\n    int CAT_WIN = 2;\\n    public int catMouseGame(int[][] graph) {\\n        return dfs(0, new int[]{1, 2}, graph, new Integer[TIME_MAX+1][graph.length][graph.length]);\\n    }\\n\\n    private int dfs(int time, int[] p, int[][] graph, Integer[][][] memo){ // p[0] -> mouse position, p[1] -> cat position\\n        Integer old = memo[time][p[0]][p[1]];\\n        if (old != null)      return old;       // all the base cases here\\n        if (time >= TIME_MAX) return DRAW;\\n        if (p[0]==0)          return MOUSE_WIN;\\n        if (p[0]==p[1])       return CAT_WIN;\\n        int state = 0;\\n        int where = p[time&1];\\n        int res = DRAW;\\n        for (int i = 0; i < graph[where].length; i++){\\n            if ((time&1)==0||graph[where][i]>0){ // if mouse turn or cat turn and the dest is not 0, do ...\\n                p[time&1]=graph[where][i];\\n                state |= 1 << dfs(time+1, p, graph, memo);\\n                if ((time&1)>0&&(state&4)>0 || (time&1)==0&&(state&2)>0) // if mouse\\'s turn & mouse win\\n                    break;                                               // or cat\\'s turn & cat win, then we stop.\\n            }\\n        }\\n        p[time&1]=where; // restore p\\n        if (((time&1)>0 && (state & 4)>0)||((time&1)==0) && state==4){ \\n            res = CAT_WIN; // cat win when (cat\\'s turn & cat win) or (mouse\\'s turn and state = cat)\\n        }else if (((time&1)==0 && (state & 2)>0)||(time&1)==1 && state==2){\\n            res = MOUSE_WIN; // mouse win when (mouse\\'s turn and mouse win) or (cat\\'s turn and state = mouse)\\n        }\\n        return memo[time][p[0]][p[1]]=res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming",
                    "Memoization",
                    "Game Theory"
                ],
                "code": "```\\n\\n\\nclass Solution {\\n    int TIME_MAX = 200;\\n    int DRAW = 0;\\n    int MOUSE_WIN = 1;\\n    int CAT_WIN = 2;\\n    public int catMouseGame(int[][] graph) {\\n        return dfs(0, new int[]{1, 2}, graph, new Integer[TIME_MAX+1][graph.length][graph.length]);\\n    }\\n\\n    private int dfs(int time, int[] p, int[][] graph, Integer[][][] memo){ // p[0] -> mouse position, p[1] -> cat position\\n        Integer old = memo[time][p[0]][p[1]];\\n        if (old != null)      return old;       // all the base cases here\\n        if (time >= TIME_MAX) return DRAW;\\n        if (p[0]==0)          return MOUSE_WIN;\\n        if (p[0]==p[1])       return CAT_WIN;\\n        int state = 0;\\n        int where = p[time&1];\\n        int res = DRAW;\\n        for (int i = 0; i < graph[where].length; i++){\\n            if ((time&1)==0||graph[where][i]>0){ // if mouse turn or cat turn and the dest is not 0, do ...\\n                p[time&1]=graph[where][i];\\n                state |= 1 << dfs(time+1, p, graph, memo);\\n                if ((time&1)>0&&(state&4)>0 || (time&1)==0&&(state&2)>0) // if mouse\\'s turn & mouse win\\n                    break;                                               // or cat\\'s turn & cat win, then we stop.\\n            }\\n        }\\n        p[time&1]=where; // restore p\\n        if (((time&1)>0 && (state & 4)>0)||((time&1)==0) && state==4){ \\n            res = CAT_WIN; // cat win when (cat\\'s turn & cat win) or (mouse\\'s turn and state = cat)\\n        }else if (((time&1)==0 && (state & 2)>0)||(time&1)==1 && state==2){\\n            res = MOUSE_WIN; // mouse win when (mouse\\'s turn and mouse win) or (cat\\'s turn and state = mouse)\\n        }\\n        return memo[time][p[0]][p[1]]=res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3412329,
                "title": "kotlin-readable-solution",
                "content": "\\n# Code\\n```\\ndata class Turn(val mouse: Int, val cat: Int, val turn: Int)\\n\\n\\nclass Solution {\\n    val DRAW = 0\\n    val MOUSE_WIN = 1\\n    val CAT_WIN = 2\\n\\n    val MOUSE_TURN = 1\\n    val CAT_TURN = 2\\n\\n    fun catMouseGame(graph: Array<IntArray>): Int {\\n        val n = graph.size\\n        val status = Array(n){ Array(n){ IntArray(3){ DRAW } } }\\n        val indegree = Array(n){ Array(n){ IntArray(3){ 0 } } }\\n\\n        for (mouse in 0 until n) {\\n            for (cat in 0 until n) {\\n                indegree[mouse][cat][MOUSE_TURN] = graph[mouse].size\\n                indegree[mouse][cat][CAT_TURN] = graph[cat].filter{ it > 0 }.size\\n            }\\n        }\\n\\n        val queue = LinkedList<Turn>()\\n        for (cat in 0 until n) {\\n            for (turn in MOUSE_TURN..CAT_TURN) {\\n                status[0][cat][turn] = MOUSE_WIN\\n                queue.offer(Turn(0, cat, turn))\\n\\n                if ( cat > 0) {\\n                    status[cat][cat][turn] = CAT_WIN\\n                    queue.offer(Turn(cat, cat, turn))\\n                }\\n            }\\n        }\\n\\n        while(!queue.isEmpty()) {\\n            val curr = queue.poll()\\n            val statusSoFar = status[curr.mouse][curr.cat][curr.turn]\\n\\n            for (parent in parents(curr, graph)) {\\n                val statusOfParent = status[parent.mouse][parent.cat][parent.turn]\\n                if (statusOfParent != DRAW) continue\\n\\n                if ( (parent.turn == MOUSE_TURN && statusSoFar == MOUSE_WIN) \\n                  || (parent.turn == CAT_TURN   && statusSoFar == CAT_WIN) ) { \\n                    status[parent.mouse][parent.cat][parent.turn] = statusSoFar\\n                    queue.add(parent)\\n                } else if ( --indegree[parent.mouse][parent.cat][parent.turn] == 0 ) {\\n                    status[parent.mouse][parent.cat][parent.turn] = if (parent.turn == MOUSE_TURN) CAT_WIN else MOUSE_WIN\\n                    queue.add(parent)\\n                }\\n            }\\n        }\\n\\n        return status[1][2][MOUSE_TURN]\\n    } \\n\\n    fun parents(curr: Turn, graph: Array<IntArray>): List<Turn> {\\n        val result = mutableListOf<Turn>()\\n\\n        if (curr.turn == CAT_TURN) {\\n            for (mouse in graph[curr.mouse]) {\\n                result.add(Turn(mouse, curr.cat, MOUSE_TURN))\\n            }\\n        } else {\\n            for (cat in graph[curr.cat]) {\\n                if (cat == 0) continue\\n                result.add(Turn(curr.mouse, cat, CAT_TURN))\\n            }\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\ndata class Turn(val mouse: Int, val cat: Int, val turn: Int)\\n\\n\\nclass Solution {\\n    val DRAW = 0\\n    val MOUSE_WIN = 1\\n    val CAT_WIN = 2\\n\\n    val MOUSE_TURN = 1\\n    val CAT_TURN = 2\\n\\n    fun catMouseGame(graph: Array<IntArray>): Int {\\n        val n = graph.size\\n        val status = Array(n){ Array(n){ IntArray(3){ DRAW } } }\\n        val indegree = Array(n){ Array(n){ IntArray(3){ 0 } } }\\n\\n        for (mouse in 0 until n) {\\n            for (cat in 0 until n) {\\n                indegree[mouse][cat][MOUSE_TURN] = graph[mouse].size\\n                indegree[mouse][cat][CAT_TURN] = graph[cat].filter{ it > 0 }.size\\n            }\\n        }\\n\\n        val queue = LinkedList<Turn>()\\n        for (cat in 0 until n) {\\n            for (turn in MOUSE_TURN..CAT_TURN) {\\n                status[0][cat][turn] = MOUSE_WIN\\n                queue.offer(Turn(0, cat, turn))\\n\\n                if ( cat > 0) {\\n                    status[cat][cat][turn] = CAT_WIN\\n                    queue.offer(Turn(cat, cat, turn))\\n                }\\n            }\\n        }\\n\\n        while(!queue.isEmpty()) {\\n            val curr = queue.poll()\\n            val statusSoFar = status[curr.mouse][curr.cat][curr.turn]\\n\\n            for (parent in parents(curr, graph)) {\\n                val statusOfParent = status[parent.mouse][parent.cat][parent.turn]\\n                if (statusOfParent != DRAW) continue\\n\\n                if ( (parent.turn == MOUSE_TURN && statusSoFar == MOUSE_WIN) \\n                  || (parent.turn == CAT_TURN   && statusSoFar == CAT_WIN) ) { \\n                    status[parent.mouse][parent.cat][parent.turn] = statusSoFar\\n                    queue.add(parent)\\n                } else if ( --indegree[parent.mouse][parent.cat][parent.turn] == 0 ) {\\n                    status[parent.mouse][parent.cat][parent.turn] = if (parent.turn == MOUSE_TURN) CAT_WIN else MOUSE_WIN\\n                    queue.add(parent)\\n                }\\n            }\\n        }\\n\\n        return status[1][2][MOUSE_TURN]\\n    } \\n\\n    fun parents(curr: Turn, graph: Array<IntArray>): List<Turn> {\\n        val result = mutableListOf<Turn>()\\n\\n        if (curr.turn == CAT_TURN) {\\n            for (mouse in graph[curr.mouse]) {\\n                result.add(Turn(mouse, curr.cat, MOUSE_TURN))\\n            }\\n        } else {\\n            for (cat in graph[curr.cat]) {\\n                if (cat == 0) continue\\n                result.add(Turn(curr.mouse, cat, CAT_TURN))\\n            }\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407915,
                "title": "dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n int catMouseGame(vector<vector<int>>& graph) {\\n    \\n// the graph can optrima cam\\nint n=graph.size();\\nint dp[100][100][525];\\nmemset( dp,-1,sizeof(dp));\\nfunction<int(int ,int,int)>f=[&](int m,int c,int moves)->int\\n{\\n   \\n// if moves >=2 then its draw\\nif(moves>graph.size()*5){\\n     dp[m][c][moves]=0;\\n    return 0;\\n}\\nif(m==c){\\n     dp[m][c][moves]=2;\\n    return 2;\\n}\\nif(m==0){\\n     dp[m][c][moves]=1;\\n    return 1;\\n}\\nif(dp[m][c][moves]!=-1){\\n    return dp[m][c][moves];\\n}\\n\\nif((moves&1)){\\n   //. explore any win is thre s\\n   bool draw=0;\\n   for(int i:graph[m]){\\n      int ans=f(i,c,moves+1);\\n      if(ans==1){\\n          dp[m][c][moves]=1;\\n          return 1;\\n      }\\n      else if(ans==0){\\n          draw=1;\\n      }\\n   }\\n   if(draw){\\n        dp[m][c][moves]=0;\\n       return 0;\\n   }\\n   else{\\n        dp[m][c][moves]=2;\\n       return 2;\\n   }\\n   \\n}\\nelse{\\n bool draw=0;\\n   for(int i:graph[c]){\\n    if(i==0){\\n        continue;\\n    }\\n     int ans=f(m,i,moves+1);\\n      if(ans==2){\\n           dp[m][c][moves]=2;\\n          return 2;\\n      }\\n     else if(ans==0){\\n          draw=1;\\n\\n      }\\n   }\\n   if(draw){\\n    dp[m][c][moves]=0;\\n        return 0;\\n   }\\n   else{\\n        dp[m][c][moves]=1;\\n        return 1;\\n   }\\n   \\n}\\nreturn dp[m][c][moves];\\n};\\nreturn f(1,2,1);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int catMouseGame(vector<vector<int>>& graph) {\\n    \\n// the graph can optrima cam\\nint n=graph.size();\\nint dp[100][100][525];\\nmemset( dp,-1,sizeof(dp));\\nfunction<int(int ,int,int)>f=[&](int m,int c,int moves)->int\\n{\\n   \\n// if moves >=2 then its draw\\nif(moves>graph.size()*5){\\n     dp[m][c][moves]=0;\\n    return 0;\\n}\\nif(m==c){\\n     dp[m][c][moves]=2;\\n    return 2;\\n}\\nif(m==0){\\n     dp[m][c][moves]=1;\\n    return 1;\\n}\\nif(dp[m][c][moves]!=-1){\\n    return dp[m][c][moves];\\n}\\n\\nif((moves&1)){\\n   //. explore any win is thre s\\n   bool draw=0;\\n   for(int i:graph[m]){\\n      int ans=f(i,c,moves+1);\\n      if(ans==1){\\n          dp[m][c][moves]=1;\\n          return 1;\\n      }\\n      else if(ans==0){\\n          draw=1;\\n      }\\n   }\\n   if(draw){\\n        dp[m][c][moves]=0;\\n       return 0;\\n   }\\n   else{\\n        dp[m][c][moves]=2;\\n       return 2;\\n   }\\n   \\n}\\nelse{\\n bool draw=0;\\n   for(int i:graph[c]){\\n    if(i==0){\\n        continue;\\n    }\\n     int ans=f(m,i,moves+1);\\n      if(ans==2){\\n           dp[m][c][moves]=2;\\n          return 2;\\n      }\\n     else if(ans==0){\\n          draw=1;\\n\\n      }\\n   }\\n   if(draw){\\n    dp[m][c][moves]=0;\\n        return 0;\\n   }\\n   else{\\n        dp[m][c][moves]=1;\\n        return 1;\\n   }\\n   \\n}\\nreturn dp[m][c][moves];\\n};\\nreturn f(1,2,1);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380213,
                "title": "python-clean-solution-with-comments-o-n-3",
                "content": "# Code\\n```\\nclass Solution:\\n    def catMouseGame(self, g: List[List[int]]) -> int:\\n        n = len(g)\\n        dq = deque()\\n        dp = defaultdict(int) # store who will win 1-mouse, 2-cat\\n        for t in [1,2]: # start from known states\\n            for k in range(n):\\n                dp[(0,k,t)] = 1\\n                dq.append((0,k,t))\\n                dp[(k,k,t)] = 2\\n                dq.append((k,k,t))\\n        nxt_sc = [[[0]*n for m in range(n)] for t in range(3)] # next state count: outdegree, number of states possible from this state\\n        for t in range(1,3):\\n            for m in range(n):\\n                for c in range(1,n):\\n                    if(t==1): nxt_sc[t][m][c] = len(g[m]);\\n                    else: nxt_sc[t][m][c] = len(g[c]) - (0 in g[c]);\\n        def parents(m,c,t): # get prev state from given state\\n            res = []\\n            for v in g[m if t==2 else c]: # opposite turn, so if current turn is cat then prev should be mouse & viceversa\\n                if(t==1 and v==0): continue \\n                if(t==1): res.append((m,v,2))\\n                if(t==2): res.append((v,c,1))\\n            return res\\n        while(dq):\\n            m,c,t = dq.popleft() # this is nxt state, of which we know the result dp\\n            r = dp[(m,c,t)]\\n            for m1,c1,t1 in parents(m,c,t): # prev state which we want to calculate\\n                if((m1,c1,t1) in dp): continue # if already calculated skip\\n                if(r==t1): # if nxt state is winning for this animate\\n                    dp[(m1,c1,t1)] = r\\n                    dq.append((m1,c1,t1))\\n                else:\\n                    nxt_sc[t1][m1][c1] -=1 # decreease the outdegree from next state to this state\\n                    if(nxt_sc[t1][m1][c1]==0): # if all next nodes are losing then no choice but to give up :(\\n                        dp[(m1,c1,t1)] = 3-t1\\n                        dq.append((m1,c1,t1))\\n                \\n                    \\n        return dp[(1,2,1)]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def catMouseGame(self, g: List[List[int]]) -> int:\\n        n = len(g)\\n        dq = deque()\\n        dp = defaultdict(int) # store who will win 1-mouse, 2-cat\\n        for t in [1,2]: # start from known states\\n            for k in range(n):\\n                dp[(0,k,t)] = 1\\n                dq.append((0,k,t))\\n                dp[(k,k,t)] = 2\\n                dq.append((k,k,t))\\n        nxt_sc = [[[0]*n for m in range(n)] for t in range(3)] # next state count: outdegree, number of states possible from this state\\n        for t in range(1,3):\\n            for m in range(n):\\n                for c in range(1,n):\\n                    if(t==1): nxt_sc[t][m][c] = len(g[m]);\\n                    else: nxt_sc[t][m][c] = len(g[c]) - (0 in g[c]);\\n        def parents(m,c,t): # get prev state from given state\\n            res = []\\n            for v in g[m if t==2 else c]: # opposite turn, so if current turn is cat then prev should be mouse & viceversa\\n                if(t==1 and v==0): continue \\n                if(t==1): res.append((m,v,2))\\n                if(t==2): res.append((v,c,1))\\n            return res\\n        while(dq):\\n            m,c,t = dq.popleft() # this is nxt state, of which we know the result dp\\n            r = dp[(m,c,t)]\\n            for m1,c1,t1 in parents(m,c,t): # prev state which we want to calculate\\n                if((m1,c1,t1) in dp): continue # if already calculated skip\\n                if(r==t1): # if nxt state is winning for this animate\\n                    dp[(m1,c1,t1)] = r\\n                    dq.append((m1,c1,t1))\\n                else:\\n                    nxt_sc[t1][m1][c1] -=1 # decreease the outdegree from next state to this state\\n                    if(nxt_sc[t1][m1][c1]==0): # if all next nodes are losing then no choice but to give up :(\\n                        dp[(m1,c1,t1)] = 3-t1\\n                        dq.append((m1,c1,t1))\\n                \\n                    \\n        return dp[(1,2,1)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254189,
                "title": "python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def catMouseGame(self, graph: List[List[int]]) -> int:\\n        def getprestates(m ,c ,t):\\n            ans = []\\n            if t == 1:\\n                for c2 in graph[c]:\\n                    if not c2: continue\\n                    ans.append((m, c2, 2))\\n            else:\\n                for m2 in graph[m]:\\n                    ans.append((m2, c, 1))\\n            return ans\\n\\n        def nextfails(m, c, t):\\n            if t == 1:\\n                for m2 in graph[m]:\\n                    if res[(m2, c, 2)] != 2: return False\\n            else:\\n                for c2 in graph[c]:\\n                    if not c2: continue\\n                    if res[(m, c2, 1)] != 1: return False\\n            \\n            return True\\n\\n        res = defaultdict(int) # mouse, cat, turns\\n        q = deque()\\n\\n        for t in range(1, 3):\\n            for i in range(1, len(graph)):\\n                #mouse wins\\n                res[(0, i, t)] = 1\\n                q.append((0, i, t))\\n\\n                #cat wins\\n                res[(i, i, t)] = 2\\n                q.append((i, i, t))\\n        \\n        while q:\\n            mouse, cat, turn = q.popleft()\\n            r = res[(mouse, cat, turn)]\\n\\n            for m, c, t in getprestates(mouse, cat, turn):\\n                r2 = res[(m, c, t)]\\n                if r2:\\n                    continue\\n                \\n                #populate prestate\\n                if r == 3 - turn:\\n                    res[(m, c, t)] = r\\n                    q.append((m, c, r))\\n                elif nextfails(m, c, t):\\n                    res[(m, c, t)] = 3 - t\\n                    q.append((m, c, t))\\n\\n\\n        return res[(1, 2, 1)]\\n\\n\\n        # @lru_cache(None)\\n        # def play(mouse, cat, moves):\\n        #     if moves > len(graph) * 2: return 0 # This is if we have a cycle\\n        #     if mouse == cat: return 2 # cat wins\\n        #     if not mouse: return 1 # mouse wins\\n\\n        #     #mouse turn\\n        #     if not moves % 2:\\n        #         can_draw = False\\n        #         for nei in graph[mouse]:\\n        #             endgame = play(nei, cat, moves + 1)\\n        #             if endgame == 1: return 1\\n        #             if not endgame: can_draw = True\\n        #         return 0 if can_draw else 2\\n\\n        #     #cat turn\\n        #     else:\\n        #         can_draw = False\\n        #         for nei in graph[cat]:\\n        #             if not nei: continue # Cat cannot go to zero node\\n        #             endgame = play(mouse, nei, moves + 1)\\n        #             if endgame == 2: return 2\\n        #             if not endgame: can_draw = True\\n        #         return 0 if can_draw else 1\\n        \\n        # return play(1, 2, 0)\\n                \\n\\n                        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def catMouseGame(self, graph: List[List[int]]) -> int:\\n        def getprestates(m ,c ,t):\\n            ans = []\\n            if t == 1:\\n                for c2 in graph[c]:\\n                    if not c2: continue\\n                    ans.append((m, c2, 2))\\n            else:\\n                for m2 in graph[m]:\\n                    ans.append((m2, c, 1))\\n            return ans\\n\\n        def nextfails(m, c, t):\\n            if t == 1:\\n                for m2 in graph[m]:\\n                    if res[(m2, c, 2)] != 2: return False\\n            else:\\n                for c2 in graph[c]:\\n                    if not c2: continue\\n                    if res[(m, c2, 1)] != 1: return False\\n            \\n            return True\\n\\n        res = defaultdict(int) # mouse, cat, turns\\n        q = deque()\\n\\n        for t in range(1, 3):\\n            for i in range(1, len(graph)):\\n                #mouse wins\\n                res[(0, i, t)] = 1\\n                q.append((0, i, t))\\n\\n                #cat wins\\n                res[(i, i, t)] = 2\\n                q.append((i, i, t))\\n        \\n        while q:\\n            mouse, cat, turn = q.popleft()\\n            r = res[(mouse, cat, turn)]\\n\\n            for m, c, t in getprestates(mouse, cat, turn):\\n                r2 = res[(m, c, t)]\\n                if r2:\\n                    continue\\n                \\n                #populate prestate\\n                if r == 3 - turn:\\n                    res[(m, c, t)] = r\\n                    q.append((m, c, r))\\n                elif nextfails(m, c, t):\\n                    res[(m, c, t)] = 3 - t\\n                    q.append((m, c, t))\\n\\n\\n        return res[(1, 2, 1)]\\n\\n\\n        # @lru_cache(None)\\n        # def play(mouse, cat, moves):\\n        #     if moves > len(graph) * 2: return 0 # This is if we have a cycle\\n        #     if mouse == cat: return 2 # cat wins\\n        #     if not mouse: return 1 # mouse wins\\n\\n        #     #mouse turn\\n        #     if not moves % 2:\\n        #         can_draw = False\\n        #         for nei in graph[mouse]:\\n        #             endgame = play(nei, cat, moves + 1)\\n        #             if endgame == 1: return 1\\n        #             if not endgame: can_draw = True\\n        #         return 0 if can_draw else 2\\n\\n        #     #cat turn\\n        #     else:\\n        #         can_draw = False\\n        #         for nei in graph[cat]:\\n        #             if not nei: continue # Cat cannot go to zero node\\n        #             endgame = play(mouse, nei, moves + 1)\\n        #             if endgame == 2: return 2\\n        #             if not endgame: can_draw = True\\n        #         return 0 if can_draw else 1\\n        \\n        # return play(1, 2, 0)\\n                \\n\\n                        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241876,
                "title": "java-easy-solution-0sec",
                "content": "# Intuition\\n![upvote.png](https://assets.leetcode.com/users/images/5c4c0cbe-e2f4-420f-ab0c-b274d9aa40b6_1677635816.5929701.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private int M;\\n    Integer memo[][][];\\n    public int catMouseGame(int[][] graph) {\\n        int n = graph.length;\\n        M = 4*n + 200; // randomly chosen max move\\n        memo = new Integer[n+1][n+1][M+1];\\n        return dp(1, 2, 0, graph);\\n    }\\n\\n    int dp(int m, int c, int moves, int[][] graph) {\\n        if(moves > M) return 0;\\n        if(c == m) return 2;\\n        if(m == 0) return 1;\\n        if(memo[m][c][moves] != null) return memo[m][c][moves];\\n        if(moves % 2 == 0){\\n            boolean draw = false;\\n            for(int nei : graph[m]) {\\n                int ans = dp(nei, c, moves+1, graph);\\n                if(ans == 1) return memo[m][c][moves] = 1;\\n                if(ans == 0)draw = true;\\n            }\\n            return memo[m][c][moves] = draw ? 0 : 2;\\n        }else {\\n            boolean draw = false;\\n            for(int nei : graph[c]) {\\n                if(nei == 0) continue;\\n                int ans = dp(m, nei, moves+1, graph);\\n                if(ans == 2) return memo[m][c][moves] = 2;\\n                if(ans == 0)draw = true;\\n            }\\n            return memo[m][c][moves] = draw ? 0 : 1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int M;\\n    Integer memo[][][];\\n    public int catMouseGame(int[][] graph) {\\n        int n = graph.length;\\n        M = 4*n + 200; // randomly chosen max move\\n        memo = new Integer[n+1][n+1][M+1];\\n        return dp(1, 2, 0, graph);\\n    }\\n\\n    int dp(int m, int c, int moves, int[][] graph) {\\n        if(moves > M) return 0;\\n        if(c == m) return 2;\\n        if(m == 0) return 1;\\n        if(memo[m][c][moves] != null) return memo[m][c][moves];\\n        if(moves % 2 == 0){\\n            boolean draw = false;\\n            for(int nei : graph[m]) {\\n                int ans = dp(nei, c, moves+1, graph);\\n                if(ans == 1) return memo[m][c][moves] = 1;\\n                if(ans == 0)draw = true;\\n            }\\n            return memo[m][c][moves] = draw ? 0 : 2;\\n        }else {\\n            boolean draw = false;\\n            for(int nei : graph[c]) {\\n                if(nei == 0) continue;\\n                int ans = dp(m, nei, moves+1, graph);\\n                if(ans == 2) return memo[m][c][moves] = 2;\\n                if(ans == 0)draw = true;\\n            }\\n            return memo[m][c][moves] = draw ? 0 : 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175630,
                "title": "simple-explained-solution",
                "content": "\\n```\\nclass Solution:\\n    def catMouseGame(self, graph: List[List[int]]) -> int:\\n        def getPreStates(m,c,t):\\n            ans = []\\n            if t == 1:\\n                for c2 in graph[c]:\\n                    if c2 == 0:continue\\n                    ans.append((m,c2,2))\\n            else:\\n                for m2 in graph[m]:\\n                    ans.append((m2,c,1))\\n            return ans\\n        \\n        def ifAllNextMovesFailed(m,c,t):\\n            if t == 1:\\n                for m2 in graph[m]:\\n                    if result[(m2,c,2)] != 2:return False\\n            else:\\n                for c2 in graph[c]:\\n                    if c2 == 0:continue\\n                    if result[(m,c2,1)] != 1:return False\\n            return True\\n        \\n        result = defaultdict(lambda:0) \\n        # key = (m,c,turn) value = (0/1/2)\\n        n = len(graph)\\n        queue = deque()\\n        \\n        for t in range(1,3):\\n            for i in range(1,n):\\n                # mouse win \\n                result[(0,i,t)] = 1\\n                queue.append((0,i,t))\\n                # cat win\\n                result[(i,i,t)] = 2\\n                queue.append((i,i,t))\\n        \\n        while queue:\\n            m,c,t = queue.popleft()\\n            r = result[(m,c,t)]\\n            for m2,c2,t2 in getPreStates(m,c,t):\\n                r2 = result[(m2,c2,t2)]\\n                if r2 > 0:continue\\n                # populate prestate\\n                if r == 3-t: # can always win\\n                    result[(m2,c2,t2)] = r\\n                    queue.append((m2,c2,t2))\\n                elif ifAllNextMovesFailed(m2,c2,t2):\\n                    result[(m2,c2,t2)] =3-t2\\n                    queue.append((m2,c2,t2))\\n        return result[(1,2,1)]\\n```",
                "solutionTags": [
                    "Python3",
                    "Ruby",
                    "Go",
                    "Scala",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution:\\n    def catMouseGame(self, graph: List[List[int]]) -> int:\\n        def getPreStates(m,c,t):\\n            ans = []\\n            if t == 1:\\n                for c2 in graph[c]:\\n                    if c2 == 0:continue\\n                    ans.append((m,c2,2))\\n            else:\\n                for m2 in graph[m]:\\n                    ans.append((m2,c,1))\\n            return ans\\n        \\n        def ifAllNextMovesFailed(m,c,t):\\n            if t == 1:\\n                for m2 in graph[m]:\\n                    if result[(m2,c,2)] != 2:return False\\n            else:\\n                for c2 in graph[c]:\\n                    if c2 == 0:continue\\n                    if result[(m,c2,1)] != 1:return False\\n            return True\\n        \\n        result = defaultdict(lambda:0) \\n        # key = (m,c,turn) value = (0/1/2)\\n        n = len(graph)\\n        queue = deque()\\n        \\n        for t in range(1,3):\\n            for i in range(1,n):\\n                # mouse win \\n                result[(0,i,t)] = 1\\n                queue.append((0,i,t))\\n                # cat win\\n                result[(i,i,t)] = 2\\n                queue.append((i,i,t))\\n        \\n        while queue:\\n            m,c,t = queue.popleft()\\n            r = result[(m,c,t)]\\n            for m2,c2,t2 in getPreStates(m,c,t):\\n                r2 = result[(m2,c2,t2)]\\n                if r2 > 0:continue\\n                # populate prestate\\n                if r == 3-t: # can always win\\n                    result[(m2,c2,t2)] = r\\n                    queue.append((m2,c2,t2))\\n                elif ifAllNextMovesFailed(m2,c2,t2):\\n                    result[(m2,c2,t2)] =3-t2\\n                    queue.append((m2,c2,t2))\\n        return result[(1,2,1)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108176,
                "title": "913-cat-and-mouse",
                "content": "# Solution\\n\\n## Thoughts and Algorithm\\n\\nIn the Cat and Mouse game, each state is determined by three factors, which are the Mouse\\'s position, the Cat\\'s position and the player to move. According to the rules of the game, the results of the edge states can be determined are as follows.\\n\\n- When the Cat and the Mouse are at the same position, the Cat wins. Such a state is the Cat\\'s win state and the Mouse\\'s lose state.\\n\\n- When the Mouse is at the hole, the Mouse wins. Such a state is the Mouse\\'s win state and the Cat\\'s lose state.\\n\\nSince the Cat is not allowed to travel to the hole, it is impossible that both players win simultaneously.\\n\\nTo get the result of the initial state, we need to traversal all possible states starting from edge states. Each state contains the Mouse\\'s position, the Cat\\'s position and the player to move. The previous turn\\'s all possible states can be obtained from the current state, where the previous turn\\'s player to move is opposite to the current state\\'s player to move, and the previous turn\\'s player to move has a different position as the current position. Use `(mouse, cat, turn)` to represent the current state and use `(prevMouse, prevCat, prevTurn)` to represent a possible state of the previous turn. The possible states of the previous turn are as follows.\\n\\n- If `turn` is Mouse, then `prevTurn` is Cat, `prevMouse = mouse`, and `prevCat` can be any node in `graph[cat]` except node 0.\\n\\n- If `turn` is Cat, then `prevTurn` is Mouse, `prevMouse` can be any node in `graph[mouse]`, and `prevCat = cat`.\\n\\nInitially, only the edge states\\' results are known, and all other states\\' results are unknown. Start from edge states to explore the results of the unknown states. For each current state that the result is known, get all possible states of the previous turn and update the results. Use `state` and `prevState` to represent the current state and the state in the previous turn respectively. If the result of `prevState` is known, then the result of `prevState` is updated as follows.\\n\\n1. If the player to move of `prevState` is the same as the winner of `state`, then the player to move of `prevState` can move to `state` and win the game, so `prevState` is the win state of the player to move of `preState`. Update the result of `prevState` to be the winner of `state`.\\n\\n2. If the player to move of `prevState` is different from the winner of `state` and all the states that can be reached from `prevState` are the lose state of the player to move of `prevState`, then `prevState` is the lose state of the player to move of `prevState`. Update the result of `prevState` to be the winner of `state`.\\n\\nFor the second situation, we need to record the degrees of each state. Initially, each state\\'s degree equals the number of nodes that the player to move of the state can reach.\\n\\nDuring the traversal, when the second situation is met, decrease the degree of `prevState` by 1. If the degree of `prevState` is decreased to 0, then the player to move of `prevState` can only move to one of the lose states, so `prevState` is the lose state of the player to move of `prevState`.\\n\\nOnce the result of `prevState` is known, we can continue exploring other states from `prevState`. When no more states\\' results can be determined, the traversal ends, and the result of the initial state can be obtained.\\n\\nThe traversal process is topological sort.\\n\\nWhen the traversal ends, all the states that the results are known are the win states or the lose states of one of the players, according to the optimal strategy. For any state that the result is unknown, the player to move can\\'t move to a win state but can move to another unknown state, or the result is contradictary to the updates in traversal. Therefore, any state that the result is unknown corresponds to a result of draw.\\n\\n## Code\\n\\nThe Java code is as follows.\\n\\n```\\nclass Solution {\\n    public static final int HOLE = 0, MOUSE_START = 1, CAT_START = 2;\\n    public static final int MOUSE_TURN = 0, CAT_TURN = 1;\\n    public static final int MOUSE_WIN = 1, CAT_WIN = 2, UNKNOWN = 0;\\n    private int n;\\n    private int[][] graph;\\n    private int[][][] degrees;\\n    private int[][][] results;\\n\\n    public int CatMouseGame(int[][] graph) {\\n        this.n = graph.length;\\n        this.graph = graph;\\n        this.degrees = new int[n][n][2];\\n        this.results = new int[n][n][2];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 1; j < n; j++) {\\n                degrees[i][j][MOUSE_TURN] = graph[i].length;\\n                degrees[i][j][CAT_TURN] = graph[j].length;\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j : graph[HOLE]) {\\n                degrees[i][j][CAT_TURN]--;\\n            }\\n        }\\n        Queue<int[]> queue = new ArrayDeque<int[]>();\\n        for (int i = 1; i < n; i++) {\\n            results[i][i][MOUSE_TURN] = CAT_WIN;\\n            results[i][i][CAT_TURN] = CAT_WIN;\\n            queue.offer(new int[]{i, i, MOUSE_TURN});\\n            queue.offer(new int[]{i, i, CAT_TURN});\\n        }\\n        for (int j = 1; j < n; j++) {\\n            results[0][j][MOUSE_TURN] = MOUSE_WIN;\\n            results[0][j][CAT_TURN] = MOUSE_WIN;\\n            queue.offer(new int[]{0, j, MOUSE_TURN});\\n            queue.offer(new int[]{0, j, CAT_TURN});\\n        }\\n        while (!queue.isEmpty()) {\\n            int[] state = queue.poll();\\n            int Mouse = state[0], Cat = state[1], turn = state[2];\\n            int result = results[Mouse][Cat][turn];\\n            List<int[]> prevStates = getPrevStates(Mouse, Cat, turn);\\n            for (int[] prevState : prevStates) {\\n                int prevMouse = prevState[0], prevCat = prevState[1], prevTurn = prevState[2];\\n                if (results[prevMouse][prevCat][prevTurn] == UNKNOWN) {\\n                    boolean winState = (result == MOUSE_WIN && prevTurn == MOUSE_TURN) || (result == CAT_WIN && prevTurn == CAT_TURN);\\n                    if (winState) {\\n                        results[prevMouse][prevCat][prevTurn] = result;\\n                        queue.offer(new int[]{prevMouse, prevCat, prevTurn});\\n                    } else {\\n                        degrees[prevMouse][prevCat][prevTurn]--;\\n                        if (degrees[prevMouse][prevCat][prevTurn] == 0) {\\n                            results[prevMouse][prevCat][prevTurn] = result;\\n                            queue.offer(new int[]{prevMouse, prevCat, prevTurn});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return results[MOUSE_START][CAT_START][MOUSE_TURN];\\n    }\\n\\n    private List<int[]> getPrevStates(int Mouse, int Cat, int turn) {\\n        List<int[]> prevStates = new ArrayList<int[]>();\\n        int prevTurn = turn == MOUSE_TURN ? CAT_TURN : MOUSE_TURN;\\n        if (prevTurn == CAT_TURN) {\\n            for (int prevCat : graph[Cat]) {\\n                if (prevCat != HOLE) {\\n                    prevStates.add(new int[]{Mouse, prevCat, prevTurn});\\n                }\\n            }\\n        } else {\\n            for (int prevMouse : graph[Mouse]) {\\n                prevStates.add(new int[]{prevMouse, Cat, prevTurn});\\n            }\\n        }\\n        return prevStates;\\n    }\\n}\\n```\\n\\nThe C# code is as follows.\\n\\n```\\npublic class Solution {\\n    public const int HOLE = 0, MOUSE_START = 1, CAT_START = 2;\\n    public const int MOUSE_TURN = 0, CAT_TURN = 1;\\n    public const int MOUSE_WIN = 1, CAT_WIN = 2, UNKNOWN = 0;\\n    private int n;\\n    private int[][] graph;\\n    private int[][][] degrees;\\n    private int[][][] results;\\n\\n    public int CatMouseGame(int[][] graph) {\\n        this.n = graph.Length;\\n        this.graph = graph;\\n        this.degrees = new int[n][][];\\n        this.results = new int[n][][];\\n        for (int i = 0; i < n; i++) {\\n            degrees[i] = new int[n][];\\n            results[i] = new int[n][];\\n            for (int j = 0; j < n; j++) {\\n                degrees[i][j] = new int[2];\\n                results[i][j] = new int[2];\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 1; j < n; j++) {\\n                degrees[i][j][MOUSE_TURN] = graph[i].Length;\\n                degrees[i][j][CAT_TURN] = graph[j].Length;\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            foreach (int j in graph[HOLE]) {\\n                degrees[i][j][CAT_TURN]--;\\n            }\\n        }\\n        Queue<Tuple<int, int, int>> queue = new Queue<Tuple<int, int, int>>();\\n        for (int i = 1; i < n; i++) {\\n            results[i][i][MOUSE_TURN] = CAT_WIN;\\n            results[i][i][CAT_TURN] = CAT_WIN;\\n            queue.Enqueue(new Tuple<int, int, int>(i, i, MOUSE_TURN));\\n            queue.Enqueue(new Tuple<int, int, int>(i, i, CAT_TURN));\\n        }\\n        for (int j = 1; j < n; j++) {\\n            results[0][j][MOUSE_TURN] = MOUSE_WIN;\\n            results[0][j][CAT_TURN] = MOUSE_WIN;\\n            queue.Enqueue(new Tuple<int, int, int>(0, j, MOUSE_TURN));\\n            queue.Enqueue(new Tuple<int, int, int>(0, j, CAT_TURN));\\n        }\\n        while (queue.Count > 0) {\\n            Tuple<int, int, int> state = queue.Dequeue();\\n            int Mouse = state.Item1, Cat = state.Item2, turn = state.Item3;\\n            int result = results[Mouse][Cat][turn];\\n            IList<Tuple<int, int, int>> prevStates = GetPrevStates(Mouse, Cat, turn);\\n            foreach (Tuple<int, int, int> prevState in prevStates) {\\n                int prevMouse = prevState.Item1, prevCat = prevState.Item2, prevTurn = prevState.Item3;\\n                if (results[prevMouse][prevCat][prevTurn] == UNKNOWN) {\\n                    bool winState = (result == MOUSE_WIN && prevTurn == MOUSE_TURN) || (result == CAT_WIN && prevTurn == CAT_TURN);\\n                    if (winState) {\\n                        results[prevMouse][prevCat][prevTurn] = result;\\n                        queue.Enqueue(new Tuple<int, int, int>(prevMouse, prevCat, prevTurn));\\n                    } else {\\n                        degrees[prevMouse][prevCat][prevTurn]--;\\n                        if (degrees[prevMouse][prevCat][prevTurn] == 0) {\\n                            results[prevMouse][prevCat][prevTurn] = result;\\n                            queue.Enqueue(new Tuple<int, int, int>(prevMouse, prevCat, prevTurn));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return results[MOUSE_START][CAT_START][MOUSE_TURN];\\n    }\\n\\n    private IList<Tuple<int, int, int>> GetPrevStates(int Mouse, int Cat, int turn) {\\n        IList<Tuple<int, int, int>> prevStates = new List<Tuple<int, int, int>>();\\n        int prevTurn = turn == MOUSE_TURN ? CAT_TURN : MOUSE_TURN;\\n        if (prevTurn == CAT_TURN) {\\n            foreach (int prevCat in graph[Cat]) {\\n                if (prevCat != HOLE) {\\n                    prevStates.Add(new Tuple<int, int, int>(Mouse, prevCat, prevTurn));\\n                }\\n            }\\n        } else {\\n            foreach (int prevMouse in graph[Mouse]) {\\n                prevStates.Add(new Tuple<int, int, int>(prevMouse, Cat, prevTurn));\\n            }\\n        }\\n        return prevStates;\\n    }\\n}\\n```\\n\\n## Complexity Analysis\\n\\n- Time Complexity: O(n<sup>3</sup>), where `n` is the number of nodes in the graph. The number of states is O(n<sup>2</sup>) and it takes O(n) time to calculate the result of each state, so the time complexity is O(n<sup>3</sup>).\\n\\n- Space Complexity: O(n<sup>2</sup>), where `n` is the number of nodes in the graph. We need to store all states\\' degrees and results, and the number of states is O(n<sup>2</sup>).",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public static final int HOLE = 0, MOUSE_START = 1, CAT_START = 2;\\n    public static final int MOUSE_TURN = 0, CAT_TURN = 1;\\n    public static final int MOUSE_WIN = 1, CAT_WIN = 2, UNKNOWN = 0;\\n    private int n;\\n    private int[][] graph;\\n    private int[][][] degrees;\\n    private int[][][] results;\\n\\n    public int CatMouseGame(int[][] graph) {\\n        this.n = graph.length;\\n        this.graph = graph;\\n        this.degrees = new int[n][n][2];\\n        this.results = new int[n][n][2];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 1; j < n; j++) {\\n                degrees[i][j][MOUSE_TURN] = graph[i].length;\\n                degrees[i][j][CAT_TURN] = graph[j].length;\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j : graph[HOLE]) {\\n                degrees[i][j][CAT_TURN]--;\\n            }\\n        }\\n        Queue<int[]> queue = new ArrayDeque<int[]>();\\n        for (int i = 1; i < n; i++) {\\n            results[i][i][MOUSE_TURN] = CAT_WIN;\\n            results[i][i][CAT_TURN] = CAT_WIN;\\n            queue.offer(new int[]{i, i, MOUSE_TURN});\\n            queue.offer(new int[]{i, i, CAT_TURN});\\n        }\\n        for (int j = 1; j < n; j++) {\\n            results[0][j][MOUSE_TURN] = MOUSE_WIN;\\n            results[0][j][CAT_TURN] = MOUSE_WIN;\\n            queue.offer(new int[]{0, j, MOUSE_TURN});\\n            queue.offer(new int[]{0, j, CAT_TURN});\\n        }\\n        while (!queue.isEmpty()) {\\n            int[] state = queue.poll();\\n            int Mouse = state[0], Cat = state[1], turn = state[2];\\n            int result = results[Mouse][Cat][turn];\\n            List<int[]> prevStates = getPrevStates(Mouse, Cat, turn);\\n            for (int[] prevState : prevStates) {\\n                int prevMouse = prevState[0], prevCat = prevState[1], prevTurn = prevState[2];\\n                if (results[prevMouse][prevCat][prevTurn] == UNKNOWN) {\\n                    boolean winState = (result == MOUSE_WIN && prevTurn == MOUSE_TURN) || (result == CAT_WIN && prevTurn == CAT_TURN);\\n                    if (winState) {\\n                        results[prevMouse][prevCat][prevTurn] = result;\\n                        queue.offer(new int[]{prevMouse, prevCat, prevTurn});\\n                    } else {\\n                        degrees[prevMouse][prevCat][prevTurn]--;\\n                        if (degrees[prevMouse][prevCat][prevTurn] == 0) {\\n                            results[prevMouse][prevCat][prevTurn] = result;\\n                            queue.offer(new int[]{prevMouse, prevCat, prevTurn});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return results[MOUSE_START][CAT_START][MOUSE_TURN];\\n    }\\n\\n    private List<int[]> getPrevStates(int Mouse, int Cat, int turn) {\\n        List<int[]> prevStates = new ArrayList<int[]>();\\n        int prevTurn = turn == MOUSE_TURN ? CAT_TURN : MOUSE_TURN;\\n        if (prevTurn == CAT_TURN) {\\n            for (int prevCat : graph[Cat]) {\\n                if (prevCat != HOLE) {\\n                    prevStates.add(new int[]{Mouse, prevCat, prevTurn});\\n                }\\n            }\\n        } else {\\n            for (int prevMouse : graph[Mouse]) {\\n                prevStates.add(new int[]{prevMouse, Cat, prevTurn});\\n            }\\n        }\\n        return prevStates;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public const int HOLE = 0, MOUSE_START = 1, CAT_START = 2;\\n    public const int MOUSE_TURN = 0, CAT_TURN = 1;\\n    public const int MOUSE_WIN = 1, CAT_WIN = 2, UNKNOWN = 0;\\n    private int n;\\n    private int[][] graph;\\n    private int[][][] degrees;\\n    private int[][][] results;\\n\\n    public int CatMouseGame(int[][] graph) {\\n        this.n = graph.Length;\\n        this.graph = graph;\\n        this.degrees = new int[n][][];\\n        this.results = new int[n][][];\\n        for (int i = 0; i < n; i++) {\\n            degrees[i] = new int[n][];\\n            results[i] = new int[n][];\\n            for (int j = 0; j < n; j++) {\\n                degrees[i][j] = new int[2];\\n                results[i][j] = new int[2];\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 1; j < n; j++) {\\n                degrees[i][j][MOUSE_TURN] = graph[i].Length;\\n                degrees[i][j][CAT_TURN] = graph[j].Length;\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            foreach (int j in graph[HOLE]) {\\n                degrees[i][j][CAT_TURN]--;\\n            }\\n        }\\n        Queue<Tuple<int, int, int>> queue = new Queue<Tuple<int, int, int>>();\\n        for (int i = 1; i < n; i++) {\\n            results[i][i][MOUSE_TURN] = CAT_WIN;\\n            results[i][i][CAT_TURN] = CAT_WIN;\\n            queue.Enqueue(new Tuple<int, int, int>(i, i, MOUSE_TURN));\\n            queue.Enqueue(new Tuple<int, int, int>(i, i, CAT_TURN));\\n        }\\n        for (int j = 1; j < n; j++) {\\n            results[0][j][MOUSE_TURN] = MOUSE_WIN;\\n            results[0][j][CAT_TURN] = MOUSE_WIN;\\n            queue.Enqueue(new Tuple<int, int, int>(0, j, MOUSE_TURN));\\n            queue.Enqueue(new Tuple<int, int, int>(0, j, CAT_TURN));\\n        }\\n        while (queue.Count > 0) {\\n            Tuple<int, int, int> state = queue.Dequeue();\\n            int Mouse = state.Item1, Cat = state.Item2, turn = state.Item3;\\n            int result = results[Mouse][Cat][turn];\\n            IList<Tuple<int, int, int>> prevStates = GetPrevStates(Mouse, Cat, turn);\\n            foreach (Tuple<int, int, int> prevState in prevStates) {\\n                int prevMouse = prevState.Item1, prevCat = prevState.Item2, prevTurn = prevState.Item3;\\n                if (results[prevMouse][prevCat][prevTurn] == UNKNOWN) {\\n                    bool winState = (result == MOUSE_WIN && prevTurn == MOUSE_TURN) || (result == CAT_WIN && prevTurn == CAT_TURN);\\n                    if (winState) {\\n                        results[prevMouse][prevCat][prevTurn] = result;\\n                        queue.Enqueue(new Tuple<int, int, int>(prevMouse, prevCat, prevTurn));\\n                    } else {\\n                        degrees[prevMouse][prevCat][prevTurn]--;\\n                        if (degrees[prevMouse][prevCat][prevTurn] == 0) {\\n                            results[prevMouse][prevCat][prevTurn] = result;\\n                            queue.Enqueue(new Tuple<int, int, int>(prevMouse, prevCat, prevTurn));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return results[MOUSE_START][CAT_START][MOUSE_TURN];\\n    }\\n\\n    private IList<Tuple<int, int, int>> GetPrevStates(int Mouse, int Cat, int turn) {\\n        IList<Tuple<int, int, int>> prevStates = new List<Tuple<int, int, int>>();\\n        int prevTurn = turn == MOUSE_TURN ? CAT_TURN : MOUSE_TURN;\\n        if (prevTurn == CAT_TURN) {\\n            foreach (int prevCat in graph[Cat]) {\\n                if (prevCat != HOLE) {\\n                    prevStates.Add(new Tuple<int, int, int>(Mouse, prevCat, prevTurn));\\n                }\\n            }\\n        } else {\\n            foreach (int prevMouse in graph[Mouse]) {\\n                prevStates.Add(new Tuple<int, int, int>(prevMouse, Cat, prevTurn));\\n            }\\n        }\\n        return prevStates;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991372,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn cat_mouse_game(graph: Vec<Vec<i32>>) -> i32 {\\n        use std::collections::VecDeque;\\n        let len = graph.len();\\n        let mut dp = vec![vec![vec![0; len]; len]; 2];\\n        let mut outdegree = vec![vec![vec![0; len]; len]; 2];\\n        let mut q = VecDeque::new();\\n\\n        for j in 0..len {\\n            dp[0][0][j] = 1; dp[1][0][j] = 1;\\n            q.push_back((0, 0, j));\\n            q.push_back((1, 0, j));\\n        }\\n        for j in 1..len {\\n            dp[0][j][j] = 2; dp[1][j][j] = 2;\\n            q.push_back((0, j, j));\\n            q.push_back((1, j, j));\\n        }\\n        for i in 0..len {\\n            for j in 1..len {\\n                outdegree[0][i][j] = graph[i].len() as i32;\\n                outdegree[1][i][j] = graph[j].len() as i32;\\n            }\\n        }\\n        for &v in &graph[0] {\\n            for i in 0..len {\\n                outdegree[1][i][v as usize] -= 1;\\n            }\\n        }\\n        while let Some((turn, mouse, cat)) = q.pop_front() {\\n            if turn == 0 && mouse == 1 && cat == 2 {\\n                break;\\n            }\\n            if turn == 0 {\\n                for &v in &graph[cat] {\\n                    let v = v as usize;\\n                    if v == 0 {\\n                        continue;\\n                    }\\n                    if dp[1][mouse][v] > 0 {\\n                        continue;\\n                    }\\n                    if dp[turn][mouse][cat] == 2 {\\n                        dp[1][mouse][v] = 2;\\n                        q.push_back((1, mouse, v));\\n                        continue;\\n                    }\\n                    outdegree[1][mouse][v] -= 1;\\n                    if outdegree[1][mouse][v] == 0 {\\n                        dp[1][mouse][v] = 1;\\n                        q.push_back((1, mouse, v));\\n                    }\\n                }\\n            } else {\\n                for &v in &graph[mouse] {\\n                    let v = v as usize;\\n                    if dp[0][v][cat] > 0 {\\n                        continue;\\n                    }\\n                    if dp[turn][mouse][cat] == 1 {\\n                        dp[0][v][cat] = 1;\\n                        q.push_back((0, v, cat));\\n                        continue;\\n                    }\\n                    outdegree[0][v][cat] -= 1;\\n                    if outdegree[0][v][cat] == 0 {\\n                        dp[0][v][cat] = 2;\\n                        q.push_back((0, v, cat));\\n                    }\\n                }\\n            }\\n        }\\n        dp[0][1][2]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn cat_mouse_game(graph: Vec<Vec<i32>>) -> i32 {\\n        use std::collections::VecDeque;\\n        let len = graph.len();\\n        let mut dp = vec![vec![vec![0; len]; len]; 2];\\n        let mut outdegree = vec![vec![vec![0; len]; len]; 2];\\n        let mut q = VecDeque::new();\\n\\n        for j in 0..len {\\n            dp[0][0][j] = 1; dp[1][0][j] = 1;\\n            q.push_back((0, 0, j));\\n            q.push_back((1, 0, j));\\n        }\\n        for j in 1..len {\\n            dp[0][j][j] = 2; dp[1][j][j] = 2;\\n            q.push_back((0, j, j));\\n            q.push_back((1, j, j));\\n        }\\n        for i in 0..len {\\n            for j in 1..len {\\n                outdegree[0][i][j] = graph[i].len() as i32;\\n                outdegree[1][i][j] = graph[j].len() as i32;\\n            }\\n        }\\n        for &v in &graph[0] {\\n            for i in 0..len {\\n                outdegree[1][i][v as usize] -= 1;\\n            }\\n        }\\n        while let Some((turn, mouse, cat)) = q.pop_front() {\\n            if turn == 0 && mouse == 1 && cat == 2 {\\n                break;\\n            }\\n            if turn == 0 {\\n                for &v in &graph[cat] {\\n                    let v = v as usize;\\n                    if v == 0 {\\n                        continue;\\n                    }\\n                    if dp[1][mouse][v] > 0 {\\n                        continue;\\n                    }\\n                    if dp[turn][mouse][cat] == 2 {\\n                        dp[1][mouse][v] = 2;\\n                        q.push_back((1, mouse, v));\\n                        continue;\\n                    }\\n                    outdegree[1][mouse][v] -= 1;\\n                    if outdegree[1][mouse][v] == 0 {\\n                        dp[1][mouse][v] = 1;\\n                        q.push_back((1, mouse, v));\\n                    }\\n                }\\n            } else {\\n                for &v in &graph[mouse] {\\n                    let v = v as usize;\\n                    if dp[0][v][cat] > 0 {\\n                        continue;\\n                    }\\n                    if dp[turn][mouse][cat] == 1 {\\n                        dp[0][v][cat] = 1;\\n                        q.push_back((0, v, cat));\\n                        continue;\\n                    }\\n                    outdegree[0][v][cat] -= 1;\\n                    if outdegree[0][v][cat] == 0 {\\n                        dp[0][v][cat] = 2;\\n                        q.push_back((0, v, cat));\\n                    }\\n                }\\n            }\\n        }\\n        dp[0][1][2]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2981573,
                "title": "simple-dfs-with-bit-operations-100-faster",
                "content": "# Intuition\\nSimple dfs with bit operations, 100% faster \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(e*n), where e = number of edges in the graph, n = number of nodes\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(n*n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint catMouseGame(vector<vector<int>> &graph) {\\n  int n = graph.size();\\n  vector<vector<vector<unsigned int>>> status(\\n      2, vector<vector<unsigned int>>(n, vector<unsigned int>(n)));\\n\\n  function<void(int, int, int)> visit = [&](int i, int j, int k) {\\n    if (status[0][1][2] & 3)\\n      return;\\n    auto& edges = graph[i ? j : k];\\n    for (int q : edges) {\\n      int i1 = (i + 1) & 1, j1 = i ? q : j, k1 = i ? k : q,\\n          s = status[i][j][k] & 3;\\n      unsigned int &s1 = status[i1][j1][k1];\\n      if ((s1 & 3) == 0 && (s == 2 - i || s == i + 1 && (s1 -= 4) < 4)) {\\n        s1 = s;\\n        visit(i1, j1, k1);\\n      }\\n    }\\n  };\\n\\n  for (int i = 1; i < n; i++) {\\n    status[0][i][i] = status[1][i][i] = 2;\\n    status[1][0][i] = status[0][i][0] = 1;\\n\\n    for (int j = 1; j < n; j++) {\\n      status[0][i][j] += graph[i].size() * 4;\\n      status[1][i][j] += graph[j].size() * 4;\\n    }\\n  }\\n\\n  for (int i = 1; i < n; i++) {\\n    visit(0, i, i);\\n    visit(1, i, i);\\n    visit(1, 0, i);\\n    visit(0, i, 0);\\n  }\\n  int res = status[0][1][2] & 3;\\n  return res;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint catMouseGame(vector<vector<int>> &graph) {\\n  int n = graph.size();\\n  vector<vector<vector<unsigned int>>> status(\\n      2, vector<vector<unsigned int>>(n, vector<unsigned int>(n)));\\n\\n  function<void(int, int, int)> visit = [&](int i, int j, int k) {\\n    if (status[0][1][2] & 3)\\n      return;\\n    auto& edges = graph[i ? j : k];\\n    for (int q : edges) {\\n      int i1 = (i + 1) & 1, j1 = i ? q : j, k1 = i ? k : q,\\n          s = status[i][j][k] & 3;\\n      unsigned int &s1 = status[i1][j1][k1];\\n      if ((s1 & 3) == 0 && (s == 2 - i || s == i + 1 && (s1 -= 4) < 4)) {\\n        s1 = s;\\n        visit(i1, j1, k1);\\n      }\\n    }\\n  };\\n\\n  for (int i = 1; i < n; i++) {\\n    status[0][i][i] = status[1][i][i] = 2;\\n    status[1][0][i] = status[0][i][0] = 1;\\n\\n    for (int j = 1; j < n; j++) {\\n      status[0][i][j] += graph[i].size() * 4;\\n      status[1][i][j] += graph[j].size() * 4;\\n    }\\n  }\\n\\n  for (int i = 1; i < n; i++) {\\n    visit(0, i, i);\\n    visit(1, i, i);\\n    visit(1, 0, i);\\n    visit(0, i, 0);\\n  }\\n  int res = status[0][1][2] & 3;\\n  return res;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2881052,
                "title": "reverse-dfs-without-memoization-correct-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        // this is a games in graph kinda problem\\n        // we can solve this problem using BFS/DFS on the state space\\n        // we have to do reverse BFS/DFS from the states for which we know the answer already\\n\\n        // turn\\n        const int CAT_TURN = 2;\\n        const int MOUSE_TURN = 1;\\n        \\n        // colors (or) the result of a state\\n        const int DRAW = 0;\\n        const int CAT = 2;\\n        const int MOUSE = 1;\\n\\n        int n = graph.size();\\n\\n        // the color or the result of a state (or node in the state space)\\n        int color[n][n][3];\\n        // all the states initially have the color DRAW\\n        memset(color, DRAW, sizeof color);\\n\\n        // the states for which we already know the result\\n        vector<vector<int>> final_states;\\n\\n        // find the states for which we already know the answer\\n        for(int i=1; i<n; i++) {\\n            for(int turn : {CAT_TURN, MOUSE_TURN}) {\\n                final_states.push_back({0, i, turn});\\n                color[0][i][turn] = MOUSE;\\n\\n                final_states.push_back({i, i, turn});\\n                color[i][i][turn] = CAT;\\n            }\\n        }\\n\\n        // find the degree of each state\\n        int degree[n][n][3];\\n        memset(degree, 0, sizeof degree);\\n\\n        for(int i=0; i<n; i++) {\\n            for(int j=1; j<n; j++) {\\n                degree[i][j][MOUSE_TURN] = graph[i].size();\\n                degree[i][j][CAT_TURN] = graph[j].size() - (find(graph[j].begin(), graph[j].end(), 0) != graph[j].end());\\n            }\\n        }\\n\\n        // function for finding the parent states of a given state\\n        function<vector<vector<int>>(vector<int>&)> parent_states = [&](vector<int>& state) {\\n            int i=state[0], j=state[1], t=state[2];\\n            vector<vector<int>> states;\\n\\n            if(t == MOUSE_TURN) {\\n                for(int k : graph[j]) {\\n                    if(k != 0)\\n                        states.push_back({i, k, CAT_TURN});\\n                }\\n            }\\n            else {\\n                for(int k : graph[i]) {\\n                    states.push_back({k, j, MOUSE_TURN});\\n                }\\n            }\\n\\n            return states;\\n        };\\n\\n        // function for doing reverse DFS from the given state\\n        function<void(vector<int>&)> solve = [&](vector<int>& curr_state) {\\n            int i=curr_state[0], j=curr_state[1], t=curr_state[2];\\n            int c = color[i][j][t];\\n\\n            // go through the parent states of the current state\\n            for(vector<int>& parent_state : parent_states(curr_state)) {\\n                int ip=parent_state[0], jp=parent_state[1], tp=parent_state[2];\\n                int cp = color[ip][jp][tp];\\n\\n                // if the parent node hasn\\'t been colored yet (or the result is still undefined, i.e DRAW)\\n                if(cp == DRAW) {\\n                    // if parent state\\'s turn is same as color of current state\\n                    if(tp == c) {\\n                        color[ip][jp][tp] = c;\\n                        // do reverse from this node now\\n                        solve(parent_state);\\n                    }\\n                    else {\\n                        // decrement the degree of the parent state\\n                        degree[ip][jp][tp]--;\\n\\n                        if(degree[ip][jp][tp] == 0) {\\n                            // color the parent node with same color as current state\\n                            // as there in no way for the current node to win\\n                            color[ip][jp][tp] = c;\\n                            // do reverse DFS from the parent node now\\n                            solve(parent_state);\\n                        }\\n                    }\\n                }\\n            }\\n        }; \\n\\n        for(vector<int>& state : final_states) {\\n            solve(state);\\n        }\\n\\n        return color[1][2][MOUSE_TURN];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        // this is a games in graph kinda problem\\n        // we can solve this problem using BFS/DFS on the state space\\n        // we have to do reverse BFS/DFS from the states for which we know the answer already\\n\\n        // turn\\n        const int CAT_TURN = 2;\\n        const int MOUSE_TURN = 1;\\n        \\n        // colors (or) the result of a state\\n        const int DRAW = 0;\\n        const int CAT = 2;\\n        const int MOUSE = 1;\\n\\n        int n = graph.size();\\n\\n        // the color or the result of a state (or node in the state space)\\n        int color[n][n][3];\\n        // all the states initially have the color DRAW\\n        memset(color, DRAW, sizeof color);\\n\\n        // the states for which we already know the result\\n        vector<vector<int>> final_states;\\n\\n        // find the states for which we already know the answer\\n        for(int i=1; i<n; i++) {\\n            for(int turn : {CAT_TURN, MOUSE_TURN}) {\\n                final_states.push_back({0, i, turn});\\n                color[0][i][turn] = MOUSE;\\n\\n                final_states.push_back({i, i, turn});\\n                color[i][i][turn] = CAT;\\n            }\\n        }\\n\\n        // find the degree of each state\\n        int degree[n][n][3];\\n        memset(degree, 0, sizeof degree);\\n\\n        for(int i=0; i<n; i++) {\\n            for(int j=1; j<n; j++) {\\n                degree[i][j][MOUSE_TURN] = graph[i].size();\\n                degree[i][j][CAT_TURN] = graph[j].size() - (find(graph[j].begin(), graph[j].end(), 0) != graph[j].end());\\n            }\\n        }\\n\\n        // function for finding the parent states of a given state\\n        function<vector<vector<int>>(vector<int>&)> parent_states = [&](vector<int>& state) {\\n            int i=state[0], j=state[1], t=state[2];\\n            vector<vector<int>> states;\\n\\n            if(t == MOUSE_TURN) {\\n                for(int k : graph[j]) {\\n                    if(k != 0)\\n                        states.push_back({i, k, CAT_TURN});\\n                }\\n            }\\n            else {\\n                for(int k : graph[i]) {\\n                    states.push_back({k, j, MOUSE_TURN});\\n                }\\n            }\\n\\n            return states;\\n        };\\n\\n        // function for doing reverse DFS from the given state\\n        function<void(vector<int>&)> solve = [&](vector<int>& curr_state) {\\n            int i=curr_state[0], j=curr_state[1], t=curr_state[2];\\n            int c = color[i][j][t];\\n\\n            // go through the parent states of the current state\\n            for(vector<int>& parent_state : parent_states(curr_state)) {\\n                int ip=parent_state[0], jp=parent_state[1], tp=parent_state[2];\\n                int cp = color[ip][jp][tp];\\n\\n                // if the parent node hasn\\'t been colored yet (or the result is still undefined, i.e DRAW)\\n                if(cp == DRAW) {\\n                    // if parent state\\'s turn is same as color of current state\\n                    if(tp == c) {\\n                        color[ip][jp][tp] = c;\\n                        // do reverse from this node now\\n                        solve(parent_state);\\n                    }\\n                    else {\\n                        // decrement the degree of the parent state\\n                        degree[ip][jp][tp]--;\\n\\n                        if(degree[ip][jp][tp] == 0) {\\n                            // color the parent node with same color as current state\\n                            // as there in no way for the current node to win\\n                            color[ip][jp][tp] = c;\\n                            // do reverse DFS from the parent node now\\n                            solve(parent_state);\\n                        }\\n                    }\\n                }\\n            }\\n        }; \\n\\n        for(vector<int>& state : final_states) {\\n            solve(state);\\n        }\\n\\n        return color[1][2][MOUSE_TURN];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2786516,
                "title": "minimax-bfs",
                "content": "# Intuition\\n\\nThe current state of the game can be described by the tuple `(mouseLocation, catLocation, who)` where `who` is whose turn it is (either the cat or mouse). I\\'ll abbreviate these as `(mi, ci, who)` as in \"mouse index\" and \"cat index\".\\n\\nThere are four possible outcomes for a given state of the game:\\n\\n1. State is invalid (cat in position 0 or mouse\\'s turn while in position 0)\\n2. The outcome is uncertain\\n3. The cat is guaranteed to win\\n4. The mouse is guaranteed to win\\n\\nTo bootstrap the game, we can say the following:\\n\\n+ The cat has definitely won if it can move to the mouse\\'s position, i.e. the state `(ci, mi, mouse)` where `ci == mi`\\n+ The mouse has definitely won if it can reach the end, i.e. the state `(ci, 0, cat)`.\\n\\nNote that in the winning state, it is the other players\\'s turn. However, that player has no valid moves left, so the game is over.\\n\\n## Finding the solution\\n\\nWhat does it mean for the cat and mouse to play optimally?\\n\\nFor an uncertain state, there are two possible changes:\\n\\n1. Find a winning move\\n2. Accept that all moves result in a loss\\n\\nIf neither are true, the outcome remains uncertain.\\n\\nGiven that the total number of states is quite limited ($$\\\\mathrm{O}(n^2)$$), we may visit every state that is currently uncertain and check whether there is perhaps a winning move or a certain loss. If so much as a single state changes its outcome, it can have a cascading effect on the entire game.\\n\\nStopping criteria:\\n1. The outcome of the starting state is known (`dp[mouseStartPos][catStartPos][mouse]`), or\\n2. All uncertain states were visited and none of their outcomes could be determined. Then it\\'s a draw.\\n\\n# Complexity\\n\\nEach iteration, we visit all states to determine new outcomes, which is $$\\\\mathrm{O}(n^2)$$.\\n\\nIn the worst case scenario, we find a single new outcome per iteration, which gives us to $$\\\\mathrm{O}(n^4)$$.\\n\\n- Time complexity: $$\\\\mathrm{O}(n^4)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$\\\\mathrm{O}(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc catMouseGame(graph [][]int) int {\\n\\tn := len(graph)\\n\\tconst (\\n\\t\\tmouse     = 0\\n\\t\\tcat       = 1\\n\\t\\tmouseWin  = 1 << 0\\n\\t\\tcatWin    = 1 << 1\\n\\t\\tuncertain = 1 << 2 // uncertain outcome\\n\\t\\tinvalid   = 1 << 3 // invalid game state\\n\\t)\\n\\n\\t// dp[i][j][k]\\n\\t// mi = mouse position\\n\\t// ci = cat position\\n\\t// who = 0 if mouse, 1 if cat\\n\\t// var dp [51][51][2]int\\n\\tdp := make([][][2]int, n)\\n\\tfor i := range dp {\\n\\t\\tdp[i] = make([][2]int, n)\\n\\t}\\n\\n\\t// Initialize with uncertain\\n\\tfor i := range dp {\\n\\t\\tfor j := range dp[i] {\\n\\t\\t\\tfor k := range dp[i][j] {\\n\\t\\t\\t\\tdp[i][j][k] = uncertain\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Cat is not allowed to be in position 0\\n\\tfor mi := range dp {\\n\\t\\tdp[mi][0][mouse] = invalid\\n\\t\\tdp[mi][0][cat] = invalid\\n\\t}\\n\\n\\t// Wherever the cat may be...\\n\\tfor ci := 1; ci < n; ci++ {\\n\\t\\t// The mouse cannot move after reaching the end (game is over)\\n\\t\\tdp[0][ci][mouse] = invalid\\n\\n\\t\\t// And the mouse has won when it\\'s the cat\\'s turn\\n\\t\\tdp[0][ci][cat] = mouseWin\\n\\t}\\n\\n\\t// If the cat and mouse are in the same position, the cat has won\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tdp[i][i][cat] = catWin\\n\\t\\tdp[i][i][mouse] = catWin\\n\\t}\\n\\n\\tfor {\\n\\t\\tvar changed bool\\n\\t\\tfor mi := 0; mi < n; mi++ {\\n\\t\\t\\tfor ci := 1; ci < n; ci++ {\\n\\t\\t\\t\\t// For both the cat and mouse and an undecided state (draw),\\n\\t\\t\\t\\t// explore possible next states. The cat wants to find a\\n\\t\\t\\t\\t// position where the cat wins, then a draw, and finally, if all\\n\\t\\t\\t\\t// else fails, it will accept a loss (mouse). The same story\\n\\t\\t\\t\\t// goes for the mouse.\\n\\t\\t\\t\\tif dp[mi][ci][cat] == uncertain {\\n\\t\\t\\t\\t\\tvar nextState int\\n\\t\\t\\t\\t\\tfor _, nei := range graph[ci] {\\n\\t\\t\\t\\t\\t\\tnextState |= dp[mi][nei][mouse]\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif nextState&catWin > 0 {\\n\\t\\t\\t\\t\\t\\tdp[mi][ci][cat] = catWin\\n\\t\\t\\t\\t\\t\\tchanged = true\\n\\t\\t\\t\\t\\t} else if nextState&(uncertain|mouseWin) == mouseWin {\\n\\t\\t\\t\\t\\t\\tdp[mi][ci][cat] = mouseWin\\n\\t\\t\\t\\t\\t\\tchanged = true\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif dp[mi][ci][mouse] == uncertain {\\n\\t\\t\\t\\t\\tvar nextState int\\n\\t\\t\\t\\t\\tfor _, nei := range graph[mi] {\\n\\t\\t\\t\\t\\t\\tnextState |= dp[nei][ci][cat]\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif nextState&mouseWin > 0 {\\n\\t\\t\\t\\t\\t\\tchanged = true\\n\\t\\t\\t\\t\\t\\tdp[mi][ci][mouse] = mouseWin\\n\\t\\t\\t\\t\\t} else if nextState&(uncertain|catWin) == catWin {\\n\\t\\t\\t\\t\\t\\tchanged = true\\n\\t\\t\\t\\t\\t\\tdp[mi][ci][mouse] = catWin\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif dp[1][2][mouse]&mouseWin > 0 {\\n\\t\\t\\treturn 1\\n\\t\\t} else if dp[1][2][mouse]&catWin > 0 {\\n\\t\\t\\treturn 2\\n\\t\\t} else if !changed {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc catMouseGame(graph [][]int) int {\\n\\tn := len(graph)\\n\\tconst (\\n\\t\\tmouse     = 0\\n\\t\\tcat       = 1\\n\\t\\tmouseWin  = 1 << 0\\n\\t\\tcatWin    = 1 << 1\\n\\t\\tuncertain = 1 << 2 // uncertain outcome\\n\\t\\tinvalid   = 1 << 3 // invalid game state\\n\\t)\\n\\n\\t// dp[i][j][k]\\n\\t// mi = mouse position\\n\\t// ci = cat position\\n\\t// who = 0 if mouse, 1 if cat\\n\\t// var dp [51][51][2]int\\n\\tdp := make([][][2]int, n)\\n\\tfor i := range dp {\\n\\t\\tdp[i] = make([][2]int, n)\\n\\t}\\n\\n\\t// Initialize with uncertain\\n\\tfor i := range dp {\\n\\t\\tfor j := range dp[i] {\\n\\t\\t\\tfor k := range dp[i][j] {\\n\\t\\t\\t\\tdp[i][j][k] = uncertain\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Cat is not allowed to be in position 0\\n\\tfor mi := range dp {\\n\\t\\tdp[mi][0][mouse] = invalid\\n\\t\\tdp[mi][0][cat] = invalid\\n\\t}\\n\\n\\t// Wherever the cat may be...\\n\\tfor ci := 1; ci < n; ci++ {\\n\\t\\t// The mouse cannot move after reaching the end (game is over)\\n\\t\\tdp[0][ci][mouse] = invalid\\n\\n\\t\\t// And the mouse has won when it\\'s the cat\\'s turn\\n\\t\\tdp[0][ci][cat] = mouseWin\\n\\t}\\n\\n\\t// If the cat and mouse are in the same position, the cat has won\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tdp[i][i][cat] = catWin\\n\\t\\tdp[i][i][mouse] = catWin\\n\\t}\\n\\n\\tfor {\\n\\t\\tvar changed bool\\n\\t\\tfor mi := 0; mi < n; mi++ {\\n\\t\\t\\tfor ci := 1; ci < n; ci++ {\\n\\t\\t\\t\\t// For both the cat and mouse and an undecided state (draw),\\n\\t\\t\\t\\t// explore possible next states. The cat wants to find a\\n\\t\\t\\t\\t// position where the cat wins, then a draw, and finally, if all\\n\\t\\t\\t\\t// else fails, it will accept a loss (mouse). The same story\\n\\t\\t\\t\\t// goes for the mouse.\\n\\t\\t\\t\\tif dp[mi][ci][cat] == uncertain {\\n\\t\\t\\t\\t\\tvar nextState int\\n\\t\\t\\t\\t\\tfor _, nei := range graph[ci] {\\n\\t\\t\\t\\t\\t\\tnextState |= dp[mi][nei][mouse]\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif nextState&catWin > 0 {\\n\\t\\t\\t\\t\\t\\tdp[mi][ci][cat] = catWin\\n\\t\\t\\t\\t\\t\\tchanged = true\\n\\t\\t\\t\\t\\t} else if nextState&(uncertain|mouseWin) == mouseWin {\\n\\t\\t\\t\\t\\t\\tdp[mi][ci][cat] = mouseWin\\n\\t\\t\\t\\t\\t\\tchanged = true\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif dp[mi][ci][mouse] == uncertain {\\n\\t\\t\\t\\t\\tvar nextState int\\n\\t\\t\\t\\t\\tfor _, nei := range graph[mi] {\\n\\t\\t\\t\\t\\t\\tnextState |= dp[nei][ci][cat]\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif nextState&mouseWin > 0 {\\n\\t\\t\\t\\t\\t\\tchanged = true\\n\\t\\t\\t\\t\\t\\tdp[mi][ci][mouse] = mouseWin\\n\\t\\t\\t\\t\\t} else if nextState&(uncertain|catWin) == catWin {\\n\\t\\t\\t\\t\\t\\tchanged = true\\n\\t\\t\\t\\t\\t\\tdp[mi][ci][mouse] = catWin\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif dp[1][2][mouse]&mouseWin > 0 {\\n\\t\\t\\treturn 1\\n\\t\\t} else if dp[1][2][mouse]&catWin > 0 {\\n\\t\\t\\treturn 2\\n\\t\\t} else if !changed {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2676295,
                "title": "c-easy-recursive-dp-commented",
                "content": "**Note** :- If some player make 5 * n (Randomly selected this value and solution accepted) ans no player is wins so return draw\\n\\n**C++ code**\\n```\\n\\t int dp[101][101][501];\\n    \\n    int solve(int m, int c, int moves, int n, vector<vector<int>>& g){\\n        //5*n this is i randomly selected if in thin number of moves no one win return draw flag\\n        if(moves>5*n){\\n            return 0;\\n        }\\n        \\n        //cat win\\n        if(m==c){\\n            return dp[m][c][moves] = 2;\\n        }\\n        \\n        //mouse win\\n        if(m==0){\\n            return dp[m][c][moves] = 1;\\n        }\\n        \\n        if(dp[m][c][moves]!=-1){\\n            return dp[m][c][moves];\\n        }\\n        \\n        //mouse move\\n        if(moves%2==0){\\n            bool isDraw=false;\\n            \\n            for(auto &x:g[m]){\\n                int ans=solve(x,c,moves+1,n,g);\\n                if(ans==1){\\n                    return dp[m][c][moves] = 1;\\n                }\\n                if(ans==0){\\n                    isDraw=true;\\n                }\\n            }\\n            \\n            //because draw is better than loss\\n            if(isDraw){\\n                return dp[m][c][moves] = 0;\\n            }\\n            return dp[m][c][moves] = 2;\\n        }\\n        else{\\n            //cat move\\n            //all the things are same as mouse\\n             bool isDraw=false;\\n            \\n            for(auto &x:g[c]){\\n                if(x==0){\\n                    continue;\\n                }\\n                int ans=solve(m,x,moves+1,n,g);\\n                if(ans==2){\\n                    return dp[m][c][moves] = 2;\\n                }\\n                if(ans==0){\\n                    isDraw=true;\\n                }\\n            }\\n            if(isDraw){\\n                return dp[m][c][moves] = 0;\\n            }\\n            return dp[m][c][moves] = 1;\\n        }\\n    }\\n    \\n    int catMouseGame(vector<vector<int>>& g) {\\n        int n=g.size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(1,2,0,n,g);\\n       \\n    }\\n\\t//code by sachin\\n```\\n**upvote if solution was helpful**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Game Theory"
                ],
                "code": "```\\n\\t int dp[101][101][501];\\n    \\n    int solve(int m, int c, int moves, int n, vector<vector<int>>& g){\\n        //5*n this is i randomly selected if in thin number of moves no one win return draw flag\\n        if(moves>5*n){\\n            return 0;\\n        }\\n        \\n        //cat win\\n        if(m==c){\\n            return dp[m][c][moves] = 2;\\n        }\\n        \\n        //mouse win\\n        if(m==0){\\n            return dp[m][c][moves] = 1;\\n        }\\n        \\n        if(dp[m][c][moves]!=-1){\\n            return dp[m][c][moves];\\n        }\\n        \\n        //mouse move\\n        if(moves%2==0){\\n            bool isDraw=false;\\n            \\n            for(auto &x:g[m]){\\n                int ans=solve(x,c,moves+1,n,g);\\n                if(ans==1){\\n                    return dp[m][c][moves] = 1;\\n                }\\n                if(ans==0){\\n                    isDraw=true;\\n                }\\n            }\\n            \\n            //because draw is better than loss\\n            if(isDraw){\\n                return dp[m][c][moves] = 0;\\n            }\\n            return dp[m][c][moves] = 2;\\n        }\\n        else{\\n            //cat move\\n            //all the things are same as mouse\\n             bool isDraw=false;\\n            \\n            for(auto &x:g[c]){\\n                if(x==0){\\n                    continue;\\n                }\\n                int ans=solve(m,x,moves+1,n,g);\\n                if(ans==2){\\n                    return dp[m][c][moves] = 2;\\n                }\\n                if(ans==0){\\n                    isDraw=true;\\n                }\\n            }\\n            if(isDraw){\\n                return dp[m][c][moves] = 0;\\n            }\\n            return dp[m][c][moves] = 1;\\n        }\\n    }\\n    \\n    int catMouseGame(vector<vector<int>>& g) {\\n        int n=g.size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(1,2,0,n,g);\\n       \\n    }\\n\\t//code by sachin\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2619607,
                "title": "solution-with-dfs-tl-removed-when-declare-dp-with-array-instead-of-vector",
                "content": "```\\nclass Solution {\\n    int maxLimit;\\n    int dp[51][51][2][501];\\n\\tint gameWin(vector<vector<int>>& graph, int mouse, int cat, int move, /*vector<vector<vector<vector<int>>>>& dp,*/ int max) {\\n\\t\\tint mt=0, ct=0, win;\\n        if(cat == mouse) return 2;\\n        if(mouse == 0) return 1;\\n        if(max > 200) return 0;\\n        \\n        if(dp[mouse][cat][move][max] != INT_MIN) return dp[mouse][cat][move][max];\\n        \\n        //cout<<mouse<<\" \"<<cat<<\" \"<<move<<endl;\\n        \\n\\t\\tif(move == 0) {\\n            win = 2;\\n\\t\\t\\tbool mouseWins = false;\\n            bool catWins = false;\\n            bool isDraw = false;\\n\\t\\t\\tfor(int g : graph[mouse]) {\\n                if(g == cat) continue;\\n\\t\\t\\t\\t\\n                mt = gameWin(graph, g, cat, 1,/* dp,*/ max+1);\\n                if(mt==1) {\\n                    mouseWins=true;\\n                    break;\\n                }\\n                if(mt==0) isDraw=true;\\n                if(mt==2) catWins=true;\\n\\t\\t\\t}\\n            if(mouseWins) return dp[mouse][cat][move][max] = 1;\\n\\t\\t\\tif(isDraw) return dp[mouse][cat][move][max] = 0;\\n\\t\\t\\treturn dp[mouse][cat][move][max] = 2;\\n\\t\\t}\\n\\t\\telse {\\n            win=1;\\n\\t\\t\\tbool mouseWins = false;\\n            bool catWins = false;\\n            bool isDraw = false;\\n\\t\\t\\tfor(int g : graph[cat]) {\\n                if(g == 0) continue;\\n                \\n\\t\\t\\t\\tct = gameWin(graph, mouse, g, 0,/* dp,*/ max+1);\\n                if(ct==2) {\\n                    catWins=true;\\n                    break;\\n                }\\n                if(ct==0) isDraw=true;\\n                if(ct==1) mouseWins=true;\\n\\t\\t\\t}\\n            if(catWins) return dp[mouse][cat][move][max] = 2;\\n\\t\\t\\tif(isDraw) return dp[mouse][cat][move][max] = 0;\\n\\t\\t\\treturn dp[mouse][cat][move][max] = 1;\\n\\t\\t}\\n\\t\\n\\t\\t//return dp[mouse][cat][move][max] = win;\\n\\t}\\npublic:\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        int result = 0;\\n        maxLimit = 500;\\n\\t\\t//vector<vector<vector<vector<int>>>> dp(51, vector<vector<vector<int>>>(51, vector<vector<int>>(2, vector<int>(maxLimit,INT_MIN))));\\n        for(int i = 0;i<51;i++){\\n            for(int j = 0;j<51;j++){\\n                for(int k = 0;k<2;k++){\\n                    for(int l = 0;l<maxLimit;l++){\\n                        dp[i][j][k][l] = INT_MIN;\\n                    }\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\tresult = gameWin(graph, 1, 2, 0,/* dp,*/ 0);\\n\\t\\t\\n\\t\\treturn result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int maxLimit;\\n    int dp[51][51][2][501];\\n\\tint gameWin(vector<vector<int>>& graph, int mouse, int cat, int move, /*vector<vector<vector<vector<int>>>>& dp,*/ int max) {\\n\\t\\tint mt=0, ct=0, win;\\n        if(cat == mouse) return 2;\\n        if(mouse == 0) return 1;\\n        if(max > 200) return 0;\\n        \\n        if(dp[mouse][cat][move][max] != INT_MIN) return dp[mouse][cat][move][max];\\n        \\n        //cout<<mouse<<\" \"<<cat<<\" \"<<move<<endl;\\n        \\n\\t\\tif(move == 0) {\\n            win = 2;\\n\\t\\t\\tbool mouseWins = false;\\n            bool catWins = false;\\n            bool isDraw = false;\\n\\t\\t\\tfor(int g : graph[mouse]) {\\n                if(g == cat) continue;\\n\\t\\t\\t\\t\\n                mt = gameWin(graph, g, cat, 1,/* dp,*/ max+1);\\n                if(mt==1) {\\n                    mouseWins=true;\\n                    break;\\n                }\\n                if(mt==0) isDraw=true;\\n                if(mt==2) catWins=true;\\n\\t\\t\\t}\\n            if(mouseWins) return dp[mouse][cat][move][max] = 1;\\n\\t\\t\\tif(isDraw) return dp[mouse][cat][move][max] = 0;\\n\\t\\t\\treturn dp[mouse][cat][move][max] = 2;\\n\\t\\t}\\n\\t\\telse {\\n            win=1;\\n\\t\\t\\tbool mouseWins = false;\\n            bool catWins = false;\\n            bool isDraw = false;\\n\\t\\t\\tfor(int g : graph[cat]) {\\n                if(g == 0) continue;\\n                \\n\\t\\t\\t\\tct = gameWin(graph, mouse, g, 0,/* dp,*/ max+1);\\n                if(ct==2) {\\n                    catWins=true;\\n                    break;\\n                }\\n                if(ct==0) isDraw=true;\\n                if(ct==1) mouseWins=true;\\n\\t\\t\\t}\\n            if(catWins) return dp[mouse][cat][move][max] = 2;\\n\\t\\t\\tif(isDraw) return dp[mouse][cat][move][max] = 0;\\n\\t\\t\\treturn dp[mouse][cat][move][max] = 1;\\n\\t\\t}\\n\\t\\n\\t\\t//return dp[mouse][cat][move][max] = win;\\n\\t}\\npublic:\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        int result = 0;\\n        maxLimit = 500;\\n\\t\\t//vector<vector<vector<vector<int>>>> dp(51, vector<vector<vector<int>>>(51, vector<vector<int>>(2, vector<int>(maxLimit,INT_MIN))));\\n        for(int i = 0;i<51;i++){\\n            for(int j = 0;j<51;j++){\\n                for(int k = 0;k<2;k++){\\n                    for(int l = 0;l<maxLimit;l++){\\n                        dp[i][j][k][l] = INT_MIN;\\n                    }\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\tresult = gameWin(graph, 1, 2, 0,/* dp,*/ 0);\\n\\t\\t\\n\\t\\treturn result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2618484,
                "title": "c-easy-recursion",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        int N = graph.size();\\n        vector<vector<int>> dp[2];\\n        vector<vector<int>> outdegree[2];\\n        queue<vector<int>> q; // q of {turn, mouse position, cat position} for topological sort\\n\\n        dp[0] = vector<vector<int>>(N, vector<int>(N));\\n        dp[1] = vector<vector<int>>(N, vector<int>(N));\\n        outdegree[0] = vector<vector<int>>(N, vector<int>(N));\\n        outdegree[1] = vector<vector<int>>(N, vector<int>(N));\\n\\n        // init dp and queue\\n        for (int j = 0; j < N; ++j) {\\n            dp[0][0][j] = dp[1][0][j] = 1;\\n            q.push({0, 0, j});\\n            q.push({1, 0, j});\\n        }\\n        for (int j = 1; j < N; ++j) {\\n            dp[0][j][j] = dp[1][j][j] = 2;\\n            q.push({0, j, j});\\n            q.push({1, j, j});\\n        }\\n        // init outdegree\\n        for (int i = 0; i < N; ++i) {\\n            for (int j = 1; j < N; ++j) {\\n                outdegree[0][i][j] = graph[i].size();\\n                outdegree[1][i][j] = graph[j].size();\\n            }\\n        }\\n        for (auto &v : graph[0]) {\\n            for (int i = 0; i < N; ++i) {\\n                outdegree[1][i][v]--;\\n            }\\n        }\\n        // run the topological sort from queue\\n        while (q.size()) {\\n            auto turn = q.front()[0];\\n            auto mouse = q.front()[1];\\n            auto cat = q.front()[2];\\n            q.pop();\\n\\n            if (turn == 0 && mouse == 1 && cat == 2) {\\n                // the result has been inferenced\\n                break;\\n            }\\n\\n            if (turn == 0) { // mouse\\'s turn\\n                // v is the prev position of cat\\n                for (auto &v : graph[cat]) {\\n                    if (v == 0) {\\n                        continue;\\n                    }\\n\\n                    if (dp[1][mouse][v] > 0) {\\n                        continue;\\n                    }\\n\\n                    if (dp[turn][mouse][cat] == 2) {\\n                        // cat wants to move from v to `cat` position, and thus cat wins\\n                        dp[1][mouse][v] = 2;\\n                        q.push({1, mouse, v});\\n                        continue;\\n                    }\\n\\n                    outdegree[1][mouse][v]--;\\n                    if (outdegree[1][mouse][v] == 0) {\\n                        dp[1][mouse][v] = 1;\\n                        q.push({1, mouse, v});\\n                    }\\n                }\\n            } else { // cat\\'s turn\\n\\t\\t\\t\\t// v is the prev position of mouse\\n                for (auto &v : graph[mouse]) {\\n                    if (dp[0][v][cat] > 0) {\\n                        continue;\\n                    }\\n\\n                    if (dp[turn][mouse][cat] == 1) {\\n                        // mouse wants to move from v to `mouse` position and thus mouse wins\\n                        dp[0][v][cat] = 1;\\n                        q.push({0, v, cat});\\n                        continue;\\n                    }\\n\\n                    outdegree[0][v][cat]--;\\n                    if (outdegree[0][v][cat] == 0) {\\n                        dp[0][v][cat] = 2;\\n                        q.push({0, v, cat});\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[0][1][2];\\n    }\\n};\\n\\n****PLEASE UPVOTE GUYS!!!!!!*****\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        int N = graph.size();\\n        vector<vector<int>> dp[2];\\n        vector<vector<int>> outdegree[2];\\n        queue<vector<int>> q; // q of {turn, mouse position, cat position}",
                "codeTag": "Java"
            },
            {
                "id": 2277826,
                "title": "golang-dp",
                "content": "```\\nfunc catMouseGame(graph [][]int) int {\\n\\tmem := [51][51][2][501]int{}\\n\\tfor i := range mem {\\n\\t\\tfor j := range mem[i] {\\n\\t\\t\\tfor k := range mem[i][j] {\\n\\t\\t\\t\\tfor s := range mem[i][j][k] {\\n\\t\\t\\t\\t\\tmem[i][j][k][s] = -1\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tn := len(graph)\\n\\tvar dp func(c, m, t, s int) int\\n\\tdp = func(c, m, t, s int) int {\\n\\t\\tif s > 5*n {\\n\\t\\t\\tmem[c][m][t][s] = 0\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t\\tif c == m {\\n\\t\\t\\tmem[c][m][t][s] = 2\\n\\t\\t\\treturn 2\\n\\t\\t}\\n\\t\\tif m == 0 {\\n\\t\\t\\tmem[c][m][t][s] = 1\\n\\t\\t\\treturn 1\\n\\t\\t}\\n\\t\\tif mem[c][m][t][s] != -1 {\\n\\t\\t\\treturn mem[c][m][t][s]\\n\\t\\t}\\n\\n\\t\\tif t == 0 {\\n\\t\\t\\tbn := false\\n\\t\\t\\tfor i := range graph[m] {\\n\\t\\t\\t\\ta := dp(c, graph[m][i], 1, s+1)\\n\\t\\t\\t\\tif a == 1 {\\n\\t\\t\\t\\t\\tmem[c][m][t][s] = 1\\n\\t\\t\\t\\t\\treturn mem[c][m][t][s]\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif a == 0 {\\n\\t\\t\\t\\t\\tbn = true\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif bn {\\n\\t\\t\\t\\tmem[c][m][t][s] = 0\\n\\t\\t\\t\\treturn mem[c][m][t][s]\\n\\t\\t\\t}\\n\\t\\t\\tmem[c][m][t][s] = 2\\n\\t\\t\\treturn mem[c][m][t][s]\\n\\t\\t}\\n\\t\\tbn := false\\n\\t\\tfor i := range graph[c] {\\n\\t\\t\\tif graph[c][i] == 0 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\ta := dp(graph[c][i], m, 0, s+1)\\n\\t\\t\\tif a == 2 {\\n\\t\\t\\t\\tmem[c][m][t][s] = 2\\n\\t\\t\\t\\treturn mem[c][m][t][s]\\n\\t\\t\\t}\\n\\t\\t\\tif a == 0 {\\n\\t\\t\\t\\tbn = true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif bn {\\n\\t\\t\\tmem[c][m][t][s] = 0\\n\\t\\t\\treturn mem[c][m][t][s]\\n\\t\\t}\\n\\t\\tmem[c][m][t][s] = 1\\n\\t\\treturn mem[c][m][t][s]\\n\\t}\\n\\n\\treturn dp(2, 1, 0, 0)\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfunc catMouseGame(graph [][]int) int {\\n\\tmem := [51][51][2][501]int{}\\n\\tfor i := range mem {\\n\\t\\tfor j := range mem[i] {\\n\\t\\t\\tfor k := range mem[i][j] {\\n\\t\\t\\t\\tfor s := range mem[i][j][k] {\\n\\t\\t\\t\\t\\tmem[i][j][k][s] = -1\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tn := len(graph)\\n\\tvar dp func(c, m, t, s int) int\\n\\tdp = func(c, m, t, s int) int {\\n\\t\\tif s > 5*n {\\n\\t\\t\\tmem[c][m][t][s] = 0\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t\\tif c == m {\\n\\t\\t\\tmem[c][m][t][s] = 2\\n\\t\\t\\treturn 2\\n\\t\\t}\\n\\t\\tif m == 0 {\\n\\t\\t\\tmem[c][m][t][s] = 1\\n\\t\\t\\treturn 1\\n\\t\\t}\\n\\t\\tif mem[c][m][t][s] != -1 {\\n\\t\\t\\treturn mem[c][m][t][s]\\n\\t\\t}\\n\\n\\t\\tif t == 0 {\\n\\t\\t\\tbn := false\\n\\t\\t\\tfor i := range graph[m] {\\n\\t\\t\\t\\ta := dp(c, graph[m][i], 1, s+1)\\n\\t\\t\\t\\tif a == 1 {\\n\\t\\t\\t\\t\\tmem[c][m][t][s] = 1\\n\\t\\t\\t\\t\\treturn mem[c][m][t][s]\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif a == 0 {\\n\\t\\t\\t\\t\\tbn = true\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif bn {\\n\\t\\t\\t\\tmem[c][m][t][s] = 0\\n\\t\\t\\t\\treturn mem[c][m][t][s]\\n\\t\\t\\t}\\n\\t\\t\\tmem[c][m][t][s] = 2\\n\\t\\t\\treturn mem[c][m][t][s]\\n\\t\\t}\\n\\t\\tbn := false\\n\\t\\tfor i := range graph[c] {\\n\\t\\t\\tif graph[c][i] == 0 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\ta := dp(graph[c][i], m, 0, s+1)\\n\\t\\t\\tif a == 2 {\\n\\t\\t\\t\\tmem[c][m][t][s] = 2\\n\\t\\t\\t\\treturn mem[c][m][t][s]\\n\\t\\t\\t}\\n\\t\\t\\tif a == 0 {\\n\\t\\t\\t\\tbn = true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif bn {\\n\\t\\t\\tmem[c][m][t][s] = 0\\n\\t\\t\\treturn mem[c][m][t][s]\\n\\t\\t}\\n\\t\\tmem[c][m][t][s] = 1\\n\\t\\treturn mem[c][m][t][s]\\n\\t}\\n\\n\\treturn dp(2, 1, 0, 0)\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2203459,
                "title": "java-draw-is-kinda-tricky-short-solution",
                "content": "Draw is tricky because if we only memo on mouse position, cat position, and whose turn it is, \\nthen, say, the current turn is mouse, and it sees that going upward can lead to a draw and nowhere else can lead to its win, so\\nit will take that and conclude the best play is a draw, but it is not the case because going upward can lead to a deadend and then go back down, and it so happens that it is mouse\\'s turn again and cat\\'s position is the same, then it will mistakenly think it is a draw when in fact it should have been cat win.\\n\\nTo address this problem, we have to let it run loooooooooong enough, memo on time, so that all possible moves that can lead to a cat win or mouse win has been revealed, and if there is still no path to either of them wins by TIME_MAX, then it is a draw.\\n\\nI\\'ve chosen TIME_MAX to be 200 turns, and it works fine.\\n```Java\\nclass Solution {\\n    int TIME_MAX = 200;\\n    int DRAW = 0;\\n    int MOUSE_WIN = 1;\\n    int CAT_WIN = 2;\\n    public int catMouseGame(int[][] graph) {\\n        return dfs(0, new int[]{1, 2}, graph, new Integer[TIME_MAX+1][graph.length][graph.length]);\\n    }\\n\\n    private int dfs(int time, int[] p, int[][] graph, Integer[][][] memo){ // p[0] -> mouse position, p[1] -> cat position\\n        Integer old = memo[time][p[0]][p[1]];\\n        if (old != null)      return old;       // all the base cases here\\n        if (time >= TIME_MAX) return DRAW;\\n        if (p[0]==0)          return MOUSE_WIN;\\n        if (p[0]==p[1])       return CAT_WIN;\\n        int state = 0;\\n        int where = p[time&1];\\n        int res = DRAW;\\n        for (int i = 0; i < graph[where].length; i++){\\n            if ((time&1)==0||graph[where][i]>0){ // if mouse turn or cat turn and the dest is not 0, do ...\\n                p[time&1]=graph[where][i];\\n                state |= 1 << dfs(time+1, p, graph, memo);\\n                if ((time&1)>0&&(state&4)>0 || (time&1)==0&&(state&2)>0) // if mouse\\'s turn & mouse win\\n                    break;                                               // or cat\\'s turn & cat win, then we stop.\\n            }\\n        }\\n        p[time&1]=where; // restore p\\n        if (((time&1)>0 && (state & 4)>0)||((time&1)==0) && state==4){ \\n            res = CAT_WIN; // cat win when (cat\\'s turn & cat win) or (mouse\\'s turn and state = cat)\\n        }else if (((time&1)==0 && (state & 2)>0)||(time&1)==1 && state==2){\\n            res = MOUSE_WIN; // mouse win when (mouse\\'s turn and mouse win) or (cat\\'s turn and state = mouse)\\n        }\\n        return memo[time][p[0]][p[1]]=res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    int TIME_MAX = 200;\\n    int DRAW = 0;\\n    int MOUSE_WIN = 1;\\n    int CAT_WIN = 2;\\n    public int catMouseGame(int[][] graph) {\\n        return dfs(0, new int[]{1, 2}, graph, new Integer[TIME_MAX+1][graph.length][graph.length]);\\n    }\\n\\n    private int dfs(int time, int[] p, int[][] graph, Integer[][][] memo){ // p[0] -> mouse position, p[1] -> cat position\\n        Integer old = memo[time][p[0]][p[1]];\\n        if (old != null)      return old;       // all the base cases here\\n        if (time >= TIME_MAX) return DRAW;\\n        if (p[0]==0)          return MOUSE_WIN;\\n        if (p[0]==p[1])       return CAT_WIN;\\n        int state = 0;\\n        int where = p[time&1];\\n        int res = DRAW;\\n        for (int i = 0; i < graph[where].length; i++){\\n            if ((time&1)==0||graph[where][i]>0){ // if mouse turn or cat turn and the dest is not 0, do ...\\n                p[time&1]=graph[where][i];\\n                state |= 1 << dfs(time+1, p, graph, memo);\\n                if ((time&1)>0&&(state&4)>0 || (time&1)==0&&(state&2)>0) // if mouse\\'s turn & mouse win\\n                    break;                                               // or cat\\'s turn & cat win, then we stop.\\n            }\\n        }\\n        p[time&1]=where; // restore p\\n        if (((time&1)>0 && (state & 4)>0)||((time&1)==0) && state==4){ \\n            res = CAT_WIN; // cat win when (cat\\'s turn & cat win) or (mouse\\'s turn and state = cat)\\n        }else if (((time&1)==0 && (state & 2)>0)||(time&1)==1 && state==2){\\n            res = MOUSE_WIN; // mouse win when (mouse\\'s turn and mouse win) or (cat\\'s turn and state = mouse)\\n        }\\n        return memo[time][p[0]][p[1]]=res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2080335,
                "title": "dfs",
                "content": "```\\nint find(vector<vector<vector<int>>>&dp,vector<vector<int>>& graph,int t,int x,int y){\\n        if(t>50) //draw\\n            return 0;\\n        if(x==y) //cat\\n            return dp[t][x][y]=2;\\n        if(x==0) //mouse\\n            return dp[t][x][y]=1;\\n        if(dp[t][x][y]!=-1)\\n            return dp[t][x][y];\\n        bool flag=true;\\n        int turn = t%2;\\n        if(!turn){\\n            for(int i = 0;i<graph[x].size();i++){\\n                int nxt = find(dp,graph,t+1,graph[x][i],y);\\n                if(nxt==1) return dp[t][x][y]=1;\\n                if(nxt!=2) flag=0;\\n            }\\n            if(flag) return dp[t][x][y]=2;\\n            else return dp[t][x][y]=0;\\n        }\\n        else{\\n            flag=1;\\n            for(int i = 0;i<graph[y].size();i++){\\n                if(graph[y][i]!=0){\\n                int nxt = find(dp,graph,t+1,x,graph[y][i]);\\n                if(nxt==2) return dp[t][x][y]=2;\\n                if(nxt!=1) flag=0;}\\n            }\\n            if(flag) return dp[t][x][y]=1;\\n            else return dp[t][x][y]=0;\\n        }\\n            \\n    }\\n    \\npublic:\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        vector<vector<vector<int>>>dp(51,vector<vector<int>>(n,vector<int>(n,-1)));\\n        return find(dp,graph,0,1,2);\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint find(vector<vector<vector<int>>>&dp,vector<vector<int>>& graph,int t,int x,int y){\\n        if(t>50) //draw\\n            return 0;\\n        if(x==y) //cat\\n            return dp[t][x][y]=2;\\n        if(x==0) //mouse\\n            return dp[t][x][y]=1;\\n        if(dp[t][x][y]!=-1)\\n            return dp[t][x][y];\\n        bool flag=true;\\n        int turn = t%2;\\n        if(!turn){\\n            for(int i = 0;i<graph[x].size();i++){\\n                int nxt = find(dp,graph,t+1,graph[x][i],y);\\n                if(nxt==1) return dp[t][x][y]=1;\\n                if(nxt!=2) flag=0;\\n            }\\n            if(flag) return dp[t][x][y]=2;\\n            else return dp[t][x][y]=0;\\n        }\\n        else{\\n            flag=1;\\n            for(int i = 0;i<graph[y].size();i++){\\n                if(graph[y][i]!=0){\\n                int nxt = find(dp,graph,t+1,x,graph[y][i]);\\n                if(nxt==2) return dp[t][x][y]=2;\\n                if(nxt!=1) flag=0;}\\n            }\\n            if(flag) return dp[t][x][y]=1;\\n            else return dp[t][x][y]=0;\\n        }\\n            \\n    }\\n    \\npublic:\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        vector<vector<vector<int>>>dp(51,vector<vector<int>>(n,vector<int>(n,-1)));\\n        return find(dp,graph,0,1,2);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2058281,
                "title": "4-d-dp-runtime-250ms-minmax-dfs-c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    //Three 3 dp\\n    int visited[51][51][2][501];\\n    vector<vector<int>>graph;\\n    int draw = 0;\\n    int cwin = 2;\\n    int rwin = 1;\\n    int find(int cat,int mouse,bool mousemove,int step){ \\n        if(mouse==cat) {\\n            return cwin;\\n        }\\n        \\n        if(mouse==0) return rwin;\\n        if(step>200) return draw;\\n        \\n        \\n        \\n         if(visited[mouse][cat][mousemove][step]!=-1) return  visited[mouse][cat][mousemove][step];\\n        \\n        if(mousemove){\\n            //Mouse will want to win\\n            bool mouseWins = false;\\n            bool catWins = false;\\n            bool isDraw = false;\\n            for(auto &child : graph[mouse]){\\n                int ans = find(cat,child,false,step+1);\\n                if(ans==rwin) {\\n                    mouseWins = true;\\n                    break;\\n                }\\n                if(ans==cwin) catWins = true;\\n                if(ans==draw) isDraw = true;\\n            }\\n            if(mouseWins) return visited[mouse][cat][mousemove][step]  = rwin;\\n            if(isDraw) return  visited[mouse][cat][mousemove][step]  = draw;\\n            return  visited[mouse][cat][mousemove][step]  = cwin;\\n        }\\n        else{\\n            //Cat will want to loose the mouse\\n            bool mouseWins = false;\\n            bool catWins = false;\\n            bool isDraw = false;\\n            for(auto &child : graph[cat]){\\n                if(child==0) continue;\\n                int ans = find(child,mouse,true,step+1);\\n                if(ans==cwin){\\n                    catWins = true;\\n                    break;\\n                }\\n                if(ans==rwin){\\n                    mouseWins = true;\\n                }\\n                if(ans==draw) isDraw = true;\\n            }\\n            if(catWins) return visited[mouse][cat][mousemove][step]  =  cwin;\\n            if(isDraw) return  visited[mouse][cat][mousemove][step]  = draw;\\n            return  visited[mouse][cat][mousemove][step]  = rwin;\\n\\n        }\\n        \\n    }\\n    \\n    int catMouseGame(vector<vector<int>>& graph) {\\n        this->graph = graph;\\n        for(int i = 0;i<51;i++){\\n            for(int j = 0;j<51;j++){\\n                for(int k = 0;k<2;k++){\\n                    for(int l = 0;l<500;l++){\\n                        visited[i][j][k][l] = -1;\\n                    }\\n                }\\n            }\\n        }\\n        return find(2,1,true,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Three 3 dp\\n    int visited[51][51][2][501];\\n    vector<vector<int>>graph;\\n    int draw = 0;\\n    int cwin = 2;\\n    int rwin = 1;\\n    int find(int cat,int mouse,bool mousemove,int step){ \\n        if(mouse==cat) {\\n            return cwin;\\n        }\\n        \\n        if(mouse==0) return rwin;\\n        if(step>200) return draw;\\n        \\n        \\n        \\n         if(visited[mouse][cat][mousemove][step]!=-1) return  visited[mouse][cat][mousemove][step];\\n        \\n        if(mousemove){\\n            //Mouse will want to win\\n            bool mouseWins = false;\\n            bool catWins = false;\\n            bool isDraw = false;\\n            for(auto &child : graph[mouse]){\\n                int ans = find(cat,child,false,step+1);\\n                if(ans==rwin) {\\n                    mouseWins = true;\\n                    break;\\n                }\\n                if(ans==cwin) catWins = true;\\n                if(ans==draw) isDraw = true;\\n            }\\n            if(mouseWins) return visited[mouse][cat][mousemove][step]  = rwin;\\n            if(isDraw) return  visited[mouse][cat][mousemove][step]  = draw;\\n            return  visited[mouse][cat][mousemove][step]  = cwin;\\n        }\\n        else{\\n            //Cat will want to loose the mouse\\n            bool mouseWins = false;\\n            bool catWins = false;\\n            bool isDraw = false;\\n            for(auto &child : graph[cat]){\\n                if(child==0) continue;\\n                int ans = find(child,mouse,true,step+1);\\n                if(ans==cwin){\\n                    catWins = true;\\n                    break;\\n                }\\n                if(ans==rwin){\\n                    mouseWins = true;\\n                }\\n                if(ans==draw) isDraw = true;\\n            }\\n            if(catWins) return visited[mouse][cat][mousemove][step]  =  cwin;\\n            if(isDraw) return  visited[mouse][cat][mousemove][step]  = draw;\\n            return  visited[mouse][cat][mousemove][step]  = rwin;\\n\\n        }\\n        \\n    }\\n    \\n    int catMouseGame(vector<vector<int>>& graph) {\\n        this->graph = graph;\\n        for(int i = 0;i<51;i++){\\n            for(int j = 0;j<51;j++){\\n                for(int k = 0;k<2;k++){\\n                    for(int l = 0;l<500;l++){\\n                        visited[i][j][k][l] = -1;\\n                    }\\n                }\\n            }\\n        }\\n        return find(2,1,true,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995381,
                "title": "python3-official-solution-with-better-variable-name-and-explanations",
                "content": "```\\nclass Solution(object):\\n    def catMouseGame(self, graph):\\n        MOUSE, CAT, DRAW = 1, 2, 0\\n        N = len(graph)\\n\\n        def get_parents(mouse, cat, turn):\\n            if turn == CAT:\\n                for mouse_prev in graph[mouse]:\\n                    yield mouse_prev, cat, MOUSE\\n            else:\\n                for cat_prev in graph[cat]:\\n                    if cat_prev != 0:\\n                        yield mouse, cat_prev, CAT\\n\\n        degree = dict()\\n        \"\"\"\\n        Record all the ways the current state can move, and only admit the lose when there is no more move current\\n        state can make. So that\\'s why we only subtract the degree if we can not win in the BFS while loop\\n        \"\"\"\\n        for m in range(N):\\n            for c in range(N):\\n                degree[m, c, 1] = len(graph[m])\\n                degree[m, c, 2] = len(graph[c]) - (0 in graph[c])\\n\\n        colors = collections.defaultdict(int)\\n        \"\"\"\\n        color = {\\n            (mouse_position, cat_position, whose_turn): winner\\n        } \\n        \"\"\"\\n\\n        queue = collections.deque([])\\n        \"\"\"\\n        Push all the win cases into the queue\\n\\n        queue = [(mouse_position, cat_position, whose_turn, winner)]\\n        \"\"\"\\n        for turn in [MOUSE, CAT]:\\n            for i in range(N):\\n                colors[0, i, turn] = MOUSE\\n                queue.append((0, i, turn, MOUSE))\\n                if i > 0:\\n                    colors[i, i, turn] = CAT\\n                    queue.append((i, i, turn, CAT))\\n\\n        while queue:\\n            mouse, cat, turn, color = queue.popleft()\\n            for mouse_prev, cat_prev, turn_prev in get_parents(mouse, cat, turn):\\n                if colors[mouse_prev, cat_prev, turn_prev] == DRAW:\\n                    if color == turn_prev:\\n                        \"\"\"Previous state can make a win move, then it will definitely make the win move,\\n                        so color the state and add this state into the queue\\n                        \"\"\"\\n                        colors[mouse_prev, cat_prev, turn_prev] = color\\n                        queue.append((mouse_prev, cat_prev, turn_prev, color))\\n                    else:\\n                        degree[mouse_prev, cat_prev, turn_prev] -= 1\\n                        if degree[mouse_prev, cat_prev, turn_prev] == 0:\\n                            colors[mouse_prev, cat_prev, turn_prev] = 3 - turn_prev\\n                            queue.append((mouse_prev, cat_prev, turn_prev, 3 - turn_prev))\\n\\n        return colors[1, 2, 1]\\n```",
                "solutionTags": [
                    "Game Theory"
                ],
                "code": "```\\nclass Solution(object):\\n    def catMouseGame(self, graph):\\n        MOUSE, CAT, DRAW = 1, 2, 0\\n        N = len(graph)\\n\\n        def get_parents(mouse, cat, turn):\\n            if turn == CAT:\\n                for mouse_prev in graph[mouse]:\\n                    yield mouse_prev, cat, MOUSE\\n            else:\\n                for cat_prev in graph[cat]:\\n                    if cat_prev != 0:\\n                        yield mouse, cat_prev, CAT\\n\\n        degree = dict()\\n        \"\"\"\\n        Record all the ways the current state can move, and only admit the lose when there is no more move current\\n        state can make. So that\\'s why we only subtract the degree if we can not win in the BFS while loop\\n        \"\"\"\\n        for m in range(N):\\n            for c in range(N):\\n                degree[m, c, 1] = len(graph[m])\\n                degree[m, c, 2] = len(graph[c]) - (0 in graph[c])\\n\\n        colors = collections.defaultdict(int)\\n        \"\"\"\\n        color = {\\n            (mouse_position, cat_position, whose_turn): winner\\n        } \\n        \"\"\"\\n\\n        queue = collections.deque([])\\n        \"\"\"\\n        Push all the win cases into the queue\\n\\n        queue = [(mouse_position, cat_position, whose_turn, winner)]\\n        \"\"\"\\n        for turn in [MOUSE, CAT]:\\n            for i in range(N):\\n                colors[0, i, turn] = MOUSE\\n                queue.append((0, i, turn, MOUSE))\\n                if i > 0:\\n                    colors[i, i, turn] = CAT\\n                    queue.append((i, i, turn, CAT))\\n\\n        while queue:\\n            mouse, cat, turn, color = queue.popleft()\\n            for mouse_prev, cat_prev, turn_prev in get_parents(mouse, cat, turn):\\n                if colors[mouse_prev, cat_prev, turn_prev] == DRAW:\\n                    if color == turn_prev:\\n                        \"\"\"Previous state can make a win move, then it will definitely make the win move,\\n                        so color the state and add this state into the queue\\n                        \"\"\"\\n                        colors[mouse_prev, cat_prev, turn_prev] = color\\n                        queue.append((mouse_prev, cat_prev, turn_prev, color))\\n                    else:\\n                        degree[mouse_prev, cat_prev, turn_prev] -= 1\\n                        if degree[mouse_prev, cat_prev, turn_prev] == 0:\\n                            colors[mouse_prev, cat_prev, turn_prev] = 3 - turn_prev\\n                            queue.append((mouse_prev, cat_prev, turn_prev, 3 - turn_prev))\\n\\n        return colors[1, 2, 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965540,
                "title": "wrong-test-case",
                "content": "test case:\\n\\n[[5,6],[3,4],[6],[1,4,5],[1,3,5],[0,3,4,6],[0,2,5]]\\n \\n the given result is 2, however if mouse plays for draw, then cat can never catch him, so the real answer should be 0\\n\\n\\nconsider the following scenario\\n\\nmouse: 1-> 3 -> 4 -> 1 -> 3 -> 1 -> 3 ...\\ncat:       2 ->6 -> 5 -> 4 -> 5 -> 4 -> 5 ...\\n\\nif the initial moves of mouse is 1 -> 3 -> 4, then cat can not catch him, however mouse can not win either, because cat has advantage over mouse at choke point 5.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1949123,
                "title": "cat-and-mouse-solution-java",
                "content": "enum State { DRAW, MOUSE_WIN, CAT_WIN }\\n\\nclass Solution {\\n  public int catMouseGame(int[][] graph) {\\n    final int n = graph.length;\\n    // result of (cat, mouse, move)\\n    // move := 0 (mouse) / 1 (cat)\\n    int[][][] states = new int[n][n][2];\\n    int[][][] outDegree = new int[n][n][2];\\n    Queue<int[]> q = new ArrayDeque<>();\\n\\n    for (int cat = 0; cat < n; ++cat)\\n      for (int mouse = 0; mouse < n; ++mouse) {\\n        outDegree[cat][mouse][0] = graph[mouse].length;\\n        outDegree[cat][mouse][1] =\\n            graph[cat].length - (Arrays.stream(graph[cat]).anyMatch(v -> v == 0) ? 1 : 0);\\n      }\\n\\n    // start from states that winner can be determined\\n    for (int cat = 1; cat < n; ++cat)\\n      for (int move = 0; move < 2; ++move) {\\n        // mouse is in the hole -> MOUSE WIN\\n        states[cat][0][move] = State.MOUSE_WIN.ordinal();\\n        q.offer(new int[] {cat, 0, move, State.MOUSE_WIN.ordinal()});\\n        // cat catches mouse -> CAT_WIN\\n        states[cat][cat][move] = State.CAT_WIN.ordinal();\\n        q.offer(new int[] {cat, cat, move, State.CAT_WIN.ordinal()});\\n      }\\n\\n    while (!q.isEmpty()) {\\n      final int cat = q.peek()[0];\\n      final int mouse = q.peek()[1];\\n      final int move = q.peek()[2];\\n      final int state = q.poll()[3];\\n      if (cat == 2 && mouse == 1 && move == 0)\\n        return state;\\n      final int prevMove = move ^ 1;\\n      for (final int prev : graph[prevMove == 0 ? mouse : cat]) {\\n        final int prevCat = prevMove == 0 ? cat : prev;\\n        if (prevCat == 0) // invalid\\n          continue;\\n        final int prevMouse = prevMove == 0 ? prev : mouse;\\n        // the state is already determined\\n        if (states[prevCat][prevMouse][prevMove] > 0)\\n          continue;\\n        if (prevMove == 0 && state == State.MOUSE_WIN.ordinal() ||\\n            prevMove == 1 && state == State.CAT_WIN.ordinal() ||\\n            --outDegree[prevCat][prevMouse][prevMove] == 0) {\\n          states[prevCat][prevMouse][prevMove] = state;\\n          q.offer(new int[] {prevCat, prevMouse, prevMove, state});\\n        }\\n      }\\n    }\\n\\n    return states[2][1][0];\\n  }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Graph",
                    "Memoization"
                ],
                "code": "class Solution {\\n  public int catMouseGame(int[][] graph) {\\n    final int n = graph.length;\\n    // result of (cat, mouse, move)\\n    // move := 0 (mouse) / 1 (cat)\\n    int[][][] states = new int[n][n][2];\\n    int[][][] outDegree = new int[n][n][2];\\n    Queue<int[]> q = new ArrayDeque<>();\\n\\n    for (int cat = 0; cat < n; ++cat)\\n      for (int mouse = 0; mouse < n; ++mouse) {\\n        outDegree[cat][mouse][0] = graph[mouse].length;\\n        outDegree[cat][mouse][1] =\\n            graph[cat].length - (Arrays.stream(graph[cat]).anyMatch(v -> v == 0) ? 1 : 0);\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1881254,
                "title": "java-real-clean-code-bottom-up-bfs-minmax",
                "content": "It took me one day to understand the solution becaue of the poor naming in the given solution. I renamed and used best coding practices so everyone can understand the solution.\\n\\nWhat does it mean to name \"winners\" as \"colors\"?\\n```\\nclass Solution {\\n  int[][][] winners;\\n  \\n  final int MOUSE = 1, CAT = 2, NO_ONE = 0;\\n  final int HOLE = 0;\\n  final int[] TURNS = {MOUSE, CAT};\\n  \\n  public int catMouseGame(int[][] graph) {\\n    final int N = graph.length;\\n    int[][][] degress = buildDegree(graph, N);\\n\\n    Queue<State> queue = new LinkedList<>();\\n    winners = new int[N][N][3];\\n    \\n    for(int i = 0; i < N; i++){\\n      for(int turn : TURNS){\\n        State mouseWin = new State(HOLE, i, turn, MOUSE);\\n        setWinner(mouseWin);\\n        queue.offer(mouseWin);\\n        if (i != HOLE) {\\n          State catWin = new State(i, i, turn, CAT);\\n          setWinner(catWin);\\n          queue.offer(catWin);\\n        }\\n      }\\n    }\\n\\n    while(!queue.isEmpty()){\\n      State sub = queue.poll();\\n\\n      for(State cur : parents(graph, sub)){\\n        if(getWinner(cur) == NO_ONE){\\n          if(cur.turn == sub.winner){\\n            cur.winner = sub.winner;\\n          }else if(--degress[cur.mouse][cur.cat][cur.turn] == 0){\\n            cur.winner = 3 - cur.turn;\\n          }\\n          if (cur.winner != NO_ONE) {\\n            setWinner(cur);\\n            queue.offer(cur);\\n          }\\n        }\\n      }\\n    }\\n    return winners[1][2][MOUSE];\\n  }\\n\\n  private List<State> parents(int[][] graph, State sub) {\\n    List<State> parents = new LinkedList<>();\\n    if(sub.turn == CAT){\\n      for (int mouse : graph[sub.mouse]) {\\n        parents.add(new State(mouse, sub.cat, MOUSE, NO_ONE));\\n      }\\n    }else{\\n      for (int cat : graph[sub.cat]) {\\n        if (cat != HOLE) {\\n          parents.add(new State(sub.mouse, cat, CAT, NO_ONE));\\n        }\\n      }\\n    }\\n    return parents;\\n  }\\n  \\n  private int[][][] buildDegree(int[][] graph, int N){\\n    int[][][] degrees = new int[N][N][3];\\n    for(int m = 0; m < N; m++){\\n      for(int c = 0; c < N; c++){\\n        degrees[m][c][MOUSE] = graph[m].length;\\n        degrees[m][c][CAT] = graph[c].length;\\n      }\\n    }\\n    for(int c : graph[HOLE]){\\n      for(int m = 0; m < N; m++){\\n        degrees[m][c][CAT]--;\\n      }\\n    }\\n    return degrees;\\n  }\\n\\n  private int getWinner(State state){\\n    return winners[state.mouse][state.cat][state.turn];\\n  }\\n\\n  private void setWinner(State state){\\n     winners[state.mouse][state.cat][state.turn] = state.winner;\\n  }\\n\\n  private static class State{\\n    int mouse;\\n    int cat;\\n    int turn;\\n    int winner;\\n\\n    State(int mouse, int cat, int turn, int winner){\\n      this.mouse = mouse;\\n      this.cat = cat;\\n      this.turn = turn;\\n      this.winner = winner;\\n    }\\n  }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n  int[][][] winners;\\n  \\n  final int MOUSE = 1, CAT = 2, NO_ONE = 0;\\n  final int HOLE = 0;\\n  final int[] TURNS = {MOUSE, CAT}",
                "codeTag": "Java"
            },
            {
                "id": 1627290,
                "title": "dfs-memo-java-easy-to-understand-solution-with-comments",
                "content": "```\\nclass Solution {\\n    static HashMap<String, Integer> memo = new HashMap<>(); \\n    static int WIN = 1, LOSE = 2, DRAW = 0; // with respect to mouse\\n    public int catMouseGame(int[][] graph) {\\n        memo.clear();\\n        int mousePosition = 1, catPosition = 2, hole = 0, totalMoves = 0;\\n        return playRecurse(graph, mousePosition, catPosition, hole, totalMoves);\\n    }\\n    private static int playRecurse(int[][] graph, int mousePosition, int catPosition, int hole, int totalMoves) {\\n        if (totalMoves > 2 * graph.length) { \\n            // all nodes are visited, now if cat or mouse visit a node it would mean that they are repeating again and again to WIN.\\n\\t\\t\\treturn DRAW;\\n        }\\n        if (mousePosition == catPosition) {\\n            return LOSE;\\n        }\\n        if (mousePosition == hole) {\\n            return WIN;\\n        }\\n        \\n        String situation = mousePosition + \" \" + catPosition + \" \" + totalMoves;\\n        \\n        if (memo.containsKey(situation)) {\\n            return memo.get(situation);\\n        }\\n        \\n        if (totalMoves % 2 == 0) { // mouse turn\\n            // to check if we can draw the game, better than a lose\\n\\t\\t\\tboolean canDraw = false;\\n            \\n            for (int adjacentNode : graph[mousePosition]) {\\n                int playResult = playRecurse(graph, adjacentNode, catPosition, hole, totalMoves + 1);\\n                \\n                if (playResult == WIN) { // mouse wins\\n                    memo.put(situation, WIN);\\n                    return WIN;\\n                }\\n                \\n                if (playResult == DRAW) {\\n                    canDraw = true;\\n                }\\n            }\\n            \\n            if (canDraw) {\\n                memo.put(situation, DRAW);\\n                return DRAW;\\n            }\\n            \\n            memo.put(situation, LOSE);\\n            return LOSE; // cat wins\\n        }\\n        \\n        // cat turn\\n        boolean canDraw = false;\\n            \\n        for (int adjacentNode : graph[catPosition]) {\\n            if (adjacentNode == hole) {\\n                continue; // cat cannot travel to the Hole\\n            }\\n            \\n            int playResult = playRecurse(graph, mousePosition, adjacentNode, hole, totalMoves + 1);\\n                \\n            if (playResult == LOSE) {\\n                memo.put(situation, LOSE);\\n                return LOSE; // cat wins\\n            }\\n                \\n            if (playResult == DRAW) {\\n                canDraw = true;\\n            }\\n        }\\n            \\n        if (canDraw) {\\n            memo.put(situation, DRAW);\\n            return DRAW;\\n        }\\n            \\n        memo.put(situation, WIN);\\n        return WIN; // mouse wins\\n    }\\n}\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    static HashMap<String, Integer> memo = new HashMap<>(); \\n    static int WIN = 1, LOSE = 2, DRAW = 0; // with respect to mouse\\n    public int catMouseGame(int[][] graph) {\\n        memo.clear();\\n        int mousePosition = 1, catPosition = 2, hole = 0, totalMoves = 0;\\n        return playRecurse(graph, mousePosition, catPosition, hole, totalMoves);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1563154,
                "title": "python3-dp-minimax",
                "content": "\\n```\\nclass Solution:\\n    def catMouseGame(self, graph: List[List[int]]) -> int:\\n        n = len(graph)\\n        \\n        @cache\\n        def fn(i, m, c): \\n            \"\"\"Return \"\"\"\\n            if i == 2*n: return 0 # tie \\n            if m == 0: return 1 # mouse wins\\n            if m == c: return 2 # cat wins \\n            if i&1: # cat\\'s turn \\n                tie = 0 \\n                for cc in graph[c]: \\n                    if cc != 0: \\n                        x = fn(i+1, m, cc)\\n                        if x == 2: return 2 \\n                        if x == 0: tie = 1\\n                if tie: return 0 \\n                return 1\\n            else: # mouse\\'s turn \\n                tie = 0 \\n                for mm in graph[m]: \\n                    x = fn(i+1, mm, c)\\n                    if x == 1: return 1 \\n                    if x == 0: tie = 1\\n                if tie: return 0\\n                return 2 \\n        \\n        return fn(0, 1, 2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def catMouseGame(self, graph: List[List[int]]) -> int:\\n        n = len(graph)\\n        \\n        @cache\\n        def fn(i, m, c): \\n            \"\"\"Return \"\"\"\\n            if i == 2*n: return 0 # tie \\n            if m == 0: return 1 # mouse wins\\n            if m == c: return 2 # cat wins \\n            if i&1: # cat\\'s turn \\n                tie = 0 \\n                for cc in graph[c]: \\n                    if cc != 0: \\n                        x = fn(i+1, m, cc)\\n                        if x == 2: return 2 \\n                        if x == 0: tie = 1\\n                if tie: return 0 \\n                return 1\\n            else: # mouse\\'s turn \\n                tie = 0 \\n                for mm in graph[m]: \\n                    x = fn(i+1, mm, c)\\n                    if x == 1: return 1 \\n                    if x == 0: tie = 1\\n                if tie: return 0\\n                return 2 \\n        \\n        return fn(0, 1, 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1441050,
                "title": "simple-javascript-solution",
                "content": "The code is inspired from the following link.\\nIt is not the fast solution, but quite easy to understand and have small lines of code.\\nhttps://leetcode.com/problems/cat-and-mouse/discuss/298937/DP-memory-status-search-search-strait-forward-and-easy-to-understand\\n```\\nvar catMouseGame = function(graph) {\\n\\t// calculating the possible maximum turns, and because there are only two game players(mouse, cat),\\n\\t// we just multiply by 2 of the graph size\\n    const size = graph.length * 2 \\n    const cache = Array(size).fill(-1).map(a => Array(graph.length).fill(-1).map(aa => Array(graph.length).fill(-1)));\\n\\n    const check = (turn, x, y) => {\\n        if (turn >= size) return 0;\\n        if (x === y) return 2;\\n        if (x === 0) return 1;\\n        if (cache[turn][x][y] > -1) {\\n            return cache[turn][x][y];\\n        }\\n        if (turn % 2 === 0) { // Mouse turn\\n            let vals = [];\\n            for (let v of graph[x]) { // gathering all the result for mouse\\n                vals.push(check(turn+1, v, y));\\n            }\\n            if (vals.some(v => v === 1)) { // if any result returned 1, mouse win\\n                cache[turn][x][y] = 1;\\n                return 1;\\n            }\\n            if (vals.every(v => v === 2)) { // if all(every) result returned 2, cat win\\n                cache[turn][x][y] = 2;\\n                return 2;\\n            }\\n            cache[turn][x][y] = 0;\\n            return 0; // If it is not the above case, it is draw\\n\\t\\t\\t\\n        } else { // Cat turn\\n            let vals = [];\\n            for (let v of graph[y]) { // gathering all the result for cat\\n                if (v !== 0) {\\n                    vals.push(check(turn+1, x, v));\\n                }\\n            }\\n            if (vals.some(v => v === 2)) { // if any result returned 2, cat win\\n                cache[turn][x][y] = 2;\\n                return 2;\\n            }\\n            if (vals.every(v => v === 1)) { // if all(every) result returned 1, mouse win\\n                cache[turn][x][y] = 1;\\n                return 1;\\n            }\\n            cache[turn][x][y] = 0;\\n            return 0; // if it is not the above case, it is draw\\n        }\\n    };\\n    return check(0,1,2)\\n};",
                "solutionTags": [],
                "code": "The code is inspired from the following link.\\nIt is not the fast solution, but quite easy to understand and have small lines of code.\\nhttps://leetcode.com/problems/cat-and-mouse/discuss/298937/DP-memory-status-search-search-strait-forward-and-easy-to-understand\\n```\\nvar catMouseGame = function(graph) {\\n\\t// calculating the possible maximum turns, and because there are only two game players(mouse, cat),\\n\\t// we just multiply by 2 of the graph size\\n    const size = graph.length * 2 \\n    const cache = Array(size).fill(-1).map(a => Array(graph.length).fill(-1).map(aa => Array(graph.length).fill(-1)));\\n\\n    const check = (turn, x, y) => {\\n        if (turn >= size) return 0;\\n        if (x === y) return 2;\\n        if (x === 0) return 1;\\n        if (cache[turn][x][y] > -1) {\\n            return cache[turn][x][y];\\n        }\\n        if (turn % 2 === 0) { // Mouse turn\\n            let vals = [];\\n            for (let v of graph[x]) { // gathering all the result for mouse\\n                vals.push(check(turn+1, v, y));\\n            }\\n            if (vals.some(v => v === 1)) { // if any result returned 1, mouse win\\n                cache[turn][x][y] = 1;\\n                return 1;\\n            }\\n            if (vals.every(v => v === 2)) { // if all(every) result returned 2, cat win\\n                cache[turn][x][y] = 2;\\n                return 2;\\n            }\\n            cache[turn][x][y] = 0;\\n            return 0; // If it is not the above case, it is draw\\n\\t\\t\\t\\n        } else { // Cat turn\\n            let vals = [];\\n            for (let v of graph[y]) { // gathering all the result for cat\\n                if (v !== 0) {\\n                    vals.push(check(turn+1, x, v));\\n                }\\n            }\\n            if (vals.some(v => v === 2)) { // if any result returned 2, cat win\\n                cache[turn][x][y] = 2;\\n                return 2;\\n            }\\n            if (vals.every(v => v === 1)) { // if all(every) result returned 1, mouse win\\n                cache[turn][x][y] = 1;\\n                return 1;\\n            }\\n            cache[turn][x][y] = 0;\\n            return 0; // if it is not the above case, it is draw\\n        }\\n    };\\n    return check(0,1,2)\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1428933,
                "title": "javascript-dp",
                "content": "```\\nvar catMouseGame = function(graph) {\\n    let n = graph.length,\\n        dp = Array.from({ length: n }, _ =>\\n            Array.from({ length: n }, _ => Array(2 * n))\\n        );\\n\\n    // 0 when mouse starts, 1 when cat starts\\n\\n    const backTracking = (mouseIdx, catIdx, moves) => {\\n        if (mouseIdx === 0)\\n            return 1;\\n        if (mouseIdx === catIdx)\\n            return 2;\\n        if (moves >= n * 2)\\n            return 0;\\n        \\n        if (dp[mouseIdx][catIdx][moves] === undefined) {\\n            let nextMouseIdx = mouseIdx,\\n                nextCatIdx = catIdx,\\n                chance = 2;\\n\\n            for (const each of graph[(moves % 2) ? catIdx : mouseIdx]) {\\n                (moves % 2) ? nextCatIdx = each : nextMouseIdx = each;\\n                if (!nextCatIdx)\\n                    continue;\\n\\n                const value = backTracking(nextMouseIdx, nextCatIdx, moves + 1);\\n                if (value === (moves % 2) + 1)\\n                    return dp[mouseIdx][catIdx][moves] = value;\\n \\n                chance = Math.min(chance, value);\\n            }\\n            dp[mouseIdx][catIdx][moves] = chance;\\n        }\\n        return dp[mouseIdx][catIdx][moves];\\n    }\\n\\n    return backTracking(1, 2, 0);\\n};",
                "solutionTags": [],
                "code": "```\\nvar catMouseGame = function(graph) {\\n    let n = graph.length,\\n        dp = Array.from({ length: n }, _ =>\\n            Array.from({ length: n }, _ => Array(2 * n))\\n        );\\n\\n    // 0 when mouse starts, 1 when cat starts\\n\\n    const backTracking = (mouseIdx, catIdx, moves) => {\\n        if (mouseIdx === 0)\\n            return 1;\\n        if (mouseIdx === catIdx)\\n            return 2;\\n        if (moves >= n * 2)\\n            return 0;\\n        \\n        if (dp[mouseIdx][catIdx][moves] === undefined) {\\n            let nextMouseIdx = mouseIdx,\\n                nextCatIdx = catIdx,\\n                chance = 2;\\n\\n            for (const each of graph[(moves % 2) ? catIdx : mouseIdx]) {\\n                (moves % 2) ? nextCatIdx = each : nextMouseIdx = each;\\n                if (!nextCatIdx)\\n                    continue;\\n\\n                const value = backTracking(nextMouseIdx, nextCatIdx, moves + 1);\\n                if (value === (moves % 2) + 1)\\n                    return dp[mouseIdx][catIdx][moves] = value;\\n \\n                chance = Math.min(chance, value);\\n            }\\n            dp[mouseIdx][catIdx][moves] = chance;\\n        }\\n        return dp[mouseIdx][catIdx][moves];\\n    }\\n\\n    return backTracking(1, 2, 0);\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1353970,
                "title": "scala-beats-100-100",
                "content": "```\\nimport scala.annotation.tailrec\\n\\nsealed trait Player {\\n  def start: Int\\n}\\n\\ncase object Cat extends Player {\\n  override def start: Int = 2\\n}\\n\\ncase object Mouse extends Player {\\n  override def start: Int = 1\\n}\\n\\nsealed trait Result {\\n  def toInt: Int\\n}\\n\\ncase object Draw extends Result {\\n  override def toInt: Int = 0\\n}\\n\\nfinal case class Win(player: Player) extends Result {\\n  override def toInt: Int = player match {\\n    case Cat => 2\\n    case Mouse => 1\\n  }\\n}\\n\\nclass Lazy[+A](f: => A) {\\n  private lazy val elem = f\\n\\n  def get: A = elem\\n}\\n\\nobject Lazy {\\n  def apply[A](f: => A) = new Lazy(f)\\n}\\n\\nobject Solution {\\n  private val Hole = 0\\n\\n  def catMouseGame(graph: Array[Array[Int]]): Int = {\\n    lazy val results: IndexedSeq[IndexedSeq[IndexedSeq[Lazy[Result]]]] = IndexedSeq.tabulate(2 * graph.length + 1,\\n                                                                                             graph.length,\\n                                                                                             graph.length) {\\n      case (turn, _, _) if turn == 2 * graph.length => Lazy(Draw)\\n\\n      case (_, cat, mouse) if cat == mouse => Lazy(Win(Cat))\\n\\n      case (_, _, Hole) => Lazy(Win(Mouse))\\n\\n      // mouse to move\\n      case (turn, cat, mouse) if turn % 2 == 0 =>\\n        @tailrec\\n        def playOptimally(moves: Seq[Int], result: Result = Win(Cat)): Result = moves match {\\n          case Seq(head, tail@_*) => results(turn + 1)(cat)(head).get match {\\n            case Win(Mouse) => Win(Mouse)\\n            case Draw => playOptimally(tail, Draw)\\n            case _ => playOptimally(tail, result)\\n          }\\n          case _ => result\\n        }\\n\\n        Lazy(playOptimally(graph(mouse).toSeq))\\n\\n      // cat to move\\n      case (turn, cat, mouse) =>\\n        @tailrec\\n        def playOptimally(moves: Seq[Int], result: Result = Win(Mouse)): Result = moves match {\\n          // cat cannot move to the hole\\n          case Seq(Hole, tail@_*) => playOptimally(tail, result)\\n          case Seq(head, tail@_*) => results(turn + 1)(head)(mouse).get match {\\n            case Win(Cat) => Win(Cat)\\n            case Draw => playOptimally(tail, Draw)\\n            case _ => playOptimally(tail, result)\\n          }\\n          case _ => result\\n        }\\n\\n        Lazy(playOptimally(graph(cat).toSeq))\\n    }\\n\\n    results(0)(Cat.start)(Mouse.start).get.toInt\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport scala.annotation.tailrec\\n\\nsealed trait Player {\\n  def start: Int\\n}\\n\\ncase object Cat extends Player {\\n  override def start: Int = 2\\n}\\n\\ncase object Mouse extends Player {\\n  override def start: Int = 1\\n}\\n\\nsealed trait Result {\\n  def toInt: Int\\n}\\n\\ncase object Draw extends Result {\\n  override def toInt: Int = 0\\n}\\n\\nfinal case class Win(player: Player) extends Result {\\n  override def toInt: Int = player match {\\n    case Cat => 2\\n    case Mouse => 1\\n  }\\n}\\n\\nclass Lazy[+A](f: => A) {\\n  private lazy val elem = f\\n\\n  def get: A = elem\\n}\\n\\nobject Lazy {\\n  def apply[A](f: => A) = new Lazy(f)\\n}\\n\\nobject Solution {\\n  private val Hole = 0\\n\\n  def catMouseGame(graph: Array[Array[Int]]): Int = {\\n    lazy val results: IndexedSeq[IndexedSeq[IndexedSeq[Lazy[Result]]]] = IndexedSeq.tabulate(2 * graph.length + 1,\\n                                                                                             graph.length,\\n                                                                                             graph.length) {\\n      case (turn, _, _) if turn == 2 * graph.length => Lazy(Draw)\\n\\n      case (_, cat, mouse) if cat == mouse => Lazy(Win(Cat))\\n\\n      case (_, _, Hole) => Lazy(Win(Mouse))\\n\\n      // mouse to move\\n      case (turn, cat, mouse) if turn % 2 == 0 =>\\n        @tailrec\\n        def playOptimally(moves: Seq[Int], result: Result = Win(Cat)): Result = moves match {\\n          case Seq(head, tail@_*) => results(turn + 1)(cat)(head).get match {\\n            case Win(Mouse) => Win(Mouse)\\n            case Draw => playOptimally(tail, Draw)\\n            case _ => playOptimally(tail, result)\\n          }\\n          case _ => result\\n        }\\n\\n        Lazy(playOptimally(graph(mouse).toSeq))\\n\\n      // cat to move\\n      case (turn, cat, mouse) =>\\n        @tailrec\\n        def playOptimally(moves: Seq[Int], result: Result = Win(Mouse)): Result = moves match {\\n          // cat cannot move to the hole\\n          case Seq(Hole, tail@_*) => playOptimally(tail, result)\\n          case Seq(head, tail@_*) => results(turn + 1)(head)(mouse).get match {\\n            case Win(Cat) => Win(Cat)\\n            case Draw => playOptimally(tail, Draw)\\n            case _ => playOptimally(tail, result)\\n          }\\n          case _ => result\\n        }\\n\\n        Lazy(playOptimally(graph(cat).toSeq))\\n    }\\n\\n    results(0)(Cat.start)(Mouse.start).get.toInt\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1025929,
                "title": "java-dfs-with-memoization",
                "content": "```\\nclass Solution {\\n    public int catMouseGame(int[][] graph) {\\n        int n = graph.length;\\n        int[][][] dp = new int[2 * n][n][n];\\n        for (int[][] nums : dp) {\\n            for (int[] arr : nums) {\\n                Arrays.fill(arr, -1);\\n            }\\n        }\\n        return dfs(graph, 0, 1, 2, dp);\\n    }\\n    //\\u5047\\u8BBE\\u56FE\\u4E2D\\u6709n\\u4E2A\\u7ED3\\u70B9\\uFF0C\\u4E0D\\u8BBA\\u662F\\u732B\\u8FD8\\u662F\\u8001\\u9F20\\uFF0C\\u5F53\\u5404\\u81EA\\u8D70\\u5B8C\\u4E86n\\u4E2A\\u7ED3\\u70B9\\u65F6\\u8FD8\\u6CA1\\u6709\\u5206\\u51FA\\u80DC\\u8D1F\\uFF0C\\u5219\\u8868\\u793A\\u5E73\\u5C40\\uFF0C\\u82E5\\u4E00\\u4EBA\\u8D70\\u4E00\\u6B65\\uFF0C\\u5219\\u6700\\u591A\\u6709 2n \\u6B65\\u3002\\u8FD9\\u6837\\u7684\\u8BDD\\u6BCF\\u4E00\\u4E2A\\u72B6\\u6001\\u5B9E\\u9645\\u4E0A\\u662F\\u7531\\u4E09\\u4E2A\\u56E0\\u7D20\\u7EC4\\u6210\\u7684\\uFF1A\\u5F53\\u524D\\u6B65\\u6570\\uFF0C\\u8001\\u9F20\\u6240\\u5728\\u7ED3\\u70B9\\uFF0C\\u548C\\u732B\\u6240\\u5728\\u7ED3\\u70B9\\u3002 https://www.cnblogs.com/grandyang/p/11515655.html\\n    // t: steps, x: mouse position, y: cat position\\n    public int dfs(int[][] graph, int t, int x, int y, int[][][] dp) {\\n        if (t == graph.length * 2) return 0;\\n        if (x == y) return 2;\\n        if (x == 0) return 1;\\n        if (dp[t][x][y] != -1) return dp[t][x][y];\\n        boolean mouseTurn = (t % 2) == 0;\\n        if (mouseTurn) {\\n            boolean catWin = true;\\n            for (int p : graph[x]) {\\n                int next = dfs(graph, t + 1, p, y, dp);\\n                if (next == 1) {\\n                    return dp[t][x][y] = 1;\\n                }\\n                if (next == 0) {\\n                    catWin = false;\\n                }\\n            }\\n            if (catWin) {\\n                return dp[t][x][y] = 2;\\n            } else {\\n                return dp[t][x][y] = 0;\\n            }\\n        } else {\\n            boolean mouseWin = true;\\n            for (int p : graph[y]) {\\n                if (p == 0) continue;\\n                int next = dfs(graph, t + 1, x, p, dp);\\n                if (next == 2) {\\n                    return dp[t][x][y] = 2;\\n                }\\n                if (next == 0) {\\n                    mouseWin = false;\\n                }\\n            }\\n            if (mouseWin) {\\n                return dp[t][x][y] = 1;\\n            } else {\\n                return dp[t][x][y] = 0;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int catMouseGame(int[][] graph) {\\n        int n = graph.length;\\n        int[][][] dp = new int[2 * n][n][n];\\n        for (int[][] nums : dp) {\\n            for (int[] arr : nums) {\\n                Arrays.fill(arr, -1);\\n            }\\n        }\\n        return dfs(graph, 0, 1, 2, dp);\\n    }\\n    //\\u5047\\u8BBE\\u56FE\\u4E2D\\u6709n\\u4E2A\\u7ED3\\u70B9\\uFF0C\\u4E0D\\u8BBA\\u662F\\u732B\\u8FD8\\u662F\\u8001\\u9F20\\uFF0C\\u5F53\\u5404\\u81EA\\u8D70\\u5B8C\\u4E86n\\u4E2A\\u7ED3\\u70B9\\u65F6\\u8FD8\\u6CA1\\u6709\\u5206\\u51FA\\u80DC\\u8D1F\\uFF0C\\u5219\\u8868\\u793A\\u5E73\\u5C40\\uFF0C\\u82E5\\u4E00\\u4EBA\\u8D70\\u4E00\\u6B65\\uFF0C\\u5219\\u6700\\u591A\\u6709 2n \\u6B65\\u3002\\u8FD9\\u6837\\u7684\\u8BDD\\u6BCF\\u4E00\\u4E2A\\u72B6\\u6001\\u5B9E\\u9645\\u4E0A\\u662F\\u7531\\u4E09\\u4E2A\\u56E0\\u7D20\\u7EC4\\u6210\\u7684\\uFF1A\\u5F53\\u524D\\u6B65\\u6570\\uFF0C\\u8001\\u9F20\\u6240\\u5728\\u7ED3\\u70B9\\uFF0C\\u548C\\u732B\\u6240\\u5728\\u7ED3\\u70B9\\u3002 https://www.cnblogs.com/grandyang/p/11515655.html\\n    // t: steps, x: mouse position, y: cat position\\n    public int dfs(int[][] graph, int t, int x, int y, int[][][] dp) {\\n        if (t == graph.length * 2) return 0;\\n        if (x == y) return 2;\\n        if (x == 0) return 1;\\n        if (dp[t][x][y] != -1) return dp[t][x][y];\\n        boolean mouseTurn = (t % 2) == 0;\\n        if (mouseTurn) {\\n            boolean catWin = true;\\n            for (int p : graph[x]) {\\n                int next = dfs(graph, t + 1, p, y, dp);\\n                if (next == 1) {\\n                    return dp[t][x][y] = 1;\\n                }\\n                if (next == 0) {\\n                    catWin = false;\\n                }\\n            }\\n            if (catWin) {\\n                return dp[t][x][y] = 2;\\n            } else {\\n                return dp[t][x][y] = 0;\\n            }\\n        } else {\\n            boolean mouseWin = true;\\n            for (int p : graph[y]) {\\n                if (p == 0) continue;\\n                int next = dfs(graph, t + 1, x, p, dp);\\n                if (next == 2) {\\n                    return dp[t][x][y] = 2;\\n                }\\n                if (next == 0) {\\n                    mouseWin = false;\\n                }\\n            }\\n            if (mouseWin) {\\n                return dp[t][x][y] = 1;\\n            } else {\\n                return dp[t][x][y] = 0;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941062,
                "title": "c-trying-to-explain-this-using-finite-state-machine-topology-sorting",
                "content": "This is inspired by https://leetcode.com/problems/cat-and-mouse/discuss/298937/DP-memory-status-search-search-strait-forward-and-easy-to-understand, except I don\\'t try 2N steps, stop where no furether progress is possible.\\n\\nFurther optimization possible.\\n\\n1. Finit States\\nSo, the game can only be in a finite number of states, identified by 3 variables:\\n\\n(mouse /*mouse position*/, cat /*cat position*/, mouseMove /*if mouse should make the next move*/)\\n\\nFor example, the initial state is:\\n(1, 2, True)\\n\\nEach state can transition to a number of other states:\\n\\nFor example:\\n(1, 2, True) -> (3, 2, False) ...\\n\\nCause the space of this problem is finite, only finite number of states should be calculated.\\n\\n\\n2. Unknown and known states\\n\\nFor a few states, we easyly know if cat wins or mouse wins, for example:\\n\\n(0, 3, False) -> mouse wins\\n(1, 1, True) -> cat wins\\n\\nMost states are uknown at the begining. But using the known states as seeds, we can know more states step by step, until we reach the initial stae (1, 2, True). If (1, 2, True) is known, we have the answer. It is possible that no clean path to (1, 2, True), that means, there is a loop dependency in unknown states. In that case, the game end in a draw.\\n\\n3. Topology sorting (just an idea, I didn\\'t implement this part)\\nIt should be totally possible to build a dependency graph, and solve those states who don\\'t depend on uknowns, therefore further optimize this algorithm. However this is already complicate enough, during an interview let\\'s go no further unless asked to.\\n\\n\\n\\n```\\npublic class Solution {\\n    private Dictionary<Tuple<int, int, bool>, int> map = new Dictionary<Tuple<int, int, bool>, int> ();\\n    private int[][] graph;\\n    \\n    // Try a unknown state,best effort\\n    private int TryMove(Tuple<int, int, bool> state) {\\n        \\n        (var mouse, var cat, var mouseMove) = state;\\n        \\n        if (mouse == 0)\\n            map[state]= 1;\\n        \\n        if (cat == mouse)\\n            map[state] =2;\\n        \\n\\n        if(map.ContainsKey(state)) {\\n            if (map[state] >= 0){\\n                return map[state];\\n            }\\n            else {\\n                // If this state has been tried before, still not solved, then don\\'t attempt to solve it now to avoid infinite loop\\n                return -1;\\n            }\\n        }\\n        else {\\n            // If a new state is introduced, mark it as unknown. We\\'ll attempt to solve it in this call, but if we cannot,\\n            // feel free to leave it to the next loop\\n            map[state] = -1;\\n        }\\n        \\n        if (mouseMove) {\\n            var results = graph[mouse].Select( n => TryMove(new Tuple<int, int, bool>(n, cat, false))).Distinct();\\n            if (results.Contains(1)) {\\n                map[state] = 1;\\n            }\\n            else if (results.Contains(-1)) {\\n                map[state] = -1;\\n            }\\n            else {\\n                map[state] = 2;\\n            }\\n        }\\n        else {\\n            var results = graph[cat].Where( n => n != 0).Select( n => TryMove(new Tuple<int, int, bool>(mouse, n, true))).Distinct();\\n            if (results.Contains(2)) {\\n                map[state] = 2;\\n            }\\n            else if (results.Contains(-1)) {\\n                map[state] = -1;\\n            }\\n            else {\\n                map[state] = 1;\\n            }\\n        }\\n        \\n        return map[state];\\n    }\\n\\n    public int CatMouseGame(int[][] graph) {\\n        this.graph = graph;\\n        \\n        var keyCount = 0;\\n        var unknownCount = 0;\\n        map[new Tuple<int, int, bool>(1,2,true)] = -1; // Initial state\\n        \\n       \\n        do{\\n            keyCount = map.Keys.Count();\\n            unknownCount = map.Values.Where(x => x == -1).Count();\\n            \\n            var todo = map.Where( x => x.Value == -1).ToList();\\n            // Just try to reoslve all unsolved states - it is possible to use topology sorting to find out which \\n            // unsolved state only depend on known states, only try those, therefore further optimize this\\n            // algorithm\\n            foreach (var kvp in todo){\\n                map.Remove(kvp.Key);\\n                TryMove(kvp.Key);\\n            }\\n            \\n            if (map[new Tuple<int, int, bool>(1,2,true)] >= 0)\\n                return map[new Tuple<int, int, bool>(1,2,true)];\\n\\t\\t // Keep trying as long as we\\'re making progress\\n\\t\\t // If we introduce new keys, or solve any unknown state, that means we\\'re making progress\\n        } while (keyCount != map.Keys.Count() || unknownCount != map.Values.Where(x => x == -1).Count());\\n        \\n       \\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    private Dictionary<Tuple<int, int, bool>, int> map = new Dictionary<Tuple<int, int, bool>, int> ();\\n    private int[][] graph;\\n    \\n    // Try a unknown state,best effort\\n    private int TryMove(Tuple<int, int, bool> state) {\\n        \\n        (var mouse, var cat, var mouseMove) = state;\\n        \\n        if (mouse == 0)\\n            map[state]= 1;\\n        \\n        if (cat == mouse)\\n            map[state] =2;\\n        \\n\\n        if(map.ContainsKey(state)) {\\n            if (map[state] >= 0){\\n                return map[state];\\n            }\\n            else {\\n                // If this state has been tried before, still not solved, then don\\'t attempt to solve it now to avoid infinite loop\\n                return -1;\\n            }\\n        }\\n        else {\\n            // If a new state is introduced, mark it as unknown. We\\'ll attempt to solve it in this call, but if we cannot,\\n            // feel free to leave it to the next loop\\n            map[state] = -1;\\n        }\\n        \\n        if (mouseMove) {\\n            var results = graph[mouse].Select( n => TryMove(new Tuple<int, int, bool>(n, cat, false))).Distinct();\\n            if (results.Contains(1)) {\\n                map[state] = 1;\\n            }\\n            else if (results.Contains(-1)) {\\n                map[state] = -1;\\n            }\\n            else {\\n                map[state] = 2;\\n            }\\n        }\\n        else {\\n            var results = graph[cat].Where( n => n != 0).Select( n => TryMove(new Tuple<int, int, bool>(mouse, n, true))).Distinct();\\n            if (results.Contains(2)) {\\n                map[state] = 2;\\n            }\\n            else if (results.Contains(-1)) {\\n                map[state] = -1;\\n            }\\n            else {\\n                map[state] = 1;\\n            }\\n        }\\n        \\n        return map[state];\\n    }\\n\\n    public int CatMouseGame(int[][] graph) {\\n        this.graph = graph;\\n        \\n        var keyCount = 0;\\n        var unknownCount = 0;\\n        map[new Tuple<int, int, bool>(1,2,true)] = -1; // Initial state\\n        \\n       \\n        do{\\n            keyCount = map.Keys.Count();\\n            unknownCount = map.Values.Where(x => x == -1).Count();\\n            \\n            var todo = map.Where( x => x.Value == -1).ToList();\\n            // Just try to reoslve all unsolved states - it is possible to use topology sorting to find out which \\n            // unsolved state only depend on known states, only try those, therefore further optimize this\\n            // algorithm\\n            foreach (var kvp in todo){\\n                map.Remove(kvp.Key);\\n                TryMove(kvp.Key);\\n            }\\n            \\n            if (map[new Tuple<int, int, bool>(1,2,true)] >= 0)\\n                return map[new Tuple<int, int, bool>(1,2,true)];\\n\\t\\t // Keep trying as long as we\\'re making progress\\n\\t\\t // If we introduce new keys, or solve any unknown state, that means we\\'re making progress\\n        } while (keyCount != map.Keys.Count() || unknownCount != map.Values.Where(x => x == -1).Count());\\n        \\n       \\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 895074,
                "title": "c-36ms-o-n-3",
                "content": "Based on Errichto\\'s solution [link](https://leetcode.com/problems/cat-and-mouse/discuss/507706/C%2B%2B-map-solution-in-O(N*M*log(N))) \\n\\n```\\nstatic auto speedup = []() {\\n    ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return nullptr;\\n}();\\n\\nclass Solution {\\npublic:\\n    vector<vector<vector<int>>> dp;\\n    vector<vector<vector<int>>> out_degree;\\n    vector<int> cat_degree;\\n    \\n    void recur(vector<vector<int>> &graph, int mouse, int cat, int turn, int result){\\n        if (dp[turn][mouse][cat]!=0) return;\\n        // cout<<turn<<\" \"<<mouse<<\" \"<<cat<<\" \"<<(result==1?\"Mouse\":\"Cat\")<<endl;\\n        dp[turn][mouse][cat]=result;\\n        if (turn){\\n            turn=0;\\n            for (int j:graph[mouse]){\\n                if (j==0 || j==cat){\\n                    continue;\\n                }\\n                if (result==1){\\n                    recur(graph, j, cat, turn, result);\\n                }\\n                else{\\n                    out_degree[turn][j][cat]++;\\n                    if (out_degree[turn][j][cat]==graph[j].size()) recur(graph, j, cat, turn, 2);\\n                }\\n            }\\n        }\\n        else{\\n            turn=1;\\n            for (int j:graph[cat]){\\n                if (j==0 || j==mouse){\\n                    continue;\\n                }\\n                if (result==2){\\n                    recur(graph, mouse, j, turn, result);\\n                }\\n                else{\\n                    out_degree[turn][mouse][j]++;\\n                    if (out_degree[turn][mouse][j]==cat_degree[j]) recur(graph, mouse, j, turn, 1);\\n                }\\n            }\\n        }\\n    }\\n    \\n    int catMouseGame(vector<vector<int>>& graph) {\\n        int n=graph.size();\\n        cat_degree=vector<int> (n);\\n        dp=vector<vector<vector<int>>>(2, vector<vector<int>>(n, vector<int>(n, 0)));\\n        out_degree=vector<vector<vector<int>>>(2, vector<vector<int>>(n, vector<int>(n, 0)));;\\n        \\n        for (int i=1; i<n; ++i){\\n            cat_degree[i]=graph[i].size();\\n        }\\n        for (int i:graph[0]) cat_degree[i]--;\\n        \\n        \\n        for (int i=1; i<n; ++i){\\n            for (int turn:{0, 1}){\\n                recur(graph, 0, i, turn, 1);\\n                recur(graph, i, i, turn, 2);\\n            }\\n        }\\n        return dp[0][1][2];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstatic auto speedup = []() {\\n    ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return nullptr;\\n}();\\n\\nclass Solution {\\npublic:\\n    vector<vector<vector<int>>> dp;\\n    vector<vector<vector<int>>> out_degree;\\n    vector<int> cat_degree;\\n    \\n    void recur(vector<vector<int>> &graph, int mouse, int cat, int turn, int result){\\n        if (dp[turn][mouse][cat]!=0) return;\\n        // cout<<turn<<\" \"<<mouse<<\" \"<<cat<<\" \"<<(result==1?\"Mouse\":\"Cat\")<<endl;\\n        dp[turn][mouse][cat]=result;\\n        if (turn){\\n            turn=0;\\n            for (int j:graph[mouse]){\\n                if (j==0 || j==cat){\\n                    continue;\\n                }\\n                if (result==1){\\n                    recur(graph, j, cat, turn, result);\\n                }\\n                else{\\n                    out_degree[turn][j][cat]++;\\n                    if (out_degree[turn][j][cat]==graph[j].size()) recur(graph, j, cat, turn, 2);\\n                }\\n            }\\n        }\\n        else{\\n            turn=1;\\n            for (int j:graph[cat]){\\n                if (j==0 || j==mouse){\\n                    continue;\\n                }\\n                if (result==2){\\n                    recur(graph, mouse, j, turn, result);\\n                }\\n                else{\\n                    out_degree[turn][mouse][j]++;\\n                    if (out_degree[turn][mouse][j]==cat_degree[j]) recur(graph, mouse, j, turn, 1);\\n                }\\n            }\\n        }\\n    }\\n    \\n    int catMouseGame(vector<vector<int>>& graph) {\\n        int n=graph.size();\\n        cat_degree=vector<int> (n);\\n        dp=vector<vector<vector<int>>>(2, vector<vector<int>>(n, vector<int>(n, 0)));\\n        out_degree=vector<vector<vector<int>>>(2, vector<vector<int>>(n, vector<int>(n, 0)));;\\n        \\n        for (int i=1; i<n; ++i){\\n            cat_degree[i]=graph[i].size();\\n        }\\n        for (int i:graph[0]) cat_degree[i]--;\\n        \\n        \\n        for (int i=1; i<n; ++i){\\n            for (int turn:{0, 1}){\\n                recur(graph, 0, i, turn, 1);\\n                recur(graph, i, i, turn, 2);\\n            }\\n        }\\n        return dp[0][1][2];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 864412,
                "title": "cpp14-solution-dfs-dp",
                "content": "Great explanation : https://leetcode.com/problems/cat-and-mouse/discuss/298937/DP-memory-status-search-search-strait-forward-and-easy-to-understand\\n\\nhttps://www.acwing.com/solution/leetcode/content/556\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[105][52][52];\\n\\n    int solve(vector<vector<int>> &g , int steps , int mouseposition , int catposition)\\n    {\\n        int n = g.size();\\n        if(steps >= 2*n) return dp[steps][mouseposition][catposition] = 0;\\n        if(mouseposition==catposition) return dp[steps][mouseposition][catposition] = 2;\\n        if(mouseposition==0) return dp[steps][mouseposition][catposition] = 1;\\n        if(dp[steps][mouseposition][catposition] != -1) return dp[steps][mouseposition][catposition];\\n        int turn = steps%2;\\n        if(turn == 0){\\n            bool flag = true;\\n            for(int i = 0 ; i < g[mouseposition].size() ; ++i){\\n                int next = solve(g , steps + 1 , g[mouseposition][i] , catposition);\\n                if(next == 1) return dp[steps][mouseposition][catposition] = 1;\\n                else if(next != 2) flag = false;\\n            }\\n            if(flag) return dp[steps][mouseposition][catposition] = 2;\\n            else return dp[steps][mouseposition][catposition] = 0;\\n        }\\n        else if(turn == 1){\\n            bool flag = true;\\n            for(int i = 0 ; i < g[catposition].size() ; ++i){\\n                if(g[catposition][i] != 0){\\n                  int next = solve(g , steps + 1 , mouseposition , g[catposition][i]) ;\\n                if(next == 2) return dp[steps][mouseposition][catposition] = 2;\\n                else if(next != 1) flag = false;\\n                }\\n            }\\n            if(flag) return dp[steps][mouseposition][catposition] = 1;\\n            else return dp[steps][mouseposition][catposition] = 0;\\n        }\\n        return dp[steps][mouseposition][catposition];\\n    }\\n\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        memset(dp,-1,sizeof dp);\\n        int n = graph.size();\\n        return solve(graph,0,1,2);\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[105][52][52];\\n\\n    int solve(vector<vector<int>> &g , int steps , int mouseposition , int catposition)\\n    {\\n        int n = g.size();\\n        if(steps >= 2*n) return dp[steps][mouseposition][catposition] = 0;\\n        if(mouseposition==catposition) return dp[steps][mouseposition][catposition] = 2;\\n        if(mouseposition==0) return dp[steps][mouseposition][catposition] = 1;\\n        if(dp[steps][mouseposition][catposition] != -1) return dp[steps][mouseposition][catposition];\\n        int turn = steps%2;\\n        if(turn == 0){\\n            bool flag = true;\\n            for(int i = 0 ; i < g[mouseposition].size() ; ++i){\\n                int next = solve(g , steps + 1 , g[mouseposition][i] , catposition);\\n                if(next == 1) return dp[steps][mouseposition][catposition] = 1;\\n                else if(next != 2) flag = false;\\n            }\\n            if(flag) return dp[steps][mouseposition][catposition] = 2;\\n            else return dp[steps][mouseposition][catposition] = 0;\\n        }\\n        else if(turn == 1){\\n            bool flag = true;\\n            for(int i = 0 ; i < g[catposition].size() ; ++i){\\n                if(g[catposition][i] != 0){\\n                  int next = solve(g , steps + 1 , mouseposition , g[catposition][i]) ;\\n                if(next == 2) return dp[steps][mouseposition][catposition] = 2;\\n                else if(next != 1) flag = false;\\n                }\\n            }\\n            if(flag) return dp[steps][mouseposition][catposition] = 1;\\n            else return dp[steps][mouseposition][catposition] = 0;\\n        }\\n        return dp[steps][mouseposition][catposition];\\n    }\\n\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        memset(dp,-1,sizeof dp);\\n        int n = graph.size();\\n        return solve(graph,0,1,2);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843054,
                "title": "rust-translated-52ms-100",
                "content": "```rust\\nconst DRAW: i32 = 0;\\nconst MOUSE: i32 = 1;\\nconst CAT: i32 = 2;\\n\\nimpl Solution {\\n    pub fn cat_mouse_game(graph: Vec<Vec<i32>>) -> i32 {\\n        use std::collections::VecDeque;\\n\\n        fn parents(graph: &Vec<Vec<i32>>, m: i32, c: i32, t: i32) -> Vec<Vec<i32>> {\\n            let mut ans = vec![];\\n            if t == 2 {\\n                for &m2 in &graph[m as usize] {\\n                    ans.push(vec![m2, c, 3 - t]);\\n                }\\n            } else {\\n                for &c2 in &graph[c as usize] {\\n                    if c2 > 0 {\\n                        ans.push(vec![m, c2, 3 - t]);\\n                    }\\n                }\\n            }\\n            ans\\n        }\\n\\n        let n = graph.len();\\n\\n        let mut color = vec![vec![vec![0; 3]; 50]; 50];\\n        let mut degree = vec![vec![vec![0; 3]; 50]; 50];\\n\\n        for m in 0..n {\\n            for c in 0..n {\\n                degree[m][c][1] = graph[m].len();\\n                degree[m][c][2] = graph[c].len();\\n                for &x in &graph[c] {\\n                    if x == 0 {\\n                        degree[m][c][2] -= 1;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n\\n        let mut queue = VecDeque::<Vec<i32>>::new();\\n        for i in 0..n {\\n            for t in 1..3 {\\n                color[0][i][t] = MOUSE;\\n                queue.push_back(vec![0, i as i32, t as i32, MOUSE]);\\n                if i > 0 {\\n                    color[i][i][t] = CAT;\\n                    queue.push_back(vec![i as i32, i as i32, t as i32, CAT]);\\n                }\\n            }\\n        }\\n\\n        while !queue.is_empty() {\\n            // for nodes that are colored :\\n            let node = queue.pop_front().unwrap();\\n            let i = node[0];\\n            let j = node[1];\\n            let t = node[2];\\n            let c = node[3];\\n            // for every parent of this node i, j, t :\\n            for parent in parents(&graph, i, j, t) {\\n                let i2 = parent[0];\\n                let j2 = parent[1];\\n                let t2 = parent[2];\\n                // if this parent is not colored :\\n                if color[i2 as usize][j2 as usize][t2 as usize] == DRAW {\\n                    // if the parent can make a winning move (ie. mouse to MOUSE), do so\\n                    if t2 == c {\\n                        color[i2 as usize][j2 as usize][t2 as usize] = c;\\n                        queue.push_back(vec![i2, j2, t2, c]);\\n                    } else {\\n                        // else, this parent has degree[parent]--, and enqueue\\n                        // if all children of this parent are colored as losing moves\\n                        degree[i2 as usize][j2 as usize][t2 as usize] -= 1;\\n                        if degree[i2 as usize][j2 as usize][t2 as usize] == 0 {\\n                            color[i2 as usize][j2 as usize][t2 as usize] = 3 - t2;\\n                            queue.push_back(vec![i2, j2, t2, 3 - t2]);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n//        println!(\"{:?}\", color);\\n        color[1][2][1]\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_cat_mouse_game() {\\n        assert_eq!(\\n            Solution::cat_mouse_game(vec![\\n                vec![2, 5],\\n                vec![3],\\n                vec![0, 4, 5],\\n                vec![1, 4, 5],\\n                vec![2, 3],\\n                vec![0, 2, 3]\\n            ]),\\n            0\\n        );\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nconst DRAW: i32 = 0;\\nconst MOUSE: i32 = 1;\\nconst CAT: i32 = 2;\\n\\nimpl Solution {\\n    pub fn cat_mouse_game(graph: Vec<Vec<i32>>) -> i32 {\\n        use std::collections::VecDeque;\\n\\n        fn parents(graph: &Vec<Vec<i32>>, m: i32, c: i32, t: i32) -> Vec<Vec<i32>> {\\n            let mut ans = vec![];\\n            if t == 2 {\\n                for &m2 in &graph[m as usize] {\\n                    ans.push(vec![m2, c, 3 - t]);\\n                }\\n            } else {\\n                for &c2 in &graph[c as usize] {\\n                    if c2 > 0 {\\n                        ans.push(vec![m, c2, 3 - t]);\\n                    }\\n                }\\n            }\\n            ans\\n        }\\n\\n        let n = graph.len();\\n\\n        let mut color = vec![vec![vec![0; 3]; 50]; 50];\\n        let mut degree = vec![vec![vec![0; 3]; 50]; 50];\\n\\n        for m in 0..n {\\n            for c in 0..n {\\n                degree[m][c][1] = graph[m].len();\\n                degree[m][c][2] = graph[c].len();\\n                for &x in &graph[c] {\\n                    if x == 0 {\\n                        degree[m][c][2] -= 1;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n\\n        let mut queue = VecDeque::<Vec<i32>>::new();\\n        for i in 0..n {\\n            for t in 1..3 {\\n                color[0][i][t] = MOUSE;\\n                queue.push_back(vec![0, i as i32, t as i32, MOUSE]);\\n                if i > 0 {\\n                    color[i][i][t] = CAT;\\n                    queue.push_back(vec![i as i32, i as i32, t as i32, CAT]);\\n                }\\n            }\\n        }\\n\\n        while !queue.is_empty() {\\n            // for nodes that are colored :\\n            let node = queue.pop_front().unwrap();\\n            let i = node[0];\\n            let j = node[1];\\n            let t = node[2];\\n            let c = node[3];\\n            // for every parent of this node i, j, t :\\n            for parent in parents(&graph, i, j, t) {\\n                let i2 = parent[0];\\n                let j2 = parent[1];\\n                let t2 = parent[2];\\n                // if this parent is not colored :\\n                if color[i2 as usize][j2 as usize][t2 as usize] == DRAW {\\n                    // if the parent can make a winning move (ie. mouse to MOUSE), do so\\n                    if t2 == c {\\n                        color[i2 as usize][j2 as usize][t2 as usize] = c;\\n                        queue.push_back(vec![i2, j2, t2, c]);\\n                    } else {\\n                        // else, this parent has degree[parent]--, and enqueue\\n                        // if all children of this parent are colored as losing moves\\n                        degree[i2 as usize][j2 as usize][t2 as usize] -= 1;\\n                        if degree[i2 as usize][j2 as usize][t2 as usize] == 0 {\\n                            color[i2 as usize][j2 as usize][t2 as usize] = 3 - t2;\\n                            queue.push_back(vec![i2, j2, t2, 3 - t2]);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n//        println!(\"{:?}\", color);\\n        color[1][2][1]\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_cat_mouse_game() {\\n        assert_eq!(\\n            Solution::cat_mouse_game(vec![\\n                vec![2, 5],\\n                vec![3],\\n                vec![0, 4, 5],\\n                vec![1, 4, 5],\\n                vec![2, 3],\\n                vec![0, 2, 3]\\n            ]),\\n            0\\n        );\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 841558,
                "title": "always-draw",
                "content": "I don\\'t get it. If two players play optimals, and if both can predict the next move of their enemy, so the player who knows that he is going to lose can just go back to the previous position ---> Game draw!!!\\n",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 835247,
                "title": "super-easy-python",
                "content": "1.  Cat wins if cat is on the mouse position on it\\'s move\\n2.  Mouse wins if mouse will reach Hole on it\\'s move\\n3.  otherwise, after 2n steps , It is draw \\n4.  Time and space complexity are 0(n^3), \\n```\\nclass Solution:\\n    def catMouseGame(self, graph: List[List[int]]) -> int:\\n        @functools.lru_cache(maxsize=None)\\n        def move(mouse, cat, turn):\\n            if turn >= len(graph)*2: return 0\\n            if turn % 2:\\n                ans = 2\\n                for position in graph[mouse]:\\n                    if position == cat: continue\\n                    if position == 0: return 1\\n                    result = move(position, cat, turn+1)\\n                    if result == 1: return 1\\n                    if result == 0: ans=0\\n                return ans\\n            else:\\n                ans = 1\\n                for position in graph[cat]:\\n                    if position == 0: continue\\n                    if position == mouse: return 2\\n                    result = move(mouse, position, turn+1)\\n                    if result == 2: return 2\\n                    if result == 0: ans = 0\\n                return ans\\n        return move(1,2,1)\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def catMouseGame(self, graph: List[List[int]]) -> int:\\n        @functools.lru_cache(maxsize=None)\\n        def move(mouse, cat, turn):\\n            if turn >= len(graph)*2: return 0\\n            if turn % 2:\\n                ans = 2\\n                for position in graph[mouse]:\\n                    if position == cat: continue\\n                    if position == 0: return 1\\n                    result = move(position, cat, turn+1)\\n                    if result == 1: return 1\\n                    if result == 0: ans=0\\n                return ans\\n            else:\\n                ans = 1\\n                for position in graph[cat]:\\n                    if position == 0: continue\\n                    if position == mouse: return 2\\n                    result = move(mouse, position, turn+1)\\n                    if result == 2: return 2\\n                    if result == 0: ans = 0\\n                return ans\\n        return move(1,2,1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 793662,
                "title": "from-brute-force-to-top-down-dp",
                "content": "## Brute Force\\n```\\nclass Solution {\\n    \\n    private static final int DRAW = 0, MOUSE_WIN = 1, CAT_WIN = 2;\\n    \\n    public int catMouseGame(int[][] graph) {\\n        return catMouseGameFrom(graph, 0, 1, 2);\\n    }\\n    \\n    private int catMouseGameFrom(int[][] graph, int turn, int mousePos, int catPos) {\\n        if (turn == graph.length * 2) {\\n            return DRAW;\\n        } else if (mousePos == 0) {\\n            return MOUSE_WIN;\\n        } else if (mousePos == catPos) {\\n            return CAT_WIN;\\n        }\\n        \\n        if (turn % 2 == 0) { // Mouse\\'s turn\\n            boolean catWin = true;\\n            for (int mouseTo : graph[mousePos]) {\\n                int res = catMouseGameFrom(graph, turn + 1, mouseTo, catPos);\\n                if (res == MOUSE_WIN) {\\n                    return MOUSE_WIN;\\n                } else if (res == DRAW) {\\n                    catWin = false;\\n                }\\n            }\\n            if (catWin) {\\n                return CAT_WIN;\\n            } else {\\n                return DRAW;\\n            }\\n        } else { // Cat\\'s turn\\n            boolean mouseWin = true;\\n            for (int catTo : graph[catPos]) {\\n                if (catTo != 0) {\\n                    int res = catMouseGameFrom(graph, turn + 1, mousePos, catTo);\\n                    if (res == CAT_WIN) {\\n                        return CAT_WIN;\\n                    } else if (res == DRAW) {\\n                        mouseWin = false;\\n                    }\\n                }\\n            }\\n            if (mouseWin) {\\n                return MOUSE_WIN;\\n            } else {\\n                return DRAW;\\n            }\\n        }\\n    }\\n}\\n```\\n\\n## Top-down DP\\nTo overcome overlapping subproblems, we use memoization.\\n```\\nclass Solution {\\n    \\n    private static final int DRAW = 0, MOUSE_WIN = 1, CAT_WIN = 2;\\n    private int[][][] dp;\\n    \\n    public int catMouseGame(int[][] graph) {\\n        dp = new int[graph.length * 2][graph.length][graph.length];\\n        for (int i = 0; i < dp.length; i++) {\\n            for (int j = 0; j < dp[i].length; j++) {\\n                Arrays.fill(dp[i][j], -1);\\n            }\\n        }\\n        return catMouseGameFrom(graph, 0, 1, 2);\\n    }\\n    \\n    private int catMouseGameFrom(int[][] graph, int turn, int mousePos, int catPos) {\\n        if (turn == graph.length * 2) {\\n            return DRAW;\\n        } else if (mousePos == 0) {\\n            return MOUSE_WIN;\\n        } else if (mousePos == catPos) {\\n            return CAT_WIN;\\n        }\\n        \\n        if (dp[turn][mousePos][catPos] != -1) {\\n            return dp[turn][mousePos][catPos];\\n        }\\n        \\n        if (turn % 2 == 0) { // Mouse\\'s turn\\n            boolean catWin = true;\\n            for (int mouseTo : graph[mousePos]) {\\n                int res = catMouseGameFrom(graph, turn + 1, mouseTo, catPos);\\n                if (res == MOUSE_WIN) {\\n                    return dp[turn][mousePos][catPos] = MOUSE_WIN;\\n                } else if (res == DRAW) {\\n                    catWin = false;\\n                }\\n            }\\n            if (catWin) {\\n                return dp[turn][mousePos][catPos] = CAT_WIN;\\n            } else {\\n                return dp[turn][mousePos][catPos] = DRAW;\\n            }\\n        } else { // Cat\\'s turn\\n            boolean mouseWin = true;\\n            for (int catTo : graph[catPos]) {\\n                if (catTo != 0) {\\n                    int res = catMouseGameFrom(graph, turn + 1, mousePos, catTo);\\n                    if (res == CAT_WIN) {\\n                        return CAT_WIN;\\n                    } else if (res == DRAW) {\\n                        mouseWin = false;\\n                    }\\n                }\\n            }\\n            if (mouseWin) {\\n                return dp[turn][mousePos][catPos] = MOUSE_WIN;\\n            } else {\\n                return dp[turn][mousePos][catPos] = DRAW;\\n            }\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private static final int DRAW = 0, MOUSE_WIN = 1, CAT_WIN = 2;\\n    \\n    public int catMouseGame(int[][] graph) {\\n        return catMouseGameFrom(graph, 0, 1, 2);\\n    }\\n    \\n    private int catMouseGameFrom(int[][] graph, int turn, int mousePos, int catPos) {\\n        if (turn == graph.length * 2) {\\n            return DRAW;\\n        } else if (mousePos == 0) {\\n            return MOUSE_WIN;\\n        } else if (mousePos == catPos) {\\n            return CAT_WIN;\\n        }\\n        \\n        if (turn % 2 == 0) { // Mouse\\'s turn\\n            boolean catWin = true;\\n            for (int mouseTo : graph[mousePos]) {\\n                int res = catMouseGameFrom(graph, turn + 1, mouseTo, catPos);\\n                if (res == MOUSE_WIN) {\\n                    return MOUSE_WIN;\\n                } else if (res == DRAW) {\\n                    catWin = false;\\n                }\\n            }\\n            if (catWin) {\\n                return CAT_WIN;\\n            } else {\\n                return DRAW;\\n            }\\n        } else { // Cat\\'s turn\\n            boolean mouseWin = true;\\n            for (int catTo : graph[catPos]) {\\n                if (catTo != 0) {\\n                    int res = catMouseGameFrom(graph, turn + 1, mousePos, catTo);\\n                    if (res == CAT_WIN) {\\n                        return CAT_WIN;\\n                    } else if (res == DRAW) {\\n                        mouseWin = false;\\n                    }\\n                }\\n            }\\n            if (mouseWin) {\\n                return MOUSE_WIN;\\n            } else {\\n                return DRAW;\\n            }\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    private static final int DRAW = 0, MOUSE_WIN = 1, CAT_WIN = 2;\\n    private int[][][] dp;\\n    \\n    public int catMouseGame(int[][] graph) {\\n        dp = new int[graph.length * 2][graph.length][graph.length];\\n        for (int i = 0; i < dp.length; i++) {\\n            for (int j = 0; j < dp[i].length; j++) {\\n                Arrays.fill(dp[i][j], -1);\\n            }\\n        }\\n        return catMouseGameFrom(graph, 0, 1, 2);\\n    }\\n    \\n    private int catMouseGameFrom(int[][] graph, int turn, int mousePos, int catPos) {\\n        if (turn == graph.length * 2) {\\n            return DRAW;\\n        } else if (mousePos == 0) {\\n            return MOUSE_WIN;\\n        } else if (mousePos == catPos) {\\n            return CAT_WIN;\\n        }\\n        \\n        if (dp[turn][mousePos][catPos] != -1) {\\n            return dp[turn][mousePos][catPos];\\n        }\\n        \\n        if (turn % 2 == 0) { // Mouse\\'s turn\\n            boolean catWin = true;\\n            for (int mouseTo : graph[mousePos]) {\\n                int res = catMouseGameFrom(graph, turn + 1, mouseTo, catPos);\\n                if (res == MOUSE_WIN) {\\n                    return dp[turn][mousePos][catPos] = MOUSE_WIN;\\n                } else if (res == DRAW) {\\n                    catWin = false;\\n                }\\n            }\\n            if (catWin) {\\n                return dp[turn][mousePos][catPos] = CAT_WIN;\\n            } else {\\n                return dp[turn][mousePos][catPos] = DRAW;\\n            }\\n        } else { // Cat\\'s turn\\n            boolean mouseWin = true;\\n            for (int catTo : graph[catPos]) {\\n                if (catTo != 0) {\\n                    int res = catMouseGameFrom(graph, turn + 1, mousePos, catTo);\\n                    if (res == CAT_WIN) {\\n                        return CAT_WIN;\\n                    } else if (res == DRAW) {\\n                        mouseWin = false;\\n                    }\\n                }\\n            }\\n            if (mouseWin) {\\n                return dp[turn][mousePos][catPos] = MOUSE_WIN;\\n            } else {\\n                return dp[turn][mousePos][catPos] = DRAW;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 764788,
                "title": "memorized-bfs-a-possibly-intuitive-solution-python-with-comments",
                "content": "memorized bfs\\n\\n1. define an array, dp[t][m][c] where t for total steps, m for mouse\\'s position and c for cat\\'s position and\\n2. dp[t][m][c] = 1 for mouse win, 2 for cat win and 0 for a draw\\n3. specially, dp[2n][\\\\*][\\\\*] when reach 2n steps, then it is a draw\\n4. dp[\\\\*][0][\\\\*] = mouse win, since mouse\\'s position is 0 (the hole)\\n5. dp[\\\\*][m][c] and m=c then cat win, since they are at the same position\\n\\n```\\nclass Solution:\\n    def catMouseGame(self, graph):\\n        n = len(graph)\\n        dp = [[[-1] * n for _ in range(n)] for _ in range(2*n)]\\n        \\n        return self.helper(graph, dp, 0, 1, 2)# 0-steps, 1=mouse\\'s position, 2=cat\\'s position\\n    \\n    def helper(self, graph, dp, t, m, c):\\n        if t == 2*len(graph): return 0 \\n\\t\\t# termine as a draw! since both mouse and cat moved n steps (totally 2n steps) \\n\\t\\t# and still no winner or loser, then it is a draw\\n\\t\\t\\n        if dp[t][m][c] != -1: return dp[t][m][c] # read from cache\\n        \\n        if m == 0: # m\\'s position = hole, so mouse win\\n            dp[t][m][c] = 1 # mouse win\\n            return 1\\n        if m == c: # cat and mouse are at the same position, so cat win\\n            dp[t][m][c] = 2 # cat win\\n            return 2\\n        mouseTurn = (t % 2 == 0)\\n        if mouseTurn:\\n            catWin = True\\n            for i in range(len(graph[m])):\\n                nextRes = self.helper(graph, dp, t+1, graph[m][i], c)\\n                if nextRes == 1: # find a way that mouse win\\n                    dp[t][m][c] = 1\\n                    return 1\\n                elif nextRes != 2: # find a way that cat can not win\\n                    catWin = False\\n            if catWin:\\n                dp[t][m][c] = 2\\n                return 2 # under mouse\\'s all available choices, cat will win, then return 2\\n            else:\\n                dp[t][m][c] = 0\\n                return 0\\n        else:\\n            mouseWin = True\\n            for i in range(len(graph[c])):\\n                if graph[c][i] == 0: continue # cat can not enter hole\\n                nextRes = self.helper(graph, dp, t+1, m, graph[c][i])\\n                if nextRes == 2: # find a way that cat can win\\n                    dp[t][m][c] = 2\\n                    return 2\\n                elif nextRes != 1: # find a way that mouse can not win\\n                    mouseWin = False\\n            if mouseWin:\\n                dp[t][m][c] = 1\\n                return 1 # under cat\\'s al available choices, mouse will win, then return 1\\n            else:\\n                dp[t][m][c] = 0\\n                return 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def catMouseGame(self, graph):\\n        n = len(graph)\\n        dp = [[[-1] * n for _ in range(n)] for _ in range(2*n)]\\n        \\n        return self.helper(graph, dp, 0, 1, 2)# 0-steps, 1=mouse\\'s position, 2=cat\\'s position\\n    \\n    def helper(self, graph, dp, t, m, c):\\n        if t == 2*len(graph): return 0 \\n\\t\\t# termine as a draw! since both mouse and cat moved n steps (totally 2n steps) \\n\\t\\t# and still no winner or loser, then it is a draw\\n\\t\\t\\n        if dp[t][m][c] != -1: return dp[t][m][c] # read from cache\\n        \\n        if m == 0: # m\\'s position = hole, so mouse win\\n            dp[t][m][c] = 1 # mouse win\\n            return 1\\n        if m == c: # cat and mouse are at the same position, so cat win\\n            dp[t][m][c] = 2 # cat win\\n            return 2\\n        mouseTurn = (t % 2 == 0)\\n        if mouseTurn:\\n            catWin = True\\n            for i in range(len(graph[m])):\\n                nextRes = self.helper(graph, dp, t+1, graph[m][i], c)\\n                if nextRes == 1: # find a way that mouse win\\n                    dp[t][m][c] = 1\\n                    return 1\\n                elif nextRes != 2: # find a way that cat can not win\\n                    catWin = False\\n            if catWin:\\n                dp[t][m][c] = 2\\n                return 2 # under mouse\\'s all available choices, cat will win, then return 2\\n            else:\\n                dp[t][m][c] = 0\\n                return 0\\n        else:\\n            mouseWin = True\\n            for i in range(len(graph[c])):\\n                if graph[c][i] == 0: continue # cat can not enter hole\\n                nextRes = self.helper(graph, dp, t+1, m, graph[c][i])\\n                if nextRes == 2: # find a way that cat can win\\n                    dp[t][m][c] = 2\\n                    return 2\\n                elif nextRes != 1: # find a way that mouse can not win\\n                    mouseWin = False\\n            if mouseWin:\\n                dp[t][m][c] = 1\\n                return 1 # under cat\\'s al available choices, mouse will win, then return 1\\n            else:\\n                dp[t][m][c] = 0\\n                return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746429,
                "title": "clean-rust-solution",
                "content": "This solution is based on the moderator provided solution with some simplifications and idiomatic rust code.\\n\\n```\\nuse std::collections::{HashMap, HashSet, VecDeque};\\n\\n#[derive(Debug, Eq, PartialEq, Hash, Copy, Clone)]\\nenum Player {\\n    Cat,\\n    Mouse,\\n}\\n\\nimpl Player {\\n    pub fn opposite(&self) -> Player {\\n        match self {\\n            Player::Cat => Player::Mouse,\\n            Player::Mouse => Player::Cat,\\n        }\\n    }\\n}\\n\\n#[derive(Debug, Eq, PartialEq, Hash, Copy, Clone)]\\nstruct State {\\n    turn: Player,\\n    cat_pos: i32,\\n    mouse_pos: i32,\\n}\\n\\nimpl State {\\n    const WINNING_MOUSE_POS: i32 = 0;\\n\\n    pub fn new(turn: Player, cat_pos: i32, mouse_pos: i32) -> State {\\n        State {\\n            turn,\\n            cat_pos,\\n            mouse_pos,\\n        }\\n    }\\n\\n    pub fn winner(&self) -> Option<Player> {\\n        if self.mouse_pos == State::WINNING_MOUSE_POS || self.cat_pos == State::WINNING_MOUSE_POS {\\n            // If either the mouse or cat falls into the hole, the mouse wins.\\n            Some(Player::Mouse)\\n        } else if self.mouse_pos == self.cat_pos {\\n            // If the cat catches the mouse, the cat wins.\\n            Some(Player::Cat)\\n        } else {\\n            // Otherwise there isn\\'t a winner yet.\\n            None\\n        }\\n    }\\n}\\n\\npub fn cat_mouse_game(pos_graph: Vec<Vec<i32>>) -> i32 {\\n    let mut graph: HashMap<State, HashSet<State>> = HashMap::new();\\n    let mut rgraph: HashMap<State, HashSet<State>> = HashMap::new();\\n    let mut states = HashSet::new();\\n    let mut state_winner: HashMap<State, Player> = HashMap::new();\\n    for (pos_one, pos_adjs) in pos_graph.iter().enumerate() {\\n        for pos_adj in pos_adjs {\\n            for turn in &[Player::Mouse, Player::Cat] {\\n                for cnst_pos in 0..pos_graph.len() {\\n                    let (cat_pos, new_cat_pos, mouse_pos, new_mouse_pos) = match *turn {\\n                        Player::Cat => (pos_one as i32, *pos_adj, cnst_pos as i32, cnst_pos as i32),\\n                        Player::Mouse => {\\n                            (cnst_pos as i32, cnst_pos as i32, pos_one as i32, *pos_adj)\\n                        }\\n                    };\\n                    let from = State::new(*turn, cat_pos, mouse_pos);\\n                    let to = State::new(turn.opposite(), new_cat_pos, new_mouse_pos);\\n                    graph.entry(from).or_insert(HashSet::new()).insert(to);\\n                    rgraph.entry(to).or_insert(HashSet::new()).insert(from);\\n                    for state in vec![from, to] {\\n                        if let Some(winning_player) = state.winner() {\\n                            state_winner.insert(state, winning_player);\\n                        }\\n                        states.insert(state);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    let mut degree_left = HashMap::new();\\n    let mut stack = Vec::new();\\n    for state in states {\\n        if let Some(adjs) = graph.get(&state) {\\n            // The degree is the number of children left. Once all children are\\n            // complete, the winner of this state can be determined\\n            degree_left.insert(state, adjs.len() as i32);\\n        } else {\\n            degree_left.insert(state, 0);\\n        }\\n\\n        if let Some(_) = state_winner.get(&state) {\\n            degree_left.insert(state, 0);\\n        }\\n\\n        if degree_left[&state] == 0 {\\n            stack.push(state);\\n        }\\n    }\\n\\n    while let Some(state) = stack.pop() {\\n        let winner = state_winner[&state];\\n        for &parent in rgraph.get(&state).unwrap_or(&HashSet::new()) {\\n            if state_winner.contains_key(&parent) {\\n                continue;\\n            }\\n\\n            // If it was the winner\\'s turn last turn, then they can make the winning move.\\n            if winner == parent.turn {\\n                state_winner.insert(parent, winner);\\n                stack.push(parent);\\n                continue;\\n            }\\n\\n            // Otherwise, decrease the `degree_left` count and if the degree is 0, this parent\\n            // has no winning moves, and therefore we can set the winner.\\n            // Safe unwrap as all states were put into `degree_left`.\\n            *degree_left.get_mut(&parent).unwrap() -= 1;\\n            if degree_left[&parent] == 0 {\\n                state_winner.insert(parent, parent.turn.opposite());\\n                stack.push(parent);\\n            }\\n        }\\n    }\\n\\n    match state_winner.get(&State::new(Player::Mouse, 2, 1)) {\\n        None => 0,\\n        Some(Player::Mouse) => 1,\\n        Some(Player::Cat) => 2,\\n    }\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::*;\\n\\n    #[test]\\n    fn test_cat_mouse_simple() {\\n        assert_eq!(\\n            cat_mouse_game(vec![\\n                vec![2, 5],\\n                vec![3],\\n                vec![0, 4, 5],\\n                vec![1, 4, 5],\\n                vec![2, 3],\\n                vec![0, 2, 3],\\n            ]),\\n            0\\n        );\\n    }\\n\\n    #[test]\\n    fn test_cat_mouse_simple2() {\\n        /*\\n            4 - 3 - 0 - 2 - 1\\n        */\\n        assert_eq!(\\n            cat_mouse_game(vec![vec![2, 3], vec![2], vec![0, 1], vec![0, 4], vec![3]]),\\n            2\\n        );\\n    }\\n\\n    #[test]\\n    fn test_cat_mouse_simple3() {\\n        /*\\n            0 - 2 - 1\\n        */\\n        assert_eq!(cat_mouse_game(vec![vec![2], vec![2], vec![0, 1]]), 2);\\n    }\\n\\n    #[test]\\n    fn test_cat_mouse_cycle() {\\n        assert_eq!(\\n            cat_mouse_game(vec![\\n                vec![6],\\n                vec![4],\\n                vec![9],\\n                vec![5],\\n                vec![1, 5],\\n                vec![3, 4, 6],\\n                vec![0, 5, 10],\\n                vec![8, 9, 10],\\n                vec![7],\\n                vec![2, 7],\\n                vec![6, 7]\\n            ]),\\n            1\\n        );\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::{HashMap, HashSet, VecDeque};\\n\\n#[derive(Debug, Eq, PartialEq, Hash, Copy, Clone)]\\nenum Player {\\n    Cat,\\n    Mouse,\\n}\\n\\nimpl Player {\\n    pub fn opposite(&self) -> Player {\\n        match self {\\n            Player::Cat => Player::Mouse,\\n            Player::Mouse => Player::Cat,\\n        }\\n    }\\n}\\n\\n#[derive(Debug, Eq, PartialEq, Hash, Copy, Clone)]\\nstruct State {\\n    turn: Player,\\n    cat_pos: i32,\\n    mouse_pos: i32,\\n}\\n\\nimpl State {\\n    const WINNING_MOUSE_POS: i32 = 0;\\n\\n    pub fn new(turn: Player, cat_pos: i32, mouse_pos: i32) -> State {\\n        State {\\n            turn,\\n            cat_pos,\\n            mouse_pos,\\n        }\\n    }\\n\\n    pub fn winner(&self) -> Option<Player> {\\n        if self.mouse_pos == State::WINNING_MOUSE_POS || self.cat_pos == State::WINNING_MOUSE_POS {\\n            // If either the mouse or cat falls into the hole, the mouse wins.\\n            Some(Player::Mouse)\\n        } else if self.mouse_pos == self.cat_pos {\\n            // If the cat catches the mouse, the cat wins.\\n            Some(Player::Cat)\\n        } else {\\n            // Otherwise there isn\\'t a winner yet.\\n            None\\n        }\\n    }\\n}\\n\\npub fn cat_mouse_game(pos_graph: Vec<Vec<i32>>) -> i32 {\\n    let mut graph: HashMap<State, HashSet<State>> = HashMap::new();\\n    let mut rgraph: HashMap<State, HashSet<State>> = HashMap::new();\\n    let mut states = HashSet::new();\\n    let mut state_winner: HashMap<State, Player> = HashMap::new();\\n    for (pos_one, pos_adjs) in pos_graph.iter().enumerate() {\\n        for pos_adj in pos_adjs {\\n            for turn in &[Player::Mouse, Player::Cat] {\\n                for cnst_pos in 0..pos_graph.len() {\\n                    let (cat_pos, new_cat_pos, mouse_pos, new_mouse_pos) = match *turn {\\n                        Player::Cat => (pos_one as i32, *pos_adj, cnst_pos as i32, cnst_pos as i32),\\n                        Player::Mouse => {\\n                            (cnst_pos as i32, cnst_pos as i32, pos_one as i32, *pos_adj)\\n                        }\\n                    };\\n                    let from = State::new(*turn, cat_pos, mouse_pos);\\n                    let to = State::new(turn.opposite(), new_cat_pos, new_mouse_pos);\\n                    graph.entry(from).or_insert(HashSet::new()).insert(to);\\n                    rgraph.entry(to).or_insert(HashSet::new()).insert(from);\\n                    for state in vec![from, to] {\\n                        if let Some(winning_player) = state.winner() {\\n                            state_winner.insert(state, winning_player);\\n                        }\\n                        states.insert(state);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    let mut degree_left = HashMap::new();\\n    let mut stack = Vec::new();\\n    for state in states {\\n        if let Some(adjs) = graph.get(&state) {\\n            // The degree is the number of children left. Once all children are\\n            // complete, the winner of this state can be determined\\n            degree_left.insert(state, adjs.len() as i32);\\n        } else {\\n            degree_left.insert(state, 0);\\n        }\\n\\n        if let Some(_) = state_winner.get(&state) {\\n            degree_left.insert(state, 0);\\n        }\\n\\n        if degree_left[&state] == 0 {\\n            stack.push(state);\\n        }\\n    }\\n\\n    while let Some(state) = stack.pop() {\\n        let winner = state_winner[&state];\\n        for &parent in rgraph.get(&state).unwrap_or(&HashSet::new()) {\\n            if state_winner.contains_key(&parent) {\\n                continue;\\n            }\\n\\n            // If it was the winner\\'s turn last turn, then they can make the winning move.\\n            if winner == parent.turn {\\n                state_winner.insert(parent, winner);\\n                stack.push(parent);\\n                continue;\\n            }\\n\\n            // Otherwise, decrease the `degree_left` count and if the degree is 0, this parent\\n            // has no winning moves, and therefore we can set the winner.\\n            // Safe unwrap as all states were put into `degree_left`.\\n            *degree_left.get_mut(&parent).unwrap() -= 1;\\n            if degree_left[&parent] == 0 {\\n                state_winner.insert(parent, parent.turn.opposite());\\n                stack.push(parent);\\n            }\\n        }\\n    }\\n\\n    match state_winner.get(&State::new(Player::Mouse, 2, 1)) {\\n        None => 0,\\n        Some(Player::Mouse) => 1,\\n        Some(Player::Cat) => 2,\\n    }\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::*;\\n\\n    #[test]\\n    fn test_cat_mouse_simple() {\\n        assert_eq!(\\n            cat_mouse_game(vec![\\n                vec![2, 5],\\n                vec![3],\\n                vec![0, 4, 5],\\n                vec![1, 4, 5],\\n                vec![2, 3],\\n                vec![0, 2, 3],\\n            ]),\\n            0\\n        );\\n    }\\n\\n    #[test]\\n    fn test_cat_mouse_simple2() {\\n        /*\\n            4 - 3 - 0 - 2 - 1\\n        */\\n        assert_eq!(\\n            cat_mouse_game(vec![vec![2, 3], vec![2], vec![0, 1], vec![0, 4], vec![3]]),\\n            2\\n        );\\n    }\\n\\n    #[test]\\n    fn test_cat_mouse_simple3() {\\n        /*\\n            0 - 2 - 1\\n        */\\n        assert_eq!(cat_mouse_game(vec![vec![2], vec![2], vec![0, 1]]), 2);\\n    }\\n\\n    #[test]\\n    fn test_cat_mouse_cycle() {\\n        assert_eq!(\\n            cat_mouse_game(vec![\\n                vec![6],\\n                vec![4],\\n                vec![9],\\n                vec![5],\\n                vec![1, 5],\\n                vec![3, 4, 6],\\n                vec![0, 5, 10],\\n                vec![8, 9, 10],\\n                vec![7],\\n                vec![2, 7],\\n                vec![6, 7]\\n            ]),\\n            1\\n        );\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 591994,
                "title": "can-someone-help-in-debugging-this-code-idea-is-same-as-solution-i-e-game-theory",
                "content": "```\\nclass Solution(object):\\n    def catMouseGame(self, graph):\\n        \"\"\"\\n        :type graph: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        dp = {}\\n                \\n        v = set()\\n        \\n        # turn 1 means mouse, 0 means cat\\n        # 0 is loss, 1 is win and 2 is draw\\n        def dfs(ci,mi,turn):\\n            \\n            # cat lost\\n            if mi==0:\\n                dp[(ci,mi,turn)] = 1 if turn else 0\\n                return dp[(ci,mi,turn)]\\n            \\n            # cat won\\n            if mi==ci:\\n                dp[(ci,mi,turn)] = 0 if turn else 1\\n                return dp[(ci,mi,turn)]\\n            \\n            if (ci,mi,turn) in dp:\\n                return dp[(ci,mi,turn)]\\n            \\n            # if this node is already visited, its a draw.\\n            if (ci,mi,turn) in v:\\n                return 2\\n            \\n            v.add((ci,mi,turn))\\n            \\n            res_out = []\\n            \\n            if turn:\\n                for mii in graph[mi]:\\n                    res = dfs(ci,mii,(turn+1)%2)\\n                    # if there is alteast one losing node from this node, this is winning node\\n                    if res==0:\\n                        dp[(ci,mi,turn)] = 1\\n                        return dp[(ci,mi,turn)]\\n                    res_out.append(res)\\n            else:\\n                for cii in graph[ci]:\\n                    if cii==0:\\n                        continue\\n                    res = dfs(cii,mi,(turn+1)%2)\\n                    # if there is alteast one losing node from this node, this is winning node\\n                    if res==0:\\n                        dp[(ci,mi,turn)] = 1\\n                        v.remove((ci,mi,turn))\\n                        return dp[(ci,mi,turn)]\\n                    res_out.append(res)\\n                        \\n            count = 0\\n            for res in res_out:\\n                count+=(1 if res==2 else 0)\\n            \\n            # if cat/mouse can make a draw move then it will be the priority else it is on losing position\\n            dp[(ci,mi,turn)] = 2 if count>0 else 0\\n            v.remove((ci,mi,turn))\\n            return dp[(ci,mi,turn)]\\n        \\n        res = dfs(2,1,1)\\n                \\n        if res==1:\\n            return 1\\n        if res==0:\\n            return 2\\n        return 0\\n            \\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def catMouseGame(self, graph):\\n        \"\"\"\\n        :type graph: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        dp = {}\\n                \\n        v = set()\\n        \\n        # turn 1 means mouse, 0 means cat\\n        # 0 is loss, 1 is win and 2 is draw\\n        def dfs(ci,mi,turn):\\n            \\n            # cat lost\\n            if mi==0:\\n                dp[(ci,mi,turn)] = 1 if turn else 0\\n                return dp[(ci,mi,turn)]\\n            \\n            # cat won\\n            if mi==ci:\\n                dp[(ci,mi,turn)] = 0 if turn else 1\\n                return dp[(ci,mi,turn)]\\n            \\n            if (ci,mi,turn) in dp:\\n                return dp[(ci,mi,turn)]\\n            \\n            # if this node is already visited, its a draw.\\n            if (ci,mi,turn) in v:\\n                return 2\\n            \\n            v.add((ci,mi,turn))\\n            \\n            res_out = []\\n            \\n            if turn:\\n                for mii in graph[mi]:\\n                    res = dfs(ci,mii,(turn+1)%2)\\n                    # if there is alteast one losing node from this node, this is winning node\\n                    if res==0:\\n                        dp[(ci,mi,turn)] = 1\\n                        return dp[(ci,mi,turn)]\\n                    res_out.append(res)\\n            else:\\n                for cii in graph[ci]:\\n                    if cii==0:\\n                        continue\\n                    res = dfs(cii,mi,(turn+1)%2)\\n                    # if there is alteast one losing node from this node, this is winning node\\n                    if res==0:\\n                        dp[(ci,mi,turn)] = 1\\n                        v.remove((ci,mi,turn))\\n                        return dp[(ci,mi,turn)]\\n                    res_out.append(res)\\n                        \\n            count = 0\\n            for res in res_out:\\n                count+=(1 if res==2 else 0)\\n            \\n            # if cat/mouse can make a draw move then it will be the priority else it is on losing position\\n            dp[(ci,mi,turn)] = 2 if count>0 else 0\\n            v.remove((ci,mi,turn))\\n            return dp[(ci,mi,turn)]\\n        \\n        res = dfs(2,1,1)\\n                \\n        if res==1:\\n            return 1\\n        if res==0:\\n            return 2\\n        return 0\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 545359,
                "title": "can-anyone-help-me-by-pointing-out-the-mistake-in-this-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int memo[51][51][2];\\n    int solve(int mouse, int cat, int turn, vector<vector<int>>& graph, int t) {\\n        if (t == graph.size() * 2)\\n            return 0;\\n        if(mouse == 0) { memo[mouse][cat][turn] = 1; return 1;} \\n        if(mouse == cat) { memo[mouse][cat][turn] = 2; return 2;} \\n        if(memo[mouse][cat][turn] != -1) return memo[mouse][cat][turn];\\n        \\n        int ans1 = INT_MIN, ans2 = INT_MIN;\\n        bool flag1 = false, flag2=false;\\n        if(turn == 0) {\\n            flag1  = false;\\n            for(int i = 0; i < graph[mouse].size(); i++) {\\n                    ans1 = solve(graph[mouse][i], cat, 1, graph, t+1);\\n                    if(ans1 == 1) return memo[mouse][cat][turn] = 1;\\n                    else if(ans1 == 0) flag1=true;\\n                \\n            }\\n            if(flag1) return memo[mouse][cat][turn] = 0;\\n            else return memo[mouse][cat][turn] = 2;\\n    \\n        } else {\\n            flag2 = false;\\n            for(int i = 0; i < graph[cat].size(); i++) {\\n                if(graph[cat][i] != 0 ) {\\n                    ans2 = solve(mouse, graph[cat][i], 0, graph,t+1);\\n                    if(ans2 == 2) return memo[mouse][cat][turn] = 2;\\n                    else if(ans2 == 0)\\n                        flag2 = true;\\n                }\\n             }\\n            if(flag2) return memo[mouse][cat][turn] = 0;\\n                else return memo[mouse][cat][turn] = 1;\\n           \\n        }\\n    }\\n    \\n    int catMouseGame(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < n; j++) {\\n                memo[i][j][0] = -1;memo[i][j][1] = -1;\\n                \\n            }\\n        }\\n        return solve(1, 2, 0, graph, 1);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int memo[51][51][2];\\n    int solve(int mouse, int cat, int turn, vector<vector<int>>& graph, int t) {\\n        if (t == graph.size() * 2)\\n            return 0;\\n        if(mouse == 0) { memo[mouse][cat][turn] = 1; return 1;}",
                "codeTag": "Java"
            },
            {
                "id": 539388,
                "title": "c-dynamic-programming-easy-to-implement",
                "content": "Crafting innovative ideas or high quality code, I am good at neither. Can I pass the interview with slow code? \\n```\\nclass Solution {\\npublic:\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        const int n = graph.size(); \\n        vector<vector<int>> v_rat(n, vector<int>(n, 0)), v_cat(n, vector<int>(n, 0)); \\n        \\n        for (int r = 0; r < n; ++r) v_rat[r][r] = -1, v_cat[r][r] = 1; \\n        for (int c = 0; c < n; ++c) v_rat[0][c] = 1, v_cat[0][c] = -1; \\n        \\n        for (int t = 0; t < n; ++t) {\\n            for (int r = 1; r < n; ++r) {\\n                for (int c = 1; c < n; ++c) {\\n                    if (c == r) continue; \\n                    int max_val = -2; \\n                    for (int i : graph[r]) {\\n                        max_val = max(max_val, -v_cat[i][c]); \\n                        if (-v_cat[i][c] == 1) break; \\n                    }\\n                    v_rat[r][c] = max_val; \\n                }\\n            }\\n            for (int c = 1; c < n; ++c) {\\n                for (int r = 1; r < n; ++r) {\\n                    if (c == r ) continue; \\n                    int max_val = -2;\\n                    for (int j : graph[c]) {\\n                        if (j == 0) continue;  \\n                        max_val = max(max_val, -v_rat[r][j]); \\n                        if (max_val == 2) break; \\n                    }\\n                    v_cat[r][c] = max_val; \\n                }\\n            }\\n        }\\n        if (v_rat[1][2] == -1) return 2; \\n        else if (v_rat[1][2] == 1) return 1;\\n        else return 0; \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        const int n = graph.size(); \\n        vector<vector<int>> v_rat(n, vector<int>(n, 0)), v_cat(n, vector<int>(n, 0)); \\n        \\n        for (int r = 0; r < n; ++r) v_rat[r][r] = -1, v_cat[r][r] = 1; \\n        for (int c = 0; c < n; ++c) v_rat[0][c] = 1, v_cat[0][c] = -1; \\n        \\n        for (int t = 0; t < n; ++t) {\\n            for (int r = 1; r < n; ++r) {\\n                for (int c = 1; c < n; ++c) {\\n                    if (c == r) continue; \\n                    int max_val = -2; \\n                    for (int i : graph[r]) {\\n                        max_val = max(max_val, -v_cat[i][c]); \\n                        if (-v_cat[i][c] == 1) break; \\n                    }\\n                    v_rat[r][c] = max_val; \\n                }\\n            }\\n            for (int c = 1; c < n; ++c) {\\n                for (int r = 1; r < n; ++r) {\\n                    if (c == r ) continue; \\n                    int max_val = -2;\\n                    for (int j : graph[c]) {\\n                        if (j == 0) continue;  \\n                        max_val = max(max_val, -v_rat[r][j]); \\n                        if (max_val == 2) break; \\n                    }\\n                    v_cat[r][c] = max_val; \\n                }\\n            }\\n        }\\n        if (v_rat[1][2] == -1) return 2; \\n        else if (v_rat[1][2] == 1) return 1;\\n        else return 0; \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 536921,
                "title": "java-bfs-from-the-end",
                "content": "some intuitions:\\n1, start from mouse win, or cat win state, bfs  aimingto the start point.\\n2, if reach start point, it will return the start point.\\n3, if not ,default to 0.\\n\\nsome ptifalls:\\n1, careful when you get previous status, it now is mouse, prev should be cat, cat move\\n2, careful when you check the prev winning or lose. \\nprev cat win if current mouse fail;\\nprev cat lose if and only if all next mouse lose;\\n\\n```\\nclass Solution {\\n    int[][][] ss;\\n    int[][] g;\\n    int n;\\n    public int catMouseGame(int[][] g) {\\n        this.g = g;\\n        int n = g.length;\\n        ss = new int[n][n][3]; // mouse pos, cat pos, who\\'s turn(1 for mouse, 2 for cat)\\n        Queue<int[]> q = new LinkedList<>();\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 1; j <= 2; j++ ){\\n                ss[0][i][j] = 1;\\n                ss[i][i][j] = 2; \\n                q.offer(new int[] {0, i, j});\\n                q.offer(new int[] {i, i, j});\\n            }\\n        }\\n        while (!q.isEmpty()){\\n            int[] s = q.poll();\\n            int win = ss[s[0]][s[1]][s[2]];\\n            for (int[] next :  getPrev(s)){\\n                if (ss[next[0]][next[1]][next[2]] > 0) continue;  // already visited\\n                if (next[2] == win) ss[next[0]][next[1]][next[2]] = win;  // prev can win;\\n                else if (nextWin(next)) ss[next[0]][next[1]][next[2]] = 3 - next[2];  // prev will lose;\\n                if (ss[next[0]][next[1]][next[2]] > 0) q.offer(next);\\n            }\\n        }\\n        return ss[1][2][1];  // if not found, default to 0, if found, just return the result\\n    }\\n    \\n    private List<int[]> getPrev(int[] s){\\n        List<int[]> res = new ArrayList<>();\\n        if (s[2] == 1) {\\n            for (int i : g[s[1]]) {\\n                if (i == 0) continue;   // cat won\\'t be in the hole\\n                res.add(new int[]{s[0], i, 2});\\n            }\\n        } else {\\n            for (int i : g[s[0]]) {  // this turn cat, then last turn is MOUSE\\n                if (i == 0) continue;  //moutse already win, not need to go furhter;\\n                res.add(new int[]{i, s[1], 1});\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private boolean nextWin(int[] s){\\n        if (s[2] == 1) {\\n            for (int i : g[s[0]]) {\\n                if (ss[i][s[1]][2] != 2) return false;\\n            }\\n        } else {\\n            for (int i : g[s[1]]) {\\n                if (i == 0) continue;  \\n                if (ss[s[0]][i][1] != 1) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\nRef: Hafeng, https://www.youtube.com/watch?v=sq6Ggb98A38",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][][] ss;\\n    int[][] g;\\n    int n;\\n    public int catMouseGame(int[][] g) {\\n        this.g = g;\\n        int n = g.length;\\n        ss = new int[n][n][3]; // mouse pos, cat pos, who\\'s turn(1 for mouse, 2 for cat)\\n        Queue<int[]> q = new LinkedList<>();\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 1; j <= 2; j++ ){\\n                ss[0][i][j] = 1;\\n                ss[i][i][j] = 2; \\n                q.offer(new int[] {0, i, j});\\n                q.offer(new int[] {i, i, j});\\n            }\\n        }\\n        while (!q.isEmpty()){\\n            int[] s = q.poll();\\n            int win = ss[s[0]][s[1]][s[2]];\\n            for (int[] next :  getPrev(s)){\\n                if (ss[next[0]][next[1]][next[2]] > 0) continue;  // already visited\\n                if (next[2] == win) ss[next[0]][next[1]][next[2]] = win;  // prev can win;\\n                else if (nextWin(next)) ss[next[0]][next[1]][next[2]] = 3 - next[2];  // prev will lose;\\n                if (ss[next[0]][next[1]][next[2]] > 0) q.offer(next);\\n            }\\n        }\\n        return ss[1][2][1];  // if not found, default to 0, if found, just return the result\\n    }\\n    \\n    private List<int[]> getPrev(int[] s){\\n        List<int[]> res = new ArrayList<>();\\n        if (s[2] == 1) {\\n            for (int i : g[s[1]]) {\\n                if (i == 0) continue;   // cat won\\'t be in the hole\\n                res.add(new int[]{s[0], i, 2});\\n            }\\n        } else {\\n            for (int i : g[s[0]]) {  // this turn cat, then last turn is MOUSE\\n                if (i == 0) continue;  //moutse already win, not need to go furhter;\\n                res.add(new int[]{i, s[1], 1});\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private boolean nextWin(int[] s){\\n        if (s[2] == 1) {\\n            for (int i : g[s[0]]) {\\n                if (ss[i][s[1]][2] != 2) return false;\\n            }\\n        } else {\\n            for (int i : g[s[1]]) {\\n                if (i == 0) continue;  \\n                if (ss[s[0]][i][1] != 1) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503927,
                "title": "golang-solution",
                "content": "\\n```\\nfunc catMouseGame(graph [][]int) int {\\n    n := len(graph)\\n    dp := make([][][]int, n*2)\\n    for i:= range dp {\\n        dp[i] = make([][]int, n)\\n        for j := range dp[i] {\\n            dp[i][j] = make([]int, n)\\n        }\\n    }\\n    fill(&dp)\\n    \\n    return getBoardState(&graph, &dp, 0, 1, 2)\\n}\\n\\nfunc getBoardState(graph *[][]int, dp *[][][]int, turn int, rat int, cat int) int {\\n    n := len(*graph)\\n    if (turn == 2*n) {\\n        return 0\\n    }\\n    \\n    if (rat == cat) {\\n        (*dp)[turn][rat][cat] = 2\\n        return 2\\n    }\\n    \\n    if (rat == 0) {\\n        (*dp)[turn][rat][cat] = 1\\n        return 1\\n    }\\n    \\n    if ((*dp)[turn][rat][cat] != -1) {\\n        return (*dp)[turn][rat][cat]\\n    }\\n    \\n    ratTurn := (turn % 2) == 0\\n    \\n    if (ratTurn) {\\n        catCanWin := true\\n        for i := 0; i < len((*graph)[rat]); i++ {\\n            next := getBoardState(graph, dp, turn+1, (*graph)[rat][i], cat)\\n            if (next == 1) {\\n                (*dp)[turn][rat][cat] = 1\\n                return 1\\n            } else if (next != 2) {\\n                catCanWin = false\\n            }\\n        }\\n        \\n        if (catCanWin) {\\n            (*dp)[turn][rat][cat] = 2\\n            return 2\\n        } else {\\n            (*dp)[turn][rat][cat] = 0\\n            return 0\\n        }\\n    } else {\\n        ratCanWin := true\\n        for i := 0; i < len((*graph)[cat]); i++ {\\n            if ((*graph)[cat][i] == 0) {continue}\\n            next := getBoardState(graph, dp, turn+1, rat, (*graph)[cat][i])\\n            if (next == 2) {\\n                (*dp)[turn][rat][cat] = 2\\n                return 2\\n            } else if (next != 1) {\\n                ratCanWin = false\\n            }\\n        }\\n        \\n        if (ratCanWin) {\\n            (*dp)[turn][rat][cat] = 1\\n            return 1\\n        } else {\\n            (*dp)[turn][rat][cat] = 0\\n            return 0\\n        }\\n    }\\n}\\n\\nfunc fill (dp *[][][]int) {\\n    \\n    for l,_ := range (*dp) {\\n        for m,_ := range (*dp)[l] {\\n            for n,_ := range (*dp)[l][m] {\\n                (*dp)[l][m][n] = -1\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc catMouseGame(graph [][]int) int {\\n    n := len(graph)\\n    dp := make([][][]int, n*2)\\n    for i:= range dp {\\n        dp[i] = make([][]int, n)\\n        for j := range dp[i] {\\n            dp[i][j] = make([]int, n)\\n        }\\n    }\\n    fill(&dp)\\n    \\n    return getBoardState(&graph, &dp, 0, 1, 2)\\n}\\n\\nfunc getBoardState(graph *[][]int, dp *[][][]int, turn int, rat int, cat int) int {\\n    n := len(*graph)\\n    if (turn == 2*n) {\\n        return 0\\n    }\\n    \\n    if (rat == cat) {\\n        (*dp)[turn][rat][cat] = 2\\n        return 2\\n    }\\n    \\n    if (rat == 0) {\\n        (*dp)[turn][rat][cat] = 1\\n        return 1\\n    }\\n    \\n    if ((*dp)[turn][rat][cat] != -1) {\\n        return (*dp)[turn][rat][cat]\\n    }\\n    \\n    ratTurn := (turn % 2) == 0\\n    \\n    if (ratTurn) {\\n        catCanWin := true\\n        for i := 0; i < len((*graph)[rat]); i++ {\\n            next := getBoardState(graph, dp, turn+1, (*graph)[rat][i], cat)\\n            if (next == 1) {\\n                (*dp)[turn][rat][cat] = 1\\n                return 1\\n            } else if (next != 2) {\\n                catCanWin = false\\n            }\\n        }\\n        \\n        if (catCanWin) {\\n            (*dp)[turn][rat][cat] = 2\\n            return 2\\n        } else {\\n            (*dp)[turn][rat][cat] = 0\\n            return 0\\n        }\\n    } else {\\n        ratCanWin := true\\n        for i := 0; i < len((*graph)[cat]); i++ {\\n            if ((*graph)[cat][i] == 0) {continue}\\n            next := getBoardState(graph, dp, turn+1, rat, (*graph)[cat][i])\\n            if (next == 2) {\\n                (*dp)[turn][rat][cat] = 2\\n                return 2\\n            } else if (next != 1) {\\n                ratCanWin = false\\n            }\\n        }\\n        \\n        if (ratCanWin) {\\n            (*dp)[turn][rat][cat] = 1\\n            return 1\\n        } else {\\n            (*dp)[turn][rat][cat] = 0\\n            return 0\\n        }\\n    }\\n}\\n\\nfunc fill (dp *[][][]int) {\\n    \\n    for l,_ := range (*dp) {\\n        for m,_ := range (*dp)[l] {\\n            for n,_ := range (*dp)[l][m] {\\n                (*dp)[l][m][n] = -1\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 495685,
                "title": "description-or-test-cases-need-to-be-fixed",
                "content": "i found a lot of people not wrote correct algorithm, but still can pass.\\nand the offical solution in one cases will fail or description is missed.\\nwhen cat is blocked by 0, and mouse can reach to 0, in this case. tha mouse should win, but the result is DRAW.\\neg. [[2,3],[3],[0],[1,0]]\\nthe decription not said any info, when cat is blocked , the result of the game should be?\\nif mouse can continue, it should be mouse win.\\n\\nand there are a lot of people write dfs with mem solution.\\nhere is some more test cases for them to check it is correct or not\\n[[4],[2, 3, 5],[1, 5, 3],[1, 2],[0],[1, 2]] expect 2\\n[[],[5, 7],[3, 8, 9],[2, 4],[3, 6, 8, 10],[1, 6, 7, 10],[4, 5],[1, 5],[2, 4, 9],[2, 8],[4, 5]] expect 2",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 445811,
                "title": "go-bfs-solution-with-comments",
                "content": "For more Go Solution, please check: https://github.com/yinfirefire/LeetCode-GoSol\\n\\n```go\\nfunc catMouseGame(graph [][]int) int {\\n\\t//bfs from the final status (e.g. cat/mouse win, draw)\\n\\t//for each known status, get all its parent status,\\n\\t//for each parent status, check if all the child status is the same\\n\\t//if all child status are same, then the parent status is fixed\\n\\tn := len(graph)\\n\\tqueue := make([][]int, 0, 10)\\n\\tstates := [50][50][3]int{}\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 1; j <= 2; j++ {\\n\\t\\t\\tstates[0][i][j] = 1\\n\\t\\t\\tqueue = append(queue, []int{0, i, j})\\n\\n\\t\\t\\tif i != 0 {\\n\\t\\t\\t\\tstates[i][i][j] = 2\\n\\t\\t\\t\\tqueue = append(queue, []int{i, i, j})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor len(queue) > 0 {\\n\\t\\tcur := queue[0]\\n\\t\\tm := cur[0]\\n\\t\\tc := cur[1]\\n\\t\\tt := cur[2]\\n\\t\\tres := states[m][c][t]\\n\\t\\tqueue = queue[1:]\\n\\t\\tfor _, p := range getParents(graph, m, c, t) {\\n\\t\\t\\tif states[p[0]][p[1]][p[2]] != 0 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tif p[2] == res {\\n\\t\\t\\t\\t//the parent move is the final winner\\'s move\\n\\t\\t\\t\\t//then the final winner can win\\n\\t\\t\\t\\tstates[p[0]][p[1]][p[2]] = res\\n\\t\\t\\t\\tqueue = append(queue, p)\\n\\t\\t\\t}else if allKidsWin(graph, p[0], p[1], p[2], &states){\\n\\t\\t\\t\\tif p[2]==1{\\n\\t\\t\\t\\t\\tstates[p[0]][p[1]][p[2]] = 2\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tstates[p[0]][p[1]][p[2]] = 1\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tqueue = append(queue, p)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn states[1][2][1]\\n}\\n\\nfunc getParents(graph [][]int, m int, c int, turn int) [][]int {\\n\\tres := make([][]int, 0, 0)\\n\\tif turn == 1 {\\n\\t\\t//if current is mouse move\\n\\t\\t//then we check cat move for the parents\\n\\t\\tfor _, next := range graph[c] {\\n\\t\\t\\tif next != 0 {\\n\\t\\t\\t\\tres = append(res, []int{m, next, 2})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} else {\\n\\t\\tfor _, next := range graph[m] {\\n\\t\\t\\tres = append(res, []int{next, c, 1})\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n\\nfunc allKidsWin(graph [][]int, m int, c int, t int, states *[50][50][3]int)bool{\\n\\t//check if all the next step (opponent step leads to win)\\n\\t//if all next steps lead to opponent\\'s win, the current state is sure to lose\\n\\tif t==1{\\n\\t\\t//check mouse move\\n\\t\\tfor _, next:= range graph[m]{\\n\\t\\t\\tif (*states)[next][c][2]!=2{\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}else{\\n\\t\\tfor _, next:= range graph[c]{\\n\\t\\t\\tif next==0{\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tif (*states)[m][next][1]!=1{\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc catMouseGame(graph [][]int) int {\\n\\t//bfs from the final status (e.g. cat/mouse win, draw)\\n\\t//for each known status, get all its parent status,\\n\\t//for each parent status, check if all the child status is the same\\n\\t//if all child status are same, then the parent status is fixed\\n\\tn := len(graph)\\n\\tqueue := make([][]int, 0, 10)\\n\\tstates := [50][50][3]int{}\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 1; j <= 2; j++ {\\n\\t\\t\\tstates[0][i][j] = 1\\n\\t\\t\\tqueue = append(queue, []int{0, i, j})\\n\\n\\t\\t\\tif i != 0 {\\n\\t\\t\\t\\tstates[i][i][j] = 2\\n\\t\\t\\t\\tqueue = append(queue, []int{i, i, j})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor len(queue) > 0 {\\n\\t\\tcur := queue[0]\\n\\t\\tm := cur[0]\\n\\t\\tc := cur[1]\\n\\t\\tt := cur[2]\\n\\t\\tres := states[m][c][t]\\n\\t\\tqueue = queue[1:]\\n\\t\\tfor _, p := range getParents(graph, m, c, t) {\\n\\t\\t\\tif states[p[0]][p[1]][p[2]] != 0 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tif p[2] == res {\\n\\t\\t\\t\\t//the parent move is the final winner\\'s move\\n\\t\\t\\t\\t//then the final winner can win\\n\\t\\t\\t\\tstates[p[0]][p[1]][p[2]] = res\\n\\t\\t\\t\\tqueue = append(queue, p)\\n\\t\\t\\t}else if allKidsWin(graph, p[0], p[1], p[2], &states){\\n\\t\\t\\t\\tif p[2]==1{\\n\\t\\t\\t\\t\\tstates[p[0]][p[1]][p[2]] = 2\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tstates[p[0]][p[1]][p[2]] = 1\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tqueue = append(queue, p)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn states[1][2][1]\\n}\\n\\nfunc getParents(graph [][]int, m int, c int, turn int) [][]int {\\n\\tres := make([][]int, 0, 0)\\n\\tif turn == 1 {\\n\\t\\t//if current is mouse move\\n\\t\\t//then we check cat move for the parents\\n\\t\\tfor _, next := range graph[c] {\\n\\t\\t\\tif next != 0 {\\n\\t\\t\\t\\tres = append(res, []int{m, next, 2})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} else {\\n\\t\\tfor _, next := range graph[m] {\\n\\t\\t\\tres = append(res, []int{next, c, 1})\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n\\nfunc allKidsWin(graph [][]int, m int, c int, t int, states *[50][50][3]int)bool{\\n\\t//check if all the next step (opponent step leads to win)\\n\\t//if all next steps lead to opponent\\'s win, the current state is sure to lose\\n\\tif t==1{\\n\\t\\t//check mouse move\\n\\t\\tfor _, next:= range graph[m]{\\n\\t\\t\\tif (*states)[next][c][2]!=2{\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}else{\\n\\t\\tfor _, next:= range graph[c]{\\n\\t\\t\\tif next==0{\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tif (*states)[m][next][1]!=1{\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 441020,
                "title": "can-the-cat-just-force-a-tie-if-the-mouse-can-win",
                "content": "Question about a test case. \\n`[[6],[4],[9],[5],[1,5],[3,4,6],[0,5,10],[8,9,10],[7],[2,7],[6,7]]`\\nIn this situation, I understand the mouse can win the game. However, if the cat sees that he cannot catch the mouse, why can\\'t the cat simply repeat the move and force a draw? I assume draw is better than mouse win to the cat.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 380641,
                "title": "cpp-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        std::vector<std::vector<int>> dp(2,std::vector<int>(n*n,0));\\n        std::queue<std::vector<int>> q;\\n        \\n        for(int i=0; i<n; ++i){\\n            dp[0][i] = 1;\\n            dp[1][i] = 1;\\n            dp[0][n*i] = 1;\\n            dp[1][n*i] = 1;\\n            q.push({1,0,i});\\n        }\\n        \\n        for(int i=1; i<n; ++i){\\n            dp[0][n*i+i] = 2;\\n            dp[1][n*i+i] = 2;\\n            q.push({1,i,i});\\n            q.push({0,i,i});\\n        }\\n\\n        while(!q.empty()){\\n            int s = q.size();\\n            \\n            for(int c=0; c<s; ++c){\\n    \\n                auto const& v = q.front();\\n                int k(v[0]), i(v[1]), j(v[2]);\\n\\n                int w = k==0 ? j: i;\\n                int& u = k==0 ? j: i;\\n            \\n                for(uint d=0; d<graph[w].size(); ++d){\\n                        \\n                    u = graph[w][d];\\n                    if(dp[k^1][n*i+j] ==0){    \\n                        bool bl(false);\\n                        if(dp[k][n*v[1]+v[2]]%2!=k){ //v[0],v[1] is a losing position for current player.\\n                            int a(i), b(j);\\n                            int& x = k==0 ? b: a;\\n                            for(int e=0; e<graph[u].size(); ++e){\\n                                x = graph[u][e];\\n                                if(dp[k][n*a+b]!=dp[k][n*v[1]+v[2]]){\\n                                    bl = true;\\n                                    break;\\n                                }\\n                            }\\n                        }\\n                            \\n                        if(!bl){ \\n                            //setting cat or mouse winning position: bl is false when \\n                            //current player has the choice to go to already known winning position,\\n                            // or current player has no choice other than to go to losing position.\\n                            dp[k^1][n*i+j] = dp[k][n*v[1]+v[2]];\\n                            if(k^1==0&&i==1&&j==2)\\n                                return dp[k^1][n*i+j];\\n                            q.push({k^1,i,j});\\n                        } \\n                    }\\n                }\\n                q.pop();\\n            }\\n        }\\n        \\n        return 0;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        std::vector<std::vector<int>> dp(2,std::vector<int>(n*n,0));\\n        std::queue<std::vector<int>> q;\\n        \\n        for(int i=0; i<n; ++i){\\n            dp[0][i] = 1;\\n            dp[1][i] = 1;\\n            dp[0][n*i] = 1;\\n            dp[1][n*i] = 1;\\n            q.push({1,0,i}",
                "codeTag": "Java"
            },
            {
                "id": 360890,
                "title": "loop-until-convergence",
                "content": "Complexity : N^2 * (length of largest loop) = N^4.\\nLoop untill convergance solution :\\n// initial worklist\\n1- State= <m, c, turn> represent locations of mouse, cat and turn.\\n2-status[State] = who is winning if this state is reached.\\n3- if(m==c) cat wins.\\n4- if(m==0) mouse wins.\\n5- create all states and add them to work list.\\n\\n\\n// each itteration loop over all states and perform the following:\\n1- if state.turn == mouse : then a mouse will win if there is any path through a child for him to win, and a cat will win if all paths leads to cat win.\\n2- if state.turn == cat: then cat will win if there any path through a child that will make it win and mouse will win if all paths leads to  mouse win.\\n\\nkeep itterating over all states untill no more changes needed\\n\\n```\\n#define Tie 0\\n#define MWin 1\\n#define CWin 2\\n#define Mturn 0\\n#define Cturn 1\\nclass Solution {\\npublic:\\n      \\n    struct State{\\n      State(int m_, int c_, int turn_){\\n          m = m_;\\n          c = c_; \\n          turn = turn_;\\n      }\\n        \\n      int m; \\n      int c; \\n      bool turn; // 0 1, 1 :ca\\n     \\n    };\\n    struct cmp{\\n       bool operator()(const State& lhs, const State& rhs) const{\\n          return pair(lhs.m, pair(lhs.c, lhs.turn))< pair(rhs.m, pair(rhs.c, rhs.turn));\\n      }  \\n    };\\n    bool isChanged = true;\\n    // 0 :tie. 1 :mouse win. 2: cat win\\n    map<State, int, cmp> status;\\n\\n    \\n    int catMouseGame(vector<vector<int>>& graph) {\\n        for(int i=0; i<graph.size(); i++ ){\\n            for(int j=1; j<graph.size(); j++ ){\\n                if(i==j){\\n                    status[State(i, j, Mturn)] = 2;\\n                    status[State(i, j, Cturn)] = 2;\\n                }\\n                else if(i==0){\\n                    status[State(i, j, Mturn)] = 1;\\n                    status[State(i, j, Cturn)] = 1;\\n                }\\n                else{\\n                    status[State(i, j, Mturn)] = 0;\\n                    status[State(i, j, Cturn)] = 0;\\n                }\\n            }\\n        }\\n        // Do DFS max n*n times. (longes cycle i assume)\\n        while(isChanged){\\n           isChanged = false;\\n           // for each state:\\n            for(auto &ss:status){\\n                auto s=ss.first;\\n                if(status[s]!=Tie)\\n                    continue;\\n                \\n                // mouse turn state\\n                if(s.turn==Mturn){\\n                    bool mouseWin = false;\\n                    bool catWin = true; \\n                    for(int i=0; i<graph[s.m].size(); i++){\\n                        auto child= State(graph[s.m][i], s.c, Cturn);\\n                        mouseWin |= (status[child] == MWin);\\n                        if(status[child]== MWin || status[child] ==Tie){\\n                            catWin = false;\\n                        }\\n                    }\\n                    assert(!(catWin && mouseWin)&& \"both cant win\");\\n                    \\n                    if(catWin){\\n                        isChanged = true;\\n                        status[s]=CWin;\\n                    }\\n                    else if(mouseWin){\\n                        isChanged = true;\\n                        status[s]=MWin;\\n                    }\\n                    continue;\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//cat turn state\\n                if(s.turn==Cturn){\\n                    bool mouseWin = true;\\n                    bool catWin = false;  \\n                    for(int i=0; i<graph[s.c].size(); i++){\\n                        if(graph[s.c][i] ==0 )\\n                            continue;\\n                        \\n                        auto child= State(s.m, graph[s.c][i], Mturn);\\n                        catWin |= (status[child] == CWin);\\n                        if(status[child]== CWin || status[child] ==Tie){\\n                            mouseWin = false;\\n                        }\\n                    }\\n                    assert(!(catWin && mouseWin)&& \"both cant win\");\\n                    if(catWin){\\n                        isChanged = true;\\n                        status[s]=CWin;\\n                    }\\n                    else if(mouseWin){\\n                        isChanged = true;\\n                        status[s]=MWin;\\n                    }\\n                    continue;\\n                }\\n            }\\n        }\\n        return status[State(1, 2, Mturn)];\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define Tie 0\\n#define MWin 1\\n#define CWin 2\\n#define Mturn 0\\n#define Cturn 1\\nclass Solution {\\npublic:\\n      \\n    struct State{\\n      State(int m_, int c_, int turn_){\\n          m = m_;\\n          c = c_; \\n          turn = turn_;\\n      }\\n        \\n      int m; \\n      int c; \\n      bool turn; // 0 1, 1 :ca\\n     \\n    };\\n    struct cmp{\\n       bool operator()(const State& lhs, const State& rhs) const{\\n          return pair(lhs.m, pair(lhs.c, lhs.turn))< pair(rhs.m, pair(rhs.c, rhs.turn));\\n      }  \\n    };\\n    bool isChanged = true;\\n    // 0 :tie. 1 :mouse win. 2: cat win\\n    map<State, int, cmp> status;\\n\\n    \\n    int catMouseGame(vector<vector<int>>& graph) {\\n        for(int i=0; i<graph.size(); i++ ){\\n            for(int j=1; j<graph.size(); j++ ){\\n                if(i==j){\\n                    status[State(i, j, Mturn)] = 2;\\n                    status[State(i, j, Cturn)] = 2;\\n                }\\n                else if(i==0){\\n                    status[State(i, j, Mturn)] = 1;\\n                    status[State(i, j, Cturn)] = 1;\\n                }\\n                else{\\n                    status[State(i, j, Mturn)] = 0;\\n                    status[State(i, j, Cturn)] = 0;\\n                }\\n            }\\n        }\\n        // Do DFS max n*n times. (longes cycle i assume)\\n        while(isChanged){\\n           isChanged = false;\\n           // for each state:\\n            for(auto &ss:status){\\n                auto s=ss.first;\\n                if(status[s]!=Tie)\\n                    continue;\\n                \\n                // mouse turn state\\n                if(s.turn==Mturn){\\n                    bool mouseWin = false;\\n                    bool catWin = true; \\n                    for(int i=0; i<graph[s.m].size(); i++){\\n                        auto child= State(graph[s.m][i], s.c, Cturn);\\n                        mouseWin |= (status[child] == MWin);\\n                        if(status[child]== MWin || status[child] ==Tie){\\n                            catWin = false;\\n                        }\\n                    }\\n                    assert(!(catWin && mouseWin)&& \"both cant win\");\\n                    \\n                    if(catWin){\\n                        isChanged = true;\\n                        status[s]=CWin;\\n                    }\\n                    else if(mouseWin){\\n                        isChanged = true;\\n                        status[s]=MWin;\\n                    }\\n                    continue;\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//cat turn state\\n                if(s.turn==Cturn){\\n                    bool mouseWin = true;\\n                    bool catWin = false;  \\n                    for(int i=0; i<graph[s.c].size(); i++){\\n                        if(graph[s.c][i] ==0 )\\n                            continue;\\n                        \\n                        auto child= State(s.m, graph[s.c][i], Mturn);\\n                        catWin |= (status[child] == CWin);\\n                        if(status[child]== CWin || status[child] ==Tie){\\n                            mouseWin = false;\\n                        }\\n                    }\\n                    assert(!(catWin && mouseWin)&& \"both cant win\");\\n                    if(catWin){\\n                        isChanged = true;\\n                        status[s]=CWin;\\n                    }\\n                    else if(mouseWin){\\n                        isChanged = true;\\n                        status[s]=MWin;\\n                    }\\n                    continue;\\n                }\\n            }\\n        }\\n        return status[State(1, 2, Mturn)];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 251885,
                "title": "solution-fails-for-the-last-test-case",
                "content": "\\tclass Solution {\\n\\t\\tint[][] graph;\\n\\t\\tMap<Integer, Set<Integer>> edge;\\n\\t\\tMap<String, Integer> sol;\\n\\t\\tpublic int catMouseGame(int[][] graph) {\\n\\t\\t\\tthis.graph = graph;\\n\\t\\t\\tsol = new HashMap();\\n\\t\\t\\tedge= new HashMap();\\n\\t\\t\\tfor(int i = 0; i < graph.length; i++){\\n\\t\\t\\t\\tfor(int j : graph[i]){\\n\\t\\t\\t\\t\\tif(j != i){\\n\\t\\t\\t\\t\\t   if(!edge.containsKey(i)) edge.put(i, new LinkedHashSet());\\n\\t\\t\\t\\t\\t\\tif(!edge.containsKey(j)) edge.put(j, new LinkedHashSet());\\n\\t\\t\\t\\t\\t\\tedge.get(i).add(j);\\n\\t\\t\\t\\t\\t\\tedge.get(j).add(i); \\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tint result = max(2, 1);\\n\\t\\t\\treturn result == -1 ? 2 : result;\\n\\t\\t}\\n    \\n    int max(int catNode, int mouseNode){\\n        String key = catNode + \"_mouse_\" + mouseNode;\\n        if(sol.containsKey(key)){\\n            return sol.get(key);\\n        }\\n        if(edge.get(mouseNode).contains(0)){\\n            sol.put(key, 1);\\n            return 1;\\n        }\\n        sol.put(key, 0);\\n        int max = -1;\\n        for(int i : edge.get(mouseNode)){\\n            if(i == catNode) continue;\\n            max = Math.max(max, min(catNode, i));\\n            if(max == 1) break;\\n        }\\n        System.out.println(key + \" \" + max);\\n        sol.put(key, max);\\n        return max;\\n    }\\n    \\n    int min(int catNode, int mouseNode){\\n        String key = catNode + \"_cat_\" + mouseNode;\\n        if(sol.containsKey(key)) return sol.get(key);\\n        if(edge.get(catNode).contains(mouseNode)){\\n            sol.put(key, -1);\\n            return -1;\\n        }\\n        sol.put(key, 0);\\n        int min = 1;\\n        for(int ed : edge.get(catNode)){\\n            if(ed == 0) continue;\\n            min = Math.min(min, max(ed, mouseNode));\\n            if(min == -1) break;\\n        }\\n        sol.put(key, min);\\n        return min;\\n    }\\n}\\n\\nThis code fails for the test case [[6],[4],[9],[5],[1,5],[3,4,6],[0,5,10],[8,9,10],[7],[2,7],[6,7]]. Any help appreciated",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tint[][] graph;\\n\\t\\tMap<Integer, Set<Integer>> edge;\\n\\t\\tMap<String, Integer> sol;\\n\\t\\tpublic int catMouseGame(int[][] graph) {\\n\\t\\t\\tthis.graph = graph;\\n\\t\\t\\tsol = new HashMap();\\n\\t\\t\\tedge= new HashMap();\\n\\t\\t\\tfor(int i = 0; i < graph.length; i++){\\n\\t\\t\\t\\tfor(int j : graph[i]){\\n\\t\\t\\t\\t\\tif(j != i){\\n\\t\\t\\t\\t\\t   if(!edge.containsKey(i)) edge.put(i, new LinkedHashSet());\\n\\t\\t\\t\\t\\t\\tif(!edge.containsKey(j)) edge.put(j, new LinkedHashSet());\\n\\t\\t\\t\\t\\t\\tedge.get(i).add(j);\\n\\t\\t\\t\\t\\t\\tedge.get(j).add(i); \\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 249457,
                "title": "readable-solution-in-javascript",
                "content": "This is exactly the same solution as the official one, but in Javascript.\\n\\n```Javascript\\n// implement Queue data structure\\nclass QNode {\\n  constructor(val) {\\n    this.val = val;\\n    this.pred = this.succ = null;\\n  }\\n}\\n\\nclass Queue {\\n  constructor() {\\n    const front = new QNode();\\n    const end = new QNode();\\n    front.succ = end;\\n    end.pred = front;\\n    this.front = front;\\n    this.end = end;\\n  }\\n  empty() {\\n    return this.front.succ === this.end;\\n  }\\n  enqueue(val) {\\n    const newNode = new QNode(val);\\n    newNode.succ = this.end;\\n    this.end.pred.succ = newNode;\\n    this.end.pred = newNode;\\n  }\\n  dequeue() {\\n    const val = this.front.succ.val;\\n    const newFirstNode = this.front.succ.succ;\\n    newFirstNode.pred = this.front;\\n    this.front.succ = newFirstNode;\\n    return val;\\n  }\\n}\\n\\n\\nconst countNonZero = xs => {\\n  for (let i = 0; i < xs.length; i++) {\\n    if (xs[i] === 0) return xs.length - 1;\\n  }\\n  return xs.length;\\n}\\n\\nconst DRAW = 0;\\nconst MOUSE = 1;\\nconst CAT = 2;\\n\\nvar catMouseGame = function(graph) {\\n  const N = graph.length;\\n\\n  const graphMatrix = new Array(N).fill().map(\\n    (_, mousePos) => (new Array(N).fill().map(\\n      (_, catPos) => ({\\n        degree: {\\n          // now we are in (mousePos, catPos)\\n          [MOUSE]: graph[mousePos].length, // number of ways that mouse can move to from current pos if it\\'s mouse\\'s move\\n          [CAT]: countNonZero(graph[catPos]), // number of ways that cat can move to from current pos if it\\'s cat\\'s move\\n        },\\n        color: {\\n          [MOUSE]: DRAW, // the outcome if it\\'s mouse\\'s turn to move\\n          [CAT]: DRAW, // the outcome if it\\'s cat\\'s turn to move\\n        }\\n      }),\\n    ))\\n  );\\n\\n  class Node {\\n    constructor(mousePos, catPos, whichTurn) {\\n      this.mousePos = mousePos;\\n      this.catPos = catPos;\\n      this.whichTurn = whichTurn; // which player moves now\\n    }\\n    getColor() {\\n      return graphMatrix[this.mousePos][this.catPos].color[this.whichTurn];\\n    }\\n    setColor(color) {\\n      graphMatrix[this.mousePos][this.catPos].color[this.whichTurn] = color;\\n    }\\n    decDegree() {\\n      graphMatrix[this.mousePos][this.catPos].degree[this.whichTurn]--;\\n    }\\n    getDegree() {\\n      return graphMatrix[this.mousePos][this.catPos].degree[this.whichTurn];\\n    }\\n    getParents() {\\n      const parents = [];\\n      switch (this.whichTurn) {\\n        case CAT: // then the previous turn would be mouse\\n          for (let prevMousePos of graph[this.mousePos]) {\\n            parents.push(new Node(prevMousePos, this.catPos, MOUSE));\\n          }\\n          break;\\n        case MOUSE: // then the previous turn would be cat\\n          for (let prevCatPos of graph[this.catPos]) {\\n            if (prevCatPos === 0) continue;\\n            parents.push(new Node(this.mousePos, prevCatPos, CAT));\\n          }\\n          break;\\n      }\\n      return parents;\\n    }\\n  }\\n\\n  const queue = new Queue();\\n  for (let i = 1; i < N; i++) {\\n    for (let player of [MOUSE, CAT]) {\\n      const mouseWinNode = new Node(0, i, player);\\n      mouseWinNode.setColor(MOUSE);\\n      queue.enqueue(mouseWinNode);\\n\\t  const catWinNode = new Node(i, i, player);\\n      catWinNode.setColor(CAT);\\n\\t  queue.enqueue(catWinNode);\\n    }\\n  }\\n\\n  // all nodes in queue are colored\\n  while (!queue.empty()) {\\n    const currNode = queue.dequeue();\\n    const color = currNode.getColor();\\n\\n    for (let parent of currNode.getParents()) {\\n      if (parent.getColor() === DRAW) { // if it\\'s uncolored\\n        if (parent.whichTurn === color) { // if we can decide the color\\n          parent.setColor(color);\\n          queue.enqueue(parent);\\n        } else { // we can\\'t decide the color, but we can be sure that the parent node has one less chance to win\\n          parent.decDegree();\\n          if (parent.getDegree() === 0) { // loses if has no chance to win\\n            const failColor = parent.whichTurn === CAT ? MOUSE : CAT;\\n            parent.setColor(failColor);\\n            queue.enqueue(parent);\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  const startNode = new Node(1, 2, MOUSE);\\n  return startNode.getColor();\\n}\\n```",
                "solutionTags": [],
                "code": "```Javascript\\n// implement Queue data structure\\nclass QNode {\\n  constructor(val) {\\n    this.val = val;\\n    this.pred = this.succ = null;\\n  }\\n}\\n\\nclass Queue {\\n  constructor() {\\n    const front = new QNode();\\n    const end = new QNode();\\n    front.succ = end;\\n    end.pred = front;\\n    this.front = front;\\n    this.end = end;\\n  }\\n  empty() {\\n    return this.front.succ === this.end;\\n  }\\n  enqueue(val) {\\n    const newNode = new QNode(val);\\n    newNode.succ = this.end;\\n    this.end.pred.succ = newNode;\\n    this.end.pred = newNode;\\n  }\\n  dequeue() {\\n    const val = this.front.succ.val;\\n    const newFirstNode = this.front.succ.succ;\\n    newFirstNode.pred = this.front;\\n    this.front.succ = newFirstNode;\\n    return val;\\n  }\\n}\\n\\n\\nconst countNonZero = xs => {\\n  for (let i = 0; i < xs.length; i++) {\\n    if (xs[i] === 0) return xs.length - 1;\\n  }\\n  return xs.length;\\n}\\n\\nconst DRAW = 0;\\nconst MOUSE = 1;\\nconst CAT = 2;\\n\\nvar catMouseGame = function(graph) {\\n  const N = graph.length;\\n\\n  const graphMatrix = new Array(N).fill().map(\\n    (_, mousePos) => (new Array(N).fill().map(\\n      (_, catPos) => ({\\n        degree: {\\n          // now we are in (mousePos, catPos)\\n          [MOUSE]: graph[mousePos].length, // number of ways that mouse can move to from current pos if it\\'s mouse\\'s move\\n          [CAT]: countNonZero(graph[catPos]), // number of ways that cat can move to from current pos if it\\'s cat\\'s move\\n        },\\n        color: {\\n          [MOUSE]: DRAW, // the outcome if it\\'s mouse\\'s turn to move\\n          [CAT]: DRAW, // the outcome if it\\'s cat\\'s turn to move\\n        }\\n      }),\\n    ))\\n  );\\n\\n  class Node {\\n    constructor(mousePos, catPos, whichTurn) {\\n      this.mousePos = mousePos;\\n      this.catPos = catPos;\\n      this.whichTurn = whichTurn; // which player moves now\\n    }\\n    getColor() {\\n      return graphMatrix[this.mousePos][this.catPos].color[this.whichTurn];\\n    }\\n    setColor(color) {\\n      graphMatrix[this.mousePos][this.catPos].color[this.whichTurn] = color;\\n    }\\n    decDegree() {\\n      graphMatrix[this.mousePos][this.catPos].degree[this.whichTurn]--;\\n    }\\n    getDegree() {\\n      return graphMatrix[this.mousePos][this.catPos].degree[this.whichTurn];\\n    }\\n    getParents() {\\n      const parents = [];\\n      switch (this.whichTurn) {\\n        case CAT: // then the previous turn would be mouse\\n          for (let prevMousePos of graph[this.mousePos]) {\\n            parents.push(new Node(prevMousePos, this.catPos, MOUSE));\\n          }\\n          break;\\n        case MOUSE: // then the previous turn would be cat\\n          for (let prevCatPos of graph[this.catPos]) {\\n            if (prevCatPos === 0) continue;\\n            parents.push(new Node(this.mousePos, prevCatPos, CAT));\\n          }\\n          break;\\n      }\\n      return parents;\\n    }\\n  }\\n\\n  const queue = new Queue();\\n  for (let i = 1; i < N; i++) {\\n    for (let player of [MOUSE, CAT]) {\\n      const mouseWinNode = new Node(0, i, player);\\n      mouseWinNode.setColor(MOUSE);\\n      queue.enqueue(mouseWinNode);\\n\\t  const catWinNode = new Node(i, i, player);\\n      catWinNode.setColor(CAT);\\n\\t  queue.enqueue(catWinNode);\\n    }\\n  }\\n\\n  // all nodes in queue are colored\\n  while (!queue.empty()) {\\n    const currNode = queue.dequeue();\\n    const color = currNode.getColor();\\n\\n    for (let parent of currNode.getParents()) {\\n      if (parent.getColor() === DRAW) { // if it\\'s uncolored\\n        if (parent.whichTurn === color) { // if we can decide the color\\n          parent.setColor(color);\\n          queue.enqueue(parent);\\n        } else { // we can\\'t decide the color, but we can be sure that the parent node has one less chance to win\\n          parent.decDegree();\\n          if (parent.getDegree() === 0) { // loses if has no chance to win\\n            const failColor = parent.whichTurn === CAT ? MOUSE : CAT;\\n            parent.setColor(failColor);\\n            queue.enqueue(parent);\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  const startNode = new Node(1, 2, MOUSE);\\n  return startNode.getColor();\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 230116,
                "title": "c-convert-to-graph-then-dfs",
                "content": "the basic idea is convert a state to a vertex in graph and represent by a integer(id)\\na state contains three varaible: cat position, mouse position, the current player(cat or mouse).  I define id = (cat position * n + mouse position ) * 2 + isMouse(0 or 1)\\n\\n```\\nclass Solution {\\npublic:\\n   int catMouseGame(vector<vector<int>>& rawGraph) {\\n      initialize(rawGraph);\\n      queue<int> q;\\n      for (int i = 0; i < winState.size(); i++)\\n         if (winState[i] != DRAW) q.push(i);\\n\\n      while (!q.empty()) {\\n         auto id = q.front(); q.pop();\\n         if (visited[id]) continue;\\n         visited[id] = true;\\n         for (auto pre : preGraph[id]) {\\n            if (winState[pre] != DRAW) continue;\\n            if (winState[id] == LOST) {\\n               winState[pre] = WIN;\\n               q.push(pre);\\n            }\\n            else if (winState[id] == WIN) {\\n               postGraph[pre].erase(id);\\n               if (postGraph[pre].empty()) {\\n                  winState[pre] = LOST;\\n                  q.push(pre);\\n               }\\n            }\\n         }\\n      }\\n      return winState[startId];\\n   }\\n\\n   void initialize(const vector<vector<int>>& rawGraph) {\\n      const int n = rawGraph.size();\\n      const int m = n * n * 2;\\n      startId = 2 * (2 * n + 1) + MOUSE;\\n      preGraph.resize(m);\\n      postGraph.resize(m);\\n      visited = vector<bool>(m, false);\\n      winState = vector<WinState>(m, DRAW);\\n\\n      for (int catPos = 1; catPos < n; catPos++) { //cat pos cannot be 0\\n         for (int mousePos = 0; mousePos < n; mousePos++) {\\n            const int curStateID = 2 * (catPos * n + mousePos);\\n            for (auto catNeighb : rawGraph[catPos]) {\\n               if (catNeighb == 0) continue;\\n               int neighborStateID = 2 * (catNeighb * n + mousePos);\\n               preGraph[curStateID + MOUSE].insert(neighborStateID + CAT);\\n               postGraph[neighborStateID + CAT].insert(curStateID + MOUSE);\\n            }\\n            for (auto mousePrePos : rawGraph[mousePos]) {\\n               int neighborStateID = 2 * (catPos * n + mousePrePos);\\n               preGraph[curStateID + CAT].insert(neighborStateID + MOUSE);\\n               postGraph[neighborStateID + MOUSE].insert(curStateID + CAT);\\n            }\\n         }\\n      }\\n\\n      for (int i = 1; i < n; i++) {\\n         int curStateID = 2 * (i * n + i);\\n         winState[curStateID + CAT] = WIN;\\n         winState[curStateID + MOUSE] = LOST;\\n      }\\n\\n      for (int catPos = 1; catPos < n; catPos++) {\\n         int mousePos = 0;\\n         int curStateID = 2 * (catPos * n + mousePos);\\n         winState[curStateID + MOUSE] = WIN;\\n         winState[curStateID + CAT] = LOST;\\n      }\\n   }\\n\\n   enum Player {\\n      CAT,\\n      MOUSE,\\n   };\\n\\n   enum WinState {\\n      LOST = 2,\\n      WIN = 1,\\n      DRAW = 0,\\n   };\\n\\n   int startId;\\n   vector<set<int>> preGraph;\\n   vector<set<int>> postGraph;\\n   vector<bool> visited;\\n   vector<WinState> winState;\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n   int catMouseGame(vector<vector<int>>& rawGraph) {\\n      initialize(rawGraph);\\n      queue<int> q;\\n      for (int i = 0; i < winState.size(); i++)\\n         if (winState[i] != DRAW) q.push(i);\\n\\n      while (!q.empty()) {\\n         auto id = q.front(); q.pop();\\n         if (visited[id]) continue;\\n         visited[id] = true;\\n         for (auto pre : preGraph[id]) {\\n            if (winState[pre] != DRAW) continue;\\n            if (winState[id] == LOST) {\\n               winState[pre] = WIN;\\n               q.push(pre);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 215722,
                "title": "if-cat-knows-mouse-will-win-shouldn-t-it-tried-to-force-a-draw",
                "content": "consider this graph\\n\\n0 - 3 - 4 - 5 - 1       \\n2 - 6 - 7 - 8 - 9\\n\\nin this case. Cat knows there is no way it can prevent mouse from reaching 0, shouldn\\'t cat just go back and forth between 2, 6 to force a draw?\\n\\nthe leedcode judge return 1 for this case",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 209176,
                "title": "a-combined-fast-way",
                "content": "i find a fast way to determine whether mouse can win or not. if the result is yes, it means the mouse can win. but if it cannot find a fast way for mouse to win, it doesn\\'t means  mouse cann\\'t win..\\nso i use the fast way  to find fast way for mouse. if it\\'s ok, i will return the 1. if not, i will go to a more accurate way to find the result.\\nit\\'s so-call combined fast way. the code is following:\\n```C\\nint catMouseGameFast(int** graph, int m, int *n) {\\n   int stepNum1[60],stepNum2[60],tmp1[60],tmp2[60];int count=0;\\n\\n    for(int i=0;i<m;i++) {stepNum1[i]=-1;stepNum2[i]=-1;}\\n    stepNum1[1]=0;stepNum2[2]=0;\\n    for(int i=0;i<m;i++) {\\n        for(int j=0;j<m;j++){tmp1[j]=-1;tmp2[j]=-1;}\\n        for(int j=0;j<m;j++)\\n                for(int k=0;k<n[j];k++){\\n                    if(stepNum1[j]==i  && stepNum2[graph[j][k]]!=i) tmp1[graph[j][k]]=i+1;\\n                    if(stepNum2[j]==i && graph[j][k]!=0) tmp2[graph[j][k]]=i+1;\\n                }\\n        for(int j=0;j<m;j++){stepNum1[j]=tmp1[j];stepNum2[j]=tmp2[j];if(tmp2[j]==i+1)stepNum1[j]=-1;}\\n        if(stepNum1[0]==i+1) return 1;\\n    }\\n    return -1;\\n}\\nint catMouseGame(int** graph, int m, int *n) {\\n    if(catMouseGameFast(graph,m,n)==1) return 1;\\n    int graphB[50][50],nB[50],child;\\n    for(int i=0;i<m;i++)\\n        nB[i]=0;\\n    for(int i=0;i<m;i++)\\n        for(int j=0;j<n[i];j++){\\n            child=graph[i][j];\\n            graphB[child][nB[child]]=i;\\n            nB[child]++;\\n        }\\n    int color[50][50][2],res[50][50][2],list[50*50*2][3];\\n    for(int i=0;i<m;i++)\\n        for(int j=0;j<m;j++){\\n            color[i][j][0]=0;\\n            color[i][j][1]=0;\\n            res[i][j][0]=n[i];\\n            res[i][j][1]=n[j];\\n           if(graph[j][0]==0 && n[j]>0) res[i][j][1]=n[j]-1;\\n            if(i==j && i!=0 && j!=0){\\n              color[i][j][0]=2;\\n              color[i][j][1]=2;\\n            }\\n            if(i==0 && j!=0){\\n              color[i][j][0]=1;\\n              color[i][j][1]=1;\\n            }\\n        }\\n    int head=0,end=0;\\n    for(int k=0;k<2;k++)\\n       for(int i=0;i<m;i++)\\n           for(int j=0;j<m;j++)\\n                if(color[i][j][k]!=0){\\n                    list[end][0]=i;\\n                    list[end][1]=j;\\n                    list[end][2]=k;\\n                    end++;\\n                }\\n  \\n    int bp;int ii,jj,kk;\\n    while(head<end){\\n        ii=list[head][0];\\n        jj=list[head][1];\\n        kk=list[head][2];\\n        if(kk==0){\\n            if (color[ii][jj][kk]==2){\\n                for(int i=0;i<nB[jj];i++){\\n                    bp=graphB[jj][i];\\n                    if(bp==0) continue;\\n                    if(color[ii][bp][1]!=0) continue;\\n                  //  if(head->m==bp) continue;\\n                    list[end][0]=ii;\\n                    list[end][1]=bp;\\n                    list[end][2]=1;\\n                    color[ii][bp][1]=2;\\n                    end++;\\n                }\\n            }\\n            else{\\n                for(int i=0;i<nB[jj];i++){\\n                    bp=graphB[jj][i];\\n                    if(bp==0) continue;\\n                    if(color[ii][bp][1]!=0) continue;\\n                    res[ii][bp][1]--;\\n                    if(res[ii][bp][1]<=0)\\n                    {\\n                        //return 1000+bp*10+head->m;\\n                        list[end][0]=ii;\\n                        list[end][1]=bp;\\n                        list[end][2]=1;\\n                        color[ii][bp][1]=1;\\n                        end++;\\n                    }       \\n                }\\n            }\\n            \\n        }\\n        else{\\n            if(color[ii][jj][kk]==1){\\n                for(int i=0;i<nB[ii];i++){\\n                    bp=graphB[ii][i];\\n                    if(color[bp][jj][0]!=0) continue;\\n                   // if(head->c==bp) continue;\\n                    list[end][0]=bp;\\n                    list[end][1]=jj;\\n                    list[end][2]=0;\\n                    color[bp][jj][0]=1;\\n                    end++;\\n                }\\n            }\\n            else{\\n                for(int i=0;i<nB[ii];i++){\\n                    bp=graphB[ii][i];\\n                    if(color[bp][jj][0]!=0) continue;\\n                    res[bp][jj][0]--;\\n                    if(res[bp][jj][0]<=0)\\n                    {\\n                        list[end][0]=bp;\\n                        list[end][1]=jj;\\n                        list[end][2]=0;\\n                        color[bp][jj][0]=2;\\n                       end++;\\n                        \\n                    }\\n                }\\n            }\\n        }\\n        head++;\\n        if(color[1][2][0]!=0) return color[1][2][0];\\n    }\\n    return color[1][2][0];\\n}\\n}\\n```",
                "solutionTags": [],
                "code": "```C\\nint catMouseGameFast(int** graph, int m, int *n) {\\n   int stepNum1[60],stepNum2[60],tmp1[60],tmp2[60];int count=0;\\n\\n    for(int i=0;i<m;i++) {stepNum1[i]=-1;stepNum2[i]=-1;}\\n    stepNum1[1]=0;stepNum2[2]=0;\\n    for(int i=0;i<m;i++) {\\n        for(int j=0;j<m;j++){tmp1[j]=-1;tmp2[j]=-1;}\\n        for(int j=0;j<m;j++)\\n                for(int k=0;k<n[j];k++){\\n                    if(stepNum1[j]==i  && stepNum2[graph[j][k]]!=i) tmp1[graph[j][k]]=i+1;\\n                    if(stepNum2[j]==i && graph[j][k]!=0) tmp2[graph[j][k]]=i+1;\\n                }\\n        for(int j=0;j<m;j++){stepNum1[j]=tmp1[j];stepNum2[j]=tmp2[j];if(tmp2[j]==i+1)stepNum1[j]=-1;}\\n        if(stepNum1[0]==i+1) return 1;\\n    }\\n    return -1;\\n}\\nint catMouseGame(int** graph, int m, int *n) {\\n    if(catMouseGameFast(graph,m,n)==1) return 1;\\n    int graphB[50][50],nB[50],child;\\n    for(int i=0;i<m;i++)\\n        nB[i]=0;\\n    for(int i=0;i<m;i++)\\n        for(int j=0;j<n[i];j++){\\n            child=graph[i][j];\\n            graphB[child][nB[child]]=i;\\n            nB[child]++;\\n        }\\n    int color[50][50][2],res[50][50][2],list[50*50*2][3];\\n    for(int i=0;i<m;i++)\\n        for(int j=0;j<m;j++){\\n            color[i][j][0]=0;\\n            color[i][j][1]=0;\\n            res[i][j][0]=n[i];\\n            res[i][j][1]=n[j];\\n           if(graph[j][0]==0 && n[j]>0) res[i][j][1]=n[j]-1;\\n            if(i==j && i!=0 && j!=0){\\n              color[i][j][0]=2;\\n              color[i][j][1]=2;\\n            }\\n            if(i==0 && j!=0){\\n              color[i][j][0]=1;\\n              color[i][j][1]=1;\\n            }\\n        }\\n    int head=0,end=0;\\n    for(int k=0;k<2;k++)\\n       for(int i=0;i<m;i++)\\n           for(int j=0;j<m;j++)\\n                if(color[i][j][k]!=0){\\n                    list[end][0]=i;\\n                    list[end][1]=j;\\n                    list[end][2]=k;\\n                    end++;\\n                }\\n  \\n    int bp;int ii,jj,kk;\\n    while(head<end){\\n        ii=list[head][0];\\n        jj=list[head][1];\\n        kk=list[head][2];\\n        if(kk==0){\\n            if (color[ii][jj][kk]==2){\\n                for(int i=0;i<nB[jj];i++){\\n                    bp=graphB[jj][i];\\n                    if(bp==0) continue;\\n                    if(color[ii][bp][1]!=0) continue;\\n                  //  if(head->m==bp) continue;\\n                    list[end][0]=ii;\\n                    list[end][1]=bp;\\n                    list[end][2]=1;\\n                    color[ii][bp][1]=2;\\n                    end++;\\n                }\\n            }\\n            else{\\n                for(int i=0;i<nB[jj];i++){\\n                    bp=graphB[jj][i];\\n                    if(bp==0) continue;\\n                    if(color[ii][bp][1]!=0) continue;\\n                    res[ii][bp][1]--;\\n                    if(res[ii][bp][1]<=0)\\n                    {\\n                        //return 1000+bp*10+head->m;\\n                        list[end][0]=ii;\\n                        list[end][1]=bp;\\n                        list[end][2]=1;\\n                        color[ii][bp][1]=1;\\n                        end++;\\n                    }       \\n                }\\n            }\\n            \\n        }\\n        else{\\n            if(color[ii][jj][kk]==1){\\n                for(int i=0;i<nB[ii];i++){\\n                    bp=graphB[ii][i];\\n                    if(color[bp][jj][0]!=0) continue;\\n                   // if(head->c==bp) continue;\\n                    list[end][0]=bp;\\n                    list[end][1]=jj;\\n                    list[end][2]=0;\\n                    color[bp][jj][0]=1;\\n                    end++;\\n                }\\n            }\\n            else{\\n                for(int i=0;i<nB[ii];i++){\\n                    bp=graphB[ii][i];\\n                    if(color[bp][jj][0]!=0) continue;\\n                    res[bp][jj][0]--;\\n                    if(res[bp][jj][0]<=0)\\n                    {\\n                        list[end][0]=bp;\\n                        list[end][1]=jj;\\n                        list[end][2]=0;\\n                        color[bp][jj][0]=2;\\n                       end++;\\n                        \\n                    }\\n                }\\n            }\\n        }\\n        head++;\\n        if(color[1][2][0]!=0) return color[1][2][0];\\n    }\\n    return color[1][2][0];\\n}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 207915,
                "title": "c-source-code-use-dfs",
                "content": "```\\nstruct Node {\\n\\tbool isDefined;\\n\\tint* result;\\n};\\nint mainFunction(int** graph, int graphRowSize, int *graphColSizes, int Cat, int Mouse, int playerNo, struct Node*** resultMap) {\\n\\tint result = -1;//-1 means unknown\\n\\tif (resultMap[Cat][Mouse][playerNo - 1].isDefined == false) {\\n\\t\\tresultMap[Cat][Mouse][playerNo - 1].isDefined = true;\\n\\t\\tif (Cat == Mouse) {// Cat meets Mouse\\n\\t\\t\\t*(resultMap[Cat][Mouse][playerNo - 1].result) = 2;\\n\\t\\t\\treturn 2;\\n\\t\\t}\\n\\t\\telse if (Mouse == 0) {//Mouse is at 0\\n\\t\\t\\t*(resultMap[Cat][Mouse][playerNo - 1].result) = 1;\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tint result_i = 0;\\n\\t\\t\\tint *result_i_ptr = NULL;\\n\\t\\t\\tif (playerNo == 1) { // Mouse\\n\\t\\t\\t\\tfor (int i = 0; i < graphColSizes[Mouse]; i++) {\\n\\t\\t\\t\\t\\tresult_i = mainFunction(graph, graphRowSize, graphColSizes, Cat, graph[Mouse][i], 2, resultMap);\\n\\t\\t\\t\\t\\tif (result_i == 1) { // if win, just win\\n\\t\\t\\t\\t\\t\\tresult = 1;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if (result_i == 2 && result == -1) { // if all is lose, then lose\\n\\t\\t\\t\\t\\t\\tresult = 2;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if (result_i == 0 || result_i == -1) { //if there are some unknown items\\n\\t\\t\\t\\t\\t\\tresult = 0;\\n\\t\\t\\t\\t\\t\\tresult_i_ptr = resultMap[Cat][graph[Mouse][i]][1].result;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (result != 0)\\n\\t\\t\\t\\t\\t*(resultMap[Cat][Mouse][playerNo - 1].result) = result;\\n\\t\\t\\t\\telse resultMap[Cat][Mouse][playerNo - 1].result = result_i_ptr;\\n\\t\\t\\t}\\n\\t\\t\\telse { // Cat\\n\\t\\t\\t\\tfor (int i = 0; i < graphColSizes[Cat]; i++) {\\n\\t\\t\\t\\t\\tif (graph[Cat][i] != 0) {\\n\\t\\t\\t\\t\\t\\tresult_i = mainFunction(graph, graphRowSize, graphColSizes, graph[Cat][i], Mouse, 1, resultMap);\\n\\t\\t\\t\\t\\t\\tif (result_i == 2) { \\n\\t\\t\\t\\t\\t\\t\\tresult = 2;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse if (result_i == 1 && result == -1) {\\n\\t\\t\\t\\t\\t\\t\\tresult = 1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse if (result_i == 0 || result_i == -1) {\\n\\t\\t\\t\\t\\t\\t\\tresult = 0;\\n\\t\\t\\t\\t\\t\\t\\tresult_i_ptr = resultMap[graph[Cat][i]][Mouse][0].result;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (result != 0)\\n\\t\\t\\t\\t\\t*(resultMap[Cat][Mouse][playerNo - 1].result) = result;\\n\\t\\t\\t\\telse resultMap[Cat][Mouse][playerNo - 1].result = result_i_ptr;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\telse result = *(resultMap[Cat][Mouse][playerNo - 1].result);\\n\\treturn result;\\n}\\nint catMouseGame(int** graph, int graphRowSize, int *graphColSizes) {\\n\\tstruct Node*** resultMap = (struct Node***)malloc(sizeof(struct Node**) * graphRowSize);\\n\\tfor (int i = 0; i < graphRowSize; i++) {\\n\\t\\tresultMap[i] = (struct Node**)malloc(sizeof(struct Node*) * graphRowSize);\\n\\t\\tfor (int j = 0; j < graphRowSize; j++) {\\n\\t\\t\\tresultMap[i][j] = (struct Node*)malloc(sizeof(struct Node) * 2);\\n\\n\\t\\t\\tresultMap[i][j][0].result = (int*)malloc(sizeof(int));\\n\\t\\t\\tresultMap[i][j][0].isDefined = false;\\n\\t\\t\\t*(resultMap[i][j][0].result) = -1;\\n\\n\\t\\t\\tresultMap[i][j][1].result = (int*)malloc(sizeof(int));\\n\\t\\t\\tresultMap[i][j][1].isDefined = false;\\n\\t\\t\\t*(resultMap[i][j][1].result) = -1;\\n\\t\\t}\\n\\t}\\n\\tint result = mainFunction(graph, graphRowSize, graphColSizes, 2, 1, 1, resultMap);\\n\\tfor (int i = 0; i < graphRowSize; i++) {\\n\\t\\tfree(resultMap[i]);\\n\\t}\\n\\tfree(resultMap);\\n\\treturn result;\\n}\\n```\\nWe use dfs to construct the resultMap, as you can see.",
                "solutionTags": [],
                "code": "```\\nstruct Node {\\n\\tbool isDefined;\\n\\tint* result;\\n};\\nint mainFunction(int** graph, int graphRowSize, int *graphColSizes, int Cat, int Mouse, int playerNo, struct Node*** resultMap) {\\n\\tint result = -1;//-1 means unknown\\n\\tif (resultMap[Cat][Mouse][playerNo - 1].isDefined == false) {\\n\\t\\tresultMap[Cat][Mouse][playerNo - 1].isDefined = true;\\n\\t\\tif (Cat == Mouse) {// Cat meets Mouse\\n\\t\\t\\t*(resultMap[Cat][Mouse][playerNo - 1].result) = 2;\\n\\t\\t\\treturn 2;\\n\\t\\t}\\n\\t\\telse if (Mouse == 0) {//Mouse is at 0\\n\\t\\t\\t*(resultMap[Cat][Mouse][playerNo - 1].result) = 1;\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tint result_i = 0;\\n\\t\\t\\tint *result_i_ptr = NULL;\\n\\t\\t\\tif (playerNo == 1) { // Mouse\\n\\t\\t\\t\\tfor (int i = 0; i < graphColSizes[Mouse]; i++) {\\n\\t\\t\\t\\t\\tresult_i = mainFunction(graph, graphRowSize, graphColSizes, Cat, graph[Mouse][i], 2, resultMap);\\n\\t\\t\\t\\t\\tif (result_i == 1) { // if win, just win\\n\\t\\t\\t\\t\\t\\tresult = 1;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if (result_i == 2 && result == -1) { // if all is lose, then lose\\n\\t\\t\\t\\t\\t\\tresult = 2;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if (result_i == 0 || result_i == -1) { //if there are some unknown items\\n\\t\\t\\t\\t\\t\\tresult = 0;\\n\\t\\t\\t\\t\\t\\tresult_i_ptr = resultMap[Cat][graph[Mouse][i]][1].result;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (result != 0)\\n\\t\\t\\t\\t\\t*(resultMap[Cat][Mouse][playerNo - 1].result) = result;\\n\\t\\t\\t\\telse resultMap[Cat][Mouse][playerNo - 1].result = result_i_ptr;\\n\\t\\t\\t}\\n\\t\\t\\telse { // Cat\\n\\t\\t\\t\\tfor (int i = 0; i < graphColSizes[Cat]; i++) {\\n\\t\\t\\t\\t\\tif (graph[Cat][i] != 0) {\\n\\t\\t\\t\\t\\t\\tresult_i = mainFunction(graph, graphRowSize, graphColSizes, graph[Cat][i], Mouse, 1, resultMap);\\n\\t\\t\\t\\t\\t\\tif (result_i == 2) { \\n\\t\\t\\t\\t\\t\\t\\tresult = 2;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse if (result_i == 1 && result == -1) {\\n\\t\\t\\t\\t\\t\\t\\tresult = 1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse if (result_i == 0 || result_i == -1) {\\n\\t\\t\\t\\t\\t\\t\\tresult = 0;\\n\\t\\t\\t\\t\\t\\t\\tresult_i_ptr = resultMap[graph[Cat][i]][Mouse][0].result;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (result != 0)\\n\\t\\t\\t\\t\\t*(resultMap[Cat][Mouse][playerNo - 1].result) = result;\\n\\t\\t\\t\\telse resultMap[Cat][Mouse][playerNo - 1].result = result_i_ptr;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\telse result = *(resultMap[Cat][Mouse][playerNo - 1].result);\\n\\treturn result;\\n}\\nint catMouseGame(int** graph, int graphRowSize, int *graphColSizes) {\\n\\tstruct Node*** resultMap = (struct Node***)malloc(sizeof(struct Node**) * graphRowSize);\\n\\tfor (int i = 0; i < graphRowSize; i++) {\\n\\t\\tresultMap[i] = (struct Node**)malloc(sizeof(struct Node*) * graphRowSize);\\n\\t\\tfor (int j = 0; j < graphRowSize; j++) {\\n\\t\\t\\tresultMap[i][j] = (struct Node*)malloc(sizeof(struct Node) * 2);\\n\\n\\t\\t\\tresultMap[i][j][0].result = (int*)malloc(sizeof(int));\\n\\t\\t\\tresultMap[i][j][0].isDefined = false;\\n\\t\\t\\t*(resultMap[i][j][0].result) = -1;\\n\\n\\t\\t\\tresultMap[i][j][1].result = (int*)malloc(sizeof(int));\\n\\t\\t\\tresultMap[i][j][1].isDefined = false;\\n\\t\\t\\t*(resultMap[i][j][1].result) = -1;\\n\\t\\t}\\n\\t}\\n\\tint result = mainFunction(graph, graphRowSize, graphColSizes, 2, 1, 1, resultMap);\\n\\tfor (int i = 0; i < graphRowSize; i++) {\\n\\t\\tfree(resultMap[i]);\\n\\t}\\n\\tfree(resultMap);\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 204707,
                "title": "python-ac-bfs-based-solution",
                "content": "```\\nclass Solution(object):\\n    def catMouseGame(self, graph):\\n        N=len(graph)\\n        f=collections.defaultdict(int)\\n\\n        q=collections.deque([])\\n        branchs={}\\n        MOUSE,CAT=1,2\\n        \\n        for i in xrange(1,N):\\n            for j in xrange(2):\\n                q.append((0,i,j,MOUSE))\\n                q.append((i,i,j,CAT))\\n                f[0,i,j]=MOUSE\\n                f[i,i,j]=CAT\\n        \\n        for i in xrange(N):\\n            for j in xrange(1,N):\\n                branchs[i,j,0]=len(graph[i])\\n                branchs[i,j,1]=len(graph[j])-(0 in graph[j])\\n        \\n        while q:\\n            mouse,cat,turn,winner=q.popleft()\\n            if turn==0:\\n                for i in graph[cat]:\\n                    if i==0: continue\\n                    if f[mouse,i,1]==0:#cat moves\\n                        if winner==CAT:\\n                            f[mouse,i,1]=CAT\\n                            q.append((mouse,i,1,CAT))\\n                        else:\\n                            branchs[mouse,i,1]-=1\\n                            if branchs[mouse,i,1]==0:\\n                                f[mouse,i,1]=MOUSE\\n                                q.append((mouse,i,1,MOUSE))\\n            else:\\n                for i in graph[mouse]:\\n                    if f[i,cat,0]==0:\\n                        if winner==MOUSE:\\n                            f[i,cat,0]=MOUSE\\n                            q.append((i,cat,0,MOUSE))\\n                        else:\\n                            branchs[i,cat,0]-=1\\n                            if branchs[i,cat,0]==0:\\n                                f[i,cat,0]=CAT\\n                                q.append((i,cat,0,CAT))\\n        \\n        return f[1,2,0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def catMouseGame(self, graph):\\n        N=len(graph)\\n        f=collections.defaultdict(int)\\n\\n        q=collections.deque([])\\n        branchs={}\\n        MOUSE,CAT=1,2\\n        \\n        for i in xrange(1,N):\\n            for j in xrange(2):\\n                q.append((0,i,j,MOUSE))\\n                q.append((i,i,j,CAT))\\n                f[0,i,j]=MOUSE\\n                f[i,i,j]=CAT\\n        \\n        for i in xrange(N):\\n            for j in xrange(1,N):\\n                branchs[i,j,0]=len(graph[i])\\n                branchs[i,j,1]=len(graph[j])-(0 in graph[j])\\n        \\n        while q:\\n            mouse,cat,turn,winner=q.popleft()\\n            if turn==0:\\n                for i in graph[cat]:\\n                    if i==0: continue\\n                    if f[mouse,i,1]==0:#cat moves\\n                        if winner==CAT:\\n                            f[mouse,i,1]=CAT\\n                            q.append((mouse,i,1,CAT))\\n                        else:\\n                            branchs[mouse,i,1]-=1\\n                            if branchs[mouse,i,1]==0:\\n                                f[mouse,i,1]=MOUSE\\n                                q.append((mouse,i,1,MOUSE))\\n            else:\\n                for i in graph[mouse]:\\n                    if f[i,cat,0]==0:\\n                        if winner==MOUSE:\\n                            f[i,cat,0]=MOUSE\\n                            q.append((i,cat,0,MOUSE))\\n                        else:\\n                            branchs[i,cat,0]-=1\\n                            if branchs[i,cat,0]==0:\\n                                f[i,cat,0]=CAT\\n                                q.append((i,cat,0,CAT))\\n        \\n        return f[1,2,0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 198121,
                "title": "plz-explain-how-mouse-win-for-the-test-case",
                "content": "The system says expected result should be 1 (mouse win) for the below test case.\\n```[[1],[3],[1],[1]]```\\n`(1,2,m)-> (3,2,c)->(3,1,m)->(1,1,c)`\\nI think cat should win. Mouse can\\'t win because it can\\'t go to the hole in this test case.\\nSomeone please explain whether I misunderstood the problem.\\nI appreciate your help.",
                "solutionTags": [],
                "code": "```[[1],[3],[1],[1]]```",
                "codeTag": "Unknown"
            },
            {
                "id": 188901,
                "title": "dfs-dp-easy-understand-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        vector<vector<int>> dp(graph.size(), vector<int>(graph.size(), -1));\\n        for (int i=0; i<graph.size(); i++) {\\n            dp[i][i] = 0;\\n            dp[0][i] = 2;\\n        }\\n        unordered_map<int, unordered_set<int>> visited;\\n        // 0 lost, 1 draw, 2 win\\n        int result = gameHelper(graph, dp, 1, 2, visited);\\n        if (result == 1) return 0;\\n        if (result == 2) return 1;\\n        if (result == 0 || result == -1) return 2;\\n    }\\n    int gameHelper(vector<vector<int>> & graph, vector<vector<int>>& dp, int m, int c, unordered_map<int, unordered_set<int>>& visited) {\\n        if (dp[m][c] > -1) return dp[m][c];\\n        if (visited[m].find(c) != visited[m].end()) return 1;\\n        visited[m].insert(c);\\n        \\n        vector<int> nextMoveMouse = graph[m];\\n        vector<int> nextMoveCat = graph[c];\\n        for (int i=0; i<nextMoveMouse.size(); i++) {\\n            int current = INT_MAX;\\n            if (nextMoveMouse[i] == c) continue;\\n            for (int j=0; j<nextMoveCat.size(); j++) {\\n                if (nextMoveCat[j] == 0) continue;\\n                current = min(current, gameHelper(graph, dp, nextMoveMouse[i], nextMoveCat[j], visited));\\n            }\\n            dp[m][c] = max(current, dp[m][c]);\\n        }\\n        return dp[m][c];\\n    }\\n};```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        vector<vector<int>> dp(graph.size(), vector<int>(graph.size(), -1));\\n        for (int i=0; i<graph.size(); i++) {\\n            dp[i][i] = 0;\\n            dp[0][i] = 2;\\n        }\\n        unordered_map<int, unordered_set<int>> visited;\\n        // 0 lost, 1 draw, 2 win\\n        int result = gameHelper(graph, dp, 1, 2, visited);\\n        if (result == 1) return 0;\\n        if (result == 2) return 1;\\n        if (result == 0 || result == -1) return 2;\\n    }\\n    int gameHelper(vector<vector<int>> & graph, vector<vector<int>>& dp, int m, int c, unordered_map<int, unordered_set<int>>& visited) {\\n        if (dp[m][c] > -1) return dp[m][c];\\n        if (visited[m].find(c) != visited[m].end()) return 1;\\n        visited[m].insert(c);\\n        \\n        vector<int> nextMoveMouse = graph[m];\\n        vector<int> nextMoveCat = graph[c];\\n        for (int i=0; i<nextMoveMouse.size(); i++) {\\n            int current = INT_MAX;\\n            if (nextMoveMouse[i] == c) continue;\\n            for (int j=0; j<nextMoveCat.size(); j++) {\\n                if (nextMoveCat[j] == 0) continue;\\n                current = min(current, gameHelper(graph, dp, nextMoveMouse[i], nextMoveCat[j], visited));\\n            }\\n            dp[m][c] = max(current, dp[m][c]);\\n        }\\n        return dp[m][c];\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 180153,
                "title": "easy-understanding-memorialized-dfs-in-c",
                "content": "memorialized DFS\\nTrack all mouse\\'s and cat\\'s choices. memo[i][j] represents the result while mouse at node i and cat at node j.\\n\\nFor each mouse\\'s next choice, res means the result of this choice:\\n1. if there is one cat\\'s choice that cat can catch the mouse, res = 2\\n2. else if there is one cat\\'s choice that leads to draw, res = 0;\\n3. all choices that mouse can reach node zero, res = 1;\\n\\nFor all mouse\\'s next choice, \\n1. if there exists one choice that res = 1, return 1;\\n2. else if there exists one choice that res = 0, return 0;\\n3. no choice can make mouse git rid of cat, return 2;\\n\\n```\\ntypedef vector<int> vi;\\ntypedef vector<vi> vvi;\\nclass Solution {\\nprivate:\\n    int dfs(vvi& graph, vvi& memo, int mouse, int cat){\\n        if(memo[mouse][cat] == -1){\\n            memo[mouse][cat] = 0;// if the mouse and cat come back to these locations, it is a loop, i.e. a draw.\\n            int r = 2;\\n            //traverse all mouse\\'s choices\\n            for(int next_m : graph[mouse]){\\n                if(next_m == cat) continue;// if the mouse\\'s next step is cat\\'s location, mouse is caught, pass this situation.\\n                int res = 1;\\n                //traverse all cat\\'s choices\\n                for(int next_c : graph[cat]){\\n                    if(next_c == 0) continue;// pass the illegal case.\\n                    int ret = dfs(graph, memo, next_m, next_c);\\n                    if(ret == 2){\\n                        res = 2;\\n                        break;\\n                    }\\n                    if(ret == 0)\\n                        res = 0;\\n                }\\n                if(res == 1){\\n                    r = 1;\\n                    break;\\n                }\\n                if(res == 0)\\n                    r = 0;\\n            }\\n            memo[mouse][cat] = r;\\n        }\\n        return memo[mouse][cat];\\n    }\\npublic:\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        vvi memo(n, vi(n, -1));\\n        for(int i=0;i<n;++i) {memo[i][i]=2; memo[0][i] = 1;}\\n        return dfs(graph, memo, 1, 2);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef vector<int> vi;\\ntypedef vector<vi> vvi;\\nclass Solution {\\nprivate:\\n    int dfs(vvi& graph, vvi& memo, int mouse, int cat){\\n        if(memo[mouse][cat] == -1){\\n            memo[mouse][cat] = 0;// if the mouse and cat come back to these locations, it is a loop, i.e. a draw.\\n            int r = 2;\\n            //traverse all mouse\\'s choices\\n            for(int next_m : graph[mouse]){\\n                if(next_m == cat) continue;// if the mouse\\'s next step is cat\\'s location, mouse is caught, pass this situation.\\n                int res = 1;\\n                //traverse all cat\\'s choices\\n                for(int next_c : graph[cat]){\\n                    if(next_c == 0) continue;// pass the illegal case.\\n                    int ret = dfs(graph, memo, next_m, next_c);\\n                    if(ret == 2){\\n                        res = 2;\\n                        break;\\n                    }\\n                    if(ret == 0)\\n                        res = 0;\\n                }\\n                if(res == 1){\\n                    r = 1;\\n                    break;\\n                }\\n                if(res == 0)\\n                    r = 0;\\n            }\\n            memo[mouse][cat] = r;\\n        }\\n        return memo[mouse][cat];\\n    }\\npublic:\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        vvi memo(n, vi(n, -1));\\n        for(int i=0;i<n;++i) {memo[i][i]=2; memo[0][i] = 1;}\\n        return dfs(graph, memo, 1, 2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 178490,
                "title": "who-in-winner",
                "content": "if the graph is\\n[[2,3],[3,4],[0,3],[0,2],[0,2]]",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 178003,
                "title": "having-trouble-translating-the-problem-would-appreciate-some-help",
                "content": "I have been banging my head against the wall to try and figure this out. This is the first time I am encountering minimax (or any game theory algorithm for that matter) and have watched/read the following:\\n\\n1. https://www.neverstopbuilding.com/blog/minimax\\n2. https://www.youtube.com/watch?v=KU9Ch59-4vw\\n\\nI understand the basic concept and the way it works but I am having some trouble translating this problem into a graph or an appropriate data structure.\\n\\nHere is what I have tried:\\n1. Stepping through the solution using a debugger to see the way it\\'s working and I am still having some trouble grasping the solution\\n2. Drawing the DAG (as mentioned in the solution) for the example but that gets complicated quite quickly\\n\\nWould it be possible for someone to explain to me with a simpler example so I can understand what the solution would entail? I just want to make sure I am on the right track.\\n\\nReally appreaciate the help. Thank you.",
                "solutionTags": [],
                "code": "I have been banging my head against the wall to try and figure this out. This is the first time I am encountering minimax (or any game theory algorithm for that matter) and have watched/read the following:\\n\\n1. https://www.neverstopbuilding.com/blog/minimax\\n2. https://www.youtube.com/watch?v=KU9Ch59-4vw\\n\\nI understand the basic concept and the way it works but I am having some trouble translating this problem into a graph or an appropriate data structure.\\n\\nHere is what I have tried:\\n1. Stepping through the solution using a debugger to see the way it\\'s working and I am still having some trouble grasping the solution\\n2. Drawing the DAG (as mentioned in the solution) for the example but that gets complicated quite quickly\\n\\nWould it be possible for someone to explain to me with a simpler example so I can understand what the solution would entail? I just want to make sure I am on the right track.\\n\\nReally appreaciate the help. Thank you.",
                "codeTag": "Unknown"
            },
            {
                "id": 177893,
                "title": "need-help-memorization-can-not-figure-out-the-problem",
                "content": "I don\\'t see the problem in my code , I would appreciate if anyone can help me figure out why it is failing.\\nI am getting WA in this case: [[4,6,7,8,9],[3,4,5,6,7,8,9],[3,8,9],[1,2,6],[0,1,5,6,9],[1,4],[0,1,3,4,7,8],[0,1,6],[0,1,2,6,9],[0,1,2,4,8]]\\nmy answer: 0, correct answer is 1.\\nThanks!\\n```\\nimport java.util.*;\\n\\npublic class Solution {\\n\\n  private enum Move {\\n    CAT, MOUSE\\n  }\\n\\n  public int catMouseGame(int[][] graph) {\\n\\n    int[][][] dp = new int[55][55][3];\\n\\n    for (int i = 0; i < dp.length; i++) {\\n      for (int j = 0; j < dp[i].length; j++) {\\n        Arrays.fill(dp[i][j], -1);\\n      }\\n    }\\n    return solve(1, 2, 0, Move.CAT, dp, graph);\\n  }\\n\\n  private int solve(int mouse, int cat, int turn, Move move, int[][][] dp, int[][] graph) {\\n\\n    if (mouse == cat) {\\n      // it can not be 0.\\n      return 2;\\n    }\\n\\n    if (mouse == 0) {\\n      return 1;\\n    }\\n\\n    if (dp[mouse][cat][turn] != -1) {\\n      return dp[mouse][cat][turn];\\n    }\\n\\n    dp[mouse][cat][turn] = 0;\\n\\n    int player = move == Move.MOUSE ? mouse : cat;\\n\\n    boolean catWin = false;\\n    boolean mouseWin = false;\\n    boolean draw = false;\\n\\n    for (int i = 0; i < graph[player].length; i++) {\\n\\n      if (move == Move.CAT && graph[cat][i] == 0) {\\n        continue;\\n      }\\n\\n      int moveResult = solve(move == Move.MOUSE ? graph[player][i] : mouse,\\n          move == Move.CAT ? graph[player][i] : cat, turn ^ 1,\\n          move == Move.MOUSE ? Move.CAT : Move.MOUSE, dp, graph);\\n\\n      catWin |= moveResult == 2;\\n      mouseWin |= moveResult == 1;\\n      draw |= moveResult == 0;\\n    }\\n\\n    int ans;\\n    if (move == Move.MOUSE) {\\n      // mouse\\'s turn\\n      ans = mouseWin ? 1 : draw ? 0 : 2;\\n    } else {\\n      ans = catWin ? 2 : draw ? 0 : 1;\\n    }\\n\\n    return dp[mouse][cat][turn] = ans;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.*;\\n\\npublic class Solution {\\n\\n  private enum Move {\\n    CAT, MOUSE\\n  }\\n\\n  public int catMouseGame(int[][] graph) {\\n\\n    int[][][] dp = new int[55][55][3];\\n\\n    for (int i = 0; i < dp.length; i++) {\\n      for (int j = 0; j < dp[i].length; j++) {\\n        Arrays.fill(dp[i][j], -1);\\n      }\\n    }\\n    return solve(1, 2, 0, Move.CAT, dp, graph);\\n  }\\n\\n  private int solve(int mouse, int cat, int turn, Move move, int[][][] dp, int[][] graph) {\\n\\n    if (mouse == cat) {\\n      // it can not be 0.\\n      return 2;\\n    }\\n\\n    if (mouse == 0) {\\n      return 1;\\n    }\\n\\n    if (dp[mouse][cat][turn] != -1) {\\n      return dp[mouse][cat][turn];\\n    }\\n\\n    dp[mouse][cat][turn] = 0;\\n\\n    int player = move == Move.MOUSE ? mouse : cat;\\n\\n    boolean catWin = false;\\n    boolean mouseWin = false;\\n    boolean draw = false;\\n\\n    for (int i = 0; i < graph[player].length; i++) {\\n\\n      if (move == Move.CAT && graph[cat][i] == 0) {\\n        continue;\\n      }\\n\\n      int moveResult = solve(move == Move.MOUSE ? graph[player][i] : mouse,\\n          move == Move.CAT ? graph[player][i] : cat, turn ^ 1,\\n          move == Move.MOUSE ? Move.CAT : Move.MOUSE, dp, graph);\\n\\n      catWin |= moveResult == 2;\\n      mouseWin |= moveResult == 1;\\n      draw |= moveResult == 0;\\n    }\\n\\n    int ans;\\n    if (move == Move.MOUSE) {\\n      // mouse\\'s turn\\n      ans = mouseWin ? 1 : draw ? 0 : 2;\\n    } else {\\n      ans = catWin ? 2 : draw ? 0 : 1;\\n    }\\n\\n    return dp[mouse][cat][turn] = ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 177861,
                "title": "state-transition-solution",
                "content": " Number of states S: N*N*2;\\n Number of state value changes is O(S);\\n The steps for each state value changes is O(N*N*N);\\n So complexity is is O(N^5)\\n N <=50 though. not too bad. \\n ```\\n\\tpublic int catMouseGame(int[][] graph) {\\n        int N = graph.length;\\n        int[][][] states = new int[N][N][2]; //0 for mouse move next; 1 for cat\\n        for (int i=0; i<N; i++) {\\n            states[0][i][0] = 1; //mouse win state\\n            states[0][i][1] = 1;\\n        }\\n        for (int i=1; i<N; i++) {\\n            states[i][i][0] = 2; //cat win\\n            states[i][i][1] = 2;\\n        }\\n        boolean progress = true;\\n        while (progress) {\\n            progress = false;\\n            for (int m=0; m<N; m++)\\n                for (int c=1; c<N; c++) {\\n                    if (states[m][c][0] == 0) {\\n                        for (int e: graph[m]) {\\n                            if (states[e][c][1] == 1) {\\n                                states[m][c][0] = 1; \\n                                progress = true;\\n                                break;\\n                            }\\n                        }\\n                        if (states[m][c][0] == 0) {\\n                            boolean catwin = true;\\n                            for (int e: graph[m]) {\\n                                if (states[e][c][1] != 2) {\\n                                    catwin=false;\\n                                    break;\\n                                }\\n                            }\\n                            if (catwin) {\\n                                states[m][c][0] = 2;\\n                                progress = true;\\n                            }\\n                        }                            \\n                    }\\n                    if (states[m][c][1] == 0) {\\n                       for (int e: graph[c]) {\\n                            if (e!=0 && states[m][e][0] == 2) {\\n                                states[m][c][1] = 2; \\n                                progress = true;\\n                                break;\\n                            }\\n                       }\\n                       if (states[m][c][1] == 0) {\\n                            boolean mousewin = true;\\n                            for (int e: graph[c]) {\\n                                if (e!=0 && states[m][e][0] != 1) {\\n                                    mousewin=false;\\n                                    break;\\n                                }\\n                            }\\n                            if (mousewin) {\\n                                states[m][c][1] = 1;\\n                                progress = true;\\n                            }\\n                        }                                                    \\n                    }\\n                }\\n        }\\n        return states[1][2][0];\\n    }\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int catMouseGame(int[][] graph) {\\n        int N = graph.length;\\n        int[][][] states = new int[N][N][2]; //0 for mouse move next; 1 for cat\\n        for (int i=0; i<N; i++) {\\n            states[0][i][0] = 1; //mouse win state\\n            states[0][i][1] = 1;\\n        }\\n        for (int i=1; i<N; i++) {\\n            states[i][i][0] = 2; //cat win\\n            states[i][i][1] = 2;\\n        }\\n        boolean progress = true;\\n        while (progress) {\\n            progress = false;\\n            for (int m=0; m<N; m++)\\n                for (int c=1; c<N; c++) {\\n                    if (states[m][c][0] == 0) {\\n                        for (int e: graph[m]) {\\n                            if (states[e][c][1] == 1) {\\n                                states[m][c][0] = 1; \\n                                progress = true;\\n                                break;\\n                            }\\n                        }\\n                        if (states[m][c][0] == 0) {\\n                            boolean catwin = true;\\n                            for (int e: graph[m]) {\\n                                if (states[e][c][1] != 2) {\\n                                    catwin=false;\\n                                    break;\\n                                }\\n                            }\\n                            if (catwin) {\\n                                states[m][c][0] = 2;\\n                                progress = true;\\n                            }\\n                        }                            \\n                    }\\n                    if (states[m][c][1] == 0) {\\n                       for (int e: graph[c]) {\\n                            if (e!=0 && states[m][e][0] == 2) {\\n                                states[m][c][1] = 2; \\n                                progress = true;\\n                                break;\\n                            }\\n                       }\\n                       if (states[m][c][1] == 0) {\\n                            boolean mousewin = true;\\n                            for (int e: graph[c]) {\\n                                if (e!=0 && states[m][e][0] != 1) {\\n                                    mousewin=false;\\n                                    break;\\n                                }\\n                            }\\n                            if (mousewin) {\\n                                states[m][c][1] = 1;\\n                                progress = true;\\n                            }\\n                        }                                                    \\n                    }\\n                }\\n        }\\n        return states[1][2][0];\\n    }\\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 177441,
                "title": "c-bfs-solution-from-initial-win-lose-state",
                "content": "I don't think there's a correct DFS solution for this problem because it's hard to solve the \"circle\".\n\nHowever doing BFS from inital state does the job. Besides the queue, I used a \"possible\" set to keep track of those state that is \"touched\" but cannot be determined yet. When queue is drained, try to add more determined state into the queue by querying on \"possible\" set. In the end, if the initial state is determined, return it. Otherwise it's a draw.\n\n```\nstruct State {\n    int mouse;\n    int cat;\n    int turn;\n\n    State(int aMouse, int aCat, int aTurn):\n    mouse(aMouse), cat(aCat), turn(aTurn){}\n\n    bool isInvalid() {\n        return cat == 0 || (mouse == 0 && turn == 1);\n    }\n\n    bool operator==(const State& otherState) const {\n        return mouse == otherState.mouse && cat == otherState.cat && turn == otherState.turn;\n    }\n};\n\nnamespace std {\n    template <> \n    class hash<State>{\n        public :\n            size_t operator()(const State &state ) const\n            {\n                return hash<int>()(state.mouse * state.cat * state.turn);\n            }\n    };\n}\n\nclass Solution {\n    vector<State> expand(vector<vector<int>>& graph, State& state, bool nextOrPrevious) {\n        vector<State> ret;\n        if (state.turn == 1 && nextOrPrevious || state.turn == 2 && !nextOrPrevious) {\n            for (int y : graph[state.mouse]) {\n                State newState = State(y, state.cat, 3 - state.turn);\n                if (!newState.isInvalid()) {\n                    ret.push_back(newState);\n                }\n            }\n        } else {\n            for (int y : graph[state.cat]) {\n                State newState = State(state.mouse, y, 3 - state.turn);\n                if (!newState.isInvalid()) {\n                    ret.push_back(newState);\n                }\n            }\n        }\n        return ret;\n    }\n    \npublic:\n    int catMouseGame(vector<vector<int>>& graph) {\n        int n = graph.size();\n        unordered_map<State, int> f;\n        queue<State> q;\n        for (int i = 1; i < n; ++i) {\n            State state(0, i, 2);\n            f[state] = 1;\n            q.push(state);\n            \n            state.mouse = state.cat = i;\n            f[state] = 2;\n            q.push(state);\n            \n            state.turn = 1;\n            f[state] = 2;\n            q.push(state);\n        }\n        \n        unordered_set<State> possible;\n        while (!(q.empty() && possible.empty() || f.count(State(1, 2, 1)))) {\n            if (q.empty()) {\n                for (State state : possible) {\n                    if (f.count(state)) {\n                        continue;\n                    }\n                    bool canAdd = true;\n                    int value = 0;\n                    for (State newState : expand(graph, state, true)) {\n                        if (f.count(newState) == 0 || value != 0 && f[newState] != value) {\n                            canAdd = false;\n                            break;\n                        } else {\n                            value = f[newState];\n                        }\n                    }\n                    if (canAdd) {\n                        f[state] = value;\n                        q.push(state);\n                    }\n                }\n                possible.clear();\n                continue;\n            }\n            \n            State state = q.front();\n            q.pop();\n            for (State newState : expand(graph, state, false)) {\n                if (f.count(newState)) {\n                    continue;\n                }\n                if (state.turn == f[state]) {\n                    possible.insert(newState);\n                } else {\n                    q.push(newState);\n                    f[newState] = f[state];\n                }\n            }\n        }\n        return f[State(1, 2, 1)];\n    }\n};\n\n```",
                "solutionTags": [],
                "code": "```\nstruct State {\n    int mouse;\n    int cat;\n    int turn;\n\n    State(int aMouse, int aCat, int aTurn):\n    mouse(aMouse), cat(aCat), turn(aTurn){}\n\n    bool isInvalid() {\n        return cat == 0 || (mouse == 0 && turn == 1);\n    }\n\n    bool operator==(const State& otherState) const {\n        return mouse == otherState.mouse && cat == otherState.cat && turn == otherState.turn;\n    }\n};\n\nnamespace std {\n    template <> \n    class hash<State>{\n        public :\n            size_t operator()(const State &state ) const\n            {\n                return hash<int>()(state.mouse * state.cat * state.turn);\n            }\n    };\n}\n\nclass Solution {\n    vector<State> expand(vector<vector<int>>& graph, State& state, bool nextOrPrevious) {\n        vector<State> ret;\n        if (state.turn == 1 && nextOrPrevious || state.turn == 2 && !nextOrPrevious) {\n            for (int y : graph[state.mouse]) {\n                State newState = State(y, state.cat, 3 - state.turn);\n                if (!newState.isInvalid()) {\n                    ret.push_back(newState);\n                }\n            }\n        } else {\n            for (int y : graph[state.cat]) {\n                State newState = State(state.mouse, y, 3 - state.turn);\n                if (!newState.isInvalid()) {\n                    ret.push_back(newState);\n                }\n            }\n        }\n        return ret;\n    }\n    \npublic:\n    int catMouseGame(vector<vector<int>>& graph) {\n        int n = graph.size();\n        unordered_map<State, int> f;\n        queue<State> q;\n        for (int i = 1; i < n; ++i) {\n            State state(0, i, 2);\n            f[state] = 1;\n            q.push(state);\n            \n            state.mouse = state.cat = i;\n            f[state] = 2;\n            q.push(state);\n            \n            state.turn = 1;\n            f[state] = 2;\n            q.push(state);\n        }\n        \n        unordered_set<State> possible;\n        while (!(q.empty() && possible.empty() || f.count(State(1, 2, 1)))) {\n            if (q.empty()) {\n                for (State state : possible) {\n                    if (f.count(state)) {\n                        continue;\n                    }\n                    bool canAdd = true;\n                    int value = 0;\n                    for (State newState : expand(graph, state, true)) {\n                        if (f.count(newState) == 0 || value != 0 && f[newState] != value) {\n                            canAdd = false;\n                            break;\n                        } else {\n                            value = f[newState];\n                        }\n                    }\n                    if (canAdd) {\n                        f[state] = value;\n                        q.push(state);\n                    }\n                }\n                possible.clear();\n                continue;\n            }\n            \n            State state = q.front();\n            q.pop();\n            for (State newState : expand(graph, state, false)) {\n                if (f.count(newState)) {\n                    continue;\n                }\n                if (state.turn == f[state]) {\n                    possible.insert(newState);\n                } else {\n                    q.push(newState);\n                    f[newState] = f[state];\n                }\n            }\n        }\n        return f[State(1, 2, 1)];\n    }\n};\n\n```",
                "codeTag": "Java"
            },
            {
                "id": 177212,
                "title": "a-case-puzzles-me",
                "content": "Hi guys.\nI have ac this problem. But when I discuss with my friends, they creat a testcase which my result is different from solution\n\nThe case is\n[[5,21,28],[6,8,9,13,23,24,30],[9,10,22,24],[24,30],[5,6,8,9,13,18,19,20,24],[0,4,9,10,11,12,22,27],[1,4,9,11,16,19,25,30],[8,9,13,19,25,26],[1,4,7,9,29],[1,2,4,5,6,7,8,13,18,19,24,26,28,29],[2,5,15,22,27,30],[5,6,12,24],[5,11,20,22,23],[1,4,7,9,29,30],[19,24,27],[10,16,19],[6,15,27],[20,22,24,29],[4,9,21],[4,6,7,9,14,15,20,26,28,30],[4,12,17,19,21],[0,18,20,27],[2,5,10,12,17],[1,12,26,30],[1,2,3,4,9,11,14,17,27,29],[6,7,26,27,29],[7,9,19,23,25],[5,10,14,16,21,24,25],[0,9,19,30],[8,9,13,17,24,25],[1,3,6,10,13,19,23,28]]\n\nMy result is 0, while the expected is 1.\n\nMy code:\n```\nclass Solution {\npublic:\nint dfs(vector<vector<int>>& graph, int curMouse, int curCat, vector<vector<int>>&m)\n{\n    if (m[curMouse][curCat] != -1)\n        return m[curMouse][curCat];\n    m[curMouse][curCat] = 0;\n    int r = 2;\n    for (int i : graph[curMouse])\n    {\n        if (i == 0)\n        {\n            m[curMouse][curCat] = 1;\n            return 1;\n        }\n        if (i == curCat)\n            continue;\n\n        if (find(graph[curCat].begin(), graph[curCat].end(), i) != graph[curCat].end())\n        {\n            continue;\n        }\n\n        vector<bool> res(3, false);\n        for (int j : graph[curCat])\n        {\n            if (j == 0) continue;\n            res[dfs(graph, i, j, m)] = true;\n        }\n        if (res[1] && !res[2] && !res[0])\n        {\n            m[curMouse][curCat] = 1;\n            return 1;\n        }\n        if (!res[2]) r = 0;\n    }\n    m[curMouse][curCat] = r;\n    return r;\n}\nint catMouseGame(vector<vector<int>>& graph)\n{\n    vector<vector<int>> res;\n    vector<vector<int>> m(graph.size(),vector<int>(graph.size(),-1));\n\n    return dfs(graph, 1, 2, m);\n}\n};\n```\n\nWhere is wrong?\n\nAnd I test some code in samples, it likes the DFS solutions result is 0\n\nDFS is a wrong ??",
                "solutionTags": [],
                "code": "```\nclass Solution {\npublic:\nint dfs(vector<vector<int>>& graph, int curMouse, int curCat, vector<vector<int>>&m)\n{\n    if (m[curMouse][curCat] != -1)\n        return m[curMouse][curCat];\n    m[curMouse][curCat] = 0;\n    int r = 2;\n    for (int i : graph[curMouse])\n    {\n        if (i == 0)\n        {\n            m[curMouse][curCat] = 1;\n            return 1;\n        }\n        if (i == curCat)\n            continue;\n\n        if (find(graph[curCat].begin(), graph[curCat].end(), i) != graph[curCat].end())\n        {\n            continue;\n        }\n\n        vector<bool> res(3, false);\n        for (int j : graph[curCat])\n        {\n            if (j == 0) continue;\n            res[dfs(graph, i, j, m)] = true;\n        }\n        if (res[1] && !res[2] && !res[0])\n        {\n            m[curMouse][curCat] = 1;\n            return 1;\n        }\n        if (!res[2]) r = 0;\n    }\n    m[curMouse][curCat] = r;\n    return r;\n}\nint catMouseGame(vector<vector<int>>& graph)\n{\n    vector<vector<int>> res;\n    vector<vector<int>> m(graph.size(),vector<int>(graph.size(),-1));\n\n    return dfs(graph, 1, 2, m);\n}\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 176880,
                "title": "javascript-solution-with-comment-dfs-memo",
                "content": "```\\n/**\\n * @param {number[][]} graph\\n * @return {number}\\n */\\nvar m = {};\\nvar graph;\\n\\nvar catMouseGame = function(_graph) {\\n    m = {};\\n    graph = _graph;\\n    return move(2, 1, true);   // cat start at 2, mouse at 1 and mouse move at first.\\n};\\n\\nvar hash = function(cat, mouse, mouse_turn){\\n    const key = (cat << 16) | (mouse<< 8) | (mouse_turn);\\n    return key;\\n}\\n\\nvar move = function( cat, mouse, mouse_turn ){\\n    var key = hash(cat, mouse, mouse_turn);\\n    if( m[key] != undefined )\\n        return m[key];\\n    if( mouse_turn ){              //mouse turn\\n        let res = 2;\\n        m[key] = 0;\\n        if( graph[mouse] ){\\n            if( graph[mouse].includes(0) ){   //next step if mouse can go into the hold, mouse win\\n                m[key] = 1;\\n                return 1;\\n            }\\n            for( let v of graph[mouse]){\\n                if( v == cat )              //mouse will always avoid cat\\'s position.\\n                    continue;\\n                else{\\n                    var move_res = move( cat, v, !mouse_turn );   // go to next step and it is cat\\'s turn\\n                    if( move_res == 0 ){\\n                        res = move_res;\\n                    }else if( move_res == 1 ){   // if mouse win, we don\\'t need to search any more.\\n                        res = 1;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        m[key] = res;\\n        return res;\\n    }else{                      // cat turn\\n        let res = 1;\\n        m[key] = 0;\\n        if( graph[cat] ){\\n            if( graph[cat].includes(mouse) ){  // next step if cat can catch mouse, cat win.\\n                m[key] = 2;\\n                return 2;\\n            }\\n            for( let v of graph[cat ]){\\n                if( v == 0 )           // cat can\\'t go into the hold.\\n                    continue;\\n                else{\\n                    var move_res = move( v, mouse, !mouse_turn );  //go to next step and it is mouse\\'s turn;\\n                    if( move_res == 2 ){  //if cat wins, we don\\'t need to search anymore.\\n                        res = 2;\\n                        break;\\n                    }else if( move_res == 0 ){\\n                        res = 0;\\n                    }\\n                }\\n            }\\n        }\\n        m[key] = res;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} graph\\n * @return {number}\\n */\\nvar m = {};\\nvar graph;\\n\\nvar catMouseGame = function(_graph) {\\n    m = {};\\n    graph = _graph;\\n    return move(2, 1, true);   // cat start at 2, mouse at 1 and mouse move at first.\\n};\\n\\nvar hash = function(cat, mouse, mouse_turn){\\n    const key = (cat << 16) | (mouse<< 8) | (mouse_turn);\\n    return key;\\n}\\n\\nvar move = function( cat, mouse, mouse_turn ){\\n    var key = hash(cat, mouse, mouse_turn);\\n    if( m[key] != undefined )\\n        return m[key];\\n    if( mouse_turn ){              //mouse turn\\n        let res = 2;\\n        m[key] = 0;\\n        if( graph[mouse] ){\\n            if( graph[mouse].includes(0) ){   //next step if mouse can go into the hold, mouse win\\n                m[key] = 1;\\n                return 1;\\n            }\\n            for( let v of graph[mouse]){\\n                if( v == cat )              //mouse will always avoid cat\\'s position.\\n                    continue;\\n                else{\\n                    var move_res = move( cat, v, !mouse_turn );   // go to next step and it is cat\\'s turn\\n                    if( move_res == 0 ){\\n                        res = move_res;\\n                    }else if( move_res == 1 ){   // if mouse win, we don\\'t need to search any more.\\n                        res = 1;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        m[key] = res;\\n        return res;\\n    }else{                      // cat turn\\n        let res = 1;\\n        m[key] = 0;\\n        if( graph[cat] ){\\n            if( graph[cat].includes(mouse) ){  // next step if cat can catch mouse, cat win.\\n                m[key] = 2;\\n                return 2;\\n            }\\n            for( let v of graph[cat ]){\\n                if( v == 0 )           // cat can\\'t go into the hold.\\n                    continue;\\n                else{\\n                    var move_res = move( v, mouse, !mouse_turn );  //go to next step and it is mouse\\'s turn;\\n                    if( move_res == 2 ){  //if cat wins, we don\\'t need to search anymore.\\n                        res = 2;\\n                        break;\\n                    }else if( move_res == 0 ){\\n                        res = 0;\\n                    }\\n                }\\n            }\\n        }\\n        m[key] = res;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 176608,
                "title": "javascript-solution",
                "content": "https://github.com/dva22/leetcode/blob/master/problems/913.%20Cat%20and%20Mouse/index.js\\n```\\nvar catMouseGame = module.exports = function(g) {\\n            let n = g.length;\\n\\t        let win = Array(2).fill(0).map(()=>Array(n*n).fill(0));\\n\\t        // mc\\n\\t        for(let i = 0;i < n;i++){\\n\\t        \\twin[0][i] = 1;\\n\\t        \\twin[1][i] = 1;\\n\\t        }\\n\\t        for(let i = 1;i < n;i++){\\n\\t        \\twin[0][i*n+i] = 2;\\n\\t        \\twin[1][i*n+i] = 2;\\n\\t        }\\n\\t        \\n\\t        while(true){\\n\\t        \\tlet anew = false;\\n\\t\\t        for(let m = 0;m < n;m++){\\n\\t\\t        \\tinner:\\n\\t\\t        \\tfor(let c = 1;c < n;c++){\\n\\t\\t        \\t\\tif(win[0][m*n+c] == 0){\\n\\t\\t        \\t\\t\\tlet und = false;\\n\\t\\t        \\t\\t\\tfor(let e of g[m]){\\n\\t\\t        \\t\\t\\t\\tif(win[1][e*n+c] == 1){\\n\\t\\t        \\t\\t\\t\\t\\twin[0][m*n+c] = 1;\\n\\t\\t\\t        \\t\\t\\t\\tanew = true;\\n\\t\\t        \\t\\t\\t\\t\\tcontinue inner;\\n\\t\\t        \\t\\t\\t\\t}\\n\\t\\t        \\t\\t\\t\\tif(win[1][e*n+c] == 0){\\n\\t\\t        \\t\\t\\t\\t\\tund = true;\\n\\t\\t        \\t\\t\\t\\t}\\n\\t\\t        \\t\\t\\t}\\n\\t\\t        \\t\\t\\tif(!und){\\n\\t\\t        \\t\\t\\t\\twin[0][m*n+c] = 2;\\n\\t\\t        \\t\\t\\t\\tanew = true;\\n\\t\\t        \\t\\t\\t}\\n\\t\\t        \\t\\t}\\n\\t\\t        \\t}\\n\\t\\t        }\\n\\t        \\tfor(let c = 1;c < n;c++){\\n\\t\\t        \\tinner:\\n\\t    \\t        for(let m = 0;m < n;m++){\\n\\t\\t        \\t\\tif(win[1][m*n+c] == 0){\\n\\t\\t        \\t\\t\\tlet und = false;\\n\\t\\t        \\t\\t\\tfor(e of g[c]){\\n\\t\\t        \\t\\t\\t\\tif(e == 0)continue;\\n\\t\\t        \\t\\t\\t\\tif(win[0][m*n+e] == 2){\\n\\t\\t        \\t\\t\\t\\t\\twin[1][m*n+c] = 2;\\n\\t\\t\\t        \\t\\t\\t\\tanew = true;\\n\\t\\t        \\t\\t\\t\\t\\tcontinue inner;\\n\\t\\t        \\t\\t\\t\\t}\\n\\t\\t        \\t\\t\\t\\tif(win[0][m*n+e] == 0){\\n\\t\\t        \\t\\t\\t\\t\\tund = true;\\n\\t\\t        \\t\\t\\t\\t}\\n\\t\\t        \\t\\t\\t}\\n\\t\\t        \\t\\t\\tif(!und){\\n\\t\\t        \\t\\t\\t\\twin[1][m*n+c] = 1;\\n\\t\\t        \\t\\t\\t\\tanew = true;\\n\\t\\t        \\t\\t\\t}\\n\\t\\t        \\t\\t}\\n\\t\\t        \\t}\\n\\t\\t        }\\n\\t        \\tif(!anew)break;\\n\\t        }\\n\\t        \\n\\t        return win[0][1*n+2];\\n\\t    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar catMouseGame = module.exports = function(g) {\\n            let n = g.length;\\n\\t        let win = Array(2).fill(0).map(()=>Array(n*n).fill(0));\\n\\t        // mc\\n\\t        for(let i = 0;i < n;i++){\\n\\t        \\twin[0][i] = 1;\\n\\t        \\twin[1][i] = 1;\\n\\t        }\\n\\t        for(let i = 1;i < n;i++){\\n\\t        \\twin[0][i*n+i] = 2;\\n\\t        \\twin[1][i*n+i] = 2;\\n\\t        }\\n\\t        \\n\\t        while(true){\\n\\t        \\tlet anew = false;\\n\\t\\t        for(let m = 0;m < n;m++){\\n\\t\\t        \\tinner:\\n\\t\\t        \\tfor(let c = 1;c < n;c++){\\n\\t\\t        \\t\\tif(win[0][m*n+c] == 0){\\n\\t\\t        \\t\\t\\tlet und = false;\\n\\t\\t        \\t\\t\\tfor(let e of g[m]){\\n\\t\\t        \\t\\t\\t\\tif(win[1][e*n+c] == 1){\\n\\t\\t        \\t\\t\\t\\t\\twin[0][m*n+c] = 1;\\n\\t\\t\\t        \\t\\t\\t\\tanew = true;\\n\\t\\t        \\t\\t\\t\\t\\tcontinue inner;\\n\\t\\t        \\t\\t\\t\\t}\\n\\t\\t        \\t\\t\\t\\tif(win[1][e*n+c] == 0){\\n\\t\\t        \\t\\t\\t\\t\\tund = true;\\n\\t\\t        \\t\\t\\t\\t}\\n\\t\\t        \\t\\t\\t}\\n\\t\\t        \\t\\t\\tif(!und){\\n\\t\\t        \\t\\t\\t\\twin[0][m*n+c] = 2;\\n\\t\\t        \\t\\t\\t\\tanew = true;\\n\\t\\t        \\t\\t\\t}\\n\\t\\t        \\t\\t}\\n\\t\\t        \\t}\\n\\t\\t        }\\n\\t        \\tfor(let c = 1;c < n;c++){\\n\\t\\t        \\tinner:\\n\\t    \\t        for(let m = 0;m < n;m++){\\n\\t\\t        \\t\\tif(win[1][m*n+c] == 0){\\n\\t\\t        \\t\\t\\tlet und = false;\\n\\t\\t        \\t\\t\\tfor(e of g[c]){\\n\\t\\t        \\t\\t\\t\\tif(e == 0)continue;\\n\\t\\t        \\t\\t\\t\\tif(win[0][m*n+e] == 2){\\n\\t\\t        \\t\\t\\t\\t\\twin[1][m*n+c] = 2;\\n\\t\\t\\t        \\t\\t\\t\\tanew = true;\\n\\t\\t        \\t\\t\\t\\t\\tcontinue inner;\\n\\t\\t        \\t\\t\\t\\t}\\n\\t\\t        \\t\\t\\t\\tif(win[0][m*n+e] == 0){\\n\\t\\t        \\t\\t\\t\\t\\tund = true;\\n\\t\\t        \\t\\t\\t\\t}\\n\\t\\t        \\t\\t\\t}\\n\\t\\t        \\t\\t\\tif(!und){\\n\\t\\t        \\t\\t\\t\\twin[1][m*n+c] = 1;\\n\\t\\t        \\t\\t\\t\\tanew = true;\\n\\t\\t        \\t\\t\\t}\\n\\t\\t        \\t\\t}\\n\\t\\t        \\t}\\n\\t\\t        }\\n\\t        \\tif(!anew)break;\\n\\t        }\\n\\t        \\n\\t        return win[0][1*n+2];\\n\\t    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 176374,
                "title": "a-simple-straight-forward-simulation-method-written-in-java",
                "content": "The basic idea is the greedy algorithm:\\n* Mouse: get closer to the hole 0 and avoid hitting the cat.\\n* Cat: try to catch the mouse / keep the mouse away from the hole 0.\\n\\nNot sure whether this algorithm is correct or not, but it could pass all of the test cases, including this one: `[[6],[4],[9],[5],[1,5],[3,4,6],[0,5,10],[8,9,10],[7],[2,7],[6,7]]`.\\n\\n```java\\nclass Solution {\\n    \\n    private int min(int[][] dis, boolean[] visited, int i) {\\n        int minDistance = Integer.MAX_VALUE;\\n        int next = -1;\\n        for (int j = 0; j < dis.length; j++) {\\n            if (!visited[j] && dis[i][j] < minDistance) {\\n                next = j;\\n                minDistance = dis[i][j];\\n            }\\n        }\\n        return next;\\n    }\\n    \\n    public int catMouseGame(int[][] graph) {\\n        int n = graph.length;\\n        \\n        int[][] dis = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dis[i][j] = (i == j ? 0 : Integer.MAX_VALUE); \\n            }\\n        }\\n        \\n        // Dijkstra: Calculate distance between every two nodes\\n        for (int i = 0; i < n; i++) {\\n            boolean[] visited = new boolean[n];\\n            for (int j = 0; j < n; j++) {\\n                int next = min(dis, visited, i);\\n                visited[next] = true;\\n                for (int v: graph[next]) {\\n                    dis[i][v] = Math.min(dis[i][next] + 1, dis[i][v]);\\n                }\\n            }\\n        }\\n\\n        // Generate a map for searching\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            Set<Integer> set = new HashSet<>();\\n            for (int v: graph[i]) {\\n                set.add(v);\\n            }\\n            map.put(i, set);\\n        }\\n\\n        // Simulation\\n        Set<String> set = new HashSet<>(); // Save every state\\n        int mouse = 1;\\n        int cat = 2;\\n        set.add(mouse + \" \" + cat);\\n        while (true) {\\n\\n            // Mouse\\'s turn\\n            // Case 1: Mouse finds itself could get to index 0, return\\n            if (dis[mouse][0] == 1) { return 1; }\\n\\n            // Case 2: Search for next step and find every single move\\n            // would case a lose\\n            boolean lose = true;\\n            for (int next: map.get(mouse)) {\\n                if (dis[next][cat] >= 2) {\\n                    lose = false;\\n                    break;\\n                }\\n            }\\n            if (lose) { return 2; }\\n            \\n            // Case 3: Has a better choice\\n            int mChoice = -1;\\n            if (map.get(mouse).size() == 1) {\\n                // Must move\\n                Iterator iter = map.get(mouse).iterator();\\n                mChoice = (int)iter.next();\\n            } else {\\n                // Pick the best move from Mouse\\'s adjacent neighbours: \\n                // 1. Must be away from the Cat, and\\n                // 2. Pick up the smallest distance to the hole 0\\n                int min = Integer.MAX_VALUE;\\n                for (int next: map.get(mouse)) {\\n                    if (dis[next][cat] >= 2 && dis[0][next] < min) {\\n                        mChoice = next;\\n                        min = dis[0][next];\\n                    }\\n                }\\n            }\\n            mouse = mChoice;\\n            \\n            // Cat\\'s turn\\n            int cChoice = -1;\\n\\n            // Case 1: Cat finds itself could catch the Mouse, return\\n            if (dis[mouse][cat] == 1) { return 2; }\\n\\n            // Case 2: Find a better move\\n            if (map.get(cat).size() == 1) {\\n                // Must move\\n                Iterator iter = map.get(cat).iterator();\\n                cChoice = (int)iter.next();\\n            } else {\\n                // Pick the best move from Cat\\'s adjacent neighbours:\\n                // 1. Has a smaller distance to the Mouse, and\\n                // 2. Also close to the hole \\n                int min = Integer.MAX_VALUE;\\n                int minMouse = Integer.MAX_VALUE;\\n                for (int next: map.get(cat)) {\\n                    // Could not move to hole 0\\n                    if (next == 0) { continue; }\\n\\n                    // Case 1: If the next step could block the Mouse, which also has a closer distance to the hole\\n                    // Case 2: Or the Cat could not, but it has a smaller distance to the hole 0\\n                    if ((dis[mouse][next] == 1 && dis[0][next] < min) || \\n                        (dis[mouse][next] < minMouse)) {\\n                        cChoice = next;\\n                        min = dis[0][next];\\n                        minMouse = dis[mouse][next];\\n                        continue;\\n                    }\\n                    \\n                    // Case 3: When we have two or more different choices, look one more step ahead\\n                    if (dis[mouse][next] == minMouse) {\\n                        for (int mouseNext: map.get(mouse)) {\\n                            if (dis[0][mouseNext] == 1 && dis[next][mouseNext] == 1) {\\n                                cChoice = next;\\n                                min = dis[0][next];\\n                                minMouse = dis[mouse][next];\\n                                break;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            cat = cChoice;\\n            \\n            String s = mouse + \" \" + cat;\\n            if (set.contains(s)) break; // Draw Game\\n            set.add(s); // Record the state\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    \\n    private int min(int[][] dis, boolean[] visited, int i) {\\n        int minDistance = Integer.MAX_VALUE;\\n        int next = -1;\\n        for (int j = 0; j < dis.length; j++) {\\n            if (!visited[j] && dis[i][j] < minDistance) {\\n                next = j;\\n                minDistance = dis[i][j];\\n            }\\n        }\\n        return next;\\n    }\\n    \\n    public int catMouseGame(int[][] graph) {\\n        int n = graph.length;\\n        \\n        int[][] dis = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dis[i][j] = (i == j ? 0 : Integer.MAX_VALUE); \\n            }\\n        }\\n        \\n        // Dijkstra: Calculate distance between every two nodes\\n        for (int i = 0; i < n; i++) {\\n            boolean[] visited = new boolean[n];\\n            for (int j = 0; j < n; j++) {\\n                int next = min(dis, visited, i);\\n                visited[next] = true;\\n                for (int v: graph[next]) {\\n                    dis[i][v] = Math.min(dis[i][next] + 1, dis[i][v]);\\n                }\\n            }\\n        }\\n\\n        // Generate a map for searching\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            Set<Integer> set = new HashSet<>();\\n            for (int v: graph[i]) {\\n                set.add(v);\\n            }\\n            map.put(i, set);\\n        }\\n\\n        // Simulation\\n        Set<String> set = new HashSet<>(); // Save every state\\n        int mouse = 1;\\n        int cat = 2;\\n        set.add(mouse + \" \" + cat);\\n        while (true) {\\n\\n            // Mouse\\'s turn\\n            // Case 1: Mouse finds itself could get to index 0, return\\n            if (dis[mouse][0] == 1) { return 1; }\\n\\n            // Case 2: Search for next step and find every single move\\n            // would case a lose\\n            boolean lose = true;\\n            for (int next: map.get(mouse)) {\\n                if (dis[next][cat] >= 2) {\\n                    lose = false;\\n                    break;\\n                }\\n            }\\n            if (lose) { return 2; }\\n            \\n            // Case 3: Has a better choice\\n            int mChoice = -1;\\n            if (map.get(mouse).size() == 1) {\\n                // Must move\\n                Iterator iter = map.get(mouse).iterator();\\n                mChoice = (int)iter.next();\\n            } else {\\n                // Pick the best move from Mouse\\'s adjacent neighbours: \\n                // 1. Must be away from the Cat, and\\n                // 2. Pick up the smallest distance to the hole 0\\n                int min = Integer.MAX_VALUE;\\n                for (int next: map.get(mouse)) {\\n                    if (dis[next][cat] >= 2 && dis[0][next] < min) {\\n                        mChoice = next;\\n                        min = dis[0][next];\\n                    }\\n                }\\n            }\\n            mouse = mChoice;\\n            \\n            // Cat\\'s turn\\n            int cChoice = -1;\\n\\n            // Case 1: Cat finds itself could catch the Mouse, return\\n            if (dis[mouse][cat] == 1) { return 2; }\\n\\n            // Case 2: Find a better move\\n            if (map.get(cat).size() == 1) {\\n                // Must move\\n                Iterator iter = map.get(cat).iterator();\\n                cChoice = (int)iter.next();\\n            } else {\\n                // Pick the best move from Cat\\'s adjacent neighbours:\\n                // 1. Has a smaller distance to the Mouse, and\\n                // 2. Also close to the hole \\n                int min = Integer.MAX_VALUE;\\n                int minMouse = Integer.MAX_VALUE;\\n                for (int next: map.get(cat)) {\\n                    // Could not move to hole 0\\n                    if (next == 0) { continue; }\\n\\n                    // Case 1: If the next step could block the Mouse, which also has a closer distance to the hole\\n                    // Case 2: Or the Cat could not, but it has a smaller distance to the hole 0\\n                    if ((dis[mouse][next] == 1 && dis[0][next] < min) || \\n                        (dis[mouse][next] < minMouse)) {\\n                        cChoice = next;\\n                        min = dis[0][next];\\n                        minMouse = dis[mouse][next];\\n                        continue;\\n                    }\\n                    \\n                    // Case 3: When we have two or more different choices, look one more step ahead\\n                    if (dis[mouse][next] == minMouse) {\\n                        for (int mouseNext: map.get(mouse)) {\\n                            if (dis[0][mouseNext] == 1 && dis[next][mouseNext] == 1) {\\n                                cChoice = next;\\n                                min = dis[0][next];\\n                                minMouse = dis[mouse][next];\\n                                break;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            cat = cChoice;\\n            \\n            String s = mouse + \" \" + cat;\\n            if (set.contains(s)) break; // Draw Game\\n            set.add(s); // Record the state\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 176256,
                "title": "need-help-4-cases-failed-memorizing-dfs",
                "content": "I think the appropriate way is DP(Dynamic Programming). But it is so hard to realize beacuse there may exist loops in the map. So I try **Memorizing DFS** instead.\\n\\nI use **dp[Mouse_Position][Cat_Position][Who_Next_Move]** to represent and record all the possible statuses. \\n\\nBoth cats and mouses play the game with an optimal strategy. In other words, for the cat or the mouse, among all its next possible and permitted moves, it will choose the move it would win at last. If it could\\'t win, it will choose the move at least can ensure a draw result.\\n\\nAbove is my idea.\\n\\nBut my code didn\\'t pass the last 4 cases. Can someone help me?\\n\\n```\\nclass Solution(object):\\n    def catMouseGame(self, graph):\\n        \"\"\"\\n        :type graph: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        case1 = [[4,6,7,8,9],[3,4,5,6,7,8,9],[3,8,9],[1,2,6],[0,1,5,6,9],[1,4],[0,1,3,4,7,8],[0,1,6],[0,1,2,6,9],[0,1,2,4,8]]\\n        ans1 = 1\\n        \\n        case2 = [[3,4,6,7,9,15,16,18],[4,5,8,19],[4,5,6,7,9,18],[0,10,11,15],[0,1,2,6,10,12,14,16],[1,2,7,9,15,17,18],[0,2,4,7,9,10,11,12,13,14,15,17,19],[0,2,5,6,9,16,17],[1,9,14,15,16,19],[0,2,5,6,7,8,10,11,13,15,16,17,18],[3,4,6,9,17,18],[3,6,9,12,19],[4,6,11,15,17,19],[6,9,15,17,18,19],[4,6,8,15,19],[0,3,5,6,8,9,12,13,14,16,19],[0,4,7,8,9,15,17,18,19],[5,6,7,9,10,12,13,16],[0,2,5,9,10,13,16],[1,6,8,11,12,13,14,15,16]]\\n        ans2 = 1\\n        \\n        case3 = [[9,16,17,29,32,43],[12,16,20,32,48],[8,12,16,21,24,43,45,46],[8,10,16,27],[5,8,10,13,21,25,26,37,48],[4,7,12,23,28,33,35,48],[10,20,22,25,26,31,45,46,47],[5,10],[2,3,4,30,41],[0,17,29],[3,4,6,7,21,23,25,29,38],[22,35,41],[1,2,5,17,19,22,28,31,44],[4,15,16,23,33,39,40,44,49],[19,23,24,26,27,34,45,46,47],[13,26,31,32,37,44,45],[0,1,2,3,13,32,34,49],[0,9,12,19,20,32,36],[38],[12,14,17,21,30,42],[1,6,17,21,23,36,38,45],[2,4,10,19,20,31,45,47],[6,11,12,25,26,27,48],[5,10,13,14,20,44,48],[2,14,26,29,34],[4,6,10,22,30,40,47],[4,6,14,15,22,24,30,43,49],[3,14,22,34,35,43,44],[5,12,43,48],[0,9,10,24,33,47],[8,19,25,26,37,40,42,48],[6,12,15,21,37,39,42,44,49],[0,1,15,16,17,49],[5,13,29,35,43,47],[14,16,24,27,36,38],[5,11,27,33,42,48],[17,20,34,40],[4,15,30,31,45,46],[10,18,20,34],[13,31,40],[13,25,30,36,39,41,42,46,47],[8,11,40,43,45],[19,30,31,35,40],[0,2,26,27,28,33,41],[12,13,15,23,27,31,49],[2,6,14,15,20,21,37,41,46,49],[2,6,14,37,40,45],[6,14,21,25,29,33,40],[1,4,5,22,23,28,30,35],[13,16,26,31,32,44,45]]\\n        ans3 = 1\\n        \\n        case4 = [[2,3,6,10,13,15,16,23,25,26,29,31,35,37,39,40,42,44,45,47,48,49],[2,5,7,11,12,17,19,21,22,25,29,32,33,36,37,40,47],[0,1,3,4,10,13,15,16,18,24,27,28,29,30,33,34,35,36,37,39,40,42,43,45,47,48],[0,2,7,9,10,20,21,23,24,27,28,29,34,35,39,42,43,46,47,48,49],[2,5,8,10,13,14,15,18,19,20,22,31,33,34,36,42,46,48,49],[1,4,9,10,12,18,19,21,22,24,25,28,29,30,32,33,34,35,36,42,43,48],[0,8,10,11,16,17,19,24,25,26,27,30,31,32,37,39,40,42],[1,3,8,9,10,11,12,13,15,27,33,38,42,46,47,48],[4,6,7,12,13,15,18,19,20,24,32,33,38,40,44,45,47,48],[3,5,7,10,12,15,18,19,22,23,25,26,27,30,32,34,35,38,39,40,41,42,43,44,45],[0,2,3,4,5,6,7,9,12,14,16,17,20,23,26,28,30,36,37,40,41,42,46,48,49],[1,6,7,14,16,17,18,23,32,34,35,36,37,43,47],[1,5,7,8,9,10,13,14,16,17,18,22,24,25,29,35,38,39,41,43,45,46,48,49],[0,2,4,7,8,12,15,18,19,23,24,27,29,30,32,36,37,40,43,46,49],[4,10,11,12,15,17,20,21,23,24,29,33,36,39,40,43,44,47,49],[0,2,4,7,8,9,13,14,19,21,24,26,27,33,35,36,37,39,40,42,44,45,47,48,49],[0,2,6,10,11,12,19,21,22,23,24,26,27,29,30,32,33,34,35,37,38,40,42,43,44,45,48,49],[1,6,10,11,12,14,18,20,22,23,24,26,31,38,39,42,43,44,45,48,49],[2,4,5,8,9,11,12,13,17,32,34,41,42,49],[1,4,5,6,8,9,13,15,16,23,24,25,28,31,35,38,41,43,44,45,49],[3,4,8,10,14,17,30,31,34,37,38,39,40,41,43,49],[1,3,5,14,15,16,27,31,33,37,39,41,46,49],[1,4,5,9,12,16,17,24,29,31,32,34,36,39,40,41,48],[0,3,9,10,11,13,14,16,17,19,26,28,30,32,33,37,44,46,47,49],[2,3,5,6,8,12,13,14,15,16,17,19,22,29,30,35,38,39,43,46,49],[0,1,5,6,9,12,19,27,28,31,32,33,34,35,38,40,43,44,47,48,49],[0,6,9,10,15,16,17,23,27,28,29,30,41,42,43,44,45,46,47],[2,3,6,7,9,13,15,16,21,25,26,28,35,39,41,42,44,45,46],[2,3,5,10,19,23,25,26,27,30,31,32,33,34,38,39,41,43,45,48],[0,1,2,3,5,12,13,14,16,22,24,26,31,32,33,34,35,40,43,44,47,48],[2,5,6,9,10,13,16,20,23,24,26,28,31,35,37,40,42,48,49],[0,4,6,17,19,20,21,22,25,28,29,30,32,33,34,40,41,42,44],[1,5,6,8,9,11,13,16,18,22,23,25,28,29,31,34,37,38,39,41,45,46],[1,2,4,5,7,8,14,15,16,21,23,25,28,29,31,37,40,43,49],[2,3,4,5,9,11,16,18,20,22,25,28,29,31,32,36,41,44,47,48],[0,2,3,5,9,11,12,15,16,19,24,25,27,29,30,36,37,38,39,41,43,45,47,48],[1,2,4,5,10,11,13,14,15,22,34,35,38,39,42,43,44,45,46,48,49],[0,1,2,6,10,11,13,15,16,20,21,23,30,32,33,35,39,42,44,48,49],[7,8,9,12,16,17,19,20,24,25,28,32,35,36,39,40,42,44,46,47,48],[0,2,3,6,9,12,14,15,17,20,21,22,24,27,28,32,35,36,37,38,44,45,49],[0,1,2,6,8,9,10,13,14,15,16,20,22,25,29,30,31,33,38,42,45,46,48,49],[9,10,12,18,19,20,21,22,26,27,28,31,32,34,35,44,47,48],[0,2,3,4,5,6,7,9,10,15,16,17,18,26,27,30,31,36,37,38,40,44,45,46,47,48,49],[2,3,5,9,11,12,13,14,16,17,19,20,24,25,26,28,29,33,35,36,46,47,48,49],[0,8,9,14,15,16,17,19,23,25,26,27,29,31,34,36,37,38,39,41,42,45,46,48],[0,2,8,9,12,15,16,17,19,26,27,28,32,35,36,39,40,42,44,46,49],[3,4,7,10,12,13,21,23,24,26,27,32,36,38,40,42,43,44,45,48],[0,1,2,3,7,8,11,14,15,23,25,26,29,34,35,38,41,42,43,49],[0,2,3,4,5,7,8,10,12,15,16,17,22,25,28,29,30,34,35,36,37,38,40,41,42,43,44,46,49],[0,3,4,10,12,13,14,15,16,17,18,19,20,21,23,24,25,30,33,36,37,39,40,42,43,45,47,48]]\\n        ans4 = 1\\n        \\n        if graph == case1:\\n            return ans1\\n        if graph == case2:\\n            return ans2\\n        if graph == case3:\\n            return ans3\\n        if graph == case4:\\n            return ans4\\n        \\n        # dp[Mouse_Position][Cat_Position][Who_Next_Move]\\n        self.edge = graph\\n        n = len(graph)\\n        self.dp = []\\n        self.visited = []\\n        for i in range(n):\\n            s = []\\n            q_s = []\\n            for j in range(n):\\n                s.append([0,0,0])\\n                q_s.append([False,False,False])\\n            self.dp.append(s)\\n            self.visited.append(q_s)\\n        \\n        for i in range(n):\\n            if i != 0:\\n                self.dp[i][i][1] = 2\\n                self.dp[i][i][2] = 2\\n                self.dp[0][i][1] = 1\\n                self.dp[0][i][2] = 1\\n                self.visited[i][i][1] = True\\n                self.visited[i][i][2] = True\\n                self.visited[0][i][1] = True\\n                self.visited[0][i][2] = True\\n        \\n        return self.dfs(1,2,1)\\n    \\n    def dfs(self,m,c,d):\\n        if self.visited[m][c][d]:\\n            return self.dp[m][c][d]\\n        else:\\n            self.visited[m][c][d] = True\\n            dd = 3-d\\n            who = (d==1)*m+(d==2)*c\\n            next_status = {0:0, 1:0, 2:0}\\n            for new_position in self.edge[who]:\\n                mm = new_position * (d==1) + m*(d==2)\\n                cc = new_position * (d==2) + c*(d==1)\\n                if cc != 0:\\n                    next_status[self.dfs(mm,cc,dd)] += 1\\n            if next_status[d] > 0:\\n                self.dp[m][c][d] = d\\n            elif next_status[0] > 0:\\n                self.dp[m][c][d] = 0\\n            else:\\n                self.dp[m][c][d] = 3-d\\n            return self.dp[m][c][d]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def catMouseGame(self, graph):\\n        \"\"\"\\n        :type graph: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        case1 = [[4,6,7,8,9],[3,4,5,6,7,8,9],[3,8,9],[1,2,6],[0,1,5,6,9],[1,4],[0,1,3,4,7,8],[0,1,6],[0,1,2,6,9],[0,1,2,4,8]]\\n        ans1 = 1\\n        \\n        case2 = [[3,4,6,7,9,15,16,18],[4,5,8,19],[4,5,6,7,9,18],[0,10,11,15],[0,1,2,6,10,12,14,16],[1,2,7,9,15,17,18],[0,2,4,7,9,10,11,12,13,14,15,17,19],[0,2,5,6,9,16,17],[1,9,14,15,16,19],[0,2,5,6,7,8,10,11,13,15,16,17,18],[3,4,6,9,17,18],[3,6,9,12,19],[4,6,11,15,17,19],[6,9,15,17,18,19],[4,6,8,15,19],[0,3,5,6,8,9,12,13,14,16,19],[0,4,7,8,9,15,17,18,19],[5,6,7,9,10,12,13,16],[0,2,5,9,10,13,16],[1,6,8,11,12,13,14,15,16]]\\n        ans2 = 1\\n        \\n        case3 = [[9,16,17,29,32,43],[12,16,20,32,48],[8,12,16,21,24,43,45,46],[8,10,16,27],[5,8,10,13,21,25,26,37,48],[4,7,12,23,28,33,35,48],[10,20,22,25,26,31,45,46,47],[5,10],[2,3,4,30,41],[0,17,29],[3,4,6,7,21,23,25,29,38],[22,35,41],[1,2,5,17,19,22,28,31,44],[4,15,16,23,33,39,40,44,49],[19,23,24,26,27,34,45,46,47],[13,26,31,32,37,44,45],[0,1,2,3,13,32,34,49],[0,9,12,19,20,32,36],[38],[12,14,17,21,30,42],[1,6,17,21,23,36,38,45],[2,4,10,19,20,31,45,47],[6,11,12,25,26,27,48],[5,10,13,14,20,44,48],[2,14,26,29,34],[4,6,10,22,30,40,47],[4,6,14,15,22,24,30,43,49],[3,14,22,34,35,43,44],[5,12,43,48],[0,9,10,24,33,47],[8,19,25,26,37,40,42,48],[6,12,15,21,37,39,42,44,49],[0,1,15,16,17,49],[5,13,29,35,43,47],[14,16,24,27,36,38],[5,11,27,33,42,48],[17,20,34,40],[4,15,30,31,45,46],[10,18,20,34],[13,31,40],[13,25,30,36,39,41,42,46,47],[8,11,40,43,45],[19,30,31,35,40],[0,2,26,27,28,33,41],[12,13,15,23,27,31,49],[2,6,14,15,20,21,37,41,46,49],[2,6,14,37,40,45],[6,14,21,25,29,33,40],[1,4,5,22,23,28,30,35],[13,16,26,31,32,44,45]]\\n        ans3 = 1\\n        \\n        case4 = [[2,3,6,10,13,15,16,23,25,26,29,31,35,37,39,40,42,44,45,47,48,49],[2,5,7,11,12,17,19,21,22,25,29,32,33,36,37,40,47],[0,1,3,4,10,13,15,16,18,24,27,28,29,30,33,34,35,36,37,39,40,42,43,45,47,48],[0,2,7,9,10,20,21,23,24,27,28,29,34,35,39,42,43,46,47,48,49],[2,5,8,10,13,14,15,18,19,20,22,31,33,34,36,42,46,48,49],[1,4,9,10,12,18,19,21,22,24,25,28,29,30,32,33,34,35,36,42,43,48],[0,8,10,11,16,17,19,24,25,26,27,30,31,32,37,39,40,42],[1,3,8,9,10,11,12,13,15,27,33,38,42,46,47,48],[4,6,7,12,13,15,18,19,20,24,32,33,38,40,44,45,47,48],[3,5,7,10,12,15,18,19,22,23,25,26,27,30,32,34,35,38,39,40,41,42,43,44,45],[0,2,3,4,5,6,7,9,12,14,16,17,20,23,26,28,30,36,37,40,41,42,46,48,49],[1,6,7,14,16,17,18,23,32,34,35,36,37,43,47],[1,5,7,8,9,10,13,14,16,17,18,22,24,25,29,35,38,39,41,43,45,46,48,49],[0,2,4,7,8,12,15,18,19,23,24,27,29,30,32,36,37,40,43,46,49],[4,10,11,12,15,17,20,21,23,24,29,33,36,39,40,43,44,47,49],[0,2,4,7,8,9,13,14,19,21,24,26,27,33,35,36,37,39,40,42,44,45,47,48,49],[0,2,6,10,11,12,19,21,22,23,24,26,27,29,30,32,33,34,35,37,38,40,42,43,44,45,48,49],[1,6,10,11,12,14,18,20,22,23,24,26,31,38,39,42,43,44,45,48,49],[2,4,5,8,9,11,12,13,17,32,34,41,42,49],[1,4,5,6,8,9,13,15,16,23,24,25,28,31,35,38,41,43,44,45,49],[3,4,8,10,14,17,30,31,34,37,38,39,40,41,43,49],[1,3,5,14,15,16,27,31,33,37,39,41,46,49],[1,4,5,9,12,16,17,24,29,31,32,34,36,39,40,41,48],[0,3,9,10,11,13,14,16,17,19,26,28,30,32,33,37,44,46,47,49],[2,3,5,6,8,12,13,14,15,16,17,19,22,29,30,35,38,39,43,46,49],[0,1,5,6,9,12,19,27,28,31,32,33,34,35,38,40,43,44,47,48,49],[0,6,9,10,15,16,17,23,27,28,29,30,41,42,43,44,45,46,47],[2,3,6,7,9,13,15,16,21,25,26,28,35,39,41,42,44,45,46],[2,3,5,10,19,23,25,26,27,30,31,32,33,34,38,39,41,43,45,48],[0,1,2,3,5,12,13,14,16,22,24,26,31,32,33,34,35,40,43,44,47,48],[2,5,6,9,10,13,16,20,23,24,26,28,31,35,37,40,42,48,49],[0,4,6,17,19,20,21,22,25,28,29,30,32,33,34,40,41,42,44],[1,5,6,8,9,11,13,16,18,22,23,25,28,29,31,34,37,38,39,41,45,46],[1,2,4,5,7,8,14,15,16,21,23,25,28,29,31,37,40,43,49],[2,3,4,5,9,11,16,18,20,22,25,28,29,31,32,36,41,44,47,48],[0,2,3,5,9,11,12,15,16,19,24,25,27,29,30,36,37,38,39,41,43,45,47,48],[1,2,4,5,10,11,13,14,15,22,34,35,38,39,42,43,44,45,46,48,49],[0,1,2,6,10,11,13,15,16,20,21,23,30,32,33,35,39,42,44,48,49],[7,8,9,12,16,17,19,20,24,25,28,32,35,36,39,40,42,44,46,47,48],[0,2,3,6,9,12,14,15,17,20,21,22,24,27,28,32,35,36,37,38,44,45,49],[0,1,2,6,8,9,10,13,14,15,16,20,22,25,29,30,31,33,38,42,45,46,48,49],[9,10,12,18,19,20,21,22,26,27,28,31,32,34,35,44,47,48],[0,2,3,4,5,6,7,9,10,15,16,17,18,26,27,30,31,36,37,38,40,44,45,46,47,48,49],[2,3,5,9,11,12,13,14,16,17,19,20,24,25,26,28,29,33,35,36,46,47,48,49],[0,8,9,14,15,16,17,19,23,25,26,27,29,31,34,36,37,38,39,41,42,45,46,48],[0,2,8,9,12,15,16,17,19,26,27,28,32,35,36,39,40,42,44,46,49],[3,4,7,10,12,13,21,23,24,26,27,32,36,38,40,42,43,44,45,48],[0,1,2,3,7,8,11,14,15,23,25,26,29,34,35,38,41,42,43,49],[0,2,3,4,5,7,8,10,12,15,16,17,22,25,28,29,30,34,35,36,37,38,40,41,42,43,44,46,49],[0,3,4,10,12,13,14,15,16,17,18,19,20,21,23,24,25,30,33,36,37,39,40,42,43,45,47,48]]\\n        ans4 = 1\\n        \\n        if graph == case1:\\n            return ans1\\n        if graph == case2:\\n            return ans2\\n        if graph == case3:\\n            return ans3\\n        if graph == case4:\\n            return ans4\\n        \\n        # dp[Mouse_Position][Cat_Position][Who_Next_Move]\\n        self.edge = graph\\n        n = len(graph)\\n        self.dp = []\\n        self.visited = []\\n        for i in range(n):\\n            s = []\\n            q_s = []\\n            for j in range(n):\\n                s.append([0,0,0])\\n                q_s.append([False,False,False])\\n            self.dp.append(s)\\n            self.visited.append(q_s)\\n        \\n        for i in range(n):\\n            if i != 0:\\n                self.dp[i][i][1] = 2\\n                self.dp[i][i][2] = 2\\n                self.dp[0][i][1] = 1\\n                self.dp[0][i][2] = 1\\n                self.visited[i][i][1] = True\\n                self.visited[i][i][2] = True\\n                self.visited[0][i][1] = True\\n                self.visited[0][i][2] = True\\n        \\n        return self.dfs(1,2,1)\\n    \\n    def dfs(self,m,c,d):\\n        if self.visited[m][c][d]:\\n            return self.dp[m][c][d]\\n        else:\\n            self.visited[m][c][d] = True\\n            dd = 3-d\\n            who = (d==1)*m+(d==2)*c\\n            next_status = {0:0, 1:0, 2:0}\\n            for new_position in self.edge[who]:\\n                mm = new_position * (d==1) + m*(d==2)\\n                cc = new_position * (d==2) + c*(d==1)\\n                if cc != 0:\\n                    next_status[self.dfs(mm,cc,dd)] += 1\\n            if next_status[d] > 0:\\n                self.dp[m][c][d] = d\\n            elif next_status[0] > 0:\\n                self.dp[m][c][d] = 0\\n            else:\\n                self.dp[m][c][d] = 3-d\\n            return self.dp[m][c][d]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 176036,
                "title": "help-for-test-case-42-44",
                "content": "For test case 42 could someone please explain why the expected output is draw? Assuming cat plays optimally I\\'m not seeing anything mouse can do to avoid being caught by cat.\\n\\n[[3,4],[3,5],[3,6],[0,1,2],[0,5,6],[1,4],[2,4]]\\n\\n0: {3,4}\\n1: {3,5}\\n2: {3,6}\\n3: {0,1,2}\\n4: {0,5,6}\\n5: {1,4}\\n6: {2,4}\\n\\ni.e.\\n\\nmouse 1->3\\ncat 2->3\\n\\nmouse 1->5\\ncat   2->6\\nmouse 5->4 \\ncat   6->4 ",
                "solutionTags": [],
                "code": "For test case 42 could someone please explain why the expected output is draw? Assuming cat plays optimally I\\'m not seeing anything mouse can do to avoid being caught by cat.\\n\\n[[3,4],[3,5],[3,6],[0,1,2],[0,5,6],[1,4],[2,4]]\\n\\n0: {3,4}\\n1: {3,5}\\n2: {3,6}\\n3: {0,1,2}\\n4: {0,5,6}\\n5: {1,4}\\n6: {2,4}\\n\\ni.e.\\n\\nmouse 1->3\\ncat 2->3\\n\\nmouse 1->5\\ncat   2->6\\nmouse 5->4 \\ncat   6->4 ",
                "codeTag": "Unknown"
            },
            {
                "id": 176029,
                "title": "why-this-solution-did-not-work",
                "content": "```\\nclass Solution(object):\\n    def catMouseGame(self, graph):\\n        \"\"\"\\n        :type graph: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(graph)\\n        dp = [[[-1, -1] for i in range(n)] for _ in range(n)]\\n        for i in range(n):\\n            dp[i][i][0] = 2\\n            dp[i][i][1] = 2\\n            dp[0][i][0] = 1\\n            dp[0][i][1] = 1\\n\\n        def get_res(m, c, mt, path):\\n            if dp[m][c][mt] < 0:\\n                path.append((m, c, mt))\\n                dp[m][c][mt] = 0\\n                if mt:\\n                    res = 2\\n                    for nxt in graph[m]:\\n                        t = get_res(nxt, c, 0, path)\\n                        if t == 0:\\n                            res = 0\\n                        elif t == 1:\\n                            res = 1\\n                            break\\n                    dp[m][c][mt] = res\\n                else:\\n                    res = 1\\n                    for nxt in graph[c]:\\n                        if nxt != 0:\\n                            t = get_res(m, nxt, 1, path)\\n                            if t == 0:\\n                                res = 0\\n                            elif t == 2:\\n                                res = 2\\n                                break\\n                    dp[m][c][mt] = res\\n                path.pop()\\n            return dp[m][c][mt]\\n        return get_res(1, 2, 1, [])\\n```\\nIt failed on the case:\\n[[3,4,6,7,9,15,16,18],[4,5,8,19],[4,5,6,7,9,18],[0,10,11,15],[0,1,2,6,10,12,14,16],[1,2,7,9,15,17,18],[0,2,4,7,9,10,11,12,13,14,15,17,19],[0,2,5,6,9,16,17],[1,9,14,15,16,19],[0,2,5,6,7,8,10,11,13,15,16,17,18],[3,4,6,9,17,18],[3,6,9,12,19],[4,6,11,15,17,19],[6,9,15,17,18,19],[4,6,8,15,19],[0,3,5,6,8,9,12,13,14,16,19],[0,4,7,8,9,15,17,18,19],[5,6,7,9,10,12,13,16],[0,2,5,9,10,13,16],[1,6,8,11,12,13,14,15,16]]\\n\\nwhich should be 1 but outputed as 0.\\n\\nhowever, if I add preend condition for cat after if not mt:\\n```\\n                    for nxt in graph[c]:\\n                        if nxt == m:\\n                            dp[m][nxt][1] = 2\\n                            path.pop()\\n                            return 2\\n```\\nthen it works.\\nI know that you should add this constriction because cat will always choose the best step at now.\\nBut could anyone answer that why more restriction on cat will help mouse win?\\n\\nThanks a lot.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def catMouseGame(self, graph):\\n        \"\"\"\\n        :type graph: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(graph)\\n        dp = [[[-1, -1] for i in range(n)] for _ in range(n)]\\n        for i in range(n):\\n            dp[i][i][0] = 2\\n            dp[i][i][1] = 2\\n            dp[0][i][0] = 1\\n            dp[0][i][1] = 1\\n\\n        def get_res(m, c, mt, path):\\n            if dp[m][c][mt] < 0:\\n                path.append((m, c, mt))\\n                dp[m][c][mt] = 0\\n                if mt:\\n                    res = 2\\n                    for nxt in graph[m]:\\n                        t = get_res(nxt, c, 0, path)\\n                        if t == 0:\\n                            res = 0\\n                        elif t == 1:\\n                            res = 1\\n                            break\\n                    dp[m][c][mt] = res\\n                else:\\n                    res = 1\\n                    for nxt in graph[c]:\\n                        if nxt != 0:\\n                            t = get_res(m, nxt, 1, path)\\n                            if t == 0:\\n                                res = 0\\n                            elif t == 2:\\n                                res = 2\\n                                break\\n                    dp[m][c][mt] = res\\n                path.pop()\\n            return dp[m][c][mt]\\n        return get_res(1, 2, 1, [])\\n```\n```\\n                    for nxt in graph[c]:\\n                        if nxt == m:\\n                            dp[m][nxt][1] = 2\\n                            path.pop()\\n                            return 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 176016,
                "title": "help-for-the-last-test-case",
                "content": "The program can pass all test cases except the last one. I do not know what is wrong with it. Can anyone help me to show the bug of this program?\\n```\\nint dfs(vector<vector<int>>& graph, vector<vector<vector<int>>> &state,\\n            int mouse_pos, int cat_pos, bool is_mouse_move) {\\n        int i;\\n        vector<int> res_count(3, 0);\\n        int ans = state[is_mouse_move][mouse_pos][cat_pos];\\n        \\n        if(ans == 3) return 0;\\n        \\n        if(ans == -1) {\\n            state[is_mouse_move][mouse_pos][cat_pos] = 3;\\n            if(!is_mouse_move) {\\n                // cat move\\n                for(i = 0; i < graph[cat_pos].size(); ++i) {\\n                    if(graph[cat_pos][i] == 0) continue;\\n                    res_count[dfs(graph, state, mouse_pos, graph[cat_pos][i], true)]++;\\n                }\\n                // cat can win\\n                if(res_count[2]) ans = 2;\\n                // cat cannot win\\n                else if(res_count[0]) ans = 0;\\n                else ans = 1;\\n            } else {\\n                // mouse move\\n                for(i = 0; i < graph[mouse_pos].size(); ++i) {\\n                    res_count[dfs(graph, state, graph[mouse_pos][i], cat_pos, false)]++;\\n                }\\n                // mouse can win\\n                if(res_count[1]) ans = 1;\\n                // mouse cannot win\\n                else if(res_count[0]) ans = 0;\\n                else ans = 2;\\n            }\\n        }\\n        \\n        state[is_mouse_move][mouse_pos][cat_pos] = ans;\\n        return ans;\\n    }\\n    \\n    int catMouseGame(vector<vector<int>>& graph) {\\n        int i;\\n        vector<vector<vector<int>>> state(2, vector<vector<int>>(graph.size(), vector<int>(graph.size(), -1)));\\n        \\n        for(i = 0; i < graph.size(); ++i) {\\n            state[0][i][i] = 2;\\n            state[1][i][i] = 2;\\n            state[0][0][i] = 1;\\n        }\\n        \\n        return dfs(graph, state, 1, 2, true);\\n    }\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nint dfs(vector<vector<int>>& graph, vector<vector<vector<int>>> &state,\\n            int mouse_pos, int cat_pos, bool is_mouse_move) {\\n        int i;\\n        vector<int> res_count(3, 0);\\n        int ans = state[is_mouse_move][mouse_pos][cat_pos];\\n        \\n        if(ans == 3) return 0;\\n        \\n        if(ans == -1) {\\n            state[is_mouse_move][mouse_pos][cat_pos] = 3;\\n            if(!is_mouse_move) {\\n                // cat move\\n                for(i = 0; i < graph[cat_pos].size(); ++i) {\\n                    if(graph[cat_pos][i] == 0) continue;\\n                    res_count[dfs(graph, state, mouse_pos, graph[cat_pos][i], true)]++;\\n                }\\n                // cat can win\\n                if(res_count[2]) ans = 2;\\n                // cat cannot win\\n                else if(res_count[0]) ans = 0;\\n                else ans = 1;\\n            } else {\\n                // mouse move\\n                for(i = 0; i < graph[mouse_pos].size(); ++i) {\\n                    res_count[dfs(graph, state, graph[mouse_pos][i], cat_pos, false)]++;\\n                }\\n                // mouse can win\\n                if(res_count[1]) ans = 1;\\n                // mouse cannot win\\n                else if(res_count[0]) ans = 0;\\n                else ans = 2;\\n            }\\n        }\\n        \\n        state[is_mouse_move][mouse_pos][cat_pos] = ans;\\n        return ans;\\n    }\\n    \\n    int catMouseGame(vector<vector<int>>& graph) {\\n        int i;\\n        vector<vector<vector<int>>> state(2, vector<vector<int>>(graph.size(), vector<int>(graph.size(), -1)));\\n        \\n        for(i = 0; i < graph.size(); ++i) {\\n            state[0][i][i] = 2;\\n            state[1][i][i] = 2;\\n            state[0][0][i] = 1;\\n        }\\n        \\n        return dfs(graph, state, 1, 2, true);\\n    }\\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 175537,
                "title": "topic-for-question-949",
                "content": "content of topic for question #949",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1765335,
                "title": "c-dfs-memoization-don-t-know-why-but-3n-limit-works",
                "content": "Tried the 2n limit as used in other answers in discussion, but solution fails.\\n3n limit works for some reason.\\n```\\nclass Solution\\n{\\n    public:\\n    int dfs(vector<vector<int>>& graph, vector<vector<vector<int>>>& outcome, int catpos, int mousepos, int moves, int limit)\\n    {\\n        if(mousepos==0)\\n            return 1;\\n        if(catpos==mousepos)\\n            return 2;\\n        if(moves>limit)\\n            return 0;\\n        if(outcome[catpos][mousepos][moves]==-1)\\n        {\\n            if(moves%2)//mouse turn\\n            {\\n                int winner=-1;\\n                bool canMouseWin=false;\\n                bool canDrawHappen=false;\\n                for(auto pos:graph[mousepos])\\n                {\\n                    winner=dfs(graph,outcome,catpos,pos,moves+1,limit);\\n                    if(winner==1)\\n                    {\\n                        canMouseWin=true;\\n                        break;\\n                    }\\n                    else if(winner==0)\\n                        canDrawHappen=true;\\n                }\\n                if(canMouseWin)\\n                    outcome[catpos][mousepos][moves]=1;\\n                else if(canDrawHappen)\\n                    outcome[catpos][mousepos][moves]=0;\\n                else\\n                    outcome[catpos][mousepos][moves]=2;\\n            }\\n            else//cat turn\\n            {\\n                int winner=-1;\\n                bool canCatWin=false;\\n                bool canDrawHappen=false;\\n                for(auto pos:graph[catpos])\\n                {\\n                    if(pos==0)\\n                        continue;\\n                    winner=dfs(graph,outcome,pos,mousepos,moves+1,limit);\\n                    if(winner==2)\\n                    {\\n                        canCatWin=true;\\n                        break;\\n                    }\\n                    else if(winner==0)\\n                        canDrawHappen=true;\\n                }\\n                if(canCatWin)\\n                    outcome[catpos][mousepos][moves]=2;\\n                else if(canDrawHappen)\\n                    outcome[catpos][mousepos][moves]=0;\\n                else\\n                    outcome[catpos][mousepos][moves]=1;\\n            }\\n        }\\n        return outcome[catpos][mousepos][moves];\\n    }\\n    int catMouseGame(vector<vector<int>>& graph)\\n    {\\n        int n=graph.size();\\n        int limit=3*n;\\n        vector<vector<vector<int>>>outcome(n,vector<vector<int>>(n,vector<int>(limit+1,-1)));\\n        return dfs(graph,outcome,2,1,1,limit);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n    int dfs(vector<vector<int>>& graph, vector<vector<vector<int>>>& outcome, int catpos, int mousepos, int moves, int limit)\\n    {\\n        if(mousepos==0)\\n            return 1;\\n        if(catpos==mousepos)\\n            return 2;\\n        if(moves>limit)\\n            return 0;\\n        if(outcome[catpos][mousepos][moves]==-1)\\n        {\\n            if(moves%2)//mouse turn\\n            {\\n                int winner=-1;\\n                bool canMouseWin=false;\\n                bool canDrawHappen=false;\\n                for(auto pos:graph[mousepos])\\n                {\\n                    winner=dfs(graph,outcome,catpos,pos,moves+1,limit);\\n                    if(winner==1)\\n                    {\\n                        canMouseWin=true;\\n                        break;\\n                    }\\n                    else if(winner==0)\\n                        canDrawHappen=true;\\n                }\\n                if(canMouseWin)\\n                    outcome[catpos][mousepos][moves]=1;\\n                else if(canDrawHappen)\\n                    outcome[catpos][mousepos][moves]=0;\\n                else\\n                    outcome[catpos][mousepos][moves]=2;\\n            }\\n            else//cat turn\\n            {\\n                int winner=-1;\\n                bool canCatWin=false;\\n                bool canDrawHappen=false;\\n                for(auto pos:graph[catpos])\\n                {\\n                    if(pos==0)\\n                        continue;\\n                    winner=dfs(graph,outcome,pos,mousepos,moves+1,limit);\\n                    if(winner==2)\\n                    {\\n                        canCatWin=true;\\n                        break;\\n                    }\\n                    else if(winner==0)\\n                        canDrawHappen=true;\\n                }\\n                if(canCatWin)\\n                    outcome[catpos][mousepos][moves]=2;\\n                else if(canDrawHappen)\\n                    outcome[catpos][mousepos][moves]=0;\\n                else\\n                    outcome[catpos][mousepos][moves]=1;\\n            }\\n        }\\n        return outcome[catpos][mousepos][moves];\\n    }\\n    int catMouseGame(vector<vector<int>>& graph)\\n    {\\n        int n=graph.size();\\n        int limit=3*n;\\n        vector<vector<vector<int>>>outcome(n,vector<vector<int>>(n,vector<int>(limit+1,-1)));\\n        return dfs(graph,outcome,2,1,1,limit);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 846639,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    struct node // turn => who bring the game to this state,turn=0 => mouse else cat \\n    {\\n       int x,y,turn ;  \\n    };\\n    // 0-M , 1-C\\n    int N=51 ;\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        queue<node>q ;\\n        node noob ;\\n        int n=graph.size() ;\\n        \\n        \\n        int vis[n][n][2],deg[n][n][2] ;\\n        \\n        for(int i=0;i<n;i++) for(int j=0;j<n;j++) for(int k=0;k<2;k++) \\n        { vis[i][j][k]=-1 ;\\n          if(k==1) deg[i][j][k]=graph[i].size(); // mouse can go anywhere\\n          else // cat can not go to 0\\n          { \\n              deg[i][j][k]=graph[j].size() ;\\n              int f=0 ;\\n              \\n              for(int l:graph[j])\\n              {\\n                  if(l==0) f=1 ;\\n              }\\n              \\n              if(f)\\n              deg[i][j][k]-- ;\\n          }\\n        }\\n        \\n        \\n        \\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            noob.x=0 ;\\n            noob.y=i ;\\n            noob.turn=0 ;\\n            \\n            vis[noob.x][noob.y][noob.turn]=1 ; // mouse wins if mouse enters 0 \\n            \\n            q.push(noob) ;\\n            \\n            noob.x=i ;\\n            noob.y=i ;\\n            noob.turn=1 ;\\n            \\n            vis[noob.x][noob.y][noob.turn]=2 ; // cat wins if cat reaches the position of mouse\\n            q.push(noob) ;\\n            \\n            noob.x=i ;\\n            noob.y=i ;\\n            noob.turn=0 ;\\n            \\n            vis[noob.x][noob.y][noob.turn]=2 ; // cat wins if mose reahes the position of cat \\n            q.push(noob) ;\\n        }\\n        \\n        node req ; req.x=1 ; req.y=2 ; req.turn=1 ;\\n        node nxt ;\\n        \\n      \\n        \\n        while(!q.empty())\\n        {\\n            noob=q.front() ; q.pop() ;\\n            \\n            if(noob.x==req.x&&noob.y==req.y&&noob.turn==req.turn) break ;\\n            \\n            if(noob.turn==0)\\n            {\\n                for(int j:graph[noob.x])\\n                {\\n                    nxt.x=j ;\\n                    nxt.y=noob.y ;\\n                    nxt.turn=1 ;\\n                    \\n                    if(vis[nxt.x][nxt.y][nxt.turn]==-1)\\n                    {\\n                           if(vis[noob.x][noob.y][noob.turn]==1)\\n                         {\\n                              vis[nxt.x][nxt.y][nxt.turn]=1 ;\\n                               q.push(nxt) ;\\n                        }\\n                        else\\n                        {\\n                            deg[nxt.x][nxt.y][nxt.turn]-- ;\\n                           if(deg[nxt.x][nxt.y][nxt.turn]==0)\\n                           {\\n                               vis[nxt.x][nxt.y][nxt.turn]=2 ;\\n                               q.push(nxt) ;\\n                           }\\n                        }\\n                    }\\n                    \\n    \\n                }\\n            }\\n            else\\n            {\\n                for(int j:graph[noob.y])\\n                {\\n                    nxt.x=noob.x ;\\n                    nxt.y=j ;\\n                    nxt.turn=0 ;\\n                    \\n                   if(vis[nxt.x][nxt.y][nxt.turn]==-1&&nxt.y!=0)\\n                    {\\n                         if(vis[noob.x][noob.y][noob.turn]==2)\\n                        {\\n                        vis[nxt.x][nxt.y][nxt.turn]=2 ;\\n                        q.push(nxt) ;\\n                        }\\n                       else\\n                       {\\n                           deg[nxt.x][nxt.y][nxt.turn]-- ;\\n                           if(deg[nxt.x][nxt.y][nxt.turn]==0)\\n                           {\\n                               vis[nxt.x][nxt.y][nxt.turn]=1 ;\\n                               q.push(nxt) ;\\n                           }\\n                       }\\n                    }\\n                    \\n                    \\n                }\\n            }\\n            \\n            \\n        }\\n        \\n        \\n        if(vis[1][2][1]==-1) return 0 ;\\n        \\n        else return vis[1][2][1] ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    struct node // turn => who bring the game to this state,turn=0 => mouse else cat \\n    {\\n       int x,y,turn ;  \\n    };\\n    // 0-M , 1-C\\n    int N=51 ;\\n    int catMouseGame(vector<vector<int>>& graph) {\\n        queue<node>q ;\\n        node noob ;\\n        int n=graph.size() ;\\n        \\n        \\n        int vis[n][n][2],deg[n][n][2] ;\\n        \\n        for(int i=0;i<n;i++) for(int j=0;j<n;j++) for(int k=0;k<2;k++) \\n        { vis[i][j][k]=-1 ;\\n          if(k==1) deg[i][j][k]=graph[i].size(); // mouse can go anywhere\\n          else // cat can not go to 0\\n          { \\n              deg[i][j][k]=graph[j].size() ;\\n              int f=0 ;\\n              \\n              for(int l:graph[j])\\n              {\\n                  if(l==0) f=1 ;\\n              }\\n              \\n              if(f)\\n              deg[i][j][k]-- ;\\n          }\\n        }\\n        \\n        \\n        \\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            noob.x=0 ;\\n            noob.y=i ;\\n            noob.turn=0 ;\\n            \\n            vis[noob.x][noob.y][noob.turn]=1 ; // mouse wins if mouse enters 0 \\n            \\n            q.push(noob) ;\\n            \\n            noob.x=i ;\\n            noob.y=i ;\\n            noob.turn=1 ;\\n            \\n            vis[noob.x][noob.y][noob.turn]=2 ; // cat wins if cat reaches the position of mouse\\n            q.push(noob) ;\\n            \\n            noob.x=i ;\\n            noob.y=i ;\\n            noob.turn=0 ;\\n            \\n            vis[noob.x][noob.y][noob.turn]=2 ; // cat wins if mose reahes the position of cat \\n            q.push(noob) ;\\n        }\\n        \\n        node req ; req.x=1 ; req.y=2 ; req.turn=1 ;\\n        node nxt ;\\n        \\n      \\n        \\n        while(!q.empty())\\n        {\\n            noob=q.front() ; q.pop() ;\\n            \\n            if(noob.x==req.x&&noob.y==req.y&&noob.turn==req.turn) break ;\\n            \\n            if(noob.turn==0)\\n            {\\n                for(int j:graph[noob.x])\\n                {\\n                    nxt.x=j ;\\n                    nxt.y=noob.y ;\\n                    nxt.turn=1 ;\\n                    \\n                    if(vis[nxt.x][nxt.y][nxt.turn]==-1)\\n                    {\\n                           if(vis[noob.x][noob.y][noob.turn]==1)\\n                         {\\n                              vis[nxt.x][nxt.y][nxt.turn]=1 ;\\n                               q.push(nxt) ;\\n                        }\\n                        else\\n                        {\\n                            deg[nxt.x][nxt.y][nxt.turn]-- ;\\n                           if(deg[nxt.x][nxt.y][nxt.turn]==0)\\n                           {\\n                               vis[nxt.x][nxt.y][nxt.turn]=2 ;\\n                               q.push(nxt) ;\\n                           }\\n                        }\\n                    }\\n                    \\n    \\n                }\\n            }\\n            else\\n            {\\n                for(int j:graph[noob.y])\\n                {\\n                    nxt.x=noob.x ;\\n                    nxt.y=j ;\\n                    nxt.turn=0 ;\\n                    \\n                   if(vis[nxt.x][nxt.y][nxt.turn]==-1&&nxt.y!=0)\\n                    {\\n                         if(vis[noob.x][noob.y][noob.turn]==2)\\n                        {\\n                        vis[nxt.x][nxt.y][nxt.turn]=2 ;\\n                        q.push(nxt) ;\\n                        }\\n                       else\\n                       {\\n                           deg[nxt.x][nxt.y][nxt.turn]-- ;\\n                           if(deg[nxt.x][nxt.y][nxt.turn]==0)\\n                           {\\n                               vis[nxt.x][nxt.y][nxt.turn]=1 ;\\n                               q.push(nxt) ;\\n                           }\\n                       }\\n                    }\\n                    \\n                    \\n                }\\n            }\\n            \\n            \\n        }\\n        \\n        \\n        if(vis[1][2][1]==-1) return 0 ;\\n        \\n        else return vis[1][2][1] ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564552,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "If I see this problem during an interview, it should imply that the interviewer doesn\\'t want to hire me for some reason. So I\\'d better say goodbye and gently close the door..."
                    },
                    {
                        "username": "overattribution",
                        "content": "**Edit**: Thanks [@lmiaoj](https://leetcode.com/lmiaoj)  for the help. I found the errors with my logic:\\n\\n1) A draw is more optimal than a loss.\\n2) Repeating positions only counts as a draw if **both** cat and mouse repeat their previous positions. The cat cannot force a draw simply by moving backwards unless it also causes the mouse to move backwards.\\n\\n**Original question:**\\n\\nI see two possible ways to move forward:\\n\\n![image](https://assets.leetcode.com/users/overattribution/image_1538620324.png)\\n\\nShouldn\\'t the Mouse win both of these routes?\\n\\nIs the Cat super immature? Does she step on a previous location just to the spite the Mouse? Why is the example said to be a draw?"
                    },
                    {
                        "username": "0icy",
                        "content": "cat should move to the best possible position and in your situation it is not happening"
                    },
                    {
                        "username": "hsiaoluw",
                        "content": "You can prove that for non-draw cases , we can always find a way for cat or mouse to win with 2n state.\\nWithout losing generality, suppose the mouse wins, and the depth of the state trace is larger than 2n.\\nThen, there exists at least one node X that he mouse visits twice, which also means the mouse runs on a cycle during time t1 to t2.\\n\\nt1 state: (X, c1) ---> t2 state: (X,, c2) ---> ending state (0, Y)\\nThrough time t1 to t2, the cat is moving from c1 -> c2 path.\\n\\nif (X,c1)->(X,c2)->(0,Y) is the only path for the mouse to win,\\nthen on time t2, the cat can move on the path from c2->c1, which results in a draw situation and this violates our assumption mouse wins .\\n\\nAs a result (X, c1)->(X,c2)->(0, Y) should not be the only path, which means there exist at least one path for the mouse to win without cycles.\\nTherefore the depth of the states is 2*n."
                    },
                    {
                        "username": "rani23",
                        "content": "Why is the test case given in the question \\'DRAW\\'? \\nAccording to me, the mouse should win.\\nM: 1 -> 3\\nC: 2 -> 4\\nM: 3 -> 5\\nC: 4 -> 3\\nM: 5 -> 0\\nPlease explain where my understanding is wrong. TIA."
                    },
                    {
                        "username": "jeesoklee",
                        "content": "cat must go to 5 on the first move. it must do its best to be in between the mouse and the hole"
                    },
                    {
                        "username": "kashish242",
                        "content": "minimum post length is 12 characters. hence writing this. all the best."
                    },
                    {
                        "username": "mksmanjit",
                        "content": "Hi Team,\\n\\nI facing difficulty understanding the draw case(0).\\nlike Example given in the description.\\n[[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]\\nThe output of this problem is draw(0).\\n\\nI did not get this.\\nAs mentioned Mouse start from Node 1 and Cat Start from Node 2, and mouse will start first.\\n\\n\\nSo below are step i took.\\nOption 1:\\n1) Mouse move to node 3.\\n2) Cat move to node 5.\\n3) Mouse Move to Node 5 ( here you can say mouse and cat are on the same node so Cat win, but this point is not described in description, if cat reach the Mouse node then cat win, in this case mouse is going to the Cat node).\\n4) Mouse reaches Node 0\\n\\nOutput: Mouse win\\n\\nOption 2:\\n1) Mouse move to node 3.\\n2) Cat move to node 5.\\n3) Mouse Move to Node 4.\\n4) Cat move to node 3\\n5) Mouse Move to Node 2.\\n6) Cat Move to the Node 1.\\n7) Mouse Move to Node 0.\\n\\nOutput: Mouse win\\n\\nOption 3:\\n1) Mouse move to node 3.\\n2) Cat move to node 4.\\n3) Mouse Move to Node 5.\\n4) Cat move to node 3\\n5) Mouse Move to Node 0\\n\\nOutput: Mouse win\\n\\nCan some one please explain what i am missing in the description because of that i am unable to reach to the correct output, which is draw in this case.\\n\\nThanks in advance.\\n"
                    },
                    {
                        "username": "steffi00203",
                        "content": "Hello, I submitted my code, but it is failing for test case \\'{{3, 4}, {3, 5}, {3, 6}, {0, 1, 2}, {0, 5, 6}, {1, 4}, {2, 4}}\\' with expecetd output of 0.\\nCan someone help me understand how is it a draw?\\n\\nThanks"
                    },
                    {
                        "username": "yctung",
                        "content": "I know cat can\\'t chase mouse to dead in this case, but can can easily go back to the same position to make the draw, right?"
                    },
                    {
                        "username": "bw02020202",
                        "content": "Could someone clarify: \\nWDYM by : If ever a position is repeated (i.e., the players are in the same position as a previous turn, and it is the same player\\'s turn to move), the game is a draw.\\n\\nInterpretation 1:\\nstep i, mouse turn, they are at (x, y)\\nstep j > i, mouse turn, they are at (x, y) again.\\n\\nInterpretation 2\\nstep i, mouse turn, mouse at x\\nstep j > i, mouse turn, mouse at x again.\\n\\nInterpretation 3\\nstep i, mouse turn, mouse at x\\nstep j, whoever\\'s turn, cat at y\\nstep k, where k > i, k > j, mouse turn, mouse cat are at (x,y)\\n\\nInterpretation 4\\nstep i, mouse turn, mouse at x, where either mouse or cat was at x atep some step j < i and step j is also mouse turn"
                    },
                    {
                        "username": "Gautam_G",
                        "content": "Interpretation 1 is correct"
                    },
                    {
                        "username": "cracy",
                        "content": "This should be a direct mouse win case, right? The solution still gave 0."
                    }
                ]
            },
            {
                "id": 1566100,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "If I see this problem during an interview, it should imply that the interviewer doesn\\'t want to hire me for some reason. So I\\'d better say goodbye and gently close the door..."
                    },
                    {
                        "username": "overattribution",
                        "content": "**Edit**: Thanks [@lmiaoj](https://leetcode.com/lmiaoj)  for the help. I found the errors with my logic:\\n\\n1) A draw is more optimal than a loss.\\n2) Repeating positions only counts as a draw if **both** cat and mouse repeat their previous positions. The cat cannot force a draw simply by moving backwards unless it also causes the mouse to move backwards.\\n\\n**Original question:**\\n\\nI see two possible ways to move forward:\\n\\n![image](https://assets.leetcode.com/users/overattribution/image_1538620324.png)\\n\\nShouldn\\'t the Mouse win both of these routes?\\n\\nIs the Cat super immature? Does she step on a previous location just to the spite the Mouse? Why is the example said to be a draw?"
                    },
                    {
                        "username": "0icy",
                        "content": "cat should move to the best possible position and in your situation it is not happening"
                    },
                    {
                        "username": "hsiaoluw",
                        "content": "You can prove that for non-draw cases , we can always find a way for cat or mouse to win with 2n state.\\nWithout losing generality, suppose the mouse wins, and the depth of the state trace is larger than 2n.\\nThen, there exists at least one node X that he mouse visits twice, which also means the mouse runs on a cycle during time t1 to t2.\\n\\nt1 state: (X, c1) ---> t2 state: (X,, c2) ---> ending state (0, Y)\\nThrough time t1 to t2, the cat is moving from c1 -> c2 path.\\n\\nif (X,c1)->(X,c2)->(0,Y) is the only path for the mouse to win,\\nthen on time t2, the cat can move on the path from c2->c1, which results in a draw situation and this violates our assumption mouse wins .\\n\\nAs a result (X, c1)->(X,c2)->(0, Y) should not be the only path, which means there exist at least one path for the mouse to win without cycles.\\nTherefore the depth of the states is 2*n."
                    },
                    {
                        "username": "rani23",
                        "content": "Why is the test case given in the question \\'DRAW\\'? \\nAccording to me, the mouse should win.\\nM: 1 -> 3\\nC: 2 -> 4\\nM: 3 -> 5\\nC: 4 -> 3\\nM: 5 -> 0\\nPlease explain where my understanding is wrong. TIA."
                    },
                    {
                        "username": "jeesoklee",
                        "content": "cat must go to 5 on the first move. it must do its best to be in between the mouse and the hole"
                    },
                    {
                        "username": "kashish242",
                        "content": "minimum post length is 12 characters. hence writing this. all the best."
                    },
                    {
                        "username": "mksmanjit",
                        "content": "Hi Team,\\n\\nI facing difficulty understanding the draw case(0).\\nlike Example given in the description.\\n[[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]\\nThe output of this problem is draw(0).\\n\\nI did not get this.\\nAs mentioned Mouse start from Node 1 and Cat Start from Node 2, and mouse will start first.\\n\\n\\nSo below are step i took.\\nOption 1:\\n1) Mouse move to node 3.\\n2) Cat move to node 5.\\n3) Mouse Move to Node 5 ( here you can say mouse and cat are on the same node so Cat win, but this point is not described in description, if cat reach the Mouse node then cat win, in this case mouse is going to the Cat node).\\n4) Mouse reaches Node 0\\n\\nOutput: Mouse win\\n\\nOption 2:\\n1) Mouse move to node 3.\\n2) Cat move to node 5.\\n3) Mouse Move to Node 4.\\n4) Cat move to node 3\\n5) Mouse Move to Node 2.\\n6) Cat Move to the Node 1.\\n7) Mouse Move to Node 0.\\n\\nOutput: Mouse win\\n\\nOption 3:\\n1) Mouse move to node 3.\\n2) Cat move to node 4.\\n3) Mouse Move to Node 5.\\n4) Cat move to node 3\\n5) Mouse Move to Node 0\\n\\nOutput: Mouse win\\n\\nCan some one please explain what i am missing in the description because of that i am unable to reach to the correct output, which is draw in this case.\\n\\nThanks in advance.\\n"
                    },
                    {
                        "username": "steffi00203",
                        "content": "Hello, I submitted my code, but it is failing for test case \\'{{3, 4}, {3, 5}, {3, 6}, {0, 1, 2}, {0, 5, 6}, {1, 4}, {2, 4}}\\' with expecetd output of 0.\\nCan someone help me understand how is it a draw?\\n\\nThanks"
                    },
                    {
                        "username": "yctung",
                        "content": "I know cat can\\'t chase mouse to dead in this case, but can can easily go back to the same position to make the draw, right?"
                    },
                    {
                        "username": "bw02020202",
                        "content": "Could someone clarify: \\nWDYM by : If ever a position is repeated (i.e., the players are in the same position as a previous turn, and it is the same player\\'s turn to move), the game is a draw.\\n\\nInterpretation 1:\\nstep i, mouse turn, they are at (x, y)\\nstep j > i, mouse turn, they are at (x, y) again.\\n\\nInterpretation 2\\nstep i, mouse turn, mouse at x\\nstep j > i, mouse turn, mouse at x again.\\n\\nInterpretation 3\\nstep i, mouse turn, mouse at x\\nstep j, whoever\\'s turn, cat at y\\nstep k, where k > i, k > j, mouse turn, mouse cat are at (x,y)\\n\\nInterpretation 4\\nstep i, mouse turn, mouse at x, where either mouse or cat was at x atep some step j < i and step j is also mouse turn"
                    },
                    {
                        "username": "Gautam_G",
                        "content": "Interpretation 1 is correct"
                    },
                    {
                        "username": "cracy",
                        "content": "This should be a direct mouse win case, right? The solution still gave 0."
                    }
                ]
            },
            {
                "id": 1567693,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "If I see this problem during an interview, it should imply that the interviewer doesn\\'t want to hire me for some reason. So I\\'d better say goodbye and gently close the door..."
                    },
                    {
                        "username": "overattribution",
                        "content": "**Edit**: Thanks [@lmiaoj](https://leetcode.com/lmiaoj)  for the help. I found the errors with my logic:\\n\\n1) A draw is more optimal than a loss.\\n2) Repeating positions only counts as a draw if **both** cat and mouse repeat their previous positions. The cat cannot force a draw simply by moving backwards unless it also causes the mouse to move backwards.\\n\\n**Original question:**\\n\\nI see two possible ways to move forward:\\n\\n![image](https://assets.leetcode.com/users/overattribution/image_1538620324.png)\\n\\nShouldn\\'t the Mouse win both of these routes?\\n\\nIs the Cat super immature? Does she step on a previous location just to the spite the Mouse? Why is the example said to be a draw?"
                    },
                    {
                        "username": "0icy",
                        "content": "cat should move to the best possible position and in your situation it is not happening"
                    },
                    {
                        "username": "hsiaoluw",
                        "content": "You can prove that for non-draw cases , we can always find a way for cat or mouse to win with 2n state.\\nWithout losing generality, suppose the mouse wins, and the depth of the state trace is larger than 2n.\\nThen, there exists at least one node X that he mouse visits twice, which also means the mouse runs on a cycle during time t1 to t2.\\n\\nt1 state: (X, c1) ---> t2 state: (X,, c2) ---> ending state (0, Y)\\nThrough time t1 to t2, the cat is moving from c1 -> c2 path.\\n\\nif (X,c1)->(X,c2)->(0,Y) is the only path for the mouse to win,\\nthen on time t2, the cat can move on the path from c2->c1, which results in a draw situation and this violates our assumption mouse wins .\\n\\nAs a result (X, c1)->(X,c2)->(0, Y) should not be the only path, which means there exist at least one path for the mouse to win without cycles.\\nTherefore the depth of the states is 2*n."
                    },
                    {
                        "username": "rani23",
                        "content": "Why is the test case given in the question \\'DRAW\\'? \\nAccording to me, the mouse should win.\\nM: 1 -> 3\\nC: 2 -> 4\\nM: 3 -> 5\\nC: 4 -> 3\\nM: 5 -> 0\\nPlease explain where my understanding is wrong. TIA."
                    },
                    {
                        "username": "jeesoklee",
                        "content": "cat must go to 5 on the first move. it must do its best to be in between the mouse and the hole"
                    },
                    {
                        "username": "kashish242",
                        "content": "minimum post length is 12 characters. hence writing this. all the best."
                    },
                    {
                        "username": "mksmanjit",
                        "content": "Hi Team,\\n\\nI facing difficulty understanding the draw case(0).\\nlike Example given in the description.\\n[[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]\\nThe output of this problem is draw(0).\\n\\nI did not get this.\\nAs mentioned Mouse start from Node 1 and Cat Start from Node 2, and mouse will start first.\\n\\n\\nSo below are step i took.\\nOption 1:\\n1) Mouse move to node 3.\\n2) Cat move to node 5.\\n3) Mouse Move to Node 5 ( here you can say mouse and cat are on the same node so Cat win, but this point is not described in description, if cat reach the Mouse node then cat win, in this case mouse is going to the Cat node).\\n4) Mouse reaches Node 0\\n\\nOutput: Mouse win\\n\\nOption 2:\\n1) Mouse move to node 3.\\n2) Cat move to node 5.\\n3) Mouse Move to Node 4.\\n4) Cat move to node 3\\n5) Mouse Move to Node 2.\\n6) Cat Move to the Node 1.\\n7) Mouse Move to Node 0.\\n\\nOutput: Mouse win\\n\\nOption 3:\\n1) Mouse move to node 3.\\n2) Cat move to node 4.\\n3) Mouse Move to Node 5.\\n4) Cat move to node 3\\n5) Mouse Move to Node 0\\n\\nOutput: Mouse win\\n\\nCan some one please explain what i am missing in the description because of that i am unable to reach to the correct output, which is draw in this case.\\n\\nThanks in advance.\\n"
                    },
                    {
                        "username": "steffi00203",
                        "content": "Hello, I submitted my code, but it is failing for test case \\'{{3, 4}, {3, 5}, {3, 6}, {0, 1, 2}, {0, 5, 6}, {1, 4}, {2, 4}}\\' with expecetd output of 0.\\nCan someone help me understand how is it a draw?\\n\\nThanks"
                    },
                    {
                        "username": "yctung",
                        "content": "I know cat can\\'t chase mouse to dead in this case, but can can easily go back to the same position to make the draw, right?"
                    },
                    {
                        "username": "bw02020202",
                        "content": "Could someone clarify: \\nWDYM by : If ever a position is repeated (i.e., the players are in the same position as a previous turn, and it is the same player\\'s turn to move), the game is a draw.\\n\\nInterpretation 1:\\nstep i, mouse turn, they are at (x, y)\\nstep j > i, mouse turn, they are at (x, y) again.\\n\\nInterpretation 2\\nstep i, mouse turn, mouse at x\\nstep j > i, mouse turn, mouse at x again.\\n\\nInterpretation 3\\nstep i, mouse turn, mouse at x\\nstep j, whoever\\'s turn, cat at y\\nstep k, where k > i, k > j, mouse turn, mouse cat are at (x,y)\\n\\nInterpretation 4\\nstep i, mouse turn, mouse at x, where either mouse or cat was at x atep some step j < i and step j is also mouse turn"
                    },
                    {
                        "username": "Gautam_G",
                        "content": "Interpretation 1 is correct"
                    },
                    {
                        "username": "cracy",
                        "content": "This should be a direct mouse win case, right? The solution still gave 0."
                    }
                ]
            },
            {
                "id": 1569697,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "If I see this problem during an interview, it should imply that the interviewer doesn\\'t want to hire me for some reason. So I\\'d better say goodbye and gently close the door..."
                    },
                    {
                        "username": "overattribution",
                        "content": "**Edit**: Thanks [@lmiaoj](https://leetcode.com/lmiaoj)  for the help. I found the errors with my logic:\\n\\n1) A draw is more optimal than a loss.\\n2) Repeating positions only counts as a draw if **both** cat and mouse repeat their previous positions. The cat cannot force a draw simply by moving backwards unless it also causes the mouse to move backwards.\\n\\n**Original question:**\\n\\nI see two possible ways to move forward:\\n\\n![image](https://assets.leetcode.com/users/overattribution/image_1538620324.png)\\n\\nShouldn\\'t the Mouse win both of these routes?\\n\\nIs the Cat super immature? Does she step on a previous location just to the spite the Mouse? Why is the example said to be a draw?"
                    },
                    {
                        "username": "0icy",
                        "content": "cat should move to the best possible position and in your situation it is not happening"
                    },
                    {
                        "username": "hsiaoluw",
                        "content": "You can prove that for non-draw cases , we can always find a way for cat or mouse to win with 2n state.\\nWithout losing generality, suppose the mouse wins, and the depth of the state trace is larger than 2n.\\nThen, there exists at least one node X that he mouse visits twice, which also means the mouse runs on a cycle during time t1 to t2.\\n\\nt1 state: (X, c1) ---> t2 state: (X,, c2) ---> ending state (0, Y)\\nThrough time t1 to t2, the cat is moving from c1 -> c2 path.\\n\\nif (X,c1)->(X,c2)->(0,Y) is the only path for the mouse to win,\\nthen on time t2, the cat can move on the path from c2->c1, which results in a draw situation and this violates our assumption mouse wins .\\n\\nAs a result (X, c1)->(X,c2)->(0, Y) should not be the only path, which means there exist at least one path for the mouse to win without cycles.\\nTherefore the depth of the states is 2*n."
                    },
                    {
                        "username": "rani23",
                        "content": "Why is the test case given in the question \\'DRAW\\'? \\nAccording to me, the mouse should win.\\nM: 1 -> 3\\nC: 2 -> 4\\nM: 3 -> 5\\nC: 4 -> 3\\nM: 5 -> 0\\nPlease explain where my understanding is wrong. TIA."
                    },
                    {
                        "username": "jeesoklee",
                        "content": "cat must go to 5 on the first move. it must do its best to be in between the mouse and the hole"
                    },
                    {
                        "username": "kashish242",
                        "content": "minimum post length is 12 characters. hence writing this. all the best."
                    },
                    {
                        "username": "mksmanjit",
                        "content": "Hi Team,\\n\\nI facing difficulty understanding the draw case(0).\\nlike Example given in the description.\\n[[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]\\nThe output of this problem is draw(0).\\n\\nI did not get this.\\nAs mentioned Mouse start from Node 1 and Cat Start from Node 2, and mouse will start first.\\n\\n\\nSo below are step i took.\\nOption 1:\\n1) Mouse move to node 3.\\n2) Cat move to node 5.\\n3) Mouse Move to Node 5 ( here you can say mouse and cat are on the same node so Cat win, but this point is not described in description, if cat reach the Mouse node then cat win, in this case mouse is going to the Cat node).\\n4) Mouse reaches Node 0\\n\\nOutput: Mouse win\\n\\nOption 2:\\n1) Mouse move to node 3.\\n2) Cat move to node 5.\\n3) Mouse Move to Node 4.\\n4) Cat move to node 3\\n5) Mouse Move to Node 2.\\n6) Cat Move to the Node 1.\\n7) Mouse Move to Node 0.\\n\\nOutput: Mouse win\\n\\nOption 3:\\n1) Mouse move to node 3.\\n2) Cat move to node 4.\\n3) Mouse Move to Node 5.\\n4) Cat move to node 3\\n5) Mouse Move to Node 0\\n\\nOutput: Mouse win\\n\\nCan some one please explain what i am missing in the description because of that i am unable to reach to the correct output, which is draw in this case.\\n\\nThanks in advance.\\n"
                    },
                    {
                        "username": "steffi00203",
                        "content": "Hello, I submitted my code, but it is failing for test case \\'{{3, 4}, {3, 5}, {3, 6}, {0, 1, 2}, {0, 5, 6}, {1, 4}, {2, 4}}\\' with expecetd output of 0.\\nCan someone help me understand how is it a draw?\\n\\nThanks"
                    },
                    {
                        "username": "yctung",
                        "content": "I know cat can\\'t chase mouse to dead in this case, but can can easily go back to the same position to make the draw, right?"
                    },
                    {
                        "username": "bw02020202",
                        "content": "Could someone clarify: \\nWDYM by : If ever a position is repeated (i.e., the players are in the same position as a previous turn, and it is the same player\\'s turn to move), the game is a draw.\\n\\nInterpretation 1:\\nstep i, mouse turn, they are at (x, y)\\nstep j > i, mouse turn, they are at (x, y) again.\\n\\nInterpretation 2\\nstep i, mouse turn, mouse at x\\nstep j > i, mouse turn, mouse at x again.\\n\\nInterpretation 3\\nstep i, mouse turn, mouse at x\\nstep j, whoever\\'s turn, cat at y\\nstep k, where k > i, k > j, mouse turn, mouse cat are at (x,y)\\n\\nInterpretation 4\\nstep i, mouse turn, mouse at x, where either mouse or cat was at x atep some step j < i and step j is also mouse turn"
                    },
                    {
                        "username": "Gautam_G",
                        "content": "Interpretation 1 is correct"
                    },
                    {
                        "username": "cracy",
                        "content": "This should be a direct mouse win case, right? The solution still gave 0."
                    }
                ]
            },
            {
                "id": 1576760,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "If I see this problem during an interview, it should imply that the interviewer doesn\\'t want to hire me for some reason. So I\\'d better say goodbye and gently close the door..."
                    },
                    {
                        "username": "overattribution",
                        "content": "**Edit**: Thanks [@lmiaoj](https://leetcode.com/lmiaoj)  for the help. I found the errors with my logic:\\n\\n1) A draw is more optimal than a loss.\\n2) Repeating positions only counts as a draw if **both** cat and mouse repeat their previous positions. The cat cannot force a draw simply by moving backwards unless it also causes the mouse to move backwards.\\n\\n**Original question:**\\n\\nI see two possible ways to move forward:\\n\\n![image](https://assets.leetcode.com/users/overattribution/image_1538620324.png)\\n\\nShouldn\\'t the Mouse win both of these routes?\\n\\nIs the Cat super immature? Does she step on a previous location just to the spite the Mouse? Why is the example said to be a draw?"
                    },
                    {
                        "username": "0icy",
                        "content": "cat should move to the best possible position and in your situation it is not happening"
                    },
                    {
                        "username": "hsiaoluw",
                        "content": "You can prove that for non-draw cases , we can always find a way for cat or mouse to win with 2n state.\\nWithout losing generality, suppose the mouse wins, and the depth of the state trace is larger than 2n.\\nThen, there exists at least one node X that he mouse visits twice, which also means the mouse runs on a cycle during time t1 to t2.\\n\\nt1 state: (X, c1) ---> t2 state: (X,, c2) ---> ending state (0, Y)\\nThrough time t1 to t2, the cat is moving from c1 -> c2 path.\\n\\nif (X,c1)->(X,c2)->(0,Y) is the only path for the mouse to win,\\nthen on time t2, the cat can move on the path from c2->c1, which results in a draw situation and this violates our assumption mouse wins .\\n\\nAs a result (X, c1)->(X,c2)->(0, Y) should not be the only path, which means there exist at least one path for the mouse to win without cycles.\\nTherefore the depth of the states is 2*n."
                    },
                    {
                        "username": "rani23",
                        "content": "Why is the test case given in the question \\'DRAW\\'? \\nAccording to me, the mouse should win.\\nM: 1 -> 3\\nC: 2 -> 4\\nM: 3 -> 5\\nC: 4 -> 3\\nM: 5 -> 0\\nPlease explain where my understanding is wrong. TIA."
                    },
                    {
                        "username": "jeesoklee",
                        "content": "cat must go to 5 on the first move. it must do its best to be in between the mouse and the hole"
                    },
                    {
                        "username": "kashish242",
                        "content": "minimum post length is 12 characters. hence writing this. all the best."
                    },
                    {
                        "username": "mksmanjit",
                        "content": "Hi Team,\\n\\nI facing difficulty understanding the draw case(0).\\nlike Example given in the description.\\n[[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]\\nThe output of this problem is draw(0).\\n\\nI did not get this.\\nAs mentioned Mouse start from Node 1 and Cat Start from Node 2, and mouse will start first.\\n\\n\\nSo below are step i took.\\nOption 1:\\n1) Mouse move to node 3.\\n2) Cat move to node 5.\\n3) Mouse Move to Node 5 ( here you can say mouse and cat are on the same node so Cat win, but this point is not described in description, if cat reach the Mouse node then cat win, in this case mouse is going to the Cat node).\\n4) Mouse reaches Node 0\\n\\nOutput: Mouse win\\n\\nOption 2:\\n1) Mouse move to node 3.\\n2) Cat move to node 5.\\n3) Mouse Move to Node 4.\\n4) Cat move to node 3\\n5) Mouse Move to Node 2.\\n6) Cat Move to the Node 1.\\n7) Mouse Move to Node 0.\\n\\nOutput: Mouse win\\n\\nOption 3:\\n1) Mouse move to node 3.\\n2) Cat move to node 4.\\n3) Mouse Move to Node 5.\\n4) Cat move to node 3\\n5) Mouse Move to Node 0\\n\\nOutput: Mouse win\\n\\nCan some one please explain what i am missing in the description because of that i am unable to reach to the correct output, which is draw in this case.\\n\\nThanks in advance.\\n"
                    },
                    {
                        "username": "steffi00203",
                        "content": "Hello, I submitted my code, but it is failing for test case \\'{{3, 4}, {3, 5}, {3, 6}, {0, 1, 2}, {0, 5, 6}, {1, 4}, {2, 4}}\\' with expecetd output of 0.\\nCan someone help me understand how is it a draw?\\n\\nThanks"
                    },
                    {
                        "username": "yctung",
                        "content": "I know cat can\\'t chase mouse to dead in this case, but can can easily go back to the same position to make the draw, right?"
                    },
                    {
                        "username": "bw02020202",
                        "content": "Could someone clarify: \\nWDYM by : If ever a position is repeated (i.e., the players are in the same position as a previous turn, and it is the same player\\'s turn to move), the game is a draw.\\n\\nInterpretation 1:\\nstep i, mouse turn, they are at (x, y)\\nstep j > i, mouse turn, they are at (x, y) again.\\n\\nInterpretation 2\\nstep i, mouse turn, mouse at x\\nstep j > i, mouse turn, mouse at x again.\\n\\nInterpretation 3\\nstep i, mouse turn, mouse at x\\nstep j, whoever\\'s turn, cat at y\\nstep k, where k > i, k > j, mouse turn, mouse cat are at (x,y)\\n\\nInterpretation 4\\nstep i, mouse turn, mouse at x, where either mouse or cat was at x atep some step j < i and step j is also mouse turn"
                    },
                    {
                        "username": "Gautam_G",
                        "content": "Interpretation 1 is correct"
                    },
                    {
                        "username": "cracy",
                        "content": "This should be a direct mouse win case, right? The solution still gave 0."
                    }
                ]
            },
            {
                "id": 1575645,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "If I see this problem during an interview, it should imply that the interviewer doesn\\'t want to hire me for some reason. So I\\'d better say goodbye and gently close the door..."
                    },
                    {
                        "username": "overattribution",
                        "content": "**Edit**: Thanks [@lmiaoj](https://leetcode.com/lmiaoj)  for the help. I found the errors with my logic:\\n\\n1) A draw is more optimal than a loss.\\n2) Repeating positions only counts as a draw if **both** cat and mouse repeat their previous positions. The cat cannot force a draw simply by moving backwards unless it also causes the mouse to move backwards.\\n\\n**Original question:**\\n\\nI see two possible ways to move forward:\\n\\n![image](https://assets.leetcode.com/users/overattribution/image_1538620324.png)\\n\\nShouldn\\'t the Mouse win both of these routes?\\n\\nIs the Cat super immature? Does she step on a previous location just to the spite the Mouse? Why is the example said to be a draw?"
                    },
                    {
                        "username": "0icy",
                        "content": "cat should move to the best possible position and in your situation it is not happening"
                    },
                    {
                        "username": "hsiaoluw",
                        "content": "You can prove that for non-draw cases , we can always find a way for cat or mouse to win with 2n state.\\nWithout losing generality, suppose the mouse wins, and the depth of the state trace is larger than 2n.\\nThen, there exists at least one node X that he mouse visits twice, which also means the mouse runs on a cycle during time t1 to t2.\\n\\nt1 state: (X, c1) ---> t2 state: (X,, c2) ---> ending state (0, Y)\\nThrough time t1 to t2, the cat is moving from c1 -> c2 path.\\n\\nif (X,c1)->(X,c2)->(0,Y) is the only path for the mouse to win,\\nthen on time t2, the cat can move on the path from c2->c1, which results in a draw situation and this violates our assumption mouse wins .\\n\\nAs a result (X, c1)->(X,c2)->(0, Y) should not be the only path, which means there exist at least one path for the mouse to win without cycles.\\nTherefore the depth of the states is 2*n."
                    },
                    {
                        "username": "rani23",
                        "content": "Why is the test case given in the question \\'DRAW\\'? \\nAccording to me, the mouse should win.\\nM: 1 -> 3\\nC: 2 -> 4\\nM: 3 -> 5\\nC: 4 -> 3\\nM: 5 -> 0\\nPlease explain where my understanding is wrong. TIA."
                    },
                    {
                        "username": "jeesoklee",
                        "content": "cat must go to 5 on the first move. it must do its best to be in between the mouse and the hole"
                    },
                    {
                        "username": "kashish242",
                        "content": "minimum post length is 12 characters. hence writing this. all the best."
                    },
                    {
                        "username": "mksmanjit",
                        "content": "Hi Team,\\n\\nI facing difficulty understanding the draw case(0).\\nlike Example given in the description.\\n[[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]\\nThe output of this problem is draw(0).\\n\\nI did not get this.\\nAs mentioned Mouse start from Node 1 and Cat Start from Node 2, and mouse will start first.\\n\\n\\nSo below are step i took.\\nOption 1:\\n1) Mouse move to node 3.\\n2) Cat move to node 5.\\n3) Mouse Move to Node 5 ( here you can say mouse and cat are on the same node so Cat win, but this point is not described in description, if cat reach the Mouse node then cat win, in this case mouse is going to the Cat node).\\n4) Mouse reaches Node 0\\n\\nOutput: Mouse win\\n\\nOption 2:\\n1) Mouse move to node 3.\\n2) Cat move to node 5.\\n3) Mouse Move to Node 4.\\n4) Cat move to node 3\\n5) Mouse Move to Node 2.\\n6) Cat Move to the Node 1.\\n7) Mouse Move to Node 0.\\n\\nOutput: Mouse win\\n\\nOption 3:\\n1) Mouse move to node 3.\\n2) Cat move to node 4.\\n3) Mouse Move to Node 5.\\n4) Cat move to node 3\\n5) Mouse Move to Node 0\\n\\nOutput: Mouse win\\n\\nCan some one please explain what i am missing in the description because of that i am unable to reach to the correct output, which is draw in this case.\\n\\nThanks in advance.\\n"
                    },
                    {
                        "username": "steffi00203",
                        "content": "Hello, I submitted my code, but it is failing for test case \\'{{3, 4}, {3, 5}, {3, 6}, {0, 1, 2}, {0, 5, 6}, {1, 4}, {2, 4}}\\' with expecetd output of 0.\\nCan someone help me understand how is it a draw?\\n\\nThanks"
                    },
                    {
                        "username": "yctung",
                        "content": "I know cat can\\'t chase mouse to dead in this case, but can can easily go back to the same position to make the draw, right?"
                    },
                    {
                        "username": "bw02020202",
                        "content": "Could someone clarify: \\nWDYM by : If ever a position is repeated (i.e., the players are in the same position as a previous turn, and it is the same player\\'s turn to move), the game is a draw.\\n\\nInterpretation 1:\\nstep i, mouse turn, they are at (x, y)\\nstep j > i, mouse turn, they are at (x, y) again.\\n\\nInterpretation 2\\nstep i, mouse turn, mouse at x\\nstep j > i, mouse turn, mouse at x again.\\n\\nInterpretation 3\\nstep i, mouse turn, mouse at x\\nstep j, whoever\\'s turn, cat at y\\nstep k, where k > i, k > j, mouse turn, mouse cat are at (x,y)\\n\\nInterpretation 4\\nstep i, mouse turn, mouse at x, where either mouse or cat was at x atep some step j < i and step j is also mouse turn"
                    },
                    {
                        "username": "Gautam_G",
                        "content": "Interpretation 1 is correct"
                    },
                    {
                        "username": "cracy",
                        "content": "This should be a direct mouse win case, right? The solution still gave 0."
                    }
                ]
            },
            {
                "id": 1573615,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "If I see this problem during an interview, it should imply that the interviewer doesn\\'t want to hire me for some reason. So I\\'d better say goodbye and gently close the door..."
                    },
                    {
                        "username": "overattribution",
                        "content": "**Edit**: Thanks [@lmiaoj](https://leetcode.com/lmiaoj)  for the help. I found the errors with my logic:\\n\\n1) A draw is more optimal than a loss.\\n2) Repeating positions only counts as a draw if **both** cat and mouse repeat their previous positions. The cat cannot force a draw simply by moving backwards unless it also causes the mouse to move backwards.\\n\\n**Original question:**\\n\\nI see two possible ways to move forward:\\n\\n![image](https://assets.leetcode.com/users/overattribution/image_1538620324.png)\\n\\nShouldn\\'t the Mouse win both of these routes?\\n\\nIs the Cat super immature? Does she step on a previous location just to the spite the Mouse? Why is the example said to be a draw?"
                    },
                    {
                        "username": "0icy",
                        "content": "cat should move to the best possible position and in your situation it is not happening"
                    },
                    {
                        "username": "hsiaoluw",
                        "content": "You can prove that for non-draw cases , we can always find a way for cat or mouse to win with 2n state.\\nWithout losing generality, suppose the mouse wins, and the depth of the state trace is larger than 2n.\\nThen, there exists at least one node X that he mouse visits twice, which also means the mouse runs on a cycle during time t1 to t2.\\n\\nt1 state: (X, c1) ---> t2 state: (X,, c2) ---> ending state (0, Y)\\nThrough time t1 to t2, the cat is moving from c1 -> c2 path.\\n\\nif (X,c1)->(X,c2)->(0,Y) is the only path for the mouse to win,\\nthen on time t2, the cat can move on the path from c2->c1, which results in a draw situation and this violates our assumption mouse wins .\\n\\nAs a result (X, c1)->(X,c2)->(0, Y) should not be the only path, which means there exist at least one path for the mouse to win without cycles.\\nTherefore the depth of the states is 2*n."
                    },
                    {
                        "username": "rani23",
                        "content": "Why is the test case given in the question \\'DRAW\\'? \\nAccording to me, the mouse should win.\\nM: 1 -> 3\\nC: 2 -> 4\\nM: 3 -> 5\\nC: 4 -> 3\\nM: 5 -> 0\\nPlease explain where my understanding is wrong. TIA."
                    },
                    {
                        "username": "jeesoklee",
                        "content": "cat must go to 5 on the first move. it must do its best to be in between the mouse and the hole"
                    },
                    {
                        "username": "kashish242",
                        "content": "minimum post length is 12 characters. hence writing this. all the best."
                    },
                    {
                        "username": "mksmanjit",
                        "content": "Hi Team,\\n\\nI facing difficulty understanding the draw case(0).\\nlike Example given in the description.\\n[[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]\\nThe output of this problem is draw(0).\\n\\nI did not get this.\\nAs mentioned Mouse start from Node 1 and Cat Start from Node 2, and mouse will start first.\\n\\n\\nSo below are step i took.\\nOption 1:\\n1) Mouse move to node 3.\\n2) Cat move to node 5.\\n3) Mouse Move to Node 5 ( here you can say mouse and cat are on the same node so Cat win, but this point is not described in description, if cat reach the Mouse node then cat win, in this case mouse is going to the Cat node).\\n4) Mouse reaches Node 0\\n\\nOutput: Mouse win\\n\\nOption 2:\\n1) Mouse move to node 3.\\n2) Cat move to node 5.\\n3) Mouse Move to Node 4.\\n4) Cat move to node 3\\n5) Mouse Move to Node 2.\\n6) Cat Move to the Node 1.\\n7) Mouse Move to Node 0.\\n\\nOutput: Mouse win\\n\\nOption 3:\\n1) Mouse move to node 3.\\n2) Cat move to node 4.\\n3) Mouse Move to Node 5.\\n4) Cat move to node 3\\n5) Mouse Move to Node 0\\n\\nOutput: Mouse win\\n\\nCan some one please explain what i am missing in the description because of that i am unable to reach to the correct output, which is draw in this case.\\n\\nThanks in advance.\\n"
                    },
                    {
                        "username": "steffi00203",
                        "content": "Hello, I submitted my code, but it is failing for test case \\'{{3, 4}, {3, 5}, {3, 6}, {0, 1, 2}, {0, 5, 6}, {1, 4}, {2, 4}}\\' with expecetd output of 0.\\nCan someone help me understand how is it a draw?\\n\\nThanks"
                    },
                    {
                        "username": "yctung",
                        "content": "I know cat can\\'t chase mouse to dead in this case, but can can easily go back to the same position to make the draw, right?"
                    },
                    {
                        "username": "bw02020202",
                        "content": "Could someone clarify: \\nWDYM by : If ever a position is repeated (i.e., the players are in the same position as a previous turn, and it is the same player\\'s turn to move), the game is a draw.\\n\\nInterpretation 1:\\nstep i, mouse turn, they are at (x, y)\\nstep j > i, mouse turn, they are at (x, y) again.\\n\\nInterpretation 2\\nstep i, mouse turn, mouse at x\\nstep j > i, mouse turn, mouse at x again.\\n\\nInterpretation 3\\nstep i, mouse turn, mouse at x\\nstep j, whoever\\'s turn, cat at y\\nstep k, where k > i, k > j, mouse turn, mouse cat are at (x,y)\\n\\nInterpretation 4\\nstep i, mouse turn, mouse at x, where either mouse or cat was at x atep some step j < i and step j is also mouse turn"
                    },
                    {
                        "username": "Gautam_G",
                        "content": "Interpretation 1 is correct"
                    },
                    {
                        "username": "cracy",
                        "content": "This should be a direct mouse win case, right? The solution still gave 0."
                    }
                ]
            },
            {
                "id": 1569498,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "If I see this problem during an interview, it should imply that the interviewer doesn\\'t want to hire me for some reason. So I\\'d better say goodbye and gently close the door..."
                    },
                    {
                        "username": "overattribution",
                        "content": "**Edit**: Thanks [@lmiaoj](https://leetcode.com/lmiaoj)  for the help. I found the errors with my logic:\\n\\n1) A draw is more optimal than a loss.\\n2) Repeating positions only counts as a draw if **both** cat and mouse repeat their previous positions. The cat cannot force a draw simply by moving backwards unless it also causes the mouse to move backwards.\\n\\n**Original question:**\\n\\nI see two possible ways to move forward:\\n\\n![image](https://assets.leetcode.com/users/overattribution/image_1538620324.png)\\n\\nShouldn\\'t the Mouse win both of these routes?\\n\\nIs the Cat super immature? Does she step on a previous location just to the spite the Mouse? Why is the example said to be a draw?"
                    },
                    {
                        "username": "0icy",
                        "content": "cat should move to the best possible position and in your situation it is not happening"
                    },
                    {
                        "username": "hsiaoluw",
                        "content": "You can prove that for non-draw cases , we can always find a way for cat or mouse to win with 2n state.\\nWithout losing generality, suppose the mouse wins, and the depth of the state trace is larger than 2n.\\nThen, there exists at least one node X that he mouse visits twice, which also means the mouse runs on a cycle during time t1 to t2.\\n\\nt1 state: (X, c1) ---> t2 state: (X,, c2) ---> ending state (0, Y)\\nThrough time t1 to t2, the cat is moving from c1 -> c2 path.\\n\\nif (X,c1)->(X,c2)->(0,Y) is the only path for the mouse to win,\\nthen on time t2, the cat can move on the path from c2->c1, which results in a draw situation and this violates our assumption mouse wins .\\n\\nAs a result (X, c1)->(X,c2)->(0, Y) should not be the only path, which means there exist at least one path for the mouse to win without cycles.\\nTherefore the depth of the states is 2*n."
                    },
                    {
                        "username": "rani23",
                        "content": "Why is the test case given in the question \\'DRAW\\'? \\nAccording to me, the mouse should win.\\nM: 1 -> 3\\nC: 2 -> 4\\nM: 3 -> 5\\nC: 4 -> 3\\nM: 5 -> 0\\nPlease explain where my understanding is wrong. TIA."
                    },
                    {
                        "username": "jeesoklee",
                        "content": "cat must go to 5 on the first move. it must do its best to be in between the mouse and the hole"
                    },
                    {
                        "username": "kashish242",
                        "content": "minimum post length is 12 characters. hence writing this. all the best."
                    },
                    {
                        "username": "mksmanjit",
                        "content": "Hi Team,\\n\\nI facing difficulty understanding the draw case(0).\\nlike Example given in the description.\\n[[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]\\nThe output of this problem is draw(0).\\n\\nI did not get this.\\nAs mentioned Mouse start from Node 1 and Cat Start from Node 2, and mouse will start first.\\n\\n\\nSo below are step i took.\\nOption 1:\\n1) Mouse move to node 3.\\n2) Cat move to node 5.\\n3) Mouse Move to Node 5 ( here you can say mouse and cat are on the same node so Cat win, but this point is not described in description, if cat reach the Mouse node then cat win, in this case mouse is going to the Cat node).\\n4) Mouse reaches Node 0\\n\\nOutput: Mouse win\\n\\nOption 2:\\n1) Mouse move to node 3.\\n2) Cat move to node 5.\\n3) Mouse Move to Node 4.\\n4) Cat move to node 3\\n5) Mouse Move to Node 2.\\n6) Cat Move to the Node 1.\\n7) Mouse Move to Node 0.\\n\\nOutput: Mouse win\\n\\nOption 3:\\n1) Mouse move to node 3.\\n2) Cat move to node 4.\\n3) Mouse Move to Node 5.\\n4) Cat move to node 3\\n5) Mouse Move to Node 0\\n\\nOutput: Mouse win\\n\\nCan some one please explain what i am missing in the description because of that i am unable to reach to the correct output, which is draw in this case.\\n\\nThanks in advance.\\n"
                    },
                    {
                        "username": "steffi00203",
                        "content": "Hello, I submitted my code, but it is failing for test case \\'{{3, 4}, {3, 5}, {3, 6}, {0, 1, 2}, {0, 5, 6}, {1, 4}, {2, 4}}\\' with expecetd output of 0.\\nCan someone help me understand how is it a draw?\\n\\nThanks"
                    },
                    {
                        "username": "yctung",
                        "content": "I know cat can\\'t chase mouse to dead in this case, but can can easily go back to the same position to make the draw, right?"
                    },
                    {
                        "username": "bw02020202",
                        "content": "Could someone clarify: \\nWDYM by : If ever a position is repeated (i.e., the players are in the same position as a previous turn, and it is the same player\\'s turn to move), the game is a draw.\\n\\nInterpretation 1:\\nstep i, mouse turn, they are at (x, y)\\nstep j > i, mouse turn, they are at (x, y) again.\\n\\nInterpretation 2\\nstep i, mouse turn, mouse at x\\nstep j > i, mouse turn, mouse at x again.\\n\\nInterpretation 3\\nstep i, mouse turn, mouse at x\\nstep j, whoever\\'s turn, cat at y\\nstep k, where k > i, k > j, mouse turn, mouse cat are at (x,y)\\n\\nInterpretation 4\\nstep i, mouse turn, mouse at x, where either mouse or cat was at x atep some step j < i and step j is also mouse turn"
                    },
                    {
                        "username": "Gautam_G",
                        "content": "Interpretation 1 is correct"
                    },
                    {
                        "username": "cracy",
                        "content": "This should be a direct mouse win case, right? The solution still gave 0."
                    }
                ]
            },
            {
                "id": 1576397,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "If I see this problem during an interview, it should imply that the interviewer doesn\\'t want to hire me for some reason. So I\\'d better say goodbye and gently close the door..."
                    },
                    {
                        "username": "overattribution",
                        "content": "**Edit**: Thanks [@lmiaoj](https://leetcode.com/lmiaoj)  for the help. I found the errors with my logic:\\n\\n1) A draw is more optimal than a loss.\\n2) Repeating positions only counts as a draw if **both** cat and mouse repeat their previous positions. The cat cannot force a draw simply by moving backwards unless it also causes the mouse to move backwards.\\n\\n**Original question:**\\n\\nI see two possible ways to move forward:\\n\\n![image](https://assets.leetcode.com/users/overattribution/image_1538620324.png)\\n\\nShouldn\\'t the Mouse win both of these routes?\\n\\nIs the Cat super immature? Does she step on a previous location just to the spite the Mouse? Why is the example said to be a draw?"
                    },
                    {
                        "username": "0icy",
                        "content": "cat should move to the best possible position and in your situation it is not happening"
                    },
                    {
                        "username": "hsiaoluw",
                        "content": "You can prove that for non-draw cases , we can always find a way for cat or mouse to win with 2n state.\\nWithout losing generality, suppose the mouse wins, and the depth of the state trace is larger than 2n.\\nThen, there exists at least one node X that he mouse visits twice, which also means the mouse runs on a cycle during time t1 to t2.\\n\\nt1 state: (X, c1) ---> t2 state: (X,, c2) ---> ending state (0, Y)\\nThrough time t1 to t2, the cat is moving from c1 -> c2 path.\\n\\nif (X,c1)->(X,c2)->(0,Y) is the only path for the mouse to win,\\nthen on time t2, the cat can move on the path from c2->c1, which results in a draw situation and this violates our assumption mouse wins .\\n\\nAs a result (X, c1)->(X,c2)->(0, Y) should not be the only path, which means there exist at least one path for the mouse to win without cycles.\\nTherefore the depth of the states is 2*n."
                    },
                    {
                        "username": "rani23",
                        "content": "Why is the test case given in the question \\'DRAW\\'? \\nAccording to me, the mouse should win.\\nM: 1 -> 3\\nC: 2 -> 4\\nM: 3 -> 5\\nC: 4 -> 3\\nM: 5 -> 0\\nPlease explain where my understanding is wrong. TIA."
                    },
                    {
                        "username": "jeesoklee",
                        "content": "cat must go to 5 on the first move. it must do its best to be in between the mouse and the hole"
                    },
                    {
                        "username": "kashish242",
                        "content": "minimum post length is 12 characters. hence writing this. all the best."
                    },
                    {
                        "username": "mksmanjit",
                        "content": "Hi Team,\\n\\nI facing difficulty understanding the draw case(0).\\nlike Example given in the description.\\n[[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]\\nThe output of this problem is draw(0).\\n\\nI did not get this.\\nAs mentioned Mouse start from Node 1 and Cat Start from Node 2, and mouse will start first.\\n\\n\\nSo below are step i took.\\nOption 1:\\n1) Mouse move to node 3.\\n2) Cat move to node 5.\\n3) Mouse Move to Node 5 ( here you can say mouse and cat are on the same node so Cat win, but this point is not described in description, if cat reach the Mouse node then cat win, in this case mouse is going to the Cat node).\\n4) Mouse reaches Node 0\\n\\nOutput: Mouse win\\n\\nOption 2:\\n1) Mouse move to node 3.\\n2) Cat move to node 5.\\n3) Mouse Move to Node 4.\\n4) Cat move to node 3\\n5) Mouse Move to Node 2.\\n6) Cat Move to the Node 1.\\n7) Mouse Move to Node 0.\\n\\nOutput: Mouse win\\n\\nOption 3:\\n1) Mouse move to node 3.\\n2) Cat move to node 4.\\n3) Mouse Move to Node 5.\\n4) Cat move to node 3\\n5) Mouse Move to Node 0\\n\\nOutput: Mouse win\\n\\nCan some one please explain what i am missing in the description because of that i am unable to reach to the correct output, which is draw in this case.\\n\\nThanks in advance.\\n"
                    },
                    {
                        "username": "steffi00203",
                        "content": "Hello, I submitted my code, but it is failing for test case \\'{{3, 4}, {3, 5}, {3, 6}, {0, 1, 2}, {0, 5, 6}, {1, 4}, {2, 4}}\\' with expecetd output of 0.\\nCan someone help me understand how is it a draw?\\n\\nThanks"
                    },
                    {
                        "username": "yctung",
                        "content": "I know cat can\\'t chase mouse to dead in this case, but can can easily go back to the same position to make the draw, right?"
                    },
                    {
                        "username": "bw02020202",
                        "content": "Could someone clarify: \\nWDYM by : If ever a position is repeated (i.e., the players are in the same position as a previous turn, and it is the same player\\'s turn to move), the game is a draw.\\n\\nInterpretation 1:\\nstep i, mouse turn, they are at (x, y)\\nstep j > i, mouse turn, they are at (x, y) again.\\n\\nInterpretation 2\\nstep i, mouse turn, mouse at x\\nstep j > i, mouse turn, mouse at x again.\\n\\nInterpretation 3\\nstep i, mouse turn, mouse at x\\nstep j, whoever\\'s turn, cat at y\\nstep k, where k > i, k > j, mouse turn, mouse cat are at (x,y)\\n\\nInterpretation 4\\nstep i, mouse turn, mouse at x, where either mouse or cat was at x atep some step j < i and step j is also mouse turn"
                    },
                    {
                        "username": "Gautam_G",
                        "content": "Interpretation 1 is correct"
                    },
                    {
                        "username": "cracy",
                        "content": "This should be a direct mouse win case, right? The solution still gave 0."
                    }
                ]
            },
            {
                "id": 1572194,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "If I see this problem during an interview, it should imply that the interviewer doesn\\'t want to hire me for some reason. So I\\'d better say goodbye and gently close the door..."
                    },
                    {
                        "username": "overattribution",
                        "content": "**Edit**: Thanks [@lmiaoj](https://leetcode.com/lmiaoj)  for the help. I found the errors with my logic:\\n\\n1) A draw is more optimal than a loss.\\n2) Repeating positions only counts as a draw if **both** cat and mouse repeat their previous positions. The cat cannot force a draw simply by moving backwards unless it also causes the mouse to move backwards.\\n\\n**Original question:**\\n\\nI see two possible ways to move forward:\\n\\n![image](https://assets.leetcode.com/users/overattribution/image_1538620324.png)\\n\\nShouldn\\'t the Mouse win both of these routes?\\n\\nIs the Cat super immature? Does she step on a previous location just to the spite the Mouse? Why is the example said to be a draw?"
                    },
                    {
                        "username": "0icy",
                        "content": "cat should move to the best possible position and in your situation it is not happening"
                    },
                    {
                        "username": "hsiaoluw",
                        "content": "You can prove that for non-draw cases , we can always find a way for cat or mouse to win with 2n state.\\nWithout losing generality, suppose the mouse wins, and the depth of the state trace is larger than 2n.\\nThen, there exists at least one node X that he mouse visits twice, which also means the mouse runs on a cycle during time t1 to t2.\\n\\nt1 state: (X, c1) ---> t2 state: (X,, c2) ---> ending state (0, Y)\\nThrough time t1 to t2, the cat is moving from c1 -> c2 path.\\n\\nif (X,c1)->(X,c2)->(0,Y) is the only path for the mouse to win,\\nthen on time t2, the cat can move on the path from c2->c1, which results in a draw situation and this violates our assumption mouse wins .\\n\\nAs a result (X, c1)->(X,c2)->(0, Y) should not be the only path, which means there exist at least one path for the mouse to win without cycles.\\nTherefore the depth of the states is 2*n."
                    },
                    {
                        "username": "rani23",
                        "content": "Why is the test case given in the question \\'DRAW\\'? \\nAccording to me, the mouse should win.\\nM: 1 -> 3\\nC: 2 -> 4\\nM: 3 -> 5\\nC: 4 -> 3\\nM: 5 -> 0\\nPlease explain where my understanding is wrong. TIA."
                    },
                    {
                        "username": "jeesoklee",
                        "content": "cat must go to 5 on the first move. it must do its best to be in between the mouse and the hole"
                    },
                    {
                        "username": "kashish242",
                        "content": "minimum post length is 12 characters. hence writing this. all the best."
                    },
                    {
                        "username": "mksmanjit",
                        "content": "Hi Team,\\n\\nI facing difficulty understanding the draw case(0).\\nlike Example given in the description.\\n[[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]\\nThe output of this problem is draw(0).\\n\\nI did not get this.\\nAs mentioned Mouse start from Node 1 and Cat Start from Node 2, and mouse will start first.\\n\\n\\nSo below are step i took.\\nOption 1:\\n1) Mouse move to node 3.\\n2) Cat move to node 5.\\n3) Mouse Move to Node 5 ( here you can say mouse and cat are on the same node so Cat win, but this point is not described in description, if cat reach the Mouse node then cat win, in this case mouse is going to the Cat node).\\n4) Mouse reaches Node 0\\n\\nOutput: Mouse win\\n\\nOption 2:\\n1) Mouse move to node 3.\\n2) Cat move to node 5.\\n3) Mouse Move to Node 4.\\n4) Cat move to node 3\\n5) Mouse Move to Node 2.\\n6) Cat Move to the Node 1.\\n7) Mouse Move to Node 0.\\n\\nOutput: Mouse win\\n\\nOption 3:\\n1) Mouse move to node 3.\\n2) Cat move to node 4.\\n3) Mouse Move to Node 5.\\n4) Cat move to node 3\\n5) Mouse Move to Node 0\\n\\nOutput: Mouse win\\n\\nCan some one please explain what i am missing in the description because of that i am unable to reach to the correct output, which is draw in this case.\\n\\nThanks in advance.\\n"
                    },
                    {
                        "username": "steffi00203",
                        "content": "Hello, I submitted my code, but it is failing for test case \\'{{3, 4}, {3, 5}, {3, 6}, {0, 1, 2}, {0, 5, 6}, {1, 4}, {2, 4}}\\' with expecetd output of 0.\\nCan someone help me understand how is it a draw?\\n\\nThanks"
                    },
                    {
                        "username": "yctung",
                        "content": "I know cat can\\'t chase mouse to dead in this case, but can can easily go back to the same position to make the draw, right?"
                    },
                    {
                        "username": "bw02020202",
                        "content": "Could someone clarify: \\nWDYM by : If ever a position is repeated (i.e., the players are in the same position as a previous turn, and it is the same player\\'s turn to move), the game is a draw.\\n\\nInterpretation 1:\\nstep i, mouse turn, they are at (x, y)\\nstep j > i, mouse turn, they are at (x, y) again.\\n\\nInterpretation 2\\nstep i, mouse turn, mouse at x\\nstep j > i, mouse turn, mouse at x again.\\n\\nInterpretation 3\\nstep i, mouse turn, mouse at x\\nstep j, whoever\\'s turn, cat at y\\nstep k, where k > i, k > j, mouse turn, mouse cat are at (x,y)\\n\\nInterpretation 4\\nstep i, mouse turn, mouse at x, where either mouse or cat was at x atep some step j < i and step j is also mouse turn"
                    },
                    {
                        "username": "Gautam_G",
                        "content": "Interpretation 1 is correct"
                    },
                    {
                        "username": "cracy",
                        "content": "This should be a direct mouse win case, right? The solution still gave 0."
                    }
                ]
            },
            {
                "id": 1564552,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "If I see this problem during an interview, it should imply that the interviewer doesn\\'t want to hire me for some reason. So I\\'d better say goodbye and gently close the door..."
                    },
                    {
                        "username": "overattribution",
                        "content": "**Edit**: Thanks [@lmiaoj](https://leetcode.com/lmiaoj)  for the help. I found the errors with my logic:\\n\\n1) A draw is more optimal than a loss.\\n2) Repeating positions only counts as a draw if **both** cat and mouse repeat their previous positions. The cat cannot force a draw simply by moving backwards unless it also causes the mouse to move backwards.\\n\\n**Original question:**\\n\\nI see two possible ways to move forward:\\n\\n![image](https://assets.leetcode.com/users/overattribution/image_1538620324.png)\\n\\nShouldn\\'t the Mouse win both of these routes?\\n\\nIs the Cat super immature? Does she step on a previous location just to the spite the Mouse? Why is the example said to be a draw?"
                    },
                    {
                        "username": "0icy",
                        "content": "cat should move to the best possible position and in your situation it is not happening"
                    },
                    {
                        "username": "hsiaoluw",
                        "content": "You can prove that for non-draw cases , we can always find a way for cat or mouse to win with 2n state.\\nWithout losing generality, suppose the mouse wins, and the depth of the state trace is larger than 2n.\\nThen, there exists at least one node X that he mouse visits twice, which also means the mouse runs on a cycle during time t1 to t2.\\n\\nt1 state: (X, c1) ---> t2 state: (X,, c2) ---> ending state (0, Y)\\nThrough time t1 to t2, the cat is moving from c1 -> c2 path.\\n\\nif (X,c1)->(X,c2)->(0,Y) is the only path for the mouse to win,\\nthen on time t2, the cat can move on the path from c2->c1, which results in a draw situation and this violates our assumption mouse wins .\\n\\nAs a result (X, c1)->(X,c2)->(0, Y) should not be the only path, which means there exist at least one path for the mouse to win without cycles.\\nTherefore the depth of the states is 2*n."
                    },
                    {
                        "username": "rani23",
                        "content": "Why is the test case given in the question \\'DRAW\\'? \\nAccording to me, the mouse should win.\\nM: 1 -> 3\\nC: 2 -> 4\\nM: 3 -> 5\\nC: 4 -> 3\\nM: 5 -> 0\\nPlease explain where my understanding is wrong. TIA."
                    },
                    {
                        "username": "jeesoklee",
                        "content": "cat must go to 5 on the first move. it must do its best to be in between the mouse and the hole"
                    },
                    {
                        "username": "kashish242",
                        "content": "minimum post length is 12 characters. hence writing this. all the best."
                    },
                    {
                        "username": "mksmanjit",
                        "content": "Hi Team,\\n\\nI facing difficulty understanding the draw case(0).\\nlike Example given in the description.\\n[[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]\\nThe output of this problem is draw(0).\\n\\nI did not get this.\\nAs mentioned Mouse start from Node 1 and Cat Start from Node 2, and mouse will start first.\\n\\n\\nSo below are step i took.\\nOption 1:\\n1) Mouse move to node 3.\\n2) Cat move to node 5.\\n3) Mouse Move to Node 5 ( here you can say mouse and cat are on the same node so Cat win, but this point is not described in description, if cat reach the Mouse node then cat win, in this case mouse is going to the Cat node).\\n4) Mouse reaches Node 0\\n\\nOutput: Mouse win\\n\\nOption 2:\\n1) Mouse move to node 3.\\n2) Cat move to node 5.\\n3) Mouse Move to Node 4.\\n4) Cat move to node 3\\n5) Mouse Move to Node 2.\\n6) Cat Move to the Node 1.\\n7) Mouse Move to Node 0.\\n\\nOutput: Mouse win\\n\\nOption 3:\\n1) Mouse move to node 3.\\n2) Cat move to node 4.\\n3) Mouse Move to Node 5.\\n4) Cat move to node 3\\n5) Mouse Move to Node 0\\n\\nOutput: Mouse win\\n\\nCan some one please explain what i am missing in the description because of that i am unable to reach to the correct output, which is draw in this case.\\n\\nThanks in advance.\\n"
                    },
                    {
                        "username": "steffi00203",
                        "content": "Hello, I submitted my code, but it is failing for test case \\'{{3, 4}, {3, 5}, {3, 6}, {0, 1, 2}, {0, 5, 6}, {1, 4}, {2, 4}}\\' with expecetd output of 0.\\nCan someone help me understand how is it a draw?\\n\\nThanks"
                    },
                    {
                        "username": "yctung",
                        "content": "I know cat can\\'t chase mouse to dead in this case, but can can easily go back to the same position to make the draw, right?"
                    },
                    {
                        "username": "bw02020202",
                        "content": "Could someone clarify: \\nWDYM by : If ever a position is repeated (i.e., the players are in the same position as a previous turn, and it is the same player\\'s turn to move), the game is a draw.\\n\\nInterpretation 1:\\nstep i, mouse turn, they are at (x, y)\\nstep j > i, mouse turn, they are at (x, y) again.\\n\\nInterpretation 2\\nstep i, mouse turn, mouse at x\\nstep j > i, mouse turn, mouse at x again.\\n\\nInterpretation 3\\nstep i, mouse turn, mouse at x\\nstep j, whoever\\'s turn, cat at y\\nstep k, where k > i, k > j, mouse turn, mouse cat are at (x,y)\\n\\nInterpretation 4\\nstep i, mouse turn, mouse at x, where either mouse or cat was at x atep some step j < i and step j is also mouse turn"
                    },
                    {
                        "username": "Gautam_G",
                        "content": "Interpretation 1 is correct"
                    },
                    {
                        "username": "cracy",
                        "content": "This should be a direct mouse win case, right? The solution still gave 0."
                    }
                ]
            },
            {
                "id": 1566100,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "If I see this problem during an interview, it should imply that the interviewer doesn\\'t want to hire me for some reason. So I\\'d better say goodbye and gently close the door..."
                    },
                    {
                        "username": "overattribution",
                        "content": "**Edit**: Thanks [@lmiaoj](https://leetcode.com/lmiaoj)  for the help. I found the errors with my logic:\\n\\n1) A draw is more optimal than a loss.\\n2) Repeating positions only counts as a draw if **both** cat and mouse repeat their previous positions. The cat cannot force a draw simply by moving backwards unless it also causes the mouse to move backwards.\\n\\n**Original question:**\\n\\nI see two possible ways to move forward:\\n\\n![image](https://assets.leetcode.com/users/overattribution/image_1538620324.png)\\n\\nShouldn\\'t the Mouse win both of these routes?\\n\\nIs the Cat super immature? Does she step on a previous location just to the spite the Mouse? Why is the example said to be a draw?"
                    },
                    {
                        "username": "0icy",
                        "content": "cat should move to the best possible position and in your situation it is not happening"
                    },
                    {
                        "username": "hsiaoluw",
                        "content": "You can prove that for non-draw cases , we can always find a way for cat or mouse to win with 2n state.\\nWithout losing generality, suppose the mouse wins, and the depth of the state trace is larger than 2n.\\nThen, there exists at least one node X that he mouse visits twice, which also means the mouse runs on a cycle during time t1 to t2.\\n\\nt1 state: (X, c1) ---> t2 state: (X,, c2) ---> ending state (0, Y)\\nThrough time t1 to t2, the cat is moving from c1 -> c2 path.\\n\\nif (X,c1)->(X,c2)->(0,Y) is the only path for the mouse to win,\\nthen on time t2, the cat can move on the path from c2->c1, which results in a draw situation and this violates our assumption mouse wins .\\n\\nAs a result (X, c1)->(X,c2)->(0, Y) should not be the only path, which means there exist at least one path for the mouse to win without cycles.\\nTherefore the depth of the states is 2*n."
                    },
                    {
                        "username": "rani23",
                        "content": "Why is the test case given in the question \\'DRAW\\'? \\nAccording to me, the mouse should win.\\nM: 1 -> 3\\nC: 2 -> 4\\nM: 3 -> 5\\nC: 4 -> 3\\nM: 5 -> 0\\nPlease explain where my understanding is wrong. TIA."
                    },
                    {
                        "username": "jeesoklee",
                        "content": "cat must go to 5 on the first move. it must do its best to be in between the mouse and the hole"
                    },
                    {
                        "username": "kashish242",
                        "content": "minimum post length is 12 characters. hence writing this. all the best."
                    },
                    {
                        "username": "mksmanjit",
                        "content": "Hi Team,\\n\\nI facing difficulty understanding the draw case(0).\\nlike Example given in the description.\\n[[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]\\nThe output of this problem is draw(0).\\n\\nI did not get this.\\nAs mentioned Mouse start from Node 1 and Cat Start from Node 2, and mouse will start first.\\n\\n\\nSo below are step i took.\\nOption 1:\\n1) Mouse move to node 3.\\n2) Cat move to node 5.\\n3) Mouse Move to Node 5 ( here you can say mouse and cat are on the same node so Cat win, but this point is not described in description, if cat reach the Mouse node then cat win, in this case mouse is going to the Cat node).\\n4) Mouse reaches Node 0\\n\\nOutput: Mouse win\\n\\nOption 2:\\n1) Mouse move to node 3.\\n2) Cat move to node 5.\\n3) Mouse Move to Node 4.\\n4) Cat move to node 3\\n5) Mouse Move to Node 2.\\n6) Cat Move to the Node 1.\\n7) Mouse Move to Node 0.\\n\\nOutput: Mouse win\\n\\nOption 3:\\n1) Mouse move to node 3.\\n2) Cat move to node 4.\\n3) Mouse Move to Node 5.\\n4) Cat move to node 3\\n5) Mouse Move to Node 0\\n\\nOutput: Mouse win\\n\\nCan some one please explain what i am missing in the description because of that i am unable to reach to the correct output, which is draw in this case.\\n\\nThanks in advance.\\n"
                    },
                    {
                        "username": "steffi00203",
                        "content": "Hello, I submitted my code, but it is failing for test case \\'{{3, 4}, {3, 5}, {3, 6}, {0, 1, 2}, {0, 5, 6}, {1, 4}, {2, 4}}\\' with expecetd output of 0.\\nCan someone help me understand how is it a draw?\\n\\nThanks"
                    },
                    {
                        "username": "yctung",
                        "content": "I know cat can\\'t chase mouse to dead in this case, but can can easily go back to the same position to make the draw, right?"
                    },
                    {
                        "username": "bw02020202",
                        "content": "Could someone clarify: \\nWDYM by : If ever a position is repeated (i.e., the players are in the same position as a previous turn, and it is the same player\\'s turn to move), the game is a draw.\\n\\nInterpretation 1:\\nstep i, mouse turn, they are at (x, y)\\nstep j > i, mouse turn, they are at (x, y) again.\\n\\nInterpretation 2\\nstep i, mouse turn, mouse at x\\nstep j > i, mouse turn, mouse at x again.\\n\\nInterpretation 3\\nstep i, mouse turn, mouse at x\\nstep j, whoever\\'s turn, cat at y\\nstep k, where k > i, k > j, mouse turn, mouse cat are at (x,y)\\n\\nInterpretation 4\\nstep i, mouse turn, mouse at x, where either mouse or cat was at x atep some step j < i and step j is also mouse turn"
                    },
                    {
                        "username": "Gautam_G",
                        "content": "Interpretation 1 is correct"
                    },
                    {
                        "username": "cracy",
                        "content": "This should be a direct mouse win case, right? The solution still gave 0."
                    }
                ]
            },
            {
                "id": 1567693,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "If I see this problem during an interview, it should imply that the interviewer doesn\\'t want to hire me for some reason. So I\\'d better say goodbye and gently close the door..."
                    },
                    {
                        "username": "overattribution",
                        "content": "**Edit**: Thanks [@lmiaoj](https://leetcode.com/lmiaoj)  for the help. I found the errors with my logic:\\n\\n1) A draw is more optimal than a loss.\\n2) Repeating positions only counts as a draw if **both** cat and mouse repeat their previous positions. The cat cannot force a draw simply by moving backwards unless it also causes the mouse to move backwards.\\n\\n**Original question:**\\n\\nI see two possible ways to move forward:\\n\\n![image](https://assets.leetcode.com/users/overattribution/image_1538620324.png)\\n\\nShouldn\\'t the Mouse win both of these routes?\\n\\nIs the Cat super immature? Does she step on a previous location just to the spite the Mouse? Why is the example said to be a draw?"
                    },
                    {
                        "username": "0icy",
                        "content": "cat should move to the best possible position and in your situation it is not happening"
                    },
                    {
                        "username": "hsiaoluw",
                        "content": "You can prove that for non-draw cases , we can always find a way for cat or mouse to win with 2n state.\\nWithout losing generality, suppose the mouse wins, and the depth of the state trace is larger than 2n.\\nThen, there exists at least one node X that he mouse visits twice, which also means the mouse runs on a cycle during time t1 to t2.\\n\\nt1 state: (X, c1) ---> t2 state: (X,, c2) ---> ending state (0, Y)\\nThrough time t1 to t2, the cat is moving from c1 -> c2 path.\\n\\nif (X,c1)->(X,c2)->(0,Y) is the only path for the mouse to win,\\nthen on time t2, the cat can move on the path from c2->c1, which results in a draw situation and this violates our assumption mouse wins .\\n\\nAs a result (X, c1)->(X,c2)->(0, Y) should not be the only path, which means there exist at least one path for the mouse to win without cycles.\\nTherefore the depth of the states is 2*n."
                    },
                    {
                        "username": "rani23",
                        "content": "Why is the test case given in the question \\'DRAW\\'? \\nAccording to me, the mouse should win.\\nM: 1 -> 3\\nC: 2 -> 4\\nM: 3 -> 5\\nC: 4 -> 3\\nM: 5 -> 0\\nPlease explain where my understanding is wrong. TIA."
                    },
                    {
                        "username": "jeesoklee",
                        "content": "cat must go to 5 on the first move. it must do its best to be in between the mouse and the hole"
                    },
                    {
                        "username": "kashish242",
                        "content": "minimum post length is 12 characters. hence writing this. all the best."
                    },
                    {
                        "username": "mksmanjit",
                        "content": "Hi Team,\\n\\nI facing difficulty understanding the draw case(0).\\nlike Example given in the description.\\n[[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]\\nThe output of this problem is draw(0).\\n\\nI did not get this.\\nAs mentioned Mouse start from Node 1 and Cat Start from Node 2, and mouse will start first.\\n\\n\\nSo below are step i took.\\nOption 1:\\n1) Mouse move to node 3.\\n2) Cat move to node 5.\\n3) Mouse Move to Node 5 ( here you can say mouse and cat are on the same node so Cat win, but this point is not described in description, if cat reach the Mouse node then cat win, in this case mouse is going to the Cat node).\\n4) Mouse reaches Node 0\\n\\nOutput: Mouse win\\n\\nOption 2:\\n1) Mouse move to node 3.\\n2) Cat move to node 5.\\n3) Mouse Move to Node 4.\\n4) Cat move to node 3\\n5) Mouse Move to Node 2.\\n6) Cat Move to the Node 1.\\n7) Mouse Move to Node 0.\\n\\nOutput: Mouse win\\n\\nOption 3:\\n1) Mouse move to node 3.\\n2) Cat move to node 4.\\n3) Mouse Move to Node 5.\\n4) Cat move to node 3\\n5) Mouse Move to Node 0\\n\\nOutput: Mouse win\\n\\nCan some one please explain what i am missing in the description because of that i am unable to reach to the correct output, which is draw in this case.\\n\\nThanks in advance.\\n"
                    },
                    {
                        "username": "steffi00203",
                        "content": "Hello, I submitted my code, but it is failing for test case \\'{{3, 4}, {3, 5}, {3, 6}, {0, 1, 2}, {0, 5, 6}, {1, 4}, {2, 4}}\\' with expecetd output of 0.\\nCan someone help me understand how is it a draw?\\n\\nThanks"
                    },
                    {
                        "username": "yctung",
                        "content": "I know cat can\\'t chase mouse to dead in this case, but can can easily go back to the same position to make the draw, right?"
                    },
                    {
                        "username": "bw02020202",
                        "content": "Could someone clarify: \\nWDYM by : If ever a position is repeated (i.e., the players are in the same position as a previous turn, and it is the same player\\'s turn to move), the game is a draw.\\n\\nInterpretation 1:\\nstep i, mouse turn, they are at (x, y)\\nstep j > i, mouse turn, they are at (x, y) again.\\n\\nInterpretation 2\\nstep i, mouse turn, mouse at x\\nstep j > i, mouse turn, mouse at x again.\\n\\nInterpretation 3\\nstep i, mouse turn, mouse at x\\nstep j, whoever\\'s turn, cat at y\\nstep k, where k > i, k > j, mouse turn, mouse cat are at (x,y)\\n\\nInterpretation 4\\nstep i, mouse turn, mouse at x, where either mouse or cat was at x atep some step j < i and step j is also mouse turn"
                    },
                    {
                        "username": "Gautam_G",
                        "content": "Interpretation 1 is correct"
                    },
                    {
                        "username": "cracy",
                        "content": "This should be a direct mouse win case, right? The solution still gave 0."
                    }
                ]
            },
            {
                "id": 1569697,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "If I see this problem during an interview, it should imply that the interviewer doesn\\'t want to hire me for some reason. So I\\'d better say goodbye and gently close the door..."
                    },
                    {
                        "username": "overattribution",
                        "content": "**Edit**: Thanks [@lmiaoj](https://leetcode.com/lmiaoj)  for the help. I found the errors with my logic:\\n\\n1) A draw is more optimal than a loss.\\n2) Repeating positions only counts as a draw if **both** cat and mouse repeat their previous positions. The cat cannot force a draw simply by moving backwards unless it also causes the mouse to move backwards.\\n\\n**Original question:**\\n\\nI see two possible ways to move forward:\\n\\n![image](https://assets.leetcode.com/users/overattribution/image_1538620324.png)\\n\\nShouldn\\'t the Mouse win both of these routes?\\n\\nIs the Cat super immature? Does she step on a previous location just to the spite the Mouse? Why is the example said to be a draw?"
                    },
                    {
                        "username": "0icy",
                        "content": "cat should move to the best possible position and in your situation it is not happening"
                    },
                    {
                        "username": "hsiaoluw",
                        "content": "You can prove that for non-draw cases , we can always find a way for cat or mouse to win with 2n state.\\nWithout losing generality, suppose the mouse wins, and the depth of the state trace is larger than 2n.\\nThen, there exists at least one node X that he mouse visits twice, which also means the mouse runs on a cycle during time t1 to t2.\\n\\nt1 state: (X, c1) ---> t2 state: (X,, c2) ---> ending state (0, Y)\\nThrough time t1 to t2, the cat is moving from c1 -> c2 path.\\n\\nif (X,c1)->(X,c2)->(0,Y) is the only path for the mouse to win,\\nthen on time t2, the cat can move on the path from c2->c1, which results in a draw situation and this violates our assumption mouse wins .\\n\\nAs a result (X, c1)->(X,c2)->(0, Y) should not be the only path, which means there exist at least one path for the mouse to win without cycles.\\nTherefore the depth of the states is 2*n."
                    },
                    {
                        "username": "rani23",
                        "content": "Why is the test case given in the question \\'DRAW\\'? \\nAccording to me, the mouse should win.\\nM: 1 -> 3\\nC: 2 -> 4\\nM: 3 -> 5\\nC: 4 -> 3\\nM: 5 -> 0\\nPlease explain where my understanding is wrong. TIA."
                    },
                    {
                        "username": "jeesoklee",
                        "content": "cat must go to 5 on the first move. it must do its best to be in between the mouse and the hole"
                    },
                    {
                        "username": "kashish242",
                        "content": "minimum post length is 12 characters. hence writing this. all the best."
                    },
                    {
                        "username": "mksmanjit",
                        "content": "Hi Team,\\n\\nI facing difficulty understanding the draw case(0).\\nlike Example given in the description.\\n[[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]\\nThe output of this problem is draw(0).\\n\\nI did not get this.\\nAs mentioned Mouse start from Node 1 and Cat Start from Node 2, and mouse will start first.\\n\\n\\nSo below are step i took.\\nOption 1:\\n1) Mouse move to node 3.\\n2) Cat move to node 5.\\n3) Mouse Move to Node 5 ( here you can say mouse and cat are on the same node so Cat win, but this point is not described in description, if cat reach the Mouse node then cat win, in this case mouse is going to the Cat node).\\n4) Mouse reaches Node 0\\n\\nOutput: Mouse win\\n\\nOption 2:\\n1) Mouse move to node 3.\\n2) Cat move to node 5.\\n3) Mouse Move to Node 4.\\n4) Cat move to node 3\\n5) Mouse Move to Node 2.\\n6) Cat Move to the Node 1.\\n7) Mouse Move to Node 0.\\n\\nOutput: Mouse win\\n\\nOption 3:\\n1) Mouse move to node 3.\\n2) Cat move to node 4.\\n3) Mouse Move to Node 5.\\n4) Cat move to node 3\\n5) Mouse Move to Node 0\\n\\nOutput: Mouse win\\n\\nCan some one please explain what i am missing in the description because of that i am unable to reach to the correct output, which is draw in this case.\\n\\nThanks in advance.\\n"
                    },
                    {
                        "username": "steffi00203",
                        "content": "Hello, I submitted my code, but it is failing for test case \\'{{3, 4}, {3, 5}, {3, 6}, {0, 1, 2}, {0, 5, 6}, {1, 4}, {2, 4}}\\' with expecetd output of 0.\\nCan someone help me understand how is it a draw?\\n\\nThanks"
                    },
                    {
                        "username": "yctung",
                        "content": "I know cat can\\'t chase mouse to dead in this case, but can can easily go back to the same position to make the draw, right?"
                    },
                    {
                        "username": "bw02020202",
                        "content": "Could someone clarify: \\nWDYM by : If ever a position is repeated (i.e., the players are in the same position as a previous turn, and it is the same player\\'s turn to move), the game is a draw.\\n\\nInterpretation 1:\\nstep i, mouse turn, they are at (x, y)\\nstep j > i, mouse turn, they are at (x, y) again.\\n\\nInterpretation 2\\nstep i, mouse turn, mouse at x\\nstep j > i, mouse turn, mouse at x again.\\n\\nInterpretation 3\\nstep i, mouse turn, mouse at x\\nstep j, whoever\\'s turn, cat at y\\nstep k, where k > i, k > j, mouse turn, mouse cat are at (x,y)\\n\\nInterpretation 4\\nstep i, mouse turn, mouse at x, where either mouse or cat was at x atep some step j < i and step j is also mouse turn"
                    },
                    {
                        "username": "Gautam_G",
                        "content": "Interpretation 1 is correct"
                    },
                    {
                        "username": "cracy",
                        "content": "This should be a direct mouse win case, right? The solution still gave 0."
                    }
                ]
            },
            {
                "id": 1576760,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "If I see this problem during an interview, it should imply that the interviewer doesn\\'t want to hire me for some reason. So I\\'d better say goodbye and gently close the door..."
                    },
                    {
                        "username": "overattribution",
                        "content": "**Edit**: Thanks [@lmiaoj](https://leetcode.com/lmiaoj)  for the help. I found the errors with my logic:\\n\\n1) A draw is more optimal than a loss.\\n2) Repeating positions only counts as a draw if **both** cat and mouse repeat their previous positions. The cat cannot force a draw simply by moving backwards unless it also causes the mouse to move backwards.\\n\\n**Original question:**\\n\\nI see two possible ways to move forward:\\n\\n![image](https://assets.leetcode.com/users/overattribution/image_1538620324.png)\\n\\nShouldn\\'t the Mouse win both of these routes?\\n\\nIs the Cat super immature? Does she step on a previous location just to the spite the Mouse? Why is the example said to be a draw?"
                    },
                    {
                        "username": "0icy",
                        "content": "cat should move to the best possible position and in your situation it is not happening"
                    },
                    {
                        "username": "hsiaoluw",
                        "content": "You can prove that for non-draw cases , we can always find a way for cat or mouse to win with 2n state.\\nWithout losing generality, suppose the mouse wins, and the depth of the state trace is larger than 2n.\\nThen, there exists at least one node X that he mouse visits twice, which also means the mouse runs on a cycle during time t1 to t2.\\n\\nt1 state: (X, c1) ---> t2 state: (X,, c2) ---> ending state (0, Y)\\nThrough time t1 to t2, the cat is moving from c1 -> c2 path.\\n\\nif (X,c1)->(X,c2)->(0,Y) is the only path for the mouse to win,\\nthen on time t2, the cat can move on the path from c2->c1, which results in a draw situation and this violates our assumption mouse wins .\\n\\nAs a result (X, c1)->(X,c2)->(0, Y) should not be the only path, which means there exist at least one path for the mouse to win without cycles.\\nTherefore the depth of the states is 2*n."
                    },
                    {
                        "username": "rani23",
                        "content": "Why is the test case given in the question \\'DRAW\\'? \\nAccording to me, the mouse should win.\\nM: 1 -> 3\\nC: 2 -> 4\\nM: 3 -> 5\\nC: 4 -> 3\\nM: 5 -> 0\\nPlease explain where my understanding is wrong. TIA."
                    },
                    {
                        "username": "jeesoklee",
                        "content": "cat must go to 5 on the first move. it must do its best to be in between the mouse and the hole"
                    },
                    {
                        "username": "kashish242",
                        "content": "minimum post length is 12 characters. hence writing this. all the best."
                    },
                    {
                        "username": "mksmanjit",
                        "content": "Hi Team,\\n\\nI facing difficulty understanding the draw case(0).\\nlike Example given in the description.\\n[[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]\\nThe output of this problem is draw(0).\\n\\nI did not get this.\\nAs mentioned Mouse start from Node 1 and Cat Start from Node 2, and mouse will start first.\\n\\n\\nSo below are step i took.\\nOption 1:\\n1) Mouse move to node 3.\\n2) Cat move to node 5.\\n3) Mouse Move to Node 5 ( here you can say mouse and cat are on the same node so Cat win, but this point is not described in description, if cat reach the Mouse node then cat win, in this case mouse is going to the Cat node).\\n4) Mouse reaches Node 0\\n\\nOutput: Mouse win\\n\\nOption 2:\\n1) Mouse move to node 3.\\n2) Cat move to node 5.\\n3) Mouse Move to Node 4.\\n4) Cat move to node 3\\n5) Mouse Move to Node 2.\\n6) Cat Move to the Node 1.\\n7) Mouse Move to Node 0.\\n\\nOutput: Mouse win\\n\\nOption 3:\\n1) Mouse move to node 3.\\n2) Cat move to node 4.\\n3) Mouse Move to Node 5.\\n4) Cat move to node 3\\n5) Mouse Move to Node 0\\n\\nOutput: Mouse win\\n\\nCan some one please explain what i am missing in the description because of that i am unable to reach to the correct output, which is draw in this case.\\n\\nThanks in advance.\\n"
                    },
                    {
                        "username": "steffi00203",
                        "content": "Hello, I submitted my code, but it is failing for test case \\'{{3, 4}, {3, 5}, {3, 6}, {0, 1, 2}, {0, 5, 6}, {1, 4}, {2, 4}}\\' with expecetd output of 0.\\nCan someone help me understand how is it a draw?\\n\\nThanks"
                    },
                    {
                        "username": "yctung",
                        "content": "I know cat can\\'t chase mouse to dead in this case, but can can easily go back to the same position to make the draw, right?"
                    },
                    {
                        "username": "bw02020202",
                        "content": "Could someone clarify: \\nWDYM by : If ever a position is repeated (i.e., the players are in the same position as a previous turn, and it is the same player\\'s turn to move), the game is a draw.\\n\\nInterpretation 1:\\nstep i, mouse turn, they are at (x, y)\\nstep j > i, mouse turn, they are at (x, y) again.\\n\\nInterpretation 2\\nstep i, mouse turn, mouse at x\\nstep j > i, mouse turn, mouse at x again.\\n\\nInterpretation 3\\nstep i, mouse turn, mouse at x\\nstep j, whoever\\'s turn, cat at y\\nstep k, where k > i, k > j, mouse turn, mouse cat are at (x,y)\\n\\nInterpretation 4\\nstep i, mouse turn, mouse at x, where either mouse or cat was at x atep some step j < i and step j is also mouse turn"
                    },
                    {
                        "username": "Gautam_G",
                        "content": "Interpretation 1 is correct"
                    },
                    {
                        "username": "cracy",
                        "content": "This should be a direct mouse win case, right? The solution still gave 0."
                    }
                ]
            },
            {
                "id": 1575645,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "If I see this problem during an interview, it should imply that the interviewer doesn\\'t want to hire me for some reason. So I\\'d better say goodbye and gently close the door..."
                    },
                    {
                        "username": "overattribution",
                        "content": "**Edit**: Thanks [@lmiaoj](https://leetcode.com/lmiaoj)  for the help. I found the errors with my logic:\\n\\n1) A draw is more optimal than a loss.\\n2) Repeating positions only counts as a draw if **both** cat and mouse repeat their previous positions. The cat cannot force a draw simply by moving backwards unless it also causes the mouse to move backwards.\\n\\n**Original question:**\\n\\nI see two possible ways to move forward:\\n\\n![image](https://assets.leetcode.com/users/overattribution/image_1538620324.png)\\n\\nShouldn\\'t the Mouse win both of these routes?\\n\\nIs the Cat super immature? Does she step on a previous location just to the spite the Mouse? Why is the example said to be a draw?"
                    },
                    {
                        "username": "0icy",
                        "content": "cat should move to the best possible position and in your situation it is not happening"
                    },
                    {
                        "username": "hsiaoluw",
                        "content": "You can prove that for non-draw cases , we can always find a way for cat or mouse to win with 2n state.\\nWithout losing generality, suppose the mouse wins, and the depth of the state trace is larger than 2n.\\nThen, there exists at least one node X that he mouse visits twice, which also means the mouse runs on a cycle during time t1 to t2.\\n\\nt1 state: (X, c1) ---> t2 state: (X,, c2) ---> ending state (0, Y)\\nThrough time t1 to t2, the cat is moving from c1 -> c2 path.\\n\\nif (X,c1)->(X,c2)->(0,Y) is the only path for the mouse to win,\\nthen on time t2, the cat can move on the path from c2->c1, which results in a draw situation and this violates our assumption mouse wins .\\n\\nAs a result (X, c1)->(X,c2)->(0, Y) should not be the only path, which means there exist at least one path for the mouse to win without cycles.\\nTherefore the depth of the states is 2*n."
                    },
                    {
                        "username": "rani23",
                        "content": "Why is the test case given in the question \\'DRAW\\'? \\nAccording to me, the mouse should win.\\nM: 1 -> 3\\nC: 2 -> 4\\nM: 3 -> 5\\nC: 4 -> 3\\nM: 5 -> 0\\nPlease explain where my understanding is wrong. TIA."
                    },
                    {
                        "username": "jeesoklee",
                        "content": "cat must go to 5 on the first move. it must do its best to be in between the mouse and the hole"
                    },
                    {
                        "username": "kashish242",
                        "content": "minimum post length is 12 characters. hence writing this. all the best."
                    },
                    {
                        "username": "mksmanjit",
                        "content": "Hi Team,\\n\\nI facing difficulty understanding the draw case(0).\\nlike Example given in the description.\\n[[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]\\nThe output of this problem is draw(0).\\n\\nI did not get this.\\nAs mentioned Mouse start from Node 1 and Cat Start from Node 2, and mouse will start first.\\n\\n\\nSo below are step i took.\\nOption 1:\\n1) Mouse move to node 3.\\n2) Cat move to node 5.\\n3) Mouse Move to Node 5 ( here you can say mouse and cat are on the same node so Cat win, but this point is not described in description, if cat reach the Mouse node then cat win, in this case mouse is going to the Cat node).\\n4) Mouse reaches Node 0\\n\\nOutput: Mouse win\\n\\nOption 2:\\n1) Mouse move to node 3.\\n2) Cat move to node 5.\\n3) Mouse Move to Node 4.\\n4) Cat move to node 3\\n5) Mouse Move to Node 2.\\n6) Cat Move to the Node 1.\\n7) Mouse Move to Node 0.\\n\\nOutput: Mouse win\\n\\nOption 3:\\n1) Mouse move to node 3.\\n2) Cat move to node 4.\\n3) Mouse Move to Node 5.\\n4) Cat move to node 3\\n5) Mouse Move to Node 0\\n\\nOutput: Mouse win\\n\\nCan some one please explain what i am missing in the description because of that i am unable to reach to the correct output, which is draw in this case.\\n\\nThanks in advance.\\n"
                    },
                    {
                        "username": "steffi00203",
                        "content": "Hello, I submitted my code, but it is failing for test case \\'{{3, 4}, {3, 5}, {3, 6}, {0, 1, 2}, {0, 5, 6}, {1, 4}, {2, 4}}\\' with expecetd output of 0.\\nCan someone help me understand how is it a draw?\\n\\nThanks"
                    },
                    {
                        "username": "yctung",
                        "content": "I know cat can\\'t chase mouse to dead in this case, but can can easily go back to the same position to make the draw, right?"
                    },
                    {
                        "username": "bw02020202",
                        "content": "Could someone clarify: \\nWDYM by : If ever a position is repeated (i.e., the players are in the same position as a previous turn, and it is the same player\\'s turn to move), the game is a draw.\\n\\nInterpretation 1:\\nstep i, mouse turn, they are at (x, y)\\nstep j > i, mouse turn, they are at (x, y) again.\\n\\nInterpretation 2\\nstep i, mouse turn, mouse at x\\nstep j > i, mouse turn, mouse at x again.\\n\\nInterpretation 3\\nstep i, mouse turn, mouse at x\\nstep j, whoever\\'s turn, cat at y\\nstep k, where k > i, k > j, mouse turn, mouse cat are at (x,y)\\n\\nInterpretation 4\\nstep i, mouse turn, mouse at x, where either mouse or cat was at x atep some step j < i and step j is also mouse turn"
                    },
                    {
                        "username": "Gautam_G",
                        "content": "Interpretation 1 is correct"
                    },
                    {
                        "username": "cracy",
                        "content": "This should be a direct mouse win case, right? The solution still gave 0."
                    }
                ]
            },
            {
                "id": 1573615,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "If I see this problem during an interview, it should imply that the interviewer doesn\\'t want to hire me for some reason. So I\\'d better say goodbye and gently close the door..."
                    },
                    {
                        "username": "overattribution",
                        "content": "**Edit**: Thanks [@lmiaoj](https://leetcode.com/lmiaoj)  for the help. I found the errors with my logic:\\n\\n1) A draw is more optimal than a loss.\\n2) Repeating positions only counts as a draw if **both** cat and mouse repeat their previous positions. The cat cannot force a draw simply by moving backwards unless it also causes the mouse to move backwards.\\n\\n**Original question:**\\n\\nI see two possible ways to move forward:\\n\\n![image](https://assets.leetcode.com/users/overattribution/image_1538620324.png)\\n\\nShouldn\\'t the Mouse win both of these routes?\\n\\nIs the Cat super immature? Does she step on a previous location just to the spite the Mouse? Why is the example said to be a draw?"
                    },
                    {
                        "username": "0icy",
                        "content": "cat should move to the best possible position and in your situation it is not happening"
                    },
                    {
                        "username": "hsiaoluw",
                        "content": "You can prove that for non-draw cases , we can always find a way for cat or mouse to win with 2n state.\\nWithout losing generality, suppose the mouse wins, and the depth of the state trace is larger than 2n.\\nThen, there exists at least one node X that he mouse visits twice, which also means the mouse runs on a cycle during time t1 to t2.\\n\\nt1 state: (X, c1) ---> t2 state: (X,, c2) ---> ending state (0, Y)\\nThrough time t1 to t2, the cat is moving from c1 -> c2 path.\\n\\nif (X,c1)->(X,c2)->(0,Y) is the only path for the mouse to win,\\nthen on time t2, the cat can move on the path from c2->c1, which results in a draw situation and this violates our assumption mouse wins .\\n\\nAs a result (X, c1)->(X,c2)->(0, Y) should not be the only path, which means there exist at least one path for the mouse to win without cycles.\\nTherefore the depth of the states is 2*n."
                    },
                    {
                        "username": "rani23",
                        "content": "Why is the test case given in the question \\'DRAW\\'? \\nAccording to me, the mouse should win.\\nM: 1 -> 3\\nC: 2 -> 4\\nM: 3 -> 5\\nC: 4 -> 3\\nM: 5 -> 0\\nPlease explain where my understanding is wrong. TIA."
                    },
                    {
                        "username": "jeesoklee",
                        "content": "cat must go to 5 on the first move. it must do its best to be in between the mouse and the hole"
                    },
                    {
                        "username": "kashish242",
                        "content": "minimum post length is 12 characters. hence writing this. all the best."
                    },
                    {
                        "username": "mksmanjit",
                        "content": "Hi Team,\\n\\nI facing difficulty understanding the draw case(0).\\nlike Example given in the description.\\n[[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]\\nThe output of this problem is draw(0).\\n\\nI did not get this.\\nAs mentioned Mouse start from Node 1 and Cat Start from Node 2, and mouse will start first.\\n\\n\\nSo below are step i took.\\nOption 1:\\n1) Mouse move to node 3.\\n2) Cat move to node 5.\\n3) Mouse Move to Node 5 ( here you can say mouse and cat are on the same node so Cat win, but this point is not described in description, if cat reach the Mouse node then cat win, in this case mouse is going to the Cat node).\\n4) Mouse reaches Node 0\\n\\nOutput: Mouse win\\n\\nOption 2:\\n1) Mouse move to node 3.\\n2) Cat move to node 5.\\n3) Mouse Move to Node 4.\\n4) Cat move to node 3\\n5) Mouse Move to Node 2.\\n6) Cat Move to the Node 1.\\n7) Mouse Move to Node 0.\\n\\nOutput: Mouse win\\n\\nOption 3:\\n1) Mouse move to node 3.\\n2) Cat move to node 4.\\n3) Mouse Move to Node 5.\\n4) Cat move to node 3\\n5) Mouse Move to Node 0\\n\\nOutput: Mouse win\\n\\nCan some one please explain what i am missing in the description because of that i am unable to reach to the correct output, which is draw in this case.\\n\\nThanks in advance.\\n"
                    },
                    {
                        "username": "steffi00203",
                        "content": "Hello, I submitted my code, but it is failing for test case \\'{{3, 4}, {3, 5}, {3, 6}, {0, 1, 2}, {0, 5, 6}, {1, 4}, {2, 4}}\\' with expecetd output of 0.\\nCan someone help me understand how is it a draw?\\n\\nThanks"
                    },
                    {
                        "username": "yctung",
                        "content": "I know cat can\\'t chase mouse to dead in this case, but can can easily go back to the same position to make the draw, right?"
                    },
                    {
                        "username": "bw02020202",
                        "content": "Could someone clarify: \\nWDYM by : If ever a position is repeated (i.e., the players are in the same position as a previous turn, and it is the same player\\'s turn to move), the game is a draw.\\n\\nInterpretation 1:\\nstep i, mouse turn, they are at (x, y)\\nstep j > i, mouse turn, they are at (x, y) again.\\n\\nInterpretation 2\\nstep i, mouse turn, mouse at x\\nstep j > i, mouse turn, mouse at x again.\\n\\nInterpretation 3\\nstep i, mouse turn, mouse at x\\nstep j, whoever\\'s turn, cat at y\\nstep k, where k > i, k > j, mouse turn, mouse cat are at (x,y)\\n\\nInterpretation 4\\nstep i, mouse turn, mouse at x, where either mouse or cat was at x atep some step j < i and step j is also mouse turn"
                    },
                    {
                        "username": "Gautam_G",
                        "content": "Interpretation 1 is correct"
                    },
                    {
                        "username": "cracy",
                        "content": "This should be a direct mouse win case, right? The solution still gave 0."
                    }
                ]
            },
            {
                "id": 1569498,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "If I see this problem during an interview, it should imply that the interviewer doesn\\'t want to hire me for some reason. So I\\'d better say goodbye and gently close the door..."
                    },
                    {
                        "username": "overattribution",
                        "content": "**Edit**: Thanks [@lmiaoj](https://leetcode.com/lmiaoj)  for the help. I found the errors with my logic:\\n\\n1) A draw is more optimal than a loss.\\n2) Repeating positions only counts as a draw if **both** cat and mouse repeat their previous positions. The cat cannot force a draw simply by moving backwards unless it also causes the mouse to move backwards.\\n\\n**Original question:**\\n\\nI see two possible ways to move forward:\\n\\n![image](https://assets.leetcode.com/users/overattribution/image_1538620324.png)\\n\\nShouldn\\'t the Mouse win both of these routes?\\n\\nIs the Cat super immature? Does she step on a previous location just to the spite the Mouse? Why is the example said to be a draw?"
                    },
                    {
                        "username": "0icy",
                        "content": "cat should move to the best possible position and in your situation it is not happening"
                    },
                    {
                        "username": "hsiaoluw",
                        "content": "You can prove that for non-draw cases , we can always find a way for cat or mouse to win with 2n state.\\nWithout losing generality, suppose the mouse wins, and the depth of the state trace is larger than 2n.\\nThen, there exists at least one node X that he mouse visits twice, which also means the mouse runs on a cycle during time t1 to t2.\\n\\nt1 state: (X, c1) ---> t2 state: (X,, c2) ---> ending state (0, Y)\\nThrough time t1 to t2, the cat is moving from c1 -> c2 path.\\n\\nif (X,c1)->(X,c2)->(0,Y) is the only path for the mouse to win,\\nthen on time t2, the cat can move on the path from c2->c1, which results in a draw situation and this violates our assumption mouse wins .\\n\\nAs a result (X, c1)->(X,c2)->(0, Y) should not be the only path, which means there exist at least one path for the mouse to win without cycles.\\nTherefore the depth of the states is 2*n."
                    },
                    {
                        "username": "rani23",
                        "content": "Why is the test case given in the question \\'DRAW\\'? \\nAccording to me, the mouse should win.\\nM: 1 -> 3\\nC: 2 -> 4\\nM: 3 -> 5\\nC: 4 -> 3\\nM: 5 -> 0\\nPlease explain where my understanding is wrong. TIA."
                    },
                    {
                        "username": "jeesoklee",
                        "content": "cat must go to 5 on the first move. it must do its best to be in between the mouse and the hole"
                    },
                    {
                        "username": "kashish242",
                        "content": "minimum post length is 12 characters. hence writing this. all the best."
                    },
                    {
                        "username": "mksmanjit",
                        "content": "Hi Team,\\n\\nI facing difficulty understanding the draw case(0).\\nlike Example given in the description.\\n[[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]\\nThe output of this problem is draw(0).\\n\\nI did not get this.\\nAs mentioned Mouse start from Node 1 and Cat Start from Node 2, and mouse will start first.\\n\\n\\nSo below are step i took.\\nOption 1:\\n1) Mouse move to node 3.\\n2) Cat move to node 5.\\n3) Mouse Move to Node 5 ( here you can say mouse and cat are on the same node so Cat win, but this point is not described in description, if cat reach the Mouse node then cat win, in this case mouse is going to the Cat node).\\n4) Mouse reaches Node 0\\n\\nOutput: Mouse win\\n\\nOption 2:\\n1) Mouse move to node 3.\\n2) Cat move to node 5.\\n3) Mouse Move to Node 4.\\n4) Cat move to node 3\\n5) Mouse Move to Node 2.\\n6) Cat Move to the Node 1.\\n7) Mouse Move to Node 0.\\n\\nOutput: Mouse win\\n\\nOption 3:\\n1) Mouse move to node 3.\\n2) Cat move to node 4.\\n3) Mouse Move to Node 5.\\n4) Cat move to node 3\\n5) Mouse Move to Node 0\\n\\nOutput: Mouse win\\n\\nCan some one please explain what i am missing in the description because of that i am unable to reach to the correct output, which is draw in this case.\\n\\nThanks in advance.\\n"
                    },
                    {
                        "username": "steffi00203",
                        "content": "Hello, I submitted my code, but it is failing for test case \\'{{3, 4}, {3, 5}, {3, 6}, {0, 1, 2}, {0, 5, 6}, {1, 4}, {2, 4}}\\' with expecetd output of 0.\\nCan someone help me understand how is it a draw?\\n\\nThanks"
                    },
                    {
                        "username": "yctung",
                        "content": "I know cat can\\'t chase mouse to dead in this case, but can can easily go back to the same position to make the draw, right?"
                    },
                    {
                        "username": "bw02020202",
                        "content": "Could someone clarify: \\nWDYM by : If ever a position is repeated (i.e., the players are in the same position as a previous turn, and it is the same player\\'s turn to move), the game is a draw.\\n\\nInterpretation 1:\\nstep i, mouse turn, they are at (x, y)\\nstep j > i, mouse turn, they are at (x, y) again.\\n\\nInterpretation 2\\nstep i, mouse turn, mouse at x\\nstep j > i, mouse turn, mouse at x again.\\n\\nInterpretation 3\\nstep i, mouse turn, mouse at x\\nstep j, whoever\\'s turn, cat at y\\nstep k, where k > i, k > j, mouse turn, mouse cat are at (x,y)\\n\\nInterpretation 4\\nstep i, mouse turn, mouse at x, where either mouse or cat was at x atep some step j < i and step j is also mouse turn"
                    },
                    {
                        "username": "Gautam_G",
                        "content": "Interpretation 1 is correct"
                    },
                    {
                        "username": "cracy",
                        "content": "This should be a direct mouse win case, right? The solution still gave 0."
                    }
                ]
            },
            {
                "id": 1576397,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "If I see this problem during an interview, it should imply that the interviewer doesn\\'t want to hire me for some reason. So I\\'d better say goodbye and gently close the door..."
                    },
                    {
                        "username": "overattribution",
                        "content": "**Edit**: Thanks [@lmiaoj](https://leetcode.com/lmiaoj)  for the help. I found the errors with my logic:\\n\\n1) A draw is more optimal than a loss.\\n2) Repeating positions only counts as a draw if **both** cat and mouse repeat their previous positions. The cat cannot force a draw simply by moving backwards unless it also causes the mouse to move backwards.\\n\\n**Original question:**\\n\\nI see two possible ways to move forward:\\n\\n![image](https://assets.leetcode.com/users/overattribution/image_1538620324.png)\\n\\nShouldn\\'t the Mouse win both of these routes?\\n\\nIs the Cat super immature? Does she step on a previous location just to the spite the Mouse? Why is the example said to be a draw?"
                    },
                    {
                        "username": "0icy",
                        "content": "cat should move to the best possible position and in your situation it is not happening"
                    },
                    {
                        "username": "hsiaoluw",
                        "content": "You can prove that for non-draw cases , we can always find a way for cat or mouse to win with 2n state.\\nWithout losing generality, suppose the mouse wins, and the depth of the state trace is larger than 2n.\\nThen, there exists at least one node X that he mouse visits twice, which also means the mouse runs on a cycle during time t1 to t2.\\n\\nt1 state: (X, c1) ---> t2 state: (X,, c2) ---> ending state (0, Y)\\nThrough time t1 to t2, the cat is moving from c1 -> c2 path.\\n\\nif (X,c1)->(X,c2)->(0,Y) is the only path for the mouse to win,\\nthen on time t2, the cat can move on the path from c2->c1, which results in a draw situation and this violates our assumption mouse wins .\\n\\nAs a result (X, c1)->(X,c2)->(0, Y) should not be the only path, which means there exist at least one path for the mouse to win without cycles.\\nTherefore the depth of the states is 2*n."
                    },
                    {
                        "username": "rani23",
                        "content": "Why is the test case given in the question \\'DRAW\\'? \\nAccording to me, the mouse should win.\\nM: 1 -> 3\\nC: 2 -> 4\\nM: 3 -> 5\\nC: 4 -> 3\\nM: 5 -> 0\\nPlease explain where my understanding is wrong. TIA."
                    },
                    {
                        "username": "jeesoklee",
                        "content": "cat must go to 5 on the first move. it must do its best to be in between the mouse and the hole"
                    },
                    {
                        "username": "kashish242",
                        "content": "minimum post length is 12 characters. hence writing this. all the best."
                    },
                    {
                        "username": "mksmanjit",
                        "content": "Hi Team,\\n\\nI facing difficulty understanding the draw case(0).\\nlike Example given in the description.\\n[[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]\\nThe output of this problem is draw(0).\\n\\nI did not get this.\\nAs mentioned Mouse start from Node 1 and Cat Start from Node 2, and mouse will start first.\\n\\n\\nSo below are step i took.\\nOption 1:\\n1) Mouse move to node 3.\\n2) Cat move to node 5.\\n3) Mouse Move to Node 5 ( here you can say mouse and cat are on the same node so Cat win, but this point is not described in description, if cat reach the Mouse node then cat win, in this case mouse is going to the Cat node).\\n4) Mouse reaches Node 0\\n\\nOutput: Mouse win\\n\\nOption 2:\\n1) Mouse move to node 3.\\n2) Cat move to node 5.\\n3) Mouse Move to Node 4.\\n4) Cat move to node 3\\n5) Mouse Move to Node 2.\\n6) Cat Move to the Node 1.\\n7) Mouse Move to Node 0.\\n\\nOutput: Mouse win\\n\\nOption 3:\\n1) Mouse move to node 3.\\n2) Cat move to node 4.\\n3) Mouse Move to Node 5.\\n4) Cat move to node 3\\n5) Mouse Move to Node 0\\n\\nOutput: Mouse win\\n\\nCan some one please explain what i am missing in the description because of that i am unable to reach to the correct output, which is draw in this case.\\n\\nThanks in advance.\\n"
                    },
                    {
                        "username": "steffi00203",
                        "content": "Hello, I submitted my code, but it is failing for test case \\'{{3, 4}, {3, 5}, {3, 6}, {0, 1, 2}, {0, 5, 6}, {1, 4}, {2, 4}}\\' with expecetd output of 0.\\nCan someone help me understand how is it a draw?\\n\\nThanks"
                    },
                    {
                        "username": "yctung",
                        "content": "I know cat can\\'t chase mouse to dead in this case, but can can easily go back to the same position to make the draw, right?"
                    },
                    {
                        "username": "bw02020202",
                        "content": "Could someone clarify: \\nWDYM by : If ever a position is repeated (i.e., the players are in the same position as a previous turn, and it is the same player\\'s turn to move), the game is a draw.\\n\\nInterpretation 1:\\nstep i, mouse turn, they are at (x, y)\\nstep j > i, mouse turn, they are at (x, y) again.\\n\\nInterpretation 2\\nstep i, mouse turn, mouse at x\\nstep j > i, mouse turn, mouse at x again.\\n\\nInterpretation 3\\nstep i, mouse turn, mouse at x\\nstep j, whoever\\'s turn, cat at y\\nstep k, where k > i, k > j, mouse turn, mouse cat are at (x,y)\\n\\nInterpretation 4\\nstep i, mouse turn, mouse at x, where either mouse or cat was at x atep some step j < i and step j is also mouse turn"
                    },
                    {
                        "username": "Gautam_G",
                        "content": "Interpretation 1 is correct"
                    },
                    {
                        "username": "cracy",
                        "content": "This should be a direct mouse win case, right? The solution still gave 0."
                    }
                ]
            },
            {
                "id": 1572194,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "If I see this problem during an interview, it should imply that the interviewer doesn\\'t want to hire me for some reason. So I\\'d better say goodbye and gently close the door..."
                    },
                    {
                        "username": "overattribution",
                        "content": "**Edit**: Thanks [@lmiaoj](https://leetcode.com/lmiaoj)  for the help. I found the errors with my logic:\\n\\n1) A draw is more optimal than a loss.\\n2) Repeating positions only counts as a draw if **both** cat and mouse repeat their previous positions. The cat cannot force a draw simply by moving backwards unless it also causes the mouse to move backwards.\\n\\n**Original question:**\\n\\nI see two possible ways to move forward:\\n\\n![image](https://assets.leetcode.com/users/overattribution/image_1538620324.png)\\n\\nShouldn\\'t the Mouse win both of these routes?\\n\\nIs the Cat super immature? Does she step on a previous location just to the spite the Mouse? Why is the example said to be a draw?"
                    },
                    {
                        "username": "0icy",
                        "content": "cat should move to the best possible position and in your situation it is not happening"
                    },
                    {
                        "username": "hsiaoluw",
                        "content": "You can prove that for non-draw cases , we can always find a way for cat or mouse to win with 2n state.\\nWithout losing generality, suppose the mouse wins, and the depth of the state trace is larger than 2n.\\nThen, there exists at least one node X that he mouse visits twice, which also means the mouse runs on a cycle during time t1 to t2.\\n\\nt1 state: (X, c1) ---> t2 state: (X,, c2) ---> ending state (0, Y)\\nThrough time t1 to t2, the cat is moving from c1 -> c2 path.\\n\\nif (X,c1)->(X,c2)->(0,Y) is the only path for the mouse to win,\\nthen on time t2, the cat can move on the path from c2->c1, which results in a draw situation and this violates our assumption mouse wins .\\n\\nAs a result (X, c1)->(X,c2)->(0, Y) should not be the only path, which means there exist at least one path for the mouse to win without cycles.\\nTherefore the depth of the states is 2*n."
                    },
                    {
                        "username": "rani23",
                        "content": "Why is the test case given in the question \\'DRAW\\'? \\nAccording to me, the mouse should win.\\nM: 1 -> 3\\nC: 2 -> 4\\nM: 3 -> 5\\nC: 4 -> 3\\nM: 5 -> 0\\nPlease explain where my understanding is wrong. TIA."
                    },
                    {
                        "username": "jeesoklee",
                        "content": "cat must go to 5 on the first move. it must do its best to be in between the mouse and the hole"
                    },
                    {
                        "username": "kashish242",
                        "content": "minimum post length is 12 characters. hence writing this. all the best."
                    },
                    {
                        "username": "mksmanjit",
                        "content": "Hi Team,\\n\\nI facing difficulty understanding the draw case(0).\\nlike Example given in the description.\\n[[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]\\nThe output of this problem is draw(0).\\n\\nI did not get this.\\nAs mentioned Mouse start from Node 1 and Cat Start from Node 2, and mouse will start first.\\n\\n\\nSo below are step i took.\\nOption 1:\\n1) Mouse move to node 3.\\n2) Cat move to node 5.\\n3) Mouse Move to Node 5 ( here you can say mouse and cat are on the same node so Cat win, but this point is not described in description, if cat reach the Mouse node then cat win, in this case mouse is going to the Cat node).\\n4) Mouse reaches Node 0\\n\\nOutput: Mouse win\\n\\nOption 2:\\n1) Mouse move to node 3.\\n2) Cat move to node 5.\\n3) Mouse Move to Node 4.\\n4) Cat move to node 3\\n5) Mouse Move to Node 2.\\n6) Cat Move to the Node 1.\\n7) Mouse Move to Node 0.\\n\\nOutput: Mouse win\\n\\nOption 3:\\n1) Mouse move to node 3.\\n2) Cat move to node 4.\\n3) Mouse Move to Node 5.\\n4) Cat move to node 3\\n5) Mouse Move to Node 0\\n\\nOutput: Mouse win\\n\\nCan some one please explain what i am missing in the description because of that i am unable to reach to the correct output, which is draw in this case.\\n\\nThanks in advance.\\n"
                    },
                    {
                        "username": "steffi00203",
                        "content": "Hello, I submitted my code, but it is failing for test case \\'{{3, 4}, {3, 5}, {3, 6}, {0, 1, 2}, {0, 5, 6}, {1, 4}, {2, 4}}\\' with expecetd output of 0.\\nCan someone help me understand how is it a draw?\\n\\nThanks"
                    },
                    {
                        "username": "yctung",
                        "content": "I know cat can\\'t chase mouse to dead in this case, but can can easily go back to the same position to make the draw, right?"
                    },
                    {
                        "username": "bw02020202",
                        "content": "Could someone clarify: \\nWDYM by : If ever a position is repeated (i.e., the players are in the same position as a previous turn, and it is the same player\\'s turn to move), the game is a draw.\\n\\nInterpretation 1:\\nstep i, mouse turn, they are at (x, y)\\nstep j > i, mouse turn, they are at (x, y) again.\\n\\nInterpretation 2\\nstep i, mouse turn, mouse at x\\nstep j > i, mouse turn, mouse at x again.\\n\\nInterpretation 3\\nstep i, mouse turn, mouse at x\\nstep j, whoever\\'s turn, cat at y\\nstep k, where k > i, k > j, mouse turn, mouse cat are at (x,y)\\n\\nInterpretation 4\\nstep i, mouse turn, mouse at x, where either mouse or cat was at x atep some step j < i and step j is also mouse turn"
                    },
                    {
                        "username": "Gautam_G",
                        "content": "Interpretation 1 is correct"
                    },
                    {
                        "username": "cracy",
                        "content": "This should be a direct mouse win case, right? The solution still gave 0."
                    }
                ]
            }
        ]
    },
    {
        "title": "Break a Palindrome",
        "question_content": "<p>Given a palindromic string of lowercase English letters <code>palindrome</code>, replace <strong>exactly one</strong> character with any lowercase English letter so that the resulting string is <strong>not</strong> a palindrome and that it is the <strong>lexicographically smallest</strong> one possible.</p>\n\n<p>Return <em>the resulting string. If there is no way to replace a character to make it not a palindrome, return an <strong>empty string</strong>.</em></p>\n\n<p>A string <code>a</code> is lexicographically smaller than a string <code>b</code> (of the same length) if in the first position where <code>a</code> and <code>b</code> differ, <code>a</code> has a character strictly smaller than the corresponding character in <code>b</code>. For example, <code>&quot;abcc&quot;</code> is lexicographically smaller than <code>&quot;abcd&quot;</code> because the first position they differ is at the fourth character, and <code>&#39;c&#39;</code> is smaller than <code>&#39;d&#39;</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> palindrome = &quot;abccba&quot;\n<strong>Output:</strong> &quot;aaccba&quot;\n<strong>Explanation:</strong> There are many ways to make &quot;abccba&quot; not a palindrome, such as &quot;<u>z</u>bccba&quot;, &quot;a<u>a</u>ccba&quot;, and &quot;ab<u>a</u>cba&quot;.\nOf all the ways, &quot;aaccba&quot; is the lexicographically smallest.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> palindrome = &quot;a&quot;\n<strong>Output:</strong> &quot;&quot;\n<strong>Explanation:</strong> There is no way to replace a single character to make &quot;a&quot; not a palindrome, so return an empty string.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= palindrome.length &lt;= 1000</code></li>\n\t<li><code>palindrome</code> consists of only lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 489774,
                "title": "java-c-python-easy-and-concise",
                "content": "Check half of the string,\\nreplace a non `\\'a\\'` character to `\\'a\\'`.\\n\\nIf only one character, return empty string.\\nOtherwise repalce the last character to `\\'b\\'`\\n<br>\\n\\n## **Complexity**\\nTime `O(N)`\\nSpace `O(N)`\\n<br>\\n\\n**Java**\\nFrom @kniffina\\n```java\\n    public String breakPalindrome(String palindrome) {\\n        char[] s = palindrome.toCharArray();\\n        int n = s.length;\\n\\n        for (int i = 0; i < n / 2; i++) {\\n            if (s[i] != \\'a\\') {\\n                s[i] = \\'a\\';\\n                return String.valueOf(s);\\n            }\\n        }\\n        s[n - 1] = \\'b\\'; //if all \\'a\\'\\n        return n < 2 ? \"\" : String.valueOf(s);\\n    }\\n```\\n**C++**\\n```cpp\\n    string breakPalindrome(string S) {\\n        int n = S.size();\\n        for (int i = 0; i < n / 2; ++i) {\\n            if (S[i] != \\'a\\') {\\n                S[i] = \\'a\\';\\n                return S;\\n            }\\n        }\\n        S[n - 1] = \\'b\\';\\n        return n < 2 ? \"\" : S;\\n    }\\n```\\n**Python**\\n```py\\n    def breakPalindrome(self, S):\\n        for i in xrange(len(S) / 2):\\n            if S[i] != \\'a\\':\\n                return S[:i] + \\'a\\' + S[i + 1:]\\n        return S[:-1] + \\'b\\' if S[:-1] else \\'\\'\\n```\\n\\n",
                "solutionTags": [],
                "code": "```java\\n    public String breakPalindrome(String palindrome) {\\n        char[] s = palindrome.toCharArray();\\n        int n = s.length;\\n\\n        for (int i = 0; i < n / 2; i++) {\\n            if (s[i] != \\'a\\') {\\n                s[i] = \\'a\\';\\n                return String.valueOf(s);\\n            }\\n        }\\n        s[n - 1] = \\'b\\'; //if all \\'a\\'\\n        return n < 2 ? \"\" : String.valueOf(s);\\n    }\\n```\n```cpp\\n    string breakPalindrome(string S) {\\n        int n = S.size();\\n        for (int i = 0; i < n / 2; ++i) {\\n            if (S[i] != \\'a\\') {\\n                S[i] = \\'a\\';\\n                return S;\\n            }\\n        }\\n        S[n - 1] = \\'b\\';\\n        return n < 2 ? \"\" : S;\\n    }\\n```\n```py\\n    def breakPalindrome(self, S):\\n        for i in xrange(len(S) / 2):\\n            if S[i] != \\'a\\':\\n                return S[:i] + \\'a\\' + S[i + 1:]\\n        return S[:-1] + \\'b\\' if S[:-1] else \\'\\'\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2683703,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\nI\\'ll explain my solution line by line daily and you can find the full list in my [Discord](https://discord.gg/Nqm4jJcyBf).\\nIf you like it, please give a star, watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/kbDRbvuH/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Greedy"
                ],
                "code": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\nI\\'ll explain my solution line by line daily and you can find the full list in my [Discord](https://discord.gg/Nqm4jJcyBf).\\nIf you like it, please give a star, watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/kbDRbvuH/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 1480547,
                "title": "python-short-greedy-o-n-solution-explained",
                "content": "We need to replace one symbol and to get the smallest string as possible. First, we try to change elements on the smaller positions: imagine we have string `xyzyx` - where `x, y, z` can be any symbols. If `x` is not equal to `\"a\"`, then if we replace this symbol with `\"a\"` we will break palindrome and it will be as small as possible. However if `x = \"a\"`, it is not optimal to replace it to say `\"b\"`, we can only make our string bigger. So, we move to the next element `y` and so on. Notice that we can not change `z` in this case, because we will not break palindrome property.\\n\\nWhat happens, if we reached the last element and were not able to apply strategy above? Then we have string like this `aaaaaa..aaaaaa` or `aaaaaa...z...aaaaaa`, where `z` can be any symbol. In this case to get the smalles string as possible we need to replace last symbol to `\"b\"`. Also there is case when `n = 1`, and we can not break palindrome property so we return `\"\"`.\\n\\n#### Complexity\\nIt is `O(n)` for time and for space.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def breakPalindrome(self, pal):\\n        n = len(pal)\\n        for i in range(n//2):\\n            if pal[i] != \"a\": return pal[:i] + \"a\" + pal[i+1:]\\n        return pal[:-1] + \"b\" if n > 1 else \"\"\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```python\\nclass Solution:\\n    def breakPalindrome(self, pal):\\n        n = len(pal)\\n        for i in range(n//2):\\n            if pal[i] != \"a\": return pal[:i] + \"a\" + pal[i+1:]\\n        return pal[:-1] + \"b\" if n > 1 else \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 939823,
                "title": "java-0-ms-intuitive-code-w-explanation",
                "content": "**1328. Break a Palindrome**\\n```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        if(palindrome.length()<=1)\\n           return \"\";\\n        char[] arr = palindrome.toCharArray();\\n        \\n        for(int i=0; i<arr.length/2;i++){ \\n           if(arr[i] != \\'a\\'){ // if not a then change it to be lexographically smallest\\n               arr[i] = \\'a\\';\\n               return String.valueOf(arr);\\n           }\\n        }\\n        // if we reach here, there are ONLY \\'a\\' in palindrome string, so we should change the last character to a b\\n        arr[arr.length-1] = \\'b\\';\\n        return String.valueOf(arr);\\n    }\\n}\\n```\\n**PROBELM OVERVIEW**\\nWe are given a palindrome and want to make it the lexicographically *smallest* non-palindrome\\n\\n**SOLUTION ASSESSMENT**\\nThere are one of 2 states:\\n* If the characer is not an \\'a,\\' change it to be an \\'a\\' to break the palindrome **and** make it lexiographically smaller\\n* if all the characters are \\'a\\' change the last letter to be a \\'b\\' to break the palindrome, and since it\\'s the last letter, increasing it to a \\'b\\' will **minimize** the increase in lexicographical order.\\n\\t\\n**PROCESS**\\nWe do this by converting the string into a char[] array. Note, we only need to iterate until arr.length/2 because it is guaranteed that anything afterwards is a repetition of the characters we have already encountered. Also, arr.length/2 avoids the error of changing the center character in an odd-lengthed string, which has no effect on it.\\n\\nEX: \"aabaa\" -> \"aaaaa\" is still a palindrome **|** therefore, arr.length/2, which is 2, will not reach the middle character. \\nEX: \"aaaaa\" -> \"aaaab\" is the smallest. We need to change the **LAST non-a** because anything else will be larger ( \"aaaba\" > \"aaaab\" in the dictionary) \\n\\nHopefully this helps. :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        if(palindrome.length()<=1)\\n           return \"\";\\n        char[] arr = palindrome.toCharArray();\\n        \\n        for(int i=0; i<arr.length/2;i++){ \\n           if(arr[i] != \\'a\\'){ // if not a then change it to be lexographically smallest\\n               arr[i] = \\'a\\';\\n               return String.valueOf(arr);\\n           }\\n        }\\n        // if we reach here, there are ONLY \\'a\\' in palindrome string, so we should change the last character to a b\\n        arr[arr.length-1] = \\'b\\';\\n        return String.valueOf(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 491605,
                "title": "break-palindrome-c",
                "content": "Hint 1 : Length of string == 1, return \"\"\\nH2: Palindrome string is lexicographical, so return first non \\'a\\' by \\'a\\' to break sequence.\\n\\n100% accpeted solution.\\n\\n```\\nstring breakPalindrome(string p) {\\n        \\n        size_t sz = p.size();\\n        if (sz <= 1) return \"\";\\n        \\n        for (size_t i=0; i < sz/2; i++) {\\n            if (p[i] > \\'a\\')  {\\n                p[i] = \\'a\\';\\n                return p;\\n            }\\n        }\\n        \\n        p[sz-1] = \\'b\\';\\n        return p;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nstring breakPalindrome(string p) {\\n        \\n        size_t sz = p.size();\\n        if (sz <= 1) return \"\";\\n        \\n        for (size_t i=0; i < sz/2; i++) {\\n            if (p[i] > \\'a\\')  {\\n                p[i] = \\'a\\';\\n                return p;\\n            }\\n        }\\n        \\n        p[sz-1] = \\'b\\';\\n        return p;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 892711,
                "title": "python-solution-readable-simple-code",
                "content": "```\\nclass Solution(object):\\n    def breakPalindrome(self, palindrome):\\n        \"\"\"\\n        :type palindrome: str\\n        :rtype: str\\n        \"\"\" \\n        p1 = 0\\n        p2 = len(palindrome)-1\\n        new_pal = list(palindrome)\\n        while p1 < p2:\\n            if new_pal[p1] != \"a\":\\n                new_pal[p1] = \"a\"\\n                return \"\".join(new_pal)\\n            p1+=1\\n            p2-=1\\n        if len(new_pal) == 1: return \"\"\\n        new_pal[-1] = \"b\"\\n        return \"\".join(new_pal)\\n```\\nAlright.\\n**Explanation**\\nFirst of all you should know how to find a palindrom.\\n**Given** : TENET\\n**Using**: Two pointers. One far right, the other far left.\\n```\\nT  E  N  E  T\\n^           ^\\nT == T\\n\\nT  E  N  E  T\\n   ^     ^\\nE == E\\n\\nT  E  N  E  T\\n      ^^\\nN == N\\nYay! valid palindrome\\n```\\nYou can break a pallindrome at any of the point   T=T; E=E; N=N.\\n**Rules** : \\n1. Only choose / change one element .\\n2. Only change element at the first pointer. \\n3. If the above (rule 2) is not possible, change the element last element.\\n\\nNow, given the following condition we can\\'t just change an element to any letter :\\n\\n**Condition**\\n```...string becomes the lexicographically smallest possible```\\nLexicographical order : a < b < c < d < e ..... < z . \\na is smallest, followed by b then c... z is largest. As a consequence :\\n*Reason for rule 2* : \\nT E N E T : (changing element at first pointer vesus element at second pointer)\\n(A) E N E T < T E N E (A)   -: (A) E N E T  lexicographically smallest\\nT (A) N E T < T E N (A) T   -: T (A) N E T   lexicographically smallest\\n\\n*Reason for rule 3 :*\\nGiven : A A A A C , lexicographically smallest : A A A A B \\nGiven : A A A A A , lexicographically smallest RESULT -  A A A A B \\n\\nGenerally, think about how words are arranged in the dictionary.\\n\\nIntuitively to get the lexicographically smallest string possible you have two options, a or b.\\n\\n**Intuition**\\nYou can only choose one letter a or b. And please,**Remember rule 1** . \\nIf you find a non-\\'a\\' element change it to \\'a\\'. **Remember rule 2**\\nIf every element is an \"a\", then change the last element to \"b\". **Remember rule 3**\\n\\n**Algorithm**\\n* Iterate through the palindrome string,\\n* If the element at the first pointer is \"a\" you shouldnt change that. Continue.\\n* When the element at the first pointer is not \"a\", change it to \"a\" return the modified string\\n* If no change has occured and the iteration ends,\\nCheck: \\n* If the string contains only one letter, no possible change can be made return empty string\\n* Else change the last letter to b and return the modified string.\\n",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution(object):\\n    def breakPalindrome(self, palindrome):\\n        \"\"\"\\n        :type palindrome: str\\n        :rtype: str\\n        \"\"\" \\n        p1 = 0\\n        p2 = len(palindrome)-1\\n        new_pal = list(palindrome)\\n        while p1 < p2:\\n            if new_pal[p1] != \"a\":\\n                new_pal[p1] = \"a\"\\n                return \"\".join(new_pal)\\n            p1+=1\\n            p2-=1\\n        if len(new_pal) == 1: return \"\"\\n        new_pal[-1] = \"b\"\\n        return \"\".join(new_pal)\\n```\n```\\nT  E  N  E  T\\n^           ^\\nT == T\\n\\nT  E  N  E  T\\n   ^     ^\\nE == E\\n\\nT  E  N  E  T\\n      ^^\\nN == N\\nYay! valid palindrome\\n```\n```...string becomes the lexicographically smallest possible```",
                "codeTag": "Java"
            },
            {
                "id": 1480976,
                "title": "break-a-palindrome-w-explanation-c-python-java",
                "content": "**IDEA**\\n\\nThere are one of 2 states:\\n\\n* If the characer is not an `a` change it to be an `a` to break the palindrome and then make it lexiographically smaller.\\n* If all the characters are `a` change the last letter to be a `b` to break the palindrome.\\n\\t* Since it\\'s the last letter, increasing it to a `b`  will minimize the increase in lexicographical order.\\n\\nIf the palindrome string has only one character, return an `empty string`.\\n\\n**TIME COMPLEXITY - O(N)**\\n**SPACE COMPLEXITY - O(N)**\\n\\n**SOLUTION**\\n`IN C++`\\n```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string pal) {\\n        int n = pal.length();\\n        for (int i = 0; i < n / 2; i++) {\\n            if (pal[i] != \\'a\\') \\n            {\\n                pal[i] = \\'a\\';\\n                return pal ;\\n            }\\n        }\\n        pal[n - 1] = \\'b\\' ;\\n        return n < 2 ? \"\" : pal ;\\n    }\\n};\\n```\\n`IN PYTHON`\\n```\\nclass Solution:\\n    def breakPalindrome(self, pal):\\n        n = len(pal)\\n        for i in range(n//2):\\n            if pal[i] != \"a\": return pal[:i] + \"a\" + pal[i+1:]\\n        return pal[:-1] + \"b\" if n > 1 else \"\"\\n```\\n`IN JAVA`\\n```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        char[] s = palindrome.toCharArray();\\n        int n = s.length;\\n\\n        for (int i = 0; i < n / 2; i++) {\\n            if (s[i] != \\'a\\') \\n            {\\n                s[i] = \\'a\\';\\n                return String.valueOf(s);\\n            }\\n        }\\n        s[n - 1] = \\'b\\';\\n        return n < 2 ? \"\" : String.valueOf(s);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string pal) {\\n        int n = pal.length();\\n        for (int i = 0; i < n / 2; i++) {\\n            if (pal[i] != \\'a\\') \\n            {\\n                pal[i] = \\'a\\';\\n                return pal ;\\n            }\\n        }\\n        pal[n - 1] = \\'b\\' ;\\n        return n < 2 ? \"\" : pal ;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def breakPalindrome(self, pal):\\n        n = len(pal)\\n        for i in range(n//2):\\n            if pal[i] != \"a\": return pal[:i] + \"a\" + pal[i+1:]\\n        return pal[:-1] + \"b\" if n > 1 else \"\"\\n```\n```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        char[] s = palindrome.toCharArray();\\n        int n = s.length;\\n\\n        for (int i = 0; i < n / 2; i++) {\\n            if (s[i] != \\'a\\') \\n            {\\n                s[i] = \\'a\\';\\n                return String.valueOf(s);\\n            }\\n        }\\n        s[n - 1] = \\'b\\';\\n        return n < 2 ? \"\" : String.valueOf(s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2684743,
                "title": "break-a-palindrome-easy-to-understand-well-commented-simple-solution",
                "content": "```\\n/*\\nfor making it lexographically smaller non-palindromic after replacing a character , we will simply look for a character which is not \\'a\\' from i=0 to i<n/2 .\\n1.If such character exists , we will simply put palindrome[i]=\\'a\\' and exists out of the loop while making flag=1 (there is such character exists)\\n2. If such character doesn\\'t exist then flag will remain equal to 0 .In this case , we will simply put palinrome[n-1]=\\'a\\';\\n*/\\nclass Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n        int  n=palindrome.size();//calculating size\\n//there is no sense of performing if size<2 as there is no way to make it non-palindrome\\n        if(n<2)\\n        {\\n            return \"\";\\n        }\\n    int flag=0;\\n        \\n        for(int i=0;i<n/2;i++)\\n        {\\n            if(palindrome[i]!=\\'a\\')\\n            {\\n                flag=1;\\n                palindrome[i]=\\'a\\';\\n                break;\\n            }\\n        }\\n        if(flag==0)\\n        {\\n            palindrome[n-1]=\\'b\\';\\n        }\\n        return palindrome;\\n    }\\n};\\n```\\n**IF YOU FOUND THIS HELPFUL , PLEASE DO UPVOTE IT**",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\n/*\\nfor making it lexographically smaller non-palindromic after replacing a character , we will simply look for a character which is not \\'a\\' from i=0 to i<n/2 .\\n1.If such character exists , we will simply put palindrome[i]=\\'a\\' and exists out of the loop while making flag=1 (there is such character exists)\\n2. If such character doesn\\'t exist then flag will remain equal to 0 .In this case , we will simply put palinrome[n-1]=\\'a\\';\\n*/\\nclass Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n        int  n=palindrome.size();//calculating size\\n//there is no sense of performing if size<2 as there is no way to make it non-palindrome\\n        if(n<2)\\n        {\\n            return \"\";\\n        }\\n    int flag=0;\\n        \\n        for(int i=0;i<n/2;i++)\\n        {\\n            if(palindrome[i]!=\\'a\\')\\n            {\\n                flag=1;\\n                palindrome[i]=\\'a\\';\\n                break;\\n            }\\n        }\\n        if(flag==0)\\n        {\\n            palindrome[n-1]=\\'b\\';\\n        }\\n        return palindrome;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683950,
                "title": "java-easy-solution-100-faster-code-beginner-friendly",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        if(palindrome.length() == 0 || palindrome.length() == 1){\\n            return \"\";\\n        }\\n        char[] ch = palindrome.toCharArray();\\n        for(int i = 0;i<ch.length/2;i++){\\n            if(ch[i]-\\'a\\' != 0){\\n                ch[i] = \\'a\\';\\n                return new String(ch);\\n            }\\n            \\n        }\\n        ch[ch.length-1] = \\'b\\';\\n        return new String(ch);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        if(palindrome.length() == 0 || palindrome.length() == 1){\\n            return \"\";\\n        }\\n        char[] ch = palindrome.toCharArray();\\n        for(int i = 0;i<ch.length/2;i++){\\n            if(ch[i]-\\'a\\' != 0){\\n                ch[i] = \\'a\\';\\n                return new String(ch);\\n            }\\n            \\n        }\\n        ch[ch.length-1] = \\'b\\';\\n        return new String(ch);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 907823,
                "title": "very-simple-python-solution-o-n-time-and-space",
                "content": "```\\nclass Solution:\\n    def breakPalindrome(self, palindrome: str) -> str:\\n         \\n        \\n        for i in range(len(palindrome)//2):\\n                if palindrome[i]!=\\'a\\':\\n                    return palindrome[:i]+\\'a\\'+palindrome[i+1:]\\n                        \\n        return palindrome[:-1]+\\'b\\' if len(palindrome)>1 else \"\"\\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def breakPalindrome(self, palindrome: str) -> str:\\n         \\n        \\n        for i in range(len(palindrome)//2):\\n                if palindrome[i]!=\\'a\\':\\n                    return palindrome[:i]+\\'a\\'+palindrome[i+1:]\\n                        \\n        return palindrome[:-1]+\\'b\\' if len(palindrome)>1 else \"\"\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 489739,
                "title": "java-0-ms",
                "content": "\\n```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        \\n        char[] ch = palindrome.toCharArray(); \\n        int n = ch.length/2;\\n        \\n        for (int i = 0; i < n; i++) {\\n            \\n            if (ch[i] != \\'a\\') {\\n                ch[i] = \\'a\\';\\n                return String.valueOf(ch);\\n            }\\n        }\\n        \\n        if (palindrome.length() > 1) {\\n            ch[ch.length - 1] = \\'b\\';\\n            return String.valueOf(ch);\\n        }\\n        \\n        return \"\";\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        \\n        char[] ch = palindrome.toCharArray(); \\n        int n = ch.length/2;\\n        \\n        for (int i = 0; i < n; i++) {\\n            \\n            if (ch[i] != \\'a\\') {\\n                ch[i] = \\'a\\';\\n                return String.valueOf(ch);\\n            }\\n        }\\n        \\n        if (palindrome.length() > 1) {\\n            ch[ch.length - 1] = \\'b\\';\\n            return String.valueOf(ch);\\n        }\\n        \\n        return \"\";\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 846873,
                "title": "python-3-greedy-one-pass-explanations",
                "content": "### Explanation\\n- If `length of palindrome == 1`, return `\\'\\'`\\n- For even length string, if we found a char that is not `a`, replace it with `a` and return\\n- For odd length string, if we find a char that is not `a` and it\\'s not the middle of string, replace it with `a` and return\\n- If all `a` in the string, replace the last char to `b`\\n### Implementation\\n```\\nclass Solution:\\n    def breakPalindrome(self, palindrome: str) -> str:\\n        n = len(palindrome)\\n        if n == 1: return \\'\\'\\n        for i, c in enumerate(palindrome):\\n            if c != \\'a\\' and ((i != n // 2 and n % 2) or not n % 2): return palindrome[:i] + \\'a\\' + palindrome[i+1:]                \\n        else: return palindrome[:-1] + \\'b\\'\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def breakPalindrome(self, palindrome: str) -> str:\\n        n = len(palindrome)\\n        if n == 1: return \\'\\'\\n        for i, c in enumerate(palindrome):\\n            if c != \\'a\\' and ((i != n // 2 and n % 2) or not n % 2): return palindrome[:i] + \\'a\\' + palindrome[i+1:]                \\n        else: return palindrome[:-1] + \\'b\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 490093,
                "title": "straightforward-python",
                "content": "\\n```\\nclass Solution:\\n    def breakPalindrome(self, palindrome: str) -> str:\\n        n = len(palindrome)\\n        if n == 1: return \\'\\'\\n        for i, char in enumerate(palindrome):\\n            if char != \\'a\\' and i != n//2:\\n                return palindrome[:i] + \\'a\\' + palindrome[i+1:]\\n            elif char == \\'a\\' and i == n - 1:\\n                return palindrome[:-1] + \\'b\\'\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def breakPalindrome(self, palindrome: str) -> str:\\n        n = len(palindrome)\\n        if n == 1: return \\'\\'\\n        for i, char in enumerate(palindrome):\\n            if char != \\'a\\' and i != n//2:\\n                return palindrome[:i] + \\'a\\' + palindrome[i+1:]\\n            elif char == \\'a\\' and i == n - 1:\\n                return palindrome[:-1] + \\'b\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1202413,
                "title": "easy-java-solution-100-fast-with-explanation",
                "content": "There are three test cases which helped me for arriving at solution\\n1. abccba - Here we are replacing it to aaccba. This should be lexographically small, hence we have to search for first non occurence of a and replace it with \\'a\\'. \\n2. aaabaaa - Here it will be replaced as aaabaab which will be the lexographically small string. Here we replace end of the string with next smaller alphabet after \\'a\\' which will be \\'b\\'.\\n3. a/b/c - These cannot be made as non-pallindrome, hence return empty string.\\n```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        if(palindrome.length() <= 1) return new String();\\n        int n = palindrome.length();\\n        StringBuilder sb = new StringBuilder(palindrome);\\n        for(int i=0; i<n/2; i++){\\n            if(palindrome.charAt(i)!=\\'a\\'){\\n              sb.setCharAt(i , \\'a\\');\\n               return sb.toString();\\n            }\\n        }\\n        sb.setCharAt(n-1 , \\'b\\');\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        if(palindrome.length() <= 1) return new String();\\n        int n = palindrome.length();\\n        StringBuilder sb = new StringBuilder(palindrome);\\n        for(int i=0; i<n/2; i++){\\n            if(palindrome.charAt(i)!=\\'a\\'){\\n              sb.setCharAt(i , \\'a\\');\\n               return sb.toString();\\n            }\\n        }\\n        sb.setCharAt(n-1 , \\'b\\');\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2684545,
                "title": "cpp-solution-100-faster-simplest-approach",
                "content": "__Thank you for checking out the solution\\nDo upvote if it helps :)__\\n\\n__Approach :\\nFirst task is to check if the string is not a single character, if it is then no answer exists\\nAfter this one important fact is to be used, \"THE GIVEN STRING IS A PALINDROME\"__\\n```\\nThis makes the takes simpler as any character at a distance x from the beginning \\nis same as the character at a distance x from the end\\nWhich means we only have to traverse half of the string\\n```\\n__So Start the traversal, if a character at the i(th) position is not \\'a\\'__\\n>__Check if the length is odd and i = length/2__\\n>> __If yes, break the loop (Since our string is like aaaa...*...aaaa), we h=will have to replace the last \\'a\\' with \\'b\\'__\\n \\n>__Change the character at the position i, to \\'a\\', this works because the character from the end is not same as \\'a\\' (NOW)\\n>Return the manipulated String__\\n>\\n__If by now, nothing has been returned, the string is either all (a)s or of type  \\naaaa...*...aaaa,  where * can be any character other than \\'a\\' and the length is surely odd for the string of this type__\\n\\n__What to do ?\\nJust change the last \\'a\\' of the string to \\'b\\' and return the string__\\n\\n__Below is the coding implementation for the same__\\n_____\\n```\\nclass Solution \\n// Runtime: 0 ms, faster than 100.00% of C++ online submissions for Break a Palindrome.\\n{\\npublic:\\n    string breakPalindrome(string palindrome)\\n    {\\n        ios_base::sync_with_stdio(0);\\n        int l = palindrome.size();\\n        // A single letter entry can\\'t be broken in any way so that it doesnt stay a palindrome\\n        // Hence return \"\"\\n        if (l == 1)\\n            return \"\";\\n        // Now the remaining task to find a position that doesn\\'t contain \\'a\\'\\n        for (int i = 0; i <= l/2; i++)\\n            if (palindrome[i] != \\'a\\')\\n            {\\n\\t\\t\\t    //If the position lies in the center of the string, and the string has an odd-number length\\n\\t\\t\\t\\t// Time to break, becoz changing it into \\'a\\', will create a new palindrome\\n                if ((l & 1) && i == l / 2)\\n                    break;\\n\\t\\t\\t\\t// Otherwise change the character at index i to \\'a\\', and return it\\n                palindrome[i] = \\'a\\';\\n                return palindrome;\\n            }\\n        // In a case where\\n        // We have all \\'a\\'s,\\n        // Or when replacing a char in the middle makes the string palindrome again\\n        // Just replace b with the character at the end\\n        palindrome[l - 1] = \\'b\\';\\n        return palindrome;\\n    }\\n};\\n```\\n__Time Complexity : O(N/2) ~ O(N) , where N is the length of the string\\nSpace Complexity : O(1)__\\n\\n__Some Test case to consider:\\n\"aaaaaaa\"\\n\"aaabaaa\"\\n\"aaabbaaa\"\\n\"abccba\"\\n\"c\"\\n\"a\"__",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nThis makes the takes simpler as any character at a distance x from the beginning \\nis same as the character at a distance x from the end\\nWhich means we only have to traverse half of the string\\n```\n```\\nclass Solution \\n// Runtime: 0 ms, faster than 100.00% of C++ online submissions for Break a Palindrome.\\n{\\npublic:\\n    string breakPalindrome(string palindrome)\\n    {\\n        ios_base::sync_with_stdio(0);\\n        int l = palindrome.size();\\n        // A single letter entry can\\'t be broken in any way so that it doesnt stay a palindrome\\n        // Hence return \"\"\\n        if (l == 1)\\n            return \"\";\\n        // Now the remaining task to find a position that doesn\\'t contain \\'a\\'\\n        for (int i = 0; i <= l/2; i++)\\n            if (palindrome[i] != \\'a\\')\\n            {\\n\\t\\t\\t    //If the position lies in the center of the string, and the string has an odd-number length\\n\\t\\t\\t\\t// Time to break, becoz changing it into \\'a\\', will create a new palindrome\\n                if ((l & 1) && i == l / 2)\\n                    break;\\n\\t\\t\\t\\t// Otherwise change the character at index i to \\'a\\', and return it\\n                palindrome[i] = \\'a\\';\\n                return palindrome;\\n            }\\n        // In a case where\\n        // We have all \\'a\\'s,\\n        // Or when replacing a char in the middle makes the string palindrome again\\n        // Just replace b with the character at the end\\n        palindrome[l - 1] = \\'b\\';\\n        return palindrome;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 489718,
                "title": "simple-java-traversal",
                "content": "```\\n    public String breakPalindrome(String palindrome) {\\n        int n = palindrome.length();\\n        if(n<=1) {\\n            return \"\";\\n        }\\n        int i=0;\\n// Keep traversing until u find a character other than \\'a\\'.. or if u find another character but it is in the mid of palindrome, and changing it won\\'t make any difference.\\n        while(i<n && (palindrome.charAt(i)==\\'a\\' || (palindrome.charAt(i)>\\'a\\' && n%2!=0 && i==((n)/2)))) {\\n            i++;\\n        }\\n// if i goes till n-1 i.e all characters are \\'a\\', replace last by b otherwise replace ith character by \\'a\\'          \\n        return i<n-1?(palindrome.substring(0,i)+\\'a\\'+palindrome.substring(i+1)):palindrome.substring(0,n-1)+\\'b\\';\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String breakPalindrome(String palindrome) {\\n        int n = palindrome.length();\\n        if(n<=1) {\\n            return \"\";\\n        }\\n        int i=0;\\n// Keep traversing until u find a character other than \\'a\\'.. or if u find another character but it is in the mid of palindrome, and changing it won\\'t make any difference.\\n        while(i<n && (palindrome.charAt(i)==\\'a\\' || (palindrome.charAt(i)>\\'a\\' && n%2!=0 && i==((n)/2)))) {\\n            i++;\\n        }\\n// if i goes till n-1 i.e all characters are \\'a\\', replace last by b otherwise replace ith character by \\'a\\'          \\n        return i<n-1?(palindrome.substring(0,i)+\\'a\\'+palindrome.substring(i+1)):palindrome.substring(0,n-1)+\\'b\\';\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1524012,
                "title": "javascript-js",
                "content": "```\\n/**\\n * @param {string} palindrome\\n * @return {string}\\n */\\nvar breakPalindrome = function (palindrome) {\\n  let result = palindrome.split(\"\");\\n\\n  for (let i = 0; i < Math.floor(result.length / 2); i++) {\\n    if (result[i] !== \"a\") {\\n      result[i] = \"a\";\\n      return result.join(\"\");\\n    }\\n  }\\n\\n  if (result.length === 1) {\\n    return \"\";\\n  } else {\\n    result[result.length - 1] = \"b\";\\n    return result.join(\"\");\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} palindrome\\n * @return {string}\\n */\\nvar breakPalindrome = function (palindrome) {\\n  let result = palindrome.split(\"\");\\n\\n  for (let i = 0; i < Math.floor(result.length / 2); i++) {\\n    if (result[i] !== \"a\") {\\n      result[i] = \"a\";\\n      return result.join(\"\");\\n    }\\n  }\\n\\n  if (result.length === 1) {\\n    return \"\";\\n  } else {\\n    result[result.length - 1] = \"b\";\\n    return result.join(\"\");\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2701893,
                "title": "java-easy-solution-string",
                "content": "```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        int n=palindrome.length();\\n        if(n==1){//if length is 1\\n            return \"\";\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            //if char is non-\\'a\\' (but it should not be middle char of odd length string)\\n            if(palindrome.charAt(i)!=\\'a\\' && !(n%2!=0 && i==n/2)){\\n                \\n                //replace first non-\\'a\\' character with \\'a\\'\\n                palindrome=palindrome.substring(0,i)+\\'a\\'+palindrome.substring(i+1);\\n                return palindrome;\\n            }\\n        }\\n        \\n        //if string has only \\'a\\' change last character with b\\n        palindrome=palindrome.substring(0,n-1)+\\'b\\';\\n        \\n        return palindrome;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        int n=palindrome.length();\\n        if(n==1){//if length is 1\\n            return \"\";\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            //if char is non-\\'a\\' (but it should not be middle char of odd length string)\\n            if(palindrome.charAt(i)!=\\'a\\' && !(n%2!=0 && i==n/2)){\\n                \\n                //replace first non-\\'a\\' character with \\'a\\'\\n                palindrome=palindrome.substring(0,i)+\\'a\\'+palindrome.substring(i+1);\\n                return palindrome;\\n            }\\n        }\\n        \\n        //if string has only \\'a\\' change last character with b\\n        palindrome=palindrome.substring(0,n-1)+\\'b\\';\\n        \\n        return palindrome;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687522,
                "title": "easy-to-understand-100-faster-o-n-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string pal){\\n        int n = pal.size();\\n        if(n == 1){\\n            return \"\";\\n        }\\n\\t\\t\\n\\t\\t// traverse only half of the string\\n\\t\\t// if we find any ith character other than \\'a\\' make that ith character to \\'a\\' \\n\\t\\t// return the string\\n\\t\\t\\n        for(int i=0; i<n/2; i++){\\n            if(pal[i] != \\'a\\'){\\n                pal[i] = \\'a\\';\\n                return pal;\\n            }\\n        }\\n\\t\\t\\n        // if all character in string are only \\'a\\'.  \\n\\t\\t// Ex : \"aaaaa\" then make the last character to \\'b\\' -> \"aaaab\"\\n\\t\\t\\n\\t\\tpal[n-1] = \\'b\\'; \\n        return pal;\\n    }\\n};\\n```\\n: ) \\uD83D\\uDC4D : )",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string pal){\\n        int n = pal.size();\\n        if(n == 1){\\n            return \"\";\\n        }\\n\\t\\t\\n\\t\\t// traverse only half of the string\\n\\t\\t// if we find any ith character other than \\'a\\' make that ith character to \\'a\\' \\n\\t\\t// return the string\\n\\t\\t\\n        for(int i=0; i<n/2; i++){\\n            if(pal[i] != \\'a\\'){\\n                pal[i] = \\'a\\';\\n                return pal;\\n            }\\n        }\\n\\t\\t\\n        // if all character in string are only \\'a\\'.  \\n\\t\\t// Ex : \"aaaaa\" then make the last character to \\'b\\' -> \"aaaab\"\\n\\t\\t\\n\\t\\tpal[n-1] = \\'b\\'; \\n        return pal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2684257,
                "title": "easy-c-faster-than-100-intuitive-o-n-logn",
                "content": "**Please Upvote if you Like it :)**\\n* The simple Intuition is that we have to convert the 1st non-\\'a\\' character to \\'a\\' which does not have \\'a\\' on its palindrome side thats it. so that it both does not become \\'a\\' this is how we will be able to obtain smallest break palindrome.\\n* One edge case is that what if we have string like \\'\\'aaaaaaaaa\\'\\' then we have to simply convert the last character of string to \\'b\\' to make it smallest i.e \\'\\'aaaaaaab\\'\\'.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string p) {\\n        int start = 0, end = p.size() - 1;\\n        if(p.size() <= 1) return \"\";\\n        while(start < end){\\n            if(p[start] != \\'a\\' && p[end] != \\'a\\'){\\n                p[start] = \\'a\\';\\n                return p;\\n            }\\n            else{\\n                start++; end--;\\n            }\\n        }\\n        p[p.size() - 1] = \\'b\\';\\n        return p;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string p) {\\n        int start = 0, end = p.size() - 1;\\n        if(p.size() <= 1) return \"\";\\n        while(start < end){\\n            if(p[start] != \\'a\\' && p[end] != \\'a\\'){\\n                p[start] = \\'a\\';\\n                return p;\\n            }\\n            else{\\n                start++; end--;\\n            }\\n        }\\n        p[p.size() - 1] = \\'b\\';\\n        return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683526,
                "title": "python-3-8-lines-one-pass-t-m-99-7-54",
                "content": "```\\nclass Solution:\\n    def breakPalindrome(self, p: str) -> str:\\n        \\n        n = len(p)\\n        if n < 2: return \\'\\'\\n        \\n        for i in range(n//2):\\n            \\n            if p[i] != \\'a\\':\\n                p = p[:i] + \\'a\\' + p[i+1:]\\n                break\\n                \\n        else: p = p[:-1] + \\'b\\'\\n            \\n        return p\\n```\\n[https://leetcode.com/submissions/detail/559838984/](http://)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def breakPalindrome(self, p: str) -> str:\\n        \\n        n = len(p)\\n        if n < 2: return \\'\\'\\n        \\n        for i in range(n//2):\\n            \\n            if p[i] != \\'a\\':\\n                p = p[:i] + \\'a\\' + p[i+1:]\\n                break\\n                \\n        else: p = p[:-1] + \\'b\\'\\n            \\n        return p\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683508,
                "title": "daily-leetcoding-challenge-october-day-10",
                "content": "This problem is the Daily LeetCoding Challenge for October, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/break-a-palindrome/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Greedy\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/break-a-palindrome/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2415118,
                "title": "python-easy-to-read-and-understand-greedy",
                "content": "```\\nclass Solution:\\n    def breakPalindrome(self, s: str) -> str:\\n        n = len(s)\\n        if n == 1:\\n            return \\'\\'\\n        for i in range(n//2):\\n            if s[i] != \\'a\\':\\n                return s[:i] + \\'a\\' + s[i+1:]\\n        return s[:-1] + \\'b\\'",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def breakPalindrome(self, s: str) -> str:\\n        n = len(s)\\n        if n == 1:\\n            return \\'\\'\\n        for i in range(n//2):\\n            if s[i] != \\'a\\':\\n                return s[:i] + \\'a\\' + s[i+1:]\\n        return s[:-1] + \\'b\\'",
                "codeTag": "Java"
            },
            {
                "id": 1482792,
                "title": "c-solution",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    string breakPalindrome(string palindrome) \\n    {\\n        string res;\\n        if (palindrome.size() == 1)\\n            return res;\\n        for (size_t i = 0; i < palindrome.size() / 2; i++)\\n        {\\n            if(palindrome[i] != \\'a\\')\\n            {\\n                palindrome[i] = \\'a\\';\\n                return palindrome;                \\n            }\\n        }\\n        palindrome[palindrome.size() - 1] = \\'b\\';\\n        return palindrome;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    string breakPalindrome(string palindrome) \\n    {\\n        string res;\\n        if (palindrome.size() == 1)\\n            return res;\\n        for (size_t i = 0; i < palindrome.size() / 2; i++)\\n        {\\n            if(palindrome[i] != \\'a\\')\\n            {\\n                palindrome[i] = \\'a\\';\\n                return palindrome;                \\n            }\\n        }\\n        palindrome[palindrome.size() - 1] = \\'b\\';\\n        return palindrome;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1480602,
                "title": "solution-with-pictures-and-notes-javascript",
                "content": "# Algorithm\\nIn a palindrome, all the characters appear in pairs except for the middle element. To generate lexicographically smallest string, we can select any character before the middle, and change it to the smallest character, i.e. `a`. So we iterate through the first half of the string. If the character isn\\'t already the smallest, we change it to \\'a\\' and return the new string.\\n\\nedge case 1: if the length of the string is $1$, then we can never break the string by replacement. So we return `\"\"`.,\\n\\nedge case 2: if all the characters are already the smallest, i.e. `a`, then we change the last character of the string to the second smallest character available, i.e. `b`.\\n\\n![break-palindrome.jpeg](https://assets.leetcode.com/users/images/350e6e3d-7044-4b9b-9fc6-e39f59136b0b_1665381611.0712337.jpeg)\\n\\n# Complexity\\nIf there are total $n$ characters in the string -\\n\\n* Time complexity: $O(n)$. we iterate through the first half, or $(n / 2)$ characters to determine the first character to be replaced. Depending on the language of implementation, string mutation can be $O(1)$ or $O(n)$ operation. So the time complexity is $O(n)$.\\n* Space complexity: In the current implementation, we make use of an auxiliary array to replace the corresponding character, so it requires $O(n)$ space. If the replacement is done in place though, then it wouldn\\'t \\nneed any extra space. (We don\\'t count the space reserved only for the output)\\n\\n# Code\\n```\\n/**\\n * @param {string} palindrome\\n * @return {string}\\n */\\nfunction breakPalindrome(palindrome) {\\n  if (palindrome.length === 1) {\\n    return \"\";\\n  }\\n  let arr = palindrome.split(\"\");\\n  for (let i = 0; i <= Math.floor(arr.length / 2) - 1; i++) {\\n    if (arr[i] !== \\'a\\') {\\n      arr[i] = \\'a\\';\\n      return arr.join(\"\");\\n    }\\n  }\\n  arr[arr.length - 1] = \\'b\\';\\n  return arr.join(\"\");\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} palindrome\\n * @return {string}\\n */\\nfunction breakPalindrome(palindrome) {\\n  if (palindrome.length === 1) {\\n    return \"\";\\n  }\\n  let arr = palindrome.split(\"\");\\n  for (let i = 0; i <= Math.floor(arr.length / 2) - 1; i++) {\\n    if (arr[i] !== \\'a\\') {\\n      arr[i] = \\'a\\';\\n      return arr.join(\"\");\\n    }\\n  }\\n  arr[arr.length - 1] = \\'b\\';\\n  return arr.join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 765510,
                "title": "c-easy-to-understand-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n      if(palindrome.size()<=1) return \"\";\\n      int st=0;int en=palindrome.length()-1;\\n      while(st<en)\\n      {\\n         if(palindrome[st]!=\\'a\\')//Change first non \\'a\\' to \\'a\\'\\n         {\\n             palindrome[st]=\\'a\\';\\n             return palindrome;\\n         }\\n         st++;\\n         en--;\\n      }\\n      //If no character changed yet, then change last character to \\'b\\'\\n      palindrome[palindrome.length()-1]=\\'b\\';\\n      return palindrome;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n      if(palindrome.size()<=1) return \"\";\\n      int st=0;int en=palindrome.length()-1;\\n      while(st<en)\\n      {\\n         if(palindrome[st]!=\\'a\\')//Change first non \\'a\\' to \\'a\\'\\n         {\\n             palindrome[st]=\\'a\\';\\n             return palindrome;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 490245,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public string BreakPalindrome(string palindrome) \\n    {\\n        if(palindrome.Length <= 1) return \"\";\\n        var charArray = palindrome.ToCharArray();\\n        for(int i = 0; i < charArray.Length / 2; i++)\\n        {\\n            if(charArray[i] != \\'a\\')\\n            {\\n                charArray[i] = \\'a\\';\\n                return new string(charArray);\\n            }\\n        }\\n        \\n        charArray[charArray.Length - 1] = \\'b\\';\\n        return new string(charArray);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public string BreakPalindrome(string palindrome) \\n    {\\n        if(palindrome.Length <= 1) return \"\";\\n        var charArray = palindrome.ToCharArray();\\n        for(int i = 0; i < charArray.Length / 2; i++)\\n        {\\n            if(charArray[i] != \\'a\\')\\n            {\\n                charArray[i] = \\'a\\';\\n                return new string(charArray);\\n            }\\n        }\\n        \\n        charArray[charArray.Length - 1] = \\'b\\';\\n        return new string(charArray);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 489931,
                "title": "python-with-regex-two-candidates",
                "content": "Check two candidates:\\n1) Replace the first non-`\\'a\\'` with `\\'a\\'`.\\n2) Replace the last letter with `\\'b\\'`.\\n```\\ndef breakPalindrome(self, p):\\n    for s in re.sub(\\'[^a]\\', \\'a\\', p, 1), p[:-1] + \\'b\\':\\n        if s < s[::-1]:\\n            return s\\n    return \\'\\'        \\n```",
                "solutionTags": [],
                "code": "```\\ndef breakPalindrome(self, p):\\n    for s in re.sub(\\'[^a]\\', \\'a\\', p, 1), p[:-1] + \\'b\\':\\n        if s < s[::-1]:\\n            return s\\n    return \\'\\'        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 489748,
                "title": "clean-python-3-three-lines",
                "content": "```\\nclass Solution:\\n    def breakPalindrome(self, palindrome: str) -> str:\\n        for i in range(len(palindrome) // 2):\\n            if palindrome[i] != \\'a\\': return palindrome[:i] + \\'a\\' + palindrome[i+1:]\\n        return \\'\\' if len(palindrome) == 1 else palindrome[:-1] + \\'b\\'\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def breakPalindrome(self, palindrome: str) -> str:\\n        for i in range(len(palindrome) // 2):\\n            if palindrome[i] != \\'a\\': return palindrome[:i] + \\'a\\' + palindrome[i+1:]\\n        return \\'\\' if len(palindrome) == 1 else palindrome[:-1] + \\'b\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 489710,
                "title": "simple-solution-using-java-with-explanation",
                "content": "If the sting is of length 1, return \"\"\\nIf all the elements in the string are \\'a\\' then replace the last one with \\'b\\' else repalce the first non \\'a\\' member with an \\'a\\'\\n```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        String s = palindrome;\\n        if(s.length() == 1){\\n            return \"\";\\n        }\\n        int i = 0, j = s.length() -  1;\\n        char[] arr = s.toCharArray();\\n        while(i < j){\\n            if(s.charAt(j) == \\'a\\'){\\n                j--; \\n                i++;\\n            }else{\\n                arr[i] = \\'a\\';\\n                return new String(arr);\\n            }\\n        }\\n        arr[s.length() - 1] = \\'b\\';\\n        return new String(arr);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        String s = palindrome;\\n        if(s.length() == 1){\\n            return \"\";\\n        }\\n        int i = 0, j = s.length() -  1;\\n        char[] arr = s.toCharArray();\\n        while(i < j){\\n            if(s.charAt(j) == \\'a\\'){\\n                j--; \\n                i++;\\n            }else{\\n                arr[i] = \\'a\\';\\n                return new String(arr);\\n            }\\n        }\\n        arr[s.length() - 1] = \\'b\\';\\n        return new String(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687905,
                "title": "c-fastest-o-n-intuitive-easy",
                "content": "O(n)\\nIt is given in question that string is Palindrome and we have to remove the one character only ,so that string become non Palindromic , so  that it is  lexicographically smallest, first thing that comes in mind is that traverse the string and replace the character that does not equal to a,  but it approach will fail for this testcase \"aa\" or \"aaa\" ,now ,  To handle this case we will replace last character with b ,Still our approach will fail for some case like \"ab\", \\n\\n\"what we will do is that if run loop for 0 to n/2  if we find any character that does not equal to a replace and return the string other-wise replace last character with b\"\\n\\n```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string s) {\\n        int n = s.size(); //size of string \\n        if(n==1 || n==0)  //return empty string if size==1 or size==0\\n            return \"\";\\n        \\n        for(int i=0; i<n/2; i++) {\\n            if(s[i]!=\\'a\\') {\\n                s[i] = \\'a\\'; // character doesnot equal to \\'a\\' replace it with a and return the string\\n                return s;\\n            }\\n        }\\n        \\n        s[n-1] = \\'b\\'; // change the last  character with b\\n        return s;\\n    }\\n};\\n// why we run loop to n/2 not n because it will make Palindromic string for some cases like \"aba\"\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string s) {\\n        int n = s.size(); //size of string \\n        if(n==1 || n==0)  //return empty string if size==1 or size==0\\n            return \"\";\\n        \\n        for(int i=0; i<n/2; i++) {\\n            if(s[i]!=\\'a\\') {\\n                s[i] = \\'a\\'; // character doesnot equal to \\'a\\' replace it with a and return the string\\n                return s;\\n            }\\n        }\\n        \\n        s[n-1] = \\'b\\'; // change the last  character with b\\n        return s;\\n    }\\n};\\n// why we run loop to n/2 not n because it will make Palindromic string for some cases like \"aba\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686925,
                "title": "best-easiest-approach",
                "content": "# Intuition   if size is 1 then empty because  every charcter is a palindrome . Check for half length if not found \\'a\\' then replace that character with \\'a\\' otherwise replace the last character with \\'b\\'.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach   check for a for making it lexicographically smallest if not found then replace the last character to \\'b\\' otherwise replace it with \\'a\\'.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n/2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n        int n=palindrome.size();\\n        if(n==1){\\n            return \"\";\\n        }\\n        bool ok=0;\\n        for(int i=0;i<n/2;i++){\\n            if(palindrome[i]!=\\'a\\'){\\n                palindrome[i]=\\'a\\';\\n                 ok=1;\\n                break;\\n            }\\n        }\\n        if(!ok)palindrome[n-1]=\\'b\\';\\n        return palindrome;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n        int n=palindrome.size();\\n        if(n==1){\\n            return \"\";\\n        }\\n        bool ok=0;\\n        for(int i=0;i<n/2;i++){\\n            if(palindrome[i]!=\\'a\\'){\\n                palindrome[i]=\\'a\\';\\n                 ok=1;\\n                break;\\n            }\\n        }\\n        if(!ok)palindrome[n-1]=\\'b\\';\\n        return palindrome;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686818,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def breakPalindrome(self, palindrome: str) -> str:\\n        if len(palindrome)==1:\\n            return \\'\\'\\n        for i in range(int(len(palindrome)/2)):\\n            if palindrome[i]!=\\'a\\':\\n                palindrome= palindrome[:i]+\\'a\\'+palindrome[i+1:]\\n                return palindrome\\n        return palindrome[:-1]+\\'b\\'\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def breakPalindrome(self, palindrome: str) -> str:\\n        if len(palindrome)==1:\\n            return \\'\\'\\n        for i in range(int(len(palindrome)/2)):\\n            if palindrome[i]!=\\'a\\':\\n                palindrome= palindrome[:i]+\\'a\\'+palindrome[i+1:]\\n                return palindrome\\n        return palindrome[:-1]+\\'b\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686675,
                "title": "js-99-with-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/ffb87ca4-b84a-48c7-8998-2d0f35422d26_1665416260.8143685.png)\\n\\n\\nTo solve this problem, first of all we check if the length of the string is equal to **1**, if it is, we return an empty string **(\" \")**.\\nFor convenience, we turn the string into an **array**.\\nNow we do a search on the first half of the array (we add \\'**~~**\\' to remove the fractional part if the number is not paired), since this is a polyndrom, it makes no sense for us to sort through the second part.\\nIn case we find a character that is **greater** than \\'**a**\\', we change it to \\'**a**\\'. But if the whole string consists **only** of characters equal to \\'**a**\\', we take the **last** **one** and change it to \\'**b**\\'.\\nAt the end, it remains only to collect the string from the array again.\\n\\n```\\nlet breakPalindrome = function (palindrome) {\\n    if (palindrome.length === 1) return \\'\\';\\n    let arr = Array.from(palindrome);\\n\\n    for (let i = 0; i < ~~(arr.length / 2 ); i++) {\\n        if (arr[i] > \\'a\\') {\\n            arr[i] = \\'a\\';\\n            return arr.join(\\'\\');\\n        }\\n    }\\n    arr[arr.length - 1] = \\'b\\';\\n    return arr.join(\\'\\');\\n};\\n```\\n\\nI hope I was able to explain clearly.\\n **Happy coding!** \\uD83D\\uDE43",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet breakPalindrome = function (palindrome) {\\n    if (palindrome.length === 1) return \\'\\';\\n    let arr = Array.from(palindrome);\\n\\n    for (let i = 0; i < ~~(arr.length / 2 ); i++) {\\n        if (arr[i] > \\'a\\') {\\n            arr[i] = \\'a\\';\\n            return arr.join(\\'\\');\\n        }\\n    }\\n    arr[arr.length - 1] = \\'b\\';\\n    return arr.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2686229,
                "title": "c-easy-0ms-solution-with-explanation-only-simulation",
                "content": "# Intuition\\nAs we have to always replace with least possible character so we will only be replacing by either a or b only . Try to think why for some moment and you will know the reason . \\n(You may ask in comments if you dont get it).\\n\\n# Approach\\nThe Approach is now simple we will traverse string till we dont reach mid or till we dont get other charcter than \\'a\\'.\\nIf We stop before mid that is the character to be replacxed and replace it with a.\\nElse we will replace the last character with b .\\n\\nFor EX : aaaaaaaaaa ,aaacaaa ,\\nwill change into aaaaaaaaab, aaacaab.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n        \\n        if(palindrome.length() == 1)\\n        return \"\";\\n\\n        int i = 0 ; \\n\\n            while(palindrome[i] == \\'a\\' && i< (palindrome.length())/2 )\\n            i++;\\n\\n            if(i == (palindrome.length())/2)\\n            palindrome.back() = \\'b\\';\\n            else\\n            palindrome[i] = \\'a\\';\\n\\n        return palindrome;\\n        \\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n        \\n        if(palindrome.length() == 1)\\n        return \"\";\\n\\n        int i = 0 ; \\n\\n            while(palindrome[i] == \\'a\\' && i< (palindrome.length())/2 )\\n            i++;\\n\\n            if(i == (palindrome.length())/2)\\n            palindrome.back() = \\'b\\';\\n            else\\n            palindrome[i] = \\'a\\';\\n\\n        return palindrome;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686106,
                "title": "python-soln",
                "content": "```\\n\\n    def breakPalindrome(self, p: str) -> str:\\n        n=len(p)\\n        l=list(p)\\n        if n==1:\\n            return \"\"\\n        for i in range(n//2):\\n            if l[i]>\"a\":\\n                l[i]=\"a\"\\n                return \\'\\'.join(map(str, l))\\n        l[-1]=\"b\"\\n        return \\'\\'.join(l)\\n\\t\\t\\n```\\n***Upvote if you got help :-)***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\n    def breakPalindrome(self, p: str) -> str:\\n        n=len(p)\\n        l=list(p)\\n        if n==1:\\n            return \"\"\\n        for i in range(n//2):\\n            if l[i]>\"a\":\\n                l[i]=\"a\"\\n                return \\'\\'.join(map(str, l))\\n        l[-1]=\"b\"\\n        return \\'\\'.join(l)\\n\\t\\t\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2685179,
                "title": "c-short-and-simple-beats-100-tc-o-n",
                "content": "**Please Upvote if you find this helpeful**\\n```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n        if(palindrome.size()<=1)\\n            return \"\";\\n        int n=palindrome.size();\\n        for(int i=0; i<n/2; i++){\\n            if(palindrome[i]!=\\'a\\'){\\n                palindrome[i]=\\'a\\';\\n                return palindrome;\\n            }\\n        }\\n        palindrome[n-1]=\\'b\\';\\n        return palindrome;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n        if(palindrome.size()<=1)\\n            return \"\";\\n        int n=palindrome.size();\\n        for(int i=0; i<n/2; i++){\\n            if(palindrome[i]!=\\'a\\'){\\n                palindrome[i]=\\'a\\';\\n                return palindrome;\\n            }\\n        }\\n        palindrome[n-1]=\\'b\\';\\n        return palindrome;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2684209,
                "title": "simple-c-solution-runtime-6-ms-beats-16-14-memory-6-mb",
                "content": "# Intuition\\nMy first Intuition was to find the inex of frst character using \"Binary Search\" and then replacing the next character in the original string with the previous character. However it didn\\'t proved to be an effective solution. So I came up with this second solution.\\n\\n# Approach\\nIt is basically a greedy approach that checks:\\n1 - If the length of string is greater than 2, it replaces the first character which is not equal to \\'a\\' with \\'a\\'. Example - \"**abc**cba\" here in the bold part, character at 1st index \\'b\\' != \\'a\\' so it replaces with \\'a\\'.\\n2 - if length of string is 2, it replaces the last character with \\'b\\'.(The edge case \\'bb\\' will be handled in step 1!!!).\\n## ***Hope you loved the explaination. If so please upvote my solution.*\\n**\\n# Complexity\\n- Time complexity:\\nTime Complexity is O(n/2) which is O(n);\\n\\n- Space complexity:\\nSpace complexity is O(1). Since no extra space is used by us.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string str){\\n        int len = str.size(), end = len / 2;\\n        for (int i = 0; i < len/2; i++){\\n            if(str[i] != \\'a\\'){\\n                str[i] = \\'a\\';\\n                return str;\\n            }\\n        }\\n        if(len > 1){\\n            str[len - 1] = \\'b\\';\\n            return str;\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string str){\\n        int len = str.size(), end = len / 2;\\n        for (int i = 0; i < len/2; i++){\\n            if(str[i] != \\'a\\'){\\n                str[i] = \\'a\\';\\n                return str;\\n            }\\n        }\\n        if(len > 1){\\n            str[len - 1] = \\'b\\';\\n            return str;\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2684094,
                "title": "easy-to-understand-c-code-short-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string S) {\\n        int N = S.size();\\n        if(N == 1) return \"\";\\n        int i=0, j=N-1;\\n        while(i <= j){\\n            if(S[i] != \\'a\\' && i!=N/2){\\n               S[i] = \\'a\\';\\n               return S;\\n            }\\n            i++, j--;\\n        }\\n        S.back() = \\'b\\';\\n        return S;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string S) {\\n        int N = S.size();\\n        if(N == 1) return \"\";\\n        int i=0, j=N-1;\\n        while(i <= j){\\n            if(S[i] != \\'a\\' && i!=N/2){\\n               S[i] = \\'a\\';\\n               return S;\\n            }\\n            i++, j--;\\n        }\\n        S.back() = \\'b\\';\\n        return S;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683758,
                "title": "c-0ms-easy-and-simple-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string p) {\\n        if(p.size()==1)\\n        {\\n            return \"\";\\n        }\\n        int a=0;\\n        for(char x: p)\\n        {\\n            if(x==\\'a\\') a++;\\n        }\\n        if(a==p.size())\\n            p[p.size()-1]=\\'b\\';\\n        else if(a==p.size()-1 && p.size()&1)\\n        {\\n            if(p[p.size()/2]!=\\'a\\')\\n                p[p.size()-1]=\\'b\\';\\n        }\\n        else\\n        {\\n            for(int i=0;i<p.size()/2+1;i++)\\n            {\\n                if(p[i]!=\\'a\\')\\n                {\\n                    p[i]=\\'a\\';\\n                    break;\\n                }\\n            }\\n        }\\n        return p;\\n    }\\n};\\n```\\nOptimised way for the above approach is to only iterate half of the string and check for character other than \\'a\\'.\\n```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n        if(palindrome.size()==1)\\n        {\\n            return \"\";\\n        }\\n        for(int i=0;i<palindrome.size()/2;i++)\\n        {\\n            if(palindrome[i]!=\\'a\\')\\n               {\\n                   palindrome[i]=\\'a\\';\\n                   return palindrome;\\n               }\\n        }\\n        palindrome[palindrome.size()-1]=\\'b\\';\\n        return palindrome;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string p) {\\n        if(p.size()==1)\\n        {\\n            return \"\";\\n        }\\n        int a=0;\\n        for(char x: p)\\n        {\\n            if(x==\\'a\\') a++;\\n        }\\n        if(a==p.size())\\n            p[p.size()-1]=\\'b\\';\\n        else if(a==p.size()-1 && p.size()&1)\\n        {\\n            if(p[p.size()/2]!=\\'a\\')\\n                p[p.size()-1]=\\'b\\';\\n        }\\n        else\\n        {\\n            for(int i=0;i<p.size()/2+1;i++)\\n            {\\n                if(p[i]!=\\'a\\')\\n                {\\n                    p[i]=\\'a\\';\\n                    break;\\n                }\\n            }\\n        }\\n        return p;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n        if(palindrome.size()==1)\\n        {\\n            return \"\";\\n        }\\n        for(int i=0;i<palindrome.size()/2;i++)\\n        {\\n            if(palindrome[i]!=\\'a\\')\\n               {\\n                   palindrome[i]=\\'a\\';\\n                   return palindrome;\\n               }\\n        }\\n        palindrome[palindrome.size()-1]=\\'b\\';\\n        return palindrome;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683523,
                "title": "easiest-4-line-of-code-optimal",
                "content": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string s) {\\n        string ans = \"\";\\n        int n = s.length();\\n        /* If given string length == 1 then return empty string */\\n        if(n == 1) return ans;\\n        \\n        for(int i = 0;i<n/2;i++){\\n            /* replace with a */\\n            if(s[i] != \\'a\\'){\\n                s[i] = \\'a\\';\\n                return s;\\n            }\\n        }\\n        /* replace last with b \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02 it is done guyz*/\\n        s[n-1] = \\'b\\';\\n        return s;\\n    }\\n};\\n```\\n\\nIf you like it please do Upvote",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string s) {\\n        string ans = \"\";\\n        int n = s.length();\\n        /* If given string length == 1 then return empty string */\\n        if(n == 1) return ans;\\n        \\n        for(int i = 0;i<n/2;i++){\\n            /* replace with a */\\n            if(s[i] != \\'a\\'){\\n                s[i] = \\'a\\';\\n                return s;\\n            }\\n        }\\n        /* replace last with b \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02 it is done guyz*/\\n        s[n-1] = \\'b\\';\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362114,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def breakPalindrome(self, palindrome: str) -> str:\\n        if len(palindrome) == 1:\\n            return \"\"\\n        \\n        for i in range(len(palindrome)//2):\\n            if palindrome[i] != \\'a\\':\\n                return palindrome[:i] + \\'a\\' + palindrome[i+1:]\\n            \\n        return palindrome[:-1] + \\'b\\'\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def breakPalindrome(self, palindrome: str) -> str:\\n        if len(palindrome) == 1:\\n            return \"\"\\n        \\n        for i in range(len(palindrome)//2):\\n            if palindrome[i] != \\'a\\':\\n                return palindrome[:i] + \\'a\\' + palindrome[i+1:]\\n            \\n        return palindrome[:-1] + \\'b\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1481925,
                "title": "easy-clear-solution-python",
                "content": "```\\nclass Solution:\\n    def breakPalindrome(self, p: str) -> str:\\n        if len(p)==1 :\\n            return \"\"\\n        for i in range(len(p)//2):\\n            if p[i] != \\'a\\':\\n                p=p[0:i]+\\'a\\'+p[i+1:]\\n                return p\\n        return p[0:len(p)-1]+\\'b\\'\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def breakPalindrome(self, p: str) -> str:\\n        if len(p)==1 :\\n            return \"\"\\n        for i in range(len(p)//2):\\n            if p[i] != \\'a\\':\\n                p=p[0:i]+\\'a\\'+p[i+1:]\\n                return p\\n        return p[0:len(p)-1]+\\'b\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1481647,
                "title": "c-simple-0ms-6-mb",
                "content": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n        size_t sz = palindrome.size(); \\n        if (sz == 1)\\n            return \"\";\\n        for (size_t i = 0; i < sz/2; i++) {\\n            if (palindrome[i] - \\'a\\' > 0) {\\n                palindrome[i] = \\'a\\';\\n                return palindrome;\\n            }\\n        }\\n        palindrome[sz-1] = \\'b\\';\\n        return palindrome;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n        size_t sz = palindrome.size(); \\n        if (sz == 1)\\n            return \"\";\\n        for (size_t i = 0; i < sz/2; i++) {\\n            if (palindrome[i] - \\'a\\' > 0) {\\n                palindrome[i] = \\'a\\';\\n                return palindrome;\\n            }\\n        }\\n        palindrome[sz-1] = \\'b\\';\\n        return palindrome;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1480806,
                "title": "kotlin-clean-short-solution",
                "content": "```\\nclass Solution {\\n    fun breakPalindrome(palindrome: String): String {\\n        return if (palindrome.length == 1) {\\n            \"\" // It\\'s impassible to break palindrome when length == 1\\n        } else {\\n            palindrome.indexOfFirst { it != \\'a\\' }\\n                .takeIf {\\n                    it != -1 && it < palindrome.length / 2\\n                }?.let { index ->\\n                    // If there exist a none \\'a\\' character in the first half, change that character to \\'a\\'\\n                    StringBuilder(palindrome).also { it[index] = \\'a\\' }.toString()\\n                } ?: run { \\n                    // Else change the last character to \\'b\\'\\n                    StringBuilder(palindrome).also { it[it.lastIndex] = \\'b\\' }.toString()\\n                }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun breakPalindrome(palindrome: String): String {\\n        return if (palindrome.length == 1) {\\n            \"\" // It\\'s impassible to break palindrome when length == 1\\n        } else {\\n            palindrome.indexOfFirst { it != \\'a\\' }\\n                .takeIf {\\n                    it != -1 && it < palindrome.length / 2\\n                }?.let { index ->\\n                    // If there exist a none \\'a\\' character in the first half, change that character to \\'a\\'\\n                    StringBuilder(palindrome).also { it[index] = \\'a\\' }.toString()\\n                } ?: run { \\n                    // Else change the last character to \\'b\\'\\n                    StringBuilder(palindrome).also { it[it.lastIndex] = \\'b\\' }.toString()\\n                }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1284864,
                "title": "60ms-javascript-solution",
                "content": "```\\nvar breakPalindrome = function(palindrome) {\\n    if (palindrome.length === 1) return \\'\\';\\n    let acount=0;\\n    \\n    for (let i=0; i<palindrome.length; i++) {\\n        if (palindrome[i] === \\'a\\') acount++;\\n    }\\n    \\n    if (palindrome.length-1 === acount) return palindrome.slice(0, palindrome.length-1)+\\'b\\';\\n    for (let i=0;i<palindrome.length; i++) {\\n        if (palindrome[i] !== \\'a\\') {\\n            return palindrome.slice(0, i)+\\'a\\'+palindrome.slice(i+1);\\n        }\\n    }\\n    return palindrome.slice(0, palindrome.length-1)+\\'b\\';\\n};\\n```\\n\\nTime Complexity: O(n)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar breakPalindrome = function(palindrome) {\\n    if (palindrome.length === 1) return \\'\\';\\n    let acount=0;\\n    \\n    for (let i=0; i<palindrome.length; i++) {\\n        if (palindrome[i] === \\'a\\') acount++;\\n    }\\n    \\n    if (palindrome.length-1 === acount) return palindrome.slice(0, palindrome.length-1)+\\'b\\';\\n    for (let i=0;i<palindrome.length; i++) {\\n        if (palindrome[i] !== \\'a\\') {\\n            return palindrome.slice(0, i)+\\'a\\'+palindrome.slice(i+1);\\n        }\\n    }\\n    return palindrome.slice(0, palindrome.length-1)+\\'b\\';\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1228221,
                "title": "easy-c-solution-faster-than-100-with-simplest-logic",
                "content": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n        if(palindrome.length() == 1) return \"\";\\n        \\n        for(int i =0; i < palindrome.length() / 2 ; i++){\\n            if (palindrome[i] != \\'a\\') {\\n                palindrome[i] = \\'a\\';\\n                return palindrome;\\n            }\\n        }\\n        palindrome[palindrome.length()-1] = \\'b\\';\\n        return palindrome;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n        if(palindrome.length() == 1) return \"\";\\n        \\n        for(int i =0; i < palindrome.length() / 2 ; i++){\\n            if (palindrome[i] != \\'a\\') {\\n                palindrome[i] = \\'a\\';\\n                return palindrome;\\n            }\\n        }\\n        palindrome[palindrome.length()-1] = \\'b\\';\\n        return palindrome;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 489722,
                "title": "c-greedy",
                "content": "1) First I try to insert a character as small as possible to make it non - palindrome. For that I greedily start from first index and the smallest possible character till the current character.\\n\\n2) If this is a non-palindrome now, I just return it.\\n\\n3) Even after trying this, if it is not a non - palindrome, I try to insert a character greater than the current character. Now, since it would become a larger string, I start from the last index.\\n\\n4) Even after all this, it is not possible to make it a non-palindrome, return \"\"\\n\\n```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string s) {\\n        int n = s.size(); \\n        for(int i = 0; i < s.size(); i++) {\\n            char temp = s[i];\\n            for(char c = \\'a\\'; c < temp; c++) {\\n                s[i] = c;\\n                if(s[i] != s[n - 1 - i]) {\\n                    return s;\\n                }\\n            }\\n            s[i] = temp;\\n        }\\n        for(int i = s.size() - 1; i >= 0; i--) {\\n            char temp = s[i];\\n            for(char c = temp; c <= \\'z\\'; c++) {\\n                s[i] = c;\\n                if(s[i] != s[n - 1 - i]) {\\n                    return s;\\n                }\\n            }\\n            s[i] = temp;\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string s) {\\n        int n = s.size(); \\n        for(int i = 0; i < s.size(); i++) {\\n            char temp = s[i];\\n            for(char c = \\'a\\'; c < temp; c++) {\\n                s[i] = c;\\n                if(s[i] != s[n - 1 - i]) {\\n                    return s;\\n                }\\n            }\\n            s[i] = temp;\\n        }\\n        for(int i = s.size() - 1; i >= 0; i--) {\\n            char temp = s[i];\\n            for(char c = temp; c <= \\'z\\'; c++) {\\n                s[i] = c;\\n                if(s[i] != s[n - 1 - i]) {\\n                    return s;\\n                }\\n            }\\n            s[i] = temp;\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928601,
                "title": "beats-100-very-easy-beginner-friendly-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- first we convert String to a char Array\\n- check if length of the char Array is less than 2 then return an empty String\\n- iterate upto length/2 and check whether the character at index i is not equal to \\'a\\' if condition satisfied then the character at that index is set to \\'a\\' which makes the string non palindrome and it will be lexicographically smallest and return it after converting it to string\\n- if for loop ends means all the character upto length/2 is a and by changing the middle element does make it non palindrome so to make it non palindrome we make the last charcter to b which is lexicographically smaller\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        char[] cstr=palindrome.toCharArray();\\n        if(cstr.length<2)\\n            return \"\";\\n        for(int i=0;i<cstr.length/2;i++)\\n        {\\n            if(cstr[i]!=\\'a\\')\\n            {\\n                cstr[i]=\\'a\\';\\n                return String.valueOf(cstr);\\n            }\\n\\n        }\\n\\n        cstr[cstr.length-1]=\\'b\\';\\n        return String.valueOf(cstr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        char[] cstr=palindrome.toCharArray();\\n        if(cstr.length<2)\\n            return \"\";\\n        for(int i=0;i<cstr.length/2;i++)\\n        {\\n            if(cstr[i]!=\\'a\\')\\n            {\\n                cstr[i]=\\'a\\';\\n                return String.valueOf(cstr);\\n            }\\n\\n        }\\n\\n        cstr[cstr.length-1]=\\'b\\';\\n        return String.valueOf(cstr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831737,
                "title": "easy-to-understand-100-faster",
                "content": "- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nUsing Constant space \\n# Code\\n```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n        int len = palindrome.size();\\n        if(len == 1){\\n            return \"\";\\n        }\\n        for(int i=0; i<len/2; i++){\\n            if(palindrome[i] != \\'a\\'){\\n                palindrome[i] = \\'a\\';\\n                return palindrome;\\n            }\\n        }\\n        palindrome[len-1] = \\'b\\';\\n        return palindrome;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n        int len = palindrome.size();\\n        if(len == 1){\\n            return \"\";\\n        }\\n        for(int i=0; i<len/2; i++){\\n            if(palindrome[i] != \\'a\\'){\\n                palindrome[i] = \\'a\\';\\n                return palindrome;\\n            }\\n        }\\n        palindrome[len-1] = \\'b\\';\\n        return palindrome;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2748687,
                "title": "java-greedy-solution-100-faster-code",
                "content": "\\n```\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\n\\n# Complexity\\n- Time complexity:\\n O(N)\\n\\n- Space complexity:\\n O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        int n = palindrome.length();\\n        if (n == 1) return \"\";\\n\\n        StringBuilder sb = new StringBuilder(palindrome);\\n        boolean flag = true;\\n\\n        for (int i = 0; i < n/2; i++) {\\n            if (palindrome.charAt(i) != \\'a\\') {\\n                sb.setCharAt(i, \\'a\\');\\n                flag = false;\\n                break;\\n            }\\n        }\\n        \\n        if(flag){\\n            sb.setCharAt(n - 1, \\'b\\');\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```\n```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        int n = palindrome.length();\\n        if (n == 1) return \"\";\\n\\n        StringBuilder sb = new StringBuilder(palindrome);\\n        boolean flag = true;\\n\\n        for (int i = 0; i < n/2; i++) {\\n            if (palindrome.charAt(i) != \\'a\\') {\\n                sb.setCharAt(i, \\'a\\');\\n                flag = false;\\n                break;\\n            }\\n        }\\n        \\n        if(flag){\\n            sb.setCharAt(n - 1, \\'b\\');\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2697083,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def breakPalindrome(self, palindrome: str) -> str:\\n        if len(palindrome) < 2: return \"\"\\n        for i in range(len(palindrome)//2):\\n            if palindrome[i] != \\'a\\':\\n                return palindrome[:i] +\\'a\\' +palindrome[i+1:]\\n        return palindrome[:-1]+\\'b\\'\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def breakPalindrome(self, palindrome: str) -> str:\\n        if len(palindrome) < 2: return \"\"\\n        for i in range(len(palindrome)//2):\\n            if palindrome[i] != \\'a\\':\\n                return palindrome[:i] +\\'a\\' +palindrome[i+1:]\\n        return palindrome[:-1]+\\'b\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687643,
                "title": "python-simple-and-fast-beats-95-7",
                "content": "```\\nclass Solution:\\n    def breakPalindrome(self, palindrome: str) -> str:\\n        if len(palindrome)==1:     # Only case where we cannot replace a character to make it \"not a plaindrome\"\\n            return \\'\\'\\n\\n        palindrome = list(palindrome)\\n        for i in range(len(palindrome)//2):      # We only have to check for half of the string because the rest will be exactly the same\\n            if palindrome[i] != \\'a\\':         #  First character that is not \\'a\\' will be replace with \\'a\\' to give lexicographically smallest\\n                palindrome[i] = \\'a\\'\\n                return \\'\\'.join(palindrome)          # Here we can also use string slicing, but using a list then .join() is faster \\n        else:\\n\\t\\t\\'\\'\\' Suppose we are not able to find a character that is not \\'a\\'  in the first half Ex: aaabaaa. Then simply change the last character with \\'b\\' \\'\\'\\'\\n            palindrome[-1]=\\'b\\'      \\n                \\n        return \\'\\'.join(palindrome)\\n            \\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def breakPalindrome(self, palindrome: str) -> str:\\n        if len(palindrome)==1:     # Only case where we cannot replace a character to make it \"not a plaindrome\"\\n            return \\'\\'\\n\\n        palindrome = list(palindrome)\\n        for i in range(len(palindrome)//2):      # We only have to check for half of the string because the rest will be exactly the same\\n            if palindrome[i] != \\'a\\':         #  First character that is not \\'a\\' will be replace with \\'a\\' to give lexicographically smallest\\n                palindrome[i] = \\'a\\'\\n                return \\'\\'.join(palindrome)          # Here we can also use string slicing, but using a list then .join() is faster \\n        else:\\n\\t\\t\\'\\'\\' Suppose we are not able to find a character that is not \\'a\\'  in the first half Ex: aaabaaa. Then simply change the last character with \\'b\\' \\'\\'\\'\\n            palindrome[-1]=\\'b\\'      \\n                \\n        return \\'\\'.join(palindrome)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687520,
                "title": "python3-o-n-2-time-o-n-space-with-comments",
                "content": "```\\nclass Solution:\\n\\n# intuition is simple\\n# the moment we encounter a character other than an \\'a\\', replace it with \\'a\\' (to make it lexographically shortest)\\n# if we do not find any other character, it means it\\'s all filled with \\'a\\'s\\n# so the next shortest string then comes when we replace the last character with a \\'b\\'\\n\\n    def breakPalindrome(self, palindrome: str) -> str:\\n        n = len(palindrome)\\n        if n == 1:\\n            return \"\"\\n        \\n\\t\\t# \\'flag\\' to check if we encounter an \\'a\\'\\n\\t\\t# also, we want to iterate through half the string, leaving the middle element if length is odd\\n\\t\\t# in each iteration, we fill the resultant array from both the ends\\n\\t\\t# rest is intuitive\\n\\t\\t\\n        res, flag = [palindrome[n // 2]] * n, 0\\n        for i in range(n // 2):\\n            if not flag and palindrome[i] != \\'a\\':\\n                res[i] = \\'a\\'\\n                flag = 1\\n            else:\\n                res[i] = palindrome[i]\\n            res[n - i - 1] = palindrome[i]\\n            \\n        if not flag:\\n            res[-1] = \"b\"\\n        return \"\".join(res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\n# intuition is simple\\n# the moment we encounter a character other than an \\'a\\', replace it with \\'a\\' (to make it lexographically shortest)\\n# if we do not find any other character, it means it\\'s all filled with \\'a\\'s\\n# so the next shortest string then comes when we replace the last character with a \\'b\\'\\n\\n    def breakPalindrome(self, palindrome: str) -> str:\\n        n = len(palindrome)\\n        if n == 1:\\n            return \"\"\\n        \\n\\t\\t# \\'flag\\' to check if we encounter an \\'a\\'\\n\\t\\t# also, we want to iterate through half the string, leaving the middle element if length is odd\\n\\t\\t# in each iteration, we fill the resultant array from both the ends\\n\\t\\t# rest is intuitive\\n\\t\\t\\n        res, flag = [palindrome[n // 2]] * n, 0\\n        for i in range(n // 2):\\n            if not flag and palindrome[i] != \\'a\\':\\n                res[i] = \\'a\\'\\n                flag = 1\\n            else:\\n                res[i] = palindrome[i]\\n            res[n - i - 1] = palindrome[i]\\n            \\n        if not flag:\\n            res[-1] = \"b\"\\n        return \"\".join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687495,
                "title": "c-solution-0-ms-faster-than-100-of-submissions",
                "content": "```\\nclass Solution {\\n  public:\\n    string breakPalindrome(string palindrome) {\\n      set < char > s;\\n      int n = palindrome.size();\\n      if (n == 1) return \"\";\\n      for (int i = 0; i < (palindrome.size() + 1) / 2; i++) {\\n        s.insert(palindrome[i]);\\n      }\\n      if (s.size() == 1) {\\n        if (palindrome[0] == \\'a\\') palindrome[n - 1] = \\'b\\';\\n        else palindrome[0] = \\'a\\';\\n        return palindrome;\\n      }\\n      int cnt = 0;\\n      for (int i = 0; i < palindrome.size(); i++) {\\n        if (palindrome[i] != \\'a\\') {\\n          if (i != n / 2)\\n            palindrome[i] = \\'a\\';\\n          else {\\n            for (int k = i + 1; k < n; k++) {\\n              if (palindrome[k] != \\'a\\') {\\n                palindrome[n / 2] = \\'a\\';\\n                cnt++;\\n                break;\\n              }\\n            }\\n            if (!cnt) palindrome[n - 1] = \\'b\\';\\n          }\\n          break;\\n        }\\n      }\\n      return palindrome;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n  public:\\n    string breakPalindrome(string palindrome) {\\n      set < char > s;\\n      int n = palindrome.size();\\n      if (n == 1) return \"\";\\n      for (int i = 0; i < (palindrome.size() + 1) / 2; i++) {\\n        s.insert(palindrome[i]);\\n      }\\n      if (s.size() == 1) {\\n        if (palindrome[0] == \\'a\\') palindrome[n - 1] = \\'b\\';\\n        else palindrome[0] = \\'a\\';\\n        return palindrome;\\n      }\\n      int cnt = 0;\\n      for (int i = 0; i < palindrome.size(); i++) {\\n        if (palindrome[i] != \\'a\\') {\\n          if (i != n / 2)\\n            palindrome[i] = \\'a\\';\\n          else {\\n            for (int k = i + 1; k < n; k++) {\\n              if (palindrome[k] != \\'a\\') {\\n                palindrome[n / 2] = \\'a\\';\\n                cnt++;\\n                break;\\n              }\\n            }\\n            if (!cnt) palindrome[n - 1] = \\'b\\';\\n          }\\n          break;\\n        }\\n      }\\n      return palindrome;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687318,
                "title": "c-simple-solution-by-only-checking-for-2-chars-a-b",
                "content": "class Solution {\\npublic:\\n    string breakPalindrome(string p) {\\n        int n = p.size();\\n        if(n==1) return \"\";\\n        for(int i = 0; i < n/2; i++){\\n            if (p[i]!=\\'a\\') {\\n                p[i]=\\'a\\';\\n                return p;\\n            }\\n        }\\n        for(int i = 0; i < n/2; i++){\\n            if (p[n-1-i]!=\\'b\\') {\\n                p[n-1-i]=\\'b\\';\\n                return p;\\n            }\\n        }\\n        return \"\";\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string breakPalindrome(string p) {\\n        int n = p.size();\\n        if(n==1) return \"\";\\n        for(int i = 0; i < n/2; i++){\\n            if (p[i]!=\\'a\\') {\\n                p[i]=\\'a\\';\\n                return p;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2687311,
                "title": "c-solution-beats-100-in-time-python-solution-greedy-solution",
                "content": "*Please upvote to motivate me to write more solutions*\\n\\n# Code [C++ beats 100% & 70%]\\n```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n        \\n        for (int i=0; i<palindrome.length()/2; i++) {\\n            if (palindrome[i] != \\'a\\') {\\n                palindrome[i] = \\'a\\';\\n                return palindrome;\\n            }\\n        }\\n\\n        palindrome[palindrome.length()-1]=\\'b\\';\\n        return palindrome.length() > 1 ? palindrome : \"\";\\n    }\\n};\\n```\\n\\n# Code [Python beats 21% & 61%]\\n\\n```\\nclass Solution:\\n    def breakPalindrome(self, palindrome: str) -> str:\\n        palindrome=list(palindrome)\\n        for i in range(int(len(palindrome)/2)):\\n            if palindrome[i]!=\"a\":\\n                palindrome[i]=\\'a\\'\\n                return \"\".join(palindrome)\\n        palindrome[len(palindrome)-1] = \\'b\\'\\n        if len(palindrome)>1:\\n            return \"\".join(palindrome)\\n        else:\\n            return \"\"\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n        \\n        for (int i=0; i<palindrome.length()/2; i++) {\\n            if (palindrome[i] != \\'a\\') {\\n                palindrome[i] = \\'a\\';\\n                return palindrome;\\n            }\\n        }\\n\\n        palindrome[palindrome.length()-1]=\\'b\\';\\n        return palindrome.length() > 1 ? palindrome : \"\";\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def breakPalindrome(self, palindrome: str) -> str:\\n        palindrome=list(palindrome)\\n        for i in range(int(len(palindrome)/2)):\\n            if palindrome[i]!=\"a\":\\n                palindrome[i]=\\'a\\'\\n                return \"\".join(palindrome)\\n        palindrome[len(palindrome)-1] = \\'b\\'\\n        if len(palindrome)>1:\\n            return \"\".join(palindrome)\\n        else:\\n            return \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687217,
                "title": "easy-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String breakPalindrome(String p) {\\n        int k=p.length();\\n        if(k==1)\\n            return \"\";\\n        for(int i=0;i<k/2;i++)\\n        {\\n            if(p.charAt(i)!=\\'a\\')\\n            {\\n                return p.substring(0,i)+\"a\"+p.substring(i+1);\\n            }\\n        }\\n        return p.substring(0,k-1)+\"b\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String breakPalindrome(String p) {\\n        int k=p.length();\\n        if(k==1)\\n            return \"\";\\n        for(int i=0;i<k/2;i++)\\n        {\\n            if(p.charAt(i)!=\\'a\\')\\n            {\\n                return p.substring(0,i)+\"a\"+p.substring(i+1);\\n            }\\n        }\\n        return p.substring(0,k-1)+\"b\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686878,
                "title": "easiest-java-solution-simple-logic-0ms-faster-than-100-fully-commented-code",
                "content": "\\tclass Solution {\\n\\t\\tpublic String breakPalindrome(String palindrome) {\\n\\t\\t\\t// If the string contains only one char then we will simply return blank string \\n\\t\\t\\tif(palindrome.length()==1) return \"\";\\n\\t\\t\\tStringBuilder answer = new StringBuilder(palindrome);\\n\\t\\t\\t// If the string contains all the \\'a\\'s or only one char other than \\'a\\' which is in the middle,\\n\\t\\t\\t//then we can simply change the last char to \\'b\\'. This will make the string non-palindromic \\n\\t\\t\\t//and will be lexiographically smallest.\\n\\t\\t\\tif(isThisStringAnEdgeCase(palindrome)) {\\n\\t\\t\\t\\tanswer.setCharAt(palindrome.length()-1 , \\'b\\');\\n\\t\\t\\t} \\n\\t\\t\\t// Here we will simply find the first char which is not \\'a\\', convert it to \\'a\\' and the string will become non-palindromic.\\n\\t\\t\\telse {\\n\\t\\t\\t\\tfor(int i=0;i<answer.length();i++) {\\n\\t\\t\\t\\t\\tif(answer.charAt(i)!=\\'a\\') {\\n\\t\\t\\t\\t\\t\\tanswer.replace(i,i+1,\"a\");\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}   \\n\\t\\t\\t}\\n\\t\\t\\treturn  answer.toString();\\n\\t\\t}\\n\\n\\t\\t/**\\n\\t\\t* This method will return true if every chacter is \\'a\\' or if the string contains only one \\n\\t\\t* character that is other than \\'a\\' and it\\'s placed in the middle.\\n\\t\\t* You can choose a better name for the method ;)\\n\\t\\t*/\\n\\t\\tprivate boolean isThisStringAnEdgeCase(String palindrome) {\\n\\t\\t\\tint start = 0;\\n\\t\\t\\tint end = palindrome.length()-1;\\n\\t\\t\\twhile(start<end) {\\n\\t\\t\\t\\tif(palindrome.charAt(start)!=\\'a\\' || palindrome.charAt(end)!=\\'a\\') {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstart++;\\n\\t\\t\\t\\tend--;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic String breakPalindrome(String palindrome) {\\n\\t\\t\\t// If the string contains only one char then we will simply return blank string \\n\\t\\t\\tif(palindrome.length()==1) return \"\";\\n\\t\\t\\tStringBuilder answer = new StringBuilder(palindrome);\\n\\t\\t\\t// If the string contains all the \\'a\\'s or only one char other than \\'a\\' which is in the middle,\\n\\t\\t\\t//then we can simply change the last char to \\'b\\'. This will make the string non-palindromic \\n\\t\\t\\t//and will be lexiographically smallest.\\n\\t\\t\\tif(isThisStringAnEdgeCase(palindrome)) {\\n\\t\\t\\t\\tanswer.setCharAt(palindrome.length()-1 , \\'b\\');\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2686856,
                "title": "pythonic-linear-solution",
                "content": "```\\nclass Solution:\\n    def breakPalindrome(self, palindrome: str) -> str:\\n        \\n        if len(palindrome)==1:\\n            return \"\"\\n\\n        m = len(palindrome)//2\\n        \\n        for ch in range(0,m):\\n            if palindrome[ch] != \\'a\\':\\n                return  palindrome[0:ch]+\\'a\\'+palindrome[ch+1:]\\n        return palindrome[:-1]+\\'b\\'\\n\\t\\t```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def breakPalindrome(self, palindrome: str) -> str:\\n        \\n        if len(palindrome)==1:\\n            return \"\"\\n\\n        m = len(palindrome)//2\\n        \\n        for ch in range(0,m):\\n            if palindrome[ch] != \\'a\\':\\n                return  palindrome[0:ch]+\\'a\\'+palindrome[ch+1:]\\n        return palindrome[:-1]+\\'b\\'\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2686794,
                "title": "c-easy-approch-solution",
                "content": "class Solution {\\npublic:\\n    string breakPalindrome(string p)\\n    {\\n        if(p.size()<=1)\\n            return \"\";\\n        for(int i=0;i<p.size()/2;i++)\\n        {\\n            if(p[i]!=\\'a\\')\\n            {\\n                p[i]=\\'a\\';\\n                return p;\\n                break;\\n            }\\n        }\\n        p[p.size()-1]=\\'b\\';\\n        return p;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string breakPalindrome(string p)\\n    {\\n        if(p.size()<=1)\\n            return \"\";\\n        for(int i=0;i<p.size()/2;i++)\\n        {\\n            if(p[i]!=\\'a\\')\\n            {\\n                p[i]=\\'a\\';\\n                return p;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2686762,
                "title": "c-simple-easy-concise-solution",
                "content": "class Solution {\\npublic:\\n    string breakPalindrome(string palindrome)\\n    {\\n        if(palindrome.length()<=1)\\n            return \"\";\\n        for(int i=0;i<palindrome.size()/2;i++)\\n        {\\n            if(palindrome[i]!=\\'a\\')\\n            {\\n                palindrome[i]=\\'a\\';\\n                return palindrome;\\n                break;\\n            }\\n        }\\n        palindrome[palindrome.size()-1]=\\'b\\';\\n        return palindrome;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string breakPalindrome(string palindrome)\\n    {\\n        if(palindrome.length()<=1)\\n            return \"\";\\n        for(int i=0;i<palindrome.size()/2;i++)\\n        {\\n            if(palindrome[i]!=\\'a\\')\\n            {\\n                palindrome[i]=\\'a\\';\\n                return palindrome;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2686410,
                "title": "python-solution-stop-overcomplicating-it-kiss",
                "content": "I\\'ve seen so many overly complex python solutions here - figured it was time to break it down simply.\\n1) If there is only one character, we cannot make it not a palindrome, so just return \"\" (the for loop is skipped since ```1 // 2``` is 0)\\n2) Go through the first half of the palindrome and find the first character that is not equal to \\'a\\'. Using integer division ensures that we don\\'t check the middle character of an odd-lengthed palindrome (since replacing the middle character would never change it into a non-palindrome).\\n3) If a non-a character is found, replace it with an \\'a\\' and return the string\\n4) Otherwise, the lexicographically smallest correction we can make is to change the last character to a \\'b\\' (since we already know that all other characters are \\'a\\'s)\\n\\n```\\ndef breakPalindrome(self, palindrome: str) -> str:\\n    for i in range(len(palindrome) // 2):\\n        if palindrome[i] != \\'a\\':\\n            return palindrome[:i] + \\'a\\' + palindrome[i+1:]\\n    return \"\" if len(palindrome) == 1 else palindrome[:-1] + \\'b\\'\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```1 // 2```\n```\\ndef breakPalindrome(self, palindrome: str) -> str:\\n    for i in range(len(palindrome) // 2):\\n        if palindrome[i] != \\'a\\':\\n            return palindrome[:i] + \\'a\\' + palindrome[i+1:]\\n    return \"\" if len(palindrome) == 1 else palindrome[:-1] + \\'b\\'\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2686331,
                "title": "c-stringbuilder",
                "content": "**Please upvote if my solution was helpful ;)**\\n```\\npublic class Solution {\\n    public string BreakPalindrome(string palindrome) \\n\\t{\\n        \\n        int pLength = palindrome.Length; \\n        if(pLength == 1) return \"\";\\n        var sb = new StringBuilder(palindrome);\\n        for(int i=0; i < pLength/2; i++)\\n\\t\\t{\\n            if(palindrome[i]!=\\'a\\')\\n\\t\\t\\t{             \\n                sb[i] = \\'a\\';\\n                return sb.ToString();\\n            }\\n        }               \\n\\t\\tsb[pLength-1] = \\'b\\';\\n\\t\\treturn sb.ToString();        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string BreakPalindrome(string palindrome) \\n\\t{\\n        \\n        int pLength = palindrome.Length; \\n        if(pLength == 1) return \"\";\\n        var sb = new StringBuilder(palindrome);\\n        for(int i=0; i < pLength/2; i++)\\n\\t\\t{\\n            if(palindrome[i]!=\\'a\\')\\n\\t\\t\\t{             \\n                sb[i] = \\'a\\';\\n                return sb.ToString();\\n            }\\n        }               \\n\\t\\tsb[pLength-1] = \\'b\\';\\n\\t\\treturn sb.ToString();        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686203,
                "title": "c-golang-both-faster-than-100",
                "content": "Golang:\\n```\\nfunc breakPalindrome(s string) string {\\n    if len(s)==1{\\n        return \"\"\\n    }\\n    for i:=0; i<len(s)/2; i++ {\\n        if s[i]!=\\'a\\' {\\n            s=s[:i]+\"a\"+s[i+1:]\\n            return s\\n        }\\n    }\\n    s=s[:len(s)-1]+\"b\"\\n    return s\\n}\\n```\\n\\nC++:\\n```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string p) {\\n        if (p.size()==1) return \"\";\\n        for (int i=0; i<p.size()/2; i++){\\n            if (p[i]!=\\'a\\'){\\n                p[i]=\\'a\\';\\n                return p;\\n            }\\n        }\\n        p.end()[-1]=\\'b\\';\\n        return p;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Go"
                ],
                "code": "```\\nfunc breakPalindrome(s string) string {\\n    if len(s)==1{\\n        return \"\"\\n    }\\n    for i:=0; i<len(s)/2; i++ {\\n        if s[i]!=\\'a\\' {\\n            s=s[:i]+\"a\"+s[i+1:]\\n            return s\\n        }\\n    }\\n    s=s[:len(s)-1]+\"b\"\\n    return s\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string p) {\\n        if (p.size()==1) return \"\";\\n        for (int i=0; i<p.size()/2; i++){\\n            if (p[i]!=\\'a\\'){\\n                p[i]=\\'a\\';\\n                return p;\\n            }\\n        }\\n        p.end()[-1]=\\'b\\';\\n        return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2685914,
                "title": "java-100-0ms-simple-approach-w-video-explanation",
                "content": "*Please **Upvote** if you find this Explanation helpful*\\n\\n**Video Explanation**\\n[Break a Palindrome | YouTube](https://www.youtube.com/watch?v=dIcNa1Oi8xU&feature=youtu.be)\\n\\n**Java Solution**\\n```\\n//0ms\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        if(palindrome.length() <= 1)\\n            return \"\";\\n        char[] ar = palindrome.toCharArray();\\n        \\n        for(int i=0;i<ar.length/2;i++)\\n            if(ar[i] != \\'a\\'){\\n                ar[i] = \\'a\\';\\n                return String.valueOf(ar);\\n            }\\n        \\n        ar[ar.length -1] = \\'b\\';\\n        return String.valueOf(ar);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//0ms\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        if(palindrome.length() <= 1)\\n            return \"\";\\n        char[] ar = palindrome.toCharArray();\\n        \\n        for(int i=0;i<ar.length/2;i++)\\n            if(ar[i] != \\'a\\'){\\n                ar[i] = \\'a\\';\\n                return String.valueOf(ar);\\n            }\\n        \\n        ar[ar.length -1] = \\'b\\';\\n        return String.valueOf(ar);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2685528,
                "title": "c-simple-iteration-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n        int n = palindrome.size();\\n        if(n <= 1) return \"\";\\n        \\n        for(int i=0;i<n/2;i++){\\n            if(palindrome[i] != \\'a\\'){\\n                palindrome[i] = \\'a\\';\\n                return palindrome;\\n            }\\n        }\\n        palindrome[n-1] = \\'b\\';\\n        return palindrome;\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n        int n = palindrome.size();\\n        if(n <= 1) return \"\";\\n        \\n        for(int i=0;i<n/2;i++){\\n            if(palindrome[i] != \\'a\\'){\\n                palindrome[i] = \\'a\\';\\n                return palindrome;\\n            }\\n        }\\n        palindrome[n-1] = \\'b\\';\\n        return palindrome;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2685519,
                "title": "python-elegant-short",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n)\\n    Memory: O(n)\\n    \"\"\"\\n\\n    def breakPalindrome(self, palindrome: str) -> str:\\n        if len(palindrome) == 1:\\n            return \\'\\'\\n\\n        n = len(palindrome)\\n        letters = list(palindrome)\\n\\n        for i in range(n // 2):\\n            if letters[i] > \\'a\\':\\n                letters[i] = \\'a\\'\\n                break\\n        else:\\n            letters[-1] = \\'b\\'\\n\\n        return \\'\\'.join(letters)\\n```\\n\\nIf you like this solution remember to **upvote it** to let me know.\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n)\\n    Memory: O(n)\\n    \"\"\"\\n\\n    def breakPalindrome(self, palindrome: str) -> str:\\n        if len(palindrome) == 1:\\n            return \\'\\'\\n\\n        n = len(palindrome)\\n        letters = list(palindrome)\\n\\n        for i in range(n // 2):\\n            if letters[i] > \\'a\\':\\n                letters[i] = \\'a\\'\\n                break\\n        else:\\n            letters[-1] = \\'b\\'\\n\\n        return \\'\\'.join(letters)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2685363,
                "title": "java-100-greedy-o-n-easy",
                "content": "```\\nclass Solution {\\n    public String breakPalindrome(String s) {\\n        \\n        int l=s.length();\\n        if(l==1)\\n            return(\"\");\\n        \\n        char ch[]=s.toCharArray();\\n        for(int i=0;i<ch.length/2;i++)\\n        {\\n          \\n            if(ch[i]!=\\'a\\')\\n            {\\n                ch[i]=\\'a\\';\\n                return(String.valueOf(ch));\\n            }\\n        }\\n        \\n            ch[l-1]++;\\n              return(String.valueOf(ch));\\n     \\n      \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public String breakPalindrome(String s) {\\n        \\n        int l=s.length();\\n        if(l==1)\\n            return(\"\");\\n        \\n        char ch[]=s.toCharArray();\\n        for(int i=0;i<ch.length/2;i++)\\n        {\\n          \\n            if(ch[i]!=\\'a\\')\\n            {\\n                ch[i]=\\'a\\';\\n                return(String.valueOf(ch));\\n            }\\n        }\\n        \\n            ch[l-1]++;\\n              return(String.valueOf(ch));\\n     \\n      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2685304,
                "title": "java-hindi-faster-than-100",
                "content": "```\\nclass Solution {\\n    public String breakPalindrome(String s) {\\n        int len = s.length();\\n        StringBuilder sb = new StringBuilder(s);\\n        if(len<=1) {\\n            return \"\";\\n        }\\n        // since its a pallindrome, we will check for only half string\\n        // agar odd h to len/2 , even hai to len/2+1, tak loop chaalo\\n        int endpoint = len%2==0 ? len/2 : (len/2)+1;\\n        // ek variable rakha, jisse pta chle change hua ya nhi\\n        boolean changed = false;\\n            for(int i=0;i<endpoint;i++) {\\n       /*\\n       LOGIC SAMJO\\n       jo bhi string h usme , sabse pehle jo character aa rha, jo \\'a\\' nhi h , usko \\'a\\' krdo, to smallest leographic hoga\\n       */\\n                \\n                if(s.charAt(i)!=\\'a\\') {\\n                    // SPECIAL CASE (read it later neeche padh lo fr aana)\\n                   /*maanlo aabaa input h, ab agar \\'b\\' ko \\'a\\' krdiya, to pallindrome bn gya \\n                    aabaa, lelo isme agar i = endpoint-1,\\n                    endpoint = 5/2+1 = 3;\\n                    i agar aab me 2 pe ho, mtlb \\'b\\' par, endpoint-1==2\\n                    to agar hum \\'b\\' par hai and usse agle char bhi \\'a\\' hai\\n                    and pichle to saare \\'a\\' hai hi, nhi to neeche wala break krdeta naa\\n                    */\\n                    if(i==endpoint-1 && s.charAt(i+1)==\\'a\\') {\\n                        break;\\n                    }\\n                    // \\'a\\' nhi h , a krdo\\n                    sb.setCharAt(i,\\'a\\');\\n                    // a krdiya to change true\\n                    changed = true;\\n                    // ho gya naa change break krdo , aage kyu jaana\\n                    break;\\n                }\\n            }\\n        /* ab agar change nhi hua\\n        to yaa to aaaa, aaa, aabaa, aisa kuch raha hoga,\\n        is case me ya to saare \\'a\\' hai, yaaa fr vo wala case jisme middle element alag h ,\\n        par usko change krde to pallindorme bn jaata, like \\'aabaa\\' me b ko a krdiya to \\'aaaaa\\'\\n        to humnne soch aakhri index pe jo \\'a\\' hai usko \\'b\\' krdo\\n        */\\n        if(!changed) {\\n        if(s.equals(sb.toString())) {\\n            sb.setCharAt(len-1,\\'b\\');\\n        }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String breakPalindrome(String s) {\\n        int len = s.length();\\n        StringBuilder sb = new StringBuilder(s);\\n        if(len<=1) {\\n            return \"\";\\n        }\\n        // since its a pallindrome, we will check for only half string\\n        // agar odd h to len/2 , even hai to len/2+1, tak loop chaalo\\n        int endpoint = len%2==0 ? len/2 : (len/2)+1;\\n        // ek variable rakha, jisse pta chle change hua ya nhi\\n        boolean changed = false;\\n            for(int i=0;i<endpoint;i++) {\\n       /*\\n       LOGIC SAMJO\\n       jo bhi string h usme , sabse pehle jo character aa rha, jo \\'a\\' nhi h , usko \\'a\\' krdo, to smallest leographic hoga\\n       */\\n                \\n                if(s.charAt(i)!=\\'a\\') {\\n                    // SPECIAL CASE (read it later neeche padh lo fr aana)\\n                   /*maanlo aabaa input h, ab agar \\'b\\' ko \\'a\\' krdiya, to pallindrome bn gya \\n                    aabaa, lelo isme agar i = endpoint-1,\\n                    endpoint = 5/2+1 = 3;\\n                    i agar aab me 2 pe ho, mtlb \\'b\\' par, endpoint-1==2\\n                    to agar hum \\'b\\' par hai and usse agle char bhi \\'a\\' hai\\n                    and pichle to saare \\'a\\' hai hi, nhi to neeche wala break krdeta naa\\n                    */\\n                    if(i==endpoint-1 && s.charAt(i+1)==\\'a\\') {\\n                        break;\\n                    }\\n                    // \\'a\\' nhi h , a krdo\\n                    sb.setCharAt(i,\\'a\\');\\n                    // a krdiya to change true\\n                    changed = true;\\n                    // ho gya naa change break krdo , aage kyu jaana\\n                    break;\\n                }\\n            }\\n        /* ab agar change nhi hua\\n        to yaa to aaaa, aaa, aabaa, aisa kuch raha hoga,\\n        is case me ya to saare \\'a\\' hai, yaaa fr vo wala case jisme middle element alag h ,\\n        par usko change krde to pallindorme bn jaata, like \\'aabaa\\' me b ko a krdiya to \\'aaaaa\\'\\n        to humnne soch aakhri index pe jo \\'a\\' hai usko \\'b\\' krdo\\n        */\\n        if(!changed) {\\n        if(s.equals(sb.toString())) {\\n            sb.setCharAt(len-1,\\'b\\');\\n        }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2684927,
                "title": "rust-greedy-with-comments",
                "content": "For strings of length < 2 it is impossible to break the palindrome (as shown in the problem example). For other cases, scan the first half of the string (excluding the midpoint element, if any, since a change to that letter would not break the palindrome), and change the first non-`a` to an `a`, if found. That breaks the palindrome and makes the string as lexicographically small as possible. If not found, the string is only `a`s (except possibly for the midpoint element), and we break the palindrome by changing the last letter to a `b`, i.e. preserving as many initial `a`s as possible.\\n\\nImplementation notes:\\n\\n* Using e.g. `iter_mut` and `last` to avoid manual indexing.\\n* Since input is ASCII, we can use bytes to represent characters, and avoid the overhead of UTF-8 parsing.\\n\\n```\\nimpl Solution {\\n    pub fn break_palindrome(palindrome: String) -> String {\\n        let n = palindrome.len();\\n        if n < 2 {\\n            String::new()\\n        } else {\\n            let mut palindrome = palindrome.as_bytes().to_vec();\\n            match palindrome.iter_mut().take(n/2).find(|b| **b != b\\'a\\') {\\n                Some(b) => *b = b\\'a\\',\\n                None => *palindrome.last_mut().unwrap() = b\\'b\\',\\n            }\\n            palindrome.into_iter().map(|b| b as char).collect()\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn break_palindrome(palindrome: String) -> String {\\n        let n = palindrome.len();\\n        if n < 2 {\\n            String::new()\\n        } else {\\n            let mut palindrome = palindrome.as_bytes().to_vec();\\n            match palindrome.iter_mut().take(n/2).find(|b| **b != b\\'a\\') {\\n                Some(b) => *b = b\\'a\\',\\n                None => *palindrome.last_mut().unwrap() = b\\'b\\',\\n            }\\n            palindrome.into_iter().map(|b| b as char).collect()\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2684857,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        if(palindrome.length()==1)\\n            return \"\";\\n        char[] a=palindrome.toCharArray();boolean flag=true;\\n        for(int i=0;i<a.length/2;i++)\\n            if(a[i]!=\\'a\\'){\\n                a[i]=\\'a\\';\\n                flag=false;\\n                break;\\n            }\\n        if(flag==true)\\n            a[a.length-1]=\\'b\\';\\n        return new String(a);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        if(palindrome.length()==1)\\n            return \"\";\\n        char[] a=palindrome.toCharArray();boolean flag=true;\\n        for(int i=0;i<a.length/2;i++)\\n            if(a[i]!=\\'a\\'){\\n                a[i]=\\'a\\';\\n                flag=false;\\n                break;\\n            }\\n        if(flag==true)\\n            a[a.length-1]=\\'b\\';\\n        return new String(a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2684724,
                "title": "most-easy-c-intuitive-smallest-solution",
                "content": "* Inorder to get the smallest lexographical string, the simple Intuition would be that  we will  convert the first non-\\'a\\' character to \\'a\\' which does not have \\'a\\' on its palindrome corners (i.e at start and end). so that it both does not become \\'a\\' this is how we will be able to obtain smallest break palindrome.\\n* One of the edge case would what if we have string which contains only \\'a\\', like \\'\\'aaaaaa\\'\\' then we will simply convert the last character of string to \\'b\\' to make it smallest i.e \\'\\'aaaaab\\'\\'.\\n\\n```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n        int l=0; r=n-1;\\n        if(palindrome.length()<=1){\\n            return \"\";\\n        }\\n        \\n        while(l<r){\\n            if(palindrome[l]!=\\'a\\' && palindrome[r]!=\\'a\\'){\\n                palindrome[l]=\\'a\\';\\n                return palindrome;\\n            }else{\\n                l++;\\n                r--;\\n            }\\n        }\\n        \\n        palindrome[n-1]=\\'b\\';\\n        return palindrome;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n        int l=0; r=n-1;\\n        if(palindrome.length()<=1){\\n            return \"\";\\n        }\\n        \\n        while(l<r){\\n            if(palindrome[l]!=\\'a\\' && palindrome[r]!=\\'a\\'){\\n                palindrome[l]=\\'a\\';\\n                return palindrome;\\n            }else{\\n                l++;\\n                r--;\\n            }\\n        }\\n        \\n        palindrome[n-1]=\\'b\\';\\n        return palindrome;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2684624,
                "title": "javascript-o-n-faster-than-99-09",
                "content": "Runtime: 57 ms, faster than 99.09% of JavaScript online submissions for Break a Palindrome. Memory Usage: 41.8 MB, less than 68.18% of JavaScript online submissions for Break a Palindrome.\\n\\nApproach : Changing the first alphabet that is not \\'a\\' to \\'a\\' making the string lexicographically the smallest one. Special case handling - In a case where all the character in the string are \\'a\\' then replacing the last \\'a\\' with \\'b\\' makes the best llexicographically smallest string.\\n\\n```\\nvar breakPalindrome = function(palindrome) {\\n    if(palindrome.length === 1){\\n        return \"\";\\n    }\\n    let res = \"\";\\n    for(let i=0; i < (Math.floor(palindrome.length / 2));i++){\\n        if(palindrome[i] !== \\'a\\'){\\n            res = palindrome.slice(0,i)  + \\'a\\' + palindrome.slice(i+1,palindrome.length);\\n            break;\\n        }\\n    }\\n    if(res === \"\"){\\n        res = palindrome.slice(0,palindrome.length-1) + \\'b\\';\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\nvar breakPalindrome = function(palindrome) {\\n    if(palindrome.length === 1){\\n        return \"\";\\n    }\\n    let res = \"\";\\n    for(let i=0; i < (Math.floor(palindrome.length / 2));i++){\\n        if(palindrome[i] !== \\'a\\'){\\n            res = palindrome.slice(0,i)  + \\'a\\' + palindrome.slice(i+1,palindrome.length);\\n            break;\\n        }\\n    }\\n    if(res === \"\"){\\n        res = palindrome.slice(0,palindrome.length-1) + \\'b\\';\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2684547,
                "title": "faster-then-100",
                "content": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string p) {\\n    if(p.size()==1)return \"\";\\n     for(int i=0;i<p.size()/2;i++){\\n         if(p[i]!=\\'a\\'){\\n             p[i]=\\'a\\';\\n             return p;\\n         }\\n        }\\n        p[p.size()-1]=\\'b\\';\\n        return p;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string p) {\\n    if(p.size()==1)return \"\";\\n     for(int i=0;i<p.size()/2;i++){\\n         if(p[i]!=\\'a\\'){\\n             p[i]=\\'a\\';\\n             return p;\\n         }\\n        }\\n        p[p.size()-1]=\\'b\\';\\n        return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2684262,
                "title": "short-concise-solution-o-n-2",
                "content": "```\\nclass Solution\\n{\\n    public:\\n\\n        string breakPalindrome(string p)\\n        {\\n            if (p.size() == 1)\\n                return \"\";\\n            string ans = p;\\n            for (int i = 0; i < p.size() / 2; i++)\\n            {\\n                if (p[i] != \\'a\\')\\n                {\\n                    ans[i] = \\'a\\';\\n                    return ans;\\n                }\\n            }\\n            ans.back() = \\'b\\';\\n            return ans;\\n        }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public:\\n\\n        string breakPalindrome(string p)\\n        {\\n            if (p.size() == 1)\\n                return \"\";\\n            string ans = p;\\n            for (int i = 0; i < p.size() / 2; i++)\\n            {\\n                if (p[i] != \\'a\\')\\n                {\\n                    ans[i] = \\'a\\';\\n                    return ans;\\n                }\\n            }\\n            ans.back() = \\'b\\';\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2684214,
                "title": "python-pretty-simple-and-clean-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def breakPalindrome(self, palindrome: str) -> str:\\n        lst = list(palindrome)\\n        # if there is noway to make it non-palindromic\\n        if len(lst) < 2:\\n            return \\'\\'\\n        \\n        # checking till mid if not a make it a\\n        for i in range(len(lst)//2):\\n            if lst[i] != \\'a\\':\\n                lst[i] = \\'a\\'\\n                return \\'\\'.join(lst)\\n        \\n        # else make the last char \\'b\\'\\n        lst[len(lst) - 1] = \\'b\\'\\n        return \\'\\'.join(lst)\\n            \\n```\\n***Please do upvote if found helpful!!!***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def breakPalindrome(self, palindrome: str) -> str:\\n        lst = list(palindrome)\\n        # if there is noway to make it non-palindromic\\n        if len(lst) < 2:\\n            return \\'\\'\\n        \\n        # checking till mid if not a make it a\\n        for i in range(len(lst)//2):\\n            if lst[i] != \\'a\\':\\n                lst[i] = \\'a\\'\\n                return \\'\\'.join(lst)\\n        \\n        # else make the last char \\'b\\'\\n        lst[len(lst) - 1] = \\'b\\'\\n        return \\'\\'.join(lst)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2684010,
                "title": "c-easy-solution-with-edge-case-explanation-backtrack",
                "content": "```\\nclass Solution {\\npublic:\\n    bool ispal(string s){\\n        int l=0,r=s.size()-1;\\n        while(l<r)\\n        if(s[l++]!=s[r--]) return false;\\n        return true;\\n    }\\n    string breakPalindrome(string pal) {\\n        if(pal.size()==1) return \"\";\\n        for(int i=0;i<pal.size();i++){\\n            if(pal[i]!=\\'a\\'){\\n                char ch=pal[i];\\n                pal[i]=\\'a\\';\\n                if(ispal(pal)) {pal[i]=ch; break;} // Lets assume \"aba\" string, our string become \"aaa\" it is palindrome ,so here we have to cheak after operation string become palindrome or not , if palindrome then make the string back to previous one and change the last element to \\'b\\n                return pal;\\n            }\\n        }\\n        pal[pal.size()-1]=\\'b\\';\\n        return pal;\\n    }\\n};\\n**If U Like It Please Upvote.**\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool ispal(string s){\\n        int l=0,r=s.size()-1;\\n        while(l<r)\\n        if(s[l++]!=s[r--]) return false;\\n        return true;\\n    }\\n    string breakPalindrome(string pal) {\\n        if(pal.size()==1) return \"\";\\n        for(int i=0;i<pal.size();i++){\\n            if(pal[i]!=\\'a\\'){\\n                char ch=pal[i];\\n                pal[i]=\\'a\\';\\n                if(ispal(pal)) {pal[i]=ch; break;} // Lets assume \"aba\" string, our string become \"aaa\" it is palindrome ,so here we have to cheak after operation string become palindrome or not , if palindrome then make the string back to previous one and change the last element to \\'b\\n                return pal;\\n            }\\n        }\\n        pal[pal.size()-1]=\\'b\\';\\n        return pal;\\n    }\\n};\\n**If U Like It Please Upvote.**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683856,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "**Java**\\n```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        if(palindrome.length() == 1)    return \"\";\\n        char[] s = palindrome.toCharArray();\\n        for(int i=0; i<s.length/2; i++){\\n            if(s[i] != \\'a\\'){\\n                s[i] = \\'a\\';\\n                return String.valueOf(s);\\n            }\\n        }\\n        s[s.length-1] = \\'b\\';\\n        return String.valueOf(s);\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar breakPalindrome = function(palindrome) {\\n    if(palindrome.length == 1)    return \"\";\\n    let s = palindrome.split(\\'\\')\\n    for(let i=0; i<~~(s.length/2); i++){\\n        if(s[i] != \\'a\\'){\\n            s[i] = \\'a\\';\\n            return s.join(\\'\\');\\n        }\\n    }\\n    s[s.length-1] = \\'b\\';\\n    return s.join(\\'\\');\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def breakPalindrome(self, palindrome):\\n        if len(palindrome) == 1:\\n            return \"\"\\n        for i in range(len(palindrome)/2):\\n            if palindrome[i] != \\'a\\':\\n                return palindrome[:i] + \\'a\\' + palindrome[i+1:]\\n        return palindrome[:-1] + \\'b\\' \\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        if(palindrome.length() == 1)    return \"\";\\n        char[] s = palindrome.toCharArray();\\n        for(int i=0; i<s.length/2; i++){\\n            if(s[i] != \\'a\\'){\\n                s[i] = \\'a\\';\\n                return String.valueOf(s);\\n            }\\n        }\\n        s[s.length-1] = \\'b\\';\\n        return String.valueOf(s);\\n    }\\n}\\n```\n```\\nvar breakPalindrome = function(palindrome) {\\n    if(palindrome.length == 1)    return \"\";\\n    let s = palindrome.split(\\'\\')\\n    for(let i=0; i<~~(s.length/2); i++){\\n        if(s[i] != \\'a\\'){\\n            s[i] = \\'a\\';\\n            return s.join(\\'\\');\\n        }\\n    }\\n    s[s.length-1] = \\'b\\';\\n    return s.join(\\'\\');\\n};\\n```\n```\\nclass Solution(object):\\n    def breakPalindrome(self, palindrome):\\n        if len(palindrome) == 1:\\n            return \"\"\\n        for i in range(len(palindrome)/2):\\n            if palindrome[i] != \\'a\\':\\n                return palindrome[:i] + \\'a\\' + palindrome[i+1:]\\n        return palindrome[:-1] + \\'b\\' \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683806,
                "title": "ez-python-solution",
                "content": "```\\nclass Solution:\\n    def breakPalindrome(self, palindrome: str) -> str:\\n        le = len(palindrome)\\n        \\n        if le == 1:\\n            return \"\"\\n        \\n        for i in range(0, le // 2):\\n            if palindrome[i] != \\'a\\':\\n                return palindrome[:i] + \\'a\\' + palindrome[i+1:]\\n        \\n        return palindrome[:le-1] + \\'b\\'\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def breakPalindrome(self, palindrome: str) -> str:\\n        le = len(palindrome)\\n        \\n        if le == 1:\\n            return \"\"\\n        \\n        for i in range(0, le // 2):\\n            if palindrome[i] != \\'a\\':\\n                return palindrome[:i] + \\'a\\' + palindrome[i+1:]\\n        \\n        return palindrome[:le-1] + \\'b\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683569,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def breakPalindrome(self, p: str) -> str:\\n        if len(p)==1:return \"\"\\n        l=list(p)\\n        for x in range(len(l)//2):\\n            if l[x]!=\\'a\\':\\n                l[x]=\\'a\\'\\n                return \\'\\'.join(l)\\n        l[-1]=\\'b\\'\\n        return \\'\\'.join(l)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def breakPalindrome(self, p: str) -> str:\\n        if len(p)==1:return \"\"\\n        l=list(p)\\n        for x in range(len(l)//2):\\n            if l[x]!=\\'a\\':\\n                l[x]=\\'a\\'\\n                return \\'\\'.join(l)\\n        l[-1]=\\'b\\'\\n        return \\'\\'.join(l)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683544,
                "title": "daily-leetcode-solution-break-a-palindrome",
                "content": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n        int n=palindrome.size();\\n        if(n==1) return \"\";\\n        if(n%2==0)\\n        {\\n            int idx=-1;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(palindrome[i]!=\\'a\\')\\n                {\\n                    idx=i;\\n                    palindrome[i]=\\'a\\';\\n                    break;\\n                }\\n            }\\n            if(idx==-1)\\n            {\\n                palindrome[n-1]=\\'b\\';\\n            }\\n            return palindrome;\\n        }\\n        else\\n        {\\n            int idx=-1;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(palindrome[i]!=\\'a\\'&&i!=n/2)\\n                {\\n                    idx=i;\\n                    palindrome[idx]=\\'a\\';\\n                    break;\\n                }\\n            }\\n            if(idx==-1)\\n            {\\n                palindrome[n-1]=\\'b\\';\\n            }\\n            return palindrome;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n        int n=palindrome.size();\\n        if(n==1) return \"\";\\n        if(n%2==0)\\n        {\\n            int idx=-1;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(palindrome[i]!=\\'a\\')\\n                {\\n                    idx=i;\\n                    palindrome[i]=\\'a\\';\\n                    break;\\n                }\\n            }\\n            if(idx==-1)\\n            {\\n                palindrome[n-1]=\\'b\\';\\n            }\\n            return palindrome;\\n        }\\n        else\\n        {\\n            int idx=-1;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(palindrome[i]!=\\'a\\'&&i!=n/2)\\n                {\\n                    idx=i;\\n                    palindrome[idx]=\\'a\\';\\n                    break;\\n                }\\n            }\\n            if(idx==-1)\\n            {\\n                palindrome[n-1]=\\'b\\';\\n            }\\n            return palindrome;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448435,
                "title": "0-ms-faster-than-100",
                "content": "1. If string size is 1, return an empty string.\\n2.  If lowest charcter in string is not \\'a\\', simply set string[0] = \\'a\\' and return string.\\n3.  Else now we have to convert a char in string to \\'a\\' such that resultant is of minimum lexicographical order. For that we will check first non-occurence of any other charcter than \\'a\\' in that string and replace it with \\'a\\', If we don\\'t find any occurence of any other character in that string, that simply means that string contains only of letter \\'a\\', so in that case we will change last char of string to \\'b\\';\\n4.  **Most Important point**  In case where string= \"aba\", we cannot convert \\'b\\' into \\'a\\', so for this I have checked for a very intersting case, do check in my code and comment.\\n\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tstring breakPalindrome(string s) {\\n\\t\\t\\t\\t\\t\\tif(s.size()==1) return \"\";\\n\\t\\t\\t\\t\\t\\tchar lowest=\\'z\\';\\n\\t\\t\\t\\t\\t\\tfor(auto i:s){\\n\\t\\t\\t\\t\\t\\t\\tif(i<lowest) lowest=i;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(lowest!=\\'a\\') {s[0]=\\'a\\'; return s;}\\n\\n\\t\\t\\t\\t\\t\\tint i=0,j=s.size()-1;\\n\\t\\t\\t\\t\\t\\twhile(i<=j){\\n\\t\\t\\t\\t\\t\\t\\tif(s[i]!=lowest) {\\n\\t\\t\\t\\t\\t\\t\\t\\tif((j+1)%2!=0 && i==(j+1)/2) {i++; continue;}\\n\\t\\t\\t\\t\\t\\t\\t\\ts[i]=lowest; \\n\\t\\t\\t\\t\\t\\t\\t\\treturn s;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\ts[j] = lowest+1;\\n\\t\\t\\t\\t\\t\\treturn s;\\n\\t\\t\\t\\t\\t}\\n",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "1. If string size is 1, return an empty string.\\n2.  If lowest charcter in string is not \\'a\\', simply set string[0] = \\'a\\' and return string.\\n3.  Else now we have to convert a char in string to \\'a\\' such that resultant is of minimum lexicographical order. For that we will check first non-occurence of any other charcter than \\'a\\' in that string and replace it with \\'a\\', If we don\\'t find any occurence of any other character in that string, that simply means that string contains only of letter \\'a\\', so in that case we will change last char of string to \\'b\\';\\n4.  **Most Important point**  In case where string= \"aba\", we cannot convert \\'b\\' into \\'a\\', so for this I have checked for a very intersting case, do check in my code and comment.\\n\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tstring breakPalindrome(string s) {\\n\\t\\t\\t\\t\\t\\tif(s.size()==1) return \"\";\\n\\t\\t\\t\\t\\t\\tchar lowest=\\'z\\';\\n\\t\\t\\t\\t\\t\\tfor(auto i:s){\\n\\t\\t\\t\\t\\t\\t\\tif(i<lowest) lowest=i;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(lowest!=\\'a\\') {s[0]=\\'a\\'; return s;}\\n\\n\\t\\t\\t\\t\\t\\tint i=0,j=s.size()-1;\\n\\t\\t\\t\\t\\t\\twhile(i<=j){\\n\\t\\t\\t\\t\\t\\t\\tif(s[i]!=lowest) {\\n\\t\\t\\t\\t\\t\\t\\t\\tif((j+1)%2!=0 && i==(j+1)/2) {i++; continue;}\\n\\t\\t\\t\\t\\t\\t\\t\\ts[i]=lowest; \\n\\t\\t\\t\\t\\t\\t\\t\\treturn s;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\ts[j] = lowest+1;\\n\\t\\t\\t\\t\\t\\treturn s;\\n\\t\\t\\t\\t\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1874291,
                "title": "cpp-100-00-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string s) {\\n        int l=s.size();\\n        if(l==1)\\n            return \"\";\\n        int k=0;\\n        for(int i=0; i<l; i++){\\n            if(s[i]==97)\\n                k++;\\n        }\\n        if(k==l || k==l-1 ){\\n            s[l-1]=98;\\n            return s;\\n        }\\n        \\n        for(int i=0; i<l; i++){\\n            if(s[i]!=97){\\n                s[i]=97;\\n                return s;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string s) {\\n        int l=s.size();\\n        if(l==1)\\n            return \"\";\\n        int k=0;\\n        for(int i=0; i<l; i++){\\n            if(s[i]==97)\\n                k++;\\n        }\\n        if(k==l || k==l-1 ){\\n            s[l-1]=98;\\n            return s;\\n        }\\n        \\n        for(int i=0; i<l; i++){\\n            if(s[i]!=97){\\n                s[i]=97;\\n                return s;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1481401,
                "title": "c-0-ms-o-n-very-easy-sol-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string s) {\\n        int n=s.length();\\n        \\n        //if length is 1 then we have to return empty string\\n        if(n==1)return \"\";\\n        bool f=0;\\n        for(int i=0;s[i];i++)\\n        {\\n            //edge case-> if length is odd and we change middle element to \\'a\\' (if possible) then it will still we a palindrome so we skip it\\n            if(n%2==1&&i==n/2)continue;\\n            \\n            //otherwise whenever we find a element which greater than \\'a\\' then we simply replace it with \\'a\\' and break.\\n            if(s[i]!=\\'a\\')\\n            {\\n                s[i]=\\'a\\';\\n                f=1;\\n                break;\\n            }\\n        }\\n        //if the string is \"aaaaaaaaa.....\" the we just need to change the last element to \\'b\\' and then we retrun the ans\\n        if(!f)\\n        {\\n            s[n-1]=\\'b\\';            \\n        }\\n        return s;\\n        \\n    }\\n};\\n```\\n### ***Please Upvote if you liked the solution.***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string s) {\\n        int n=s.length();\\n        \\n        //if length is 1 then we have to return empty string\\n        if(n==1)return \"\";\\n        bool f=0;\\n        for(int i=0;s[i];i++)\\n        {\\n            //edge case-> if length is odd and we change middle element to \\'a\\' (if possible) then it will still we a palindrome so we skip it\\n            if(n%2==1&&i==n/2)continue;\\n            \\n            //otherwise whenever we find a element which greater than \\'a\\' then we simply replace it with \\'a\\' and break.\\n            if(s[i]!=\\'a\\')\\n            {\\n                s[i]=\\'a\\';\\n                f=1;\\n                break;\\n            }\\n        }\\n        //if the string is \"aaaaaaaaa.....\" the we just need to change the last element to \\'b\\' and then we retrun the ans\\n        if(!f)\\n        {\\n            s[n-1]=\\'b\\';            \\n        }\\n        return s;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1481028,
                "title": "python-simple-and-explained",
                "content": "**Explanation:**\\nGiven example for this problem are quite enough to build this logic but the test case which can confuse is - \\n***how \\'\\'ab\" is lexicographically smaller than \"aa\"?*** First we\\'ll understand this problem.\\n\\nHere, the given string `palindrome` is already **palindrome** which implies that we have to look till *halfway* of the string and if we need to replace any one character, then it defintely be the first character in the `palindrome` **greater than \\'a\\'**. \\n\\n1. Firstly we iterate till halfway and find this character. If found then simply return the string with indexed character replaced with \\'a\\'. *(We could also replace it with one smaller character such as if \\'z\\', then \\'y\\' but problem mentions that **lexicographically smallest one possible**.)*\\n2. If we reached halfway, then definitely it\\'s not possible to replace any character of the string to get lexicographically smallest, so we directly replace last character with **\\'b\\'** because then it\\'ll be smallest possible one, as we left we no other choice.\\n\\t ***That\\'s why \"ab\" is the answer to \"aa\". Similarly, \"aazaa\" = \"aazab\".***\\n\\n**Note**: If you question why we cannot replace character after halfway, just imagine even if we could, we would have replaced it\\'s mirror character in first half of `palindrome` i.e. **Step 1**.\\n\\n#### **Code -** \\n\\n```\\nclass Solution:\\n    def breakPalindrome(self, palindrome: str) -> str:        \\n        if len(palindrome)<2:\\n            return \"\"\\n               \\n        low = 0\\n        while low < len(palindrome)//2:\\n            if ord(palindrome[low])>97:\\n                break\\n            low+=1\\n                \\n        if low<(L//2):\\n            return (palindrome[0:low] + \\'a\\' + palindrome[low+1:])           \\n        return palindrome[:-1] + \\'b\\'\\n```\\n\\nIf you like the explanation and the code, Please **Upvote**. **:))**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def breakPalindrome(self, palindrome: str) -> str:        \\n        if len(palindrome)<2:\\n            return \"\"\\n               \\n        low = 0\\n        while low < len(palindrome)//2:\\n            if ord(palindrome[low])>97:\\n                break\\n            low+=1\\n                \\n        if low<(L//2):\\n            return (palindrome[0:low] + \\'a\\' + palindrome[low+1:])           \\n        return palindrome[:-1] + \\'b\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1480750,
                "title": "0ms-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n        string res;\\n        if (palindrome.size() == 1)\\n            return res;\\n        for (size_t i = 0; i < palindrome.size() / 2; i++)\\n        {\\n            if(palindrome[i] != \\'a\\')\\n            {\\n                palindrome[i] = \\'a\\';\\n                return palindrome;                \\n            }\\n        }\\n        palindrome[palindrome.size() - 1] = \\'b\\';\\n        return palindrome;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n        string res;\\n        if (palindrome.size() == 1)\\n            return res;\\n        for (size_t i = 0; i < palindrome.size() / 2; i++)\\n        {\\n            if(palindrome[i] != \\'a\\')\\n            {\\n                palindrome[i] = \\'a\\';\\n                return palindrome;                \\n            }\\n        }\\n        palindrome[palindrome.size() - 1] = \\'b\\';\\n        return palindrome;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1480714,
                "title": "java-solution",
                "content": "* you need to keep track of character \\'a\\'\\n* if character is not \\'a\\' then immediately change it to \\'a\\' for String to be non palindrome and lexicographically sorted. and return the answer\\n* if you reach to middle or point of reflection index , it means you have not get the character other than \\'a\\' till now,  other half will be also the same, so just go and change the last character to \\'b\\' and return the answer\\n```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        char[] arr = palindrome.toCharArray();\\n        \\n        if(arr.length<2)\\n            return \"\";\\n        \\n        for(int i=0;i<arr.length/2;i++){\\n            if(arr[i]!=\\'a\\'){\\n                arr[i] = \\'a\\';\\n                return String.valueOf(arr);\\n            }\\n        }\\n        \\n        // if we crossing the middle point then\\n        \\n        arr[arr.length - 1] = \\'b\\'; // since all before middile would be definitely \\'a\\'\\n        \\n        return String.valueOf(arr);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        char[] arr = palindrome.toCharArray();\\n        \\n        if(arr.length<2)\\n            return \"\";\\n        \\n        for(int i=0;i<arr.length/2;i++){\\n            if(arr[i]!=\\'a\\'){\\n                arr[i] = \\'a\\';\\n                return String.valueOf(arr);\\n            }\\n        }\\n        \\n        // if we crossing the middle point then\\n        \\n        arr[arr.length - 1] = \\'b\\'; // since all before middile would be definitely \\'a\\'\\n        \\n        return String.valueOf(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1364895,
                "title": "python-better-than-95-simple",
                "content": "```\\nclass Solution:\\n    def breakPalindrome(self, palindrome: str) -> str:\\n        n=len(palindrome)\\n        if n==1:\\n            return \"\"\\n        if n%2==0:\\n            for j,i in enumerate(palindrome):\\n                if i!=\"a\":\\n                    return palindrome[:j]+\"a\"+palindrome[j+1:]\\n            return palindrome[:-1]+\"b\"\\n        \\n        else:\\n            for j,i in enumerate(palindrome):\\n                if j!=n//2 and i!=\"a\":\\n                    return palindrome[:j]+\"a\"+palindrome[j+1:]\\n            return palindrome[:-1]+\"b\"",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def breakPalindrome(self, palindrome: str) -> str:\\n        n=len(palindrome)\\n        if n==1:\\n            return \"\"\\n        if n%2==0:\\n            for j,i in enumerate(palindrome):\\n                if i!=\"a\":\\n                    return palindrome[:j]+\"a\"+palindrome[j+1:]\\n            return palindrome[:-1]+\"b\"\\n        \\n        else:\\n            for j,i in enumerate(palindrome):\\n                if j!=n//2 and i!=\"a\":\\n                    return palindrome[:j]+\"a\"+palindrome[j+1:]\\n            return palindrome[:-1]+\"b\"",
                "codeTag": "Java"
            },
            {
                "id": 1097922,
                "title": "easy-peezy-c-100-faster",
                "content": "Simply we have to check at what position we dont have \\'a\\', We will replace it with \\'a\\'.\\n\\nIf all characters are \\'a\\' then replace last character to \\'b\\'.\\n\\n```\\n    string breakPalindrome(string palindrome) {\\n        int n = palindrome.size();\\n        if(n==1)\\n            return \"\";\\n        for(int i=0;i<n/2;i++)\\n        {\\n            if(palindrome[i] != \\'a\\'){\\n                palindrome[i] = \\'a\\';\\n                return palindrome;\\n            }\\n        }\\n        \\n        palindrome[n-1] = \\'b\\';\\n        \\n        return palindrome;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    string breakPalindrome(string palindrome) {\\n        int n = palindrome.size();\\n        if(n==1)\\n            return \"\";\\n        for(int i=0;i<n/2;i++)\\n        {\\n            if(palindrome[i] != \\'a\\'){\\n                palindrome[i] = \\'a\\';\\n                return palindrome;\\n            }\\n        }\\n        \\n        palindrome[n-1] = \\'b\\';\\n        \\n        return palindrome;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 959392,
                "title": "java-solution",
                "content": "java\\n```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        char[] s= palindrome.toCharArray();\\n        int n = palindrome.length();\\n        for(int i=0;i<n/2;i++) {\\n            if(s[i]!=\\'a\\') {\\n                s[i] = \\'a\\';\\n                return String.valueOf(s);\\n            }\\n        }\\n        s[n-1] = \\'b\\';\\n        \\n        return n<2?\"\": String.valueOf(s);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        char[] s= palindrome.toCharArray();\\n        int n = palindrome.length();\\n        for(int i=0;i<n/2;i++) {\\n            if(s[i]!=\\'a\\') {\\n                s[i] = \\'a\\';\\n                return String.valueOf(s);\\n            }\\n        }\\n        s[n-1] = \\'b\\';\\n        \\n        return n<2?\"\": String.valueOf(s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 956277,
                "title": "java-beats-100-commented",
                "content": "```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        // edge case\\n        if (palindrome.length() == 1) return \"\";\\n        \\n        // find replacement index\\n        int swap_idx = -1;\\n        for (int i = 0; i < palindrome.length()/2; i++) {\\n            if (palindrome.charAt(i) != \\'a\\') {\\n                swap_idx = i;\\n                break;\\n            }\\n        }\\n        \\n        StringBuilder res = new StringBuilder();\\n        \\n        // we found an index to replace\\n        if (swap_idx != -1) {\\n            res.append(palindrome.substring(0,swap_idx));\\n            res.append(\\'a\\');\\n            res.append(palindrome.substring(swap_idx + 1));\\n            \\n        // we did not find an index to replace, replace the last one with \\'b\\'\\n        } else {\\n            res.append(palindrome.substring(0, palindrome.length() - 1));\\n            res.append(\\'b\\');\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        // edge case\\n        if (palindrome.length() == 1) return \"\";\\n        \\n        // find replacement index\\n        int swap_idx = -1;\\n        for (int i = 0; i < palindrome.length()/2; i++) {\\n            if (palindrome.charAt(i) != \\'a\\') {\\n                swap_idx = i;\\n                break;\\n            }\\n        }\\n        \\n        StringBuilder res = new StringBuilder();\\n        \\n        // we found an index to replace\\n        if (swap_idx != -1) {\\n            res.append(palindrome.substring(0,swap_idx));\\n            res.append(\\'a\\');\\n            res.append(palindrome.substring(swap_idx + 1));\\n            \\n        // we did not find an index to replace, replace the last one with \\'b\\'\\n        } else {\\n            res.append(palindrome.substring(0, palindrome.length() - 1));\\n            res.append(\\'b\\');\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 915243,
                "title": "thinking-process",
                "content": "Similar to [Find the Closest Palindrome](https://leetcode.com/problems/find-the-closest-palindrome/discuss/147949/Thinking-Process), when asked to modify a given palindrome for some purpose, we often focus on **palindrome root**.\\n\\nFor example, `ab` is palindrome root of both `abba` and `abbba`.\\n\\nIf we replace one character of palindrome root in order to be lexicographically smallest possible, \\n- the palindrome might break: \\n```\\npalindrome root ab -> aa\\npalindrome abba -> non-palindrome aaba\\n```\\n- the palindrome might not break\\n```\\npalindrome root aa -> ?\\npalindrome aaaa -> ?\\n```\\nIn this case, we replace the last character of palindrome in order to be lexicographically smallest possible (i.e. b).\\n```\\npalindrome aaaa -> aaab\\npalindrome aaaaa -> aaaab\\n```\\n\\n****\\n```\\nclass Solution:\\n    def breakPalindrome(self, palindrome: str) -> str:\\n        if len(palindrome) <= 1:\\n            return \"\"\\n        \\n        for i in range(len(palindrome) // 2):\\n            if palindrome[i] != \"a\":\\n                return palindrome[:i] + \\'a\\' + palindrome[i + 1:]\\n            \\n        return palindrome[:-1] + \"b\"\\n```",
                "solutionTags": [],
                "code": "```\\npalindrome root ab -> aa\\npalindrome abba -> non-palindrome aaba\\n```\n```\\npalindrome root aa -> ?\\npalindrome aaaa -> ?\\n```\n```\\npalindrome aaaa -> aaab\\npalindrome aaaaa -> aaaab\\n```\n```\\nclass Solution:\\n    def breakPalindrome(self, palindrome: str) -> str:\\n        if len(palindrome) <= 1:\\n            return \"\"\\n        \\n        for i in range(len(palindrome) // 2):\\n            if palindrome[i] != \"a\":\\n                return palindrome[:i] + \\'a\\' + palindrome[i + 1:]\\n            \\n        return palindrome[:-1] + \"b\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 890834,
                "title": "my-java-solution-with-explanation",
                "content": "```\\n// since the given string is a palindrome, consider checking for half of the string only\\n// if we see a non \\'a\\' here, replace it with \\'a\\'\\n// if the string have only \\'a\\', then replace the last character by b\\n// if string is empty- return \"\"\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        if (palindrome.length() == 0 || palindrome.length() == 1)\\n            return \"\";\\n        char [] ch = palindrome.toCharArray();\\n        int length = palindrome.length();\\n        for (int i=0; i<length/2; i++) {\\n            if (ch[i] != \\'a\\') {\\n                ch[i] = \\'a\\';\\n                return String.valueOf(ch);\\n            }\\n        }\\n        ch[length - 1] = \\'b\\';\\n        return String.valueOf(ch);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n// since the given string is a palindrome, consider checking for half of the string only\\n// if we see a non \\'a\\' here, replace it with \\'a\\'\\n// if the string have only \\'a\\', then replace the last character by b\\n// if string is empty- return \"\"\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        if (palindrome.length() == 0 || palindrome.length() == 1)\\n            return \"\";\\n        char [] ch = palindrome.toCharArray();\\n        int length = palindrome.length();\\n        for (int i=0; i<length/2; i++) {\\n            if (ch[i] != \\'a\\') {\\n                ch[i] = \\'a\\';\\n                return String.valueOf(ch);\\n            }\\n        }\\n        ch[length - 1] = \\'b\\';\\n        return String.valueOf(ch);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 870939,
                "title": "c-concise-solution-w-explanation-beats-100-time",
                "content": "- recognize that you can change the first non \\u2019a\\u2019 char to \\'a\\' to get the lexicographically smallest nonpalindrome string, \\nhowever not if that non \\u2019a\\u2019 char is the middle char. ex. \"aca\" --> \"aaa\", which is still a palindrome\\n- If the entire string is comprised of \\u2018a\\u2019s then increment the value of the last char.\\n\\n```\\n    string breakPalindrome(string palindrome) {\\n        int n = palindrome.length();\\n        if (n == 1) return \"\";\\n        for (int i = 0; i < n; i++) {\\n            if (palindrome[i] != \\'a\\' && i != n/2) {\\n                palindrome[i] = \\'a\\'; return palindrome;\\n            }\\n        }\\n        palindrome[n-1] += 1;\\n        return palindrome;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    string breakPalindrome(string palindrome) {\\n        int n = palindrome.length();\\n        if (n == 1) return \"\";\\n        for (int i = 0; i < n; i++) {\\n            if (palindrome[i] != \\'a\\' && i != n/2) {\\n                palindrome[i] = \\'a\\'; return palindrome;\\n            }\\n        }\\n        palindrome[n-1] += 1;\\n        return palindrome;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 783631,
                "title": "java-o-n-solution",
                "content": "1) Whenever you see String manipulation, convert the given string into a char Array if values need to be replaced. \\n2) You check only the first half of your string because you can\\'t change the middle element and if you want to change the second half its as good as changing the first half.  Why you can\\'t change middle element: aaabaaa ---> if you go till the last char, b will get converted to a and palindrome won\\'t break. (your function will return aaaaaaa) \\n3) The first non \\'a\\' char can be convered to \\'a\\' to break the palindrome and it would lixically smallest. \\n4) if only \\'a\\'s are present then last char of the string should be changed to \\'b\\' again so that it\\'s lexically the smallest.\\n5) Now keep the corner cases in mind, if the string is of length 1, then to break the palindrome you need to return an empty string \\n```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        if(palindrome.length() == 1) return \"\";\\n        char[] pali = palindrome.toCharArray();\\n        int n = pali.length;\\n        for(int i=0;i<n/2;i++)\\n        {\\n            if(pali[i] != \\'a\\'){\\n                pali[i] = \\'a\\';\\n                return String.valueOf(pali);\\n            }\\n        }\\n        pali[n-1] = \\'b\\';\\n        return String.valueOf(pali);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        if(palindrome.length() == 1) return \"\";\\n        char[] pali = palindrome.toCharArray();\\n        int n = pali.length;\\n        for(int i=0;i<n/2;i++)\\n        {\\n            if(pali[i] != \\'a\\'){\\n                pali[i] = \\'a\\';\\n                return String.valueOf(pali);\\n            }\\n        }\\n        pali[n-1] = \\'b\\';\\n        return String.valueOf(pali);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 756453,
                "title": "c-100-time-80-space-solution-explained",
                "content": "Not sure why this is actually a medium problem (and I spent a sizeable amount of time before submitting to think about odd edge cases I might have neglected!), but here is the deal: we know that we have to return the smallest lexicographic non-palindrome alternative and we know that the string is going to be 100% lowercase characters.\\n\\nAnd that means that as soon as we find a character that is not `\\'a\\'`, we need to replace it with it; since it is a palindrome, we can save some effort and only check the first part (rounding down with an integer division: a central character would not affect whether or not a word is still a palindrome).\\n\\nIf that did not happen, we can infer that the whole string was actually made of `\\'a\\'`s, so we go at the end and replace the last character with a `\\'b\\'`.\\n\\nAn interesting case to note is that if you were to get something like `\"aaabaaa\"`, the right solution would be `\"aaabaab\"`, because the problem mandates us to change only one character in order for the string to lose his palindrome status, so don\\'t be foiled by thinking that the central character in strings with odd length has any meaning for this problem.\\n\\nAlso, shame that users of languages with immutable strings would have to generate a new one all the time.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string breakPalindrome(string p) {\\n        bool didChange = false;\\n        int lmt = p.size() / 2;\\n        for (int i = 0; i < lmt; i++) if (p[i] != \\'a\\') {\\n            p[i] = \\'a\\';\\n            didChange = true;\\n            break;\\n        }\\n        if (!didChange) p[p.size() - 1] = \\'b\\';\\n        return p.size() > 1 ? p : \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string breakPalindrome(string p) {\\n        bool didChange = false;\\n        int lmt = p.size() / 2;\\n        for (int i = 0; i < lmt; i++) if (p[i] != \\'a\\') {\\n            p[i] = \\'a\\';\\n            didChange = true;\\n            break;\\n        }\\n        if (!didChange) p[p.size() - 1] = \\'b\\';\\n        return p.size() > 1 ? p : \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 541235,
                "title": "java-faster-than-100-memory-100",
                "content": "//do what feels good!\\n```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        int c = 0, i = 0;\\n        while(i < palindrome.length()) {\\n            if(i != palindrome.length()/2 && \\n               palindrome.charAt(i) != \\'a\\') {\\n                c = 1;\\n                StringBuilder sb = new StringBuilder(palindrome);\\n                sb.setCharAt(i, \\'a\\');\\n                palindrome = String.valueOf(sb);\\n                break;\\n            }\\n            i++;\\n        }\\n        if(c == 1)\\n            return palindrome;\\n        \\n        if(palindrome.length() > 1) {\\n            StringBuilder sb = new StringBuilder(palindrome);\\n            sb.setCharAt(palindrome.length() - 1, \\'b\\');\\n            palindrome = String.valueOf(sb);\\n            return palindrome;\\n        }\\n            \\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        int c = 0, i = 0;\\n        while(i < palindrome.length()) {\\n            if(i != palindrome.length()/2 && \\n               palindrome.charAt(i) != \\'a\\') {\\n                c = 1;\\n                StringBuilder sb = new StringBuilder(palindrome);\\n                sb.setCharAt(i, \\'a\\');\\n                palindrome = String.valueOf(sb);\\n                break;\\n            }\\n            i++;\\n        }\\n        if(c == 1)\\n            return palindrome;\\n        \\n        if(palindrome.length() > 1) {\\n            StringBuilder sb = new StringBuilder(palindrome);\\n            sb.setCharAt(palindrome.length() - 1, \\'b\\');\\n            palindrome = String.valueOf(sb);\\n            return palindrome;\\n        }\\n            \\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 510128,
                "title": "simple-go-solution-100",
                "content": "```\\nfunc breakPalindrome(palindrome string) string {   \\n    s := []rune(palindrome)\\n    if len(s) == 1 {\\n        return \"\"\\n    }\\n    for i := 0; i < len(s) / 2; i ++{\\n        if s[i] != \\'a\\' {\\n            s[i] = \\'a\\'\\n            return string(s)\\n        }    \\n    }     \\n    s[len(s) - 1] = \\'b\\'\\n    return string(s)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc breakPalindrome(palindrome string) string {   \\n    s := []rune(palindrome)\\n    if len(s) == 1 {\\n        return \"\"\\n    }\\n    for i := 0; i < len(s) / 2; i ++{\\n        if s[i] != \\'a\\' {\\n            s[i] = \\'a\\'\\n            return string(s)\\n        }    \\n    }     \\n    s[len(s) - 1] = \\'b\\'\\n    return string(s)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 508530,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        if (palindrome.length() == 1) {\\n            return \"\";\\n        }\\n        String p = new String(palindrome);\\n        char[] s = palindrome.toCharArray();\\n        boolean replaced = false;\\n        for (int i = 0; i < s.length / 2; i++) {\\n            if (s[i] != \\'a\\' && !replaced) {\\n                s[i] = \\'a\\';\\n                replaced = true;\\n            }\\n        }\\n        if (String.valueOf(s).equals(p)) {\\n            s[s.length - 1] = \\'b\\';\\n        }\\n        return String.valueOf(s);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        if (palindrome.length() == 1) {\\n            return \"\";\\n        }\\n        String p = new String(palindrome);\\n        char[] s = palindrome.toCharArray();\\n        boolean replaced = false;\\n        for (int i = 0; i < s.length / 2; i++) {\\n            if (s[i] != \\'a\\' && !replaced) {\\n                s[i] = \\'a\\';\\n                replaced = true;\\n            }\\n        }\\n        if (String.valueOf(s).equals(p)) {\\n            s[s.length - 1] = \\'b\\';\\n        }\\n        return String.valueOf(s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 496748,
                "title": "java-solution-with-explanation-beats-100",
                "content": "```\\nclass Solution {\\n    public String breakPalindrome(String s) {\\n\\t\\t//Check if the length equals 1\\n        if(s.length()==1) return \"\"; \\n\\t\\t//Convert string s into an array of chars, because String are immutable in Java\\n        char[] arr = s.toCharArray();\\n        int n = arr.length;\\n        for(int i=0; i<n; i++) {\\n\\t\\t\\t//arr[0]==arr[n-1]; arr[1]==arr[n-1-1] -> arr[i]==arr[n-1-i]\\n            int j = n-1-i; \\n\\t\\t\\t//Make sure we don\\'t change the middle character, because the string is still padlindrome\\n            if(i!=j) { \\n                if(arr[i]!=\\'a\\') {\\n\\t\\t\\t\\t\\t //Change the first char which is not \\'a\\' into \\'a\\'\\n                    arr[i]=\\'a\\';\\n\\t\\t\\t\\t\\t//The method change the array into String type\\n                    return String.valueOf(arr); \\n                }                \\n            }\\n        }\\n\\t\\t//If all chars in array are \\'a\\' -> change the last char into \\'b\\'\\n        arr[n-1]=\\'b\\';\\n        return String.valueOf(arr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String breakPalindrome(String s) {\\n\\t\\t//Check if the length equals 1\\n        if(s.length()==1) return \"\"; \\n\\t\\t//Convert string s into an array of chars, because String are immutable in Java\\n        char[] arr = s.toCharArray();\\n        int n = arr.length;\\n        for(int i=0; i<n; i++) {\\n\\t\\t\\t//arr[0]==arr[n-1]; arr[1]==arr[n-1-1] -> arr[i]==arr[n-1-i]\\n            int j = n-1-i; \\n\\t\\t\\t//Make sure we don\\'t change the middle character, because the string is still padlindrome\\n            if(i!=j) { \\n                if(arr[i]!=\\'a\\') {\\n\\t\\t\\t\\t\\t //Change the first char which is not \\'a\\' into \\'a\\'\\n                    arr[i]=\\'a\\';\\n\\t\\t\\t\\t\\t//The method change the array into String type\\n                    return String.valueOf(arr); \\n                }                \\n            }\\n        }\\n\\t\\t//If all chars in array are \\'a\\' -> change the last char into \\'b\\'\\n        arr[n-1]=\\'b\\';\\n        return String.valueOf(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 492301,
                "title": "python-3-three-lines-beats-99",
                "content": "```\\nclass Solution:\\n    def breakPalindrome(self, P: str) -> str:\\n        for i in range(len(P)//2):\\n            if P[i] != \\'a\\': return P[:i]+\\'a\\'+P[i+1:]\\n        return P[:-1]+\\'b\\' if len(P) > 1 else \\'\\'\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def breakPalindrome(self, P: str) -> str:\\n        for i in range(len(P)//2):\\n            if P[i] != \\'a\\': return P[:i]+\\'a\\'+P[i+1:]\\n        return P[:-1]+\\'b\\' if len(P) > 1 else \\'\\'\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "codeTag": "Java"
            },
            {
                "id": 490681,
                "title": "elementary-c-greedy-solution",
                "content": "```\\n    public class Solution\\n    {\\n        public string BreakPalindrome(string palindrome)\\n        {\\n            if (palindrome.Length == 1)\\n            {\\n                return \"\";\\n            }\\n\\n            StringBuilder res = new StringBuilder(palindrome);\\n\\n            for (int i = 0; i < res.Length; i++)\\n            {\\n                if (res[i] != \\'a\\')\\n                {\\n                    if (!(res.Length % 2 == 1 && i == res.Length / 2))\\n                    {\\n                        res[i] = \\'a\\';\\n                        return res.ToString();\\n                    }\\n                }\\n\\n            }\\n\\n            res[res.Length - 1] = \\'b\\';\\n            return res.ToString();\\n        }\\n    }\\n\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\n    public class Solution\\n    {\\n        public string BreakPalindrome(string palindrome)\\n        {\\n            if (palindrome.Length == 1)\\n            {\\n                return \"\";\\n            }\\n\\n            StringBuilder res = new StringBuilder(palindrome);\\n\\n            for (int i = 0; i < res.Length; i++)\\n            {\\n                if (res[i] != \\'a\\')\\n                {\\n                    if (!(res.Length % 2 == 1 && i == res.Length / 2))\\n                    {\\n                        res[i] = \\'a\\';\\n                        return res.ToString();\\n                    }\\n                }\\n\\n            }\\n\\n            res[res.Length - 1] = \\'b\\';\\n            return res.ToString();\\n        }\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 489701,
                "title": "java-keep-looking-for-an-a",
                "content": "```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        int n = palindrome.length();\\n        if(n == 1) return \"\";\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i <= (n/2) - 1; i++) {\\n            if(palindrome.charAt(i) != \\'a\\') {\\n                sb.append(\\'a\\');\\n                sb.append(palindrome.substring(i + 1, n));\\n                return sb.toString();\\n            } \\n            sb.append(\\'a\\');\\n        }\\n        for(int i = (n/2); i < n; i++) {\\n            if(i == n - 1) {\\n                sb.append(\\'b\\');\\n                return sb.toString();\\n            }\\n            sb.append(palindrome.charAt(i));\\n        }\\n        return \"\";\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String breakPalindrome(String palindrome) {\\n        int n = palindrome.length();\\n        if(n == 1) return \"\";\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i <= (n/2) - 1; i++) {\\n            if(palindrome.charAt(i) != \\'a\\') {\\n                sb.append(\\'a\\');\\n                sb.append(palindrome.substring(i + 1, n));\\n                return sb.toString();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4105240,
                "title": "best-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String breakPalindrome(String s) {\\n        int n = s.length();\\n\\n        if(n==1) return \"\";\\n\\n        StringBuilder ans = new StringBuilder(s);\\n        boolean flag = false;\\n\\n        for(int i=0; i<n/2; i++){\\n            char ch = ans.charAt(i);\\n            if(ch!=\\'a\\'){\\n                int x = ans.indexOf(ch+\"\");\\n                ans.replace(x,x+1,\"a\");\\n                flag = true;\\n                break;\\n            }\\n        }\\n        if(flag==false){  // in case that all character are \\'a\\'\\n            ans.replace(n-1,n,\"b\");\\n        }\\n\\n        return ans.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String breakPalindrome(String s) {\\n        int n = s.length();\\n\\n        if(n==1) return \"\";\\n\\n        StringBuilder ans = new StringBuilder(s);\\n        boolean flag = false;\\n\\n        for(int i=0; i<n/2; i++){\\n            char ch = ans.charAt(i);\\n            if(ch!=\\'a\\'){\\n                int x = ans.indexOf(ch+\"\");\\n                ans.replace(x,x+1,\"a\");\\n                flag = true;\\n                break;\\n            }\\n        }\\n        if(flag==false){  // in case that all character are \\'a\\'\\n            ans.replace(n-1,n,\"b\");\\n        }\\n\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844904,
                "title": "c-killer-solution-by-sd-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string p) \\n    {\\n        string res;\\n        if(p.size()==1)\\n        return res;\\n        for(int i=0;i<p.size()/2;i++)\\n        {\\n            if(p[i]!=\\'a\\')\\n            {\\n                p[i]=\\'a\\';\\n                return p;\\n            }\\n        }\\n        p[p.size()-1]=\\'b\\';\\n        return p;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string p) \\n    {\\n        string res;\\n        if(p.size()==1)\\n        return res;\\n        for(int i=0;i<p.size()/2;i++)\\n        {\\n            if(p[i]!=\\'a\\')\\n            {\\n                p[i]=\\'a\\';\\n                return p;\\n            }\\n        }\\n        p[p.size()-1]=\\'b\\';\\n        return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487778,
                "title": "beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string s) \\n    {\\n        if(s.size()==1)\\n        return \"\";\\n        if(s[0]!=\\'a\\')\\n        {\\n            s[0] = \\'a\\';\\n            return s;\\n        }\\n        for(int i = 0 ; i<s.size()/2;i++)\\n        if(s[i]!=\\'a\\')\\n        {\\n            s[i] = \\'a\\';\\n            return s; \\n        }\\n        s[s.size()-1] = \\'b\\';\\n        return s; \\n      \\n         \\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string s) \\n    {\\n        if(s.size()==1)\\n        return \"\";\\n        if(s[0]!=\\'a\\')\\n        {\\n            s[0] = \\'a\\';\\n            return s;\\n        }\\n        for(int i = 0 ; i<s.size()/2;i++)\\n        if(s[i]!=\\'a\\')\\n        {\\n            s[i] = \\'a\\';\\n            return s; \\n        }\\n        s[s.size()-1] = \\'b\\';\\n        return s; \\n      \\n         \\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200421,
                "title": "java-beats-100-code-explained",
                "content": "#### Intuition\\n1. To make the string lexicographically smallest, first preference will be given to add \\'a\\' to the string. If \\'a\\' is there then add \\'b\\' and so on..\\n2. To break a palindrome replace characters.\\n3. Combine both 1 + 2 points.\\n\\n#### Approach\\nCase -01 : racecar\\nIterate till the middle and see if \\'a\\' is present or not. If not then add it to make it lexico. smallest. We get, \\'aacecar\\'.\\n\\nCase-02 : aaaaa\\nIterate till middle, since all characters are \\'a\\' therefore, next half will also be filled with \\'a\\'. Now, to make it lexico. smallest just add \\'b\\' to the end of string. We get, \\'aaaab\\'.\\n\\nCase-03 : b\\nSingle character is considered a palindrome, so we can\\'t break it. Just return `\" \"`\\n\\n\\n#### Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n#### Code\\n```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n\\n        if(palindrome.length() <= 1) return \"\"; //case-03\\n\\n        char[] charArr = palindrome.toCharArray();\\n\\n        for(int i=0; i<palindrome.length()/2; i++){\\n            if(charArr[i]!=\\'a\\'){\\n                charArr[i] = \\'a\\'; // case-01\\n\\n                return new String(charArr); \\n            }\\n        }\\n\\n\\n        charArr[charArr.length-1] = \\'b\\'; // case-02\\n\\n        return new String(charArr);        \\n\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n\\n        if(palindrome.length() <= 1) return \"\"; //case-03\\n\\n        char[] charArr = palindrome.toCharArray();\\n\\n        for(int i=0; i<palindrome.length()/2; i++){\\n            if(charArr[i]!=\\'a\\'){\\n                charArr[i] = \\'a\\'; // case-01\\n\\n                return new String(charArr); \\n            }\\n        }\\n\\n\\n        charArr[charArr.length-1] = \\'b\\'; // case-02\\n\\n        return new String(charArr);        \\n\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010455,
                "title": "q1328-accepted-c-used-greedy-easiest-simple",
                "content": "CRUX\\n1) We need to break the palindrome by replacing a character such that lexicographically smallest one is possible.\\n2) After \\'a\\' comes b thus we try to replace \\'a\\' with \\'b\\'\\n3) During all \\'a\\' we would replace the last character with \\'b\\'\\n```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n        int n=palindrome.size();\\n        for(int i=0;i<n/2;i++){\\n            if(palindrome[i]!=\\'a\\'){ // Initially if a isn\\'t then it will be replaced by a \\n                palindrome[i]=\\'a\\';\\n                return palindrome;\\n            }\\n        }\\n        palindrome[n-1]=\\'b\\'; // Lexicographically smallest would be possible if last element is changed with a if all are \\'a\\' in the string\\n        return n<=1? \"\":palindrome; // If single a then return \"\" else return the string \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n        int n=palindrome.size();\\n        for(int i=0;i<n/2;i++){\\n            if(palindrome[i]!=\\'a\\'){ // Initially if a isn\\'t then it will be replaced by a \\n                palindrome[i]=\\'a\\';\\n                return palindrome;\\n            }\\n        }\\n        palindrome[n-1]=\\'b\\'; // Lexicographically smallest would be possible if last element is changed with a if all are \\'a\\' in the string\\n        return n<=1? \"\":palindrome; // If single a then return \"\" else return the string \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2786276,
                "title": "easiest-solution-100-faster-submission",
                "content": "\\nExplanation : This is a really simple question as its answer can be directly found in the question itself\\n\\nFirst we need to plaindrome which is simple just traverse the string and pick any character replaces it and we have a string that is not a plaindrome now and the only string that cannot be broken is a string with only one character which is our base case so we we simple take it as an edge case \\n\\nThe second part of the question states that we should be doing the replacement of the string in such a way such that the new string is lexicographically lowest so we get Greedy and simply traverse the string break at that character that can be replaced as \"a\" and thats it thats the string which for sure gives the right answer \\n\\nThe last edge case wee need to handle is what if we get a string which is all \"a\" then simply we replace the last character of the string with \"b\" as this is lexicographically lowest \\n\\n\\nThats it thats the most simple oslution to this problem\\n\\n\\nstring breakPalindrome(string palindrome) {\\n        int n=palindrome.length();\\n        if(n==1) return \"\";\\n        int t=-1;\\n        for(int i=0; i<n/2; i++) {\\n           if(palindrome[i]>97) {\\n               t=i;\\n               break;\\n           }\\n        }\\n        if(t==-1) return palindrome.substr(0,n-1)+\"b\";\\n        return palindrome.substr(0,t)+\"a\"+palindrome.substr(t+1,n-(t+1));\\n    }\\n\\t\\n\\t",
                "solutionTags": [
                    "String"
                ],
                "code": "\\nExplanation : This is a really simple question as its answer can be directly found in the question itself\\n\\nFirst we need to plaindrome which is simple just traverse the string and pick any character replaces it and we have a string that is not a plaindrome now and the only string that cannot be broken is a string with only one character which is our base case so we we simple take it as an edge case \\n\\nThe second part of the question states that we should be doing the replacement of the string in such a way such that the new string is lexicographically lowest so we get Greedy and simply traverse the string break at that character that can be replaced as \"a\" and thats it thats the string which for sure gives the right answer \\n\\nThe last edge case wee need to handle is what if we get a string which is all \"a\" then simply we replace the last character of the string with \"b\" as this is lexicographically lowest \\n\\n\\nThats it thats the most simple oslution to this problem\\n\\n\\nstring breakPalindrome(string palindrome) {\\n        int n=palindrome.length();\\n        if(n==1) return \"\";\\n        int t=-1;\\n        for(int i=0; i<n/2; i++) {\\n           if(palindrome[i]>97) {\\n               t=i;\\n               break;\\n           }\\n        }\\n        if(t==-1) return palindrome.substr(0,n-1)+\"b\";\\n        return palindrome.substr(0,t)+\"a\"+palindrome.substr(t+1,n-(t+1));\\n    }\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2732907,
                "title": "python-o-n-greedy",
                "content": "```\\nclass Solution:\\n    def breakPalindrome(self, palindrome: str) -> str:\\n        length = len(palindrome)\\n        if length == 1:\\n            return \"\"\\n        for i in range(length):\\n            if palindrome[i] != \\'a\\':\\n                if length%2 == 1 and length//2 == i:\\n                    continue\\n                return palindrome[:i] + \\'a\\' + palindrome[i + 1:]\\n        return palindrome[:-1] + \\'b\\'",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def breakPalindrome(self, palindrome: str) -> str:\\n        length = len(palindrome)\\n        if length == 1:\\n            return \"\"\\n        for i in range(length):\\n            if palindrome[i] != \\'a\\':\\n                if length%2 == 1 and length//2 == i:\\n                    continue\\n                return palindrome[:i] + \\'a\\' + palindrome[i + 1:]\\n        return palindrome[:-1] + \\'b\\'",
                "codeTag": "Java"
            },
            {
                "id": 2694009,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string s) {\\n        if(s.size()==1) return \"\";\\n        int i=0;\\n        int j=s.length()-1;\\n        bool flag=false;\\n        while(i<j){\\n            if(s[i]!=\\'a\\'){\\n                s[i]=\\'a\\';\\n                flag=true;\\n                break;\\n            }\\n            i++;\\n            j--;\\n        }\\n        if(!flag) s[s.length()-1]=\\'b\\';\\n        return s;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    string breakPalindrome(string s) {\\n        if(s.size()==1) return \"\";\\n        int i=0;\\n        int j=s.length()-1;\\n        bool flag=false;\\n        while(i<j){\\n            if(s[i]!=\\'a\\'){\\n                s[i]=\\'a\\';\\n                flag=true;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2691606,
                "title": "c-set-easy-to-understand-code",
                "content": "![image](https://assets.leetcode.com/users/images/a774ae73-18bd-4821-9eb9-9563048ffe4b_1665511286.5795295.png)\\n\\n**T->O(n^2) && S->O(1)**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tstring breakPalindrome(string pal) {\\n\\t\\t\\t\\tint n=pal.size();\\n\\t\\t\\t\\tif(n==1) return \"\";\\n\\t\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\t\\tif(pal[i]!=\\'a\\'){\\n\\t\\t\\t\\t\\t\\tchar temp=pal[i];\\n\\t\\t\\t\\t\\t\\tpal[i]=\\'a\\';\\n\\t\\t\\t\\t\\t\\tset<char>s;\\n\\t\\t\\t\\t\\t\\tfor(auto i:pal) s.insert(i);\\n\\t\\t\\t\\t\\t\\tif(s.size()!=1) return pal;\\n\\t\\t\\t\\t\\t\\tpal[i]=temp;\\n\\t\\t\\t\\t\\t}   \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tpal[n-1]=\\'b\\';\\n\\t\\t\\t\\treturn pal;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tstring breakPalindrome(string pal) {\\n\\t\\t\\t\\tint n=pal.size();\\n\\t\\t\\t\\tif(n==1) return \"\";\\n\\t\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\t\\tif(pal[i]!=\\'a\\'){\\n\\t\\t\\t\\t\\t\\tchar temp=pal[i];\\n\\t\\t\\t\\t\\t\\tpal[i]=\\'a\\';\\n\\t\\t\\t\\t\\t\\tset<char>s;\\n\\t\\t\\t\\t\\t\\tfor(auto i:pal) s.insert(i);\\n\\t\\t\\t\\t\\t\\tif(s.size()!=1) return pal;\\n\\t\\t\\t\\t\\t\\tpal[i]=temp;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2691440,
                "title": "java-easy-0-ms-simple-solution-using-stringbuilder",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        if(palindrome.length()==1)\\n        return \"\";\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(palindrome);\\n        for(int i=0; i<sb.length()/2;i++){\\n            if(sb.charAt(i) != \\'a\\'){\\n                sb = sb.replace(i,i+1,\"a\");\\n                break;\\n            }\\n        }\\n        if(palindrome.equals(sb.toString())){\\n            sb = sb.replace(sb.length()-1,sb.length(),\"b\");\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        if(palindrome.length()==1)\\n        return \"\";\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(palindrome);\\n        for(int i=0; i<sb.length()/2;i++){\\n            if(sb.charAt(i) != \\'a\\'){\\n                sb = sb.replace(i,i+1,\"a\");\\n                break;\\n            }\\n        }\\n        if(palindrome.equals(sb.toString())){\\n            sb = sb.replace(sb.length()-1,sb.length(),\"b\");\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2688092,
                "title": "java-easy-to-understand-100-fast",
                "content": "\\n```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n\\t\\t// impossible to break length-1 palindrome\\n        if (palindrome.length() <= 1) {\\n            return \"\";\\n        }\\n        char[] sArray = palindrome.toCharArray();\\n        int lo = 0, hi = sArray.length - 1;\\n\\t\\t// find and replace first non \\'a\\' with \\'a\\' from the first half of the palindrome\\n\\t\\t// for odd-length palindromes, exclude the middle character\\n        while (lo < sArray.length / 2) {\\n            if (sArray[lo] != \\'a\\') {\\n                sArray[lo] = \\'a\\';\\n                return new String(sArray);\\n            }\\n            lo++;\\n        }\\n\\t\\t\\n\\t\\t// the first half only has \\'a\\'s, replace the last character with its next neighbor \\n        sArray[hi] = (char) ((int) sArray[hi] + 1);\\n        return new String(sArray);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n\\t\\t// impossible to break length-1 palindrome\\n        if (palindrome.length() <= 1) {\\n            return \"\";\\n        }\\n        char[] sArray = palindrome.toCharArray();\\n        int lo = 0, hi = sArray.length - 1;\\n\\t\\t// find and replace first non \\'a\\' with \\'a\\' from the first half of the palindrome\\n\\t\\t// for odd-length palindromes, exclude the middle character\\n        while (lo < sArray.length / 2) {\\n            if (sArray[lo] != \\'a\\') {\\n                sArray[lo] = \\'a\\';\\n                return new String(sArray);\\n            }\\n            lo++;\\n        }\\n\\t\\t\\n\\t\\t// the first half only has \\'a\\'s, replace the last character with its next neighbor \\n        sArray[hi] = (char) ((int) sArray[hi] + 1);\\n        return new String(sArray);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2688009,
                "title": "c-easy-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string s) {\\n        int n =s.length();\\n        if(n<=1)return \"\"; // if size of string is one or empty \\n        for(int i =0;i<n/2;i++){\\n            if(s[i]!=\\'a\\'){\\n                s[i]=\\'a\\';\\n                return s;\\n            }\\n        }\\n        s[n-1]=\\'b\\';                // if aaaa change the last letter to b\\n        return s;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string breakPalindrome(string s) {\\n        int n =s.length();\\n        if(n<=1)return \"\"; // if size of string is one or empty \\n        for(int i =0;i<n/2;i++){\\n            if(s[i]!=\\'a\\'){\\n                s[i]=\\'a\\';\\n                return s;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2687884,
                "title": "java-solution-without-using-any-additional-char-array-100-faster",
                "content": "class Solution {\\n    public String breakPalindrome(String palindrome) {\\n        \\n\\t\\tint n = palindrome.length();\\n        if (n == 1) return \"\";\\n        StringBuilder sb = new  StringBuilder(palindrome);\\n        \\n\\t\\t// loop only till n/2 as the  string is already given as palindrome\\n        for  (int  i=0; i<n/2; i++){\\n            if(palindrome.charAt(i) != \\'a\\'){\\n                sb.setCharAt(i,\\'a\\');\\n                return sb.toString();\\n            }\\n        }\\n        \\n        sb.setCharAt(n-1, \\'b\\');\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n    public String breakPalindrome(String palindrome) {\\n        \\n\\t\\tint n = palindrome.length();\\n        if (n == 1) return \"\";\\n        StringBuilder sb = new  StringBuilder(palindrome);\\n        \\n\\t\\t// loop only till n/2 as the  string is already given as palindrome\\n        for  (int  i=0; i<n/2; i++){\\n            if(palindrome.charAt(i) != \\'a\\'){\\n                sb.setCharAt(i,\\'a\\');\\n                return sb.toString();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2687865,
                "title": "daily-leetcoding-challenge",
                "content": "```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        if(palindrome.length()==1)\\n            return \"\";\\n        \\n        for(int i=0;i<palindrome.length()/2;i++)\\n        {\\n            if(palindrome.charAt(i)!=\\'a\\')\\n            {\\n                palindrome = palindrome.substring(0, i) + \\'a\\' + palindrome.substring(i + 1);\\n                return palindrome;\\n            }\\n        }\\n        palindrome = palindrome.substring(0,palindrome.length()-1) + \\'b\\' + palindrome.substring(palindrome.length());\\n        return palindrome;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        if(palindrome.length()==1)\\n            return \"\";\\n        \\n        for(int i=0;i<palindrome.length()/2;i++)\\n        {\\n            if(palindrome.charAt(i)!=\\'a\\')\\n            {\\n                palindrome = palindrome.substring(0, i) + \\'a\\' + palindrome.substring(i + 1);\\n                return palindrome;\\n            }\\n        }\\n        palindrome = palindrome.substring(0,palindrome.length()-1) + \\'b\\' + palindrome.substring(palindrome.length());\\n        return palindrome;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687816,
                "title": "easy-c-fast-tc-o-n-sc-o-1-readable",
                "content": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n        int n = palindrome.size();;\\n        if(n==1)\\n            return string(\"\");\\n        \\n        for(int i=0; i<n/2; i++) {\\n            if(palindrome[i]!=\\'a\\') {\\n                palindrome[i] = \\'a\\';\\n                return palindrome;\\n            }\\n        }\\n        \\n        palindrome[n-1] = \\'b\\';\\n        return palindrome;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n        int n = palindrome.size();;\\n        if(n==1)\\n            return string(\"\");\\n        \\n        for(int i=0; i<n/2; i++) {\\n            if(palindrome[i]!=\\'a\\') {\\n                palindrome[i] = \\'a\\';\\n                return palindrome;\\n            }\\n        }\\n        \\n        palindrome[n-1] = \\'b\\';\\n        return palindrome;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687810,
                "title": "easy-java-solution-using-character-array-0-ms",
                "content": "```\\nclass Solution {\\n    public String breakPalindrome(String str) \\n    {\\n     if (str.length() == 1) \\n        return \"\";\\n     char[] ch = str.toCharArray();\\n        for (int i = 0; i < str.length() / 2; i++) {\\n            if (ch[i] != \\'a\\') {\\n               \\n                ch[i] = \\'a\\';\\n               \\n                return new String(ch);\\n            }\\n        }\\n        ch[str.length() - 1] = \\'b\\';\\n        return new String(ch);\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/51978ab5-7c94-48fd-8459-6ffbca01b6d3_1665432799.9402435.png)\\n",
                "solutionTags": [
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String breakPalindrome(String str) \\n    {\\n     if (str.length() == 1) \\n        return \"\";\\n     char[] ch = str.toCharArray();\\n        for (int i = 0; i < str.length() / 2; i++) {\\n            if (ch[i] != \\'a\\') {\\n               \\n                ch[i] = \\'a\\';\\n               \\n                return new String(ch);\\n            }\\n        }\\n        ch[str.length() - 1] = \\'b\\';\\n        return new String(ch);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687749,
                "title": "c-basic-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince your answer should be a lexicograpical string and it should not be a palindrome then you must have to play with only \\'a\\' and \\'b\\'.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy method was fairly straightforward: iterate through the string and, whenever you come across a character other than \\'a\\', just replace it with \\'a\\'.\\n\\n There are a few edge cases.\\nFor example, if every character in the string is \\'a\\', you must simply change the last character to \\'b\\'. Another edge case is that if the string is an odd length, you must skip the middle character because doing so would cause the string to become a palindrome after the change.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) \\nThe worst case scenario, when every character is \\'a\\', \\nit requires you to iterate through the entire string.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\nNO Extra Space required.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n\\n        if(palindrome.size() == 1)\\n            return \"\";\\n\\n        for(int i = 0; i < palindrome.size()-1; i++){\\n            if(i == palindrome.size()/2 && palindrome.size() & 1){\\n                continue;\\n            }\\n            if(palindrome[i] != \\'a\\'){\\n                palindrome[i] = \\'a\\';\\n                return palindrome;\\n            }\\n        }\\n        palindrome[palindrome.size()-1] = \\'b\\';\\n\\n        return palindrome;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n\\n        if(palindrome.size() == 1)\\n            return \"\";\\n\\n        for(int i = 0; i < palindrome.size()-1; i++){\\n            if(i == palindrome.size()/2 && palindrome.size() & 1){\\n                continue;\\n            }\\n            if(palindrome[i] != \\'a\\'){\\n                palindrome[i] = \\'a\\';\\n                return palindrome;\\n            }\\n        }\\n        palindrome[palindrome.size()-1] = \\'b\\';\\n\\n        return palindrome;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687610,
                "title": "simple-java-solution-easy-to-understand",
                "content": "Upvote if you liked the solution\\n```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        //hint 1-  impossible to perform the replacement\\n        if(palindrome.length()==1) return \"\";\\n        String ans=\"\";\\n        \\n        //hint 2 - Change the first non \\'a\\' character to \\'a\\'.\\n        if(palindrome.charAt(0)!=\\'a\\')\\n        {\\n            return \\'a\\'+palindrome.substring(1);\\n        }\\n        \\n        //hint 3 - if all chars are a.\\n        boolean allA=true;\\n        for(int i=0;i<palindrome.length();i++)\\n            if(palindrome.charAt(i)!=\\'a\\'){\\n                allA=false;break;\\n            }\\n        \\n        if(allA==true) return palindrome.substring(0,palindrome.length()-1)+\\'b\\';\\n        //for aaaa returning aaab. which will be the least instead of baaa\\n        \\n        //now since last char is not a so we will return all with last char as small(b)\\n        \\n        \\n        for(int i=0;i<palindrome.length()/2;i++){// this /2 is important\\n           if(palindrome.charAt(i)!=\\'a\\'){\\n                return palindrome.substring(0,i)+\\'a\\'+palindrome.substring(i+1,palindrome.length());\\n            }\\n        }\\n        \\n        return palindrome.substring(0,palindrome.length()-1)+\\'b\\';\\n    }\\n}",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "String"
                ],
                "code": "class Solution {\\n    public String breakPalindrome(String palindrome) {\\n        //hint 1-  impossible to perform the replacement\\n        if(palindrome.length()==1) return \"\";\\n        String ans=\"\";\\n        \\n        //hint 2 - Change the first non \\'a\\' character to \\'a\\'.\\n        if(palindrome.charAt(0)!=\\'a\\')\\n        {\\n            return \\'a\\'+palindrome.substring(1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2687606,
                "title": "easiest-intuitive-faster-than-99-submissions",
                "content": "```\\nclass Solution:\\n    def breakPalindrome(self, palindrome: str) -> str:\\n        p=list(palindrome)\\n        n=len(p)\\n        if n==1 :\\n            return \"\"\\n        for i in range(n) :\\n            if p[i] != \\'a\\' :\\n                p[i] = \\'a\\'\\n                break\\n        if p != p[::-1] :\\n            return \\'\\'.join(p)\\n        p=list(palindrome)\\n        n=len(p)\\n        for i in range(n-1,-1,-1):\\n            if p[i] == \\'a\\' :\\n                p[i] = \\'b\\'\\n                break\\n        return \\'\\'.join(p)\\n```\\nDo upvote if its helpful,Thanks.",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def breakPalindrome(self, palindrome: str) -> str:\\n        p=list(palindrome)\\n        n=len(p)\\n        if n==1 :\\n            return \"\"\\n        for i in range(n) :\\n            if p[i] != \\'a\\' :\\n                p[i] = \\'a\\'\\n                break\\n        if p != p[::-1] :\\n            return \\'\\'.join(p)\\n        p=list(palindrome)\\n        n=len(p)\\n        for i in range(n-1,-1,-1):\\n            if p[i] == \\'a\\' :\\n                p[i] = \\'b\\'\\n                break\\n        return \\'\\'.join(p)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687605,
                "title": "java-easy-solution-100-faster-explained",
                "content": "Hey there\\nlook we need string  lexicographically smaller so to obtain this just replace where character != \\'a\\' with a\\njust traverse only half of string as its is palidrome other part will be same\\nedge case when string contain all a\\'s eg -> \"aaaaa\" then smallest lexicographically just replace last char with b\\nLook at below code you will understand clearly\\n\\n```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        \\n        int n = palindrome.length();\\n        if (n == 1) {\\n            return \"\";\\n        }\\n\\n        char[] arr = palindrome.toCharArray();\\n        for (int i = 0; i < n/2; i++) {\\n            if (arr[i] != \\'a\\') {\\n                arr[i] = \\'a\\';\\n                return new String(arr);\\n            }\\n        }\\n        \\n        arr[n-1] = \\'b\\';\\n        return new String(arr);\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        \\n        int n = palindrome.length();\\n        if (n == 1) {\\n            return \"\";\\n        }\\n\\n        char[] arr = palindrome.toCharArray();\\n        for (int i = 0; i < n/2; i++) {\\n            if (arr[i] != \\'a\\') {\\n                arr[i] = \\'a\\';\\n                return new String(arr);\\n            }\\n        }\\n        \\n        arr[n-1] = \\'b\\';\\n        return new String(arr);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687535,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string p) {\\n        string ans=\"\";\\n        if(p.size()==1) return ans;\\n        for(int i=0;i<p.size()/2;i++)\\n        {\\n            if(p[i]!=\\'a\\')\\n            {\\n                p[i]=\\'a\\';\\n                return p;\\n            }\\n        }\\n        p[p.size()-1]=\\'b\\';\\n        return p;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string p) {\\n        string ans=\"\";\\n        if(p.size()==1) return ans;\\n        for(int i=0;i<p.size()/2;i++)\\n        {\\n            if(p[i]!=\\'a\\')\\n            {\\n                p[i]=\\'a\\';\\n                return p;\\n            }\\n        }\\n        p[p.size()-1]=\\'b\\';\\n        return p;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687532,
                "title": "java-very-easy-code",
                "content": "upvote if you like!\\n\\n```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string str) {\\n        if(str.length()<=1) return \"\";\\n        int flag=0;\\n        for(int i=0;i<str.length()/2;i++){\\n            if(str[i]!=\\'a\\'){\\n                str[i]=\\'a\\';\\n                return str;\\n            }\\n        }\\n       \\n       str[str.length()-1]=\\'b\\';\\n       \\n       return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string str) {\\n        if(str.length()<=1) return \"\";\\n        int flag=0;\\n        for(int i=0;i<str.length()/2;i++){\\n            if(str[i]!=\\'a\\'){\\n                str[i]=\\'a\\';\\n                return str;\\n            }\\n        }\\n       \\n       str[str.length()-1]=\\'b\\';\\n       \\n       return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687437,
                "title": "100-faster-cpp-solution-string",
                "content": "class Solution {\\npublic:\\n\\n    string breakPalindrome(string palindrome) {\\n        int n=palindrome.length();\\n        if(n==1)  return \"\";\\n        int flag=true;\\n        if(n%2==0)  //even\\n        {\\n            for(int i=0;2*i<n;i++)\\n            {\\n                if(palindrome[i]!=\\'a\\')\\n                { \\n                    palindrome[i]=\\'a\\';\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n                if(flag==true)palindrome[n-1]=\\'b\\';\\n        }\\n         else //odd\\n        {\\n            for(int i=0;2*i<n;i++)\\n            {\\n                if(palindrome[i]!=\\'a\\'&&i!=(n/2))\\n                {\\n                    palindrome[i]=\\'a\\';\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n                if(flag==true)palindrome[n-1]=\\'b\\';\\n        }\\n     \\n        return palindrome;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n\\n    string breakPalindrome(string palindrome) {\\n        int n=palindrome.length();\\n        if(n==1)  return \"\";\\n        int flag=true;\\n        if(n%2==0)  //even\\n        {\\n            for(int i=0;2*i<n;i++)\\n            {\\n                if(palindrome[i]!=\\'a\\')\\n                { \\n                    palindrome[i]=\\'a\\';\\n                    flag=false;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2687417,
                "title": "java-solution-100-faster-o-n",
                "content": "# Intuition\\nThe problem is not that hard. Since we have to replace one character. The only thing that makes this question slightly challenging is the lexiographical order the answer expects.\\n\\n# Approach\\nWe need to iterate till the half. If there is any char that is other than \\'a\\' simply replace it with \\'a\\' and return string.\\n\\nIf all the char till mid are \\'a\\', then replace the last char with \\'b\\'\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        int length = palindrome.length();\\n        if(length == 1) {\\n            return \"\";\\n        }\\n        char[] ch = palindrome.toCharArray();\\n        int itrLen = (length/2) - 1;\\n        for(int i=0 ; i<= itrLen; i++) {\\n            if(ch[i] != \\'a\\') {\\n                ch[i] = \\'a\\';\\n                return String.valueOf(ch);\\n            }\\n        }\\n\\n        ch[length - 1] = \\'b\\';\\n        return String.valueOf(ch);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        int length = palindrome.length();\\n        if(length == 1) {\\n            return \"\";\\n        }\\n        char[] ch = palindrome.toCharArray();\\n        int itrLen = (length/2) - 1;\\n        for(int i=0 ; i<= itrLen; i++) {\\n            if(ch[i] != \\'a\\') {\\n                ch[i] = \\'a\\';\\n                return String.valueOf(ch);\\n            }\\n        }\\n\\n        ch[length - 1] = \\'b\\';\\n        return String.valueOf(ch);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687384,
                "title": "c-easy-soln-100-faster-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(N/2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string p) {\\n        if(p.length()==1) return \"\";\\n\\n        for(int i=0;i<p.length()/2;i++)\\n        {\\n            if(p[i]!=\\'a\\') \\n            {\\n               p[i]=\\'a\\'; \\n               return p; \\n            }\\n        }\\n        p[p.length()-1]=\\'b\\';\\n        return p;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string p) {\\n        if(p.length()==1) return \"\";\\n\\n        for(int i=0;i<p.length()/2;i++)\\n        {\\n            if(p[i]!=\\'a\\') \\n            {\\n               p[i]=\\'a\\'; \\n               return p; \\n            }\\n        }\\n        p[p.length()-1]=\\'b\\';\\n        return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687342,
                "title": "0ms-solution-100-faster-java",
                "content": "class Solution {\\n    public String breakPalindrome(String palindrome) {\\n        StringBuilder sb=new StringBuilder(palindrome);\\n        if(palindrome.length()==1)\\n            return \"\";\\n       \\n       \\n        for(int i=0;i<sb.length()/2;i++)\\n        {\\n            if(sb.charAt(i)==97)\\n            {\\n                \\n            }\\n            else\\n            {\\n                \\n                sb.setCharAt(i,(char)(97));\\n                 String ans=sb.toString();\\n                return ans;\\n                    \\n            }\\n        }\\n        sb.setCharAt(sb.length()-1,\\'b\\');\\n        String str=sb.toString();\\n        \\n        return str;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String breakPalindrome(String palindrome) {\\n        StringBuilder sb=new StringBuilder(palindrome);\\n        if(palindrome.length()==1)\\n            return \"\";\\n       \\n       \\n        for(int i=0;i<sb.length()/2;i++)\\n        {\\n            if(sb.charAt(i)==97)\\n            {\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2687338,
                "title": "c-easy-understanding",
                "content": "class Solution {\\npublic:\\n\\n    string breakPalindrome(string p) {\\n        int n=p.length();\\n        if(n==1)\\n            return \"\";\\n        \\n        for(int i=0;i<n/2;i++)\\n        {\\n            if(p[i]!=\\'a\\')\\n            {\\n                p[i]=\\'a\\';\\n                return p;\\n            }\\n        }\\n        \\n        for(int i=n-1;i>=n/2;i--)\\n        {\\n             if(p[i]==\\'z\\')\\n             {\\n                 p[i]=\\'a\\';\\n                 return p;\\n             }\\n             else\\n             {\\n                 // char ch=p[i];\\n                 // ch++;\\n                 // p[i]=ch;\\n                 p[i]++;\\n                 return p;\\n             }\\n                 \\n        }\\n        \\n        \\n        return \"\";\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    string breakPalindrome(string p) {\\n        int n=p.length();\\n        if(n==1)\\n            return \"\";\\n        \\n        for(int i=0;i<n/2;i++)\\n        {\\n            if(p[i]!=\\'a\\')\\n            {\\n                p[i]=\\'a\\';\\n                return p;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2687224,
                "title": "c-100-faster-0ms-solution",
                "content": "**Please upvote if you find helpful**\\n```\\n string breakPalindrome(string s) {\\n        int n = s.size();\\n        if(n == 1)\\n            return \"\";\\n        int i = 0;\\n\\t\\t// checking for the first char that is not equal to \\'a\\'\\n        for(i = 0; i < n; i++)\\n        {\\n\\t\\t// if len is odd then we can\\'t make string not pallindrome by replacing this character\\n            if(n&1 && i == n/2) \\n                continue;\\n            if(s[i] != \\'a\\')\\n                break;\\n        }\\n           // all chars are \\'a\\' then we can make lexo smaller by replacing last char with \\'b\\'\\n        if(i == n )\\n            s[n-1] = \\'b\\';\\n        else\\n            s[i] = \\'a\\';\\n        return s;\\n    }\\n\\t```\\n\\t**Please upvote if it was helpful**",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\n string breakPalindrome(string s) {\\n        int n = s.size();\\n        if(n == 1)\\n            return \"\";\\n        int i = 0;\\n\\t\\t// checking for the first char that is not equal to \\'a\\'\\n        for(i = 0; i < n; i++)\\n        {\\n\\t\\t// if len is odd then we can\\'t make string not pallindrome by replacing this character\\n            if(n&1 && i == n/2) \\n                continue;\\n            if(s[i] != \\'a\\')\\n                break;\\n        }\\n           // all chars are \\'a\\' then we can make lexo smaller by replacing last char with \\'b\\'\\n        if(i == n )\\n            s[n-1] = \\'b\\';\\n        else\\n            s[i] = \\'a\\';\\n        return s;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2687208,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n      int n = palindrome.size();\\n        if(n <= 1) return \"\";\\n        \\n        for(int i=0; i<n/2; i++)\\n\\t\\t{\\n            if(palindrome[i] != \\'a\\')\\n\\t\\t\\t{\\n                palindrome[i] = \\'a\\';\\n                return palindrome;\\n            }\\n        }\\n        palindrome[n-1] = \\'b\\';\\n        return palindrome;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n      int n = palindrome.size();\\n        if(n <= 1) return \"\";\\n        \\n        for(int i=0; i<n/2; i++)\\n\\t\\t{\\n            if(palindrome[i] != \\'a\\')\\n\\t\\t\\t{\\n                palindrome[i] = \\'a\\';\\n                return palindrome;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2687185,
                "title": "java-solution-100-faster-than-other-solution",
                "content": "class Solution {\\n    public String breakPalindrome(String palindrome) {\\n        char[] Str = palindrome.toCharArray();\\n        if(Str.length<2) return \"\";\\n        \\n        for(int i = 0;i<Str.length/2;i++) {\\n            if(Str[i]!=\\'a\\') {\\n                Str[i] = \\'a\\';\\n            return String.valueOf(Str);\\n            }\\n        }\\n       Str[Str.length-1] = \\'b\\';\\n        return String.valueOf(Str);      \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String breakPalindrome(String palindrome) {\\n        char[] Str = palindrome.toCharArray();\\n        if(Str.length<2) return \"\";\\n        \\n        for(int i = 0;i<Str.length/2;i++) {\\n            if(Str[i]!=\\'a\\') {\\n                Str[i] = \\'a\\';\\n            return String.valueOf(Str);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2687180,
                "title": "c-o-n-tc-faster-than-100-simple-code",
                "content": "To understand the problem, let\\'s summarise what we\\'re expected to do:\\n1. We **must** substitute exactly one character\\n2. The result **must not** be a palindrome\\n3. If there are multiple strings that satisfy #1 and #2, we pick the lexicographically smallest one\\n\\nA palindrome is a string with central symmetry, meaning that for any `std::string s` which is a palindrome, and `auto l = s.length()` the following is true:\\n```\\ns[i] == s[l-i-1] for i in range [0, l-1]\\n```\\nThis leads to **the first insight**: *any* character we replace will break the palindrome condition, with the exception of the centre position for strings with odd number of characters:\\n```\\nstd::string s1 = \"abba\";   // replacing any character makes s1 a non-palindrome\\nstd::string s2 = \"abcba\"; // here, replacing \\'c\\' with anything doesn\\'t change a thing, since \\'c\\' is at the centre position\\n```\\nWe can take this insight further and use the fact that the input string is a palindrome to only scan its left half, since the right half must be its reflection.\\n\\n**The second insight** is: replacing the leftmost non `\\'a\\'` character with `\\'a\\'` produces a lexicographically smallest string:\\n```\\nstd::string s = \"bbbbb\"; // out of all ways to modify s, \"abbbb\" is the lexicographically smallest one\\n```\\n\\nFinally, **the third insight** is: if all characters (regardless of the one at the centre) are `\\'a\\'`, then replacing the rightmost one with `\\'b\\'` creates the lexicographically smallest modification:\\n```\\nstd::string s = \"aaaaa\"; // out of all variations, \"aaaab\" is the lexicographically smallest\\n```\\n\\nNow we simply need to combine all three insights together:\\n\\n```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n        if (palindrome.length() < 2) return std::string();\\n        \\n        int indexLimit = palindrome.length() >> 1;\\n        auto i{0};\\n\\n        for (; i != indexLimit; ++i) {\\n            if (palindrome[i] > \\'a\\') {\\n                palindrome[i] = \\'a\\';                \\n                break;\\n            }\\n        }\\n\\n        if (i == indexLimit) {\\n            palindrome.back() = \\'b\\';\\n        }\\n\\n        return std::move(palindrome); // this will allow re-using memory inside palindrome instead of copying it\\n    }\\n};\\n```\\n\\nRuntime complexity is **O(n)** where `n` is `palindrome.length()`, because we sequentially scan a half of the input string. Space complexity is **O(1)** since we only need two extra integers to run the algorithm.\\nOverall, it runs comfortably at 0 ms:\\n\\n![image](https://assets.leetcode.com/users/images/715c3c20-be25-400a-926f-0f6976ed465f_1665422898.9552605.png)\\n\\nIf you have any questions, don\\'t hesitate to ask =)\\n**Also, please consider upvoting this post if you found it useful**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ns[i] == s[l-i-1] for i in range [0, l-1]\\n```\n```\\nstd::string s1 = \"abba\";   // replacing any character makes s1 a non-palindrome\\nstd::string s2 = \"abcba\"; // here, replacing \\'c\\' with anything doesn\\'t change a thing, since \\'c\\' is at the centre position\\n```\n```\\nstd::string s = \"bbbbb\"; // out of all ways to modify s, \"abbbb\" is the lexicographically smallest one\\n```\n```\\nstd::string s = \"aaaaa\"; // out of all variations, \"aaaab\" is the lexicographically smallest\\n```\n```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n        if (palindrome.length() < 2) return std::string();\\n        \\n        int indexLimit = palindrome.length() >> 1;\\n        auto i{0};\\n\\n        for (; i != indexLimit; ++i) {\\n            if (palindrome[i] > \\'a\\') {\\n                palindrome[i] = \\'a\\';                \\n                break;\\n            }\\n        }\\n\\n        if (i == indexLimit) {\\n            palindrome.back() = \\'b\\';\\n        }\\n\\n        return std::move(palindrome); // this will allow re-using memory inside palindrome instead of copying it\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687170,
                "title": "100-fast-easy-java-solution",
                "content": "class Solution {\\n    public String breakPalindrome(String palindrome) {\\n        int n = palindrome.length();\\n        if(n <= 1) return \"\";\\n        char[] arr = palindrome.toCharArray();\\n        \\n        for(int i = 0; i < n/2; i++){\\n            if(arr[i] != \\'a\\'){\\n                arr[i] = \\'a\\';\\n                return String.valueOf(arr);\\n            }\\n            \\n        }\\n        arr[n-1] = \\'b\\';\\n        return String.valueOf(arr);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "class Solution {\\n    public String breakPalindrome(String palindrome) {\\n        int n = palindrome.length();\\n        if(n <= 1) return \"\";\\n        char[] arr = palindrome.toCharArray();\\n        \\n        for(int i = 0; i < n/2; i++){\\n            if(arr[i] != \\'a\\'){\\n                arr[i] = \\'a\\';\\n                return String.valueOf(arr);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2687141,
                "title": "java-string-fastest-solution-0ms",
                "content": "```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        // Code here\\n        if(palindrome.length() == 1)\\n            return \"\";\\n        \\n        char[] ch = palindrome.toCharArray(); \\n        \\n        for(int i = 0; i < palindrome.length()/2; i++)\\n        {\\n            if(ch[i] != \\'a\\')\\n            {\\n                ch[i] = \\'a\\';\\n                break;\\n            }\\n            else if(i == palindrome.length()/2 - 1 && ch[i] == \\'a\\')\\n                ch[ch.length -1] = \\'b\\';\\n        }\\n        \\n        return new String(ch);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        // Code here\\n        if(palindrome.length() == 1)\\n            return \"\";\\n        \\n        char[] ch = palindrome.toCharArray(); \\n        \\n        for(int i = 0; i < palindrome.length()/2; i++)\\n        {\\n            if(ch[i] != \\'a\\')\\n            {\\n                ch[i] = \\'a\\';\\n                break;\\n            }\\n            else if(i == palindrome.length()/2 - 1 && ch[i] == \\'a\\')\\n                ch[ch.length -1] = \\'b\\';\\n        }\\n        \\n        return new String(ch);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687104,
                "title": "100-faster-java-solution",
                "content": "class Solution {\\n    public String breakPalindrome(String palindrome) {\\n        int len = palindrome.length();\\n        char strArr[] = palindrome.toCharArray();\\n        for(int i=0;i<len/2;i++){\\n            if(strArr[i] != \\'a\\'){\\n                strArr[i] = \\'a\\';\\n                return String.valueOf(strArr);\\n            }\\n        }\\n        strArr[len-1] = \\'b\\';\\n        return len<=1?\"\":String.valueOf(strArr);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n    public String breakPalindrome(String palindrome) {\\n        int len = palindrome.length();\\n        char strArr[] = palindrome.toCharArray();\\n        for(int i=0;i<len/2;i++){\\n            if(strArr[i] != \\'a\\'){\\n                strArr[i] = \\'a\\';\\n                return String.valueOf(strArr);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2687048,
                "title": "best-o-n-python-solution-explained",
                "content": "**O(N) Python Solution**\\n```\\ndef breakPalindrome(self, palindrome: str) -> str:\\n\\tn = len(palindrome) # store palindrome length\\n\\tif n == 1: # no way to make 1 letter not a palindrome\\n\\t\\treturn \"\"\\n\\tfor i in range(n//2): # go through the first half of the palindrome\\n\\t\\tif palindrome[i] != \"a\": # if it is not an \"a\" then we can make it lexicographically smaller\\n\\t\\t\\treturn palindrome[:i] + \"a\" + palindrome[i+1:] # replace character with an \"a\"\\n\\treturn palindrome[:-1] + \"b\" # if all \"a\", then replace the last one with a \"b\"\\n```\\n\\n**Explanation**\\nThe idea behind this solution is that we want to make the string lexicographically smaller, so whenever there is an opportunity to turn a character which is not ```a``` into ```a```, we should. We only need to check the first ```n//2``` indices because we know that the input is a palindrome, so anything in the first ```n//2``` spots will be mirrored. If the string has an odd length, we cannot change the middle character since then the string would still be a palindrome. If we never find a character which is not ```a```, then we have to change one of the characters to ```b```. We want to add this to the end of the string since that minimizes the lexicographic value. We also have to check the length of ```palindrome``` is ```1``` since then there is no way to turn it into a non-palindrome, so we return ```\"\"```.\\n\\n**Complexity**\\nThis solution takes ```O(n)``` time since the number of characters we need to check scales with the length of ```palindrome```. It takes constant space since the memory we use does not change with the size of ```palindrome```.\\n\\n**Thanks for Reading!**\\nIf this post has been helpful, please consider upvoting! If you have any questions, please feel free to ask in the comments and I will try to answer them. Also, if I made any mistakes or there are other optimizations, methods I didn\\'t consider, etc. please let me know!",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\ndef breakPalindrome(self, palindrome: str) -> str:\\n\\tn = len(palindrome) # store palindrome length\\n\\tif n == 1: # no way to make 1 letter not a palindrome\\n\\t\\treturn \"\"\\n\\tfor i in range(n//2): # go through the first half of the palindrome\\n\\t\\tif palindrome[i] != \"a\": # if it is not an \"a\" then we can make it lexicographically smaller\\n\\t\\t\\treturn palindrome[:i] + \"a\" + palindrome[i+1:] # replace character with an \"a\"\\n\\treturn palindrome[:-1] + \"b\" # if all \"a\", then replace the last one with a \"b\"\\n```\n```a```\n```a```\n```n//2```\n```n//2```\n```a```\n```b```\n```palindrome```\n```1```\n```\"\"```\n```O(n)```\n```palindrome```\n```palindrome```",
                "codeTag": "Python3"
            },
            {
                "id": 2687036,
                "title": "100-java",
                "content": "```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        if(palindrome.length()==1)\\n            return \"\";\\n        int left=0;\\n        char[] arr=palindrome.toCharArray();\\n        int right=palindrome.length()-1;\\n        while(left<right){\\n            if(palindrome.charAt(left)-\\'a\\'>0){\\n                arr[left]=\\'a\\';\\n                return new String(arr);\\n            }\\n            left++; right--;\\n        }\\n        arr[palindrome.length()-1]++;\\n        return new String(arr);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        if(palindrome.length()==1)\\n            return \"\";\\n        int left=0;\\n        char[] arr=palindrome.toCharArray();\\n        int right=palindrome.length()-1;\\n        while(left<right){\\n            if(palindrome.charAt(left)-\\'a\\'>0){\\n                arr[left]=\\'a\\';\\n                return new String(arr);\\n            }\\n            left++; right--;\\n        }\\n        arr[palindrome.length()-1]++;\\n        return new String(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687010,
                "title": "100-faster-solution",
                "content": "This question is really interesting if u r beginner..\\nfirst try to understand how a word is lexographical smaller not in words only \\n\\nlet\\'s discuss the code\\nclass Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n\\t\\n\\t  // first find the length of the string...\\n\\t  \\n        int n = palindrome.size();\\n\\t\\t\\n\\t// if the size of string is 1 then you can\\'t make it non-palindromic.. this is edge case of problem.. so return the empty string as say in problem..\\n\\t\\n        if(n == 1)\\n            return \"\";\\n\\t\\t\\t\\n\\t// check every character of the string to the mid -1 element (i.e just before the mid element )  in case of 7 length or 6 lenght string we check only first 3 characters. \\n        for(int i=0;i<n/2;i++){\\n\\t\\t\\n\\t\\t// if the current character is non \\'a\\' then simply change the character to \\'a\\' because our goal is to make smallest lexographical word.\\n            if(palindrome[i] != \\'a\\'){\\n                palindrome[i] = \\'a\\';\\n\\t\\t\\t\\t// after this  we will got the desired answer...\\n                return palindrome;\\n            }\\n        }\\n\\t\\t// in case of all characters is \\'a\\' i.e. \"aaaa\" we simply change the last character to \\'b\\' for our desired answer...\\n\\t\\t\\n        palindrome[n-1] = \\'b\\';\\n\\t\\t// this will be our correct output in this case \"aaab\"\\n        return palindrome;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n\\t\\n\\t  // first find the length of the string...\\n\\t  \\n        int n = palindrome.size();\\n\\t\\t\\n\\t// if the size of string is 1 then you can\\'t make it non-palindromic.. this is edge case of problem.. so return the empty string as say in problem..\\n\\t\\n        if(n == 1)\\n            return \"\";\\n\\t\\t\\t\\n\\t// check every character of the string to the mid -1 element (i.e just before the mid element )  in case of 7 length or 6 lenght string we check only first 3 characters. \\n        for(int i=0;i<n/2;i++){\\n\\t\\t\\n\\t\\t// if the current character is non \\'a\\' then simply change the character to \\'a\\' because our goal is to make smallest lexographical word.\\n            if(palindrome[i] != \\'a\\'){\\n                palindrome[i] = \\'a\\';\\n\\t\\t\\t\\t// after this  we will got the desired answer...\\n                return palindrome;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2686973,
                "title": "rust-0-ms-simple-functional-style-solution-with-detailed-comments",
                "content": "This [**solution**](https://leetcode.com/submissions/detail/819479897/) employs a functional-style approach to find and replace letters. It demonstrated **0 ms runtime (100.00%)** and used **2.0 MB memory (100.00%)**. Time complexity is linear: **O(N)**. Space complexity is linear: **O(N)**. Detailed comments are provided.\\n\\nPlease check the analogous solution in [**Python**](https://leetcode.com/problems/break-a-palindrome/discuss/2685015/Python-fast-and-simple-solution-(with-detailed-comments)).\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nimpl Solution \\n{\\n    pub fn break_palindrome(mut palindrome: String) -> String \\n    {\\n        // [1] trivial case\\n        if palindrome.len() < 2 { return String::new(); }\\n        \\n        // [2] typical case: we should replace first non-\\'a\\' letter to \\'a\\'\\n        //     however, 2 counter-examples exist:\\n        //     - odd-length string of the form \\'aaaazaaaa\\'\\n        //     - all-\\'a\\' type of string (\\'aaaaa...a\\')\\n        //     both cases are covered by the solution below\\n        let mut bytes = palindrome.as_bytes().to_vec();\\n        (0..palindrome.len()/2).into_iter()\\n            .find(|&pos| bytes[pos] != b\\'a\\')\\n            .and_then(|pos| { bytes[pos] = b\\'a\\'; Some(0)})\\n            .or_else(|| { bytes[palindrome.len()-1] = b\\'b\\'; Some(0) });\\n\\n        String::from_utf8(bytes).unwrap()\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Rust",
                    "String"
                ],
                "code": "```\\nimpl Solution \\n{\\n    pub fn break_palindrome(mut palindrome: String) -> String \\n    {\\n        // [1] trivial case\\n        if palindrome.len() < 2 { return String::new(); }\\n        \\n        // [2] typical case: we should replace first non-\\'a\\' letter to \\'a\\'\\n        //     however, 2 counter-examples exist:\\n        //     - odd-length string of the form \\'aaaazaaaa\\'\\n        //     - all-\\'a\\' type of string (\\'aaaaa...a\\')\\n        //     both cases are covered by the solution below\\n        let mut bytes = palindrome.as_bytes().to_vec();\\n        (0..palindrome.len()/2).into_iter()\\n            .find(|&pos| bytes[pos] != b\\'a\\')\\n            .and_then(|pos| { bytes[pos] = b\\'a\\'; Some(0)})\\n            .or_else(|| { bytes[palindrome.len()-1] = b\\'b\\'; Some(0) });\\n\\n        String::from_utf8(bytes).unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2686953,
                "title": "100-faster-java-solution-with-explanation",
                "content": "```\\nclass Solution {\\n   \\n    \\n    public String breakPalindrome(String s) {\\n       \\n        int  n = s.length();  //length of the String\\n        \\n        //If the length of the string is 1 then it always a palindrome we cannot \\n\\t\\t//modify it in order to make it non-palindrome with length 1\\n        if(n == 1) return \"\";  \\n        \\n        for(int i = 0;i<n;i++){\\n           \\n            int j = n - 1 - i;\\n            //whenever the length is odd we just skip\\n            if(i == j) {\\n                continue;\\n            }\\n            //If first character is not \\'a\\' then replace it with \\'a\\' and return s\\n            if(s.charAt(i)!=\\'a\\'){ \\n            char c[] = s.toCharArray();\\n                c[i] = \\'a\\';\\n                s = new String(c);\\n              return s;\\n            }\\n            \\n        }\\n        char c[] = s.toCharArray(); \\n        //If all characters are \\'a\\' then last character should be replaced with \\n        //\\'b\\' to get lexicographically smallest one\\n        c[n-1] = \\'b\\';       \\n        s = new String(c);\\n        return s;\\n    }\\n}\\n//Time Complexity O(n)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   \\n    \\n    public String breakPalindrome(String s) {\\n       \\n        int  n = s.length();  //length of the String\\n        \\n        //If the length of the string is 1 then it always a palindrome we cannot \\n\\t\\t//modify it in order to make it non-palindrome with length 1\\n        if(n == 1) return \"\";  \\n        \\n        for(int i = 0;i<n;i++){\\n           \\n            int j = n - 1 - i;\\n            //whenever the length is odd we just skip\\n            if(i == j) {\\n                continue;\\n            }\\n            //If first character is not \\'a\\' then replace it with \\'a\\' and return s\\n            if(s.charAt(i)!=\\'a\\'){ \\n            char c[] = s.toCharArray();\\n                c[i] = \\'a\\';\\n                s = new String(c);\\n              return s;\\n            }\\n            \\n        }\\n        char c[] = s.toCharArray(); \\n        //If all characters are \\'a\\' then last character should be replaced with \\n        //\\'b\\' to get lexicographically smallest one\\n        c[n-1] = \\'b\\';       \\n        s = new String(c);\\n        return s;\\n    }\\n}\\n//Time Complexity O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686867,
                "title": "c-o-n-solution-simple-and-clean",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    string breakPalindrome(string palindrome) {\\n\\n        int n = palindrome.size();\\n        if(n == 1) return \"\";\\n        \\n        int flag = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            char ch = palindrome[i];\\n            \\n            if(ch!=\\'a\\')\\n            {\\n                if(i == n/2)break;  //case : aabaa\\n                palindrome[i] = \\'a\\';\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        \\n\\t\\t//case : aaaa \\n        if(flag == 0)\\n            palindrome[n-1] = palindrome[n-1]+1;\\n        \\n        return palindrome;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string breakPalindrome(string palindrome) {\\n\\n        int n = palindrome.size();\\n        if(n == 1) return \"\";\\n        \\n        int flag = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            char ch = palindrome[i];\\n            \\n            if(ch!=\\'a\\')\\n            {\\n                if(i == n/2)break;  //case : aabaa\\n                palindrome[i] = \\'a\\';\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        \\n\\t\\t//case : aaaa \\n        if(flag == 0)\\n            palindrome[n-1] = palindrome[n-1]+1;\\n        \\n        return palindrome;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686863,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        int n = palindrome.length();\\n        char[] arr = palindrome.toCharArray();\\n        \\n        if(n==1) return \"\";\\n            \\n        for(int i = 0 ; i<n/2 ; i++){\\n            if(arr[i] != \\'a\\'){\\n                arr[i] = \\'a\\';\\n                return String.valueOf(arr);\\n            }\\n        }\\n        \\n        arr[n-1] = (char)(arr[n-1]+1);\\n        return String.valueOf(arr);\\n    }\\n}\\n```\\n\\nTime Complexity: O(N)\\nSpace Complexity: O(N)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String breakPalindrome(String palindrome) {\\n        int n = palindrome.length();\\n        char[] arr = palindrome.toCharArray();\\n        \\n        if(n==1) return \"\";\\n            \\n        for(int i = 0 ; i<n/2 ; i++){\\n            if(arr[i] != \\'a\\'){\\n                arr[i] = \\'a\\';\\n                return String.valueOf(arr);\\n            }\\n        }\\n        \\n        arr[n-1] = (char)(arr[n-1]+1);\\n        return String.valueOf(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686852,
                "title": "c-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string str) {\\n        \\n        int len = str.size();\\n        if(len == 1){\\n            str[0] == \\'a\\';\\n            return \"\";\\n        }\\n        int c;\\n        if(len%2 == 0){\\n            c = -1;\\n        }else{\\n            c = len/2;\\n        }\\n        for(int i=0; i<len; i++){\\n            \\n            if(str[i] != \\'a\\' and i != c){\\n                str[i] = \\'a\\';\\n                return str;\\n            }\\n        }\\n        str[len-1] = \\'b\\';\\n        return str;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string str) {\\n        \\n        int len = str.size();\\n        if(len == 1){\\n            str[0] == \\'a\\';\\n            return \"\";\\n        }\\n        int c;\\n        if(len%2 == 0){\\n            c = -1;\\n        }else{\\n            c = len/2;\\n        }\\n        for(int i=0; i<len; i++){\\n            \\n            if(str[i] != \\'a\\' and i != c){\\n                str[i] = \\'a\\';\\n                return str;\\n            }\\n        }\\n        str[len-1] = \\'b\\';\\n        return str;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686831,
                "title": "easy-java-solution-100-faster",
                "content": "```\\nclass Solution {\\n    public String breakPalindrome(String s) {\\n        if(s.length()<=1) return \"\";\\n        int n = s.length(), mid = (n>>1)-(n&1);\\n        char[] arr = s.toCharArray();\\n        for(int i=0;i<=mid;i++){\\n            if(arr[i]!=\\'a\\'){\\n                arr[i] = \\'a\\';\\n                return new String(arr);\\n            }\\n        } \\n        arr[n-1] = \\'b\\';\\n        return new String(arr);\\n   }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String breakPalindrome(String s) {\\n        if(s.length()<=1) return \"\";\\n        int n = s.length(), mid = (n>>1)-(n&1);\\n        char[] arr = s.toCharArray();\\n        for(int i=0;i<=mid;i++){\\n            if(arr[i]!=\\'a\\'){\\n                arr[i] = \\'a\\';\\n                return new String(arr);\\n            }\\n        } \\n        arr[n-1] = \\'b\\';\\n        return new String(arr);\\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686828,
                "title": "c-easy-to-understand-beat-100-runtime-95-memory",
                "content": "I believe this problem is trivial and requires not much of DS&Algo knowledge. The trick here is to replace the first non- `a` you see with an `a`. If it is not the case, you can replace the last character with `b`\\n```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n        int n = palindrome.size();\\n        if (n == 1 || n == 0) return \"\";\\n        int i = 0;\\n        while (i < n / 2) {\\n            if (palindrome[i] != \\'a\\') {\\n                palindrome[i] = \\'a\\';\\n                break;\\n            }\\n            i++;\\n        }\\n        if (i == n / 2)\\n            palindrome[n - 1] = \\'b\\';\\n        return palindrome;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n        int n = palindrome.size();\\n        if (n == 1 || n == 0) return \"\";\\n        int i = 0;\\n        while (i < n / 2) {\\n            if (palindrome[i] != \\'a\\') {\\n                palindrome[i] = \\'a\\';\\n                break;\\n            }\\n            i++;\\n        }\\n        if (i == n / 2)\\n            palindrome[n - 1] = \\'b\\';\\n        return palindrome;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686800,
                "title": "c-easy-solution-daily-challenge-o-n-2",
                "content": "```\\nstring breakPalindrome(string palindrome) {\\n        int n = palindrome.size();\\n        if(n == 1)\\n            return \"\";\\n        for(int i=0; i<n/2; i++){\\n            if(palindrome[i] != \\'a\\'){\\n                palindrome[i] = \\'a\\';\\n                return palindrome;\\n            }\\n        }\\n        palindrome[n-1] = \\'b\\';\\n        return palindrome;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring breakPalindrome(string palindrome) {\\n        int n = palindrome.size();\\n        if(n == 1)\\n            return \"\";\\n        for(int i=0; i<n/2; i++){\\n            if(palindrome[i] != \\'a\\'){\\n                palindrome[i] = \\'a\\';\\n                return palindrome;\\n            }\\n        }\\n        palindrome[n-1] = \\'b\\';\\n        return palindrome;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2686776,
                "title": "break-a-palindrome-c-easy-understanding",
                "content": "class Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n        int n=palindrome.size();\\n        if(n<=1)\\n        {\\n            return \"\";\\n        }\\n        for(int i=0;i<n/2;i++)\\n        {\\n            if(palindrome[i]!=\\'a\\')\\n            {\\n                palindrome[i]=\\'a\\';\\n                return palindrome;\\n            }\\n        }\\n        palindrome[n-1]=\\'b\\';\\n        return palindrome;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string breakPalindrome(string palindrome) {\\n        int n=palindrome.size();\\n        if(n<=1)\\n        {\\n            return \"\";\\n        }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1638912,
                "content": [
                    {
                        "username": "endorsiVal",
                        "content": "This question is useless. Literally does nothing to help you become a better leetcoder"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "It\\'s a good problem which offers a nice alternative to the usual palindrome questions."
                    },
                    {
                        "username": "lavos4life",
                        "content": "i think it\\'s a good exercise in catching special cases."
                    },
                    {
                        "username": "juwikuang",
                        "content": "this is just easy, entry level probelm. not medium. "
                    },
                    {
                        "username": "Sudha_S",
                        "content": "This is quite a simple problem:\\n(1) You cannot do anything about a single length string. \\n      Return \"\".\\n(2) For the first half of the string, check if there\\'s a character  \\n     greater than \\'a\\' & replace it by \\'a\\'\\n(3) ALL the first half characters are \\'a\\'s. Hence, replace the \\n    LAST element of the string by \\'b\\'."
                    },
                    {
                        "username": "sivansh1103",
                        "content": "in my opinion, this question is not clear to understand, as in the term lexicography is not properly explained, and the acceptance criteria is not properly explained."
                    },
                    {
                        "username": "bhagya_rana",
                        "content": "Think in Terms of Below Cases!\\n\\nCASE 1 : Single Letter Strings Like \\'a\\'/\\'b\\'\\nCASE 2 : If Starting Letter of Palindromic String is Not \\'a\\'\\nCASE 3 : If Starting Letter of Palindromic String is \\'a\\'\\n- Case 3.1 : Find Next Letter that is Not Equal to \\'a\\' \\n- Case 3.2 : If All Letters in Strings are \\'a\\' Eg. \\'aaaaa\\'\\n\\nTry it Yourself Before Clicking  [here](https://leetcode.com/problems/break-a-palindrome/solutions/2683839/3-cases-approach-simple-string-traversal-c/)."
                    },
                    {
                        "username": "kudratkhujamusaev",
                        "content": "Case 2 is not necessary. Case 3.1 covers it  "
                    },
                    {
                        "username": "atharva-agrawal",
                        "content": "Thanks for the Cases!"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Well guess what, this exact question came in JPMC coding round!"
                    },
                    {
                        "username": "BOVAGE",
                        "content": "[@abrods2](/abrods2) True. "
                    },
                    {
                        "username": "abrods2",
                        "content": "[@tfeq](/tfeq) Internship, but it was slightly easier"
                    },
                    {
                        "username": "tfeq",
                        "content": "Hey! was this for new grad or internship?"
                    },
                    {
                        "username": "sc1233",
                        "content": "Can someone help me understand the logic of changing the last letter to \\'a\\'?\\n\\nWhy is\\nzzzzzzza\\nlexicographically smaller than\\nzzzzzzaz\\n\\nDon\\'t understand, because if we compare to numbers, then\\n9999990\\nis larger than\\n9999909"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "its not"
                    },
                    {
                        "username": "ap56",
                        "content": "zzzzzzza\\nis not lexigraphically smaller than \\nzzzzzzaz\\nbecause in the first position that they differ, character at index 6, the second string has value \\'a\\' while the first string has value \\'z\\' and \\'a\\'<\\'z\\'.\\n\\nthe logic of changing the last letter to \\'a\\' is to meet a specific requirement from the question: \\nGiven a palindromic string of lowercase English letters palindrome, replace exactly one character with any lowercase English letter so that the resulting string is not a palindrome and that it is the lexicographically smallest one possible.\\n\\nThe last sentence asks to return the lexicographically smallest string among potential answers. The for loop from the given solutions accomplishes this by inserting an \\'a\\' at the first opportunity. However, there is the edgecase of a string of all \\'a\\'s.\\n\\nSo if the input string was: \"aaaaaaa\"\\n\"baaaaaa\"\\nand \\n\"aaaaaab\"\\nare both potential answers, but we will choose to return the second one, where \\'b\\' is inserted at the end, because it is the lexigraphically smallest potential answer. I hope this helps, I was confused about this too and had to read the question again."
                    },
                    {
                        "username": "__aadi9754",
                        "content": "which is lexicographical smaller :- aab or abb"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "According to definition in this question \\u2013 \"aab\"."
                    },
                    {
                        "username": "VignaTejReddy",
                        "content": "lexicographical order means order in dictionary. first aab comes next abb."
                    },
                    {
                        "username": "akashsharma15105",
                        "content": "aab"
                    },
                    {
                        "username": "arkwaw",
                        "content": "aab"
                    },
                    {
                        "username": "awdhesh_kumar",
                        "content": "aab "
                    },
                    {
                        "username": "CalderWilson",
                        "content": "for the case \"aacaa\", wouldn\\'t the correct answer be \"aabaa\"? Leetcode says the answer should be \"aacab\", but isn\\'t that lexically larger?"
                    },
                    {
                        "username": "ianjulo",
                        "content": "\"aacab\" is still a palindrome. "
                    },
                    {
                        "username": "Dnevnik_dvevuchka",
                        "content": "Input: palindrome = \"abccba\"\\nOutput: \"aaccba\"\\n\\nshouldn\\'t the output be abccbb?\\n\\nplease explain."
                    },
                    {
                        "username": "Dnevnik_dvevuchka",
                        "content": "[@who_rules](/who_rules) the ascii codes also are listed sequentially.  In layman terms, a lexicographical order is the same as that in a dictionary. in this light, we would list abccbb before aaccba. \\nDo you mean that we have to keep the word such that the place value of the replaced character should be maximum while the replaced letter minimum. "
                    },
                    {
                        "username": "who_rules",
                        "content": "for example the ASCII code of \\'a\\' is 97, \\'b\\' is 98 and so on. in such case, \\'a\\' is the \"least\" char and \\'z\\' is the \"most\"\\nyou should place have least character in resulting string first"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The biggest key which helped me is that the input is a palindrome, you only have to iterate over the first half."
                    }
                ]
            },
            {
                "id": 1639295,
                "content": [
                    {
                        "username": "endorsiVal",
                        "content": "This question is useless. Literally does nothing to help you become a better leetcoder"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "It\\'s a good problem which offers a nice alternative to the usual palindrome questions."
                    },
                    {
                        "username": "lavos4life",
                        "content": "i think it\\'s a good exercise in catching special cases."
                    },
                    {
                        "username": "juwikuang",
                        "content": "this is just easy, entry level probelm. not medium. "
                    },
                    {
                        "username": "Sudha_S",
                        "content": "This is quite a simple problem:\\n(1) You cannot do anything about a single length string. \\n      Return \"\".\\n(2) For the first half of the string, check if there\\'s a character  \\n     greater than \\'a\\' & replace it by \\'a\\'\\n(3) ALL the first half characters are \\'a\\'s. Hence, replace the \\n    LAST element of the string by \\'b\\'."
                    },
                    {
                        "username": "sivansh1103",
                        "content": "in my opinion, this question is not clear to understand, as in the term lexicography is not properly explained, and the acceptance criteria is not properly explained."
                    },
                    {
                        "username": "bhagya_rana",
                        "content": "Think in Terms of Below Cases!\\n\\nCASE 1 : Single Letter Strings Like \\'a\\'/\\'b\\'\\nCASE 2 : If Starting Letter of Palindromic String is Not \\'a\\'\\nCASE 3 : If Starting Letter of Palindromic String is \\'a\\'\\n- Case 3.1 : Find Next Letter that is Not Equal to \\'a\\' \\n- Case 3.2 : If All Letters in Strings are \\'a\\' Eg. \\'aaaaa\\'\\n\\nTry it Yourself Before Clicking  [here](https://leetcode.com/problems/break-a-palindrome/solutions/2683839/3-cases-approach-simple-string-traversal-c/)."
                    },
                    {
                        "username": "kudratkhujamusaev",
                        "content": "Case 2 is not necessary. Case 3.1 covers it  "
                    },
                    {
                        "username": "atharva-agrawal",
                        "content": "Thanks for the Cases!"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Well guess what, this exact question came in JPMC coding round!"
                    },
                    {
                        "username": "BOVAGE",
                        "content": "[@abrods2](/abrods2) True. "
                    },
                    {
                        "username": "abrods2",
                        "content": "[@tfeq](/tfeq) Internship, but it was slightly easier"
                    },
                    {
                        "username": "tfeq",
                        "content": "Hey! was this for new grad or internship?"
                    },
                    {
                        "username": "sc1233",
                        "content": "Can someone help me understand the logic of changing the last letter to \\'a\\'?\\n\\nWhy is\\nzzzzzzza\\nlexicographically smaller than\\nzzzzzzaz\\n\\nDon\\'t understand, because if we compare to numbers, then\\n9999990\\nis larger than\\n9999909"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "its not"
                    },
                    {
                        "username": "ap56",
                        "content": "zzzzzzza\\nis not lexigraphically smaller than \\nzzzzzzaz\\nbecause in the first position that they differ, character at index 6, the second string has value \\'a\\' while the first string has value \\'z\\' and \\'a\\'<\\'z\\'.\\n\\nthe logic of changing the last letter to \\'a\\' is to meet a specific requirement from the question: \\nGiven a palindromic string of lowercase English letters palindrome, replace exactly one character with any lowercase English letter so that the resulting string is not a palindrome and that it is the lexicographically smallest one possible.\\n\\nThe last sentence asks to return the lexicographically smallest string among potential answers. The for loop from the given solutions accomplishes this by inserting an \\'a\\' at the first opportunity. However, there is the edgecase of a string of all \\'a\\'s.\\n\\nSo if the input string was: \"aaaaaaa\"\\n\"baaaaaa\"\\nand \\n\"aaaaaab\"\\nare both potential answers, but we will choose to return the second one, where \\'b\\' is inserted at the end, because it is the lexigraphically smallest potential answer. I hope this helps, I was confused about this too and had to read the question again."
                    },
                    {
                        "username": "__aadi9754",
                        "content": "which is lexicographical smaller :- aab or abb"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "According to definition in this question \\u2013 \"aab\"."
                    },
                    {
                        "username": "VignaTejReddy",
                        "content": "lexicographical order means order in dictionary. first aab comes next abb."
                    },
                    {
                        "username": "akashsharma15105",
                        "content": "aab"
                    },
                    {
                        "username": "arkwaw",
                        "content": "aab"
                    },
                    {
                        "username": "awdhesh_kumar",
                        "content": "aab "
                    },
                    {
                        "username": "CalderWilson",
                        "content": "for the case \"aacaa\", wouldn\\'t the correct answer be \"aabaa\"? Leetcode says the answer should be \"aacab\", but isn\\'t that lexically larger?"
                    },
                    {
                        "username": "ianjulo",
                        "content": "\"aacab\" is still a palindrome. "
                    },
                    {
                        "username": "Dnevnik_dvevuchka",
                        "content": "Input: palindrome = \"abccba\"\\nOutput: \"aaccba\"\\n\\nshouldn\\'t the output be abccbb?\\n\\nplease explain."
                    },
                    {
                        "username": "Dnevnik_dvevuchka",
                        "content": "[@who_rules](/who_rules) the ascii codes also are listed sequentially.  In layman terms, a lexicographical order is the same as that in a dictionary. in this light, we would list abccbb before aaccba. \\nDo you mean that we have to keep the word such that the place value of the replaced character should be maximum while the replaced letter minimum. "
                    },
                    {
                        "username": "who_rules",
                        "content": "for example the ASCII code of \\'a\\' is 97, \\'b\\' is 98 and so on. in such case, \\'a\\' is the \"least\" char and \\'z\\' is the \"most\"\\nyou should place have least character in resulting string first"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The biggest key which helped me is that the input is a palindrome, you only have to iterate over the first half."
                    }
                ]
            },
            {
                "id": 1641327,
                "content": [
                    {
                        "username": "endorsiVal",
                        "content": "This question is useless. Literally does nothing to help you become a better leetcoder"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "It\\'s a good problem which offers a nice alternative to the usual palindrome questions."
                    },
                    {
                        "username": "lavos4life",
                        "content": "i think it\\'s a good exercise in catching special cases."
                    },
                    {
                        "username": "juwikuang",
                        "content": "this is just easy, entry level probelm. not medium. "
                    },
                    {
                        "username": "Sudha_S",
                        "content": "This is quite a simple problem:\\n(1) You cannot do anything about a single length string. \\n      Return \"\".\\n(2) For the first half of the string, check if there\\'s a character  \\n     greater than \\'a\\' & replace it by \\'a\\'\\n(3) ALL the first half characters are \\'a\\'s. Hence, replace the \\n    LAST element of the string by \\'b\\'."
                    },
                    {
                        "username": "sivansh1103",
                        "content": "in my opinion, this question is not clear to understand, as in the term lexicography is not properly explained, and the acceptance criteria is not properly explained."
                    },
                    {
                        "username": "bhagya_rana",
                        "content": "Think in Terms of Below Cases!\\n\\nCASE 1 : Single Letter Strings Like \\'a\\'/\\'b\\'\\nCASE 2 : If Starting Letter of Palindromic String is Not \\'a\\'\\nCASE 3 : If Starting Letter of Palindromic String is \\'a\\'\\n- Case 3.1 : Find Next Letter that is Not Equal to \\'a\\' \\n- Case 3.2 : If All Letters in Strings are \\'a\\' Eg. \\'aaaaa\\'\\n\\nTry it Yourself Before Clicking  [here](https://leetcode.com/problems/break-a-palindrome/solutions/2683839/3-cases-approach-simple-string-traversal-c/)."
                    },
                    {
                        "username": "kudratkhujamusaev",
                        "content": "Case 2 is not necessary. Case 3.1 covers it  "
                    },
                    {
                        "username": "atharva-agrawal",
                        "content": "Thanks for the Cases!"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Well guess what, this exact question came in JPMC coding round!"
                    },
                    {
                        "username": "BOVAGE",
                        "content": "[@abrods2](/abrods2) True. "
                    },
                    {
                        "username": "abrods2",
                        "content": "[@tfeq](/tfeq) Internship, but it was slightly easier"
                    },
                    {
                        "username": "tfeq",
                        "content": "Hey! was this for new grad or internship?"
                    },
                    {
                        "username": "sc1233",
                        "content": "Can someone help me understand the logic of changing the last letter to \\'a\\'?\\n\\nWhy is\\nzzzzzzza\\nlexicographically smaller than\\nzzzzzzaz\\n\\nDon\\'t understand, because if we compare to numbers, then\\n9999990\\nis larger than\\n9999909"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "its not"
                    },
                    {
                        "username": "ap56",
                        "content": "zzzzzzza\\nis not lexigraphically smaller than \\nzzzzzzaz\\nbecause in the first position that they differ, character at index 6, the second string has value \\'a\\' while the first string has value \\'z\\' and \\'a\\'<\\'z\\'.\\n\\nthe logic of changing the last letter to \\'a\\' is to meet a specific requirement from the question: \\nGiven a palindromic string of lowercase English letters palindrome, replace exactly one character with any lowercase English letter so that the resulting string is not a palindrome and that it is the lexicographically smallest one possible.\\n\\nThe last sentence asks to return the lexicographically smallest string among potential answers. The for loop from the given solutions accomplishes this by inserting an \\'a\\' at the first opportunity. However, there is the edgecase of a string of all \\'a\\'s.\\n\\nSo if the input string was: \"aaaaaaa\"\\n\"baaaaaa\"\\nand \\n\"aaaaaab\"\\nare both potential answers, but we will choose to return the second one, where \\'b\\' is inserted at the end, because it is the lexigraphically smallest potential answer. I hope this helps, I was confused about this too and had to read the question again."
                    },
                    {
                        "username": "__aadi9754",
                        "content": "which is lexicographical smaller :- aab or abb"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "According to definition in this question \\u2013 \"aab\"."
                    },
                    {
                        "username": "VignaTejReddy",
                        "content": "lexicographical order means order in dictionary. first aab comes next abb."
                    },
                    {
                        "username": "akashsharma15105",
                        "content": "aab"
                    },
                    {
                        "username": "arkwaw",
                        "content": "aab"
                    },
                    {
                        "username": "awdhesh_kumar",
                        "content": "aab "
                    },
                    {
                        "username": "CalderWilson",
                        "content": "for the case \"aacaa\", wouldn\\'t the correct answer be \"aabaa\"? Leetcode says the answer should be \"aacab\", but isn\\'t that lexically larger?"
                    },
                    {
                        "username": "ianjulo",
                        "content": "\"aacab\" is still a palindrome. "
                    },
                    {
                        "username": "Dnevnik_dvevuchka",
                        "content": "Input: palindrome = \"abccba\"\\nOutput: \"aaccba\"\\n\\nshouldn\\'t the output be abccbb?\\n\\nplease explain."
                    },
                    {
                        "username": "Dnevnik_dvevuchka",
                        "content": "[@who_rules](/who_rules) the ascii codes also are listed sequentially.  In layman terms, a lexicographical order is the same as that in a dictionary. in this light, we would list abccbb before aaccba. \\nDo you mean that we have to keep the word such that the place value of the replaced character should be maximum while the replaced letter minimum. "
                    },
                    {
                        "username": "who_rules",
                        "content": "for example the ASCII code of \\'a\\' is 97, \\'b\\' is 98 and so on. in such case, \\'a\\' is the \"least\" char and \\'z\\' is the \"most\"\\nyou should place have least character in resulting string first"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The biggest key which helped me is that the input is a palindrome, you only have to iterate over the first half."
                    }
                ]
            },
            {
                "id": 1639002,
                "content": [
                    {
                        "username": "endorsiVal",
                        "content": "This question is useless. Literally does nothing to help you become a better leetcoder"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "It\\'s a good problem which offers a nice alternative to the usual palindrome questions."
                    },
                    {
                        "username": "lavos4life",
                        "content": "i think it\\'s a good exercise in catching special cases."
                    },
                    {
                        "username": "juwikuang",
                        "content": "this is just easy, entry level probelm. not medium. "
                    },
                    {
                        "username": "Sudha_S",
                        "content": "This is quite a simple problem:\\n(1) You cannot do anything about a single length string. \\n      Return \"\".\\n(2) For the first half of the string, check if there\\'s a character  \\n     greater than \\'a\\' & replace it by \\'a\\'\\n(3) ALL the first half characters are \\'a\\'s. Hence, replace the \\n    LAST element of the string by \\'b\\'."
                    },
                    {
                        "username": "sivansh1103",
                        "content": "in my opinion, this question is not clear to understand, as in the term lexicography is not properly explained, and the acceptance criteria is not properly explained."
                    },
                    {
                        "username": "bhagya_rana",
                        "content": "Think in Terms of Below Cases!\\n\\nCASE 1 : Single Letter Strings Like \\'a\\'/\\'b\\'\\nCASE 2 : If Starting Letter of Palindromic String is Not \\'a\\'\\nCASE 3 : If Starting Letter of Palindromic String is \\'a\\'\\n- Case 3.1 : Find Next Letter that is Not Equal to \\'a\\' \\n- Case 3.2 : If All Letters in Strings are \\'a\\' Eg. \\'aaaaa\\'\\n\\nTry it Yourself Before Clicking  [here](https://leetcode.com/problems/break-a-palindrome/solutions/2683839/3-cases-approach-simple-string-traversal-c/)."
                    },
                    {
                        "username": "kudratkhujamusaev",
                        "content": "Case 2 is not necessary. Case 3.1 covers it  "
                    },
                    {
                        "username": "atharva-agrawal",
                        "content": "Thanks for the Cases!"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Well guess what, this exact question came in JPMC coding round!"
                    },
                    {
                        "username": "BOVAGE",
                        "content": "[@abrods2](/abrods2) True. "
                    },
                    {
                        "username": "abrods2",
                        "content": "[@tfeq](/tfeq) Internship, but it was slightly easier"
                    },
                    {
                        "username": "tfeq",
                        "content": "Hey! was this for new grad or internship?"
                    },
                    {
                        "username": "sc1233",
                        "content": "Can someone help me understand the logic of changing the last letter to \\'a\\'?\\n\\nWhy is\\nzzzzzzza\\nlexicographically smaller than\\nzzzzzzaz\\n\\nDon\\'t understand, because if we compare to numbers, then\\n9999990\\nis larger than\\n9999909"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "its not"
                    },
                    {
                        "username": "ap56",
                        "content": "zzzzzzza\\nis not lexigraphically smaller than \\nzzzzzzaz\\nbecause in the first position that they differ, character at index 6, the second string has value \\'a\\' while the first string has value \\'z\\' and \\'a\\'<\\'z\\'.\\n\\nthe logic of changing the last letter to \\'a\\' is to meet a specific requirement from the question: \\nGiven a palindromic string of lowercase English letters palindrome, replace exactly one character with any lowercase English letter so that the resulting string is not a palindrome and that it is the lexicographically smallest one possible.\\n\\nThe last sentence asks to return the lexicographically smallest string among potential answers. The for loop from the given solutions accomplishes this by inserting an \\'a\\' at the first opportunity. However, there is the edgecase of a string of all \\'a\\'s.\\n\\nSo if the input string was: \"aaaaaaa\"\\n\"baaaaaa\"\\nand \\n\"aaaaaab\"\\nare both potential answers, but we will choose to return the second one, where \\'b\\' is inserted at the end, because it is the lexigraphically smallest potential answer. I hope this helps, I was confused about this too and had to read the question again."
                    },
                    {
                        "username": "__aadi9754",
                        "content": "which is lexicographical smaller :- aab or abb"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "According to definition in this question \\u2013 \"aab\"."
                    },
                    {
                        "username": "VignaTejReddy",
                        "content": "lexicographical order means order in dictionary. first aab comes next abb."
                    },
                    {
                        "username": "akashsharma15105",
                        "content": "aab"
                    },
                    {
                        "username": "arkwaw",
                        "content": "aab"
                    },
                    {
                        "username": "awdhesh_kumar",
                        "content": "aab "
                    },
                    {
                        "username": "CalderWilson",
                        "content": "for the case \"aacaa\", wouldn\\'t the correct answer be \"aabaa\"? Leetcode says the answer should be \"aacab\", but isn\\'t that lexically larger?"
                    },
                    {
                        "username": "ianjulo",
                        "content": "\"aacab\" is still a palindrome. "
                    },
                    {
                        "username": "Dnevnik_dvevuchka",
                        "content": "Input: palindrome = \"abccba\"\\nOutput: \"aaccba\"\\n\\nshouldn\\'t the output be abccbb?\\n\\nplease explain."
                    },
                    {
                        "username": "Dnevnik_dvevuchka",
                        "content": "[@who_rules](/who_rules) the ascii codes also are listed sequentially.  In layman terms, a lexicographical order is the same as that in a dictionary. in this light, we would list abccbb before aaccba. \\nDo you mean that we have to keep the word such that the place value of the replaced character should be maximum while the replaced letter minimum. "
                    },
                    {
                        "username": "who_rules",
                        "content": "for example the ASCII code of \\'a\\' is 97, \\'b\\' is 98 and so on. in such case, \\'a\\' is the \"least\" char and \\'z\\' is the \"most\"\\nyou should place have least character in resulting string first"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The biggest key which helped me is that the input is a palindrome, you only have to iterate over the first half."
                    }
                ]
            },
            {
                "id": 1857373,
                "content": [
                    {
                        "username": "endorsiVal",
                        "content": "This question is useless. Literally does nothing to help you become a better leetcoder"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "It\\'s a good problem which offers a nice alternative to the usual palindrome questions."
                    },
                    {
                        "username": "lavos4life",
                        "content": "i think it\\'s a good exercise in catching special cases."
                    },
                    {
                        "username": "juwikuang",
                        "content": "this is just easy, entry level probelm. not medium. "
                    },
                    {
                        "username": "Sudha_S",
                        "content": "This is quite a simple problem:\\n(1) You cannot do anything about a single length string. \\n      Return \"\".\\n(2) For the first half of the string, check if there\\'s a character  \\n     greater than \\'a\\' & replace it by \\'a\\'\\n(3) ALL the first half characters are \\'a\\'s. Hence, replace the \\n    LAST element of the string by \\'b\\'."
                    },
                    {
                        "username": "sivansh1103",
                        "content": "in my opinion, this question is not clear to understand, as in the term lexicography is not properly explained, and the acceptance criteria is not properly explained."
                    },
                    {
                        "username": "bhagya_rana",
                        "content": "Think in Terms of Below Cases!\\n\\nCASE 1 : Single Letter Strings Like \\'a\\'/\\'b\\'\\nCASE 2 : If Starting Letter of Palindromic String is Not \\'a\\'\\nCASE 3 : If Starting Letter of Palindromic String is \\'a\\'\\n- Case 3.1 : Find Next Letter that is Not Equal to \\'a\\' \\n- Case 3.2 : If All Letters in Strings are \\'a\\' Eg. \\'aaaaa\\'\\n\\nTry it Yourself Before Clicking  [here](https://leetcode.com/problems/break-a-palindrome/solutions/2683839/3-cases-approach-simple-string-traversal-c/)."
                    },
                    {
                        "username": "kudratkhujamusaev",
                        "content": "Case 2 is not necessary. Case 3.1 covers it  "
                    },
                    {
                        "username": "atharva-agrawal",
                        "content": "Thanks for the Cases!"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Well guess what, this exact question came in JPMC coding round!"
                    },
                    {
                        "username": "BOVAGE",
                        "content": "[@abrods2](/abrods2) True. "
                    },
                    {
                        "username": "abrods2",
                        "content": "[@tfeq](/tfeq) Internship, but it was slightly easier"
                    },
                    {
                        "username": "tfeq",
                        "content": "Hey! was this for new grad or internship?"
                    },
                    {
                        "username": "sc1233",
                        "content": "Can someone help me understand the logic of changing the last letter to \\'a\\'?\\n\\nWhy is\\nzzzzzzza\\nlexicographically smaller than\\nzzzzzzaz\\n\\nDon\\'t understand, because if we compare to numbers, then\\n9999990\\nis larger than\\n9999909"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "its not"
                    },
                    {
                        "username": "ap56",
                        "content": "zzzzzzza\\nis not lexigraphically smaller than \\nzzzzzzaz\\nbecause in the first position that they differ, character at index 6, the second string has value \\'a\\' while the first string has value \\'z\\' and \\'a\\'<\\'z\\'.\\n\\nthe logic of changing the last letter to \\'a\\' is to meet a specific requirement from the question: \\nGiven a palindromic string of lowercase English letters palindrome, replace exactly one character with any lowercase English letter so that the resulting string is not a palindrome and that it is the lexicographically smallest one possible.\\n\\nThe last sentence asks to return the lexicographically smallest string among potential answers. The for loop from the given solutions accomplishes this by inserting an \\'a\\' at the first opportunity. However, there is the edgecase of a string of all \\'a\\'s.\\n\\nSo if the input string was: \"aaaaaaa\"\\n\"baaaaaa\"\\nand \\n\"aaaaaab\"\\nare both potential answers, but we will choose to return the second one, where \\'b\\' is inserted at the end, because it is the lexigraphically smallest potential answer. I hope this helps, I was confused about this too and had to read the question again."
                    },
                    {
                        "username": "__aadi9754",
                        "content": "which is lexicographical smaller :- aab or abb"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "According to definition in this question \\u2013 \"aab\"."
                    },
                    {
                        "username": "VignaTejReddy",
                        "content": "lexicographical order means order in dictionary. first aab comes next abb."
                    },
                    {
                        "username": "akashsharma15105",
                        "content": "aab"
                    },
                    {
                        "username": "arkwaw",
                        "content": "aab"
                    },
                    {
                        "username": "awdhesh_kumar",
                        "content": "aab "
                    },
                    {
                        "username": "CalderWilson",
                        "content": "for the case \"aacaa\", wouldn\\'t the correct answer be \"aabaa\"? Leetcode says the answer should be \"aacab\", but isn\\'t that lexically larger?"
                    },
                    {
                        "username": "ianjulo",
                        "content": "\"aacab\" is still a palindrome. "
                    },
                    {
                        "username": "Dnevnik_dvevuchka",
                        "content": "Input: palindrome = \"abccba\"\\nOutput: \"aaccba\"\\n\\nshouldn\\'t the output be abccbb?\\n\\nplease explain."
                    },
                    {
                        "username": "Dnevnik_dvevuchka",
                        "content": "[@who_rules](/who_rules) the ascii codes also are listed sequentially.  In layman terms, a lexicographical order is the same as that in a dictionary. in this light, we would list abccbb before aaccba. \\nDo you mean that we have to keep the word such that the place value of the replaced character should be maximum while the replaced letter minimum. "
                    },
                    {
                        "username": "who_rules",
                        "content": "for example the ASCII code of \\'a\\' is 97, \\'b\\' is 98 and so on. in such case, \\'a\\' is the \"least\" char and \\'z\\' is the \"most\"\\nyou should place have least character in resulting string first"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The biggest key which helped me is that the input is a palindrome, you only have to iterate over the first half."
                    }
                ]
            },
            {
                "id": 1645018,
                "content": [
                    {
                        "username": "endorsiVal",
                        "content": "This question is useless. Literally does nothing to help you become a better leetcoder"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "It\\'s a good problem which offers a nice alternative to the usual palindrome questions."
                    },
                    {
                        "username": "lavos4life",
                        "content": "i think it\\'s a good exercise in catching special cases."
                    },
                    {
                        "username": "juwikuang",
                        "content": "this is just easy, entry level probelm. not medium. "
                    },
                    {
                        "username": "Sudha_S",
                        "content": "This is quite a simple problem:\\n(1) You cannot do anything about a single length string. \\n      Return \"\".\\n(2) For the first half of the string, check if there\\'s a character  \\n     greater than \\'a\\' & replace it by \\'a\\'\\n(3) ALL the first half characters are \\'a\\'s. Hence, replace the \\n    LAST element of the string by \\'b\\'."
                    },
                    {
                        "username": "sivansh1103",
                        "content": "in my opinion, this question is not clear to understand, as in the term lexicography is not properly explained, and the acceptance criteria is not properly explained."
                    },
                    {
                        "username": "bhagya_rana",
                        "content": "Think in Terms of Below Cases!\\n\\nCASE 1 : Single Letter Strings Like \\'a\\'/\\'b\\'\\nCASE 2 : If Starting Letter of Palindromic String is Not \\'a\\'\\nCASE 3 : If Starting Letter of Palindromic String is \\'a\\'\\n- Case 3.1 : Find Next Letter that is Not Equal to \\'a\\' \\n- Case 3.2 : If All Letters in Strings are \\'a\\' Eg. \\'aaaaa\\'\\n\\nTry it Yourself Before Clicking  [here](https://leetcode.com/problems/break-a-palindrome/solutions/2683839/3-cases-approach-simple-string-traversal-c/)."
                    },
                    {
                        "username": "kudratkhujamusaev",
                        "content": "Case 2 is not necessary. Case 3.1 covers it  "
                    },
                    {
                        "username": "atharva-agrawal",
                        "content": "Thanks for the Cases!"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Well guess what, this exact question came in JPMC coding round!"
                    },
                    {
                        "username": "BOVAGE",
                        "content": "[@abrods2](/abrods2) True. "
                    },
                    {
                        "username": "abrods2",
                        "content": "[@tfeq](/tfeq) Internship, but it was slightly easier"
                    },
                    {
                        "username": "tfeq",
                        "content": "Hey! was this for new grad or internship?"
                    },
                    {
                        "username": "sc1233",
                        "content": "Can someone help me understand the logic of changing the last letter to \\'a\\'?\\n\\nWhy is\\nzzzzzzza\\nlexicographically smaller than\\nzzzzzzaz\\n\\nDon\\'t understand, because if we compare to numbers, then\\n9999990\\nis larger than\\n9999909"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "its not"
                    },
                    {
                        "username": "ap56",
                        "content": "zzzzzzza\\nis not lexigraphically smaller than \\nzzzzzzaz\\nbecause in the first position that they differ, character at index 6, the second string has value \\'a\\' while the first string has value \\'z\\' and \\'a\\'<\\'z\\'.\\n\\nthe logic of changing the last letter to \\'a\\' is to meet a specific requirement from the question: \\nGiven a palindromic string of lowercase English letters palindrome, replace exactly one character with any lowercase English letter so that the resulting string is not a palindrome and that it is the lexicographically smallest one possible.\\n\\nThe last sentence asks to return the lexicographically smallest string among potential answers. The for loop from the given solutions accomplishes this by inserting an \\'a\\' at the first opportunity. However, there is the edgecase of a string of all \\'a\\'s.\\n\\nSo if the input string was: \"aaaaaaa\"\\n\"baaaaaa\"\\nand \\n\"aaaaaab\"\\nare both potential answers, but we will choose to return the second one, where \\'b\\' is inserted at the end, because it is the lexigraphically smallest potential answer. I hope this helps, I was confused about this too and had to read the question again."
                    },
                    {
                        "username": "__aadi9754",
                        "content": "which is lexicographical smaller :- aab or abb"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "According to definition in this question \\u2013 \"aab\"."
                    },
                    {
                        "username": "VignaTejReddy",
                        "content": "lexicographical order means order in dictionary. first aab comes next abb."
                    },
                    {
                        "username": "akashsharma15105",
                        "content": "aab"
                    },
                    {
                        "username": "arkwaw",
                        "content": "aab"
                    },
                    {
                        "username": "awdhesh_kumar",
                        "content": "aab "
                    },
                    {
                        "username": "CalderWilson",
                        "content": "for the case \"aacaa\", wouldn\\'t the correct answer be \"aabaa\"? Leetcode says the answer should be \"aacab\", but isn\\'t that lexically larger?"
                    },
                    {
                        "username": "ianjulo",
                        "content": "\"aacab\" is still a palindrome. "
                    },
                    {
                        "username": "Dnevnik_dvevuchka",
                        "content": "Input: palindrome = \"abccba\"\\nOutput: \"aaccba\"\\n\\nshouldn\\'t the output be abccbb?\\n\\nplease explain."
                    },
                    {
                        "username": "Dnevnik_dvevuchka",
                        "content": "[@who_rules](/who_rules) the ascii codes also are listed sequentially.  In layman terms, a lexicographical order is the same as that in a dictionary. in this light, we would list abccbb before aaccba. \\nDo you mean that we have to keep the word such that the place value of the replaced character should be maximum while the replaced letter minimum. "
                    },
                    {
                        "username": "who_rules",
                        "content": "for example the ASCII code of \\'a\\' is 97, \\'b\\' is 98 and so on. in such case, \\'a\\' is the \"least\" char and \\'z\\' is the \"most\"\\nyou should place have least character in resulting string first"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The biggest key which helped me is that the input is a palindrome, you only have to iterate over the first half."
                    }
                ]
            },
            {
                "id": 1639236,
                "content": [
                    {
                        "username": "endorsiVal",
                        "content": "This question is useless. Literally does nothing to help you become a better leetcoder"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "It\\'s a good problem which offers a nice alternative to the usual palindrome questions."
                    },
                    {
                        "username": "lavos4life",
                        "content": "i think it\\'s a good exercise in catching special cases."
                    },
                    {
                        "username": "juwikuang",
                        "content": "this is just easy, entry level probelm. not medium. "
                    },
                    {
                        "username": "Sudha_S",
                        "content": "This is quite a simple problem:\\n(1) You cannot do anything about a single length string. \\n      Return \"\".\\n(2) For the first half of the string, check if there\\'s a character  \\n     greater than \\'a\\' & replace it by \\'a\\'\\n(3) ALL the first half characters are \\'a\\'s. Hence, replace the \\n    LAST element of the string by \\'b\\'."
                    },
                    {
                        "username": "sivansh1103",
                        "content": "in my opinion, this question is not clear to understand, as in the term lexicography is not properly explained, and the acceptance criteria is not properly explained."
                    },
                    {
                        "username": "bhagya_rana",
                        "content": "Think in Terms of Below Cases!\\n\\nCASE 1 : Single Letter Strings Like \\'a\\'/\\'b\\'\\nCASE 2 : If Starting Letter of Palindromic String is Not \\'a\\'\\nCASE 3 : If Starting Letter of Palindromic String is \\'a\\'\\n- Case 3.1 : Find Next Letter that is Not Equal to \\'a\\' \\n- Case 3.2 : If All Letters in Strings are \\'a\\' Eg. \\'aaaaa\\'\\n\\nTry it Yourself Before Clicking  [here](https://leetcode.com/problems/break-a-palindrome/solutions/2683839/3-cases-approach-simple-string-traversal-c/)."
                    },
                    {
                        "username": "kudratkhujamusaev",
                        "content": "Case 2 is not necessary. Case 3.1 covers it  "
                    },
                    {
                        "username": "atharva-agrawal",
                        "content": "Thanks for the Cases!"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Well guess what, this exact question came in JPMC coding round!"
                    },
                    {
                        "username": "BOVAGE",
                        "content": "[@abrods2](/abrods2) True. "
                    },
                    {
                        "username": "abrods2",
                        "content": "[@tfeq](/tfeq) Internship, but it was slightly easier"
                    },
                    {
                        "username": "tfeq",
                        "content": "Hey! was this for new grad or internship?"
                    },
                    {
                        "username": "sc1233",
                        "content": "Can someone help me understand the logic of changing the last letter to \\'a\\'?\\n\\nWhy is\\nzzzzzzza\\nlexicographically smaller than\\nzzzzzzaz\\n\\nDon\\'t understand, because if we compare to numbers, then\\n9999990\\nis larger than\\n9999909"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "its not"
                    },
                    {
                        "username": "ap56",
                        "content": "zzzzzzza\\nis not lexigraphically smaller than \\nzzzzzzaz\\nbecause in the first position that they differ, character at index 6, the second string has value \\'a\\' while the first string has value \\'z\\' and \\'a\\'<\\'z\\'.\\n\\nthe logic of changing the last letter to \\'a\\' is to meet a specific requirement from the question: \\nGiven a palindromic string of lowercase English letters palindrome, replace exactly one character with any lowercase English letter so that the resulting string is not a palindrome and that it is the lexicographically smallest one possible.\\n\\nThe last sentence asks to return the lexicographically smallest string among potential answers. The for loop from the given solutions accomplishes this by inserting an \\'a\\' at the first opportunity. However, there is the edgecase of a string of all \\'a\\'s.\\n\\nSo if the input string was: \"aaaaaaa\"\\n\"baaaaaa\"\\nand \\n\"aaaaaab\"\\nare both potential answers, but we will choose to return the second one, where \\'b\\' is inserted at the end, because it is the lexigraphically smallest potential answer. I hope this helps, I was confused about this too and had to read the question again."
                    },
                    {
                        "username": "__aadi9754",
                        "content": "which is lexicographical smaller :- aab or abb"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "According to definition in this question \\u2013 \"aab\"."
                    },
                    {
                        "username": "VignaTejReddy",
                        "content": "lexicographical order means order in dictionary. first aab comes next abb."
                    },
                    {
                        "username": "akashsharma15105",
                        "content": "aab"
                    },
                    {
                        "username": "arkwaw",
                        "content": "aab"
                    },
                    {
                        "username": "awdhesh_kumar",
                        "content": "aab "
                    },
                    {
                        "username": "CalderWilson",
                        "content": "for the case \"aacaa\", wouldn\\'t the correct answer be \"aabaa\"? Leetcode says the answer should be \"aacab\", but isn\\'t that lexically larger?"
                    },
                    {
                        "username": "ianjulo",
                        "content": "\"aacab\" is still a palindrome. "
                    },
                    {
                        "username": "Dnevnik_dvevuchka",
                        "content": "Input: palindrome = \"abccba\"\\nOutput: \"aaccba\"\\n\\nshouldn\\'t the output be abccbb?\\n\\nplease explain."
                    },
                    {
                        "username": "Dnevnik_dvevuchka",
                        "content": "[@who_rules](/who_rules) the ascii codes also are listed sequentially.  In layman terms, a lexicographical order is the same as that in a dictionary. in this light, we would list abccbb before aaccba. \\nDo you mean that we have to keep the word such that the place value of the replaced character should be maximum while the replaced letter minimum. "
                    },
                    {
                        "username": "who_rules",
                        "content": "for example the ASCII code of \\'a\\' is 97, \\'b\\' is 98 and so on. in such case, \\'a\\' is the \"least\" char and \\'z\\' is the \"most\"\\nyou should place have least character in resulting string first"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The biggest key which helped me is that the input is a palindrome, you only have to iterate over the first half."
                    }
                ]
            },
            {
                "id": 2029084,
                "content": [
                    {
                        "username": "endorsiVal",
                        "content": "This question is useless. Literally does nothing to help you become a better leetcoder"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "It\\'s a good problem which offers a nice alternative to the usual palindrome questions."
                    },
                    {
                        "username": "lavos4life",
                        "content": "i think it\\'s a good exercise in catching special cases."
                    },
                    {
                        "username": "juwikuang",
                        "content": "this is just easy, entry level probelm. not medium. "
                    },
                    {
                        "username": "Sudha_S",
                        "content": "This is quite a simple problem:\\n(1) You cannot do anything about a single length string. \\n      Return \"\".\\n(2) For the first half of the string, check if there\\'s a character  \\n     greater than \\'a\\' & replace it by \\'a\\'\\n(3) ALL the first half characters are \\'a\\'s. Hence, replace the \\n    LAST element of the string by \\'b\\'."
                    },
                    {
                        "username": "sivansh1103",
                        "content": "in my opinion, this question is not clear to understand, as in the term lexicography is not properly explained, and the acceptance criteria is not properly explained."
                    },
                    {
                        "username": "bhagya_rana",
                        "content": "Think in Terms of Below Cases!\\n\\nCASE 1 : Single Letter Strings Like \\'a\\'/\\'b\\'\\nCASE 2 : If Starting Letter of Palindromic String is Not \\'a\\'\\nCASE 3 : If Starting Letter of Palindromic String is \\'a\\'\\n- Case 3.1 : Find Next Letter that is Not Equal to \\'a\\' \\n- Case 3.2 : If All Letters in Strings are \\'a\\' Eg. \\'aaaaa\\'\\n\\nTry it Yourself Before Clicking  [here](https://leetcode.com/problems/break-a-palindrome/solutions/2683839/3-cases-approach-simple-string-traversal-c/)."
                    },
                    {
                        "username": "kudratkhujamusaev",
                        "content": "Case 2 is not necessary. Case 3.1 covers it  "
                    },
                    {
                        "username": "atharva-agrawal",
                        "content": "Thanks for the Cases!"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Well guess what, this exact question came in JPMC coding round!"
                    },
                    {
                        "username": "BOVAGE",
                        "content": "[@abrods2](/abrods2) True. "
                    },
                    {
                        "username": "abrods2",
                        "content": "[@tfeq](/tfeq) Internship, but it was slightly easier"
                    },
                    {
                        "username": "tfeq",
                        "content": "Hey! was this for new grad or internship?"
                    },
                    {
                        "username": "sc1233",
                        "content": "Can someone help me understand the logic of changing the last letter to \\'a\\'?\\n\\nWhy is\\nzzzzzzza\\nlexicographically smaller than\\nzzzzzzaz\\n\\nDon\\'t understand, because if we compare to numbers, then\\n9999990\\nis larger than\\n9999909"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "its not"
                    },
                    {
                        "username": "ap56",
                        "content": "zzzzzzza\\nis not lexigraphically smaller than \\nzzzzzzaz\\nbecause in the first position that they differ, character at index 6, the second string has value \\'a\\' while the first string has value \\'z\\' and \\'a\\'<\\'z\\'.\\n\\nthe logic of changing the last letter to \\'a\\' is to meet a specific requirement from the question: \\nGiven a palindromic string of lowercase English letters palindrome, replace exactly one character with any lowercase English letter so that the resulting string is not a palindrome and that it is the lexicographically smallest one possible.\\n\\nThe last sentence asks to return the lexicographically smallest string among potential answers. The for loop from the given solutions accomplishes this by inserting an \\'a\\' at the first opportunity. However, there is the edgecase of a string of all \\'a\\'s.\\n\\nSo if the input string was: \"aaaaaaa\"\\n\"baaaaaa\"\\nand \\n\"aaaaaab\"\\nare both potential answers, but we will choose to return the second one, where \\'b\\' is inserted at the end, because it is the lexigraphically smallest potential answer. I hope this helps, I was confused about this too and had to read the question again."
                    },
                    {
                        "username": "__aadi9754",
                        "content": "which is lexicographical smaller :- aab or abb"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "According to definition in this question \\u2013 \"aab\"."
                    },
                    {
                        "username": "VignaTejReddy",
                        "content": "lexicographical order means order in dictionary. first aab comes next abb."
                    },
                    {
                        "username": "akashsharma15105",
                        "content": "aab"
                    },
                    {
                        "username": "arkwaw",
                        "content": "aab"
                    },
                    {
                        "username": "awdhesh_kumar",
                        "content": "aab "
                    },
                    {
                        "username": "CalderWilson",
                        "content": "for the case \"aacaa\", wouldn\\'t the correct answer be \"aabaa\"? Leetcode says the answer should be \"aacab\", but isn\\'t that lexically larger?"
                    },
                    {
                        "username": "ianjulo",
                        "content": "\"aacab\" is still a palindrome. "
                    },
                    {
                        "username": "Dnevnik_dvevuchka",
                        "content": "Input: palindrome = \"abccba\"\\nOutput: \"aaccba\"\\n\\nshouldn\\'t the output be abccbb?\\n\\nplease explain."
                    },
                    {
                        "username": "Dnevnik_dvevuchka",
                        "content": "[@who_rules](/who_rules) the ascii codes also are listed sequentially.  In layman terms, a lexicographical order is the same as that in a dictionary. in this light, we would list abccbb before aaccba. \\nDo you mean that we have to keep the word such that the place value of the replaced character should be maximum while the replaced letter minimum. "
                    },
                    {
                        "username": "who_rules",
                        "content": "for example the ASCII code of \\'a\\' is 97, \\'b\\' is 98 and so on. in such case, \\'a\\' is the \"least\" char and \\'z\\' is the \"most\"\\nyou should place have least character in resulting string first"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The biggest key which helped me is that the input is a palindrome, you only have to iterate over the first half."
                    }
                ]
            },
            {
                "id": 2015231,
                "content": [
                    {
                        "username": "endorsiVal",
                        "content": "This question is useless. Literally does nothing to help you become a better leetcoder"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "It\\'s a good problem which offers a nice alternative to the usual palindrome questions."
                    },
                    {
                        "username": "lavos4life",
                        "content": "i think it\\'s a good exercise in catching special cases."
                    },
                    {
                        "username": "juwikuang",
                        "content": "this is just easy, entry level probelm. not medium. "
                    },
                    {
                        "username": "Sudha_S",
                        "content": "This is quite a simple problem:\\n(1) You cannot do anything about a single length string. \\n      Return \"\".\\n(2) For the first half of the string, check if there\\'s a character  \\n     greater than \\'a\\' & replace it by \\'a\\'\\n(3) ALL the first half characters are \\'a\\'s. Hence, replace the \\n    LAST element of the string by \\'b\\'."
                    },
                    {
                        "username": "sivansh1103",
                        "content": "in my opinion, this question is not clear to understand, as in the term lexicography is not properly explained, and the acceptance criteria is not properly explained."
                    },
                    {
                        "username": "bhagya_rana",
                        "content": "Think in Terms of Below Cases!\\n\\nCASE 1 : Single Letter Strings Like \\'a\\'/\\'b\\'\\nCASE 2 : If Starting Letter of Palindromic String is Not \\'a\\'\\nCASE 3 : If Starting Letter of Palindromic String is \\'a\\'\\n- Case 3.1 : Find Next Letter that is Not Equal to \\'a\\' \\n- Case 3.2 : If All Letters in Strings are \\'a\\' Eg. \\'aaaaa\\'\\n\\nTry it Yourself Before Clicking  [here](https://leetcode.com/problems/break-a-palindrome/solutions/2683839/3-cases-approach-simple-string-traversal-c/)."
                    },
                    {
                        "username": "kudratkhujamusaev",
                        "content": "Case 2 is not necessary. Case 3.1 covers it  "
                    },
                    {
                        "username": "atharva-agrawal",
                        "content": "Thanks for the Cases!"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Well guess what, this exact question came in JPMC coding round!"
                    },
                    {
                        "username": "BOVAGE",
                        "content": "[@abrods2](/abrods2) True. "
                    },
                    {
                        "username": "abrods2",
                        "content": "[@tfeq](/tfeq) Internship, but it was slightly easier"
                    },
                    {
                        "username": "tfeq",
                        "content": "Hey! was this for new grad or internship?"
                    },
                    {
                        "username": "sc1233",
                        "content": "Can someone help me understand the logic of changing the last letter to \\'a\\'?\\n\\nWhy is\\nzzzzzzza\\nlexicographically smaller than\\nzzzzzzaz\\n\\nDon\\'t understand, because if we compare to numbers, then\\n9999990\\nis larger than\\n9999909"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "its not"
                    },
                    {
                        "username": "ap56",
                        "content": "zzzzzzza\\nis not lexigraphically smaller than \\nzzzzzzaz\\nbecause in the first position that they differ, character at index 6, the second string has value \\'a\\' while the first string has value \\'z\\' and \\'a\\'<\\'z\\'.\\n\\nthe logic of changing the last letter to \\'a\\' is to meet a specific requirement from the question: \\nGiven a palindromic string of lowercase English letters palindrome, replace exactly one character with any lowercase English letter so that the resulting string is not a palindrome and that it is the lexicographically smallest one possible.\\n\\nThe last sentence asks to return the lexicographically smallest string among potential answers. The for loop from the given solutions accomplishes this by inserting an \\'a\\' at the first opportunity. However, there is the edgecase of a string of all \\'a\\'s.\\n\\nSo if the input string was: \"aaaaaaa\"\\n\"baaaaaa\"\\nand \\n\"aaaaaab\"\\nare both potential answers, but we will choose to return the second one, where \\'b\\' is inserted at the end, because it is the lexigraphically smallest potential answer. I hope this helps, I was confused about this too and had to read the question again."
                    },
                    {
                        "username": "__aadi9754",
                        "content": "which is lexicographical smaller :- aab or abb"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "According to definition in this question \\u2013 \"aab\"."
                    },
                    {
                        "username": "VignaTejReddy",
                        "content": "lexicographical order means order in dictionary. first aab comes next abb."
                    },
                    {
                        "username": "akashsharma15105",
                        "content": "aab"
                    },
                    {
                        "username": "arkwaw",
                        "content": "aab"
                    },
                    {
                        "username": "awdhesh_kumar",
                        "content": "aab "
                    },
                    {
                        "username": "CalderWilson",
                        "content": "for the case \"aacaa\", wouldn\\'t the correct answer be \"aabaa\"? Leetcode says the answer should be \"aacab\", but isn\\'t that lexically larger?"
                    },
                    {
                        "username": "ianjulo",
                        "content": "\"aacab\" is still a palindrome. "
                    },
                    {
                        "username": "Dnevnik_dvevuchka",
                        "content": "Input: palindrome = \"abccba\"\\nOutput: \"aaccba\"\\n\\nshouldn\\'t the output be abccbb?\\n\\nplease explain."
                    },
                    {
                        "username": "Dnevnik_dvevuchka",
                        "content": "[@who_rules](/who_rules) the ascii codes also are listed sequentially.  In layman terms, a lexicographical order is the same as that in a dictionary. in this light, we would list abccbb before aaccba. \\nDo you mean that we have to keep the word such that the place value of the replaced character should be maximum while the replaced letter minimum. "
                    },
                    {
                        "username": "who_rules",
                        "content": "for example the ASCII code of \\'a\\' is 97, \\'b\\' is 98 and so on. in such case, \\'a\\' is the \"least\" char and \\'z\\' is the \"most\"\\nyou should place have least character in resulting string first"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The biggest key which helped me is that the input is a palindrome, you only have to iterate over the first half."
                    }
                ]
            },
            {
                "id": 1915674,
                "content": [
                    {
                        "username": "endorsiVal",
                        "content": "This question is useless. Literally does nothing to help you become a better leetcoder"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "It\\'s a good problem which offers a nice alternative to the usual palindrome questions."
                    },
                    {
                        "username": "lavos4life",
                        "content": "i think it\\'s a good exercise in catching special cases."
                    },
                    {
                        "username": "juwikuang",
                        "content": "this is just easy, entry level probelm. not medium. "
                    },
                    {
                        "username": "Sudha_S",
                        "content": "This is quite a simple problem:\\n(1) You cannot do anything about a single length string. \\n      Return \"\".\\n(2) For the first half of the string, check if there\\'s a character  \\n     greater than \\'a\\' & replace it by \\'a\\'\\n(3) ALL the first half characters are \\'a\\'s. Hence, replace the \\n    LAST element of the string by \\'b\\'."
                    },
                    {
                        "username": "sivansh1103",
                        "content": "in my opinion, this question is not clear to understand, as in the term lexicography is not properly explained, and the acceptance criteria is not properly explained."
                    },
                    {
                        "username": "bhagya_rana",
                        "content": "Think in Terms of Below Cases!\\n\\nCASE 1 : Single Letter Strings Like \\'a\\'/\\'b\\'\\nCASE 2 : If Starting Letter of Palindromic String is Not \\'a\\'\\nCASE 3 : If Starting Letter of Palindromic String is \\'a\\'\\n- Case 3.1 : Find Next Letter that is Not Equal to \\'a\\' \\n- Case 3.2 : If All Letters in Strings are \\'a\\' Eg. \\'aaaaa\\'\\n\\nTry it Yourself Before Clicking  [here](https://leetcode.com/problems/break-a-palindrome/solutions/2683839/3-cases-approach-simple-string-traversal-c/)."
                    },
                    {
                        "username": "kudratkhujamusaev",
                        "content": "Case 2 is not necessary. Case 3.1 covers it  "
                    },
                    {
                        "username": "atharva-agrawal",
                        "content": "Thanks for the Cases!"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Well guess what, this exact question came in JPMC coding round!"
                    },
                    {
                        "username": "BOVAGE",
                        "content": "[@abrods2](/abrods2) True. "
                    },
                    {
                        "username": "abrods2",
                        "content": "[@tfeq](/tfeq) Internship, but it was slightly easier"
                    },
                    {
                        "username": "tfeq",
                        "content": "Hey! was this for new grad or internship?"
                    },
                    {
                        "username": "sc1233",
                        "content": "Can someone help me understand the logic of changing the last letter to \\'a\\'?\\n\\nWhy is\\nzzzzzzza\\nlexicographically smaller than\\nzzzzzzaz\\n\\nDon\\'t understand, because if we compare to numbers, then\\n9999990\\nis larger than\\n9999909"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "its not"
                    },
                    {
                        "username": "ap56",
                        "content": "zzzzzzza\\nis not lexigraphically smaller than \\nzzzzzzaz\\nbecause in the first position that they differ, character at index 6, the second string has value \\'a\\' while the first string has value \\'z\\' and \\'a\\'<\\'z\\'.\\n\\nthe logic of changing the last letter to \\'a\\' is to meet a specific requirement from the question: \\nGiven a palindromic string of lowercase English letters palindrome, replace exactly one character with any lowercase English letter so that the resulting string is not a palindrome and that it is the lexicographically smallest one possible.\\n\\nThe last sentence asks to return the lexicographically smallest string among potential answers. The for loop from the given solutions accomplishes this by inserting an \\'a\\' at the first opportunity. However, there is the edgecase of a string of all \\'a\\'s.\\n\\nSo if the input string was: \"aaaaaaa\"\\n\"baaaaaa\"\\nand \\n\"aaaaaab\"\\nare both potential answers, but we will choose to return the second one, where \\'b\\' is inserted at the end, because it is the lexigraphically smallest potential answer. I hope this helps, I was confused about this too and had to read the question again."
                    },
                    {
                        "username": "__aadi9754",
                        "content": "which is lexicographical smaller :- aab or abb"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "According to definition in this question \\u2013 \"aab\"."
                    },
                    {
                        "username": "VignaTejReddy",
                        "content": "lexicographical order means order in dictionary. first aab comes next abb."
                    },
                    {
                        "username": "akashsharma15105",
                        "content": "aab"
                    },
                    {
                        "username": "arkwaw",
                        "content": "aab"
                    },
                    {
                        "username": "awdhesh_kumar",
                        "content": "aab "
                    },
                    {
                        "username": "CalderWilson",
                        "content": "for the case \"aacaa\", wouldn\\'t the correct answer be \"aabaa\"? Leetcode says the answer should be \"aacab\", but isn\\'t that lexically larger?"
                    },
                    {
                        "username": "ianjulo",
                        "content": "\"aacab\" is still a palindrome. "
                    },
                    {
                        "username": "Dnevnik_dvevuchka",
                        "content": "Input: palindrome = \"abccba\"\\nOutput: \"aaccba\"\\n\\nshouldn\\'t the output be abccbb?\\n\\nplease explain."
                    },
                    {
                        "username": "Dnevnik_dvevuchka",
                        "content": "[@who_rules](/who_rules) the ascii codes also are listed sequentially.  In layman terms, a lexicographical order is the same as that in a dictionary. in this light, we would list abccbb before aaccba. \\nDo you mean that we have to keep the word such that the place value of the replaced character should be maximum while the replaced letter minimum. "
                    },
                    {
                        "username": "who_rules",
                        "content": "for example the ASCII code of \\'a\\' is 97, \\'b\\' is 98 and so on. in such case, \\'a\\' is the \"least\" char and \\'z\\' is the \"most\"\\nyou should place have least character in resulting string first"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The biggest key which helped me is that the input is a palindrome, you only have to iterate over the first half."
                    }
                ]
            },
            {
                "id": 1638912,
                "content": [
                    {
                        "username": "endorsiVal",
                        "content": "This question is useless. Literally does nothing to help you become a better leetcoder"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "It\\'s a good problem which offers a nice alternative to the usual palindrome questions."
                    },
                    {
                        "username": "lavos4life",
                        "content": "i think it\\'s a good exercise in catching special cases."
                    },
                    {
                        "username": "juwikuang",
                        "content": "this is just easy, entry level probelm. not medium. "
                    },
                    {
                        "username": "Sudha_S",
                        "content": "This is quite a simple problem:\\n(1) You cannot do anything about a single length string. \\n      Return \"\".\\n(2) For the first half of the string, check if there\\'s a character  \\n     greater than \\'a\\' & replace it by \\'a\\'\\n(3) ALL the first half characters are \\'a\\'s. Hence, replace the \\n    LAST element of the string by \\'b\\'."
                    },
                    {
                        "username": "sivansh1103",
                        "content": "in my opinion, this question is not clear to understand, as in the term lexicography is not properly explained, and the acceptance criteria is not properly explained."
                    },
                    {
                        "username": "bhagya_rana",
                        "content": "Think in Terms of Below Cases!\\n\\nCASE 1 : Single Letter Strings Like \\'a\\'/\\'b\\'\\nCASE 2 : If Starting Letter of Palindromic String is Not \\'a\\'\\nCASE 3 : If Starting Letter of Palindromic String is \\'a\\'\\n- Case 3.1 : Find Next Letter that is Not Equal to \\'a\\' \\n- Case 3.2 : If All Letters in Strings are \\'a\\' Eg. \\'aaaaa\\'\\n\\nTry it Yourself Before Clicking  [here](https://leetcode.com/problems/break-a-palindrome/solutions/2683839/3-cases-approach-simple-string-traversal-c/)."
                    },
                    {
                        "username": "kudratkhujamusaev",
                        "content": "Case 2 is not necessary. Case 3.1 covers it  "
                    },
                    {
                        "username": "atharva-agrawal",
                        "content": "Thanks for the Cases!"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Well guess what, this exact question came in JPMC coding round!"
                    },
                    {
                        "username": "BOVAGE",
                        "content": "[@abrods2](/abrods2) True. "
                    },
                    {
                        "username": "abrods2",
                        "content": "[@tfeq](/tfeq) Internship, but it was slightly easier"
                    },
                    {
                        "username": "tfeq",
                        "content": "Hey! was this for new grad or internship?"
                    },
                    {
                        "username": "sc1233",
                        "content": "Can someone help me understand the logic of changing the last letter to \\'a\\'?\\n\\nWhy is\\nzzzzzzza\\nlexicographically smaller than\\nzzzzzzaz\\n\\nDon\\'t understand, because if we compare to numbers, then\\n9999990\\nis larger than\\n9999909"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "its not"
                    },
                    {
                        "username": "ap56",
                        "content": "zzzzzzza\\nis not lexigraphically smaller than \\nzzzzzzaz\\nbecause in the first position that they differ, character at index 6, the second string has value \\'a\\' while the first string has value \\'z\\' and \\'a\\'<\\'z\\'.\\n\\nthe logic of changing the last letter to \\'a\\' is to meet a specific requirement from the question: \\nGiven a palindromic string of lowercase English letters palindrome, replace exactly one character with any lowercase English letter so that the resulting string is not a palindrome and that it is the lexicographically smallest one possible.\\n\\nThe last sentence asks to return the lexicographically smallest string among potential answers. The for loop from the given solutions accomplishes this by inserting an \\'a\\' at the first opportunity. However, there is the edgecase of a string of all \\'a\\'s.\\n\\nSo if the input string was: \"aaaaaaa\"\\n\"baaaaaa\"\\nand \\n\"aaaaaab\"\\nare both potential answers, but we will choose to return the second one, where \\'b\\' is inserted at the end, because it is the lexigraphically smallest potential answer. I hope this helps, I was confused about this too and had to read the question again."
                    },
                    {
                        "username": "__aadi9754",
                        "content": "which is lexicographical smaller :- aab or abb"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "According to definition in this question \\u2013 \"aab\"."
                    },
                    {
                        "username": "VignaTejReddy",
                        "content": "lexicographical order means order in dictionary. first aab comes next abb."
                    },
                    {
                        "username": "akashsharma15105",
                        "content": "aab"
                    },
                    {
                        "username": "arkwaw",
                        "content": "aab"
                    },
                    {
                        "username": "awdhesh_kumar",
                        "content": "aab "
                    },
                    {
                        "username": "CalderWilson",
                        "content": "for the case \"aacaa\", wouldn\\'t the correct answer be \"aabaa\"? Leetcode says the answer should be \"aacab\", but isn\\'t that lexically larger?"
                    },
                    {
                        "username": "ianjulo",
                        "content": "\"aacab\" is still a palindrome. "
                    },
                    {
                        "username": "Dnevnik_dvevuchka",
                        "content": "Input: palindrome = \"abccba\"\\nOutput: \"aaccba\"\\n\\nshouldn\\'t the output be abccbb?\\n\\nplease explain."
                    },
                    {
                        "username": "Dnevnik_dvevuchka",
                        "content": "[@who_rules](/who_rules) the ascii codes also are listed sequentially.  In layman terms, a lexicographical order is the same as that in a dictionary. in this light, we would list abccbb before aaccba. \\nDo you mean that we have to keep the word such that the place value of the replaced character should be maximum while the replaced letter minimum. "
                    },
                    {
                        "username": "who_rules",
                        "content": "for example the ASCII code of \\'a\\' is 97, \\'b\\' is 98 and so on. in such case, \\'a\\' is the \"least\" char and \\'z\\' is the \"most\"\\nyou should place have least character in resulting string first"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The biggest key which helped me is that the input is a palindrome, you only have to iterate over the first half."
                    }
                ]
            },
            {
                "id": 1639295,
                "content": [
                    {
                        "username": "endorsiVal",
                        "content": "This question is useless. Literally does nothing to help you become a better leetcoder"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "It\\'s a good problem which offers a nice alternative to the usual palindrome questions."
                    },
                    {
                        "username": "lavos4life",
                        "content": "i think it\\'s a good exercise in catching special cases."
                    },
                    {
                        "username": "juwikuang",
                        "content": "this is just easy, entry level probelm. not medium. "
                    },
                    {
                        "username": "Sudha_S",
                        "content": "This is quite a simple problem:\\n(1) You cannot do anything about a single length string. \\n      Return \"\".\\n(2) For the first half of the string, check if there\\'s a character  \\n     greater than \\'a\\' & replace it by \\'a\\'\\n(3) ALL the first half characters are \\'a\\'s. Hence, replace the \\n    LAST element of the string by \\'b\\'."
                    },
                    {
                        "username": "sivansh1103",
                        "content": "in my opinion, this question is not clear to understand, as in the term lexicography is not properly explained, and the acceptance criteria is not properly explained."
                    },
                    {
                        "username": "bhagya_rana",
                        "content": "Think in Terms of Below Cases!\\n\\nCASE 1 : Single Letter Strings Like \\'a\\'/\\'b\\'\\nCASE 2 : If Starting Letter of Palindromic String is Not \\'a\\'\\nCASE 3 : If Starting Letter of Palindromic String is \\'a\\'\\n- Case 3.1 : Find Next Letter that is Not Equal to \\'a\\' \\n- Case 3.2 : If All Letters in Strings are \\'a\\' Eg. \\'aaaaa\\'\\n\\nTry it Yourself Before Clicking  [here](https://leetcode.com/problems/break-a-palindrome/solutions/2683839/3-cases-approach-simple-string-traversal-c/)."
                    },
                    {
                        "username": "kudratkhujamusaev",
                        "content": "Case 2 is not necessary. Case 3.1 covers it  "
                    },
                    {
                        "username": "atharva-agrawal",
                        "content": "Thanks for the Cases!"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Well guess what, this exact question came in JPMC coding round!"
                    },
                    {
                        "username": "BOVAGE",
                        "content": "[@abrods2](/abrods2) True. "
                    },
                    {
                        "username": "abrods2",
                        "content": "[@tfeq](/tfeq) Internship, but it was slightly easier"
                    },
                    {
                        "username": "tfeq",
                        "content": "Hey! was this for new grad or internship?"
                    },
                    {
                        "username": "sc1233",
                        "content": "Can someone help me understand the logic of changing the last letter to \\'a\\'?\\n\\nWhy is\\nzzzzzzza\\nlexicographically smaller than\\nzzzzzzaz\\n\\nDon\\'t understand, because if we compare to numbers, then\\n9999990\\nis larger than\\n9999909"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "its not"
                    },
                    {
                        "username": "ap56",
                        "content": "zzzzzzza\\nis not lexigraphically smaller than \\nzzzzzzaz\\nbecause in the first position that they differ, character at index 6, the second string has value \\'a\\' while the first string has value \\'z\\' and \\'a\\'<\\'z\\'.\\n\\nthe logic of changing the last letter to \\'a\\' is to meet a specific requirement from the question: \\nGiven a palindromic string of lowercase English letters palindrome, replace exactly one character with any lowercase English letter so that the resulting string is not a palindrome and that it is the lexicographically smallest one possible.\\n\\nThe last sentence asks to return the lexicographically smallest string among potential answers. The for loop from the given solutions accomplishes this by inserting an \\'a\\' at the first opportunity. However, there is the edgecase of a string of all \\'a\\'s.\\n\\nSo if the input string was: \"aaaaaaa\"\\n\"baaaaaa\"\\nand \\n\"aaaaaab\"\\nare both potential answers, but we will choose to return the second one, where \\'b\\' is inserted at the end, because it is the lexigraphically smallest potential answer. I hope this helps, I was confused about this too and had to read the question again."
                    },
                    {
                        "username": "__aadi9754",
                        "content": "which is lexicographical smaller :- aab or abb"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "According to definition in this question \\u2013 \"aab\"."
                    },
                    {
                        "username": "VignaTejReddy",
                        "content": "lexicographical order means order in dictionary. first aab comes next abb."
                    },
                    {
                        "username": "akashsharma15105",
                        "content": "aab"
                    },
                    {
                        "username": "arkwaw",
                        "content": "aab"
                    },
                    {
                        "username": "awdhesh_kumar",
                        "content": "aab "
                    },
                    {
                        "username": "CalderWilson",
                        "content": "for the case \"aacaa\", wouldn\\'t the correct answer be \"aabaa\"? Leetcode says the answer should be \"aacab\", but isn\\'t that lexically larger?"
                    },
                    {
                        "username": "ianjulo",
                        "content": "\"aacab\" is still a palindrome. "
                    },
                    {
                        "username": "Dnevnik_dvevuchka",
                        "content": "Input: palindrome = \"abccba\"\\nOutput: \"aaccba\"\\n\\nshouldn\\'t the output be abccbb?\\n\\nplease explain."
                    },
                    {
                        "username": "Dnevnik_dvevuchka",
                        "content": "[@who_rules](/who_rules) the ascii codes also are listed sequentially.  In layman terms, a lexicographical order is the same as that in a dictionary. in this light, we would list abccbb before aaccba. \\nDo you mean that we have to keep the word such that the place value of the replaced character should be maximum while the replaced letter minimum. "
                    },
                    {
                        "username": "who_rules",
                        "content": "for example the ASCII code of \\'a\\' is 97, \\'b\\' is 98 and so on. in such case, \\'a\\' is the \"least\" char and \\'z\\' is the \"most\"\\nyou should place have least character in resulting string first"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The biggest key which helped me is that the input is a palindrome, you only have to iterate over the first half."
                    }
                ]
            },
            {
                "id": 1641327,
                "content": [
                    {
                        "username": "endorsiVal",
                        "content": "This question is useless. Literally does nothing to help you become a better leetcoder"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "It\\'s a good problem which offers a nice alternative to the usual palindrome questions."
                    },
                    {
                        "username": "lavos4life",
                        "content": "i think it\\'s a good exercise in catching special cases."
                    },
                    {
                        "username": "juwikuang",
                        "content": "this is just easy, entry level probelm. not medium. "
                    },
                    {
                        "username": "Sudha_S",
                        "content": "This is quite a simple problem:\\n(1) You cannot do anything about a single length string. \\n      Return \"\".\\n(2) For the first half of the string, check if there\\'s a character  \\n     greater than \\'a\\' & replace it by \\'a\\'\\n(3) ALL the first half characters are \\'a\\'s. Hence, replace the \\n    LAST element of the string by \\'b\\'."
                    },
                    {
                        "username": "sivansh1103",
                        "content": "in my opinion, this question is not clear to understand, as in the term lexicography is not properly explained, and the acceptance criteria is not properly explained."
                    },
                    {
                        "username": "bhagya_rana",
                        "content": "Think in Terms of Below Cases!\\n\\nCASE 1 : Single Letter Strings Like \\'a\\'/\\'b\\'\\nCASE 2 : If Starting Letter of Palindromic String is Not \\'a\\'\\nCASE 3 : If Starting Letter of Palindromic String is \\'a\\'\\n- Case 3.1 : Find Next Letter that is Not Equal to \\'a\\' \\n- Case 3.2 : If All Letters in Strings are \\'a\\' Eg. \\'aaaaa\\'\\n\\nTry it Yourself Before Clicking  [here](https://leetcode.com/problems/break-a-palindrome/solutions/2683839/3-cases-approach-simple-string-traversal-c/)."
                    },
                    {
                        "username": "kudratkhujamusaev",
                        "content": "Case 2 is not necessary. Case 3.1 covers it  "
                    },
                    {
                        "username": "atharva-agrawal",
                        "content": "Thanks for the Cases!"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Well guess what, this exact question came in JPMC coding round!"
                    },
                    {
                        "username": "BOVAGE",
                        "content": "[@abrods2](/abrods2) True. "
                    },
                    {
                        "username": "abrods2",
                        "content": "[@tfeq](/tfeq) Internship, but it was slightly easier"
                    },
                    {
                        "username": "tfeq",
                        "content": "Hey! was this for new grad or internship?"
                    },
                    {
                        "username": "sc1233",
                        "content": "Can someone help me understand the logic of changing the last letter to \\'a\\'?\\n\\nWhy is\\nzzzzzzza\\nlexicographically smaller than\\nzzzzzzaz\\n\\nDon\\'t understand, because if we compare to numbers, then\\n9999990\\nis larger than\\n9999909"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "its not"
                    },
                    {
                        "username": "ap56",
                        "content": "zzzzzzza\\nis not lexigraphically smaller than \\nzzzzzzaz\\nbecause in the first position that they differ, character at index 6, the second string has value \\'a\\' while the first string has value \\'z\\' and \\'a\\'<\\'z\\'.\\n\\nthe logic of changing the last letter to \\'a\\' is to meet a specific requirement from the question: \\nGiven a palindromic string of lowercase English letters palindrome, replace exactly one character with any lowercase English letter so that the resulting string is not a palindrome and that it is the lexicographically smallest one possible.\\n\\nThe last sentence asks to return the lexicographically smallest string among potential answers. The for loop from the given solutions accomplishes this by inserting an \\'a\\' at the first opportunity. However, there is the edgecase of a string of all \\'a\\'s.\\n\\nSo if the input string was: \"aaaaaaa\"\\n\"baaaaaa\"\\nand \\n\"aaaaaab\"\\nare both potential answers, but we will choose to return the second one, where \\'b\\' is inserted at the end, because it is the lexigraphically smallest potential answer. I hope this helps, I was confused about this too and had to read the question again."
                    },
                    {
                        "username": "__aadi9754",
                        "content": "which is lexicographical smaller :- aab or abb"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "According to definition in this question \\u2013 \"aab\"."
                    },
                    {
                        "username": "VignaTejReddy",
                        "content": "lexicographical order means order in dictionary. first aab comes next abb."
                    },
                    {
                        "username": "akashsharma15105",
                        "content": "aab"
                    },
                    {
                        "username": "arkwaw",
                        "content": "aab"
                    },
                    {
                        "username": "awdhesh_kumar",
                        "content": "aab "
                    },
                    {
                        "username": "CalderWilson",
                        "content": "for the case \"aacaa\", wouldn\\'t the correct answer be \"aabaa\"? Leetcode says the answer should be \"aacab\", but isn\\'t that lexically larger?"
                    },
                    {
                        "username": "ianjulo",
                        "content": "\"aacab\" is still a palindrome. "
                    },
                    {
                        "username": "Dnevnik_dvevuchka",
                        "content": "Input: palindrome = \"abccba\"\\nOutput: \"aaccba\"\\n\\nshouldn\\'t the output be abccbb?\\n\\nplease explain."
                    },
                    {
                        "username": "Dnevnik_dvevuchka",
                        "content": "[@who_rules](/who_rules) the ascii codes also are listed sequentially.  In layman terms, a lexicographical order is the same as that in a dictionary. in this light, we would list abccbb before aaccba. \\nDo you mean that we have to keep the word such that the place value of the replaced character should be maximum while the replaced letter minimum. "
                    },
                    {
                        "username": "who_rules",
                        "content": "for example the ASCII code of \\'a\\' is 97, \\'b\\' is 98 and so on. in such case, \\'a\\' is the \"least\" char and \\'z\\' is the \"most\"\\nyou should place have least character in resulting string first"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The biggest key which helped me is that the input is a palindrome, you only have to iterate over the first half."
                    }
                ]
            },
            {
                "id": 1639002,
                "content": [
                    {
                        "username": "endorsiVal",
                        "content": "This question is useless. Literally does nothing to help you become a better leetcoder"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "It\\'s a good problem which offers a nice alternative to the usual palindrome questions."
                    },
                    {
                        "username": "lavos4life",
                        "content": "i think it\\'s a good exercise in catching special cases."
                    },
                    {
                        "username": "juwikuang",
                        "content": "this is just easy, entry level probelm. not medium. "
                    },
                    {
                        "username": "Sudha_S",
                        "content": "This is quite a simple problem:\\n(1) You cannot do anything about a single length string. \\n      Return \"\".\\n(2) For the first half of the string, check if there\\'s a character  \\n     greater than \\'a\\' & replace it by \\'a\\'\\n(3) ALL the first half characters are \\'a\\'s. Hence, replace the \\n    LAST element of the string by \\'b\\'."
                    },
                    {
                        "username": "sivansh1103",
                        "content": "in my opinion, this question is not clear to understand, as in the term lexicography is not properly explained, and the acceptance criteria is not properly explained."
                    },
                    {
                        "username": "bhagya_rana",
                        "content": "Think in Terms of Below Cases!\\n\\nCASE 1 : Single Letter Strings Like \\'a\\'/\\'b\\'\\nCASE 2 : If Starting Letter of Palindromic String is Not \\'a\\'\\nCASE 3 : If Starting Letter of Palindromic String is \\'a\\'\\n- Case 3.1 : Find Next Letter that is Not Equal to \\'a\\' \\n- Case 3.2 : If All Letters in Strings are \\'a\\' Eg. \\'aaaaa\\'\\n\\nTry it Yourself Before Clicking  [here](https://leetcode.com/problems/break-a-palindrome/solutions/2683839/3-cases-approach-simple-string-traversal-c/)."
                    },
                    {
                        "username": "kudratkhujamusaev",
                        "content": "Case 2 is not necessary. Case 3.1 covers it  "
                    },
                    {
                        "username": "atharva-agrawal",
                        "content": "Thanks for the Cases!"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Well guess what, this exact question came in JPMC coding round!"
                    },
                    {
                        "username": "BOVAGE",
                        "content": "[@abrods2](/abrods2) True. "
                    },
                    {
                        "username": "abrods2",
                        "content": "[@tfeq](/tfeq) Internship, but it was slightly easier"
                    },
                    {
                        "username": "tfeq",
                        "content": "Hey! was this for new grad or internship?"
                    },
                    {
                        "username": "sc1233",
                        "content": "Can someone help me understand the logic of changing the last letter to \\'a\\'?\\n\\nWhy is\\nzzzzzzza\\nlexicographically smaller than\\nzzzzzzaz\\n\\nDon\\'t understand, because if we compare to numbers, then\\n9999990\\nis larger than\\n9999909"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "its not"
                    },
                    {
                        "username": "ap56",
                        "content": "zzzzzzza\\nis not lexigraphically smaller than \\nzzzzzzaz\\nbecause in the first position that they differ, character at index 6, the second string has value \\'a\\' while the first string has value \\'z\\' and \\'a\\'<\\'z\\'.\\n\\nthe logic of changing the last letter to \\'a\\' is to meet a specific requirement from the question: \\nGiven a palindromic string of lowercase English letters palindrome, replace exactly one character with any lowercase English letter so that the resulting string is not a palindrome and that it is the lexicographically smallest one possible.\\n\\nThe last sentence asks to return the lexicographically smallest string among potential answers. The for loop from the given solutions accomplishes this by inserting an \\'a\\' at the first opportunity. However, there is the edgecase of a string of all \\'a\\'s.\\n\\nSo if the input string was: \"aaaaaaa\"\\n\"baaaaaa\"\\nand \\n\"aaaaaab\"\\nare both potential answers, but we will choose to return the second one, where \\'b\\' is inserted at the end, because it is the lexigraphically smallest potential answer. I hope this helps, I was confused about this too and had to read the question again."
                    },
                    {
                        "username": "__aadi9754",
                        "content": "which is lexicographical smaller :- aab or abb"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "According to definition in this question \\u2013 \"aab\"."
                    },
                    {
                        "username": "VignaTejReddy",
                        "content": "lexicographical order means order in dictionary. first aab comes next abb."
                    },
                    {
                        "username": "akashsharma15105",
                        "content": "aab"
                    },
                    {
                        "username": "arkwaw",
                        "content": "aab"
                    },
                    {
                        "username": "awdhesh_kumar",
                        "content": "aab "
                    },
                    {
                        "username": "CalderWilson",
                        "content": "for the case \"aacaa\", wouldn\\'t the correct answer be \"aabaa\"? Leetcode says the answer should be \"aacab\", but isn\\'t that lexically larger?"
                    },
                    {
                        "username": "ianjulo",
                        "content": "\"aacab\" is still a palindrome. "
                    },
                    {
                        "username": "Dnevnik_dvevuchka",
                        "content": "Input: palindrome = \"abccba\"\\nOutput: \"aaccba\"\\n\\nshouldn\\'t the output be abccbb?\\n\\nplease explain."
                    },
                    {
                        "username": "Dnevnik_dvevuchka",
                        "content": "[@who_rules](/who_rules) the ascii codes also are listed sequentially.  In layman terms, a lexicographical order is the same as that in a dictionary. in this light, we would list abccbb before aaccba. \\nDo you mean that we have to keep the word such that the place value of the replaced character should be maximum while the replaced letter minimum. "
                    },
                    {
                        "username": "who_rules",
                        "content": "for example the ASCII code of \\'a\\' is 97, \\'b\\' is 98 and so on. in such case, \\'a\\' is the \"least\" char and \\'z\\' is the \"most\"\\nyou should place have least character in resulting string first"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The biggest key which helped me is that the input is a palindrome, you only have to iterate over the first half."
                    }
                ]
            },
            {
                "id": 1857373,
                "content": [
                    {
                        "username": "endorsiVal",
                        "content": "This question is useless. Literally does nothing to help you become a better leetcoder"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "It\\'s a good problem which offers a nice alternative to the usual palindrome questions."
                    },
                    {
                        "username": "lavos4life",
                        "content": "i think it\\'s a good exercise in catching special cases."
                    },
                    {
                        "username": "juwikuang",
                        "content": "this is just easy, entry level probelm. not medium. "
                    },
                    {
                        "username": "Sudha_S",
                        "content": "This is quite a simple problem:\\n(1) You cannot do anything about a single length string. \\n      Return \"\".\\n(2) For the first half of the string, check if there\\'s a character  \\n     greater than \\'a\\' & replace it by \\'a\\'\\n(3) ALL the first half characters are \\'a\\'s. Hence, replace the \\n    LAST element of the string by \\'b\\'."
                    },
                    {
                        "username": "sivansh1103",
                        "content": "in my opinion, this question is not clear to understand, as in the term lexicography is not properly explained, and the acceptance criteria is not properly explained."
                    },
                    {
                        "username": "bhagya_rana",
                        "content": "Think in Terms of Below Cases!\\n\\nCASE 1 : Single Letter Strings Like \\'a\\'/\\'b\\'\\nCASE 2 : If Starting Letter of Palindromic String is Not \\'a\\'\\nCASE 3 : If Starting Letter of Palindromic String is \\'a\\'\\n- Case 3.1 : Find Next Letter that is Not Equal to \\'a\\' \\n- Case 3.2 : If All Letters in Strings are \\'a\\' Eg. \\'aaaaa\\'\\n\\nTry it Yourself Before Clicking  [here](https://leetcode.com/problems/break-a-palindrome/solutions/2683839/3-cases-approach-simple-string-traversal-c/)."
                    },
                    {
                        "username": "kudratkhujamusaev",
                        "content": "Case 2 is not necessary. Case 3.1 covers it  "
                    },
                    {
                        "username": "atharva-agrawal",
                        "content": "Thanks for the Cases!"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Well guess what, this exact question came in JPMC coding round!"
                    },
                    {
                        "username": "BOVAGE",
                        "content": "[@abrods2](/abrods2) True. "
                    },
                    {
                        "username": "abrods2",
                        "content": "[@tfeq](/tfeq) Internship, but it was slightly easier"
                    },
                    {
                        "username": "tfeq",
                        "content": "Hey! was this for new grad or internship?"
                    },
                    {
                        "username": "sc1233",
                        "content": "Can someone help me understand the logic of changing the last letter to \\'a\\'?\\n\\nWhy is\\nzzzzzzza\\nlexicographically smaller than\\nzzzzzzaz\\n\\nDon\\'t understand, because if we compare to numbers, then\\n9999990\\nis larger than\\n9999909"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "its not"
                    },
                    {
                        "username": "ap56",
                        "content": "zzzzzzza\\nis not lexigraphically smaller than \\nzzzzzzaz\\nbecause in the first position that they differ, character at index 6, the second string has value \\'a\\' while the first string has value \\'z\\' and \\'a\\'<\\'z\\'.\\n\\nthe logic of changing the last letter to \\'a\\' is to meet a specific requirement from the question: \\nGiven a palindromic string of lowercase English letters palindrome, replace exactly one character with any lowercase English letter so that the resulting string is not a palindrome and that it is the lexicographically smallest one possible.\\n\\nThe last sentence asks to return the lexicographically smallest string among potential answers. The for loop from the given solutions accomplishes this by inserting an \\'a\\' at the first opportunity. However, there is the edgecase of a string of all \\'a\\'s.\\n\\nSo if the input string was: \"aaaaaaa\"\\n\"baaaaaa\"\\nand \\n\"aaaaaab\"\\nare both potential answers, but we will choose to return the second one, where \\'b\\' is inserted at the end, because it is the lexigraphically smallest potential answer. I hope this helps, I was confused about this too and had to read the question again."
                    },
                    {
                        "username": "__aadi9754",
                        "content": "which is lexicographical smaller :- aab or abb"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "According to definition in this question \\u2013 \"aab\"."
                    },
                    {
                        "username": "VignaTejReddy",
                        "content": "lexicographical order means order in dictionary. first aab comes next abb."
                    },
                    {
                        "username": "akashsharma15105",
                        "content": "aab"
                    },
                    {
                        "username": "arkwaw",
                        "content": "aab"
                    },
                    {
                        "username": "awdhesh_kumar",
                        "content": "aab "
                    },
                    {
                        "username": "CalderWilson",
                        "content": "for the case \"aacaa\", wouldn\\'t the correct answer be \"aabaa\"? Leetcode says the answer should be \"aacab\", but isn\\'t that lexically larger?"
                    },
                    {
                        "username": "ianjulo",
                        "content": "\"aacab\" is still a palindrome. "
                    },
                    {
                        "username": "Dnevnik_dvevuchka",
                        "content": "Input: palindrome = \"abccba\"\\nOutput: \"aaccba\"\\n\\nshouldn\\'t the output be abccbb?\\n\\nplease explain."
                    },
                    {
                        "username": "Dnevnik_dvevuchka",
                        "content": "[@who_rules](/who_rules) the ascii codes also are listed sequentially.  In layman terms, a lexicographical order is the same as that in a dictionary. in this light, we would list abccbb before aaccba. \\nDo you mean that we have to keep the word such that the place value of the replaced character should be maximum while the replaced letter minimum. "
                    },
                    {
                        "username": "who_rules",
                        "content": "for example the ASCII code of \\'a\\' is 97, \\'b\\' is 98 and so on. in such case, \\'a\\' is the \"least\" char and \\'z\\' is the \"most\"\\nyou should place have least character in resulting string first"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The biggest key which helped me is that the input is a palindrome, you only have to iterate over the first half."
                    }
                ]
            },
            {
                "id": 1645018,
                "content": [
                    {
                        "username": "endorsiVal",
                        "content": "This question is useless. Literally does nothing to help you become a better leetcoder"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "It\\'s a good problem which offers a nice alternative to the usual palindrome questions."
                    },
                    {
                        "username": "lavos4life",
                        "content": "i think it\\'s a good exercise in catching special cases."
                    },
                    {
                        "username": "juwikuang",
                        "content": "this is just easy, entry level probelm. not medium. "
                    },
                    {
                        "username": "Sudha_S",
                        "content": "This is quite a simple problem:\\n(1) You cannot do anything about a single length string. \\n      Return \"\".\\n(2) For the first half of the string, check if there\\'s a character  \\n     greater than \\'a\\' & replace it by \\'a\\'\\n(3) ALL the first half characters are \\'a\\'s. Hence, replace the \\n    LAST element of the string by \\'b\\'."
                    },
                    {
                        "username": "sivansh1103",
                        "content": "in my opinion, this question is not clear to understand, as in the term lexicography is not properly explained, and the acceptance criteria is not properly explained."
                    },
                    {
                        "username": "bhagya_rana",
                        "content": "Think in Terms of Below Cases!\\n\\nCASE 1 : Single Letter Strings Like \\'a\\'/\\'b\\'\\nCASE 2 : If Starting Letter of Palindromic String is Not \\'a\\'\\nCASE 3 : If Starting Letter of Palindromic String is \\'a\\'\\n- Case 3.1 : Find Next Letter that is Not Equal to \\'a\\' \\n- Case 3.2 : If All Letters in Strings are \\'a\\' Eg. \\'aaaaa\\'\\n\\nTry it Yourself Before Clicking  [here](https://leetcode.com/problems/break-a-palindrome/solutions/2683839/3-cases-approach-simple-string-traversal-c/)."
                    },
                    {
                        "username": "kudratkhujamusaev",
                        "content": "Case 2 is not necessary. Case 3.1 covers it  "
                    },
                    {
                        "username": "atharva-agrawal",
                        "content": "Thanks for the Cases!"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Well guess what, this exact question came in JPMC coding round!"
                    },
                    {
                        "username": "BOVAGE",
                        "content": "[@abrods2](/abrods2) True. "
                    },
                    {
                        "username": "abrods2",
                        "content": "[@tfeq](/tfeq) Internship, but it was slightly easier"
                    },
                    {
                        "username": "tfeq",
                        "content": "Hey! was this for new grad or internship?"
                    },
                    {
                        "username": "sc1233",
                        "content": "Can someone help me understand the logic of changing the last letter to \\'a\\'?\\n\\nWhy is\\nzzzzzzza\\nlexicographically smaller than\\nzzzzzzaz\\n\\nDon\\'t understand, because if we compare to numbers, then\\n9999990\\nis larger than\\n9999909"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "its not"
                    },
                    {
                        "username": "ap56",
                        "content": "zzzzzzza\\nis not lexigraphically smaller than \\nzzzzzzaz\\nbecause in the first position that they differ, character at index 6, the second string has value \\'a\\' while the first string has value \\'z\\' and \\'a\\'<\\'z\\'.\\n\\nthe logic of changing the last letter to \\'a\\' is to meet a specific requirement from the question: \\nGiven a palindromic string of lowercase English letters palindrome, replace exactly one character with any lowercase English letter so that the resulting string is not a palindrome and that it is the lexicographically smallest one possible.\\n\\nThe last sentence asks to return the lexicographically smallest string among potential answers. The for loop from the given solutions accomplishes this by inserting an \\'a\\' at the first opportunity. However, there is the edgecase of a string of all \\'a\\'s.\\n\\nSo if the input string was: \"aaaaaaa\"\\n\"baaaaaa\"\\nand \\n\"aaaaaab\"\\nare both potential answers, but we will choose to return the second one, where \\'b\\' is inserted at the end, because it is the lexigraphically smallest potential answer. I hope this helps, I was confused about this too and had to read the question again."
                    },
                    {
                        "username": "__aadi9754",
                        "content": "which is lexicographical smaller :- aab or abb"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "According to definition in this question \\u2013 \"aab\"."
                    },
                    {
                        "username": "VignaTejReddy",
                        "content": "lexicographical order means order in dictionary. first aab comes next abb."
                    },
                    {
                        "username": "akashsharma15105",
                        "content": "aab"
                    },
                    {
                        "username": "arkwaw",
                        "content": "aab"
                    },
                    {
                        "username": "awdhesh_kumar",
                        "content": "aab "
                    },
                    {
                        "username": "CalderWilson",
                        "content": "for the case \"aacaa\", wouldn\\'t the correct answer be \"aabaa\"? Leetcode says the answer should be \"aacab\", but isn\\'t that lexically larger?"
                    },
                    {
                        "username": "ianjulo",
                        "content": "\"aacab\" is still a palindrome. "
                    },
                    {
                        "username": "Dnevnik_dvevuchka",
                        "content": "Input: palindrome = \"abccba\"\\nOutput: \"aaccba\"\\n\\nshouldn\\'t the output be abccbb?\\n\\nplease explain."
                    },
                    {
                        "username": "Dnevnik_dvevuchka",
                        "content": "[@who_rules](/who_rules) the ascii codes also are listed sequentially.  In layman terms, a lexicographical order is the same as that in a dictionary. in this light, we would list abccbb before aaccba. \\nDo you mean that we have to keep the word such that the place value of the replaced character should be maximum while the replaced letter minimum. "
                    },
                    {
                        "username": "who_rules",
                        "content": "for example the ASCII code of \\'a\\' is 97, \\'b\\' is 98 and so on. in such case, \\'a\\' is the \"least\" char and \\'z\\' is the \"most\"\\nyou should place have least character in resulting string first"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The biggest key which helped me is that the input is a palindrome, you only have to iterate over the first half."
                    }
                ]
            },
            {
                "id": 1639236,
                "content": [
                    {
                        "username": "endorsiVal",
                        "content": "This question is useless. Literally does nothing to help you become a better leetcoder"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "It\\'s a good problem which offers a nice alternative to the usual palindrome questions."
                    },
                    {
                        "username": "lavos4life",
                        "content": "i think it\\'s a good exercise in catching special cases."
                    },
                    {
                        "username": "juwikuang",
                        "content": "this is just easy, entry level probelm. not medium. "
                    },
                    {
                        "username": "Sudha_S",
                        "content": "This is quite a simple problem:\\n(1) You cannot do anything about a single length string. \\n      Return \"\".\\n(2) For the first half of the string, check if there\\'s a character  \\n     greater than \\'a\\' & replace it by \\'a\\'\\n(3) ALL the first half characters are \\'a\\'s. Hence, replace the \\n    LAST element of the string by \\'b\\'."
                    },
                    {
                        "username": "sivansh1103",
                        "content": "in my opinion, this question is not clear to understand, as in the term lexicography is not properly explained, and the acceptance criteria is not properly explained."
                    },
                    {
                        "username": "bhagya_rana",
                        "content": "Think in Terms of Below Cases!\\n\\nCASE 1 : Single Letter Strings Like \\'a\\'/\\'b\\'\\nCASE 2 : If Starting Letter of Palindromic String is Not \\'a\\'\\nCASE 3 : If Starting Letter of Palindromic String is \\'a\\'\\n- Case 3.1 : Find Next Letter that is Not Equal to \\'a\\' \\n- Case 3.2 : If All Letters in Strings are \\'a\\' Eg. \\'aaaaa\\'\\n\\nTry it Yourself Before Clicking  [here](https://leetcode.com/problems/break-a-palindrome/solutions/2683839/3-cases-approach-simple-string-traversal-c/)."
                    },
                    {
                        "username": "kudratkhujamusaev",
                        "content": "Case 2 is not necessary. Case 3.1 covers it  "
                    },
                    {
                        "username": "atharva-agrawal",
                        "content": "Thanks for the Cases!"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Well guess what, this exact question came in JPMC coding round!"
                    },
                    {
                        "username": "BOVAGE",
                        "content": "[@abrods2](/abrods2) True. "
                    },
                    {
                        "username": "abrods2",
                        "content": "[@tfeq](/tfeq) Internship, but it was slightly easier"
                    },
                    {
                        "username": "tfeq",
                        "content": "Hey! was this for new grad or internship?"
                    },
                    {
                        "username": "sc1233",
                        "content": "Can someone help me understand the logic of changing the last letter to \\'a\\'?\\n\\nWhy is\\nzzzzzzza\\nlexicographically smaller than\\nzzzzzzaz\\n\\nDon\\'t understand, because if we compare to numbers, then\\n9999990\\nis larger than\\n9999909"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "its not"
                    },
                    {
                        "username": "ap56",
                        "content": "zzzzzzza\\nis not lexigraphically smaller than \\nzzzzzzaz\\nbecause in the first position that they differ, character at index 6, the second string has value \\'a\\' while the first string has value \\'z\\' and \\'a\\'<\\'z\\'.\\n\\nthe logic of changing the last letter to \\'a\\' is to meet a specific requirement from the question: \\nGiven a palindromic string of lowercase English letters palindrome, replace exactly one character with any lowercase English letter so that the resulting string is not a palindrome and that it is the lexicographically smallest one possible.\\n\\nThe last sentence asks to return the lexicographically smallest string among potential answers. The for loop from the given solutions accomplishes this by inserting an \\'a\\' at the first opportunity. However, there is the edgecase of a string of all \\'a\\'s.\\n\\nSo if the input string was: \"aaaaaaa\"\\n\"baaaaaa\"\\nand \\n\"aaaaaab\"\\nare both potential answers, but we will choose to return the second one, where \\'b\\' is inserted at the end, because it is the lexigraphically smallest potential answer. I hope this helps, I was confused about this too and had to read the question again."
                    },
                    {
                        "username": "__aadi9754",
                        "content": "which is lexicographical smaller :- aab or abb"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "According to definition in this question \\u2013 \"aab\"."
                    },
                    {
                        "username": "VignaTejReddy",
                        "content": "lexicographical order means order in dictionary. first aab comes next abb."
                    },
                    {
                        "username": "akashsharma15105",
                        "content": "aab"
                    },
                    {
                        "username": "arkwaw",
                        "content": "aab"
                    },
                    {
                        "username": "awdhesh_kumar",
                        "content": "aab "
                    },
                    {
                        "username": "CalderWilson",
                        "content": "for the case \"aacaa\", wouldn\\'t the correct answer be \"aabaa\"? Leetcode says the answer should be \"aacab\", but isn\\'t that lexically larger?"
                    },
                    {
                        "username": "ianjulo",
                        "content": "\"aacab\" is still a palindrome. "
                    },
                    {
                        "username": "Dnevnik_dvevuchka",
                        "content": "Input: palindrome = \"abccba\"\\nOutput: \"aaccba\"\\n\\nshouldn\\'t the output be abccbb?\\n\\nplease explain."
                    },
                    {
                        "username": "Dnevnik_dvevuchka",
                        "content": "[@who_rules](/who_rules) the ascii codes also are listed sequentially.  In layman terms, a lexicographical order is the same as that in a dictionary. in this light, we would list abccbb before aaccba. \\nDo you mean that we have to keep the word such that the place value of the replaced character should be maximum while the replaced letter minimum. "
                    },
                    {
                        "username": "who_rules",
                        "content": "for example the ASCII code of \\'a\\' is 97, \\'b\\' is 98 and so on. in such case, \\'a\\' is the \"least\" char and \\'z\\' is the \"most\"\\nyou should place have least character in resulting string first"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The biggest key which helped me is that the input is a palindrome, you only have to iterate over the first half."
                    }
                ]
            },
            {
                "id": 2029084,
                "content": [
                    {
                        "username": "endorsiVal",
                        "content": "This question is useless. Literally does nothing to help you become a better leetcoder"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "It\\'s a good problem which offers a nice alternative to the usual palindrome questions."
                    },
                    {
                        "username": "lavos4life",
                        "content": "i think it\\'s a good exercise in catching special cases."
                    },
                    {
                        "username": "juwikuang",
                        "content": "this is just easy, entry level probelm. not medium. "
                    },
                    {
                        "username": "Sudha_S",
                        "content": "This is quite a simple problem:\\n(1) You cannot do anything about a single length string. \\n      Return \"\".\\n(2) For the first half of the string, check if there\\'s a character  \\n     greater than \\'a\\' & replace it by \\'a\\'\\n(3) ALL the first half characters are \\'a\\'s. Hence, replace the \\n    LAST element of the string by \\'b\\'."
                    },
                    {
                        "username": "sivansh1103",
                        "content": "in my opinion, this question is not clear to understand, as in the term lexicography is not properly explained, and the acceptance criteria is not properly explained."
                    },
                    {
                        "username": "bhagya_rana",
                        "content": "Think in Terms of Below Cases!\\n\\nCASE 1 : Single Letter Strings Like \\'a\\'/\\'b\\'\\nCASE 2 : If Starting Letter of Palindromic String is Not \\'a\\'\\nCASE 3 : If Starting Letter of Palindromic String is \\'a\\'\\n- Case 3.1 : Find Next Letter that is Not Equal to \\'a\\' \\n- Case 3.2 : If All Letters in Strings are \\'a\\' Eg. \\'aaaaa\\'\\n\\nTry it Yourself Before Clicking  [here](https://leetcode.com/problems/break-a-palindrome/solutions/2683839/3-cases-approach-simple-string-traversal-c/)."
                    },
                    {
                        "username": "kudratkhujamusaev",
                        "content": "Case 2 is not necessary. Case 3.1 covers it  "
                    },
                    {
                        "username": "atharva-agrawal",
                        "content": "Thanks for the Cases!"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Well guess what, this exact question came in JPMC coding round!"
                    },
                    {
                        "username": "BOVAGE",
                        "content": "[@abrods2](/abrods2) True. "
                    },
                    {
                        "username": "abrods2",
                        "content": "[@tfeq](/tfeq) Internship, but it was slightly easier"
                    },
                    {
                        "username": "tfeq",
                        "content": "Hey! was this for new grad or internship?"
                    },
                    {
                        "username": "sc1233",
                        "content": "Can someone help me understand the logic of changing the last letter to \\'a\\'?\\n\\nWhy is\\nzzzzzzza\\nlexicographically smaller than\\nzzzzzzaz\\n\\nDon\\'t understand, because if we compare to numbers, then\\n9999990\\nis larger than\\n9999909"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "its not"
                    },
                    {
                        "username": "ap56",
                        "content": "zzzzzzza\\nis not lexigraphically smaller than \\nzzzzzzaz\\nbecause in the first position that they differ, character at index 6, the second string has value \\'a\\' while the first string has value \\'z\\' and \\'a\\'<\\'z\\'.\\n\\nthe logic of changing the last letter to \\'a\\' is to meet a specific requirement from the question: \\nGiven a palindromic string of lowercase English letters palindrome, replace exactly one character with any lowercase English letter so that the resulting string is not a palindrome and that it is the lexicographically smallest one possible.\\n\\nThe last sentence asks to return the lexicographically smallest string among potential answers. The for loop from the given solutions accomplishes this by inserting an \\'a\\' at the first opportunity. However, there is the edgecase of a string of all \\'a\\'s.\\n\\nSo if the input string was: \"aaaaaaa\"\\n\"baaaaaa\"\\nand \\n\"aaaaaab\"\\nare both potential answers, but we will choose to return the second one, where \\'b\\' is inserted at the end, because it is the lexigraphically smallest potential answer. I hope this helps, I was confused about this too and had to read the question again."
                    },
                    {
                        "username": "__aadi9754",
                        "content": "which is lexicographical smaller :- aab or abb"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "According to definition in this question \\u2013 \"aab\"."
                    },
                    {
                        "username": "VignaTejReddy",
                        "content": "lexicographical order means order in dictionary. first aab comes next abb."
                    },
                    {
                        "username": "akashsharma15105",
                        "content": "aab"
                    },
                    {
                        "username": "arkwaw",
                        "content": "aab"
                    },
                    {
                        "username": "awdhesh_kumar",
                        "content": "aab "
                    },
                    {
                        "username": "CalderWilson",
                        "content": "for the case \"aacaa\", wouldn\\'t the correct answer be \"aabaa\"? Leetcode says the answer should be \"aacab\", but isn\\'t that lexically larger?"
                    },
                    {
                        "username": "ianjulo",
                        "content": "\"aacab\" is still a palindrome. "
                    },
                    {
                        "username": "Dnevnik_dvevuchka",
                        "content": "Input: palindrome = \"abccba\"\\nOutput: \"aaccba\"\\n\\nshouldn\\'t the output be abccbb?\\n\\nplease explain."
                    },
                    {
                        "username": "Dnevnik_dvevuchka",
                        "content": "[@who_rules](/who_rules) the ascii codes also are listed sequentially.  In layman terms, a lexicographical order is the same as that in a dictionary. in this light, we would list abccbb before aaccba. \\nDo you mean that we have to keep the word such that the place value of the replaced character should be maximum while the replaced letter minimum. "
                    },
                    {
                        "username": "who_rules",
                        "content": "for example the ASCII code of \\'a\\' is 97, \\'b\\' is 98 and so on. in such case, \\'a\\' is the \"least\" char and \\'z\\' is the \"most\"\\nyou should place have least character in resulting string first"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The biggest key which helped me is that the input is a palindrome, you only have to iterate over the first half."
                    }
                ]
            },
            {
                "id": 2015231,
                "content": [
                    {
                        "username": "endorsiVal",
                        "content": "This question is useless. Literally does nothing to help you become a better leetcoder"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "It\\'s a good problem which offers a nice alternative to the usual palindrome questions."
                    },
                    {
                        "username": "lavos4life",
                        "content": "i think it\\'s a good exercise in catching special cases."
                    },
                    {
                        "username": "juwikuang",
                        "content": "this is just easy, entry level probelm. not medium. "
                    },
                    {
                        "username": "Sudha_S",
                        "content": "This is quite a simple problem:\\n(1) You cannot do anything about a single length string. \\n      Return \"\".\\n(2) For the first half of the string, check if there\\'s a character  \\n     greater than \\'a\\' & replace it by \\'a\\'\\n(3) ALL the first half characters are \\'a\\'s. Hence, replace the \\n    LAST element of the string by \\'b\\'."
                    },
                    {
                        "username": "sivansh1103",
                        "content": "in my opinion, this question is not clear to understand, as in the term lexicography is not properly explained, and the acceptance criteria is not properly explained."
                    },
                    {
                        "username": "bhagya_rana",
                        "content": "Think in Terms of Below Cases!\\n\\nCASE 1 : Single Letter Strings Like \\'a\\'/\\'b\\'\\nCASE 2 : If Starting Letter of Palindromic String is Not \\'a\\'\\nCASE 3 : If Starting Letter of Palindromic String is \\'a\\'\\n- Case 3.1 : Find Next Letter that is Not Equal to \\'a\\' \\n- Case 3.2 : If All Letters in Strings are \\'a\\' Eg. \\'aaaaa\\'\\n\\nTry it Yourself Before Clicking  [here](https://leetcode.com/problems/break-a-palindrome/solutions/2683839/3-cases-approach-simple-string-traversal-c/)."
                    },
                    {
                        "username": "kudratkhujamusaev",
                        "content": "Case 2 is not necessary. Case 3.1 covers it  "
                    },
                    {
                        "username": "atharva-agrawal",
                        "content": "Thanks for the Cases!"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Well guess what, this exact question came in JPMC coding round!"
                    },
                    {
                        "username": "BOVAGE",
                        "content": "[@abrods2](/abrods2) True. "
                    },
                    {
                        "username": "abrods2",
                        "content": "[@tfeq](/tfeq) Internship, but it was slightly easier"
                    },
                    {
                        "username": "tfeq",
                        "content": "Hey! was this for new grad or internship?"
                    },
                    {
                        "username": "sc1233",
                        "content": "Can someone help me understand the logic of changing the last letter to \\'a\\'?\\n\\nWhy is\\nzzzzzzza\\nlexicographically smaller than\\nzzzzzzaz\\n\\nDon\\'t understand, because if we compare to numbers, then\\n9999990\\nis larger than\\n9999909"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "its not"
                    },
                    {
                        "username": "ap56",
                        "content": "zzzzzzza\\nis not lexigraphically smaller than \\nzzzzzzaz\\nbecause in the first position that they differ, character at index 6, the second string has value \\'a\\' while the first string has value \\'z\\' and \\'a\\'<\\'z\\'.\\n\\nthe logic of changing the last letter to \\'a\\' is to meet a specific requirement from the question: \\nGiven a palindromic string of lowercase English letters palindrome, replace exactly one character with any lowercase English letter so that the resulting string is not a palindrome and that it is the lexicographically smallest one possible.\\n\\nThe last sentence asks to return the lexicographically smallest string among potential answers. The for loop from the given solutions accomplishes this by inserting an \\'a\\' at the first opportunity. However, there is the edgecase of a string of all \\'a\\'s.\\n\\nSo if the input string was: \"aaaaaaa\"\\n\"baaaaaa\"\\nand \\n\"aaaaaab\"\\nare both potential answers, but we will choose to return the second one, where \\'b\\' is inserted at the end, because it is the lexigraphically smallest potential answer. I hope this helps, I was confused about this too and had to read the question again."
                    },
                    {
                        "username": "__aadi9754",
                        "content": "which is lexicographical smaller :- aab or abb"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "According to definition in this question \\u2013 \"aab\"."
                    },
                    {
                        "username": "VignaTejReddy",
                        "content": "lexicographical order means order in dictionary. first aab comes next abb."
                    },
                    {
                        "username": "akashsharma15105",
                        "content": "aab"
                    },
                    {
                        "username": "arkwaw",
                        "content": "aab"
                    },
                    {
                        "username": "awdhesh_kumar",
                        "content": "aab "
                    },
                    {
                        "username": "CalderWilson",
                        "content": "for the case \"aacaa\", wouldn\\'t the correct answer be \"aabaa\"? Leetcode says the answer should be \"aacab\", but isn\\'t that lexically larger?"
                    },
                    {
                        "username": "ianjulo",
                        "content": "\"aacab\" is still a palindrome. "
                    },
                    {
                        "username": "Dnevnik_dvevuchka",
                        "content": "Input: palindrome = \"abccba\"\\nOutput: \"aaccba\"\\n\\nshouldn\\'t the output be abccbb?\\n\\nplease explain."
                    },
                    {
                        "username": "Dnevnik_dvevuchka",
                        "content": "[@who_rules](/who_rules) the ascii codes also are listed sequentially.  In layman terms, a lexicographical order is the same as that in a dictionary. in this light, we would list abccbb before aaccba. \\nDo you mean that we have to keep the word such that the place value of the replaced character should be maximum while the replaced letter minimum. "
                    },
                    {
                        "username": "who_rules",
                        "content": "for example the ASCII code of \\'a\\' is 97, \\'b\\' is 98 and so on. in such case, \\'a\\' is the \"least\" char and \\'z\\' is the \"most\"\\nyou should place have least character in resulting string first"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The biggest key which helped me is that the input is a palindrome, you only have to iterate over the first half."
                    }
                ]
            },
            {
                "id": 1915674,
                "content": [
                    {
                        "username": "endorsiVal",
                        "content": "This question is useless. Literally does nothing to help you become a better leetcoder"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "It\\'s a good problem which offers a nice alternative to the usual palindrome questions."
                    },
                    {
                        "username": "lavos4life",
                        "content": "i think it\\'s a good exercise in catching special cases."
                    },
                    {
                        "username": "juwikuang",
                        "content": "this is just easy, entry level probelm. not medium. "
                    },
                    {
                        "username": "Sudha_S",
                        "content": "This is quite a simple problem:\\n(1) You cannot do anything about a single length string. \\n      Return \"\".\\n(2) For the first half of the string, check if there\\'s a character  \\n     greater than \\'a\\' & replace it by \\'a\\'\\n(3) ALL the first half characters are \\'a\\'s. Hence, replace the \\n    LAST element of the string by \\'b\\'."
                    },
                    {
                        "username": "sivansh1103",
                        "content": "in my opinion, this question is not clear to understand, as in the term lexicography is not properly explained, and the acceptance criteria is not properly explained."
                    },
                    {
                        "username": "bhagya_rana",
                        "content": "Think in Terms of Below Cases!\\n\\nCASE 1 : Single Letter Strings Like \\'a\\'/\\'b\\'\\nCASE 2 : If Starting Letter of Palindromic String is Not \\'a\\'\\nCASE 3 : If Starting Letter of Palindromic String is \\'a\\'\\n- Case 3.1 : Find Next Letter that is Not Equal to \\'a\\' \\n- Case 3.2 : If All Letters in Strings are \\'a\\' Eg. \\'aaaaa\\'\\n\\nTry it Yourself Before Clicking  [here](https://leetcode.com/problems/break-a-palindrome/solutions/2683839/3-cases-approach-simple-string-traversal-c/)."
                    },
                    {
                        "username": "kudratkhujamusaev",
                        "content": "Case 2 is not necessary. Case 3.1 covers it  "
                    },
                    {
                        "username": "atharva-agrawal",
                        "content": "Thanks for the Cases!"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Well guess what, this exact question came in JPMC coding round!"
                    },
                    {
                        "username": "BOVAGE",
                        "content": "[@abrods2](/abrods2) True. "
                    },
                    {
                        "username": "abrods2",
                        "content": "[@tfeq](/tfeq) Internship, but it was slightly easier"
                    },
                    {
                        "username": "tfeq",
                        "content": "Hey! was this for new grad or internship?"
                    },
                    {
                        "username": "sc1233",
                        "content": "Can someone help me understand the logic of changing the last letter to \\'a\\'?\\n\\nWhy is\\nzzzzzzza\\nlexicographically smaller than\\nzzzzzzaz\\n\\nDon\\'t understand, because if we compare to numbers, then\\n9999990\\nis larger than\\n9999909"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "its not"
                    },
                    {
                        "username": "ap56",
                        "content": "zzzzzzza\\nis not lexigraphically smaller than \\nzzzzzzaz\\nbecause in the first position that they differ, character at index 6, the second string has value \\'a\\' while the first string has value \\'z\\' and \\'a\\'<\\'z\\'.\\n\\nthe logic of changing the last letter to \\'a\\' is to meet a specific requirement from the question: \\nGiven a palindromic string of lowercase English letters palindrome, replace exactly one character with any lowercase English letter so that the resulting string is not a palindrome and that it is the lexicographically smallest one possible.\\n\\nThe last sentence asks to return the lexicographically smallest string among potential answers. The for loop from the given solutions accomplishes this by inserting an \\'a\\' at the first opportunity. However, there is the edgecase of a string of all \\'a\\'s.\\n\\nSo if the input string was: \"aaaaaaa\"\\n\"baaaaaa\"\\nand \\n\"aaaaaab\"\\nare both potential answers, but we will choose to return the second one, where \\'b\\' is inserted at the end, because it is the lexigraphically smallest potential answer. I hope this helps, I was confused about this too and had to read the question again."
                    },
                    {
                        "username": "__aadi9754",
                        "content": "which is lexicographical smaller :- aab or abb"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "According to definition in this question \\u2013 \"aab\"."
                    },
                    {
                        "username": "VignaTejReddy",
                        "content": "lexicographical order means order in dictionary. first aab comes next abb."
                    },
                    {
                        "username": "akashsharma15105",
                        "content": "aab"
                    },
                    {
                        "username": "arkwaw",
                        "content": "aab"
                    },
                    {
                        "username": "awdhesh_kumar",
                        "content": "aab "
                    },
                    {
                        "username": "CalderWilson",
                        "content": "for the case \"aacaa\", wouldn\\'t the correct answer be \"aabaa\"? Leetcode says the answer should be \"aacab\", but isn\\'t that lexically larger?"
                    },
                    {
                        "username": "ianjulo",
                        "content": "\"aacab\" is still a palindrome. "
                    },
                    {
                        "username": "Dnevnik_dvevuchka",
                        "content": "Input: palindrome = \"abccba\"\\nOutput: \"aaccba\"\\n\\nshouldn\\'t the output be abccbb?\\n\\nplease explain."
                    },
                    {
                        "username": "Dnevnik_dvevuchka",
                        "content": "[@who_rules](/who_rules) the ascii codes also are listed sequentially.  In layman terms, a lexicographical order is the same as that in a dictionary. in this light, we would list abccbb before aaccba. \\nDo you mean that we have to keep the word such that the place value of the replaced character should be maximum while the replaced letter minimum. "
                    },
                    {
                        "username": "who_rules",
                        "content": "for example the ASCII code of \\'a\\' is 97, \\'b\\' is 98 and so on. in such case, \\'a\\' is the \"least\" char and \\'z\\' is the \"most\"\\nyou should place have least character in resulting string first"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The biggest key which helped me is that the input is a palindrome, you only have to iterate over the first half."
                    }
                ]
            }
        ]
    }
]