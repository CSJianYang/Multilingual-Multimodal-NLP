[
    {
        "title": "Maximum Running Time of N Computers",
        "question_content": "You have n computers. You are given the integer n and a 0-indexed integer array batteries where the ith battery can run a computer for batteries[i] minutes. You are interested in running all n computers simultaneously using the given batteries.\nInitially, you can insert at most one battery into each computer. After that and at any integer time moment, you can remove a battery from a computer and insert another battery any number of times. The inserted battery can be a totally new battery or a battery from another computer. You may assume that the removing and inserting processes take no time.\nNote that the batteries cannot be recharged.\nReturn the maximum number of minutes you can run all the n computers simultaneously.\n&nbsp;\nExample 1:\n\nInput: n = 2, batteries = [3,3,3]\nOutput: 4\nExplanation: \nInitially, insert battery 0 into the first computer and battery 1 into the second computer.\nAfter two minutes, remove battery 1 from the second computer and insert battery 2 instead. Note that battery 1 can still run for one minute.\nAt the end of the third minute, battery 0 is drained, and you need to remove it from the first computer and insert battery 1 instead.\nBy the end of the fourth minute, battery 1 is also drained, and the first computer is no longer running.\nWe can run the two computers simultaneously for at most 4 minutes, so we return 4.\n\nExample 2:\n\nInput: n = 2, batteries = [1,1,1,1]\nOutput: 2\nExplanation: \nInitially, insert battery 0 into the first computer and battery 2 into the second computer. \nAfter one minute, battery 0 and battery 2 are drained so you need to remove them and insert battery 1 into the first computer and battery 3 into the second computer. \nAfter another minute, battery 1 and battery 3 are also drained so the first and second computers are no longer running.\nWe can run the two computers simultaneously for at most 2 minutes, so we return 2.\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= batteries.length <= 105\n\t1 <= batteries[i] <= 109",
        "solutions": [
            {
                "id": 1692939,
                "title": "java-c-python-sort-solution-with-explanation-o-mlogm",
                "content": "# **Intuition**\\nThe staright idea, is to use all baterial evenly.\\nSo we take advantage of all the energy wihout any left.\\nIn this case, we can run up to `sum(A) / n` minutes.\\nThis average value is an upper bounde of the final result.\\nIt\\'s great to start with this enviromental intuition.\\n\\n# **Explanation**\\nHowever, there may be some betteries that has too much energy.\\nThey are in charge all the time,\\nbut still can\\'t run out all they have,\\nthen their energy wastes.\\n\\n\\nSo we can compare the average value with the most powerful battery `max(A)`.\\nIf `max(A)` is bigger, then we can use this battery to charge a computer all the time.\\nNow we reduce the problem to the left bettery and `n - 1` computers.\\n\\nWe continue doing this process,\\nuntil the most powerful bettery `max(A)` can not run average time `sum(A) / n`.\\nThen the left betteries can help each other and be use evenly until the end.\\nOne key point of this problem, it\\'s to find out, why betteries can be used \"evenly\" in this situation.\\n\\nOne quick \"prove\" is that, the `max(A)` is smaller than the running time, \\nso the maximum battery won\\'t get wasted,\\nthe other smaller betteries won\\'t even get easted.\\n<br>\\n\\n# **Complexity**\\nTime `O(sort)`\\nSpace `O(sort)`\\n\\nThe best solution can be `O(A)`, similar to quick select algo.\\n<br>\\n\\n**Java**\\n```java\\n    public long maxRunTime(int n, int[] A) {\\n        Arrays.sort(A);\\n        long sum = 0;\\n        for (int a: A)\\n            sum += a;\\n        int k = 0, na = A.length;\\n        while (A[na - 1 - k] > sum / (n - k))\\n            sum -= A[na - 1 - k++];\\n        return sum / (n - k);\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    long long maxRunTime(int n, vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        long long sum = accumulate(A.begin(), A.end(), 0L);\\n        int k = 0, na = A.size();\\n        while (A[na - 1 - k] > sum / (n - k))\\n            sum -= A[na - 1 - k++];\\n        return sum / (n - k);\\n    }\\n```\\n\\n**Python**\\n```py\\n    def maxRunTime(self, n, A):\\n        A.sort()\\n        su = sum(A)\\n        while A[-1] > su / n:\\n            n -= 1\\n            su -= A.pop()\\n        return su / n\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public long maxRunTime(int n, int[] A) {\\n        Arrays.sort(A);\\n        long sum = 0;\\n        for (int a: A)\\n            sum += a;\\n        int k = 0, na = A.length;\\n        while (A[na - 1 - k] > sum / (n - k))\\n            sum -= A[na - 1 - k++];\\n        return sum / (n - k);\\n    }\\n```\n```cpp\\n    long long maxRunTime(int n, vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        long long sum = accumulate(A.begin(), A.end(), 0L);\\n        int k = 0, na = A.size();\\n        while (A[na - 1 - k] > sum / (n - k))\\n            sum -= A[na - 1 - k++];\\n        return sum / (n - k);\\n    }\\n```\n```py\\n    def maxRunTime(self, n, A):\\n        A.sort()\\n        su = sum(A)\\n        while A[-1] > su / n:\\n            n -= 1\\n            su -= A.pop()\\n        return su / n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1693347,
                "title": "heap-vs-binary-search",
                "content": "I got stuck on this question, trying to find a way to do a simulation. No luck.\\n\\nI found it harder than usual to develop an intuition for the binary search here. The heap-based solution is even trickier, but more efficient - O(n log m).\\n\\n**Intuition:** if one of the batteries has a lot of charge, we may not be able to use it up if we cannot run `n - 1` computers long enough on remaining (smaller) batteries.\\n\\n#### Solution 1: Heap\\nLet us take the \"juiciest\" battery that holds the charge for `x` minutes. If the charge per computer `sum / n` (where `sum` is aggregated charge of all batteries) is less than `x`, this battery can run one of the computers as long as needed. So, we put this battery and one of the computers aside, and find the answers for the remaining batteries, and `n - 1` computers.\\n\\nIf the charge per computer is equal or greater than `x`, we can run the remaining computers for  `sum / n` minutes. And this is our answer!\\n\\nThis solution has a better complexity: O(n log m), where m is the number of batteries. We pull up to `n` elements of of the heap of size `m`. We initialize the heap in place, so the initialization is O(m).\\n\\n**C++**\\n```cpp\\nlong long maxRunTime(int n, vector<int>& bat) {\\n    long long sum = accumulate(begin(bat), end(bat), 0LL);\\n    priority_queue<int> pq(begin(bat), end(bat));\\n    while (pq.top() > sum / n) {\\n        sum -= pq.top(); pq.pop();\\n        --n;\\n    }\\n    return sum / n;\\n}\\n```\\n\\n#### Solution 2: Binary Search\\n\\nThe idea is to check if we can run computers for `m` hours (`n * m` total hours). For that, we accumulate power from all batteries, taking no more than `m` from each. If we have enough power for `n * m` hours - we can run all our computers for `m` hours.\\n\\n**C++**\\n```cpp\\nlong long maxRunTime(int n, vector<int>& bat) {\\n    long long l = 0, r = accumulate(begin(bat), end(bat), 0LL) / n;\\n    while (l < r) {\\n        long long m = (l + r + 1) / 2, minutes = 0;\\n        for (int b : bat)\\n            minutes += min((long long)b, m);\\n        if (minutes >= n * m)\\n            l = m;\\n        else\\n            r = m - 1;\\n    }\\n    return l;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nlong long maxRunTime(int n, vector<int>& bat) {\\n    long long sum = accumulate(begin(bat), end(bat), 0LL);\\n    priority_queue<int> pq(begin(bat), end(bat));\\n    while (pq.top() > sum / n) {\\n        sum -= pq.top(); pq.pop();\\n        --n;\\n    }\\n    return sum / n;\\n}\\n```\n```cpp\\nlong long maxRunTime(int n, vector<int>& bat) {\\n    long long l = 0, r = accumulate(begin(bat), end(bat), 0LL) / n;\\n    while (l < r) {\\n        long long m = (l + r + 1) / 2, minutes = 0;\\n        for (int b : bat)\\n            minutes += min((long long)b, m);\\n        if (minutes >= n * m)\\n            l = m;\\n        else\\n            r = m - 1;\\n    }\\n    return l;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1692979,
                "title": "java-simple-solution-w-explanation",
                "content": "## Observations\\n1. If the computers cannot run simultaneously for `a` minutes, then definitely they cannot run simultaneously for `b > a` minutes.\\n2. During a simultaneous run of `a` minutes, each battery, no matter how long it can run, can \"contribute\" a maximum of `a` minutes to the total running time.\\n\\n## Solution\\n- Based on Observation #1, perform a Binary Search on the maximum number of minutes for the simultaneous run attainable.\\n- The lower and upper bound for the Binary Search are 0 (cannot run at all) and `sum(batteries[i]) / n` (the computers\\' total running time cannot exceed total battery amounts)\\n- During each search, check whether all batteries \"contribute\" enough for the total running time required for this simultaneous run, based on Observation #2.\\n- The running time would be `O(n lg m)` where `m = sum(batteries[i])`  and n = `batteries.length` are the total sum of all batteries, and number of batteries.\\n\\n\\n## Code\\n```Java\\nclass Solution {\\n\\n    private boolean canFit(int n, long k, int[] batteries) {\\n        long currBatSum = 0;\\n        long target = n * k;\\n\\n        for (int bat : batteries) {\\n            if (bat < k) {\\n                currBatSum += bat;\\n            } else {\\n                currBatSum += k;\\n            }\\n\\n            if (currBatSum >= target) {\\n                return true;\\n            }\\n        }\\n\\n        return currBatSum >= target;\\n\\n    }\\n\\n    public long maxRunTime(int n, int[] batteries) {\\n        long batSum = 0;\\n        for (int bat : batteries) {\\n            batSum += bat;\\n        }\\n        \\n        long lower = 0;\\n        long upper = batSum / n;\\n        long res = -1;\\n\\n\\t\\t// binary search\\n        while (lower <= upper) {\\n            long mid = lower + (upper - lower) / 2;\\n\\n            if (canFit(n, mid, batteries)) {\\n                res = mid;\\n                lower = mid + 1;\\n            } else {\\n                upper = mid - 1;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n\\n    private boolean canFit(int n, long k, int[] batteries) {\\n        long currBatSum = 0;\\n        long target = n * k;\\n\\n        for (int bat : batteries) {\\n            if (bat < k) {\\n                currBatSum += bat;\\n            } else {\\n                currBatSum += k;\\n            }\\n\\n            if (currBatSum >= target) {\\n                return true;\\n            }\\n        }\\n\\n        return currBatSum >= target;\\n\\n    }\\n\\n    public long maxRunTime(int n, int[] batteries) {\\n        long batSum = 0;\\n        for (int bat : batteries) {\\n            batSum += bat;\\n        }\\n        \\n        long lower = 0;\\n        long upper = batSum / n;\\n        long res = -1;\\n\\n\\t\\t// binary search\\n        while (lower <= upper) {\\n            long mid = lower + (upper - lower) / 2;\\n\\n            if (canFit(n, mid, batteries)) {\\n                res = mid;\\n                lower = mid + 1;\\n            } else {\\n                upper = mid - 1;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821914,
                "title": "binary-search-observation-easy-explanation-2-approach-short-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe maximum possible ans can be sum of all batteries divide by no computers.\\nThe minimum possible ans can 1.\\nso we found a range for ans from 1 to sum/n and we need maximum time to run computer => **BINARY SEARCH**\\n\\n# Approach-1\\n<!-- Describe your approach to solving the problem. -->\\n- Take low as 0 and high as sum/n.\\n- mid is the maximum time of 1 computer \\n- Now we check how much time each batteries last\\n\\n---\\n\\n-  n = 2, batteries = [1,4,4]\\nlow =1 , high = 9/2 = 4 , mid =3\\ntime avilable = 1 4 4\\ntime need     = 3 3 3\\ntime we get = min(1,3)+min(4,3) + min(4,3) = 1+3+3=7\\n\\n---\\n\\n\\nNow if 1 computer take mid time then n computer take n*mid time.\\nSo if time >= mid*n then there is some time left to run more computer \\n=> low = mid \\nelse time < mid*n then we dont have time to run every computer mid time => high=mid-1\\n\\n\\n# Complexity\\n- Time complexity:O(NlogK) where k=10^9\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& b) {\\n        long long low =1;\\n        long long high = accumulate(begin(b),end(b),0LL)/n;\\n\\n        while(low < high){\\n            long long mid = (high+low+1)/2;\\n            long long time=0;\\n            for(int t : b) time += min((long long)t,mid);\\n\\n            if(mid*n <= time) low = mid;\\n            else high = mid-1;\\n        }\\n        return low;\\n    }\\n};\\n```\\n---\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this approach, we start with the maximum value battery and assign it to a computer. We then check if there is enough battery capacity left to be distributed among the remaining computers such that they can all run for the same amount of time. If there is enough capacity, we can treat this battery as an \"infinite\" battery for the purposes of our problem and continue with the next highest battery. If there is not enough capacity left, we stop and the answer is the sum of the remaining battery capacities divided by the number of computers.\\n# Approach-2\\n1. Sort the batteries in ascending order to have the highest capacity battery at the end.\\n2. Calculate the sum of all the batteries (sum).\\n3. Initialize a pointer i to the end of the sorted battery array (m-1)\\n4. While i is greater than or equal to 0 and the average capacity of the remaining batteries (sum/n) is less than the capacity of the battery at index i, we do the following:\\nSubtract the capacity of the battery at index i from the total sum (sum).\\nDecrement the number of computers (n) by 1.\\nDecrement the pointer i by 1.\\nThe answer is the remaining sum of battery capacities divided by the number of computers (sum/n).\\n\\nN computers are give and M batteries are given.\\nSo if one battery have charge of infinity then what happen?\\n\\n- We just assign this battery to one computer then check for remaning batteries.\\n- n=3 , batteries = [4,7,3,1000]\\n- so 1000 charge battery can be treated as INF battery?\\n- YES, because avg = 1014/3 {sum/n} and 1000 > avg \\n- INF battery can run for long time but remaining will not and we have make sure that all n computers are on simultaneously.\\n- so we assign one 1000 battery to one computer so n-1 => 2 computers are left.\\n- Now if check we can treat 7 as INF or not.\\n- so AVG sum = 3 + 4 + 7= 14 , avg = 14/2=7 does 7 > 7 ? NO\\n- so ans is sum/n = 14/2 =7\\n\\n# Complexity\\n- Time complexity:O(NlogN)+O(N)+O(N) = O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& b) {\\n        int m = b.size();\\n        sort(b.begin(),b.end());\\n        long long sum = accumulate(begin(b),end(b),0LL);\\n        int i=m-1;\\n        while(i>=0 && sum/n < b[i] ){\\n            sum -= b[i];\\n            n--;i--;\\n        }\\n        return sum/n;\\n    }\\n};\\n```\\n> Comment **Jai Shree Ram** if you get the Intuition.\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& b) {\\n        long long low =1;\\n        long long high = accumulate(begin(b),end(b),0LL)/n;\\n\\n        while(low < high){\\n            long long mid = (high+low+1)/2;\\n            long long time=0;\\n            for(int t : b) time += min((long long)t,mid);\\n\\n            if(mid*n <= time) low = mid;\\n            else high = mid-1;\\n        }\\n        return low;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& b) {\\n        int m = b.size();\\n        sort(b.begin(),b.end());\\n        long long sum = accumulate(begin(b),end(b),0LL);\\n        int i=m-1;\\n        while(i>=0 && sum/n < b[i] ){\\n            sum -= b[i];\\n            n--;i--;\\n        }\\n        return sum/n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694041,
                "title": "c-solution-using-binary-search-with-intuition-explanation",
                "content": "**Intuition**:  In the question it is asked to find the maximum number of minutes you can run all the n computers simultaneously.\\nFor a Binary Search type question we need to observe if the given question asks us to find minimum of maximums or maximums of minimum. If we can identify this in a question, it generally can be solved using **Binary Search** .\\nThe question stated to us is the maximum time all computers run simultaneously. \\nFor example,\\n**Input**: n = 2, batteries = [3,3,3]\\n*Assume : Time in minutes*\\nn computers can run for 0 minutes. (If not possible to run, lowest value will be zero)\\nn computers can run for 1 time. (Since our batteries have more than 1 (time) x 2(computers) charge, we can keep them alive for 1 minute for sure)\\nn computers can run for 2 minutes. \\n(This can be computed using basic thinking skills)\\n\\nWe observe that our answer varies in a range. If number of computers = 1, we need summation of all batteries, to keep it alive for the longest time.\\nTherefore, low = 0 (minTime kept alive), high = summation of batteries array\\n```\\nbool isPossible(vector<int>& batteries, long long time, int computers){\\n        long long totTime = time*computers;\\n        \\n        for(long long bTime : batteries)\\n            totTime -= min(time, bTime);\\n        \\n        return (totTime <= 0);//if entire charge for all computers is drained, then we used all batteries, so it\\'s a possible solution\\n    }\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        long long low = 0, high = 0;\\n        int si = batteries.size();\\n        \\n        for(int i = 0; i < si; i++){\\n            high += batteries[i];\\n        }\\n        \\n        long long ans = 0;\\n        while(low <= high){\\n            \\n            long long mid = low + (high-low)/2;\\n            \\n            if(isPossible(batteries, mid, n)){//asking for max minutes => increase the time to check if that\\'s possible\\n                ans = mid;\\n                low = mid+1;\\n            }\\n            else{\\n                 high = mid-1;//if this particular time isn\\'t possible, reduce the range to mid-1\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\t\\n\\t",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "**Intuition**:  In the question it is asked to find the maximum number of minutes you can run all the n computers simultaneously.\\nFor a Binary Search type question we need to observe if the given question asks us to find minimum of maximums or maximums of minimum. If we can identify this in a question, it generally can be solved using **Binary Search** .\\nThe question stated to us is the maximum time all computers run simultaneously. \\nFor example,\\n**Input**: n = 2, batteries = [3,3,3]\\n*Assume : Time in minutes*\\nn computers can run for 0 minutes. (If not possible to run, lowest value will be zero)\\nn computers can run for 1 time. (Since our batteries have more than 1 (time) x 2(computers) charge, we can keep them alive for 1 minute for sure)\\nn computers can run for 2 minutes. \\n(This can be computed using basic thinking skills)\\n\\nWe observe that our answer varies in a range. If number of computers = 1, we need summation of all batteries, to keep it alive for the longest time.\\nTherefore, low = 0 (minTime kept alive), high = summation of batteries array\\n```\\nbool isPossible(vector<int>& batteries, long long time, int computers){\\n        long long totTime = time*computers;\\n        \\n        for(long long bTime : batteries)\\n            totTime -= min(time, bTime);\\n        \\n        return (totTime <= 0);//if entire charge for all computers is drained, then we used all batteries, so it\\'s a possible solution\\n    }\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        long long low = 0, high = 0;\\n        int si = batteries.size();\\n        \\n        for(int i = 0; i < si; i++){\\n            high += batteries[i];\\n        }\\n        \\n        long long ans = 0;\\n        while(low <= high){\\n            \\n            long long mid = low + (high-low)/2;\\n            \\n            if(isPossible(batteries, mid, n)){//asking for max minutes => increase the time to check if that\\'s possible\\n                ans = mid;\\n                low = mid+1;\\n            }\\n            else{\\n                 high = mid-1;//if this particular time isn\\'t possible, reduce the range to mid-1\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1692965,
                "title": "python3-greedy",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/210499523d9965e2d9dd5e1a6fbf67931233e41b) for solutions of weekly 276. \\n\\n**Intuition**\\nSort the batteries by ascending order. Let\\'s focus on the last `n` batteries and redefine this subarray as the new batteries. The remaining element can be summed into a number. Here, since a battery can be used freely, it doesn\\'t matter if one has `k` batteries with values `x, y, ...`. Without any loss of generality, one can think of them as a big battery with value `x+y+...`. Now the problems becomes we have `n` batteries for `n` computers with an extra reservoir (say `extra`). \\n\\nThus, we can adopt a greedy stragegy to check batteries progressively \\n1) give all `extra` reservoir to the lowest battery and check if it can last as much as the 2nd lowest battery; if not, return (lowest + `extra`); otherwise, proceed to next step;\\n2) given `extra` reservoir to the lowest and 2nd lowest batteries and check if they can last as much as the 3rd lowest battery; if not, return (lowest + 2nd lowest + `extra`)//2; otherwise, proceed to next step; \\n3) repeat the above step to all batteries; if stopped at `i`, return (lowest + 2nd lowest + ... + `extra`)//(i+1); \\n4) if not stopped, return (sum(batteries) + `extra`)//n. \\n\\n\\n```\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        batteries.sort()\\n        extra = sum(batteries[:-n])\\n        batteries = batteries[-n:]\\n        \\n        ans = prefix = 0 \\n        for i, x in enumerate(batteries): \\n            prefix += x \\n            if i+1 < len(batteries) and batteries[i+1]*(i+1) - prefix > extra: return (prefix + extra) // (i+1)\\n        return (prefix + extra) // n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        batteries.sort()\\n        extra = sum(batteries[:-n])\\n        batteries = batteries[-n:]\\n        \\n        ans = prefix = 0 \\n        for i, x in enumerate(batteries): \\n            prefix += x \\n            if i+1 < len(batteries) and batteries[i+1]*(i+1) - prefix > extra: return (prefix + extra) // (i+1)\\n        return (prefix + extra) // n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821393,
                "title": "video-o-m-log-k-maximizing-computer-run-time-with-binary-search",
                "content": "# Intuition\\nWhen I first read this problem, I realized that it\\'s not just about using each battery to its full capacity before moving on to the next. The goal here is to maximize the running time of all computers, and a simple linear approach would not achieve that. The challenge here lies in striking a balance between using batteries that have the most power and ensuring that no energy is wasted.\\n\\n## Video Explenation & Live Coding\\nhttps://youtu.be/_qFXyY5vBIY\\n\\n# Approach\\nThe approach I took for this problem is to find a balance between using batteries that have the most power and ensuring that no energy is wasted. I employed a binary search strategy to locate the maximum possible running time.\\n\\nInitially, I set 1 as the left boundary and the total power of all batteries divided by \\'n\\' as the right boundary. This is because 1 is the minimum time a computer can run (given the constraints that battery power is at least 1) and `sum(batteries) / n` is the maximum time all computers can run if we could distribute the power of all batteries evenly among the computers.\\n\\nIn the binary search, I set a target running time and checked if we could reach this target with the available batteries. This check is done using the line of code `if sum(min(battery, target) for battery in batteries) >= target * n:`. \\n\\nThe expression `min(battery, target) for battery in batteries` calculates how much of each battery\\'s power we can use to achieve the target running time. If a battery\\'s power is more than the target, we can only use power equal to the target from it. If a battery\\'s power is less than the target, we can use all of its power. The sum of these amounts is the total power we can use to achieve the target running time.\\n\\nIf this total power is greater than or equal to `target * n` (the total power needed to run all `n` computers for `target` time), it means we can achieve the target running time with the available batteries, so I update the left boundary to the target.\\n\\nIf we couldn\\'t achieve the target running time (i.e., the total power is less than `target * n`), I update the right boundary to one less than the target. I continue this process until the left and right boundaries meet, at which point we\\'ve found the maximum possible running time.\\n\\n# Complexity\\n- Time complexity: The time complexity for this problem is \\\\(O(m  log k)\\\\), where \\\\(m\\\\) is the length of the input array batteries and \\\\(k\\\\) is the maximum power of one battery.\\n\\n- Space complexity: The space complexity for this problem is \\\\(O(1)\\\\). During the binary search, we only need to record the boundaries of the searching space and the power extra, and the accumulative sum of extra, which only takes constant space.\\n\\n# Code\\n```Python []\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        left, right = 1, sum(batteries) // n \\n        while left < right: \\n            target = right - (right - left) // 2 \\n            if sum(min(battery, target) for battery in batteries) >= target * n: \\n                left = target \\n            else: \\n                right = target - 1 \\n        return left \\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, std::vector<int>& batteries) {\\n        std::sort(batteries.begin(), batteries.end());\\n        long long left = 1, right = std::accumulate(batteries.begin(), batteries.end(), 0LL) / n;\\n        while (left < right) {\\n            long long target = right - (right - left) / 2;\\n            long long total = std::accumulate(batteries.begin(), batteries.end(), 0LL, [&target](long long a, int b) { return a + std::min(static_cast<long long>(b), target); });\\n            if (total >= target * n) {\\n                left = target;\\n            } else {\\n                right = target - 1;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```\\n``` Java []\\npublic class Solution {\\n    public long maxRunTime(int n, int[] batteries) {\\n        Arrays.sort(batteries);\\n        long left = 1, right = (long)Arrays.stream(batteries).asLongStream().sum() / n;\\n        while (left < right) {\\n            long target = right - (right - left) / 2;\\n            long total = Arrays.stream(batteries).asLongStream().map(battery -> Math.min(battery, target)).sum();\\n            if (total >= target * n) {\\n                left = target;\\n            } else {\\n                right = target - 1;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public long MaxRunTime(int n, int[] batteries) {\\n        Array.Sort(batteries);\\n        long left = 1, right = (long)batteries.Sum(b => (long)b) / n;\\n        while (left < right) {\\n            long target = right - (right - left) / 2;\\n            long total = batteries.Sum(battery => Math.Min((long)battery, target));\\n            if (total >= target * n) {\\n                left = target;\\n            } else {\\n                right = target - 1;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {number} n\\n * @param {number[]} batteries\\n * @return {number}\\n */\\nvar maxRunTime = function(n, batteries) {\\n            batteries.sort((a, b) => a - b);\\n        let left = 1, right = Math.floor(batteries.reduce((a, b) => a + b) / n);\\n        while (left < right) {\\n            let target = right - Math.floor((right - left) / 2);\\n            let total = batteries.reduce((a, b) => a + Math.min(b, target), 0);\\n            if (total >= target * n) {\\n                left = target;\\n            } else {\\n                right = target - 1;\\n            }\\n        }\\n        return left;\\n};\\n```              \\n## Video Python & JavaScript\\n\\nhttps://youtu.be/10BC-5zKrb0   \\nhttps://youtu.be/xnkXF1Yed94   \\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript"
                ],
                "code": "```Python []\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        left, right = 1, sum(batteries) // n \\n        while left < right: \\n            target = right - (right - left) // 2 \\n            if sum(min(battery, target) for battery in batteries) >= target * n: \\n                left = target \\n            else: \\n                right = target - 1 \\n        return left \\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, std::vector<int>& batteries) {\\n        std::sort(batteries.begin(), batteries.end());\\n        long long left = 1, right = std::accumulate(batteries.begin(), batteries.end(), 0LL) / n;\\n        while (left < right) {\\n            long long target = right - (right - left) / 2;\\n            long long total = std::accumulate(batteries.begin(), batteries.end(), 0LL, [&target](long long a, int b) { return a + std::min(static_cast<long long>(b), target); });\\n            if (total >= target * n) {\\n                left = target;\\n            } else {\\n                right = target - 1;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```\n``` Java []\\npublic class Solution {\\n    public long maxRunTime(int n, int[] batteries) {\\n        Arrays.sort(batteries);\\n        long left = 1, right = (long)Arrays.stream(batteries).asLongStream().sum() / n;\\n        while (left < right) {\\n            long target = right - (right - left) / 2;\\n            long total = Arrays.stream(batteries).asLongStream().map(battery -> Math.min(battery, target)).sum();\\n            if (total >= target * n) {\\n                left = target;\\n            } else {\\n                right = target - 1;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public long MaxRunTime(int n, int[] batteries) {\\n        Array.Sort(batteries);\\n        long left = 1, right = (long)batteries.Sum(b => (long)b) / n;\\n        while (left < right) {\\n            long target = right - (right - left) / 2;\\n            long total = batteries.Sum(battery => Math.Min((long)battery, target));\\n            if (total >= target * n) {\\n                left = target;\\n            } else {\\n                right = target - 1;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {number} n\\n * @param {number[]} batteries\\n * @return {number}\\n */\\nvar maxRunTime = function(n, batteries) {\\n            batteries.sort((a, b) => a - b);\\n        let left = 1, right = Math.floor(batteries.reduce((a, b) => a + b) / n);\\n        while (left < right) {\\n            let target = right - Math.floor((right - left) / 2);\\n            let total = batteries.reduce((a, b) => a + Math.min(b, target), 0);\\n            if (total >= target * n) {\\n                left = target;\\n            } else {\\n                right = target - 1;\\n            }\\n        }\\n        return left;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693174,
                "title": "python-short-binary-search-explained",
                "content": "Let us look at the `n` biggest batteries.\\n\\n1. We can deal with the rest of battaries as with one big battery, call it accumulator.\\n2. What we need to do now is binary search: ask question: given `x`, can we survive `x` time. For each batery which is `>= x`, we are OK. For smaller battaries we need to use our accumulator.\\n\\n#### Complexity\\nIt is `O(n log M)` for time and `O(n)` for space.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def maxRunTime(self, n, B):\\n        B = sorted(B)[::-1]\\n        small = sum(B[n:])\\n\\n        beg, end = 0, sum(B) + 1\\n        while beg + 1 < end:\\n            mid = (beg + end)//2\\n            to_do = sum(max(mid - x, 0) for x in B[:n])\\n            if to_do > small:\\n                end = mid\\n            else:\\n                beg = mid\\n     \\n        return beg\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```python\\nclass Solution:\\n    def maxRunTime(self, n, B):\\n        B = sorted(B)[::-1]\\n        small = sum(B[n:])\\n\\n        beg, end = 0, sum(B) + 1\\n        while beg + 1 < end:\\n            mid = (beg + end)//2\\n            to_do = sum(max(mid - x, 0) for x in B[:n])\\n            if to_do > small:\\n                end = mid\\n            else:\\n                beg = mid\\n     \\n        return beg\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821972,
                "title": "c-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->My first thoughts on how to solve this problem would be as follows:\\n\\n1. **Understanding the Problem:** I would carefully read and understand the problem statement to grasp the requirements and constraints. In this case, we are given the number of batteries \\'n\\' and a vector \\'bat\\' containing battery times. The task is to find the maximum run time that can be achieved by selecting \\'n\\' batteries from the given list while trying to optimize the overall run time.\\n\\n2. **Approach to Optimization:** Since we need to optimize the overall run time, one approach could be to select the \\'n\\' batteries with the highest times, as these would likely contribute the most to the overall run time. However, we also need to consider that the total time is distributed among these \\'n\\' batteries, so simply choosing the \\'n\\' largest times may not always be the most optimal.\\n\\n3. **Handling the Bottleneck:** To ensure that we are optimizing the run time, we should identify and handle the bottleneck. The bottleneck is the battery with the longest time, which could limit the overall run time. If we find a battery with a time less than or equal to the average time (total time / n), it means this battery won\\'t be a bottleneck, and we can stop optimizing further.\\n\\n4. **Plan the Algorithm:** Based on the above observations, I would plan an algorithm that involves calculating the total time, sorting the battery times in non-ascending order, and then iterating through the sorted times to handle the bottleneck and optimize the overall run time.\\n\\n5. **Implementing the Solution:** Once the algorithm is planned, I would implement the code in C++ and handle any edge cases or special conditions that might arise.\\n\\n6. **Testing and Optimization:** After writing the code, I would thoroughly test it with various test cases, including edge cases and large inputs, to ensure its correctness and efficiency. If needed, I might perform further optimizations or improvements to the code.\\n\\nBy following these steps, I can develop a working solution to the problem. The initial thoughts guide me in understanding the problem better and finding an appropriate approach to tackle it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->It is a step-by-step explanation of the approach to solving the problem:\\n\\n1. **Calculate Total Time:** First, calculate the total time by summing up all the battery times in the given vector \\'bat\\'. We will use this total time later to calculate the average time.\\n\\n2. **Sort Battery Times:** Sort the battery times in non-ascending order. Sorting in reverse order allows us to efficiently pick the batteries with the longest times first, as they are likely to contribute the most to the overall run time.\\n\\n3. **Optimize Run Time:** Iterate through the sorted battery times and try to optimize the overall run time by removing batteries that could potentially be a bottleneck. To do this, we check if the current battery time is less than or equal to the average time (total time / n). If it is, we can stop further optimization because selecting this battery and the remaining batteries won\\'t exceed the average time, making it the optimal choice.\\n\\n4. **Update Total Time:** As we optimize the run time by removing batteries, we need to update the total time by subtracting the time of the batteries we remove.\\n\\n5. **Calculate Maximum Run Time:** After handling the bottleneck and optimizing the run time, divide the updated total time by the number of remaining batteries \\'n\\' to get the maximum run time achievable with the given number of batteries.\\n\\n6. **Return Result:** Return the calculated maximum run time as the output of the function.\\n\\nBy following this approach, the code can efficiently find the maximum run time with the given number of batteries, optimizing the selection to avoid bottlenecks and distribute the total time among the selected batteries as evenly as possible. The sorting step ensures that we always start with the longest battery times, which is crucial for the optimization process.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Function to calculate the maximum run time for the given number of batteries \\'n\\'\\n    // and the vector \\'bat\\' containing battery times\\n    long long maxRunTime(int n, vector<int>& bat) {\\n        long long total_time = 0; // Variable to store the total time of all batteries\\n        for(auto x : bat) total_time += x; // Calculate the total time by summing all battery times\\n        \\n        sort(bat.rbegin(), bat.rend()); // Sort the battery times in non-ascending order\\n        \\n        // Loop through the sorted battery times and try to optimize the run time\\n        for(int i = 0; i < bat.size(); i++, n--) {\\n            // If the current battery time is less than or equal to the average time (total_time/n),\\n            // then it won\\'t be a bottleneck, so we can stop optimizing further\\n            if(bat[i] <= (total_time / n)) break;\\n            \\n            total_time -= bat[i]; // Reduce the total time by the current battery time\\n        }\\n        \\n        return total_time / n; // Return the optimized maximum run time\\n    }\\n};\\n\\n```\\n![Leetcode.jpeg](https://assets.leetcode.com/users/images/b4422c0b-2b51-4c81-b281-bb6718cfe62f_1690434604.0863066.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Function to calculate the maximum run time for the given number of batteries \\'n\\'\\n    // and the vector \\'bat\\' containing battery times\\n    long long maxRunTime(int n, vector<int>& bat) {\\n        long long total_time = 0; // Variable to store the total time of all batteries\\n        for(auto x : bat) total_time += x; // Calculate the total time by summing all battery times\\n        \\n        sort(bat.rbegin(), bat.rend()); // Sort the battery times in non-ascending order\\n        \\n        // Loop through the sorted battery times and try to optimize the run time\\n        for(int i = 0; i < bat.size(); i++, n--) {\\n            // If the current battery time is less than or equal to the average time (total_time/n),\\n            // then it won\\'t be a bottleneck, so we can stop optimizing further\\n            if(bat[i] <= (total_time / n)) break;\\n            \\n            total_time -= bat[i]; // Reduce the total time by the current battery time\\n        }\\n        \\n        return total_time / n; // Return the optimized maximum run time\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1692949,
                "title": "easy-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    bool fun(vector<int>& a, long long x, long long k){\\n        long long val = x*k;\\n        for(int i=0; i<a.size(); i++){\\n            val -= min((long long)a[i],k);\\n        }\\n        return val <= 0;\\n    }\\n    long long maxRunTime(int n, vector<int>& a) {\\n        long long sum = 0;\\n        for(auto i : a){\\n            sum += i;\\n        }\\n        long long ans = 0;\\n        long long l = 0, r = sum;\\n        while(l <= r){\\n            long long mid = l + (r-l)/2;\\n            if(fun(a,n,mid)){\\n                ans = mid;\\n                l = mid + 1;\\n            }\\n            else{\\n                r = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool fun(vector<int>& a, long long x, long long k){\\n        long long val = x*k;\\n        for(int i=0; i<a.size(); i++){\\n            val -= min((long long)a[i],k);\\n        }\\n        return val <= 0;\\n    }\\n    long long maxRunTime(int n, vector<int>& a) {\\n        long long sum = 0;\\n        for(auto i : a){\\n            sum += i;\\n        }\\n        long long ans = 0;\\n        long long l = 0, r = sum;\\n        while(l <= r){\\n            long long mid = l + (r-l)/2;\\n            if(fun(a,n,mid)){\\n                ans = mid;\\n                l = mid + 1;\\n            }\\n            else{\\n                r = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821869,
                "title": "python-6-lines-of-code-easy-to-understand-hard-problem-maximum-running-time-of-n-computers",
                "content": "# Python | 6 Lines of Code | Easy to Understand | Hard Problem | 2141. Maximum Running Time of N Computers\\n```\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        batteries.sort()\\n        total = sum(batteries)\\n        while batteries[-1] > total//n:\\n            n -= 1\\n            total -= batteries.pop()\\n        return total//n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        batteries.sort()\\n        total = sum(batteries)\\n        while batteries[-1] > total//n:\\n            n -= 1\\n            total -= batteries.pop()\\n        return total//n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821752,
                "title": "beats-100-video-java-c-python",
                "content": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/6RCiXmSpfys\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\npublic class Solution {\\n    public long maxRunTime(int n, int[] batteries) {\\n        long sumPower = 0;\\n        for (int power : batteries)\\n            sumPower += power;\\n        long left = 1, right = sumPower / n;\\n        \\n        while (left < right){\\n            long time = (left+right+1) / 2;\\n            if (check(batteries, n, time))\\n                left = time;\\n            else\\n                right = time - 1;\\n        }\\n        return left;\\n    }\\n    \\n    public boolean check(int [] B, int n, long time){\\n        long sum = 0;\\n        for(int battery: B){\\n            sum+=Math.min(battery, time);\\n        }\\n        return (sum>=(long)time*n);\\n    }\\n}\\n```\\n```\\nclass Solution {\\npublic:\\n    long maxRunTime(int n, vector<int>& batteries) {\\n        long sumPower = 0;\\n        for (int power : batteries)\\n            sumPower += power;\\n        long left = 1, right = sumPower / n;\\n        \\n        while (left < right) {\\n            long time = (left + right + 1) / 2;\\n            if (check(batteries, n, time))\\n                left = time;\\n            else\\n                right = time - 1;\\n        }\\n        return left;\\n    }\\n    \\n    bool check(vector<int>& B, int n, long time) {\\n        long sum = 0;\\n        for (int battery : B) {\\n            sum += min(static_cast<long>(battery), time);\\n        }\\n        return (sum >= static_cast<long>(time) * n);\\n    }\\n};\\n\\n```\\n\\n```\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        sumPower = sum(batteries)\\n        left, right = 1, sumPower // n\\n        \\n        while left < right:\\n            time = (left + right + 1) // 2\\n            if self.check(batteries, n, time):\\n                left = time\\n            else:\\n                right = time - 1\\n        return left\\n    \\n    def check(self, B: List[int], n: int, time: int) -> bool:\\n        total_power = sum(min(battery, time) for battery in B)\\n        return total_power >= time * n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\npublic class Solution {\\n    public long maxRunTime(int n, int[] batteries) {\\n        long sumPower = 0;\\n        for (int power : batteries)\\n            sumPower += power;\\n        long left = 1, right = sumPower / n;\\n        \\n        while (left < right){\\n            long time = (left+right+1) / 2;\\n            if (check(batteries, n, time))\\n                left = time;\\n            else\\n                right = time - 1;\\n        }\\n        return left;\\n    }\\n    \\n    public boolean check(int [] B, int n, long time){\\n        long sum = 0;\\n        for(int battery: B){\\n            sum+=Math.min(battery, time);\\n        }\\n        return (sum>=(long)time*n);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    long maxRunTime(int n, vector<int>& batteries) {\\n        long sumPower = 0;\\n        for (int power : batteries)\\n            sumPower += power;\\n        long left = 1, right = sumPower / n;\\n        \\n        while (left < right) {\\n            long time = (left + right + 1) / 2;\\n            if (check(batteries, n, time))\\n                left = time;\\n            else\\n                right = time - 1;\\n        }\\n        return left;\\n    }\\n    \\n    bool check(vector<int>& B, int n, long time) {\\n        long sum = 0;\\n        for (int battery : B) {\\n            sum += min(static_cast<long>(battery), time);\\n        }\\n        return (sum >= static_cast<long>(time) * n);\\n    }\\n};\\n\\n```\n```\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        sumPower = sum(batteries)\\n        left, right = 1, sumPower // n\\n        \\n        while left < right:\\n            time = (left + right + 1) // 2\\n            if self.check(batteries, n, time):\\n                left = time\\n            else:\\n                right = time - 1\\n        return left\\n    \\n    def check(self, B: List[int], n: int, time: int) -> bool:\\n        total_power = sum(min(battery, time) for battery in B)\\n        return total_power >= time * n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821542,
                "title": "c-o-nlog-range-binary-search-over-range",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**Approach:**\\n* we will check is it possible to sustain n computers for \\'hrs\\' amount of time for given configuration of batteries.\\n* \\'hrs\\' for which we can run current configuration of batteries will depend on battery which runs for least amount of time.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    #define ll long long\\n    \\n    bool possible(int n, vector<int> &bat, ll int hrs){\\n        ll int time=0;\\n        for(int i=0;i<bat.size();i++){\\n            time += bat[i];\\n            if(time>=hrs){\\n                time-=hrs; // passing on extra time provided by battery to run other computer\\n                n--;\\n            }\\n            if(n==0) return true;\\n        }\\n        return false;\\n    }\\n    \\n    long long maxRunTime(int n, vector<int> &bat) {\\n        ll int l=1, r=0;\\n        \\n        for(int i=0;i<bat.size();i++) r += bat[i];\\n        r/=n;\\n        \\n        // max. time for which we can run current set of batteries will depend on battery with least operational time \\n        sort(bat.begin(),bat.end());\\n        while(l<r){\\n            ll int m=l+(r-l+1)/2;\\n            \\n            if(possible(n,bat,m)){\\n                l=m;\\n            }else{\\n                r=m-1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```\\n\\n**Do upvote if it helps :)**",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    #define ll long long\\n    \\n    bool possible(int n, vector<int> &bat, ll int hrs){\\n        ll int time=0;\\n        for(int i=0;i<bat.size();i++){\\n            time += bat[i];\\n            if(time>=hrs){\\n                time-=hrs; // passing on extra time provided by battery to run other computer\\n                n--;\\n            }\\n            if(n==0) return true;\\n        }\\n        return false;\\n    }\\n    \\n    long long maxRunTime(int n, vector<int> &bat) {\\n        ll int l=1, r=0;\\n        \\n        for(int i=0;i<bat.size();i++) r += bat[i];\\n        r/=n;\\n        \\n        // max. time for which we can run current set of batteries will depend on battery with least operational time \\n        sort(bat.begin(),bat.end());\\n        while(l<r){\\n            ll int m=l+(r-l+1)/2;\\n            \\n            if(possible(n,bat,m)){\\n                l=m;\\n            }else{\\n                r=m-1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823261,
                "title": "ex-amazon-explains-a-solution-with-a-video-python-javascript-java-and-c",
                "content": "# Intuition\\nUse the n leargest batteries for computers at first and keep the rest batteries as extra.\\n\\nThis Python solution beats 91%.\\n\\n![Screen Shot 2023-07-27 at 23.59.24.png](https://assets.leetcode.com/users/images/3233db8d-34ee-4b6b-9831-019bd0271d84_1690470004.0124362.png)\\n\\n\\n---\\n\\n# Solution Video\\n## *** Please upvote for this article. *** \\n\\nhttps://youtu.be/Sqyv6U1Oz1w\\n\\n# Subscribe to my channel from here. I have 232 videos as of July 27th\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\n---\\n\\n# Approach\\nThis is based on Python code. Other language might be differnt a bit.\\n\\n1. Sort the `batteries` list in ascending order. This step rearranges the elements of the list to ensure that the batteries with the least power are at the beginning of the list, and the batteries with the most power are at the end.\\n\\n2. Create a new list called `charging`, which contains the `n` largest batteries from the sorted `batteries` list. These are the batteries that will be used to power the `n` computers simultaneously.\\n\\n3. Calculate the `total_extra` variable, which represents the sum of all the extra power available from batteries that are not used to power the `n` computers with the largest batteries. This is achieved by summing the power of all batteries except the last `n` batteries in the sorted list.\\n\\n4. Iterate through the `charging` list (except the last element) using the variable `i`. For each iteration, perform the following checks:\\n\\n   a. Calculate `required_power` as `(i + 1) * (charging[i + 1] - charging[i])`. This represents the amount of extra power required to increase the running time of the computer with the smallest battery (`charging[i]`) to the running time of the next computer with the larger battery (`charging[i + 1]`).\\n\\n   b. Compare `total_extra // (i + 1)` with `required_power`. If the available extra power per computer (calculated by `total_extra // (i + 1)`) is less than the required power to increase the running time, it means that we don\\'t have enough extra power to reach the next battery\\'s running time. In this case, return the running time of the current computer (`charging[i]`) plus the maximum amount of extra power that can be used per computer (`total_extra // (i + 1)`). This ensures that we increase the running time of the computer with the smallest battery as much as possible before moving to the next battery.\\n\\n   c. If there\\'s enough extra power to reach the next battery\\'s running time, update the `total_extra` by subtracting the total power used to increase the running time of the current computer with the smallest battery. This is done by `total_extra -= (i + 1) * (charging[i + 1] - charging[i])`.\\n\\n5. If the loop finishes without returning from step 4, it means that there is still some extra power remaining (`total_extra`). In this case, distribute this remaining extra power evenly among all the `n` computers and return the running time of the last computer with the largest battery (`charging[-1]`) plus the maximum amount of extra power that can be evenly distributed among all the computers (`total_extra // n`).\\n\\nThis algorithm ensures that the running time is maximized while considering the limitations of battery usage for each computer.\\n\\n# Complexity\\nThis is based on Python code. Other might be different a bit.\\n\\n- Time complexity: O(k log k)\\nWe use sort for batteries.\\n\\n- Space complexity: O(k)\\nIt depends on a programming language you use. In Python, we need linear space to sort.\\n\\n```python []\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        batteries.sort()\\n        charging = batteries[-n:]\\n        total_extra = sum(batteries[:-n])\\n\\n        for i in range(n-1):\\n            if total_extra // (i + 1) < charging[i+1] - charging[i]:\\n                return charging[i] + total_extra // (i + 1)\\n            \\n            total_extra -= (charging[i+1] - charging[i]) * (i + 1)\\n        \\n        return charging[-1] + total_extra // n\\n```\\n```javascript []\\n/**\\n * @param {number} n\\n * @param {number[]} batteries\\n * @return {number}\\n */\\nvar maxRunTime = function(n, batteries) {\\n    batteries.sort((a, b) => a - b);\\n    const charging = batteries.slice(-n);\\n    let total_extra = batteries.slice(0, -n).reduce((acc, val) => acc + val, 0);\\n    \\n    for (let i = 0; i < n - 1; i++) {\\n        if (total_extra / (i + 1) < charging[i + 1] - charging[i]) {\\n            return charging[i] + Math.floor(total_extra / (i + 1));\\n        }\\n      \\n        total_extra -= (i + 1) * (charging[i + 1] - charging[i]);\\n    }\\n    \\n    return charging[charging.length - 1] + Math.floor(total_extra / n);    \\n};\\n```\\n```java []\\nclass Solution {\\n    public long maxRunTime(int n, int[] batteries) {\\n        Arrays.sort(batteries);\\n        int[] charging = Arrays.copyOfRange(batteries, batteries.length - n, batteries.length);\\n\\n        long total_extra = 0;\\n        for (int i = 0; i < batteries.length - n; i++) {\\n            total_extra += batteries[i];\\n        }        \\n        \\n        for (int i = 0; i < n - 1; i++) {\\n            if (total_extra < (long)(i + 1) * (charging[i + 1] - charging[i])) {\\n                return charging[i] + total_extra / (long)(i + 1);\\n            }\\n\\n            total_extra -= (long)(i + 1) * (charging[i + 1] - charging[i]);\\n        }\\n\\n        return charging[n - 1] + total_extra / n;        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        std::sort(batteries.begin(), batteries.end());\\n        std::vector<int> charging(batteries.begin() + batteries.size() - n, batteries.end());\\n        long total_extra = 0;\\n        \\n        for (int i = 0; i < batteries.size() - n; i++) {\\n            total_extra += batteries[i];\\n        }\\n        \\n        for (int i = 0; i < n - 1; i++) {\\n            if (total_extra / (i + 1) < charging[i + 1] - charging[i]) {\\n                return charging[i] + total_extra / (i + 1);\\n            }\\n            \\n            total_extra -= (i + 1) * (charging[i + 1] - charging[i]);\\n        }\\n        \\n        return charging.back() + total_extra / n;        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        batteries.sort()\\n        charging = batteries[-n:]\\n        total_extra = sum(batteries[:-n])\\n\\n        for i in range(n-1):\\n            if total_extra // (i + 1) < charging[i+1] - charging[i]:\\n                return charging[i] + total_extra // (i + 1)\\n            \\n            total_extra -= (charging[i+1] - charging[i]) * (i + 1)\\n        \\n        return charging[-1] + total_extra // n\\n```\n```javascript []\\n/**\\n * @param {number} n\\n * @param {number[]} batteries\\n * @return {number}\\n */\\nvar maxRunTime = function(n, batteries) {\\n    batteries.sort((a, b) => a - b);\\n    const charging = batteries.slice(-n);\\n    let total_extra = batteries.slice(0, -n).reduce((acc, val) => acc + val, 0);\\n    \\n    for (let i = 0; i < n - 1; i++) {\\n        if (total_extra / (i + 1) < charging[i + 1] - charging[i]) {\\n            return charging[i] + Math.floor(total_extra / (i + 1));\\n        }\\n      \\n        total_extra -= (i + 1) * (charging[i + 1] - charging[i]);\\n    }\\n    \\n    return charging[charging.length - 1] + Math.floor(total_extra / n);    \\n};\\n```\n```java []\\nclass Solution {\\n    public long maxRunTime(int n, int[] batteries) {\\n        Arrays.sort(batteries);\\n        int[] charging = Arrays.copyOfRange(batteries, batteries.length - n, batteries.length);\\n\\n        long total_extra = 0;\\n        for (int i = 0; i < batteries.length - n; i++) {\\n            total_extra += batteries[i];\\n        }        \\n        \\n        for (int i = 0; i < n - 1; i++) {\\n            if (total_extra < (long)(i + 1) * (charging[i + 1] - charging[i])) {\\n                return charging[i] + total_extra / (long)(i + 1);\\n            }\\n\\n            total_extra -= (long)(i + 1) * (charging[i + 1] - charging[i]);\\n        }\\n\\n        return charging[n - 1] + total_extra / n;        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        std::sort(batteries.begin(), batteries.end());\\n        std::vector<int> charging(batteries.begin() + batteries.size() - n, batteries.end());\\n        long total_extra = 0;\\n        \\n        for (int i = 0; i < batteries.size() - n; i++) {\\n            total_extra += batteries[i];\\n        }\\n        \\n        for (int i = 0; i < n - 1; i++) {\\n            if (total_extra / (i + 1) < charging[i + 1] - charging[i]) {\\n                return charging[i] + total_extra / (i + 1);\\n            }\\n            \\n            total_extra -= (i + 1) * (charging[i + 1] - charging[i]);\\n        }\\n        \\n        return charging.back() + total_extra / n;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822332,
                "title": "binary-search-on-answer-proper-explanation-of-ispossible-function",
                "content": "# Intuition\\nBInary search on answer as we are trying all range of time that can give answer.\\n\\n# Approach\\n- The prime problem of this question is to check whether the time is sufficient to run all computers simultaneously.\\n- for this the simple logic is that the battery time which is greater than or equal to the time(mid) we are checking we will assign computer to them for eg battery time=7, time(mid)=5 we can assign 1 computer to it directly and check for other batteries.\\n- The battery time less than time(mid), we will find average of these batteries and if average(total left battery time/no of computers left) is greater than or equal to time(mid) we can collectively assign these batteries to the remaining computers.\\n- batteries[]=[2,4,4,5,7]\\ncomputers=4;\\ncheckTime(mid)=5;\\nfor 5 and 7 battery time i.e. greater then 5(mid) so we will assign two computers, computers left=2.\\nthe average of batteries left=10/2=5 i.e equal to checkTime(mid).\\nso this time can be a answer and save it and go find other maximum answer on the right.\\n- Range-->[1,1e14]\\n1e14 because 1 computer can use 1e5 batteres with each battery minutes 1e9 so total 1e5*1e9=1e14.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int n,vector<int>&batteries,long long mid)\\n    {\\n        //here average is taken such that the battery time greater than time is added as equal to time. So that it does not contribute to average.\\n        long long time=0;\\n        for(int i=0;i<batteries.size();++i)\\n        {\\n            if(batteries[i]<mid)\\n            {\\n                time+=batteries[i];\\n            }\\n            else\\n            {\\n                time+=mid;\\n            }\\n        }\\n        return ((time/n)>=mid);\\n    }\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        long long l=1;\\n        long long h=1e14;\\n        long long ans=0;\\n        while(l<=h)\\n        {\\n            long long mid=l+((h-l)>>1);\\n            if(isPossible(n,batteries,mid))\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                h=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int n,vector<int>&batteries,long long mid)\\n    {\\n        //here average is taken such that the battery time greater than time is added as equal to time. So that it does not contribute to average.\\n        long long time=0;\\n        for(int i=0;i<batteries.size();++i)\\n        {\\n            if(batteries[i]<mid)\\n            {\\n                time+=batteries[i];\\n            }\\n            else\\n            {\\n                time+=mid;\\n            }\\n        }\\n        return ((time/n)>=mid);\\n    }\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        long long l=1;\\n        long long h=1e14;\\n        long long ans=0;\\n        while(l<=h)\\n        {\\n            long long mid=l+((h-l)>>1);\\n            if(isPossible(n,batteries,mid))\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                h=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693830,
                "title": "c-sorting-solution-o-n-logn-intuition",
                "content": "The way I build up my solution is as follows:\\n\\n(`N` is the number of batteries, `C` is the number of computers, `battery` is sorted in non-increasing order and I have followed 1-based indexing).\\n\\nFirst notice that if there were only `C` batteries, our answer would be nothing but the minimum of all values (it\\'s nothing but `battery[C]`). \\n\\nNow assume that I have another battery whose `capacity <= battery[C]` (meaning there exists `battery[C+1]`)\\n\\nNow, can we do anything with `battery[C+1]` to improve upon our current answer which is `battery[C]`?\\n\\nYes, we can use `battery[C+1]` as a filler and try to fill up `battery[C]` until it becomes equal to `battery[C-1]`. If there is still some part of this filler remaining, then we will increment both `battery[C]` and `battery[C-1]` simultaneouly, until it becomes equal to `battery[C-2]`. \\n\\nThis step we can keep on performing until either `battery[C+1]` ends or all the batteries from `1 to C` becomes equal up. If all the batteries becomes equal and still `battery[C+1]` isn\\'t exhausted, then we can use it equally among all `C` computers.\\n\\nNow notice that the same argument can be extended for `battery[C+2], ... battery[N]`. So all these values can be used as filler and then we can try to level up the minimum value.\\n\\nI hope I was able to provide an intuition for how this solution works.\\n\\nHere\\'s my accepted solution:\\n(Note: I have used `a` insted of `batteries` and 0-based indexing in the solution)\\n\\n```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int c, vector<int>& a) {\\n        int n = a.size();\\n        sort(a.rbegin(), a.rend());\\n        long long filler = 0;\\n        for(int i=c;i<n;i++) {\\n            filler += a[i];\\n        }\\n        long long ans = 0;\\n        for(int i=c-1;i-1>=0;i--) {\\n            long long diff = a[i-1]-a[i];\\n            long long req = diff * 1ll * (c - i);\\n            if(filler >= req) {\\n                filler -= req;\\n                ans = a[i-1];\\n            }\\n            else {\\n                ans = a[i] + (filler / (c - i));\\n                return ans;\\n            }\\n        }\\n        ans = a[0] + (filler / c);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int c, vector<int>& a) {\\n        int n = a.size();\\n        sort(a.rbegin(), a.rend());\\n        long long filler = 0;\\n        for(int i=c;i<n;i++) {\\n            filler += a[i];\\n        }\\n        long long ans = 0;\\n        for(int i=c-1;i-1>=0;i--) {\\n            long long diff = a[i-1]-a[i];\\n            long long req = diff * 1ll * (c - i);\\n            if(filler >= req) {\\n                filler -= req;\\n                ans = a[i-1];\\n            }\\n            else {\\n                ans = a[i] + (filler / (c - i));\\n                return ans;\\n            }\\n        }\\n        ans = a[0] + (filler / c);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2879480,
                "title": "python-binary-search-on-answer-explained",
                "content": "This is a problem where we have to \"Maximize\" some value. Here, we are asked to Maximize the Running Time of \"n\" computers. How can we use Binary Search in this case? For that, we have to first figure out the monotonicity.\\n\\nIf we can run \"n\" computers simultaneously for \"x\" minutes, then it makes sense that we can also run them simultaneously for any value than is less than \"x\", right?\\n\\nSimilarly, if we cannot run \"n\" computers simultaneously for \"x\" minutes, then it makes sense that no value greater than \"x\" can be valid. \\n\\nAnd that\\'s the monotonicity we are looking for. In this case, we can use Binary Search. More specifically, we have to apply Binary Search on the range of values that we think can be the possible \"Running time\" values. \\n\\nThe lower bound of this range can be 0 or 1. That is, suppose there is only one computer and only one battery with 1 minute of charge. In that case, we can run this computer for 1 minute only.\\n\\nSimilarly, what can be the maximum running time? That\\'s what we have to find. But we can take the sum to be the upper bound. \\n\\nEven better is to take  (sum of all the minutes / n) as the upper bound (Thanks to the Leetcode\\'s Discuss Tab)\\n\\nAnd now, we have this range [1, sum(batteries)/n] in which we know the answer will be found. On this range, we will apply Binary Search and for each \"mid\" value, we have to consider this value as the \"Running Time\". So, we have to then find if we can run \"n\" computers for \"mid\" minutes simultaneously. For that, we have a separate helper method \"isValid\".\\n\\nThis is the most tricky part in this problem - To Write the helper method which checks if we can run \"n\" computers simultaneouly for \"x\" minutes.\\n\\nTo understand how we can check, let\\'s take an example.\\n\\n\\tbatteries = [2,3,2,1,7,8,2,4]\\n\\tn = 4\\n\\tx = 5\\n\\t\\n\\tSo, we want to check if we can run 4 computers simultaneously for 5 minutes.\\n\\t\\n\\tNow, think about how can we use the batteries. \\n\\t\\n\\t___________________________________________________________________\\n\\t\\n\\tLet\\'s first take the bigger batteries. Since we want computer1 to run for \"5\" minutes\\n\\tWe simply attach the battery[5] with \"8\" minutes of charge to it. \\n\\tDo note that we only need \"5\" minutes from this battery. \\n\\t\\n\\t___________________________________________________________________\\n\\t\\n\\tFor computer2, we do the same. We attach it to the battery[4] with \"7\" minutes of charge\\n\\t\\n\\t___________________________________________________________________\\n\\t\\n\\tNow, we are at computer3. We need \"5\" minutes so for this one, we can use \\n\\tbatteries[0] and batteries[1] which in total give us 2 + 3 => 5 minutes\\n\\t\\n\\t___________________________________________________________________\\n\\t\\n\\tFinally, we have computer4. For this one, we can use batteries[2], batteries[3] and batteries[6]\\n\\tgiving us 2 + 1 + 2 => 5 minutes\\n\\t\\n\\tSo, yes, we can run 4 computers simultaenously for \"5\" minutes. \\n\\t\\n\\tBut is it the maximum running time? That\\'s what we have to find.\\n\\t\\n\\t\\nDid you notice something? If the battery has less than \"x\" minutes, then we will use it fully. On the other hand, if a battery has >= x minutes of charge, then we will only use at most \"x\" minutes out of it. We saw this in case of computer1 where we had \"8\" minutes of charge but we needed only \"5\" minutes so we only took 5 minutes. And that\\'s the whole idea of the helper method.\\n\\nWe want to find what will be the total running time if we have to run a computer for \"x\" minutes. We will keep adding the minutes to this runningTime, depending on whether battery has less than \"x\" minutes of charge or >= x minutes of charge.\\n\\nAnd once we get the runningTime, since we have the running time for one computer as \"x\", we can easily find how many computer can we run by doing \"runningTime / x\". We want this value to be at least \"n\". That is, we should be able to run at least \"n\" computers.\\n\\n\\n```\\nclass Solution:\\n    \\n    # Helper method to find if we can run \"n\" computers simultaneously for \"x\" minutes\\n    def isValid(self, x, n, batteries):\\n        runningTime = 0\\n        \\n        for minute in batteries:\\n            \\n            # If a battery has at least \"x\" minutes of charge \\n            # Then we use only \"x\" minutes from it\\n            # Otherwise, we use that battery fully\\n            runningTime += min(minute, x)\\n        \\n        # How many computers can we run with this running time?\\n        computers = runningTime / x\\n        \\n        # If number of computers we can run is at least \"n\" then it means \"x\" is valid\\n        return computers >= n\\n        \\n    \\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        # We have to find the Maximum Running time\\n        \\n        # What can be the lower bound of Running time?\\n        # What is there is only one computer and only one battery with 1 minute of charge\\n        # In that case, we can only run the computer for 1 minute\\n        start = 1\\n        \\n        # What can be the upper bound?\\n        end = sum(batteries) // n\\n        \\n        maxTime = 1\\n        \\n        # And now, in this range, we have to find the maximum running time\\n        # We can use Binary Search here because not only this range is in sorted order\\n        # But there is also monotonicity\\n        \\n        # If we can run \"n\" computers for \"x\" minutes simultaneously\\n        # Then ofcourse, we can also run them for less than \"x\" miniutes simultaneously\\n        \\n        # Similarly, If we can not run \"n\" computers for \"x\" minutes simultaneously\\n        # No value more than \"x\" can be valid\\n        \\n        while start <= end:\\n            mid = start + (end - start) // 2\\n            \\n            if self.isValid(mid, n, batteries):\\n                maxTime = mid\\n                start = mid + 1\\n            else: end = mid - 1\\n\\n        return maxTime\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    \\n    # Helper method to find if we can run \"n\" computers simultaneously for \"x\" minutes\\n    def isValid(self, x, n, batteries):\\n        runningTime = 0\\n        \\n        for minute in batteries:\\n            \\n            # If a battery has at least \"x\" minutes of charge \\n            # Then we use only \"x\" minutes from it\\n            # Otherwise, we use that battery fully\\n            runningTime += min(minute, x)\\n        \\n        # How many computers can we run with this running time?\\n        computers = runningTime / x\\n        \\n        # If number of computers we can run is at least \"n\" then it means \"x\" is valid\\n        return computers >= n\\n        \\n    \\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        # We have to find the Maximum Running time\\n        \\n        # What can be the lower bound of Running time?\\n        # What is there is only one computer and only one battery with 1 minute of charge\\n        # In that case, we can only run the computer for 1 minute\\n        start = 1\\n        \\n        # What can be the upper bound?\\n        end = sum(batteries) // n\\n        \\n        maxTime = 1\\n        \\n        # And now, in this range, we have to find the maximum running time\\n        # We can use Binary Search here because not only this range is in sorted order\\n        # But there is also monotonicity\\n        \\n        # If we can run \"n\" computers for \"x\" minutes simultaneously\\n        # Then ofcourse, we can also run them for less than \"x\" miniutes simultaneously\\n        \\n        # Similarly, If we can not run \"n\" computers for \"x\" minutes simultaneously\\n        # No value more than \"x\" can be valid\\n        \\n        while start <= end:\\n            mid = start + (end - start) // 2\\n            \\n            if self.isValid(mid, n, batteries):\\n                maxTime = mid\\n                start = mid + 1\\n            else: end = mid - 1\\n\\n        return maxTime\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824302,
                "title": "simple-solution-explained-in-detail-with-examples-time-n-logk",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nPLEASE BEAR WITH ME AND READ EVERY LINE VERY CAREFULLY...I will be answering all these questions in detail\\n\\n**1) How do we get to know in such questions, that we need to apply binary search**\\n\\n**2) How to make the function, which will help in moving the start and end point (YOU WILL UNDERSTAND THIS LATER...JUST REMAIN CALM)**\\n\\n# **ANSWER 1)**\\n\\nNow, in the question , they asked **you to give the minutes**.. that every computer should run\\n\\nNow, your computer can run for **1 min, 2min , 3min , 4min**...It can run for **infinite minutes**\\n\\nSo you will think , let us try running our computer **for every minute possible** and then get the max time, but but but....\\n\\nThis is a **linear traversal and liner traversal will give you Tle and a lot of disappointnemnt**\\n\\nNow, The other traversal, which is possible is **binary search..**\\n\\nBUT BUT BUT..We apply binary search over a **sorted thing..**\\n\\nNow, if you see the range of your time, it **goes from 1 to infinite time**, \\n\\nThis is a sorted thing only, so we can apply binary search..\\n\\n**Our start time will be 1**\\n**The max time is infinite**...but the question is can we bring this max time a little lower....\\n\\n**I will ask you a simple question, you have a battery at your home which has a power of 9 and you have 2 computers...**\\n\\nNow, for how much time the 2 computers run, it is simple => **you will do a 9/2=>4.5 hrs**\\n\\nSO, in the same way, \\n\\nIf the batteries are [3,5,6,7] and you have 3 computers so for maximum it can run till **(3+5+6+7)/3 =>7 hours**, which could be a possible answer but we know that beyond this it can\\'t go\\n\\nSo, rather then saying infinite as the limit , we know the max will be **(sum of battery array)/n**..\\n\\n**Currently our codes look like this....**\\n```\\n\\n        long long int sum = 0;\\n        long long int ans  = 0;\\n        for(int i=0; i<batteries.size(); i++)\\n        {\\n            sum+=batteries[i];\\n        }\\n\\n        long long int end = sum/(long long)n;\\n\\n        long long int start = 1;\\n\\n        while(start<=end)\\n        {\\n\\n            long long int mid = start + (end-start)/2;\\n            DO SOMETHING SOMETHING\\n        }\\n```\\n# **ANSWER 2)**\\n\\nNow, Let us take the example of battery = [3,5,6,7] and n = 3\\n\\nNow our start = 1 and end  =7\\n\\nIn the first iteration,\\n\\nmid = 4 \\n\\n**This mid reflects the maximum time the computer run simultaneoulsy**\\n\\nNow, we need to check, whether all our computers can  run simultaneoulsy or not...\\n\\nLet us see the array,The array had [3,5,6,7] , \\n\\nNow, Let me ask you simple questions...\\n\\n**For battery 7, if we plug this once in a computer,do we need to remove it** , \\n\\nThe ans is no...because we know the mid = 4(**which is the max time for running a computer**)..Once the time crosses 4, **we don\\'t care only**..**we wanted to run for 4 minutes**..**we ran it for 4 minutes**...\\n\\nFor battery 6, if we plug this once in computer...do we need to remove it..the ans is no..we wanted to run for 4 minutes, we ran for 4 minutes..\\n\\n**For battery no 5, if we plug this in computer..do we need to remove..the ans is no..**\\n\\nFor battery no 3, if we plug this in computer...do we need to remove it...**The ans is yes**..we know that the max time is 4, This battery will get drained in 3 minutes, so we will remove this...**so we can run this for only 3 minutes...**\\n\\nNow..Tell me the total time our batteries ran \\n**Battery 7 ran 4 min**\\n**Battery 6 ran 4 min**\\n**Battery 5 ran 4 min**\\n**Battery 3 ran 3 min**\\n\\nTotal time = **4+4+4+3=>15**\\n\\nNow the systems we had were 3, so total time for each system comes **(15/3) =>5 , and the max time was 4,** \\n\\n5 >= 4, It means we can run our systems **for 5 mins also**, so we need to to increase our time and to increase our time, It is simple , we will just do..\\n\\n**start = mid+1**\\n\\nIF by chance it would have come less, then we need to decrease our time, **so we need to go to the left**.....SIMPLEEEEE\\n\\n**end = mid-1**\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nLet us say (sum of battery array/n) =>k\\n\\nSO, from 1 to k we are doing binary search and for every element, we are iterating the battery array of size n , so\\n\\n**(LOG K) * N**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nNo extra space taken so **O(1)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n    bool check(long long int mid,vector<int>& batteries,int n)\\n    {\\n\\n        long long int time = 0;\\n\\n        for(int i=0; i<batteries.size(); i++)\\n        {\\n\\n            if(batteries[i]>mid)\\n            {\\n                time+=mid;\\n            }\\n            else\\n            {\\n                time+=batteries[i];\\n            }\\n\\n        }\\n\\n        int z = time/mid;\\n        if(z>=n)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n\\n    }\\n\\n\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        \\n\\n        long long int sum = 0;\\n        long long int ans  = 0;\\n        for(int i=0; i<batteries.size(); i++)\\n        {\\n            sum+=batteries[i];\\n        }\\n\\n        long long int end = sum/(long long)n;\\n\\n        long long int start = 1;\\n\\n        while(start<=end)\\n        {\\n\\n            long long int mid = start + (end-start)/2;\\n\\n            if(check(mid,batteries,n)==true)\\n            {\\n                ans = mid;\\n                start = mid+1;\\n            }\\n            else\\n            {\\n                end  = mid-1;\\n            }\\n        }\\n        \\n    return ans;\\n\\n    }\\n};\\n```\\n\\n**TIME FOR A MEME NOW**\\n\\n![WhatsApp Image 2023-07-27 at 20.16.31.jpeg](https://assets.leetcode.com/users/images/b0f50c74-01ab-4654-a4ab-44abd7c0e750_1690469225.501923.jpeg)\\n\\n# **IF YOU LIKE MY SOLUTION , PLEASE UPVOTE...**",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n\\n        long long int sum = 0;\\n        long long int ans  = 0;\\n        for(int i=0; i<batteries.size(); i++)\\n        {\\n            sum+=batteries[i];\\n        }\\n\\n        long long int end = sum/(long long)n;\\n\\n        long long int start = 1;\\n\\n        while(start<=end)\\n        {\\n\\n            long long int mid = start + (end-start)/2;\\n            DO SOMETHING SOMETHING\\n        }\\n```\n```\\nclass Solution {\\npublic:\\n\\n\\n    bool check(long long int mid,vector<int>& batteries,int n)\\n    {\\n\\n        long long int time = 0;\\n\\n        for(int i=0; i<batteries.size(); i++)\\n        {\\n\\n            if(batteries[i]>mid)\\n            {\\n                time+=mid;\\n            }\\n            else\\n            {\\n                time+=batteries[i];\\n            }\\n\\n        }\\n\\n        int z = time/mid;\\n        if(z>=n)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n\\n    }\\n\\n\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        \\n\\n        long long int sum = 0;\\n        long long int ans  = 0;\\n        for(int i=0; i<batteries.size(); i++)\\n        {\\n            sum+=batteries[i];\\n        }\\n\\n        long long int end = sum/(long long)n;\\n\\n        long long int start = 1;\\n\\n        while(start<=end)\\n        {\\n\\n            long long int mid = start + (end-start)/2;\\n\\n            if(check(mid,batteries,n)==true)\\n            {\\n                ans = mid;\\n                start = mid+1;\\n            }\\n            else\\n            {\\n                end  = mid-1;\\n            }\\n        }\\n        \\n    return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1698346,
                "title": "python-binary-search-solution-similar-problems-listed",
                "content": "Please see my solutions for these similar problems.\\n\\nFor these problems, it\\'s relatively easy to solve the subproblem:\\ngiven a specific guess, determine whether it\\'s possible to xxx?\\nFurthermore, the range of guess is limited, and the boolean answer of the above subproblem has the pattern\\nF...FT...T or T...TF...F.\\nThus, we can use binary search to find the minimal/maximal value such that the boolean answer is True.\\n[378. Kth Smallest Element in a Sorted Matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/1004232/Python-solution-with-thinking-process)\\n[668. Kth Smallest Number in Multiplication Table](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/discuss/1714072/Simple-Python-Binary-Search-(similar-problem-listed))\\n[410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/discuss/326747/Python-solutions-with-thinking-process)\\n[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/discuss/390359/Simple-Python-Binary-Search)\\n[1231. Divide Chocolate](https://leetcode.com/problems/divide-chocolate/discuss/409956/Simple-Python-Binary-Search-(similar-problem-listed))\\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/discuss/390523/Simple-Python-Binary-Search)\\n[774. Minimize Max Distance to Gas Station](https://leetcode.com/problems/minimize-max-distance-to-gas-station/discuss/390526/Simple-Python-Binary-Search)\\n[1201. Ugly Number III](https://leetcode.com/problems/ugly-number-iii/discuss/390530/Simple-Python-Binary-Search)\\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/discuss/1714075/Simple-Python-Binary-Search-(similar-problem-listed))\\n[1891. Cutting Ribbons](https://leetcode.com/problems/cutting-ribbons/discuss/2361972/Python-Binary-search-solution-(similar-problems-listed))\\n[2141. Maximum Running Time of N Computers](https://leetcode.com/problems/maximum-running-time-of-n-computers/discuss/1698346/Python-Binary-search-solution-(similar-problems-listed))\\n\\nKey points of this problem:\\n1. If the computers cannot run simultaneously for t1 minutes, then definitely they cannot run simultaneously for t2 > t1 minutes.\\n2. Use binary search to find the maximal possible value of running time:\\nGiven a guess time, is it possible to run n computers simutaneously for time? If not, this means the guess is too large. If yes, try another larger guess.\\n3. For the subproblem \"Given a guess t, is it possible to run n computers simutaneously for t minutes?\"\\n    For each battery,\\n\\t    if its running time is greater than t, it can contribute t minutes for simutaneously running.\\n\\t\\tif its running time is less than t, it can contribute all its power for simutaneously running.\\n\\t     \\n\\n```\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        def cannot_run(n, batteries, time):\\n            curr_sum = 0\\n            for t in batteries:\\n                if t < time:\\n                    curr_sum += t\\n                else:\\n                    curr_sum += time\\n            return curr_sum < n * time\\n        \\n        low, high = 0, sum(batteries) // n\\n        while low < high:\\n            guess = high - (high - low) // 2 # prevent infinite loop to find the maximal T\\n            if cannot_run(n, batteries, guess):\\n                high = guess - 1\\n            else:\\n                low = guess\\n        return low\\n```\\nTime complexity: O(len(batteries) * log (sum(batteries) / n))",
                "solutionTags": [],
                "code": "```\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        def cannot_run(n, batteries, time):\\n            curr_sum = 0\\n            for t in batteries:\\n                if t < time:\\n                    curr_sum += t\\n                else:\\n                    curr_sum += time\\n            return curr_sum < n * time\\n        \\n        low, high = 0, sum(batteries) // n\\n        while low < high:\\n            guess = high - (high - low) // 2 # prevent infinite loop to find the maximal T\\n            if cannot_run(n, batteries, guess):\\n                high = guess - 1\\n            else:\\n                low = guess\\n        return low\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3824075,
                "title": "beats-100-c-without-binary-search-beginner-friendly",
                "content": "We can do this problem without using binary search just by observation and simple mathematics.\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> \\nWe want to run the computers for maximum time so first sort the vector in `ascending order` and allocate `last n batteries` to computers so they can `maximum value battery` and then we\\'ll assess the remaining batteries\\' capacity to determine how much additional support they can provide.\\n\\n\\n# Approach\\n1. First we are `sorting` the batteries and provide `maximum value batteries` (last n batteries) to computers.\\n2. We calculate remaining batteries\\' value sum to check how much support they can provide and call it `sum`.\\n3. First we allocate battery to a computer whose battery gonna die first so we are checking the difference `d` between 1st and 2nd computer battery to make their `battery equal`.\\n4. We will do 3rd step for all batteries to maximise it runtime and while checking `kth battery` if `sum` value is less than difference `d` then we return the value of that battery because we made all the `batteries value from 1 to k-1 equals to k` and we can\\'t further increase it.\\n5. If we completed loop that means we still have remaing sum value and all the batteries from `1 to n` equals to value to value of battery `n` so we distribute remaining `sum` to all `n` batteries by doing sum/n as all the batteries value equals `same`.\\n\\n# Complexity\\n- Time complexity: `O(no. of computers)` for `loop` and `O(mlogm)` for `sorting`.\\nSo total `Time complexity` is $$O(n) + O(nlogn) => O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        sort(batteries.begin(),batteries.end());\\n        int m=batteries.size();\\n        long long sum=accumulate(batteries.begin(),batteries.end()-n,0ll);\\n        long long d=0;\\n\\n        for(int i=m-n+1,j=1;i<m;i++,j++){\\n            d += j*(batteries[i]-batteries[i-1]);\\n            if(sum==d) return batteries[i];\\n            if(sum<d){ \\n             sum=sum-d+(j*(batteries[i]-batteries[i-1]));\\n             return batteries[i-1]+sum/j;}\\n        }\\n        sum-=d;\\n        \\n      return batteries[m-1]+sum/n; \\n    }\\n};\\n```\\n**If you have found my solution helpful, I would sincerely appreciate your Upvote.**\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        sort(batteries.begin(),batteries.end());\\n        int m=batteries.size();\\n        long long sum=accumulate(batteries.begin(),batteries.end()-n,0ll);\\n        long long d=0;\\n\\n        for(int i=m-n+1,j=1;i<m;i++,j++){\\n            d += j*(batteries[i]-batteries[i-1]);\\n            if(sum==d) return batteries[i];\\n            if(sum<d){ \\n             sum=sum-d+(j*(batteries[i]-batteries[i-1]));\\n             return batteries[i-1]+sum/j;}\\n        }\\n        sum-=d;\\n        \\n      return batteries[m-1]+sum/n; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821568,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        left=0\\n        right=sum(batteries)//n+1\\n        def check(time):\\n            return sum(min(time,b) for b in batteries)>=n*time\\n\\n        while left<=right:\\n            mid=(left+right)//2\\n            if check(mid):\\n                left=mid+1\\n\\n            else:\\n                right=mid-1\\n\\n        return right                    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        left=0\\n        right=sum(batteries)//n+1\\n        def check(time):\\n            return sum(min(time,b) for b in batteries)>=n*time\\n\\n        while left<=right:\\n            mid=(left+right)//2\\n            if check(mid):\\n                left=mid+1\\n\\n            else:\\n                right=mid-1\\n\\n        return right                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823071,
                "title": "c-greedy-intuition-clear-explanation-beats-99",
                "content": "# Intuition & Approach\\n-> Reconsider the problem as following: n batteries as base which can be refilled by the remaining batteries.\\n-> The base should always be n largest batteries\\n-> finally treat the remaining batteries as a single big battery\\n-> for each index, we need to make all batteries till this index equal (by borrowing from the extra big battery) to move further.\\n-> if extra is still left after all differences are made equal, divide it equally among all n computers.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlog(n))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& b) { \\n        sort(b.begin(),b.end());\\n        long long count = b[b.size()-n];\\n        long long extra = accumulate(b.begin(),b.begin()+b.size()-n,0ll);\\n        vector<long long> diff;\\n        for(int i = b.size()-n; i<b.size()-1; i++){\\n            diff.push_back(((long long)(i-b.size()+n+1))*(b[i+1]-b[i]));\\n        }\\n        int index = 0;\\n        while(extra>0&&index<diff.size()){\\n            extra-=diff[index++];\\n            if(extra>=0)count=b[index+b.size()-n];\\n            else{ count+=(extra+diff[index-1])/(index);}\\n        }\\n        if(extra>0){\\n            count=extra/n+b.back();\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n```\\n\\n  int   int   if if if  set       set   OOO    for for for EEEEE  \\n  int   int   if    if   set     set  O     O      for     E      \\n  int   int   if if if    set   set   O     O      for     EEE    \\n  int   int   if           set set    O     O      for     E      \\n   int int    if             set        OOO        for     EEEEE  \\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& b) { \\n        sort(b.begin(),b.end());\\n        long long count = b[b.size()-n];\\n        long long extra = accumulate(b.begin(),b.begin()+b.size()-n,0ll);\\n        vector<long long> diff;\\n        for(int i = b.size()-n; i<b.size()-1; i++){\\n            diff.push_back(((long long)(i-b.size()+n+1))*(b[i+1]-b[i]));\\n        }\\n        int index = 0;\\n        while(extra>0&&index<diff.size()){\\n            extra-=diff[index++];\\n            if(extra>=0)count=b[index+b.size()-n];\\n            else{ count+=(extra+diff[index-1])/(index);}\\n        }\\n        if(extra>0){\\n            count=extra/n+b.back();\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\n\\n  int   int   if if if  set       set   OOO    for for for EEEEE  \\n  int   int   if    if   set     set  O     O      for     E      \\n  int   int   if if if    set   set   O     O      for     EEE    \\n  int   int   if           set set    O     O      for     E      \\n   int int    if             set        OOO        for     EEEEE  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822290,
                "title": "beat-100-o-m-nlogn-most-intuitive-solution-no-bs-no-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n  * Batteries can be replaced after **every minutes**. We don\\'t have to but we can.\\n  * Longest run time $\\\\iff$ lowest residue power\\n  * Therefore we want to *spread the usage of each battery* as much as possible.\\n  * We want to keep the battery with high power in use at all times.\\n  * If the battery powers are kind of \"balanced\", then our run time is\\n    $T = P / n$ where $P$ is the total power of all batteris and `n` is the computer count (the input argument).\\n  * If the battery powers are **not** \"balanced\" then for these \"high power\" batteries they will be kept in our computers until other batteries are used up (not enough to run `n` computer).\\n\\nFor example, for $n=3$ and `batteries = [4, 3, 3, 2]` they are balanced and we can run for `4` minutes.\\nOn the other hand, if `batteries = [5, 2, 2, 1]` they are not balanced and we can only run it for `2` minutes where `5` is always there in use.\\n\\nOnly the highest `n` batteries can be \"too high\". In fact, only `n - 1` of them can be \"too high\".\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can \"recursively\" figure out which battery is too high, starting from the `n`th highest power battery. Assuming we have all `n - 1` highest battery locked in use, the problem is like when `n = 1` and with `m - n + 1` batteries. We can always use the powers as much as possible because it\\'s always balanced for a single computer. If the time we find here is longer than the time the `n - 1`th battery can last, then that battery is also \"balanced\" and comes into our total power and our `n` becomes 2 now. We keep doing this until we find the boundary between \"balanced power\" and \"too high power\" batteries.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(M + n \\\\log n)$$\\n$M$ is the number of input batteries and `n` is the input argument.\\nWe select the last n elements and sort them, and do a one pass on them.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(\\\\log m)$$\\nOur algorithm runs without explicit extra space. The selection and sorting takes $\\\\Theta(\\\\log m + \\\\log n) = \\\\Theta(\\\\log m)$ space.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  long long maxRunTime(int n, vector<int>& batteries) {\\n    std::nth_element(batteries.begin(), batteries.end() - n, batteries.end());\\n    std::sort(batteries.end() - n + 1, batteries.end());\\n    int64_t power = std::accumulate(batteries.begin(), batteries.end() - n + 1, 0LL);\\n    const int start = batteries.size() - n;\\n    int used = 1;  // batteris at [start, start + used) can be used up.\\n    while (used < n) {\\n      int battery = batteries[start + used];  // next battery\\n      if (power / used < battery) {\\n        break;  // it will not be used up.\\n      }\\n      power += battery;\\n      ++used;\\n    }\\n    return power / used;\\n  }\\n};\\n```\\n\\n# A Little more on the Correctness Proof\\nThe **Approach** section above basically describes the algorithm but can also serve as a inform proof. Here we add a little more explanation why it is so.\\n\\n## Balanced vs \"Too High\"\\nIt\\'s obivious that when the `if (power / used < battery)` condtion is met, that battery is \"Too High\" and can never be fully used. We only need to prove the opposite: when that condition is not met, that battery together with other smaller batteries are \"balanced\" and \"balanced\" means we can fully use all the powers except the remainder.\\n\\nWe can proof by double mathematical induction. The first layer of induction is on `n`.\\n  * Obviously when `n = 1` it\\'s always balanced and we can always use up all batteries by keep switching to the highest power ones.\\n  * Now suppose the \"balanced\" property is correct for `n = k`, we want to prove that it\\'s also correct for `n = k + 1`.\\n    * Now we start our second layer of induction, by the power `p` of the extra battery added here. `p` is the highest power battery and if we exclude `p` and one computer, we are left with `n = k` and balanced battery set.\\n    * If $p = 1$ then obviously it\\'s balanced.\\n    * If it\\'s balanced when $p \\\\le p_0$, now consider $p = p_0 + 1$, we just need to run the computers with the highest `k + 1` batteries (which includes `p`) for one minute and we will have $p = p_0$ now and by induction they are \"balanced\".\\n",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  long long maxRunTime(int n, vector<int>& batteries) {\\n    std::nth_element(batteries.begin(), batteries.end() - n, batteries.end());\\n    std::sort(batteries.end() - n + 1, batteries.end());\\n    int64_t power = std::accumulate(batteries.begin(), batteries.end() - n + 1, 0LL);\\n    const int start = batteries.size() - n;\\n    int used = 1;  // batteris at [start, start + used) can be used up.\\n    while (used < n) {\\n      int battery = batteries[start + used];  // next battery\\n      if (power / used < battery) {\\n        break;  // it will not be used up.\\n      }\\n      power += battery;\\n      ++used;\\n    }\\n    return power / used;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394421,
                "title": "c-simple-c-code-o-nlogn",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    bool ispossible(int n, long long mid, vector<int>& batteries)\\n    {\\n        \\n        long long m = batteries.size(), val = 0, check = (long long)n*mid;\\n        for(int i = 0; i < m; i++)\\n        {\\n            if(batteries[i] < mid)\\n                val += batteries[i];\\n            else\\n                val += mid;\\n        }\\n        if(val >= check) return true;\\n        else return false;\\n    }\\npublic:\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        long long sum = 0;\\n        int mn = batteries[0];\\n        for(int &num : batteries){\\n            sum += num;\\n            mn = min(mn, num);\\n        }\\n        long long left = mn, right = (sum/n) + 1, ans = -1;\\n        while(left <= right)\\n        {\\n            long long mid = left + (right-left)/2;\\n            if(ispossible(n, mid, batteries))\\n            {\\n                ans = mid;\\n                left = mid+1;\\n            }\\n            else\\n            {\\n                right = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    bool ispossible(int n, long long mid, vector<int>& batteries)\\n    {\\n        \\n        long long m = batteries.size(), val = 0, check = (long long)n*mid;\\n        for(int i = 0; i < m; i++)\\n        {\\n            if(batteries[i] < mid)\\n                val += batteries[i];\\n            else\\n                val += mid;\\n        }\\n        if(val >= check) return true;\\n        else return false;\\n    }\\npublic:\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        long long sum = 0;\\n        int mn = batteries[0];\\n        for(int &num : batteries){\\n            sum += num;\\n            mn = min(mn, num);\\n        }\\n        long long left = mn, right = (sum/n) + 1, ans = -1;\\n        while(left <= right)\\n        {\\n            long long mid = left + (right-left)/2;\\n            if(ispossible(n, mid, batteries))\\n            {\\n                ans = mid;\\n                left = mid+1;\\n            }\\n            else\\n            {\\n                right = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693128,
                "title": "c-solution-sorting-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(long long mid,int num,vector<int> &a)\\n    {\\n        long long tmp=0,res=0;\\n        \\n        for(int i=0;i<a.size();i++)\\n        {\\n            tmp+=a[i];\\n            \\n            if(tmp>=mid)\\n            {\\n                tmp=tmp-mid;\\n                res++;\\n            }\\n        }\\n        \\n        if(res>=num)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    \\n    long long maxRunTime(int n, vector<int>& batteries) \\n    {\\n        long long start=0,end=1e16,res=-1;\\n        \\n        sort(batteries.begin(),batteries.end());\\n        \\n        while(start<=end)\\n        {\\n            long long val=start+(end-start)/2;\\n            \\n            \\n            if(check(val,n,batteries))\\n            {\\n                start=val+1;\\n                res=val;\\n            }\\n            else\\n            {\\n                end=val-1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(long long mid,int num,vector<int> &a)\\n    {\\n        long long tmp=0,res=0;\\n        \\n        for(int i=0;i<a.size();i++)\\n        {\\n            tmp+=a[i];\\n            \\n            if(tmp>=mid)\\n            {\\n                tmp=tmp-mid;\\n                res++;\\n            }\\n        }\\n        \\n        if(res>=num)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    \\n    long long maxRunTime(int n, vector<int>& batteries) \\n    {\\n        long long start=0,end=1e16,res=-1;\\n        \\n        sort(batteries.begin(),batteries.end());\\n        \\n        while(start<=end)\\n        {\\n            long long val=start+(end-start)/2;\\n            \\n            \\n            if(check(val,n,batteries))\\n            {\\n                start=val+1;\\n                res=val;\\n            }\\n            else\\n            {\\n                end=val-1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826210,
                "title": "2-approach-greed-beats-100-binary-search-on-ans",
                "content": "# Intuition\\nUse up the smallest batteries 1st, so that larger batteries can be used for a longer time.\\n# Approach (1)\\n**Greedy Algorithm** :\\nThe nth_element function is used to partition the batteries array such that the last n elements are the largest n elements. This is done by calling nth_element(batteries.begin(), batteries.end() - n, batteries.end()). After this call, the last n elements of the batteries array are the largest n elements, and all the elements before these last n elements are less than or equal to these last n elements.\\n\\nAfter partitioning the batteries array, this implementation sorts these last n elements in ascending order by calling sort(batteries.begin(), batteries.end()). Then, it calculates the sum of all elements before these last n elements by calling accumulate(batteries.begin(), batteries.end() - n + 1, 0LL).\\n\\nThe algorithm then iteratively checks if it can use up more batteries from these last n elements until it finds a battery that cannot be used up. This is done by maintaining a variable used that keeps track of how many batteries from these last n elements have been used up. The algorithm repeatedly increments used and adds the next battery from these last n elements to the sum until it finds a battery that cannot be used up. A battery can be used up if and only if its remaining time is less than or equal to the average remaining time of all used batteries.\\n\\nFinally, the algorithm returns the average remaining time of all used batteries as the maximum number of minutes that all n computers can be run simultaneously.\\n\\n# Complexity\\n- Time complexity:\\nThe overall complexity is O(batteries.size()) as the most costy operation is the accumulate on batteries vector. Others code portions have lower complexity.\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\n// Greed Beats 100% time and memory \\n\\nclass Solution {\\npublic:\\n#define ll long long\\n    ll maxRunTime(int n, vector<int>& batteries) {\\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);        \\n        nth_element(batteries.begin(), batteries.end() - n, batteries.end());\\n        sort(batteries.begin(), batteries.end());\\n        ll s(accumulate(batteries.begin(), batteries.end()-n+1, 0LL));\\n        int l(batteries.size()-n), cnt(1);\\n        while (cnt < n) {\\n            int t(batteries[l+cnt]);\\n            if (s / cnt < t) break;\\n            s += t, ++cnt;\\n        }\\n        return s / cnt;\\n    }\\n};\\n\\n\\n```\\n# Intuition for 2nd approach (BS)\\n\\nThe key idea is to use a binary search to find the maximum value of x such that it is possible to run all n computers simultaneously for x minutes using the given batteries.\\n\\n# Approach (2)\\n\\n**Binary search algorithm** : \\nThe valid lambda function is used to check if it is possible to run all n computers simultaneously for x minutes using the given batteries. This function takes one argument(x). It calculates the sum of the minimum of x and each element in the batteries vector, and returns 1 iff this sum divided by n is greater than or equal to x.\\n\\nThe maxRunTime method uses a binary search algorithm to find the maximum value of x such that the valid function returns true when called with argument x. The binary search algorithm starts with a search range of [1, 1e14] and repeatedly calculates the mid value of this range, calls the valid function with this value, and updates the search range based on the result of the valid function. If the valid function returns 1 for a given value of x, then it is possible to run all n computers simultaneously for at least x minutes, so the algorithm updates the search range to [mid + 1, r]. Otherwise, if the valid function returns false for a given value of x, then it is not possible to run all n computers simultaneously for at least x minutes, so the algorithm updates the search range to [l, mid - 1]\\n\\n# Complexity : \\nTime complexity : O(n * log(mx(batteries))) where n = batteries.size()\\nSpace complexity : O(1)\\n \\n# Code \\n```\\n#define ll long long\\nclass Solution\\n        {\\n        public:\\n            long long maxRunTime(int n, vector<int> &batteries)\\n            {\\n                ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\\n                int sz(batteries.size());\\n                auto valid = [&](ll x) {\\n                    ll s(0);\\n                    for (int i(0); i < sz; ++i)\\n                        (batteries[i] >= x)? s += x : s += batteries[i];\\n                    return (s/n) >= x;\\n                };\\n\\n                ll l(1), r((ll)1e14), mid, ans(-1);\\n                sort(batteries.rbegin(), batteries.rend());\\n                while (l <= r)\\n                    mid = l + (r - l) / 2,\\n                    (valid(mid))? (ans = mid, l = mid +1 ) : r = mid - 1;\\n                \\n                return ans;\\n            }\\n        };\\n\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\n// Greed Beats 100% time and memory \\n\\nclass Solution {\\npublic:\\n#define ll long long\\n    ll maxRunTime(int n, vector<int>& batteries) {\\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);        \\n        nth_element(batteries.begin(), batteries.end() - n, batteries.end());\\n        sort(batteries.begin(), batteries.end());\\n        ll s(accumulate(batteries.begin(), batteries.end()-n+1, 0LL));\\n        int l(batteries.size()-n), cnt(1);\\n        while (cnt < n) {\\n            int t(batteries[l+cnt]);\\n            if (s / cnt < t) break;\\n            s += t, ++cnt;\\n        }\\n        return s / cnt;\\n    }\\n};\\n\\n\\n```\n```\\n#define ll long long\\nclass Solution\\n        {\\n        public:\\n            long long maxRunTime(int n, vector<int> &batteries)\\n            {\\n                ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\\n                int sz(batteries.size());\\n                auto valid = [&](ll x) {\\n                    ll s(0);\\n                    for (int i(0); i < sz; ++i)\\n                        (batteries[i] >= x)? s += x : s += batteries[i];\\n                    return (s/n) >= x;\\n                };\\n\\n                ll l(1), r((ll)1e14), mid, ans(-1);\\n                sort(batteries.rbegin(), batteries.rend());\\n                while (l <= r)\\n                    mid = l + (r - l) / 2,\\n                    (valid(mid))? (ans = mid, l = mid +1 ) : r = mid - 1;\\n                \\n                return ans;\\n            }\\n        };\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3822355,
                "title": "simple-code-java-binarysearch",
                "content": "\\n# Approach\\n1. Finding time where all computers will run simultaniously is difficult thing.\\n2. Instead we can assume some time and check can we run all computers for this much time is easy.\\n3. so we are using binary search to get time.\\n4. we are using isPossible function to check we can run n computers for given time.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: log(sum(batteries))*batteries.length\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxRunTime(int n, int[] batteries) {\\n        long stTime=0;\\n        long edTime=0;\\n        for(int i=0;i<batteries.length;i++){\\n            edTime+=batteries[i];\\n        }\\n        long ans=0;\\n        while(stTime<=edTime){\\n            long mid=stTime + (edTime-stTime)/2;\\n            if(isPossible(n,batteries,mid)){\\n                ans=mid;\\n                stTime=mid+1;\\n            } else {\\n                edTime=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean isPossible(int n,int batteries[],long mid){\\n        long time=0;\\n        for(int i=0;i<batteries.length;i++){\\n            if(batteries[i]<=mid){\\n                time+=batteries[i];\\n            } else {\\n                time+=mid;\\n            }\\n        }\\n        return time>= mid*n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public long maxRunTime(int n, int[] batteries) {\\n        long stTime=0;\\n        long edTime=0;\\n        for(int i=0;i<batteries.length;i++){\\n            edTime+=batteries[i];\\n        }\\n        long ans=0;\\n        while(stTime<=edTime){\\n            long mid=stTime + (edTime-stTime)/2;\\n            if(isPossible(n,batteries,mid)){\\n                ans=mid;\\n                stTime=mid+1;\\n            } else {\\n                edTime=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean isPossible(int n,int batteries[],long mid){\\n        long time=0;\\n        for(int i=0;i<batteries.length;i++){\\n            if(batteries[i]<=mid){\\n                time+=batteries[i];\\n            } else {\\n                time+=mid;\\n            }\\n        }\\n        return time>= mid*n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822242,
                "title": "c-binary-search-sort-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        int m=batteries.size();\\n        int min_power=*min_element(batteries.begin(), batteries.end());\\n        if (m==n) return min_power;\\n        long long left=min_power;\\n        long long right=accumulate(batteries.begin(), batteries.end(), 0LL)/n;\\n        long long mid;\\n        while(left<right){\\n            mid=(right+left+1)/2;\\n            long long reserve=0;\\n            for (int x: batteries)\\n                reserve+=min((long long)x, mid);\\n            if (reserve>=mid*n)\\n                left=mid;\\n            else\\n                right=mid-1;\\n        }\\n        return left;\\n    }\\n};\\n```\\n# Code for sort & Prefix sum\\n```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        int m=batteries.size();\\n        sort(batteries.begin(), batteries.end());\\n        if (m==n) return batteries[0];\\n        long long reserve=accumulate(batteries.begin(), batteries.begin()+m-n, 0LL);\\n        vector<int> computer(n);\\n        copy(batteries.begin()+m-n, batteries.end(), computer.begin());\\n    \\n        for (int i=1; i<n; i++){\\n            if (reserve< (long long)i*(computer[i]-computer[i-1]))\\n                return computer[i-1]+reserve/i;\\n            reserve-=(long long)i*(computer[i]-computer[i-1]);\\n        }\\n        return computer[n-1]+reserve/n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        int m=batteries.size();\\n        int min_power=*min_element(batteries.begin(), batteries.end());\\n        if (m==n) return min_power;\\n        long long left=min_power;\\n        long long right=accumulate(batteries.begin(), batteries.end(), 0LL)/n;\\n        long long mid;\\n        while(left<right){\\n            mid=(right+left+1)/2;\\n            long long reserve=0;\\n            for (int x: batteries)\\n                reserve+=min((long long)x, mid);\\n            if (reserve>=mid*n)\\n                left=mid;\\n            else\\n                right=mid-1;\\n        }\\n        return left;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        int m=batteries.size();\\n        sort(batteries.begin(), batteries.end());\\n        if (m==n) return batteries[0];\\n        long long reserve=accumulate(batteries.begin(), batteries.begin()+m-n, 0LL);\\n        vector<int> computer(n);\\n        copy(batteries.begin()+m-n, batteries.end(), computer.begin());\\n    \\n        for (int i=1; i<n; i++){\\n            if (reserve< (long long)i*(computer[i]-computer[i-1]))\\n                return computer[i-1]+reserve/i;\\n            reserve-=(long long)i*(computer[i]-computer[i-1]);\\n        }\\n        return computer[n-1]+reserve/n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821645,
                "title": "my-solution-java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public long maxRunTime(int n, int[] batteries) {\\n        Arrays.sort(batteries);\\n        long sum = 0;\\n        for (int a: batteries)\\n            sum += a;\\n        int k = 0, na = batteries.length;\\n        while (batteries[na - 1 - k] > sum / (n - k))\\n            sum -= batteries[na - 1 - k++];\\n        return sum / (n - k);\\n    }  \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxRunTime(int n, int[] batteries) {\\n        Arrays.sort(batteries);\\n        long sum = 0;\\n        for (int a: batteries)\\n            sum += a;\\n        int k = 0, na = batteries.length;\\n        while (batteries[na - 1 - k] > sum / (n - k))\\n            sum -= batteries[na - 1 - k++];\\n        return sum / (n - k);\\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1695541,
                "title": "python3-not-fancy-simulation-solution-make-a-barrel-that-can-hold-most-water-with-planks",
                "content": "My intuition with this problem started with we could heapify the batteries array into a min-heap and every time pop two of the smallest batteries and combine them into one big battery then push it back to the heap. Repeat until we have n batteries left and the smallest battery on the heap would be the \"bottleneck\", its charge will determine the longest time we can keep the n computers running.\\n\\nHowever as I found out the hard way during contest, this is obviously wrong as it failed even the example case: \\n```\\n2\\n[3,3,3]\\n```\\nThis would turn into a heap of `[6,3]` and return 3 as the result when that\\'s obviously wrong.\\nHowever this did help me realize that it\\'s not just about combining 2 batteries together, but rather we can treat any battery of charge `x` as `x` battereis of charge 1, and those can be added to any battery to create a new battery with one extra charge.\\n\\nSo then I thought of sorting the batteries from high to low, and the first `n` largest batteries will be the basic of my solution, together they would run the longest if we didn\\'t have the rest of the smaller batteries. This configuration is now bottlenecked by the smallest batteries\\' charge. \\n\\n(This can then be thought of as a problem which you have a barrel with a bunch of planks of different length, and a bunch of scrap planks of length 1 that you can amend to any plank that is already part of the barrel, then what\\'s the most water the barrel can hold after using all the scraps to make the lowest plank taller.)\\n\\nNext, the rest of the batteries will be the reserve ones and try to add to the current top n batteries. My strategy was fill the smallest one to the second smallest one and continue until one of these condition is met:\\n* we run out of extra batteries while filling up the smaller batteries\\n* we\\'ve filled all the n batteries to the max one and still have extra batteries remaining.\\n\\nIf we run out of extra batteries then we just return the amount which we were able to top off to, if we still have extra then average them out to all the n batteries, basically `extra // n` .\\n\\nThis solution is definitiely not a fancy one but it\\'s the closest I could think of if I were asked this in an interview, hope it helps!\\n\\n```\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        batteries.sort(reverse=True)\\n        refills = batteries[n:]\\n        s = sum(refills)\\n        res = 0\\n        for i in range(n-1, 0, -1):\\n            cur = batteries[i]\\n            prev = batteries[i-1]\\n            if prev == cur:\\n                continue\\n            smaller_batteries = n-i\\n            need_for_refill = smaller_batteries * (prev-cur)\\n            if need_for_refill <= s:\\n                s -= need_for_refill\\n            else:\\n                return cur + s // smaller_batteries\\n            \\n        return batteries[0] + s // n\\n```",
                "solutionTags": [
                    "Python3",
                    "Simulation"
                ],
                "code": "```\\n2\\n[3,3,3]\\n```\n```\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        batteries.sort(reverse=True)\\n        refills = batteries[n:]\\n        s = sum(refills)\\n        res = 0\\n        for i in range(n-1, 0, -1):\\n            cur = batteries[i]\\n            prev = batteries[i-1]\\n            if prev == cur:\\n                continue\\n            smaller_batteries = n-i\\n            need_for_refill = smaller_batteries * (prev-cur)\\n            if need_for_refill <= s:\\n                s -= need_for_refill\\n            else:\\n                return cur + s // smaller_batteries\\n            \\n        return batteries[0] + s // n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694687,
                "title": "c-o-nlogn-binary-search-sorting",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    #define ll long long\\n    \\n\\t// checking if possible to assign \\'mins\\' to each computer\\n    bool possible(int n, vector<int> &bat, ll int mins){\\n        ll int s=0;\\n        for(int i=0;i<bat.size();i++){\\n            s += bat[i];\\n            if(s>=mins){\\n                s-=mins;\\n                n--;\\n            }\\n            if(n==0) return true;\\n        }\\n        return false;\\n    }\\n    \\n    long long maxRunTime(int n, vector<int> &bat) {\\n        ll int l=1, r=0;\\n        \\n        for(int i=0;i<bat.size();i++) r += bat[i];\\n        r/=n; // max. minutes will be possible when all computers are assigned average of total battery minutes\\n        \\n        sort(bat.begin(),bat.end());\\n        while(l<r){\\n            ll int m=l+(r-l+1)/2;\\n            \\n            if(possible(n,bat,m)){\\n                l=m;\\n            }else{\\n                r=m-1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```\\n\\n**Do Upvote If It Helps**",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    #define ll long long\\n    \\n\\t// checking if possible to assign \\'mins\\' to each computer\\n    bool possible(int n, vector<int> &bat, ll int mins){\\n        ll int s=0;\\n        for(int i=0;i<bat.size();i++){\\n            s += bat[i];\\n            if(s>=mins){\\n                s-=mins;\\n                n--;\\n            }\\n            if(n==0) return true;\\n        }\\n        return false;\\n    }\\n    \\n    long long maxRunTime(int n, vector<int> &bat) {\\n        ll int l=1, r=0;\\n        \\n        for(int i=0;i<bat.size();i++) r += bat[i];\\n        r/=n; // max. minutes will be possible when all computers are assigned average of total battery minutes\\n        \\n        sort(bat.begin(),bat.end());\\n        while(l<r){\\n            ll int m=l+(r-l+1)/2;\\n            \\n            if(possible(n,bat,m)){\\n                l=m;\\n            }else{\\n                r=m-1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693217,
                "title": "priority-queue-giving-tle-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int k, vector<int>& arr){\\n        int n = arr.size();\\n        if(k > n) return 0;\\n        \\n        long long ans = 0;\\n        priority_queue<int> pq;\\n        \\n        for(auto it : arr){\\n            pq.push(it);\\n        }\\n        \\n        while(pq.size() >= k){\\n            vector<int> kBattery;\\n            int temp = k;\\n            while(temp--){\\n                kBattery.push_back(pq.top());\\n                pq.pop();\\n            }\\n            for(auto &it : kBattery) it--;\\n            for(auto &it : kBattery) \\n                if(it > 0) pq.push(it);\\n            ans++;\\n        }   \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int k, vector<int>& arr){\\n        int n = arr.size();\\n        if(k > n) return 0;\\n        \\n        long long ans = 0;\\n        priority_queue<int> pq;\\n        \\n        for(auto it : arr){\\n            pq.push(it);\\n        }\\n        \\n        while(pq.size() >= k){\\n            vector<int> kBattery;\\n            int temp = k;\\n            while(temp--){\\n                kBattery.push_back(pq.top());\\n                pq.pop();\\n            }\\n            for(auto &it : kBattery) it--;\\n            for(auto &it : kBattery) \\n                if(it > 0) pq.push(it);\\n            ans++;\\n        }   \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825560,
                "title": "100-time-complexity-85-space-complexity-m-log-m-sorting-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou want to allocate batteries in the most efficient way possible to get the maximum usage. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe key concept is that by using the n largest batteries, you can ensure that rest of the batteries can be used to its maximum without having to charge multiple computers at the same time. For example, if our batteries is [10, 10, 8] with n = 2. We start with [10, 10] as our starting batteries. half of the 8 can be used in the first 4 seconds then rest can be used in the later 4 seconds. Since the third battery can never exceed the two batteries, we can distribute all of 8. If there are more than one excess batteries, the amount that needs to be allocated is the largest difference between any excess batteries. Again, this cannot exceed any of the starting batteries, so we can be 100% sure all of the excess batteries can be used.\\n\\nCase 1: There are more computers than batteries\\nNot all computers can run simulataneously, return 0\\n\\nCase 2: There are same amount of batteries as computers\\nReturn the minimum battery as once that battery runs out, one of the computer cannot run anymore.\\n\\nCase 3: There are more batteries than computers\\nThis is when the distribution needs to occur. We pick the n largest batteries and set them as our starting batteries. Since we know that the rest of the batteries can be used to its maximum, we can simply sum them. Starting from the first start battery, check if we have enough batteries left so that we can reach the next smallest starting battery. Remember that we need to multiply the difference between the next start battery and current start battery with amount of start batteries we have visited.\\nIn the case where amount of batteries you need to get to the next starting battery exceeds the amount of batteries you have left, return the current starting battery + maximum ammount of batteries you can distribute to the starting batteries you have visited. For example, if you have [10, 7, 5, 4] and n = 3, you can use 2 out of 4 to get 5 to 7, making the starting batteries [10, 7, 7] and left = 2. Since left is not enough to make both 7 go upto 10, we distribute the 2 to the 7s and return 7+1 = 8.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSorting requires $$O(m log(m))$$ where m = amount of batteries and iteration of the starting batteries require $$O(n)$$. Since n < m, time complexity is $$O(m log(m))$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(m)$$ needed for sorting\\n# Code\\n```\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        l = len(batteries)\\n        if n > l:\\n            return 0\\n        if n == l:\\n            return min(batteries)\\n        batteries.sort()\\n        curbatteries = []\\n        for _ in range (n):\\n            curbatteries.append(batteries.pop())\\n        left = sum(batteries)\\n        curbatteries.reverse()\\n        for i in range(n-1):\\n            need = (curbatteries[i+1]-curbatteries[i])*(i+1)\\n            if left < need:\\n                return curbatteries[i]+left//(i+1)\\n            left-=need\\n        return curbatteries[-1] + left//n\\n                        \\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Greedy",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        l = len(batteries)\\n        if n > l:\\n            return 0\\n        if n == l:\\n            return min(batteries)\\n        batteries.sort()\\n        curbatteries = []\\n        for _ in range (n):\\n            curbatteries.append(batteries.pop())\\n        left = sum(batteries)\\n        curbatteries.reverse()\\n        for i in range(n-1):\\n            need = (curbatteries[i+1]-curbatteries[i])*(i+1)\\n            if left < need:\\n                return curbatteries[i]+left//(i+1)\\n            left-=need\\n        return curbatteries[-1] + left//n\\n                        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822393,
                "title": "c-easy-max-heap-solution-best-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& b) {\\n        long long sum=0;\\n        priority_queue<int> pq;\\n        for(auto it:b)\\n        {\\n            sum+=it;\\n            pq.push(it);\\n        }\\n        while(pq.top() > (sum/n))\\n        {\\n            sum -= pq.top();\\n            pq.pop();\\n            n--;\\n        }\\n        return sum/n;\\n    }\\n};\\n// Please Upvote\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& b) {\\n        long long sum=0;\\n        priority_queue<int> pq;\\n        for(auto it:b)\\n        {\\n            sum+=it;\\n            pq.push(it);\\n        }\\n        while(pq.top() > (sum/n))\\n        {\\n            sum -= pq.top();\\n            pq.pop();\\n            n--;\\n        }\\n        return sum/n;\\n    }\\n};\\n// Please Upvote\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821859,
                "title": "c-easy-to-understand-optimal-solution-hard-problem-maximum-running-time-of-n-computers",
                "content": "# C++ | Easy to Understand | Optimal Solution | Hard Problem | 2141. Maximum Running Time of N Computers\\n```\\nclass Solution {\\npublic:\\n    bool check(long long sm,long long mid,vector<int>&batteries,int n){\\n        long long carry=0;\\n        int cnt=0;\\n        long long vd=0;\\n        int i=0;\\n        for(i=0;i<batteries.size();i++){\\n            vd+=max(0ll,mid-batteries[i]);     \\n            cnt++;\\n            if(cnt==n)break;\\n        }\\n       long long pf=0;\\n        for(int j=i+1;j<batteries.size();j++){\\n            pf+=batteries[j];\\n        }\\n        if(pf>=vd){\\n        return true;\\n        }\\n        return false;\\n    }\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        long long sm=0ll;\\n        for(int i=0;i<batteries.size();i++){\\n            sm+=batteries[i];\\n        }\\n        sort(batteries.rbegin(),batteries.rend());\\n        long long low=0,hgh=sm;\\n        long long ans=-1;\\n        while(low<=hgh){\\n            long long mid=(low+hgh)/2;\\n            if(!check(sm,mid,batteries,n)){\\n                hgh=mid-1;\\n            }\\n            else {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(long long sm,long long mid,vector<int>&batteries,int n){\\n        long long carry=0;\\n        int cnt=0;\\n        long long vd=0;\\n        int i=0;\\n        for(i=0;i<batteries.size();i++){\\n            vd+=max(0ll,mid-batteries[i]);     \\n            cnt++;\\n            if(cnt==n)break;\\n        }\\n       long long pf=0;\\n        for(int j=i+1;j<batteries.size();j++){\\n            pf+=batteries[j];\\n        }\\n        if(pf>=vd){\\n        return true;\\n        }\\n        return false;\\n    }\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        long long sm=0ll;\\n        for(int i=0;i<batteries.size();i++){\\n            sm+=batteries[i];\\n        }\\n        sort(batteries.rbegin(),batteries.rend());\\n        long long low=0,hgh=sm;\\n        long long ans=-1;\\n        while(low<=hgh){\\n            long long mid=(low+hgh)/2;\\n            if(!check(sm,mid,batteries,n)){\\n                hgh=mid-1;\\n            }\\n            else {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821778,
                "title": "basic-simple-approach-for-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBasic Simple Approach for java, i use array , binary search , sorting \\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxRunTime(int n, int[] batteries) {\\n        long low = 1;\\n        long high = 0;\\n        \\n        for (int battery : batteries) {\\n            high += battery;\\n        }\\n        \\n        while (low <= high) {\\n            long mid = low + (high - low) / 2;\\n            \\n            if (canRunAllComputers(n, batteries, mid)) {\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        return high; // high represents the last successful time (maximum time)\\n    }\\n    \\n    private boolean canRunAllComputers(int n, int[] batteries, long time) {\\n        long computersRunning = 0;\\n        \\n        for (int battery : batteries) {\\n            computersRunning += Math.min(battery, time);\\n        }\\n        \\n        return computersRunning >= time * n;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long maxRunTime(int n, int[] batteries) {\\n        long low = 1;\\n        long high = 0;\\n        \\n        for (int battery : batteries) {\\n            high += battery;\\n        }\\n        \\n        while (low <= high) {\\n            long mid = low + (high - low) / 2;\\n            \\n            if (canRunAllComputers(n, batteries, mid)) {\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        return high; // high represents the last successful time (maximum time)\\n    }\\n    \\n    private boolean canRunAllComputers(int n, int[] batteries, long time) {\\n        long computersRunning = 0;\\n        \\n        for (int battery : batteries) {\\n            computersRunning += Math.min(battery, time);\\n        }\\n        \\n        return computersRunning >= time * n;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821712,
                "title": "binary-search-py",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxRunTime(self, n: int, b: List[int]) -> int:\\n        def check(n,mid):\\n            return sum(mid if i>mid else i for i in b)/n>=mid\\n        i,j=0,10**20\\n        while i<j:\\n            mid=(i+j)//2\\n            if check(n,mid):\\n                i=mid+1\\n            else:\\n                j=mid\\n        return i-1\\n```\\n\\n![](https://media.tenor.com/Jl0YrqxnHmAAAAAC/binary-search-sequence-search.gif)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxRunTime(self, n: int, b: List[int]) -> int:\\n        def check(n,mid):\\n            return sum(mid if i>mid else i for i in b)/n>=mid\\n        i,j=0,10**20\\n        while i<j:\\n            mid=(i+j)//2\\n            if check(n,mid):\\n                i=mid+1\\n            else:\\n                j=mid\\n        return i-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821608,
                "title": "2-best-c-solution-simple-binary-search-approach-beats-100-in-both",
                "content": "# Code\\n```\\n// Solution 1\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& b) {\\n        long long start = 1;\\n        long long end = accumulate(b.begin(), b.end(), 0LL) / n;\\n\\n        while(start < end){\\n            long long mid = (end+start+1) / 2, time = 0;\\n            for(int t : b) \\n                time += min((long long)t, mid);\\n            if(mid*n <= time) \\n                start = mid;\\n            else \\n                end = mid-1;\\n        }\\n        return start;\\n    }\\n};\\n\\n// Solution 2\\nclass Solution {\\npublic:\\n    bool possible(int n, vector<int> &b, long long int hrs){\\n        long long int sum = 0;\\n        for(int i=0; i<b.size(); i++){\\n            sum += b[i];\\n            if(sum >= hrs)\\n                sum -= hrs, n--;\\n            if(n==0) \\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    long long maxRunTime(int n, vector<int> &b) {\\n        long long int start=1, end=0;\\n        for(int i=0; i<b.size(); i++) \\n            end += b[i];\\n        end /= n;\\n        \\n        sort(b.begin(), b.end());\\n        while(start < end){\\n            long long int mid = start+(end-start+1)/2;\\n            if(possible(n, b, mid))\\n                start = mid;\\n            else\\n                end = mid-1;\\n        }\\n        return start;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\n// Solution 1\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& b) {\\n        long long start = 1;\\n        long long end = accumulate(b.begin(), b.end(), 0LL) / n;\\n\\n        while(start < end){\\n            long long mid = (end+start+1) / 2, time = 0;\\n            for(int t : b) \\n                time += min((long long)t, mid);\\n            if(mid*n <= time) \\n                start = mid;\\n            else \\n                end = mid-1;\\n        }\\n        return start;\\n    }\\n};\\n\\n// Solution 2\\nclass Solution {\\npublic:\\n    bool possible(int n, vector<int> &b, long long int hrs){\\n        long long int sum = 0;\\n        for(int i=0; i<b.size(); i++){\\n            sum += b[i];\\n            if(sum >= hrs)\\n                sum -= hrs, n--;\\n            if(n==0) \\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    long long maxRunTime(int n, vector<int> &b) {\\n        long long int start=1, end=0;\\n        for(int i=0; i<b.size(); i++) \\n            end += b[i];\\n        end /= n;\\n        \\n        sort(b.begin(), b.end());\\n        while(start < end){\\n            long long int mid = start+(end-start+1)/2;\\n            if(possible(n, b, mid))\\n                start = mid;\\n            else\\n                end = mid-1;\\n        }\\n        return start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2160759,
                "title": "python-binary-search-with-thought-process-when-being-asked-during-interviews",
                "content": "### Binary Search + Sorting\\nBecause the battery can be reused, the best strategy is to combine the smaller batteries to construct a virtual battery as large as possible to guarantee the maximum running time. This requires us to sort the batteries first.\\nThen the probem can be converted to be given batteries, is it possible to construct `n` batteries that the minimum one is equal to `x` time. Then we can try out each possible `x` time until the maximum is found.\\nInstead of linear finding the `x`, we can use binary search to find the maixmum time that is possible for our case.\\nLastly, when we check if it is possible to construct `n` batteries, the remaining time can be reused to the next computer, so we should keep the part of battery that is larger than `x` time.\\nInterestingly, this solution is almost as same as the problem [*sum of mutated array closet to target*](https://leetcode.com/problems/sum-of-mutated-array-closest-to-target/)\\n\\n```python\\ndef maxRunTime(self, n: int, batteries: List[int]) -> int:\\n\\tbatteries.sort()\\n        \\n\\tdef possible(time):\\n\\t\\tcurr = count = 0\\n\\t\\tfor b in batteries:\\n\\t\\t\\tif curr + b < time:\\n\\t\\t\\t\\tcurr += b\\n\\t\\t\\telse:\\n\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\tcurr = b + curr - time\\n\\t\\treturn count >= n\\n        \\n\\tlow, high = batteries[0], sum(batteries)\\n\\twhile low < high:\\n\\t\\tmid = low + (high - low + 1) // 2\\n\\t\\tif possible(mid):\\n\\t\\t\\tlow = mid\\n\\t\\telse:     \\n\\t\\t\\thigh = mid - 1\\n\\treturn low\\n```\\n\\n*Time Complexity*= **O(NlgM)**, M represents the sum of batteries.\\n*Space Complexity*= **O(1)**",
                "solutionTags": [
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```python\\ndef maxRunTime(self, n: int, batteries: List[int]) -> int:\\n\\tbatteries.sort()\\n        \\n\\tdef possible(time):\\n\\t\\tcurr = count = 0\\n\\t\\tfor b in batteries:\\n\\t\\t\\tif curr + b < time:\\n\\t\\t\\t\\tcurr += b\\n\\t\\t\\telse:\\n\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\tcurr = b + curr - time\\n\\t\\treturn count >= n\\n        \\n\\tlow, high = batteries[0], sum(batteries)\\n\\twhile low < high:\\n\\t\\tmid = low + (high - low + 1) // 2\\n\\t\\tif possible(mid):\\n\\t\\t\\tlow = mid\\n\\t\\telse:     \\n\\t\\t\\thigh = mid - 1\\n\\treturn low\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1697520,
                "title": "python-space-optimized-easy-solution-with-explaination",
                "content": "The idea is to use all the batteries evenly, this gives the intution of distrubuting the average power to all the computers.This is the upper bound of the result.\\nOther thing is to pick the battery with max power and check if it can run more than the average.This is done till max power is greater than avg remaining power after this all the battery powers are evenly divided.\\n```\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        batteries.sort()\\n        total=sum(batteries)\\n        while batteries[-1]>total//n:\\n            n-=1\\n            total-=batteries.pop()\\n        return total//n\\n```\\n**Complexity Analysis:**\\nTime: O(len(battries)log(len(batteries))\\nSpace: O(1)",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        batteries.sort()\\n        total=sum(batteries)\\n        while batteries[-1]>total//n:\\n            n-=1\\n            total-=batteries.pop()\\n        return total//n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1696310,
                "title": "binary-search-clean-code-faster-than-100-of-submissions",
                "content": "```\\nclass Solution {\\n    public boolean canBeTarget(int[] batteries,int n,long target){\\n        long sum=0;\\n        long totalPC=target*n;\\n        for(int i=0;i<batteries.length;i++){\\n            sum+=Math.min(batteries[i],target);\\n            if(sum>=totalPC) return true;\\n        }\\n        return false;\\n    }\\n    public long maxRunTime(int n, int[] batteries) {\\n        long sumOfBatteries=0;\\n        for(int i=0;i<batteries.length;i++){\\n            sumOfBatteries+=batteries[i];\\n        }\\n        long low=0;\\n        long answer=0;\\n        long high=sumOfBatteries/n;\\n        while(low<=high){\\n            long mid=low+(high-low)/2;\\n            if(canBeTarget(batteries,n,mid)){\\n                low=mid+1;\\n                answer=mid;\\n            }else{\\n                high=mid-1;\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canBeTarget(int[] batteries,int n,long target){\\n        long sum=0;\\n        long totalPC=target*n;\\n        for(int i=0;i<batteries.length;i++){\\n            sum+=Math.min(batteries[i],target);\\n            if(sum>=totalPC) return true;\\n        }\\n        return false;\\n    }\\n    public long maxRunTime(int n, int[] batteries) {\\n        long sumOfBatteries=0;\\n        for(int i=0;i<batteries.length;i++){\\n            sumOfBatteries+=batteries[i];\\n        }\\n        long low=0;\\n        long answer=0;\\n        long high=sumOfBatteries/n;\\n        while(low<=high){\\n            long mid=low+(high-low)/2;\\n            if(canBeTarget(batteries,n,mid)){\\n                low=mid+1;\\n                answer=mid;\\n            }else{\\n                high=mid-1;\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693263,
                "title": "sort-binary-search-straightforward-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& a) {\\n        long long l = 1, r = 1e15;\\n        long long ans = 1;\\n        sort(a.begin(), a.end());\\n        auto yes = [&](long long x) {\\n            long long cur = 0;\\n            int cnt = 0;\\n            for (int i = 0; i < a.size(); ++i) {\\n                cur += a[i];\\n                if (cur >= x) {\\n                    cnt++;\\n                    cur = cur - x;\\n                }\\n            }\\n            return cnt >= n;\\n        };\\n        while (l <= r) {\\n            long long m = (l + r) >> 1;\\n            if (yes(m)) {\\n                ans = m;\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& a) {\\n        long long l = 1, r = 1e15;\\n        long long ans = 1;\\n        sort(a.begin(), a.end());\\n        auto yes = [&](long long x) {\\n            long long cur = 0;\\n            int cnt = 0;\\n            for (int i = 0; i < a.size(); ++i) {\\n                cur += a[i];\\n                if (cur >= x) {\\n                    cnt++;\\n                    cur = cur - x;\\n                }\\n            }\\n            return cnt >= n;\\n        };\\n        while (l <= r) {\\n            long long m = (l + r) >> 1;\\n            if (yes(m)) {\\n                ans = m;\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693181,
                "title": "c-binary-search-solution-explained",
                "content": "\\n\\nThis question can be slove with binary search\\n\\nAs lowest answer can be 1 and maximun will be less than 10^15 (as length can be max 10^5 and value of each element can be max 10^9)\\nso we will use binary search within lowest and highest limit\\n\\nAfter sorting the array and excluding last n(computers) element we will add other and assume them as single battery (sum)\\n\\n**l**=lowest **r**=highest\\n**x**=mid of l and r\\n\\nwhile checking if x can be ans we check if last n batteries can be charge with battery(sum) and value of last n batteries can be greater than or equal to x\\nthis is functioning of function->possible in my solution\\n\\neach time i am asking possible fn if x can be answer and if x can be than we will change our limit to x+1 to r\\n                                  else l to x-1\\n\\n\\n \\'\\'\\'\\n class Solution {\\npublic:\\n    \\n\\n    bool possible(vector<int> &arr,int n,long long mid,long long sum){\\n        \\n        for(int i=arr.size()-n;i<arr.size();i++){\\n            \\n\\n            if(arr[i]>=(mid)) continue;\\n            \\n            if((mid-arr[i])<=sum){\\n                sum-=(mid-arr[i]);\\n            }else{\\n                return false;\\n            \\n            }\\n            \\n        }\\n        \\n        return true;\\n    }\\n    \\n    \\n    l\\n    \\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        vector<int>& b=batteries;\\n        \\n        sort(b.begin(),b.end());\\n        \\n        long long sum=0;\\n        \\n        for(int i=0;i<(b.size()-n);i++){\\n            sum+=b[i];\\n        }\\n        \\n        long long ans=1;\\n        long long l=1,r=100000000000000000;\\n        \\n        while(l<=r){\\n            long long mid=(l+r)/2;\\n           \\n            if(possible(b,n,mid,sum)){\\n               \\n                ans=max(ans,mid);\\n                \\n                l=mid+1;\\n            }else{\\n                r=mid-1;\\n            }\\n        }\\n       \\n        \\n        return ans;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    \\n\\n    bool possible(vector<int> &arr,int n,long long mid,long long sum){\\n        \\n        for(int i=arr.size()-n;i<arr.size();i++){\\n            \\n\\n            if(arr[i]>=(mid)) continue;\\n            \\n            if((mid-arr[i])<=sum){\\n                sum-=(mid-arr[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1693063,
                "title": "c-sorting-binary-search",
                "content": "The idea is we\\'ll check if we can go upto mid minutes , if yes then store it and check for mid+1 , if no then go for mid-1 till start >= end. The final value will give us our required answer. Here start =0 , end = 1e18\\n\\n```\\nlong long maxRunTime(int n, vector<int>& batteries) {\\n        typedef long long ll;\\n        \\n        sort(batteries.begin(),batteries.end(),greater<int>());\\n        \\n        ll ext = 0;\\n        for(int i=n;i<size(batteries);i++) ext += batteries[i];\\n        \\n        \\n        ll start = 0 , end = 1e18;\\n        ll ans = 1e17;\\n        while(start <= end)\\n        {\\n            ll mid = (start + end)/2;\\n            ll temp = ext;\\n            \\n            bool ok = true;\\n            \\n            for(int i=0;i<n;i++) \\n            {\\n                if(batteries[i] + temp < mid) \\n                {\\n                    ok = false; break;\\n                }\\n                else temp -= mid > batteries[i] ? mid - batteries[i] : 0;\\n            }\\n            \\n            if(ok) ans = mid , start = mid+1;\\n            else end = mid-1;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nlong long maxRunTime(int n, vector<int>& batteries) {\\n        typedef long long ll;\\n        \\n        sort(batteries.begin(),batteries.end(),greater<int>());\\n        \\n        ll ext = 0;\\n        for(int i=n;i<size(batteries);i++) ext += batteries[i];\\n        \\n        \\n        ll start = 0 , end = 1e18;\\n        ll ans = 1e17;\\n        while(start <= end)\\n        {\\n            ll mid = (start + end)/2;\\n            ll temp = ext;\\n            \\n            bool ok = true;\\n            \\n            for(int i=0;i<n;i++) \\n            {\\n                if(batteries[i] + temp < mid) \\n                {\\n                    ok = false; break;\\n                }\\n                else temp -= mid > batteries[i] ? mid - batteries[i] : 0;\\n            }\\n            \\n            if(ok) ans = mid , start = mid+1;\\n            else end = mid-1;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1692968,
                "title": "java-binary-search-from-answer-o-nlogk",
                "content": "My solution using binary search, O(nlogk) time, O(1) space.\\n\\n```\\nclass Solution {\\n    public long maxRunTime(int n, int[] batteries) {\\n        // Sort is necessary to prevent single batteries being used simultaneously\\n        Arrays.sort(batteries);\\n        long sum = 0;\\n        int min = 0;\\n        for (int battery : batteries) {\\n            sum += battery;\\n            min = Math.min(min, battery);\\n        }\\n        // Given n <= batteries.length, the batteries can at least run min(batteries) mins\\n        long left = min, right = sum / n;\\n        while (left + 1 < right) {\\n            long mid = left + (right - left) / 2;\\n            boolean canRun = checkRunTime(n, batteries, mid);\\n            if (canRun) {\\n                left = mid;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return checkRunTime(n, batteries, right) ? right : left;\\n    }\\n    \\n    private boolean checkRunTime(int n, int[] batteries, long time) {\\n        long currSum = 0;\\n        int numOfComputers = 0;\\n        for (int battery : batteries) {\\n            currSum += battery;\\n            if (currSum >= time) {\\n                numOfComputers++;\\n                // The remaining battery life can be used by the next computer.\\n                currSum -= time;\\n            }\\n        }\\n        return numOfComputers >= n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public long maxRunTime(int n, int[] batteries) {\\n        // Sort is necessary to prevent single batteries being used simultaneously\\n        Arrays.sort(batteries);\\n        long sum = 0;\\n        int min = 0;\\n        for (int battery : batteries) {\\n            sum += battery;\\n            min = Math.min(min, battery);\\n        }\\n        // Given n <= batteries.length, the batteries can at least run min(batteries) mins\\n        long left = min, right = sum / n;\\n        while (left + 1 < right) {\\n            long mid = left + (right - left) / 2;\\n            boolean canRun = checkRunTime(n, batteries, mid);\\n            if (canRun) {\\n                left = mid;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return checkRunTime(n, batteries, right) ? right : left;\\n    }\\n    \\n    private boolean checkRunTime(int n, int[] batteries, long time) {\\n        long currSum = 0;\\n        int numOfComputers = 0;\\n        for (int battery : batteries) {\\n            currSum += battery;\\n            if (currSum >= time) {\\n                numOfComputers++;\\n                // The remaining battery life can be used by the next computer.\\n                currSum -= time;\\n            }\\n        }\\n        return numOfComputers >= n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825198,
                "title": "greedy-approach-in-c-i-var",
                "content": "> Upvote it helps you.\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTry to increase the minimum value in sub array of size $$n$$ containing batteries with longest duration from the heap of remaining battery hours by increasing them unit by unit.\\nNow minimum value in that sub array is our answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort the array in decreasing order.\\n2. Calculate sum of batteries from n to last index\\n3. Start from smallest value and try to make it equal to its next greatest by using battery hour obtained in step 02\\n4. Return minimum value from first n values and if there is extra battery hour reamaining with us then further distribute it among all computer\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(log(n))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        sort(batteries.begin(),batteries.end(),greater<int>());\\n        long long extraTime = 0;\\n        int diff;\\n\\n        for(int i=n;i<batteries.size();i++){\\n            extraTime+=batteries[i];\\n        }\\n        int updatedMin = batteries[n-1];\\n        for(int i=1;i<n;i++){\\n            diff = i*(batteries[n-i-1]-batteries[n-i]);\\n            cout<<diff<<endl;\\n            if(!diff)continue;\\n            if(diff<extraTime){\\n                extraTime -= diff;\\n                updatedMin = batteries[n-i-1];\\n            }else{\\n                updatedMin+=extraTime/i;\\n                extraTime = extraTime%i;\\n                break;\\n            }\\n        }\\n        return updatedMin+extraTime/n;;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        sort(batteries.begin(),batteries.end(),greater<int>());\\n        long long extraTime = 0;\\n        int diff;\\n\\n        for(int i=n;i<batteries.size();i++){\\n            extraTime+=batteries[i];\\n        }\\n        int updatedMin = batteries[n-1];\\n        for(int i=1;i<n;i++){\\n            diff = i*(batteries[n-i-1]-batteries[n-i]);\\n            cout<<diff<<endl;\\n            if(!diff)continue;\\n            if(diff<extraTime){\\n                extraTime -= diff;\\n                updatedMin = batteries[n-i-1];\\n            }else{\\n                updatedMin+=extraTime/i;\\n                extraTime = extraTime%i;\\n                break;\\n            }\\n        }\\n        return updatedMin+extraTime/n;;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3825036,
                "title": "binary-search-kotlin-solution",
                "content": "# Intuition\\nLet\\'s try to solve another problem, answering a question whether we can run all $$n$$ computers for $$T$$ minutes. Simple observation that we can\\'t use any battery longer than $$T$$ minutes. We just need to iterate over all batteries and find \\n$$ S = \\\\sum_{b \\\\in batteries} \\\\min(b, \\\\ T)$$. \\nIf $$S / T >=n$$ - answer yes, we can run all computers for $$T$$ minutes, otherwise answer is no.\\n\\nSome illustrations to this approach:\\n  \\n![Untitled drawing (2).png](https://assets.leetcode.com/users/images/a5608b41-d575-4b00-b109-ebf034ad636a_1690478616.4171877.png)\\n\\n\\n# Approach\\nWe will use binary search to find answer. To check whether we can run $$n$$ computers for $$T$$ minutes - use beforementioned approach.\\n\\n# Complexity\\n- Time complexity:$$O(N * log(M))$$\\nwhere $$M = \\\\sum _{b \\\\in batteries}b$$, and $$N$$ - number of batteries.\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    fun maxRunTime(n: Int, batteries: IntArray): Long {\\n        var l = 1L\\n        var r = batteries.map { it.toLong() }.sum()\\n\\n        fun check(t: Long): Boolean {\\n            var cnt = 0L\\n            var s = 0L\\n            for (v in batteries.map { minOf(it.toLong(), t) }) {\\n                cnt += (s + v) / t\\n                s = (s + v) % t\\n            }\\n            return cnt >= n\\n        }\\n\\n        while (r - l > 1) {\\n            val t = (r + l) / 2\\n            if (check(t)) {\\n                l = t\\n            } else {\\n                r = t\\n            }\\n        }\\n\\n        return if (check(r)) r else l\\n    }\\n\\n\\n}\\n\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    fun maxRunTime(n: Int, batteries: IntArray): Long {\\n        var l = 1L\\n        var r = batteries.map { it.toLong() }.sum()\\n\\n        fun check(t: Long): Boolean {\\n            var cnt = 0L\\n            var s = 0L\\n            for (v in batteries.map { minOf(it.toLong(), t) }) {\\n                cnt += (s + v) / t\\n                s = (s + v) % t\\n            }\\n            return cnt >= n\\n        }\\n\\n        while (r - l > 1) {\\n            val t = (r + l) / 2\\n            if (check(t)) {\\n                l = t\\n            } else {\\n                r = t\\n            }\\n        }\\n\\n        return if (check(r)) r else l\\n    }\\n\\n\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824968,
                "title": "easy-solution-cpp-max-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$mlogn$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& b) {\\n      if(n>b.size()) return -1;\\n      \\n      long long sum =0;\\n      priority_queue<int> maxh;\\n      for(auto i : b){\\n         sum+=i;\\n         maxh.push(i);\\n      }\\n      while(maxh.top()>sum/n){\\n          sum-=maxh.top();\\n          maxh.pop();\\n          n--;\\n      }\\n      return sum/n;\\n     \\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& b) {\\n      if(n>b.size()) return -1;\\n      \\n      long long sum =0;\\n      priority_queue<int> maxh;\\n      for(auto i : b){\\n         sum+=i;\\n         maxh.push(i);\\n      }\\n      while(maxh.top()>sum/n){\\n          sum-=maxh.top();\\n          maxh.pop();\\n          n--;\\n      }\\n      return sum/n;\\n     \\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824856,
                "title": "easy-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public long maxRunTime(int n, int[] batteries) {\\n        long lo = 1, hi = (long) 1e14+1;\\n\\n        while(lo < hi){\\n            long  mid = lo + (hi-lo)/2;\\n\\n            if(helper(batteries,n,mid)){\\n                lo = mid+1;\\n            }\\n            else{\\n                hi = mid;\\n            }\\n        }\\n\\n        return lo-1;\\n    }\\n\\n    private boolean helper(int[] battries, int n, long minutes){\\n        long val = 0;\\n\\n        for(int it : battries){\\n            val += Math.min(minutes,it);\\n        }\\n\\n        return val >= (long) n*minutes;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long maxRunTime(int n, int[] batteries) {\\n        long lo = 1, hi = (long) 1e14+1;\\n\\n        while(lo < hi){\\n            long  mid = lo + (hi-lo)/2;\\n\\n            if(helper(batteries,n,mid)){\\n                lo = mid+1;\\n            }\\n            else{\\n                hi = mid;\\n            }\\n        }\\n\\n        return lo-1;\\n    }\\n\\n    private boolean helper(int[] battries, int n, long minutes){\\n        long val = 0;\\n\\n        for(int it : battries){\\n            val += Math.min(minutes,it);\\n        }\\n\\n        return val >= (long) n*minutes;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824418,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Binary Search\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(int n, vector<int>& batteries, long long target) {\\n        long long tot = 0;\\n        for (long long x: batteries) tot += min(x, target);\\n        return tot >= n * target;\\n    }\\n\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        long long sum = 0;\\n        for (auto x: batteries) sum += x;\\n        long long lt = 1, rt = sum / n;\\n        while (lt <= rt) {\\n            long long mid = (lt + rt) / 2;\\n            if (check(n, batteries, mid)) lt = mid + 1;\\n            else rt = mid - 1;\\n        }\\n        return lt - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int n, vector<int>& batteries, long long target) {\\n        long long tot = 0;\\n        for (long long x: batteries) tot += min(x, target);\\n        return tot >= n * target;\\n    }\\n\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        long long sum = 0;\\n        for (auto x: batteries) sum += x;\\n        long long lt = 1, rt = sum / n;\\n        while (lt <= rt) {\\n            long long mid = (lt + rt) / 2;\\n            if (check(n, batteries, mid)) lt = mid + 1;\\n            else rt = mid - 1;\\n        }\\n        return lt - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823335,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& b) {\\n        long long low =1;\\n        long long high = accumulate(begin(b),end(b),0LL)/n;\\n\\n        while(low < high){\\n            long long mid = (high+low+1)/2;\\n            long long time=0;\\n            for(int t : b) time += min((long long)t,mid);\\n\\n            if(mid*n <= time) low = mid;\\n            else high = mid-1;\\n        }\\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& b) {\\n        long long low =1;\\n        long long high = accumulate(begin(b),end(b),0LL)/n;\\n\\n        while(low < high){\\n            long long mid = (high+low+1)/2;\\n            long long time=0;\\n            for(int t : b) time += min((long long)t,mid);\\n\\n            if(mid*n <= time) low = mid;\\n            else high = mid-1;\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823251,
                "title": "video-solution-c-java",
                "content": "# Intuition, approach, and time complexity dicussed in detail in video explanation\\nhttps://youtu.be/kNGW3fAzzbQ\\n\\nC++\\n```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        sort(batteries.begin(), batteries.end());\\n        return findMxRt(n, batteries);\\n    }\\n\\nprivate:  \\n    long long findMxRt(int computr, vector<int>& bat){\\n        long long left = 0LL, right = accumulate(bat.begin(), bat.end(), 0LL)/computr, maxRt = 0;\\n        while(left <= right){\\n            long long mid = left + (right - left)/2;\\n            if(testRun(bat, mid, computr)){\\n               maxRt = mid;\\n               left = mid + 1;\\n            }else{\\n                right = mid - 1; \\n            }\\n        }\\n        return maxRt;\\n    }\\n\\n    bool testRun(vector<int>& bat, int purpRt, int computr){\\n        int computrCnt = 0;\\n        long long currRt = 0LL;\\n        for(auto rT : bat){\\n            currRt += rT;\\n            if(currRt >= purpRt){\\n                currRt -= purpRt;\\n                computrCnt++;\\n            }\\n        }\\n        return computr <= computrCnt;\\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public long maxRunTime(int n, int[] batteries) {\\n        Arrays.sort(batteries);\\n        return findMxRt(n, batteries);\\n    }\\n\\n    private long findMxRt(int computr, int[] bat){\\n        long left = 0L, right = 0L, maxRt = 0;\\n        for(var rT : bat){\\n            right += rT;\\n        }\\n        right /= computr;\\n        while(left <= right){\\n            long mid = left + (right - left)/2;\\n            if(testRun(bat, mid, computr)){\\n               maxRt = mid;\\n               left = mid + 1;\\n            }else{\\n                right = mid - 1; \\n            }\\n        }\\n        return maxRt;\\n    }\\n\\n    private boolean testRun(int [] bat, long purpRt, int computr){\\n        int computrCnt = 0;\\n        long currRt = 0L;\\n        for(var rT : bat){\\n            currRt += rT;\\n            if(currRt >= purpRt){\\n                currRt -= purpRt;\\n                computrCnt++;\\n            }\\n        }\\n        return computr <= computrCnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        sort(batteries.begin(), batteries.end());\\n        return findMxRt(n, batteries);\\n    }\\n\\nprivate:  \\n    long long findMxRt(int computr, vector<int>& bat){\\n        long long left = 0LL, right = accumulate(bat.begin(), bat.end(), 0LL)/computr, maxRt = 0;\\n        while(left <= right){\\n            long long mid = left + (right - left)/2;\\n            if(testRun(bat, mid, computr)){\\n               maxRt = mid;\\n               left = mid + 1;\\n            }else{\\n                right = mid - 1; \\n            }\\n        }\\n        return maxRt;\\n    }\\n\\n    bool testRun(vector<int>& bat, int purpRt, int computr){\\n        int computrCnt = 0;\\n        long long currRt = 0LL;\\n        for(auto rT : bat){\\n            currRt += rT;\\n            if(currRt >= purpRt){\\n                currRt -= purpRt;\\n                computrCnt++;\\n            }\\n        }\\n        return computr <= computrCnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public long maxRunTime(int n, int[] batteries) {\\n        Arrays.sort(batteries);\\n        return findMxRt(n, batteries);\\n    }\\n\\n    private long findMxRt(int computr, int[] bat){\\n        long left = 0L, right = 0L, maxRt = 0;\\n        for(var rT : bat){\\n            right += rT;\\n        }\\n        right /= computr;\\n        while(left <= right){\\n            long mid = left + (right - left)/2;\\n            if(testRun(bat, mid, computr)){\\n               maxRt = mid;\\n               left = mid + 1;\\n            }else{\\n                right = mid - 1; \\n            }\\n        }\\n        return maxRt;\\n    }\\n\\n    private boolean testRun(int [] bat, long purpRt, int computr){\\n        int computrCnt = 0;\\n        long currRt = 0L;\\n        for(var rT : bat){\\n            currRt += rT;\\n            if(currRt >= purpRt){\\n                currRt -= purpRt;\\n                computrCnt++;\\n            }\\n        }\\n        return computr <= computrCnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822443,
                "title": "easy-c-solution-beats-75",
                "content": "# Intuition\\nSince we need to maximize the minimum Running Time for a computer, \\nthe first approach comes to mind is Binary Search, as minmax type problem.\\n\\n# Approach\\nSo, we will apply Binary search on time, and the only thing which should be kept in mind implementing the predicate function is that\\nwe cannot utilize the battery as extra if greater than target or we can utilize only the part of battery which is less than or equal to target.\\n\\n# Complexity\\n- Time complexity:\\nO ( k * log (r) ) where,\\nk - length of batteries array\\nr - range of binary search \\n\\n- Space complexity:\\nO ( 1 )\\n\\n# Code\\n\\nApproach 1: Using Binary Search\\n\\n```\\nclass Solution{\\nprivate:\\n    int k;\\n    bool f(vector<int>& batteries, const int n, const long long &m){\\n        long long sum=0;\\n        for(int i: batteries)\\n            sum+=min((long long)i,m);\\n        return sum/n >= m;\\n    }\\npublic:\\n    long long maxRunTime(int n, vector<int>& batteries){\\n        k=batteries.size();\\n        // base cases\\n        if(k<n) return 0;\\n        if(k==n)    return *min_element(batteries.begin(),batteries.end());\\n        // main logic - using Binary Search\\n        long long l=1, r=1e15;\\n        // pattern will form like . . . 1 1 1 0 0 0 . . .\\n        // we need to find last 1\\n        while(r>l+1){\\n            long long m=(l+r)/2;\\n            if(f(batteries,n,m))\\n                l=m;\\n            else\\n                r=m;\\n        }\\n        return l;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution{\\nprivate:\\n    int k;\\n    bool f(vector<int>& batteries, const int n, const long long &m){\\n        long long sum=0;\\n        for(int i: batteries)\\n            sum+=min((long long)i,m);\\n        return sum/n >= m;\\n    }\\npublic:\\n    long long maxRunTime(int n, vector<int>& batteries){\\n        k=batteries.size();\\n        // base cases\\n        if(k<n) return 0;\\n        if(k==n)    return *min_element(batteries.begin(),batteries.end());\\n        // main logic - using Binary Search\\n        long long l=1, r=1e15;\\n        // pattern will form like . . . 1 1 1 0 0 0 . . .\\n        // we need to find last 1\\n        while(r>l+1){\\n            long long m=(l+r)/2;\\n            if(f(batteries,n,m))\\n                l=m;\\n            else\\n                r=m;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822260,
                "title": "simple-java-code",
                "content": "\\n```Java []\\npublic class Solution {\\n    public long maxRunTime(int n, int[] batteries) {\\n        long sp = 0;\\n        for (long power : batteries)\\n            sp += power;\\n        long low = 1, high = sp / n;\\n        \\n        while (low < high){\\n            long time = (low+high+1) / 2;\\n            if (check(batteries, n, time))\\n                low = time;\\n            else\\n                high = time - 1;\\n        }\\n        return low;\\n    }\\n    \\n    public boolean check(int [] bat, int n, long time){\\n        long sum = 0;\\n        for(int battery: bat){\\n            sum+=Math.min(battery, time);\\n        }\\n        return (sum>=(long)time*n);\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```Java []\\npublic class Solution {\\n    public long maxRunTime(int n, int[] batteries) {\\n        long sp = 0;\\n        for (long power : batteries)\\n            sp += power;\\n        long low = 1, high = sp / n;\\n        \\n        while (low < high){\\n            long time = (low+high+1) / 2;\\n            if (check(batteries, n, time))\\n                low = time;\\n            else\\n                high = time - 1;\\n        }\\n        return low;\\n    }\\n    \\n    public boolean check(int [] bat, int n, long time){\\n        long sum = 0;\\n        for(int battery: bat){\\n            sum+=Math.min(battery, time);\\n        }\\n        return (sum>=(long)time*n);\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822128,
                "title": "easy-10-line-code-simple-sorting-approach-with-comments",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe goal of the code is to find the maximum average time that can be achieved by distributing batteries among \\'n\\' devices. The approach taken in the code is as follows:\\n\\n1. Calculate the total time of all batteries.\\n2. Sort the batteries in descending order.\\n3. Start distributing the batteries with the highest time to the devices until one of the following conditions is met:\\n a. All devices have received a battery (loop until \\'n\\' becomes 0).\\n b.The current battery\\'s time is less than or equal to the average time calculated by dividing the total time by the number of remaining devices (\\'n\\').\\n\\n   Once the loop is done, the code returns the maximum average time.\\n\\n# Complexity\\n  - Time complexity:  O (n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n \\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <vector>\\n#include <algorithm>\\n\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& bat) {\\n        // Calculate the total time of all batteries\\n        long long total_time = 0;\\n        for (int x : bat) {\\n            total_time += x;\\n        }\\n\\n        // Sort batteries in descending order\\n        sort(bat.rbegin(), bat.rend(),);\\n\\n        // Distribute batteries to achieve maximum average time\\n        for (int i = 0; i < bat.size(); i++, n--) {\\n            if (bat[i] <= (total_time / n)) {\\n                break;\\n            }\\n            total_time -= bat[i];\\n        }\\n\\n        // Return the maximum average time\\n        return total_time / n;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <vector>\\n#include <algorithm>\\n\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& bat) {\\n        // Calculate the total time of all batteries\\n        long long total_time = 0;\\n        for (int x : bat) {\\n            total_time += x;\\n        }\\n\\n        // Sort batteries in descending order\\n        sort(bat.rbegin(), bat.rend(),);\\n\\n        // Distribute batteries to achieve maximum average time\\n        for (int i = 0; i < bat.size(); i++, n--) {\\n            if (bat[i] <= (total_time / n)) {\\n                break;\\n            }\\n            total_time -= bat[i];\\n        }\\n\\n        // Return the maximum average time\\n        return total_time / n;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3821889,
                "title": "sorting-prefix-sum-easy-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is very simple just calculate the **total time and start from maximum time value** if with time is it **possible to operate all the computers** then check for **next maximum** otherwise **break the loop**.\\n\\n```\\nfor Ex:-   Time = [8,12,15]  n = 3\\n\\n   1st :- total_time = 8+12+15 = 35 min. and maximum time value = 15\\n          required time = 35/3 = 11 min. <  maxvalue( 15 )\\n          we can operate all 3 computers. \\u2714\\u2714\\n   2nd :- total_time = 8+12 = 20 min. and maximum time value =  12\\n          required time = 20/2 = 10 min. <  maxvalue( 12 )\\n          we can operate all 3 computers. \\u2714\\u2714\\n   3rd :- total_time = 8 min. and maximum time value = 8\\n          required time = 8/1 = 8 min. = maxvalue( 8 )\\n          break the loop \\u274C\\u274C\\nthis is (8) the maximum time value in to operate all the computers simultaneously.\\n    \\n```\\n\\n\\n# Complexity\\n- Time complexity:O(N * Log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    long long maxRunTime(int n, vector<int>& bat) {\\n    long long total_time = 0;\\n    for(auto x : bat) total_time+=x;\\n    sort(bat.rbegin(),bat.rend());\\n    for(int i = 0;i<bat.size();i++,n--)\\n    {\\n        if(bat[i]<=(total_time/n)) break;\\n        total_time-=bat[i];  \\n    }\\n    return total_time/n;\\n  }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/80bac288-8928-4b40-b383-c519419e5329_1690433152.6410513.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nfor Ex:-   Time = [8,12,15]  n = 3\\n\\n   1st :- total_time = 8+12+15 = 35 min. and maximum time value = 15\\n          required time = 35/3 = 11 min. <  maxvalue( 15 )\\n          we can operate all 3 computers. \\u2714\\u2714\\n   2nd :- total_time = 8+12 = 20 min. and maximum time value =  12\\n          required time = 20/2 = 10 min. <  maxvalue( 12 )\\n          we can operate all 3 computers. \\u2714\\u2714\\n   3rd :- total_time = 8 min. and maximum time value = 8\\n          required time = 8/1 = 8 min. = maxvalue( 8 )\\n          break the loop \\u274C\\u274C\\nthis is (8) the maximum time value in to operate all the computers simultaneously.\\n    \\n```\n```\\nclass Solution {\\npublic:\\n\\n    long long maxRunTime(int n, vector<int>& bat) {\\n    long long total_time = 0;\\n    for(auto x : bat) total_time+=x;\\n    sort(bat.rbegin(),bat.rend());\\n    for(int i = 0;i<bat.size();i++,n--)\\n    {\\n        if(bat[i]<=(total_time/n)) break;\\n        total_time-=bat[i];  \\n    }\\n    return total_time/n;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821707,
                "title": "c-solution-for-maximum-running-time-of-n-computers-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal is to find the maximum number of minutes we can run all n computers simultaneously using the given batteries. We are allowed to insert and remove batteries at any time, and we want to optimize the usage of batteries to maximize the runtime of all computers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe provided solution uses a binary search approach to find the maximum runtime that satisfies the condition of running all n computers simultaneously. The binary search is performed on the possible values of the runtime, i.e., the number of minutes we can run all computers at the same time. The search space for the runtime is from 1 to the sum of all batteries divided by n, as we can\\'t exceed this upper bound.\\n\\nFor each mid-value (target) during the binary search, the solution iterates through the batteries and calculates the total runtime that can be achieved with this target value. It keeps track of the sum of the minimum between the battery value and the target, which represents the total time all computers can run using this target value. If the total runtime is greater than or equal to n * target, it means we can achieve this runtime, so we update the left boundary to the target. Otherwise, we update the right boundary to target - 1.\\n\\nThe binary search continues until the left and right boundaries meet, and the left boundary represents the maximum runtime that satisfies the condition.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the binary search approach is O(log N), where N is the sum of all battery values. The binary search reduces the search space by half at each iteration, making it very efficient.\\n\\nThe time complexity of the loop that calculates the total runtime for each mid-value is O(N), where N is the number of batteries. Since we perform the loop inside the binary search loop, the overall time complexity is dominated by the binary search and remains O(log N).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is O(1) since it uses a constant amount of additional space for variables regardless of the input size. The solution doesn\\'t use any data structures that grow with the input, so the space complexity is constant.\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public long MaxRunTime(int n, int[] batteries)\\n    {\\n        long sumPower = 0;\\n        foreach (int power in batteries)\\n            sumPower += power;\\n\\n        long left = 1;\\n        long right = sumPower / n;\\n\\n        while (left < right)\\n        {\\n            long target = right - (right - left) / 2;\\n            long extra = 0;\\n\\n            foreach (int power in batteries)\\n                extra += Math.Min(power, target);\\n\\n            if (extra >= (long)(n * target))\\n                left = target;\\n            else\\n                right = target - 1;\\n        }\\n\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public long MaxRunTime(int n, int[] batteries)\\n    {\\n        long sumPower = 0;\\n        foreach (int power in batteries)\\n            sumPower += power;\\n\\n        long left = 1;\\n        long right = sumPower / n;\\n\\n        while (left < right)\\n        {\\n            long target = right - (right - left) / 2;\\n            long extra = 0;\\n\\n            foreach (int power in batteries)\\n                extra += Math.Min(power, target);\\n\\n            if (extra >= (long)(n * target))\\n                left = target;\\n            else\\n                right = target - 1;\\n        }\\n\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821359,
                "title": "daily-leetcoding-challenge-july-day-27",
                "content": "This problem is the Daily LeetCoding Challenge for July, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-running-time-of-n-computers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sorting and Prefix Sum\n\n  \n**Approach 2:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-running-time-of-n-computers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3749963,
                "title": "very-short-and-concise-o-n-log-n-solution-with-math-and-binary-search-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe key observation is that a battery can be supplied to different computers, but the total working hours of each battery is bounded to the maximum working hour of all computers because a battery cannot be used for more than one computer at any time point. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo, to check if a working hour $t$ of all computers is valid can be simply done by performing the following equation:\\n\\n$$ t \\\\le \\\\lfloor{ \\\\frac{\\\\sum_{i}^N \\\\min(t, b_i)}{N}} \\\\rfloor $$\\n$$ t \\\\times N \\\\le \\\\sum_{i}^N \\\\min(t, b_i) $$\\n\\nFinally, the maximun valid value of $t$ can be obtained by using binary search. \\n\\n# Complexity\\n- Time complexity: $$O(N \\\\log N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Additional memory is only $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        def check(t):\\n            return sum(min(t, v) for v in batteries) >= n * t\\n\\n        lo, hi = 0, sum(batteries) // n\\n        while lo < hi:\\n            mid = (hi + lo) // 2\\n            if check(mid):\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n\\n        return lo if check(lo) else lo - 1\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        def check(t):\\n            return sum(min(t, v) for v in batteries) >= n * t\\n\\n        lo, hi = 0, sum(batteries) // n\\n        while lo < hi:\\n            mid = (hi + lo) // 2\\n            if check(mid):\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n\\n        return lo if check(lo) else lo - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3637278,
                "title": "c-super-easy-binary-search-on-answer-self-explanatory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool isValid(long long time, vector<int>& batteries, int n){\\n        long long total = 0;\\n        for(int i=0; i<batteries.size(); i++){\\n            total += min(time,1LL*batteries[i]);\\n        }\\n        return total >= time*n;\\n    }\\npublic:\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        \\n        long long low = 1;\\n        long long high = 0;\\n        for(int i=0; i<batteries.size(); i++){\\n            high += batteries[i];\\n        }\\n        high = high/n;\\n        long long ans = 0;\\n        while(low <= high){\\n            long long mid = (high + low) / 2;\\n            if(isValid(mid,batteries,n)){\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isValid(long long time, vector<int>& batteries, int n){\\n        long long total = 0;\\n        for(int i=0; i<batteries.size(); i++){\\n            total += min(time,1LL*batteries[i]);\\n        }\\n        return total >= time*n;\\n    }\\npublic:\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        \\n        long long low = 1;\\n        long long high = 0;\\n        for(int i=0; i<batteries.size(); i++){\\n            high += batteries[i];\\n        }\\n        high = high/n;\\n        long long ans = 0;\\n        while(low <= high){\\n            long long mid = (high + low) / 2;\\n            if(isValid(mid,batteries,n)){\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540392,
                "title": "simple-solution-with-clear-and-rigorous-proof",
                "content": "# Explanation\\n\\nIn an optimal setting, we would return $\\\\lfloor sum(batteries)/n\\\\rfloor$. This would happen if the battery power could be evenly distributed among the n computers, and should be a clear upper bound.\\n\\nSince this is an upper bound, any battery with a life larger than this should be attached to some computer at every step. The actual computer it is attached to does not matter (we can swap batteries in 0 time), and so we may simply pick an arbitrary computer and assign it this battery for the entire duration.\\n\\nThis creates the subproblem where we have one less battery, and one less computer. By doing this process at the start, we may assume that all batteries have power at most $\\\\lfloor sum(batteries)/n\\\\rfloor$.\\n\\nFrom here, we can actually prove that $\\\\lfloor sum(batteries)/n\\\\rfloor$ is always rechable. Wlog assume that $n|sum(batteries)$. This is valid since repeadily subtracting 1 from any non-zero battery will not change this upper bound, and will maintain the invariant that all batteries have at most $n|sum(batteries)$ power.\\n\\nTo prove this, I will use induction:\\n\\n### Induction Hypothesis\\nIf the largest battery has size at most $\\\\lfloor sum(batteries)/n\\\\rfloor$, then the solution is $\\\\lfloor sum(batteries)/n\\\\rfloor$.\\n\\n### Base Case\\nAll batteries have 0 power. This case should be trivial.\\n\\n### Inductie Step\\nAssume wlog that some battery is non-zero and that $n|sum(batteries)$.\\n\\n#### Case 1\\nSuppose there are less than n non-zero batteries. Since all batteries have power at most $\\\\lfloor sum(batteries)/n\\\\rfloor$, it follows that\\n\\n$$sum(batteries) \\\\geq (n-1)*sum(batteries)/n > sum(batteries)$$\\n\\nA contradiction.\\n\\n#### Case 2\\nSuppose there are over n batteries with value $sum(batteries)/n$.  It follows that\\n\\n$$sum(batteries) <= (n+1)*sum(batteries)/n < sum(batteries)+1$$\\n\\nAnother contradiction.\\n\\n#### Case 3\\n\\nUse the n largest batteries. After our opperation all batteries will have value at most $sum(batteries)/n - 1$, and our requirement is still satisfied. So we may use our induction hypothesis, and conclude our proof.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        sort(batteries.begin(), batteries.end());\\n        long long sum = accumulate(batteries.begin(), batteries.end(), 0ll);\\n        int i = batteries.size() - 1;\\n        \\n        while(batteries[i] > sum/n) {\\n            sum -= batteries[i];\\n            --i, --n;\\n        }\\n\\n        return sum/n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        sort(batteries.begin(), batteries.end());\\n        long long sum = accumulate(batteries.begin(), batteries.end(), 0ll);\\n        int i = batteries.size() - 1;\\n        \\n        while(batteries[i] > sum/n) {\\n            sum -= batteries[i];\\n            --i, --n;\\n        }\\n\\n        return sum/n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2515226,
                "title": "c-both-100-79ms-54-8mb-o-n-in-some-cases-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& b) {\\n        long long r=0,l=1e9,waste=0,m=b.size();\\n        for(int i=0;i<m;++i){\\n            l=min(l,(long long)b[i]);\\n            r+=b[i];\\n        }\\n        r/=n;\\n        for(int i=0;i<m&&!waste;++i)\\n            if(b[i]>r)waste=1;\\n        if(n==m)return l;\\n        if(!waste)return r;\\n        for(long long m,tar,judge;l<=r;judge?l=m+1:r=m-1){\\n            m=(l+r)/2,tar=m*n,judge=0;\\n            for(int i=0;i<b.size()&&!judge;++i){\\n                tar-=min(m,(long long)b[i]);\\n                if(tar<=0)judge = 1;\\n            }\\n        }\\n        return l-1;\\n    }\\n};\\n```\\n1.Let m = batteries.size(). When n=m, since each battery can only be paired to one computer, the answer will be min(batteries[i]), 0 < i < m.\\n2.Think about what the best answer would be?\\nThis answer will never exceed **sum(batteries[i])/n** Why?\\nBecause when the answer is equal to this value, it means that all batteries have been used up by the computer (even if there are remaining, there will be less than n power left).\\n3.**This value is the answer when no battery has more power than sum(batteries[i])/n.** Why?\\nSuppose \\'ans\\' is our answer. Since each battery can only contribute ans of power at most, when the power of a battery exceeds ans, it can only discard the extra part, that is, sum(min(ans,batteries[i])) can be provided.\\nAnd since no power is wasted, sum(min(ans,batteries[i])) = sum(batteries[i]) = ans*n , ans = sum(batteries[i])/n #\\n4.If there is waste, use binary search to find ans.",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& b) {\\n        long long r=0,l=1e9,waste=0,m=b.size();\\n        for(int i=0;i<m;++i){\\n            l=min(l,(long long)b[i]);\\n            r+=b[i];\\n        }\\n        r/=n;\\n        for(int i=0;i<m&&!waste;++i)\\n            if(b[i]>r)waste=1;\\n        if(n==m)return l;\\n        if(!waste)return r;\\n        for(long long m,tar,judge;l<=r;judge?l=m+1:r=m-1){\\n            m=(l+r)/2,tar=m*n,judge=0;\\n            for(int i=0;i<b.size()&&!judge;++i){\\n                tar-=min(m,(long long)b[i]);\\n                if(tar<=0)judge = 1;\\n            }\\n        }\\n        return l-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2348006,
                "title": "java-binary-search-explained",
                "content": "A pretty tricky problem. Luckily, we can determine if a given day is doable in `O(n)`\\n\\nSay, we are given a day `d`, and we would like to know if all `n` computers can run for `d` days. We can think of it like this:\\n1. If a battery has `>= d` energy, assign it to a computer for the duration of all `d` days. `+1` for count as we are able to get it done for 1 computer. We can\\'t use it for other computers during this time, so the excess energy is ignored.\\n\\n2. If a battery has `< d` energy, group it up with other batteries. If the total energy is `>= d`, subtract `d` from it because the remaining can be used for other computers and we have to also `+1` to the count, as we are able to make 1 computer run for `d` days.\\n\\n3. In the end, we check if `count >= n`, if so, we can make all `n` computers run for `d` days; otherwise, we can\\'t.\\n\\n#### Time Complexity O(log(1e14) * N)\\n#### Space O(1)\\n```Java\\nclass Solution {\\n    public long maxRunTime(int n, int[] batteries) {\\n        long lo = 0, hi = (long)1e14;\\n        while(lo < hi){\\n            long mid = (lo+hi+1)>>1;\\n            long sum = 0;\\n            int count = 0;\\n            for (int b : batteries){\\n                sum += Math.min(b, mid);\\n                if (sum >= mid){\\n                    sum -= mid;\\n                    count++;\\n                }\\n            }\\n            if (count >= n){\\n                lo=mid;\\n            }else{\\n                hi=mid-1;\\n            }\\n        }\\n        return lo;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```Java\\nclass Solution {\\n    public long maxRunTime(int n, int[] batteries) {\\n        long lo = 0, hi = (long)1e14;\\n        while(lo < hi){\\n            long mid = (lo+hi+1)>>1;\\n            long sum = 0;\\n            int count = 0;\\n            for (int b : batteries){\\n                sum += Math.min(b, mid);\\n                if (sum >= mid){\\n                    sum -= mid;\\n                    count++;\\n                }\\n            }\\n            if (count >= n){\\n                lo=mid;\\n            }else{\\n                hi=mid-1;\\n            }\\n        }\\n        return lo;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2212114,
                "title": "js-100-with-explanation",
                "content": "The idea is to remove batteries (and their corresponding computers) from the equation which we know will be used continually till the end. We do this because it shows us what power will be wasted, and we can remove it from the equation. Once we get to the point that we cannot obviously remove any more, the answer will magically be the average, truncated. I do not understand the proof behind this math, it all seems very presumptive, but some research revealed it to be so.\\n```\\nvar maxRunTime = function(n, batteries) {\\n    let total = batteries.reduce((acc,x)=>acc+x,0)\\n    let batts = batteries.sort((a,b)=>b-a)\\n    let i = 0\\n    while(1){\\n        let average_truncated = parseInt(total / n)\\n        let cur = batts[i]\\n        if(cur > average_truncated){\\n            total -= cur // remove all of that batteries charge from the equation\\n            n --         // remove the computer from the equation\\n            i++\\n        } else {\\n            return average_truncated\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxRunTime = function(n, batteries) {\\n    let total = batteries.reduce((acc,x)=>acc+x,0)\\n    let batts = batteries.sort((a,b)=>b-a)\\n    let i = 0\\n    while(1){\\n        let average_truncated = parseInt(total / n)\\n        let cur = batts[i]\\n        if(cur > average_truncated){\\n            total -= cur // remove all of that batteries charge from the equation\\n            n --         // remove the computer from the equation\\n            i++\\n        } else {\\n            return average_truncated\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2122540,
                "title": "binary-search-with-explanation",
                "content": "```\\n\\n/*\\n\\nith batter can run a computer for batt[i] minutes\\n\\nMax no of minutes we can run all the computers ?\\n\\nClearly\\n\\nafter a fix time we cannot charge all computers, we needs to find that highest time\\n\\nand before that time we can charge all the computers\\n\\nwe can find this max time by applying binary search on the range of minutes becouse charging all computers at any time in a range of times is a monotonic function\\n\\n[charging(t=1)......charging(t=x) notChargging(t=x+1).....notCharging(t=1e9)]\\n\\nAns=t=x\\n\\nBut how to check whether all computers can be charged or not charged till any fix time t ?\\n\\nto run all computers for time t:\\n     total time we needed= t*no of computers\\n     \\n     now for any battery of amount = x, we can use it = min(x,t) minutes during      the time of t minutes\\n     \\n     so we calculate total available time from all batteries\\n     \\n     if total available time >= total time, than it is possible to charge all        computers for time t simultaneously\\n\\n\\n*/\\n\\n\\n#define lln long long int\\n \\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& batt) {\\n        \\n        \\n        lln l=0;\\n        \\n        lln h=0;\\n        for(int x:batt){\\n            h+=x;\\n        }\\n        \\n        lln ans=0;\\n        \\n        while(l<=h){\\n            lln mid=(l+h)/2;\\n            \\n            if(isValid(n,mid,batt)){\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            \\n            else\\n                h=mid-1;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n     bool isValid(int n,lln mid,vector<int>&batt){\\n         \\n         lln totalTime=1ll*mid*n;\\n         \\n         lln avlTime=0;\\n         \\n         for(lln x:batt){\\n             avlTime+=min(x,mid);\\n         }\\n         \\n         if(avlTime>=totalTime)\\n             return true;\\n         \\n         return false;\\n     }\\n};",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& batt) {\\n        \\n        \\n        lln l=0;\\n        \\n        lln h=0;\\n        for(int x:batt){\\n            h+=x;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1839539,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        sort(batteries.begin(), batteries.end());\\n        if(batteries.size() == 1){\\n            return batteries[0];\\n        }\\n        long start = 0, end=0, mid, ans;\\n        for(int i=0; i<batteries.size(); i++){\\n            end = end + batteries[i];\\n        }\\n        while(start <= end){\\n            mid = start + (end-start)/2;\\n            if(isPossible(mid, batteries, n)){\\n                ans = mid;\\n                start = mid+1;\\n            }\\n            else{\\n                end = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    bool isPossible(long mid, vector<int>& batteries, int n){\\n        long ans = 0;\\n        for(int i=0; i<batteries.size(); i++){\\n            if(batteries[i] >= mid){\\n                ans = ans + mid;\\n            }\\n            else{\\n                ans = ans + batteries[i];\\n            }\\n        }\\n        if(ans / n  >= mid){\\n            return true;\\n        }\\n        return false;\\n    }   \\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        sort(batteries.begin(), batteries.end());\\n        if(batteries.size() == 1){\\n            return batteries[0];\\n        }\\n        long start = 0, end=0, mid, ans;\\n        for(int i=0; i<batteries.size(); i++){\\n            end = end + batteries[i];\\n        }\\n        while(start <= end){\\n            mid = start + (end-start)/2;\\n            if(isPossible(mid, batteries, n)){\\n                ans = mid;\\n                start = mid+1;\\n            }\\n            else{\\n                end = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    bool isPossible(long mid, vector<int>& batteries, int n){\\n        long ans = 0;\\n        for(int i=0; i<batteries.size(); i++){\\n            if(batteries[i] >= mid){\\n                ans = ans + mid;\\n            }\\n            else{\\n                ans = ans + batteries[i];\\n            }\\n        }\\n        if(ans / n  >= mid){\\n            return true;\\n        }\\n        return false;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723928,
                "title": "c-easy-to-understand-binary-search-approach-faster-than-97-38-of-c-online-submissions",
                "content": "\\n        \\n\\tclass Solution {\\n\\tpublic:\\n    bool canFit(int n,long timeSpan,vector<int>batteries)\\n    {\\n        long currBatSum=0;\\n\\t\\tlong targetBatSum=n*timeSpan; \\n        for(auto it:batteries)\\n        {\\n            if(it<timeSpan)\\n                currBatSum+=it;\\n            else\\n                currBatSum+=timeSpan;\\n            \\n            if(currBatSum>=targetBatSum)\\n                return true;  \\n        }\\n        \\n        return false;\\n     }\\n    \\n    long long maxRunTime(int n, vector<int>& batteries) {\\n      long totalSum=0;\\n      long low=*min_element(batteries.begin(),batteries.end());\\n      \\n        for(auto it:batteries)\\n        {\\n            totalSum+=it;  \\n        }\\n        \\n        long high = totalSum/n;\\n        long ans=-1;\\n        \\n        while(low<=high)\\n        {\\n         \\n          long mid = low+(high-low)/2;    \\n         if(canFit(n,mid,batteries))\\n         {\\n             ans=mid;\\n             low=mid+1;\\n         }\\n         else\\n         {\\n             high=mid-1;\\n         }\\n               \\n        }  \\n       return ans;       \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    bool canFit(int n,long timeSpan,vector<int>batteries)\\n    {\\n        long currBatSum=0;\\n\\t\\tlong targetBatSum=n*timeSpan; \\n        for(auto it:batteries)\\n        {\\n            if(it<timeSpan)\\n                currBatSum+=it;\\n            else\\n                currBatSum+=timeSpan;\\n            \\n            if(currBatSum>=targetBatSum)\\n                return true;  \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1716813,
                "title": "brute-force-optimize-approach-c-binary-search",
                "content": "**1st Approach --> Brute Force**\\n```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int k, vector<int>& arr){\\n        int n = arr.size();\\n        if(k > n) return 0;\\n        \\n        long long ans = 0;\\n        priority_queue<int> pq;\\n        \\n        for(auto it : arr){\\n            pq.push(it);\\n        }\\n        \\n        while(pq.size() >= k){\\n            vector<int> kBattery;\\n            int temp = k;\\n            while(temp--){\\n                kBattery.push_back(pq.top());\\n\\t\\t\\t\\tpq.pop();\\n            }\\n            for(auto &it : kBattery) it--;\\n            for(auto &it : kBattery) \\n                if(it > 0) pq.push(it);\\n            ans++;\\n        }   \\n        return ans;\\n    }\\n};\\n```\\n\\n**2nd Approach --> Binary Search**\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(long long mid,int n,vector<int>&arr){\\n        long long duration = 0;\\n        \\n        for(auto &it : arr){\\n            if(it < mid) duration += it;\\n            else duration += mid;\\n        }\\n        \\n        return (duration/n >= mid);\\n    }\\n    \\n    long long maxRunTime(int n, vector<int>& arr) {\\n        \\n        long long sum = 0;\\n        \\n        for(auto &it : arr) sum += it;\\n        \\n        long long st = 0 , en = sum , ans = 0;\\n        \\n        while(st <= en){\\n            long long mid = st + (en - st)/2;\\n            \\n            if(isPossible(mid,n,arr)){\\n                ans = mid , st = mid + 1;   \\n            }\\n            else{\\n                en = mid - 1;   \\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int k, vector<int>& arr){\\n        int n = arr.size();\\n        if(k > n) return 0;\\n        \\n        long long ans = 0;\\n        priority_queue<int> pq;\\n        \\n        for(auto it : arr){\\n            pq.push(it);\\n        }\\n        \\n        while(pq.size() >= k){\\n            vector<int> kBattery;\\n            int temp = k;\\n            while(temp--){\\n                kBattery.push_back(pq.top());\\n\\t\\t\\t\\tpq.pop();\\n            }\\n            for(auto &it : kBattery) it--;\\n            for(auto &it : kBattery) \\n                if(it > 0) pq.push(it);\\n            ans++;\\n        }   \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPossible(long long mid,int n,vector<int>&arr){\\n        long long duration = 0;\\n        \\n        for(auto &it : arr){\\n            if(it < mid) duration += it;\\n            else duration += mid;\\n        }\\n        \\n        return (duration/n >= mid);\\n    }\\n    \\n    long long maxRunTime(int n, vector<int>& arr) {\\n        \\n        long long sum = 0;\\n        \\n        for(auto &it : arr) sum += it;\\n        \\n        long long st = 0 , en = sum , ans = 0;\\n        \\n        while(st <= en){\\n            long long mid = st + (en - st)/2;\\n            \\n            if(isPossible(mid,n,arr)){\\n                ans = mid , st = mid + 1;   \\n            }\\n            else{\\n                en = mid - 1;   \\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1696248,
                "title": "java-solution-using-sorting-only",
                "content": "```\\nclass Solution {\\n    public long maxRunTime(int n, int[] batteries) {\\n        // return 0 if there are less batteries than the computers\\n        if(batteries.length<n){\\n            return 0;\\n        }\\n        \\n        int l=batteries.length;\\n        \\n        // Sort batteries in ascending order\\n        Arrays.sort(batteries);\\n    \\n    //batteries from batteries[start_pos] to batteries[l] are taken initially for n computers\\n        int pos=l-1;\\n        int start_pos=l;\\n        while((l-start_pos)<n){\\n            start_pos=pos--;\\n        }\\n        \\n     // all battery power of the remaining batteries are stored in rembat. Now our task to evenly distribute this rembat among the computers who have already n batteries (selected in above step)\\n        long rembat=0;\\n        while(pos>=0){\\n            rembat+=((long)batteries[pos--]);\\n        }\\n        \\n        long count=0;\\n        long sum=0;\\n        long prev=-1;\\n        long max_minutes=-1;\\n        \\n        pos=start_pos;\\n        while(pos<l){\\n            long curr = (long)(batteries[pos++]);\\n            if(count>0){\\n                long temp=sum+(curr-prev)*count;\\n                if(temp>rembat){\\n                    break;\\n                }else{\\n                    sum=temp;\\n                    max_minutes=curr;\\n                }\\n            }\\n           \\n            prev=curr;\\n            count++;\\n        }\\n        \\n        if(max_minutes==-1){ \\n            long first=(long)batteries[start_pos]+(rembat-sum);\\n            if(start_pos==(l-1)){\\n                max_minutes=first;\\n            }else{\\n                if(first<=batteries[start_pos+1]){\\n                    max_minutes=first;\\n                }else{\\n                    max_minutes=(long)batteries[start_pos+1];\\n                }\\n            }\\n            \\n        }else{\\n            rembat-=sum;\\n            max_minutes=prev+(rembat/count);\\n        }\\n        \\n        return max_minutes;\\n          \\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long maxRunTime(int n, int[] batteries) {\\n        // return 0 if there are less batteries than the computers\\n        if(batteries.length<n){\\n            return 0;\\n        }\\n        \\n        int l=batteries.length;\\n        \\n        // Sort batteries in ascending order\\n        Arrays.sort(batteries);\\n    \\n    //batteries from batteries[start_pos] to batteries[l] are taken initially for n computers\\n        int pos=l-1;\\n        int start_pos=l;\\n        while((l-start_pos)<n){\\n            start_pos=pos--;\\n        }\\n        \\n     // all battery power of the remaining batteries are stored in rembat. Now our task to evenly distribute this rembat among the computers who have already n batteries (selected in above step)\\n        long rembat=0;\\n        while(pos>=0){\\n            rembat+=((long)batteries[pos--]);\\n        }\\n        \\n        long count=0;\\n        long sum=0;\\n        long prev=-1;\\n        long max_minutes=-1;\\n        \\n        pos=start_pos;\\n        while(pos<l){\\n            long curr = (long)(batteries[pos++]);\\n            if(count>0){\\n                long temp=sum+(curr-prev)*count;\\n                if(temp>rembat){\\n                    break;\\n                }else{\\n                    sum=temp;\\n                    max_minutes=curr;\\n                }\\n            }\\n           \\n            prev=curr;\\n            count++;\\n        }\\n        \\n        if(max_minutes==-1){ \\n            long first=(long)batteries[start_pos]+(rembat-sum);\\n            if(start_pos==(l-1)){\\n                max_minutes=first;\\n            }else{\\n                if(first<=batteries[start_pos+1]){\\n                    max_minutes=first;\\n                }else{\\n                    max_minutes=(long)batteries[start_pos+1];\\n                }\\n            }\\n            \\n        }else{\\n            rembat-=sum;\\n            max_minutes=prev+(rembat/count);\\n        }\\n        \\n        return max_minutes;\\n          \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693545,
                "title": "sort-and-greedy-with-picture-java",
                "content": "![image](https://assets.leetcode.com/users/images/9b8b6ba5-f748-496e-8197-b71fd5c1d58a_1642312303.0122406.jpeg)\\n\\n\\n```\\nclass Solution {\\n    public long maxRunTime(int n, int[] batteries) {\\n        int len = batteries.length;\\n        int startIndex = len - n;\\n        \\n        Arrays.sort(batteries);\\n        long[] nBatteries = new long[n];\\n        for (int i = 0; i < n; i++) {\\n            nBatteries[i] = batteries[startIndex + i];\\n        }\\n        long refills = 0;\\n        for (int i = 0; i < startIndex; i++) {\\n            refills += batteries[i];\\n        }\\n        int index = 0;\\n        long maxRunTime = nBatteries[0];\\n        while (refills > 0 && index + 1 < n) {\\n            long delta = nBatteries[index + 1] - nBatteries[index];\\n            long totalDelta = delta * (index + 1);\\n            if (refills < totalDelta) {\\n                maxRunTime += (refills / (index + 1));\\n                return maxRunTime;\\n            }\\n            maxRunTime += delta;\\n            refills -= totalDelta;\\n            index++;\\n        }\\n        maxRunTime += (refills / n);\\n        return maxRunTime;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long maxRunTime(int n, int[] batteries) {\\n        int len = batteries.length;\\n        int startIndex = len - n;\\n        \\n        Arrays.sort(batteries);\\n        long[] nBatteries = new long[n];\\n        for (int i = 0; i < n; i++) {\\n            nBatteries[i] = batteries[startIndex + i];\\n        }\\n        long refills = 0;\\n        for (int i = 0; i < startIndex; i++) {\\n            refills += batteries[i];\\n        }\\n        int index = 0;\\n        long maxRunTime = nBatteries[0];\\n        while (refills > 0 && index + 1 < n) {\\n            long delta = nBatteries[index + 1] - nBatteries[index];\\n            long totalDelta = delta * (index + 1);\\n            if (refills < totalDelta) {\\n                maxRunTime += (refills / (index + 1));\\n                return maxRunTime;\\n            }\\n            maxRunTime += delta;\\n            refills -= totalDelta;\\n            index++;\\n        }\\n        maxRunTime += (refills / n);\\n        return maxRunTime;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693365,
                "title": "python-binary-search-solution",
                "content": "When we check, we check it simultaneously and greedily.\\n1. so if the battery is enough for the computer to run on target lenght of time, it is fully ocuppied. \\n2. If it is not enough, we can combine battery with smaller capacity to fullfil it.\\n3. if together more than the total capacity needed (`n*x`), then the target running time can be meet.\\n\\n```python\\n        l, r = 0, sum(batteries) // n + 1\\n        \\n        def check(x):\\n            return sum(min(x, b) for b in batteries) >= n * x  # required capacity\\n        \\n        while l <= r:\\n            mid = (l+r)//2\\n            if check(mid):\\n                l = mid+1\\n            else:\\n                r = mid-1\\n        return r\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```python\\n        l, r = 0, sum(batteries) // n + 1\\n        \\n        def check(x):\\n            return sum(min(x, b) for b in batteries) >= n * x  # required capacity\\n        \\n        while l <= r:\\n            mid = (l+r)//2\\n            if check(mid):\\n                l = mid+1\\n            else:\\n                r = mid-1\\n        return r\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1693300,
                "title": "go-clean-binary-search",
                "content": "```\\nfunc min(a int64, b int64) int64 {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc check(nums []int, mid int64, k int64) bool {\\n    var sum int64 = 0\\n    for i := 0; i < len(nums); i++ {\\n        sum += min(int64(nums[i]), mid)\\n    }\\n    return sum / k >= mid \\n}\\n\\nfunc maxRunTime(n int, nums []int) int64 {\\n    var l, r, res int64 = 0, 0, 0\\n    for i := 0; i < len(nums); i++ {\\n        r += int64(nums[i])\\n    }\\n    \\n    for l <= r {\\n        mid := l + (r - l) / 2\\n        if check(nums, mid, int64(n)) {\\n            res = mid\\n            l = mid + 1\\n        } else {\\n            r = mid - 1\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc min(a int64, b int64) int64 {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc check(nums []int, mid int64, k int64) bool {\\n    var sum int64 = 0\\n    for i := 0; i < len(nums); i++ {\\n        sum += min(int64(nums[i]), mid)\\n    }\\n    return sum / k >= mid \\n}\\n\\nfunc maxRunTime(n int, nums []int) int64 {\\n    var l, r, res int64 = 0, 0, 0\\n    for i := 0; i < len(nums); i++ {\\n        r += int64(nums[i])\\n    }\\n    \\n    for l <= r {\\n        mid := l + (r - l) / 2\\n        if check(nums, mid, int64(n)) {\\n            res = mid\\n            l = mid + 1\\n        } else {\\n            r = mid - 1\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1693238,
                "title": "swift-solution",
                "content": "```\\n    func maxRunTime(_ n: Int, _ batteries: [Int]) -> Int {\\n        let b = batteries.sorted(by: >)\\n        var t = batteries.reduce(0, +), i = 0\\n        while b[i] > t / (n - i) {\\n            t -= b[i]\\n            i += 1\\n        }\\n        return t / (n - i)\\n    }\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n    func maxRunTime(_ n: Int, _ batteries: [Int]) -> Int {\\n        let b = batteries.sorted(by: >)\\n        var t = batteries.reduce(0, +), i = 0\\n        while b[i] > t / (n - i) {\\n            t -= b[i]\\n            i += 1\\n        }\\n        return t / (n - i)\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1692975,
                "title": "python-o-n-log-n-greedy-solution-along-with-code",
                "content": "So, the first thing we need to know is if we have exactly n batteries, then the answer is the minimum of those n batteries. We cannot redistribute power among those n batteries.\\nNow, for m batteries, where m > n, we take the excess m - n batteries and distribute the cumulative power of those excess batteries intelligently (aka greedily) in the remaining n batteries.\\nNow, how do we choose the n batteries ? We choose the n most powerful batteries. The m-n least powerful batteries become the \\'excess\\' power batteries. \\nHence we require to sort the batteries (O(n log n)).\\nSo, all we need to do is take this extra power and keep giving/adding this extra power to the least powerful battery of the n batteries till we run out of power. The least powerful batter after all the excess power has been used up is our required answer. We can obviously use a heap, but I have proposed a simpler pointer based approach (assuming it\\'s already sorted) which you can see in the code.\\nNow, I am pretty sure there\\'s a rigorous mathematical way. to prove that we can always successfully use up the excess power of the batteries completely without leaving behind any of the excess power. I would really appreciate if any of the other posts prove that. However, this greedy approach made intuitive sense to me in the heat of the contest.\\n\\nPython 3 Code for the same:\\n```\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        batteries = sorted(batteries)\\n        m = len(batteries)\\n        final_batteries = batteries[-n:]\\n        dist_batteries = batteries[:-n]\\n        rem_power = sum(dist_batteries)\\n        curr_ind = 0\\n        while curr_ind < n - 1 and rem_power > 0:\\n            max_consumption = (final_batteries[curr_ind + 1] - final_batteries[curr_ind]) * (curr_ind + 1)\\n            if max_consumption <= rem_power:\\n                rem_power -= max_consumption\\n                curr_ind += 1\\n            else:\\n                return final_batteries[curr_ind] + (rem_power // (curr_ind + 1))\\n        if curr_ind == n-1:\\n            return final_batteries[curr_ind] + (rem_power // n)\\n        return final_batteries[curr_ind]\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        batteries = sorted(batteries)\\n        m = len(batteries)\\n        final_batteries = batteries[-n:]\\n        dist_batteries = batteries[:-n]\\n        rem_power = sum(dist_batteries)\\n        curr_ind = 0\\n        while curr_ind < n - 1 and rem_power > 0:\\n            max_consumption = (final_batteries[curr_ind + 1] - final_batteries[curr_ind]) * (curr_ind + 1)\\n            if max_consumption <= rem_power:\\n                rem_power -= max_consumption\\n                curr_ind += 1\\n            else:\\n                return final_batteries[curr_ind] + (rem_power // (curr_ind + 1))\\n        if curr_ind == n-1:\\n            return final_batteries[curr_ind] + (rem_power // n)\\n        return final_batteries[curr_ind]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1692966,
                "title": "c-binary-search-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    \\n    long long maxRunTime(int n, vector<int>& bat) {\\n        // Convert the given array to array of long long (so, that addition of battery powers may not exceed integer limit.)\\n        vector<ll> b;\\n        for(auto x:bat)b.push_back(x);\\n        \\n        // Sort the given battery powers in the ascending order.\\n        sort(b.begin(),b.end());\\n        \\n        // Extra batteries with minimum possible powers.\\n        ll m = b.size() - n;\\n        \\n        // Sum of extra battery\\'s powers.\\n        ll ss = accumulate(b.begin(),b.begin()+m, 0ll);\\n        \\n        // Variables for binary search.\\n        ll i = b[m], j = b[b.size()-1]+ss;\\n        ll ans = 0;\\n        \\n        while(i<=j){\\n            ll mid = i + (j-i)/2;\\n            // Variable to hold the minimum battery power if we try to distribute \\'ss\\' power over remaining batteries and try to make each battery\\'s power greater than equal to \\'mid\\'.\\n            ll a = LLONG_MAX;\\n            ll s = ss;\\n            for(int i=m;i<b.size();i++){\\n                ll hh = b[i];\\n                if(b[i]<mid){\\n                    if((mid-b[i])<=s){\\n                        s -= (mid-b[i]);\\n                        b[i] = mid;\\n                    }else{\\n                        b[i]+=s;\\n                        s = 0;\\n                    }\\n                }\\n                a = min(a, b[i]);\\n                b[i] = hh;\\n            }\\n            \\n            if(mid == a){\\n                ans = mid;\\n                i = mid+1;\\n            }else{\\n                j = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    \\n    long long maxRunTime(int n, vector<int>& bat) {\\n        // Convert the given array to array of long long (so, that addition of battery powers may not exceed integer limit.)\\n        vector<ll> b;\\n        for(auto x:bat)b.push_back(x);\\n        \\n        // Sort the given battery powers in the ascending order.\\n        sort(b.begin(),b.end());\\n        \\n        // Extra batteries with minimum possible powers.\\n        ll m = b.size() - n;\\n        \\n        // Sum of extra battery\\'s powers.\\n        ll ss = accumulate(b.begin(),b.begin()+m, 0ll);\\n        \\n        // Variables for binary search.\\n        ll i = b[m], j = b[b.size()-1]+ss;\\n        ll ans = 0;\\n        \\n        while(i<=j){\\n            ll mid = i + (j-i)/2;\\n            // Variable to hold the minimum battery power if we try to distribute \\'ss\\' power over remaining batteries and try to make each battery\\'s power greater than equal to \\'mid\\'.\\n            ll a = LLONG_MAX;\\n            ll s = ss;\\n            for(int i=m;i<b.size();i++){\\n                ll hh = b[i];\\n                if(b[i]<mid){\\n                    if((mid-b[i])<=s){\\n                        s -= (mid-b[i]);\\n                        b[i] = mid;\\n                    }else{\\n                        b[i]+=s;\\n                        s = 0;\\n                    }\\n                }\\n                a = min(a, b[i]);\\n                b[i] = hh;\\n            }\\n            \\n            if(mid == a){\\n                ans = mid;\\n                i = mid+1;\\n            }else{\\n                j = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1692931,
                "title": "c-solution-sort-binary-serach",
                "content": "\\n\\nNote: WA without sort.\\n```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& bt) {\\n        sort(bt.begin(), bt.end());\\n        long long l = 0, r = 1e18;\\n        long long ans = 0;\\n        while(l < r) {\\n            long long mid = (l + r) / 2;\\n            long long sum = 0, cnt = 0;\\n            for(long long x : bt) {\\n                if(sum + x >= mid) {\\n                    sum = sum + x - mid;\\n                    cnt++;\\n                }else sum += x;\\n            }\\n            if(cnt >= n) {\\n                l = mid + 1;\\n                ans = max(ans, mid);\\n            }else {\\n                r = mid;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& bt) {\\n        sort(bt.begin(), bt.end());\\n        long long l = 0, r = 1e18;\\n        long long ans = 0;\\n        while(l < r) {\\n            long long mid = (l + r) / 2;\\n            long long sum = 0, cnt = 0;\\n            for(long long x : bt) {\\n                if(sum + x >= mid) {\\n                    sum = sum + x - mid;\\n                    cnt++;\\n                }else sum += x;\\n            }\\n            if(cnt >= n) {\\n                l = mid + 1;\\n                ans = max(ans, mid);\\n            }else {\\n                r = mid;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1692925,
                "title": "java-binary-search",
                "content": "1. Sort batteries, assume we use the higher ones first\\n2. Calculate the extra charges we have (besides the highest n batteries)\\n3. Binary search a potential answer, check if we can split the extra charges and build up to the answer\\n\\n```\\nclass Solution {\\n    public long maxRunTime(int n, int[] batteries) {\\n        Arrays.sort(batteries);\\n        int len = batteries.length;\\n        long sum = 0;\\n        long extra = 0;\\n        for(int i=len-1; i>=0; i--) {\\n            sum += batteries[i];\\n            if(i<len-n) extra += batteries[i];\\n        }\\n        \\n        long r = sum/n;\\n        long l = batteries[len-n];\\n        while(l<=r) {\\n            long mid = (r-l)/2 + l;\\n            if(valid(n, batteries, mid, extra)) {\\n                l = mid+1;\\n            } else {\\n                r = mid-1;\\n            }\\n        }\\n        return r;\\n    }\\n    \\n    boolean valid(int n, int[] batteries, long time, long extra) {\\n        for(int i=batteries.length-1; i>=batteries.length-n; i--) {\\n            extra -= Math.max(0, time - batteries[i]);\\n            if(extra < 0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long maxRunTime(int n, int[] batteries) {\\n        Arrays.sort(batteries);\\n        int len = batteries.length;\\n        long sum = 0;\\n        long extra = 0;\\n        for(int i=len-1; i>=0; i--) {\\n            sum += batteries[i];\\n            if(i<len-n) extra += batteries[i];\\n        }\\n        \\n        long r = sum/n;\\n        long l = batteries[len-n];\\n        while(l<=r) {\\n            long mid = (r-l)/2 + l;\\n            if(valid(n, batteries, mid, extra)) {\\n                l = mid+1;\\n            } else {\\n                r = mid-1;\\n            }\\n        }\\n        return r;\\n    }\\n    \\n    boolean valid(int n, int[] batteries, long time, long extra) {\\n        for(int i=batteries.length-1; i>=batteries.length-n; i--) {\\n            extra -= Math.max(0, time - batteries[i]);\\n            if(extra < 0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946081,
                "title": "a-simple-approach-no-binarysearch-o-nlogn-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLook at this case below:\\n```\\n3\\n[1000, 1, 1, 1]\\n```\\nAlthough we have a 1000-minute battery, we can run the computers for only 1 minutes. \\n\\nThe 1000 battery is over capacity. Put it aside and the case is transformed to:\\n```\\n2\\n[1, 1, 1]\\n```\\nThe sum of [1, 1, 1] divided by 2 equals 1 (1.5 exactly), so the final output is 1. It has nothing to do with 1000.\\n\\nLeave out all over capacity batteries, and then, average capacity of  remained batteries will be the answer. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. sort vector b in descending order\\n2. calculate the sum of vector b \\n3. leave out all over-capacity batteries \\n4. return the value of the last avg\\n\\n# Complexity\\n- Time complexity: $$O(n + m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nNote: m = battery number\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& b) {\\n        sort(b.rbegin(), b.rend());\\n\\n        long long sum = 0, avg = 0;\\n        for (int x: b) sum += x;\\n\\n        int index = 0;\\n        while (n > 0 && b[index] > (avg = sum / n)) {\\n            sum -= b[index++];\\n            n--;\\n        }\\n\\n        return avg;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n3\\n[1000, 1, 1, 1]\\n```\n```\\n2\\n[1, 1, 1]\\n```\n```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& b) {\\n        sort(b.rbegin(), b.rend());\\n\\n        long long sum = 0, avg = 0;\\n        for (int x: b) sum += x;\\n\\n        int index = 0;\\n        while (n > 0 && b[index] > (avg = sum / n)) {\\n            sum -= b[index++];\\n            n--;\\n        }\\n\\n        return avg;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833766,
                "title": "java-binary-search-solution-with-detailed-intuition-and-explanation",
                "content": "# Intuition\\nIn this question the first intuition that needs to come into the mind is that if x minutes is not the possible answer then there is no use in checking for >x minutes but if x minutes is possible then we can and should check for a higher time as thats what is required by the answer\\nThe next and the main problem for this question is how to determine whether an answer is possible or not or whether we can run the computers simultaneously for a specific minutes :\\n   traverse the batteries array all the  batteries which have more than or equal the required minutes will be occupied for the whole duration and will suffice for one computer hence the remaining computers will be decreased by one,these batteries will not be available for swapping during the whole runtime,at the end of the traversal if the remaining computers are zero then the answer is possible , or if the batteries whose capacity is less than required have an average(on the basis of remaining computer) is greater or equal than the specified minutes then also the answer is possible\\n\\n# Approach\\nBinary search on answers can be used for avoiding the linear search in the possible answers\\nEdit:-\\nThe higher bound i have taken as one because the minimum possible computers are one and for that case the maximum possible answer is till all the batteries run out which is the sum of them\\n\\n# Complexity\\n- Time complexity:\\n  O(nlogn)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxRunTime(int n, int[] batteries) {\\n        long start = 1;\\n        long end = 0;\\n        for(int e : batteries){\\n            end+=e;\\n        }\\n        while(start<=end){\\n            long mid = start+(end-start)/2;\\n            if(isPossible(batteries,n,mid)){\\n                start=mid+1;\\n            }else{\\n                end=mid-1;\\n            }\\n        }\\n        return end;\\n    }\\n    public boolean isPossible (int [] batteries,int n,long min){\\n        int comp = n;\\n        long rem = 0;\\n        for(int e : batteries){\\n            if(e>=min){\\n                comp--;\\n                if(comp==0)return true;\\n            }else{\\n                rem+=e;\\n            }\\n        }\\n        return rem>=min*comp?true:false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public long maxRunTime(int n, int[] batteries) {\\n        long start = 1;\\n        long end = 0;\\n        for(int e : batteries){\\n            end+=e;\\n        }\\n        while(start<=end){\\n            long mid = start+(end-start)/2;\\n            if(isPossible(batteries,n,mid)){\\n                start=mid+1;\\n            }else{\\n                end=mid-1;\\n            }\\n        }\\n        return end;\\n    }\\n    public boolean isPossible (int [] batteries,int n,long min){\\n        int comp = n;\\n        long rem = 0;\\n        for(int e : batteries){\\n            if(e>=min){\\n                comp--;\\n                if(comp==0)return true;\\n            }else{\\n                rem+=e;\\n            }\\n        }\\n        return rem>=min*comp?true:false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829950,
                "title": "beats-100-clear-and-concise-explanation-no-binary-search-no-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTry to reach a state where all computers have same runtime by interchanging batteries, or it is not possible to Reach such state because of certain bottleneck batteries in your store.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n----------------------------------------------------------------------\\n**If you do not want to Read this big of a thought provoking approach, please Look at the code it has necessary comments for all lines.**\\n\\n----------------------------------------------------------------------\\nSort the Batteris as only the lower value batteries can stop you  from getting more runtime, so use your higher value batteries first.\\nnow declare the **higher n batteries** as your current active batteries(say **inuse** =list of **n** higher value batteries.).\\nWe also have the rest of the batteries sum of whose capacity is say **Bank_capacity.**\\nso the **bottleneck in your current inuse is the lowest value battery in your inuse list.**\\nI have sorted the batteries in reverse order so my lowest value battery is my index no n-1;\\nso my current bottleneck is at index no **i=n-1**\\nI will take a variavle c(stands for count) that would store how many such bottleneck batteries I have in my active batteries list currently.**After counting the number of such batteries , find the nearest battery that is bigger than this bottleneck battery(or batteries).** To equalise or get over this current bottleneck **we must \\ngive all such bottleneck batteries a power equal to the difference between this nearest higher capacity battery and the bottleneck batteries**(say this total is called Total power needed). Repeat this process untill all active batteries have the **same capacity**(say all n have x capacity), or it is not possible to give all of the bottleneck batteries a power equal to this Total power needed. in this case distibute whatever avilavle capacity is left in our Bank_capacity by making a **integer divison** of this capacity by number of bottleneck_batteries ,now return the bottleneck capacity+this distributed value.\\n\\n\\nIf all batteries have the same capacity distribute whatever power is left in my Bank_capacity in all n of the batteries.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSay we have M number of Batteris and N number of computers.\\nSorting takes O(MlogM) time by conventional sorting methods.\\nthe while loops together can run only n times till Bank_capacity is available so this has complexity of O(N).\\nTotal time complexity is O(MlogM)+O(N)==O(MlogM)\\n\\n**This part I am unsure about, if you find any mistake in this calculation, please comment your approach.**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nRequires O(n) of extra space but can easily be modified to run with \\nO(1) by not storing the inuse list of computers but using the batteries array instead.\\n\\n# Code\\n```\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        batteries.sort(reverse=True)\\n        inuse=batteries[:n]         #Batties in use by active computers\\n        bank=sum(batteries[n:])     #stores total resedue power\\n        i=n-1                       #index of my current bottleneck before start\\n        c=0                         #Total number of bottleneck batteries\\n        current_power=sum(inuse)    #Stores the amount of power inuse by all active computers currently\\n        while bank>0 and current_power!=n*inuse[0]:#stop when bank is empty or all computers have same batteries\\n            bottle_neck=inuse[i]                #the current ith battery is our bottleneck\\n            while i>=0 and inuse[i]==bottle_neck:   #count the number of bottlenecks\\n                c+=1\\n                i-=1\\n            power_per_battery=inuse[i]-bottle_neck  #calculate the amount of power our current bottleneck- \\n            power_needed=power_per_battery*(c)      #-batteries need\\n            if power_needed>bank:                  # if bank does not have thst much power distribute the\\n                return inuse[i+1]+bank//c          # leftover power equally to all bottleneck batteries\\n            else:\\n                bank-=power_needed                #Else Battery has the Required power so  \\n                current_power+=power_needed #decrese the power in the bank and increase the current consumption\\n        return inuse[i]+bank//n                 \\n\\n\\n\\n\\n\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        batteries.sort(reverse=True)\\n        inuse=batteries[:n]         #Batties in use by active computers\\n        bank=sum(batteries[n:])     #stores total resedue power\\n        i=n-1                       #index of my current bottleneck before start\\n        c=0                         #Total number of bottleneck batteries\\n        current_power=sum(inuse)    #Stores the amount of power inuse by all active computers currently\\n        while bank>0 and current_power!=n*inuse[0]:#stop when bank is empty or all computers have same batteries\\n            bottle_neck=inuse[i]                #the current ith battery is our bottleneck\\n            while i>=0 and inuse[i]==bottle_neck:   #count the number of bottlenecks\\n                c+=1\\n                i-=1\\n            power_per_battery=inuse[i]-bottle_neck  #calculate the amount of power our current bottleneck- \\n            power_needed=power_per_battery*(c)      #-batteries need\\n            if power_needed>bank:                  # if bank does not have thst much power distribute the\\n                return inuse[i+1]+bank//c          # leftover power equally to all bottleneck batteries\\n            else:\\n                bank-=power_needed                #Else Battery has the Required power so  \\n                current_power+=power_needed #decrese the power in the bank and increase the current consumption\\n        return inuse[i]+bank//n                 \\n\\n\\n\\n\\n\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826074,
                "title": "easy-solution-100-beats-binary-search",
                "content": "# Intuition\\nThe problem asks us to find the maximum run time for a robot with n batteries. We have an array batteries that contains the power of each battery. The robot can only run at a constant speed of time units per battery. We need to find the maximum value of time such that the robot can run for n units of time using the given batteries.\\n\\n# Approach\\nThe main function, maxRunTime, uses binary search to find the maximum time value. It starts with the left bound left = 1 and the right bound right = sumPower / n, where sumPower is the sum of all battery powers. Then, it performs binary search to find the maximum value of time that satisfies the condition check(n, batteries, time).\\n\\nThe check function calculates the total power that the robot can run using the given time and the battery powers. It iterates through the batteries and sums up the minimum of i and time, where i is the power of the current battery. This ensures that the robot can use at most time units of power from each battery. If the total sum of power obtained from all the batteries is greater than or equal to time * n, the function returns true, indicating that the robot can run for n units of time. Otherwise, it returns false.\\n\\n# Complexity\\n- Time complexity:\\nThe binary search takes O(log(sumPower / n)) iterations, and for each iteration, the check function takes O(n) time. So, the overall time complexity is O(n log(sumPower / n)).\\n- Space complexity:\\nThe space complexity is O(1) as we are using a constant amount of extra space to store variables.\\n# Code\\n```Java []\\nclass Solution {\\n    public boolean check(int n, int[] batteries, long time) {\\n        long sum = 0;\\n        for (int i : batteries) {\\n            sum += Math.min(i, time);\\n        }\\n        return (sum >= (long)time * n);\\n    }\\n    public long maxRunTime(int n, int[] batteries) {\\n        long sumPower = 0;\\n        for (int i : batteries) {\\n            sumPower+= i;\\n        }\\n        long left = 1, right = sumPower / n;\\n        \\n        while (left < right) {\\n            long time = (left + right + 1) / 2;\\n            if (check(n, batteries, time)) {\\n                left = time;\\n            }\\n            else {\\n                right = time - 1;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    long maxRunTime(int n, vector<int>& batteries) {\\n        long sumPower = 0;\\n        for (int power : batteries)\\n            sumPower += power;\\n        long left = 1, right = sumPower / n;\\n        \\n        while (left < right) {\\n            long time = (left + right + 1) / 2;\\n            if (check(batteries, n, time))\\n                left = time;\\n            else\\n                right = time - 1;\\n        }\\n        return left;\\n    }\\n    \\n    bool check(vector<int>& B, int n, long time) {\\n        long sum = 0;\\n        for (int battery : B) {\\n            sum += min(static_cast<long>(battery), time);\\n        }\\n        return (sum >= static_cast<long>(time) * n);\\n    }\\n};\\n```\\n```Python []\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        sumPower = sum(batteries)\\n        left, right = 1, sumPower // n\\n        \\n        while left < right:\\n            time = (left + right + 1) // 2\\n            if self.check(batteries, n, time):\\n                left = time\\n            else:\\n                right = time - 1\\n        return left\\n    \\n    def check(self, B: List[int], n: int, time: int) -> bool:\\n        total_power = sum(min(battery, time) for battery in B)\\n        return total_power >= time * n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Binary Search"
                ],
                "code": "```Java []\\nclass Solution {\\n    public boolean check(int n, int[] batteries, long time) {\\n        long sum = 0;\\n        for (int i : batteries) {\\n            sum += Math.min(i, time);\\n        }\\n        return (sum >= (long)time * n);\\n    }\\n    public long maxRunTime(int n, int[] batteries) {\\n        long sumPower = 0;\\n        for (int i : batteries) {\\n            sumPower+= i;\\n        }\\n        long left = 1, right = sumPower / n;\\n        \\n        while (left < right) {\\n            long time = (left + right + 1) / 2;\\n            if (check(n, batteries, time)) {\\n                left = time;\\n            }\\n            else {\\n                right = time - 1;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    long maxRunTime(int n, vector<int>& batteries) {\\n        long sumPower = 0;\\n        for (int power : batteries)\\n            sumPower += power;\\n        long left = 1, right = sumPower / n;\\n        \\n        while (left < right) {\\n            long time = (left + right + 1) / 2;\\n            if (check(batteries, n, time))\\n                left = time;\\n            else\\n                right = time - 1;\\n        }\\n        return left;\\n    }\\n    \\n    bool check(vector<int>& B, int n, long time) {\\n        long sum = 0;\\n        for (int battery : B) {\\n            sum += min(static_cast<long>(battery), time);\\n        }\\n        return (sum >= static_cast<long>(time) * n);\\n    }\\n};\\n```\n```Python []\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        sumPower = sum(batteries)\\n        left, right = 1, sumPower // n\\n        \\n        while left < right:\\n            time = (left + right + 1) // 2\\n            if self.check(batteries, n, time):\\n                left = time\\n            else:\\n                right = time - 1\\n        return left\\n    \\n    def check(self, B: List[int], n: int, time: int) -> bool:\\n        total_power = sum(min(battery, time) for battery in B)\\n        return total_power >= time * n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825956,
                "title": "c-binary-search",
                "content": "# Code\\n```\\nusing ll = long long;\\nclass Solution {\\npublic:\\n\\n  // this function checks if the total usable time (totalUsableTime) is greater than or equal \\n  // to the required time to run all \\'n\\' computers simultaneously (target * n).\\n  // If totalUsableTime is greater than or equal to the required time,\\n  // target time, and the function returns true. Otherwise, it returns false.\\n\\n  // We add the usable time of batteries to the totalUsableTime variable, which accumulates\\n  // the total usable time for all computers combined. This step accounts for how\\n  // much time can be utilized if all batteries were used simultaneously.\\n\\n  bool canRunAllComputers(int n, vector<int>& batteries, ll target){\\n    ll totalUsableTime  = 0;\\n    for(int it:batteries){\\n      totalUsableTime += it < target ? it : target;\\n    }\\n    return totalUsableTime >= target * n;\\n  }\\n  ll maxRunTime(int n, vector<int>& batteries) {\\n    ll totalTime = accumulate(batteries.begin(), batteries.end(), 0LL);\\n    // cout<<totalTime;\\n    ll l = 1, r = totalTime / n;\\n    ll ans = -1;\\n    while(l <= r){\\n      ll mid = l + (r - l) / 2;\\n      if(canRunAllComputers(n, batteries, mid)){\\n        ans = mid;\\n        l = mid + 1;\\n      }\\n      else r = mid - 1;\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nusing ll = long long;\\nclass Solution {\\npublic:\\n\\n  // this function checks if the total usable time (totalUsableTime) is greater than or equal \\n  // to the required time to run all \\'n\\' computers simultaneously (target * n).\\n  // If totalUsableTime is greater than or equal to the required time,\\n  // target time, and the function returns true. Otherwise, it returns false.\\n\\n  // We add the usable time of batteries to the totalUsableTime variable, which accumulates\\n  // the total usable time for all computers combined. This step accounts for how\\n  // much time can be utilized if all batteries were used simultaneously.\\n\\n  bool canRunAllComputers(int n, vector<int>& batteries, ll target){\\n    ll totalUsableTime  = 0;\\n    for(int it:batteries){\\n      totalUsableTime += it < target ? it : target;\\n    }\\n    return totalUsableTime >= target * n;\\n  }\\n  ll maxRunTime(int n, vector<int>& batteries) {\\n    ll totalTime = accumulate(batteries.begin(), batteries.end(), 0LL);\\n    // cout<<totalTime;\\n    ll l = 1, r = totalTime / n;\\n    ll ans = -1;\\n    while(l <= r){\\n      ll mid = l + (r - l) / 2;\\n      if(canRunAllComputers(n, batteries, mid)){\\n        ans = mid;\\n        l = mid + 1;\\n      }\\n      else r = mid - 1;\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3825213,
                "title": "c-super-easy-clean-code-binary-search-beats-100-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool isPossible(vector<int>& bat, long long time, int n){\\n        long long total = 0;\\n        int s = bat.size();\\n        for(int i=0; i<s; i++){\\n            total += min(time,1LL*bat[i]);\\n        }\\n        return total >= time * n;\\n    }\\npublic:\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n\\n        int bat = batteries.size();\\n\\n        long long low = batteries[0];\\n        long long high = 0;\\n\\n        for(int i=0; i<bat; i++){\\n            high += batteries[i];\\n            low = min(low,1LL * batteries[i]);\\n        }\\n\\n        long long ans = low;\\n\\n        while(low <= high){\\n            long long mid = (low + high) >> 1;\\n\\n            if(isPossible(batteries,mid,n)){\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isPossible(vector<int>& bat, long long time, int n){\\n        long long total = 0;\\n        int s = bat.size();\\n        for(int i=0; i<s; i++){\\n            total += min(time,1LL*bat[i]);\\n        }\\n        return total >= time * n;\\n    }\\npublic:\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n\\n        int bat = batteries.size();\\n\\n        long long low = batteries[0];\\n        long long high = 0;\\n\\n        for(int i=0; i<bat; i++){\\n            high += batteries[i];\\n            low = min(low,1LL * batteries[i]);\\n        }\\n\\n        long long ans = low;\\n\\n        while(low <= high){\\n            long long mid = (low + high) >> 1;\\n\\n            if(isPossible(batteries,mid,n)){\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825046,
                "title": "2141-maximum-running-time-of-n-computers-java",
                "content": "```\\nclass Solution {\\n    public long maxRunTime(int n, int[] batteries) {\\n        long stTime=0;\\n        long edTime=0;\\n        for(int x:batteries){\\n            edTime+=x;\\n        }\\n        long ans=0;\\n        while(stTime<=edTime){\\n            long mid=stTime + (edTime-stTime)/2;\\n            if(isPossible(n,batteries,mid)){\\n                ans=mid;\\n                stTime=mid+1;\\n            } else {\\n                edTime=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean isPossible(int n,int batteries[],long mid){\\n        long time=0;\\n        for(int i=0;i<batteries.length;i++){\\n            if(batteries[i]<=mid){\\n                time+=batteries[i];\\n            } else {\\n                time+=mid;\\n            }\\n        }\\n        return time>= mid*n;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long maxRunTime(int n, int[] batteries) {\\n        long stTime=0;\\n        long edTime=0;\\n        for(int x:batteries){\\n            edTime+=x;\\n        }\\n        long ans=0;\\n        while(stTime<=edTime){\\n            long mid=stTime + (edTime-stTime)/2;\\n            if(isPossible(n,batteries,mid)){\\n                ans=mid;\\n                stTime=mid+1;\\n            } else {\\n                edTime=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean isPossible(int n,int batteries[],long mid){\\n        long time=0;\\n        for(int i=0;i<batteries.length;i++){\\n            if(batteries[i]<=mid){\\n                time+=batteries[i];\\n            } else {\\n                time+=mid;\\n            }\\n        }\\n        return time>= mid*n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824428,
                "title": "beats-100-in-runtime-and-98-in-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxRunTime(self, n, batteries):\\n        m = len(batteries)\\n        if n==m:\\n            return min(batteries)\\n        if m < n:\\n            return 0\\n        batteries.sort()\\n        S = sum(batteries)\\n        T = S//n\\n        for i in range(1,n):\\n            S -= batteries[-i]\\n            T = min(T, S//(n-i))\\n        return T        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxRunTime(self, n, batteries):\\n        m = len(batteries)\\n        if n==m:\\n            return min(batteries)\\n        if m < n:\\n            return 0\\n        batteries.sort()\\n        S = sum(batteries)\\n        T = S//n\\n        for i in range(1,n):\\n            S -= batteries[-i]\\n            T = min(T, S//(n-i))\\n        return T        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824420,
                "title": "c-binary-search",
                "content": "# Complexity\\n- Time complexity: \\n1. `O(n log n) --> for Sorting the array`\\n2. `O(n log m) --> for Binary search`\\n\\n   - `m = Summation Of Array Elements`\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(long long time, int computer, long long totalSum, vector<int>& batteries){\\n\\n        int n = batteries.size();\\n\\n        for(int i=n-1;i>=0;i--){\\n\\n            if(batteries[i] >= time){\\n                computer--;\\n                totalSum -= batteries[i];\\n            }\\n            else if(computer && (totalSum/computer) >= time) return true;\\n\\n        }\\n\\n        return computer <= 0;\\n\\n    }\\n\\n    long long maxRunTime(int computer, vector<int>& batteries) {\\n\\n        sort(batteries.begin(),batteries.end());\\n\\n        int n = batteries.size();\\n        long long totalSum = 0;\\n\\n        for(int i=0;i<n;i++){\\n            totalSum += batteries[i];\\n        }\\n\\n        long long lo = 0 , hi = totalSum;\\n        long long maxTime = 0;\\n\\n        while(lo <= hi){\\n\\n            long long mid = lo + (hi - lo) / 2;\\n\\n            if(isPossible(mid,computer,totalSum,batteries)){\\n                maxTime = mid;\\n                lo = mid + 1;\\n            }\\n            else{\\n                hi = mid - 1;\\n            }\\n        }\\n\\n        return maxTime;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(long long time, int computer, long long totalSum, vector<int>& batteries){\\n\\n        int n = batteries.size();\\n\\n        for(int i=n-1;i>=0;i--){\\n\\n            if(batteries[i] >= time){\\n                computer--;\\n                totalSum -= batteries[i];\\n            }\\n            else if(computer && (totalSum/computer) >= time) return true;\\n\\n        }\\n\\n        return computer <= 0;\\n\\n    }\\n\\n    long long maxRunTime(int computer, vector<int>& batteries) {\\n\\n        sort(batteries.begin(),batteries.end());\\n\\n        int n = batteries.size();\\n        long long totalSum = 0;\\n\\n        for(int i=0;i<n;i++){\\n            totalSum += batteries[i];\\n        }\\n\\n        long long lo = 0 , hi = totalSum;\\n        long long maxTime = 0;\\n\\n        while(lo <= hi){\\n\\n            long long mid = lo + (hi - lo) / 2;\\n\\n            if(isPossible(mid,computer,totalSum,batteries)){\\n                maxTime = mid;\\n                lo = mid + 1;\\n            }\\n            else{\\n                hi = mid - 1;\\n            }\\n        }\\n\\n        return maxTime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824305,
                "title": "binary-search-for-maximum-computer-runtime-allocation-easy-to-understand-solved-with",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n Use binary search to efficiently find the maximum runtime for each computer based on the battery capacities.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code utilizes a binary search-based approach to find the maximum runtime that can be allocated to each computer while ensuring they receive at least the allocated runtime.\\n\\n# Complexity\\n- Time complexity: O(log(max_runtime)),\\n where max_runtime is the maximum possible runtime value.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\n      typedef long long ll;\\n\\n      bool isPossible(vector<int>&arr,int n,ll mid)\\n      {\\n          ll minTimeReq=(ll)mid*n;\\n          for(int i=0;i<arr.size();i++)\\n          {\\n              minTimeReq-=min((ll)arr[i],mid);\\n\\n              if(minTimeReq<=0)\\n              return true;\\n          }\\n\\n          return false;\\n\\n      }\\n\\npublic:\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n      ll left=*min_element(batteries.begin(),batteries.end());\\n      ll sum=0;\\n      ll ans=0;\\n       for(int i=0;i<batteries.size();i++)\\n       {\\n            sum+=(ll)batteries[i];\\n       }\\n\\n       ll right=(ll)(sum/n);\\n\\n       while(left<=right)\\n       {\\n           ll mid=left+(right-left)/2;\\n\\n           if(isPossible(batteries,n,mid))\\n           {\\n               ans=mid;\\n               left=mid+1;\\n           }else\\n           {\\n               right=mid-1;\\n           }\\n       }\\n\\n\\n  return ans;\\n\\n\\n        \\n    }\\n}; \\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n      typedef long long ll;\\n\\n      bool isPossible(vector<int>&arr,int n,ll mid)\\n      {\\n          ll minTimeReq=(ll)mid*n;\\n          for(int i=0;i<arr.size();i++)\\n          {\\n              minTimeReq-=min((ll)arr[i],mid);\\n\\n              if(minTimeReq<=0)\\n              return true;\\n          }\\n\\n          return false;\\n\\n      }\\n\\npublic:\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n      ll left=*min_element(batteries.begin(),batteries.end());\\n      ll sum=0;\\n      ll ans=0;\\n       for(int i=0;i<batteries.size();i++)\\n       {\\n            sum+=(ll)batteries[i];\\n       }\\n\\n       ll right=(ll)(sum/n);\\n\\n       while(left<=right)\\n       {\\n           ll mid=left+(right-left)/2;\\n\\n           if(isPossible(batteries,n,mid))\\n           {\\n               ans=mid;\\n               left=mid+1;\\n           }else\\n           {\\n               right=mid-1;\\n           }\\n       }\\n\\n\\n  return ans;\\n\\n\\n        \\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824160,
                "title": "c-easy-6-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    long long maxRunTime(int n, vector<int>& bat) \\n    {\\n        long long total_time = 0; \\n        for(auto x : bat)\\n        total_time += x; \\n        sort(bat.rbegin(), bat.rend()); \\n        for(int i = 0; i < bat.size(); i++, n--) \\n        {\\n            if(bat[i] <= (total_time / n)) break;\\n            total_time -= bat[i]; \\n        }\\n        return total_time / n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    long long maxRunTime(int n, vector<int>& bat) \\n    {\\n        long long total_time = 0; \\n        for(auto x : bat)\\n        total_time += x; \\n        sort(bat.rbegin(), bat.rend()); \\n        for(int i = 0; i < bat.size(); i++, n--) \\n        {\\n            if(bat[i] <= (total_time / n)) break;\\n            total_time -= bat[i]; \\n        }\\n        return total_time / n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823975,
                "title": "binary-search",
                "content": "TLE:\\n```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int c, vector<int>& b) {\\n        int n = b.size();\\n        priority_queue<int> pq;\\n        for(auto i: b)\\n        {\\n            pq.push(i);\\n        }\\n        \\n        int res = 0;\\n        while(1)\\n        {\\n            int t = c;\\n            bool f = false;\\n            vector<int > a;\\n            while(t>0)\\n            {\\n                int v = pq.top();\\n                // cout<<v<<endl;\\n                pq.pop();\\n                if(v == 0)\\n                {\\n                    f=1;\\n                    break;\\n                }\\n                v--;\\n                a.push_back(v);\\n                t--;\\n                \\n                \\n            }\\n            \\n            \\n            \\n            \\n            if(f)\\n                break;\\n             res++;\\n            \\n            \\n            for(auto p : a)\\n            {\\n                pq.push(p);\\n            }\\n            \\n           \\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n\\nacc :\\n\\n```\\n\\nclass Solution {\\npublic:\\n    \\n    bool check(vector<int>& b, long long int mid, int n)\\n    {\\n        long long int t = n*mid;\\n        long long int sum = 0;\\n        for(int i:b)\\n        {\\n            sum+=min((long long int)i,mid);\\n            if(sum>=t)\\n                return true;\\n        }\\n        \\n        return false;\\n        \\n        \\n    }\\n    long long maxRunTime(int c, vector<int>& b) {\\n        long long int n = b.size();\\n        long long int res = 0;\\n        \\n        long long int l = *min_element(b.begin(),b.end());\\n        long long int r = (accumulate(b.begin(),b.end(),0LL))/c;\\n\\n        while(l<=r)\\n        {\\n            long long int mid = (l+r)/2;\\n            bool x = check(b,mid,c);\\n            if(x)\\n            {\\n                res  = mid;\\n                l = mid+1;\\n            }\\n            else\\n            {\\n                r = mid -1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int c, vector<int>& b) {\\n        int n = b.size();\\n        priority_queue<int> pq;\\n        for(auto i: b)\\n        {\\n            pq.push(i);\\n        }\\n        \\n        int res = 0;\\n        while(1)\\n        {\\n            int t = c;\\n            bool f = false;\\n            vector<int > a;\\n            while(t>0)\\n            {\\n                int v = pq.top();\\n                // cout<<v<<endl;\\n                pq.pop();\\n                if(v == 0)\\n                {\\n                    f=1;\\n                    break;\\n                }\\n                v--;\\n                a.push_back(v);\\n                t--;\\n                \\n                \\n            }\\n            \\n            \\n            \\n            \\n            if(f)\\n                break;\\n             res++;\\n            \\n            \\n            for(auto p : a)\\n            {\\n                pq.push(p);\\n            }\\n            \\n           \\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    \\n    bool check(vector<int>& b, long long int mid, int n)\\n    {\\n        long long int t = n*mid;\\n        long long int sum = 0;\\n        for(int i:b)\\n        {\\n            sum+=min((long long int)i,mid);\\n            if(sum>=t)\\n                return true;\\n        }\\n        \\n        return false;\\n        \\n        \\n    }\\n    long long maxRunTime(int c, vector<int>& b) {\\n        long long int n = b.size();\\n        long long int res = 0;\\n        \\n        long long int l = *min_element(b.begin(),b.end());\\n        long long int r = (accumulate(b.begin(),b.end(),0LL))/c;\\n\\n        while(l<=r)\\n        {\\n            long long int mid = (l+r)/2;\\n            bool x = check(b,mid,c);\\n            if(x)\\n            {\\n                res  = mid;\\n                l = mid+1;\\n            }\\n            else\\n            {\\n                r = mid -1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3823890,
                "title": "easy-c-solution-with-easy-to-understand-and-beat-99-64-in-run-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1)Initialize the search space for the maximum runtime value: We can set the lower bound of the search space to the minimum battery capacity and the upper bound to the sum of all battery capacities divided by \\'n\\'. These bounds represent the minimum and maximum possible runtime values.\\n\\n2)Perform binary search: In each iteration, calculate the mid value of the search space as (lower_bound + upper_bound) / 2. Check if the robot can complete its task with the mid runtime value using a helper function that verifies the given conditions. If the robot can complete the task, update the result to the current mid value and narrow the search space to the right. Otherwise, narrow the search space to the left.\\n\\n3)Continue the binary search until the lower bound is less than or equal to the upper bound.\\n\\nReturn the result as the maximum runtime value\\n**Remember I use static_cast because it help in run time  while compling and use to convert type of variable.**\\n\\n# Complexity\\n- Time complexity:O(n+log(e))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n    bool condition(vector<int>& batterie,long long mid,int n){\\n        long long max_min=mid*n;\\n        for(int i=0;i<batterie.size();i++){\\n            max_min -=min(static_cast<long long>(batterie[i]),mid);\\n        }\\n        if(max_min<=0) return true;\\n        else return false;\\n    }\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        long long l=*min_element (batteries.begin(), batteries.end());\\n        long long sum_min= accumulate(batteries.begin(), batteries.end(),static_cast<long long>(0));\\n        long long e =sum_min/n;\\n        long long result=static_cast<long long>(0);\\n        while(l<=e){\\n            long long mid=l+(e-l)/2;\\n            if(condition(batteries,mid,n)){\\n                result=mid;\\n                l=mid+1;\\n            }\\n            else e=mid-1;\\n        } \\n\\n        return result;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    bool condition(vector<int>& batterie,long long mid,int n){\\n        long long max_min=mid*n;\\n        for(int i=0;i<batterie.size();i++){\\n            max_min -=min(static_cast<long long>(batterie[i]),mid);\\n        }\\n        if(max_min<=0) return true;\\n        else return false;\\n    }\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        long long l=*min_element (batteries.begin(), batteries.end());\\n        long long sum_min= accumulate(batteries.begin(), batteries.end(),static_cast<long long>(0));\\n        long long e =sum_min/n;\\n        long long result=static_cast<long long>(0);\\n        while(l<=e){\\n            long long mid=l+(e-l)/2;\\n            if(condition(batteries,mid,n)){\\n                result=mid;\\n                l=mid+1;\\n            }\\n            else e=mid-1;\\n        } \\n\\n        return result;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823538,
                "title": "python-line-by-line-explanation",
                "content": "# Intuition\\nThe code utilizes a sorting and iteration approach to find the solution.\\n\\n# Approach\\nThe given code calculates the maximum runtime for running all the n computers simultaneously using the given batteries. The code utilizes a sorting and iteration approach to find the solution.\\n\\n\\n\\n1. `batteries.sort()`: The code sorts the array of batteries in ascending order. Sorting is performed so that we can consider the n largest batteries for our computation.\\n\\n2. `extra = sum(batteries[:-n])`: The code calculates the sum of all batteries except the n largest ones, and stores it in the variable `extra`. This represents the total energy provided by extra batteries.\\n\\n3. `live = batteries[-n:]`: The code selects the last n batteries from the sorted list and stores them in the `live` variable. These are the n largest batteries that will be used for running the computers.\\n\\n4. The code then iterates over the `live` array using a loop. It checks if there is enough energy in the `extra` batteries to support the difference in energy between consecutive batteries. If there\\'s enough energy, it subtracts the required amount from the `extra` batteries. If there\\'s not enough energy, it calculates the minimum time the computers can run with the given batteries and returns that value.\\n\\n5. After the loop, if it has not returned any value, it means all batteries have equal energy, and the code returns the last battery\\'s energy with the remaining `extra` energy divided equally among all batteries.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxRunTime(self, n, batteries):\\n        \"\"\"\\n        :type n: int\\n        :type batteries: List[int]\\n        :rtype: int\\n        \"\"\"\\n        batteries.sort()\\n        extra = sum(batteries[:-n])\\n        live = batteries[-n:]\\n        for i in range(n - 1):\\n            if extra // (i + 1) > live[i + 1] - live[i]: \\n                extra -= (i + 1) * (live[i + 1] - live[i])\\n            else:\\n                return live[i] + extra // (i + 1) \\n\\n        return live[-1] + extra // n\\n        \\n```\\n# **PLEASE DO UPVOTE!!!\\uD83E\\uDD79**",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxRunTime(self, n, batteries):\\n        \"\"\"\\n        :type n: int\\n        :type batteries: List[int]\\n        :rtype: int\\n        \"\"\"\\n        batteries.sort()\\n        extra = sum(batteries[:-n])\\n        live = batteries[-n:]\\n        for i in range(n - 1):\\n            if extra // (i + 1) > live[i + 1] - live[i]: \\n                extra -= (i + 1) * (live[i + 1] - live[i])\\n            else:\\n                return live[i] + extra // (i + 1) \\n\\n        return live[-1] + extra // n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823431,
                "title": "python-solution-array-sorting-beats-100",
                "content": "![Screenshot_11.png](https://assets.leetcode.com/users/images/c9612c94-ccfa-432e-bc6f-3a91d7b0a707_1690457384.9143794.png)\\n# Complexity\\n- Time complexity:\\n$$O(m\\u22C5log\\u2061m)$$\\n\\n- Space complexity:\\n$$O(m)$$\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n\\n        # array sorting\\n        batteries.sort()\\n\\n        # getting the energy of all extra batteries\\n        extra = sum(batteries[:-n])\\n\\n        # earlier we sorted an array to get n the largest batteries that our computers will use\\n        live = batteries[-n:]\\n\\n        # iterate over an array live\\n        for i in range(n - 1):\\n            \\n            # if extra has enough energy for our batteries (indexed from 0 to i), we take energy from extra\\n            # if hasn\\'t, return the value of smallest battery + all energy that can be provided for one battery\\n            if extra // (i + 1) > live[i + 1] - live[i]: \\n                extra -= (i + 1) * (live[i + 1] - live[i])\\n            else:\\n                return live[i] + extra // (i + 1) \\n        \\n        # if we got there, all batteries have equal energy, so we return the last battery with remaining energy, provided for all  batteries\\n        return live[-1] + extra // n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n\\n        # array sorting\\n        batteries.sort()\\n\\n        # getting the energy of all extra batteries\\n        extra = sum(batteries[:-n])\\n\\n        # earlier we sorted an array to get n the largest batteries that our computers will use\\n        live = batteries[-n:]\\n\\n        # iterate over an array live\\n        for i in range(n - 1):\\n            \\n            # if extra has enough energy for our batteries (indexed from 0 to i), we take energy from extra\\n            # if hasn\\'t, return the value of smallest battery + all energy that can be provided for one battery\\n            if extra // (i + 1) > live[i + 1] - live[i]: \\n                extra -= (i + 1) * (live[i + 1] - live[i])\\n            else:\\n                return live[i] + extra // (i + 1) \\n        \\n        # if we got there, all batteries have equal energy, so we return the last battery with remaining energy, provided for all  batteries\\n        return live[-1] + extra // n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823210,
                "title": "100-speedrun-crushed-it-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[]} batteries\\n * @return {number}\\n */\\nvar maxRunTime = function(n, batteries) {\\n    let sumPower=0;\\n    for(let power of batteries)\\n        sumPower +=power;\\n    let left=1;\\n    let right=Math.ceil(sumPower/n);\\n    while(left<right){\\n        let target=right-Math.floor((right-left)/2);\\n        let extra=0;\\n        for(let power of batteries)\\n          extra+=Math.min(power,target);\\n        if(extra>=(n*target))  \\n         left=target;\\n        else\\n         right=target-1; \\n    }\\nreturn left;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[]} batteries\\n * @return {number}\\n */\\nvar maxRunTime = function(n, batteries) {\\n    let sumPower=0;\\n    for(let power of batteries)\\n        sumPower +=power;\\n    let left=1;\\n    let right=Math.ceil(sumPower/n);\\n    while(left<right){\\n        let target=right-Math.floor((right-left)/2);\\n        let extra=0;\\n        for(let power of batteries)\\n          extra+=Math.min(power,target);\\n        if(extra>=(n*target))  \\n         left=target;\\n        else\\n         right=target-1; \\n    }\\nreturn left;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3823179,
                "title": "binary-search-proper-intuition-binar-93-faster",
                "content": "# Intuition \\uD83C\\uDF96\\uD83C\\uDF96\\nThe problem described  is finding the maximum possible run time for a group of computers **(n)** powered by **batteries** (input array) . Each computer has its own battery **(battries[i])**, and the batteries have different charging times. The goal is to find the **maximum amount of time all the computers can run (simultaniously)** with the available battery charge.\\n# Approach \\uD83C\\uDF96\\uD83C\\uDF96\\n**possible Function:**\\nThis function is a helper function that checks if it\\'s possible for all the computers to run for a given mid_time.\\n\\nIt calculates the total available charge target for all computers combined at the current mid_time, which is**n * mid_time minutes**. This represents the time each computer will run for mid_time minutes.\\n\\nIt then iterates through the individual battery charge times in the batteries vector and **deducts the minimum of batteries[i] and mid_time from the target.**\\n\\n This operation simulates how much charge will be used by each computer during this time.\\n\\n# Complexity\\n- Time complexity:\\n    O(m\\u22C5logk) - m = input array length and k = range of minutes \\n\\n- Space complexity:\\n   O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    //helper function\\n    bool possible(vector<int>& batteries, ll mid_time, int n) {\\n        \\n        ll target = n * mid_time; //each computer will run mid_time minutes\\n        \\n        ll sum = 0;\\n        \\n        for(int i = 0; i<batteries.size(); i++) {\\n            \\n            target -= min((ll)batteries[i], mid_time);\\n            \\n            if(target <= 0)\\n            return true;\\n            \\n        }\\n        return target <= 0;\\n    }\\n    \\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        \\n        ll l = *min_element(begin(batteries), end(batteries));\\n        \\n        long long sum_total_minutes = 0;\\n        \\n        for(auto &mints : batteries){\\n            sum_total_minutes += mints;\\n        }\\n        \\n        ll r = sum_total_minutes/n;\\n        \\n        ll result = 0;\\n        \\n        while(l <= r) {\\n            \\n            ll mid_time = l + (r-l)/2;\\n            \\n            if(possible(batteries, mid_time, n)) {\\n                result = mid_time;\\n                l = mid_time+1;\\n            } else {\\n                r = mid_time-1;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n//video link for help :: https://www.youtube.com/watch?v=CdqZNsvVSS4\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    //helper function\\n    bool possible(vector<int>& batteries, ll mid_time, int n) {\\n        \\n        ll target = n * mid_time; //each computer will run mid_time minutes\\n        \\n        ll sum = 0;\\n        \\n        for(int i = 0; i<batteries.size(); i++) {\\n            \\n            target -= min((ll)batteries[i], mid_time);\\n            \\n            if(target <= 0)\\n            return true;\\n            \\n        }\\n        return target <= 0;\\n    }\\n    \\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        \\n        ll l = *min_element(begin(batteries), end(batteries));\\n        \\n        long long sum_total_minutes = 0;\\n        \\n        for(auto &mints : batteries){\\n            sum_total_minutes += mints;\\n        }\\n        \\n        ll r = sum_total_minutes/n;\\n        \\n        ll result = 0;\\n        \\n        while(l <= r) {\\n            \\n            ll mid_time = l + (r-l)/2;\\n            \\n            if(possible(batteries, mid_time, n)) {\\n                result = mid_time;\\n                l = mid_time+1;\\n            } else {\\n                r = mid_time-1;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n//video link for help :: https://www.youtube.com/watch?v=CdqZNsvVSS4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823178,
                "title": "c-beats-99-87-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #include <vector>\\n#include <algorithm>\\n\\n\\n\\nlong long maxRunTime(int n, vector<int>& batteries) {\\n    sort(batteries.begin(), batteries.end());\\n    long long extra = 0;\\n    for (int i = 0; i < batteries.size() - n; i++) {\\n        extra += batteries[i];\\n    }\\n\\n    vector<int> live(batteries.begin() + batteries.size() - n, batteries.end());\\n\\n    for (int i = 0; i < n - 1; i++) {\\n        if (extra < static_cast<long long>((i + 1) * (live[i + 1] - live[i]))) {\\n            return live[i] + extra / static_cast<long long>(i + 1);\\n        }\\n        extra -= static_cast<long long>((i + 1) * (live[i + 1] - live[i]));\\n    }\\n\\n    return live[n - 1] + extra / n;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #include <vector>\\n#include <algorithm>\\n\\n\\n\\nlong long maxRunTime(int n, vector<int>& batteries) {\\n    sort(batteries.begin(), batteries.end());\\n    long long extra = 0;\\n    for (int i = 0; i < batteries.size() - n; i++) {\\n        extra += batteries[i];\\n    }\\n\\n    vector<int> live(batteries.begin() + batteries.size() - n, batteries.end());\\n\\n    for (int i = 0; i < n - 1; i++) {\\n        if (extra < static_cast<long long>((i + 1) * (live[i + 1] - live[i]))) {\\n            return live[i] + extra / static_cast<long long>(i + 1);\\n        }\\n        extra -= static_cast<long long>((i + 1) * (live[i + 1] - live[i]));\\n    }\\n\\n    return live[n - 1] + extra / n;\\n}\\n\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3823051,
                "title": "c-solution-binary-search-supereasy-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n                                `  Binary Search`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. `bool isPoss(vector<int>&batteries, long long time, int computers)`: This function checks if it is possible to distribute the power of the batteries in a way that each computer gets at least time units of power. The function takes three parameters:\\n\\n2. `batteries`: A reference to the vector containing battery power values.\\n`time`: The time units each computer should receive.\\n`computers`: The number of computers.\\nIt uses a loop to go through each battery\\'s power in the batteries vector and calculates the total time that can be provided to all computers based on the minimum of time and each battery\\'s power. The total time is stored in the variable `totalTime`.\\n\\n3. The function returns `true` if the total time provided to each computer is greater than or equal to time, indicating that it is possible to distribute the power as required, and `false` otherwise.\\n\\n4. `long long maxRunTime(int n, vector<int>& batteries)`: This function aims to find the maximum run time for the computers by using binary search. The input parameters are:\\n\\n5. `n`: The number of computers.\\n`batteries`: A reference to the vector containing battery power values.\\nIt initializes two long long variables `l` (low) and `h` (high) to `0` and `1e14`  respectively. These variables represent the lower and upper bounds for the binary search.\\n\\n6. A long long variable `res` is initialized to 0, which will eventually hold the maximum run time achieved.\\n\\n7. The function then enters a binary search loop, repeatedly calculating the middle value mid between l and h. It calls the `isPoss()` function with the current mid value as the time argument. If isPoss() returns `true`, it means the current mid value is a possible maximum run time, so it updates res to store the maximum run time found so far and moves the `l` (low) pointer to `mid + 1` to search for higher values. Otherwise, if `isPoss()` returns `false`, it means the current mid value is too high, and the `h` (high) pointer is moved to `mid - 1` to search for lower values.\\n\\n8. The binary search continues until l is less than or equal to h. Once the search ends, the maximum run time `res` is returned as the result.\\n\\n# Complexity\\n- Time complexity:$$O(m\\u22C5logk)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPoss(vector<int>&batteries,long long time,int computers){\\n\\n        long long totalTime=0;\\n\\n        for(auto t:batteries){\\n            if(t<time) totalTime+=t;\\n            else totalTime+=time;\\n        }\\n\\n        return (totalTime/computers>=time);\\n    }    \\n\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        \\n        long long l=0;\\n        long long h=1e14;\\n\\n        long long res=0;\\n\\n        while(l<=h){\\n            long long mid=l+(h-l)/2;\\n\\n            if(isPoss(batteries,mid,n)){\\n                res=mid;\\n                l=mid+1;\\n            }\\n            else{\\n                h=mid-1;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPoss(vector<int>&batteries,long long time,int computers){\\n\\n        long long totalTime=0;\\n\\n        for(auto t:batteries){\\n            if(t<time) totalTime+=t;\\n            else totalTime+=time;\\n        }\\n\\n        return (totalTime/computers>=time);\\n    }    \\n\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        \\n        long long l=0;\\n        long long h=1e14;\\n\\n        long long res=0;\\n\\n        while(l<=h){\\n            long long mid=l+(h-l)/2;\\n\\n            if(isPoss(batteries,mid,n)){\\n                res=mid;\\n                l=mid+1;\\n            }\\n            else{\\n                h=mid-1;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823041,
                "title": "solve-this-question-by-using-binary-search-method-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**1**: First, determine the range of possible durations for a PCs, which is from 0 minutes to the sum of all batteries\\' durations.\\n\\n**2**: Perform a binary search within this duration range to find the maximum duration.\\n\\n**3**: For each mid-value during the binary search, calculate the total duration of the batteries that have a duration below or equal to the mid-value, and for the batteries with durations above the mid-value, take their duration as the mid-value.\\n\\n**4**: If the calculated duration is greater than or equal to the mid-value multiplied by the number of pc (n), set the maximum duration to the mid-value and search for other possibilities to find the maximum time by incrementing the starting time.\\nIf the calculated duration is less than the mid-value multiplied by n, search for a lower maximum time by decrementing the ending time.\\n\\n**5**: Repeat steps 3 to 4 until the maximum time is found.\\n\\n**6**: Return the maximum time.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nBinary Search\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static long RunTime( int[] batteries, long mid){\\n\\n        long duration = 0;\\n\\n        for(int i=0; i<batteries.length; i++){\\n            if(batteries[i]<mid){\\n                duration += (long)batteries[i];\\n            }else{\\n                duration += mid;\\n            }\\n        }\\n\\n        return duration;\\n\\n    }\\n    public static long maxRunTime(int n, int[] batteries) {\\n\\n        long sum = 0;\\n        for(int i : batteries){\\n            sum +=(long) i;\\n        }\\n        \\n        long startTime = (long) 0, endTime = (long) sum, maxTime = (long) 0;\\n\\n        while(startTime <= endTime){\\n\\n            long mid = (long)(startTime+endTime)/2;\\n            if(RunTime(batteries, mid)>= mid*n){\\n                maxTime = mid;\\n                startTime = (long)mid + 1;\\n\\n            }else{\\n\\n                endTime = (long)mid-1;\\n\\n            }\\n\\n\\n        }\\n\\n        return maxTime;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static long RunTime( int[] batteries, long mid){\\n\\n        long duration = 0;\\n\\n        for(int i=0; i<batteries.length; i++){\\n            if(batteries[i]<mid){\\n                duration += (long)batteries[i];\\n            }else{\\n                duration += mid;\\n            }\\n        }\\n\\n        return duration;\\n\\n    }\\n    public static long maxRunTime(int n, int[] batteries) {\\n\\n        long sum = 0;\\n        for(int i : batteries){\\n            sum +=(long) i;\\n        }\\n        \\n        long startTime = (long) 0, endTime = (long) sum, maxTime = (long) 0;\\n\\n        while(startTime <= endTime){\\n\\n            long mid = (long)(startTime+endTime)/2;\\n            if(RunTime(batteries, mid)>= mid*n){\\n                maxTime = mid;\\n                startTime = (long)mid + 1;\\n\\n            }else{\\n\\n                endTime = (long)mid-1;\\n\\n            }\\n\\n\\n        }\\n\\n        return maxTime;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822937,
                "title": "binary-search-on-ans-o-n-log-1e14",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to search a max time, till then all the batteries run simultaneusly. Keep in mind these 2 example:-\\n1. n=2, bat[]={3,3,3}, here after keeping the two laptops running we are left with one battery and can utilize, its power.\\n2. But, for n=3, bat[] = {3,5,10,10}, here we must first utilise the max batteries and use the lesser power batteries as spare batteries, so the max can be 8. Even 2 batteries are left with 2-2 all the 3 can\\'t be kept on.\\n\\nUsing this way to check if our assumption of max time is true or not we can get required ans.   \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Assume the last \\'n\\' batteries are utilised first, so the total of batteries before last n batteries to provide some extra power. Hence, find sum 0 to bat.size() -n-1.\\n2. Apply binary search on ans to get the desired ans.\\n3. As we have the sum of spare time(battery\\'s power), we give it to every battery < assumed time, if at any moment we do not have enough battery time, the variable p will be < 0. \\n4. We break at that point if p<0 , and go for lesser assumption, else if all batteries ran till assumed time, we take it as ans, and search for greater ans, if found ans gets updated.\\n5. Finally, return the ans.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(1e14) + nlog n ) including sorting.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) as we changed the original array.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& bat) {\\n        long long low=0 , high=1e14 , ans=0;\\n        sort(bat.begin() , bat.end());\\n        long long pre = 0;\\n        for(int i=0 ; i<bat.size()-n ; i++){\\n                pre += bat[i];\\n        }\\n        while(low<=high){\\n            long long mid = (low+high)/2; \\n            int i;        \\n            long long p=pre;\\n            for(i=bat.size()-n ; i<bat.size() ; i++){\\n                \\n                p-=(mid-bat[i]);\\n                if(p<0) break;\\n            }\\n            if(i==bat.size()) low=mid+1 , ans=mid;\\n            else high = mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& bat) {\\n        long long low=0 , high=1e14 , ans=0;\\n        sort(bat.begin() , bat.end());\\n        long long pre = 0;\\n        for(int i=0 ; i<bat.size()-n ; i++){\\n                pre += bat[i];\\n        }\\n        while(low<=high){\\n            long long mid = (low+high)/2; \\n            int i;        \\n            long long p=pre;\\n            for(i=bat.size()-n ; i<bat.size() ; i++){\\n                \\n                p-=(mid-bat[i]);\\n                if(p<0) break;\\n            }\\n            if(i==bat.size()) low=mid+1 , ans=mid;\\n            else high = mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822914,
                "title": "binary-search-c-implementation",
                "content": "# Code\\n```cpp []\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& batteries, long long time, int computers){\\n            long long totTime = time*computers;\\n            \\n            for(long long bTime : batteries)\\n                totTime -= min(time, bTime);\\n            \\n            return (totTime <= 0);\\n    }\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        long long low = 0, high = 0;\\n        int size = batteries.size();\\n        \\n        for(int i=0; i<size; i++) high += batteries[i];\\n        \\n        long long ans = 0;\\n        while(low <= high){\\n            long long mid = low + (high-low)/2;\\n            if(isPossible(batteries, mid, n)){\\n                ans = mid;\\n                low = mid+1;\\n            }\\n            else high = mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& batteries, long long time, int computers){\\n            long long totTime = time*computers;\\n            \\n            for(long long bTime : batteries)\\n                totTime -= min(time, bTime);\\n            \\n            return (totTime <= 0);\\n    }\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        long long low = 0, high = 0;\\n        int size = batteries.size();\\n        \\n        for(int i=0; i<size; i++) high += batteries[i];\\n        \\n        long long ans = 0;\\n        while(low <= high){\\n            long long mid = low + (high-low)/2;\\n            if(isPossible(batteries, mid, n)){\\n                ans = mid;\\n                low = mid+1;\\n            }\\n            else high = mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822863,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& batteries) \\n    {\\n        long long sum =0;\\n        int k=batteries.size();\\n        for(int i=0;i<k;i++)\\n        {\\n            sum+=batteries[i];\\n        }\\n        sort(batteries.begin(),batteries.end());\\n        for(int i=k-1;i>=0;i--)\\n        {\\n            if((sum/n)<batteries[i])\\n            {\\n                sum-=batteries[i];\\n                n--;\\n            }\\n            else\\n            break;\\n        }\\n        return sum/n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& batteries) \\n    {\\n        long long sum =0;\\n        int k=batteries.size();\\n        for(int i=0;i<k;i++)\\n        {\\n            sum+=batteries[i];\\n        }\\n        sort(batteries.begin(),batteries.end());\\n        for(int i=k-1;i>=0;i--)\\n        {\\n            if((sum/n)<batteries[i])\\n            {\\n                sum-=batteries[i];\\n                n--;\\n            }\\n            else\\n            break;\\n        }\\n        return sum/n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822856,
                "title": "easiest-solution",
                "content": "# Please Upvote \\uD83E\\uDD7A\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        sort(batteries.begin(),batteries.end(),greater<int>());\\n        vector<int>v;\\n        for(int i=0;i<n;i++){\\n            v.push_back(batteries[i]);\\n        }\\n        reverse(v.begin(),v.end());\\n        long long sum=0;\\n        for(int i=n;i<batteries.size();i++){\\n            sum+=batteries[i];\\n        }\\n        for(int i=0;i<n-1;i++){\\n            int diff = v[i+1]-v[i];\\n            int req = diff*(i+1);\\n            sum-=req;\\n            if(sum<0){\\n                sum+=req;\\n                long long delta = sum/(i+1);\\n                return delta+v[i];\\n            }\\n        }\\n        if(sum==0)return v.back();\\n        return (sum/n)+v.back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        sort(batteries.begin(),batteries.end(),greater<int>());\\n        vector<int>v;\\n        for(int i=0;i<n;i++){\\n            v.push_back(batteries[i]);\\n        }\\n        reverse(v.begin(),v.end());\\n        long long sum=0;\\n        for(int i=n;i<batteries.size();i++){\\n            sum+=batteries[i];\\n        }\\n        for(int i=0;i<n-1;i++){\\n            int diff = v[i+1]-v[i];\\n            int req = diff*(i+1);\\n            sum-=req;\\n            if(sum<0){\\n                sum+=req;\\n                long long delta = sum/(i+1);\\n                return delta+v[i];\\n            }\\n        }\\n        if(sum==0)return v.back();\\n        return (sum/n)+v.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822737,
                "title": "2-approaches-binary-search-greedy-sorting-prefix-sum-c",
                "content": "# Approach-1 (Binary Search + Greedy):\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //BINARY SEARCH:\\n    bool isPossible(vector<int> &batteries,long long target,long long n){\\n        long long extra=0;\\n        for(int i=0;i<batteries.size();i++){\\n            if(batteries[i]>=target)extra+=target;\\n            else extra+=batteries[i];\\n        }\\n        return extra>=n*target;\\n    }\\n\\n    long long maxRunTime(int n, vector<int>& batteries){\\n        long long start=1;\\n        long long end=0;\\n        for(int i=0;i<batteries.size();i++)end+=batteries[i];\\n        end/=n;\\n        while(start<=end){\\n            long long mid=(start+end)/2;\\n            if(isPossible(batteries,mid,n))start=mid+1;\\n            else end=mid-1;\\n        }\\n        return start-1;\\n    }\\n};\\n```\\n\\n---\\n> Do Upvote, Happy Coding! \\uD83C\\uDF87\\n\\n---\\n\\n\\n\\n# Approach-2 (Sorting + Prefix Sum):\\n# Code:\\n```\\n    class Solution {\\npublic:\\n    //SORTING + PREFIX SUM:\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        sort(batteries.begin(),batteries.end());\\n        vector<int> live;\\n        while(live.size()!=n){\\n            live.push_back(batteries.back());\\n            batteries.pop_back();\\n        }\\n        reverse(live.begin(),live.end());\\n        long long extra=0;\\n        for(int i=0;i<batteries.size();i++)extra+=batteries[i];\\n        for(int i=0;i<n-1;i++){\\n            int diff=live[i+1]-live[i];\\n            if(extra>=(i+1)*(diff)){\\n                extra-=(i+1)*diff;\\n            }\\n            else{\\n                return live[i]+extra/(i+1);\\n            }\\n        }\\n        return live[n-1]+extra/n;\\n    }\\n    }\\n};\\n\\n```\\n![upvote xd.jpeg](https://assets.leetcode.com/users/images/e15dc8e2-859f-4516-ae29-3061418f2984_1690447087.7872043.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Greedy",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //BINARY SEARCH:\\n    bool isPossible(vector<int> &batteries,long long target,long long n){\\n        long long extra=0;\\n        for(int i=0;i<batteries.size();i++){\\n            if(batteries[i]>=target)extra+=target;\\n            else extra+=batteries[i];\\n        }\\n        return extra>=n*target;\\n    }\\n\\n    long long maxRunTime(int n, vector<int>& batteries){\\n        long long start=1;\\n        long long end=0;\\n        for(int i=0;i<batteries.size();i++)end+=batteries[i];\\n        end/=n;\\n        while(start<=end){\\n            long long mid=(start+end)/2;\\n            if(isPossible(batteries,mid,n))start=mid+1;\\n            else end=mid-1;\\n        }\\n        return start-1;\\n    }\\n};\\n```\n```\\n    class Solution {\\npublic:\\n    //SORTING + PREFIX SUM:\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        sort(batteries.begin(),batteries.end());\\n        vector<int> live;\\n        while(live.size()!=n){\\n            live.push_back(batteries.back());\\n            batteries.pop_back();\\n        }\\n        reverse(live.begin(),live.end());\\n        long long extra=0;\\n        for(int i=0;i<batteries.size();i++)extra+=batteries[i];\\n        for(int i=0;i<n-1;i++){\\n            int diff=live[i+1]-live[i];\\n            if(extra>=(i+1)*(diff)){\\n                extra-=(i+1)*diff;\\n            }\\n            else{\\n                return live[i]+extra/(i+1);\\n            }\\n        }\\n        return live[n-1]+extra/n;\\n    }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822572,
                "title": "simple-beginner-friendly-c-solution-with-intuition-and-explanation",
                "content": "# Intuition\\nThe given problem aims to find the maximum run time for a device with n batteries, given their power levels. So we use binary search to efficiently find the maximum run time that can be achieved. We iteratively adjust the search range based on the available power and the required power for n batteries at the target run time. The binary search narrows down the search space to find the maximum achievable run time, optimizing the solution.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\nSteps:\\n- Calculate the sum of all power levels in the batteries vector.\\n- Initialize the binary search range with left = 1 (minimum run time) and right = sumPower / n (maximum run time if all batteries have an equal share of power).\\n- Perform binary search to find the maximum achievable run time.\\n- In each iteration, calculate the target run time as the middle value between left and right.\\n- Check if the batteries can support the target run time by calculating the total power available (extra) while considering the minimum power needed for n batteries at the target run time.\\n- Adjust the search range based on the available power (extra):\\n1) If extra is sufficient, set left = target to search for higher possible run times.\\n2) If extra is insufficient, set right = target - 1 to search for lower possible run times.\\n- Continue the binary search until left becomes greater than or equal to right.\\n- Return the maximum achievable run time (left).\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(m log k) where, m is the length of the input array batteries and k be the maximum power of one battery.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nUPVOTE. Glad to help.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        long long sumPower=0;\\n        for(int power:batteries)\\n            sumPower+=power;\\n        long long left=1,right=sumPower/n;\\n        while(left<right){\\n            long target=right-(right-left)/2;\\n            long extra=0;\\n            for(long power:batteries)\\n                extra+=min(power,target);\\n            if(extra>=(long)(n*target))left=target;\\n            else right=target-1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        long long sumPower=0;\\n        for(int power:batteries)\\n            sumPower+=power;\\n        long long left=1,right=sumPower/n;\\n        while(left<right){\\n            long target=right-(right-left)/2;\\n            long extra=0;\\n            for(long power:batteries)\\n                extra+=min(power,target);\\n            if(extra>=(long)(n*target))left=target;\\n            else right=target-1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822559,
                "title": "113ms-beats-100-54-9mb-beats-100-c-binary-search",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    Solution(){\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n    }\\n    long long maxRunTime(int n, vector<int>& v) {\\n        long long r=accumulate(v.begin(),v.end(),0LL);\\n        long long l=0;\\n        while(l<=r)\\n        {\\n            long long mid=l+(r-l)/2;\\n            long long sum=0;\\n            for(const auto & i:v)\\n                sum+=min((long long)i,mid);\\n            if(sum>=mid*(long long)n)\\n                l=mid+1;\\n            else\\n                r=mid-1;        \\n        }\\n        return l-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Solution(){\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n    }\\n    long long maxRunTime(int n, vector<int>& v) {\\n        long long r=accumulate(v.begin(),v.end(),0LL);\\n        long long l=0;\\n        while(l<=r)\\n        {\\n            long long mid=l+(r-l)/2;\\n            long long sum=0;\\n            for(const auto & i:v)\\n                sum+=min((long long)i,mid);\\n            if(sum>=mid*(long long)n)\\n                l=mid+1;\\n            else\\n                r=mid-1;        \\n        }\\n        return l-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822547,
                "title": "beats-100-with-javascript",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[]} batteries\\n * @return {number}\\n */\\nvar maxRunTime = function(n, batteries) {\\n    // Calculate the sum of all batteries\\n    let sumPower = 0;\\n    for (let power of batteries) {\\n        sumPower += power;\\n    }\\n    // Initialize the low and high pointers for Binary Search\\n    let left = 1;\\n    let right = Math.floor(sumPower / n);\\n    // While left is less than right, do Binary Search\\n    while (left < right) {\\n        // Find the middle point\\n        let time = Math.floor((left + right + 1) / 2);\\n        // If the middle point is possible, update the left pointer\\n        if (check(batteries, n, time)) {\\n            left = time;\\n        } else {\\n            // Otherwise, update the right pointer\\n            right = time - 1;\\n        }\\n    }\\n    // Return the left pointer as the result\\n    return left;\\n};\\n\\n// Define a helper function to check if a given running time is possible\\nvar check = function(batteries, n, time) {\\n    // Initialize the sum of the minimum of each battery and the time\\n    let sum = 0;\\n    for (let battery of batteries) {\\n        sum += Math.min(battery, time);\\n    }\\n    // Return true if the sum is greater than or equal to the product of the time and n\\n    return (sum >= time * n);\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[]} batteries\\n * @return {number}\\n */\\nvar maxRunTime = function(n, batteries) {\\n    // Calculate the sum of all batteries\\n    let sumPower = 0;\\n    for (let power of batteries) {\\n        sumPower += power;\\n    }\\n    // Initialize the low and high pointers for Binary Search\\n    let left = 1;\\n    let right = Math.floor(sumPower / n);\\n    // While left is less than right, do Binary Search\\n    while (left < right) {\\n        // Find the middle point\\n        let time = Math.floor((left + right + 1) / 2);\\n        // If the middle point is possible, update the left pointer\\n        if (check(batteries, n, time)) {\\n            left = time;\\n        } else {\\n            // Otherwise, update the right pointer\\n            right = time - 1;\\n        }\\n    }\\n    // Return the left pointer as the result\\n    return left;\\n};\\n\\n// Define a helper function to check if a given running time is possible\\nvar check = function(batteries, n, time) {\\n    // Initialize the sum of the minimum of each battery and the time\\n    let sum = 0;\\n    for (let battery of batteries) {\\n        sum += Math.min(battery, time);\\n    }\\n    // Return true if the sum is greater than or equal to the product of the time and n\\n    return (sum >= time * n);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3822484,
                "title": "go-sorting-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(m*log(m))\\n\\n- Space complexity:\\nO(m)\\n\\n# Code\\n```\\nfunc maxRunTime(n int, batteries []int) int64 {\\n    sort.Ints(batteries)\\n    live := make([]int64, n)\\n    for i := 0; i < n; i++{\\n        live[i] = int64(batteries[len(batteries) - n + i])\\n    }\\n    extra := int64(0)\\n    for i := 0; i < len(batteries) - n; i++{\\n        extra += int64(batteries[i])\\n    }\\n    for i := 0; i < n-1; i++{\\n        if extra < int64(i + 1) * (live[i + 1] - live[i]){\\n            return live[i] + extra / int64(i + 1)\\n        }\\n        extra -= int64(i + 1) * (live[i + 1] - live[i])\\n    }\\n    return live[n - 1] + extra / int64(n)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Sort",
                    "Prefix Sum"
                ],
                "code": "```\\nfunc maxRunTime(n int, batteries []int) int64 {\\n    sort.Ints(batteries)\\n    live := make([]int64, n)\\n    for i := 0; i < n; i++{\\n        live[i] = int64(batteries[len(batteries) - n + i])\\n    }\\n    extra := int64(0)\\n    for i := 0; i < len(batteries) - n; i++{\\n        extra += int64(batteries[i])\\n    }\\n    for i := 0; i < n-1; i++{\\n        if extra < int64(i + 1) * (live[i + 1] - live[i]){\\n            return live[i] + extra / int64(i + 1)\\n        }\\n        extra -= int64(i + 1) * (live[i + 1] - live[i])\\n    }\\n    return live[n - 1] + extra / int64(n)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3822113,
                "title": "binary-search-c-solution-with-explanation-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we observe carefully, we will realize that the maximum time for which we can run computers is **monotonic** in nature. This is because, if we can run n computers for t minutes, we can definitely run n computers for **t - 1 minutes.** Therefore, this gives us a clue that binary search *might be applicable* in this problem.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can set our lo and hi pointers as **minimum** of all the batteries and the **sum** of all the given batteries respectively.\\n\\nThe main logic which verifies if a given **time limit is valid** is as following:\\n\\nLet\\'s assume our current time limit is **mid.** We must therefore run each computer for mid minutes. How much battery is this going consume? To answer this, let\\'s assume that there is only **one computer** which consumes battery power **equivalent** to n computers.\\n\\nOrginally, each computer consumed one unit of battery power per unit time. If we stack this rate of consumption (for n computers) onto one computer, it is going to consume **n units of battery power** per unit time! In order to last **mid** minutes, our batteries must supply at least $$mid*n$$ units of power!\\n\\nTherefore the logic to check becomes:\\n```\\nfor(auto i : batteries)\\n{\\n    temp += std::min(mid, i);\\n}\\n\\nif(temp >= mid * n)\\n{\\n    ans = mid;\\n    lo = mid + 1;\\n}\\nelse\\n{\\n    hi = mid - 1;\\n}\\n``` \\n\\n# Complexity\\n- Time complexity: $$O(m*log(k))$$ where, m = size of batteries array and k denotes the search range between lo and hi.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        long long hi = 0, lo = INT_MAX, ans;\\n        for(auto i : batteries)\\n        {\\n            hi += i;\\n            lo = std::min((int)lo, i);\\n        }\\n        ans = lo;\\n        while(lo <= hi)\\n        {\\n            long long mid = lo + (hi - lo)/2, temp = 0;\\n            for(auto i : batteries)\\n            {\\n                temp += std::min(mid, (long long)i);\\n            }\\n\\n            if(temp >= mid * n)\\n            {\\n                ans = mid;\\n                lo = mid + 1;\\n            }\\n            else\\n            {\\n                hi = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/3c723006-06d4-4177-a0ef-c900d9761042_1690438368.0250828.png)\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nfor(auto i : batteries)\\n{\\n    temp += std::min(mid, i);\\n}\\n\\nif(temp >= mid * n)\\n{\\n    ans = mid;\\n    lo = mid + 1;\\n}\\nelse\\n{\\n    hi = mid - 1;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        long long hi = 0, lo = INT_MAX, ans;\\n        for(auto i : batteries)\\n        {\\n            hi += i;\\n            lo = std::min((int)lo, i);\\n        }\\n        ans = lo;\\n        while(lo <= hi)\\n        {\\n            long long mid = lo + (hi - lo)/2, temp = 0;\\n            for(auto i : batteries)\\n            {\\n                temp += std::min(mid, (long long)i);\\n            }\\n\\n            if(temp >= mid * n)\\n            {\\n                ans = mid;\\n                lo = mid + 1;\\n            }\\n            else\\n            {\\n                hi = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821980,
                "title": "javascript-python-clean-short-and-simple-solution-with-explanation",
                "content": "# JavaScript\\n```js\\nvar maxRunTime = function(n, batteries) {\\n    batteries.sort((a, b) => a - b); // Sort\\n    let total = batteries.reduce((a, b) => a + b, 0); // Sum of all\\n\\n    // If last battery is very high\\n    // (So that if remaining battery is shared by remaining computers still less than last battery)\\n    while (batteries.at(-1) > total / n)\\n        --n, total -= batteries.pop();\\n\\n    return Math.floor(total / n);\\n};\\n```\\n\\n# Python\\n```py\\nclass Solution:\\n    def maxRunTime(self, n, batteries):\\n        batteries.sort() # Sort\\n        total = sum(batteries) # Sum of all\\n\\n        # If last battery is very high\\n        # (So that if remaining battery is shared by remaining computers still less than last battery)\\n        while batteries[-1] > total / n:\\n            n -= 1\\n            total -= batteries.pop()\\n\\n        return total // n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```js\\nvar maxRunTime = function(n, batteries) {\\n    batteries.sort((a, b) => a - b); // Sort\\n    let total = batteries.reduce((a, b) => a + b, 0); // Sum of all\\n\\n    // If last battery is very high\\n    // (So that if remaining battery is shared by remaining computers still less than last battery)\\n    while (batteries.at(-1) > total / n)\\n        --n, total -= batteries.pop();\\n\\n    return Math.floor(total / n);\\n};\\n```\n```py\\nclass Solution:\\n    def maxRunTime(self, n, batteries):\\n        batteries.sort() # Sort\\n        total = sum(batteries) # Sum of all\\n\\n        # If last battery is very high\\n        # (So that if remaining battery is shared by remaining computers still less than last battery)\\n        while batteries[-1] > total / n:\\n            n -= 1\\n            total -= batteries.pop()\\n\\n        return total // n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821918,
                "title": "c-binary-search",
                "content": "# Approach\\nUse binary search to find max time\\n\\n# Complexity\\n- Time complexity: $$O(n \\\\times log(n))$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public long MaxRunTime(int n, int[] batteries)\\n    {\\n        var left = 1L;\\n        var right = batteries.Select(x => (long)x).Sum() / n;\\n\\n        Array.Sort(batteries);\\n\\n        while (left < right)\\n        {\\n            var mid = left + (right - left + 1) / 2;\\n\\n            if (possible(n, batteries, mid))\\n            {\\n                left = mid;\\n            }\\n            else\\n            {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return left;\\n    }\\n\\n    private static bool possible(int n, int[] batteries, long hours)\\n    {\\n        long s = 0;\\n\\n        foreach (var time in batteries)\\n        {\\n            s += time;\\n\\n            if (s >= hours)\\n            {\\n                s -= hours;\\n                n--;\\n            }\\n\\n            if (n == 0)\\n            {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public long MaxRunTime(int n, int[] batteries)\\n    {\\n        var left = 1L;\\n        var right = batteries.Select(x => (long)x).Sum() / n;\\n\\n        Array.Sort(batteries);\\n\\n        while (left < right)\\n        {\\n            var mid = left + (right - left + 1) / 2;\\n\\n            if (possible(n, batteries, mid))\\n            {\\n                left = mid;\\n            }\\n            else\\n            {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return left;\\n    }\\n\\n    private static bool possible(int n, int[] batteries, long hours)\\n    {\\n        long s = 0;\\n\\n        foreach (var time in batteries)\\n        {\\n            s += time;\\n\\n            if (s >= hours)\\n            {\\n                s -= hours;\\n                n--;\\n            }\\n\\n            if (n == 0)\\n            {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821753,
                "title": "python-4-liner-solution",
                "content": "```\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        batteries.sort()\\n        su = sum(batteries)\\n        while batteries[-1] > su // n:\\n            n -= 1\\n            su -= batteries.pop()\\n        return su // n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        batteries.sort()\\n        su = sum(batteries)\\n        while batteries[-1] > su // n:\\n            n -= 1\\n            su -= batteries.pop()\\n        return su // n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821713,
                "title": "python-3-binary-search-greedy",
                "content": "# Intuition\\nObviously you need to try different time t. This part requires binary search. Nothing special. For each binary search iteration, you need to check \"if a certain t can be achieved\". This is the hardest part.\\n\\nReverse sort the array first. Sum up bat[n:]. If sum > 0, you can rearrange this sum to any battery in bat[:n]. You don\\'t need to know exactly how to arrange. If the sum can distribute to bat[:n] to achieve time t, return True. Else, return False. This part is greedy.\\n\\n# Approach\\nBinary search + greedy\\n\\n# Complexity\\n- Time complexity:\\nO(nlogk) -> Do bs operation within a time range.\\n\\n- Space complexity:\\nO(n) -> the sorted array\\n\\nn = given n\\nk = sum(bat) // n -> right boundary\\n\\n# Code\\n```\\nclass Solution:\\n    def maxRunTime(self, n: int, bat: List[int]) -> int:\\n\\n        def ok(time): # return bool, ok?\\n            if bat[n-1] >= time:\\n                return True\\n            \\n            remain = sum(bat[n:])\\n            for i in range(n-1, -1, -1):\\n                if bat[i] < time:\\n                    remain -= time - bat[i]\\n            return remain >= 0\\n\\n        bat.sort(reverse = True)\\n        \\n        l, r = 1, sum(bat) // n\\n\\n        while l < r:\\n            m = (l + r) // 2\\n            if ok(m):\\n                l = m + 1\\n            else:\\n                r = m\\n\\n        return l if ok(l) else l - 1\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxRunTime(self, n: int, bat: List[int]) -> int:\\n\\n        def ok(time): # return bool, ok?\\n            if bat[n-1] >= time:\\n                return True\\n            \\n            remain = sum(bat[n:])\\n            for i in range(n-1, -1, -1):\\n                if bat[i] < time:\\n                    remain -= time - bat[i]\\n            return remain >= 0\\n\\n        bat.sort(reverse = True)\\n        \\n        l, r = 1, sum(bat) // n\\n\\n        while l < r:\\n            m = (l + r) // 2\\n            if ok(m):\\n                l = m + 1\\n            else:\\n                r = m\\n\\n        return l if ok(l) else l - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821579,
                "title": "kotlin-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n*log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun maxRunTime(n: Int, batteries: IntArray): Long {\\n        batteries.sortDescending()\\n        var sum = batteries.fold(0L) { acc, i -> acc + i }\\n        batteries.forEachIndexed { i, v ->\\n            if (sum - v >= v * (n - i - 1L)) return sum / (n - i)\\n            sum -= v\\n        }\\n        return 0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    fun maxRunTime(n: Int, batteries: IntArray): Long {\\n        batteries.sortDescending()\\n        var sum = batteries.fold(0L) { acc, i -> acc + i }\\n        batteries.forEachIndexed { i, v ->\\n            if (sum - v >= v * (n - i - 1L)) return sum / (n - i)\\n            sum -= v\\n        }\\n        return 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821556,
                "title": "best-code-beats-up-to-86-ms-and-92-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n![Screenshot from 2023-07-27 07-27-35.png](https://assets.leetcode.com/users/images/73ded4cb-fec3-47c6-ab53-c83a79957b90_1690424876.7412786.png)\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![Screenshot from 2023-07-27 07-26-27.png](https://assets.leetcode.com/users/images/6c5f1254-080c-40dc-b697-6b12ec2a0813_1690424903.2462232.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        batteries.sort()\\n        total = sum(batteries)\\n        while batteries[-1] > total//n:\\n            n -= 1\\n            total -= batteries.pop()\\n        return total//n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        batteries.sort()\\n        total = sum(batteries)\\n        while batteries[-1] > total//n:\\n            n -= 1\\n            total -= batteries.pop()\\n        return total//n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821532,
                "title": "beats-98-2-easy-binary-search-clean-code",
                "content": "# Intuition\\nLower limit is minimumum time for which they can work simultaneously. Itcan be said as the minimum battery value of all batteries.\\nUpper limit by observation is the sum of all batteries/ number of computers.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(long long mid, int n, vector<int>& batteries) {\\n        long long target_sum = mid*n;\\n        long long current_sum = 0;\\n\\n        for(int val: batteries) {\\n            if(val < mid)   current_sum += val;\\n            else    current_sum += mid;\\n            if(current_sum >= target_sum)   return true;\\n        }\\n        return current_sum >= target_sum;\\n    }\\n\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n      long long low = LLONG_MAX;\\n      long long high, total_sum, mid;\\n      long long ans = -1;\\n\\n      for(int val: batteries){\\n          if(val < low) low = val;\\n          total_sum += val;\\n      }\\n      high = (total_sum/n)+1;\\n\\n      while(low < high) {\\n          mid = low + (high-low)/2;\\n          if(solve(mid, n, batteries)) {\\n              ans = mid;\\n              low = mid+1;  //itne minute tak toh chal gaye saare computer simultaneously, par kya isse zada chal sakte hain ? \\n          }\\n          else  high = mid;\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(long long mid, int n, vector<int>& batteries) {\\n        long long target_sum = mid*n;\\n        long long current_sum = 0;\\n\\n        for(int val: batteries) {\\n            if(val < mid)   current_sum += val;\\n            else    current_sum += mid;\\n            if(current_sum >= target_sum)   return true;\\n        }\\n        return current_sum >= target_sum;\\n    }\\n\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n      long long low = LLONG_MAX;\\n      long long high, total_sum, mid;\\n      long long ans = -1;\\n\\n      for(int val: batteries){\\n          if(val < low) low = val;\\n          total_sum += val;\\n      }\\n      high = (total_sum/n)+1;\\n\\n      while(low < high) {\\n          mid = low + (high-low)/2;\\n          if(solve(mid, n, batteries)) {\\n              ans = mid;\\n              low = mid+1;  //itne minute tak toh chal gaye saare computer simultaneously, par kya isse zada chal sakte hain ? \\n          }\\n          else  high = mid;\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821523,
                "title": "swift-binary-search",
                "content": "**Binary Search (accepted answer)**\\n```\\nclass Solution {\\n    func maxRunTime(_ n: Int, _ b: [Int]) -> Int {\\n        var (l,r) = (1, b.reduce(0,+)/n)\\n        while l < r {\\n            let mid = (l+r+1)/2\\n            (l,r) =  b.reduce(n*mid) {$0 - min($1, mid)} > 0 ? (l, mid-1) : (mid, r)\\n        }\\n        return l\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxRunTime(_ n: Int, _ b: [Int]) -> Int {\\n        var (l,r) = (1, b.reduce(0,+)/n)\\n        while l < r {\\n            let mid = (l+r+1)/2\\n            (l,r) =  b.reduce(n*mid) {$0 - min($1, mid)} > 0 ? (l, mid-1) : (mid, r)\\n        }\\n        return l\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821405,
                "title": "ruby-solution-with-binary-search-explained-100-100",
                "content": "# Intuition\\nIt\\'s comparatively easy to check whether a a specific number of minutes is possible.  Use binary search to check for possible values efficiently.\\n\\n# Approach\\n1. Save n and the batteries array as class variables so they\\'re accessible inside the helper function.  Sort the batteries array, also.\\n2. Find the maximum number of minutes theoretically possible by adding all the batteries and dividing by the number of computers.  (It will often be lower than this, but this is an upper bound.)\\n3. Perform a binary search to find the smallest number of minutes that *isn\\'t* possible, and subtract one.\\n\\nHelper function:\\n1. Create a duplicate of the array.\\n2. If there are any batteries with more than *k* charge, they can power one computer for the whole time but won\\'t be able to make use of any additional charge.  Remove the battery and one computer.\\n3. Any remaining batteries can be shuffled around to provide charge until they run out.  Return true if the total charge of remaining batteries is at least as high as the number of remaining computers times k, false otherwise.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * log(n))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\ndef max_run_time(n, batteries)\\n    @n, @arr = n, batteries.sort\\n    max = batteries.sum / n\\n    (1..max+1).bsearch { |k| !possible?(k) } - 1\\nend\\n\\ndef possible?(k)\\n    n, arr = @n, @arr.dup\\n    while arr[0] && arr[-1] >= k\\n      arr.pop\\n      n -= 1\\n    end\\n    arr.sum >= n * k\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef max_run_time(n, batteries)\\n    @n, @arr = n, batteries.sort\\n    max = batteries.sum / n\\n    (1..max+1).bsearch { |k| !possible?(k) } - 1\\nend\\n\\ndef possible?(k)\\n    n, arr = @n, @arr.dup\\n    while arr[0] && arr[-1] >= k\\n      arr.pop\\n      n -= 1\\n    end\\n    arr.sum >= n * k\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3514695,
                "title": "ruby-1-liner",
                "content": "```\\ndef max_run_time(n, a) =\\n\\n  a.sort.reverse.reduce(a.sum){ n>1 and _2>_1/n and n-=1 and _1-_2 or _1 } / n\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef max_run_time(n, a) =\\n\\n  a.sort.reverse.reduce(a.sum){ n>1 and _2>_1/n and n-=1 and _1-_2 or _1 } / n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3290635,
                "title": "binary-search-easy-approach",
                "content": "# Intuition\\nThe array provided is sorted array, so here we can get idea of using binary search.\\n\\n# Approach\\nUsing binary search, we need to decide what will be low & high pointer.\\nLow value can be min values in array\\nHigh value need to be decided \\nThe question is how can we decide the high value ?\\nLet\\'s consider array[1,1,1,1] determines there are 4 battery units and consider n=2 (computers).\\nSo finding out how long computer will run continuously\\ntotal sum  =(1+1+1+1)=4\\nn=2\\nFormula High pointer = total sum of array/n = 4/2 =2\\nNow decided \\nLow =1\\nHigh = 2+1 =3\\nmid = 2\\n\\nAnd passing those value in isPossible function\\n\\nTarget amount of total battery = mid*n  = 2*2 =4\\nNext iterating the batteries array \\n \\nArray [1,1,1,1]\\nFirst element(Battery) :1\\nif(battery>mid) \\n    which is 1>2 (no), \\n        so add it to variable sum\\n            sum =1\\n\\nSecond element(Battery) :1\\nif(battery>mid) \\n    which is 1>2 (no), \\n        so add it to variable sum\\n            sum =2\\nThird element(Battery) :1\\nif(battery>mid) \\n    which is 1>2 (no), \\n        so add it to variable sum\\n            sum =3\\n\\nFourth element(Battery) :1\\nif(battery>mid) \\n    which is 1>2 (no), \\n        so add it to variable sum\\n            sum =4\\n\\nNow checking if(sum>=total)\\n    which is (4>=4),\\n        return true\\n\\nRes = mid =2\\nlow = mid+1 =3\\nhigh =3\\n\\nlow<high so it came out of loop \\n\\nHence answer will be 3\\n\\n# Complexity\\n- Time complexity:\\nn(logn)\\n\\n\\n# Code\\n```\\n\\n\\nclass Solution {\\n    public static boolean isPossible(int []batteries,int n ,long target)\\n    {\\n        long total = n*target;\\n        long sum =0;\\n        for(int battery: batteries)\\n        {\\n            if(battery>target)\\n                sum += target;\\n                \\n            else\\n                sum += battery;\\n\\n            if(sum>=total)\\n                return true;\\n        }\\n        return (sum>=total);\\n\\n\\n    }\\n    public long maxRunTime(int n, int[] batteries) {\\n        long low = 0;\\n        long totalSum =0;\\n        for(int elem:batteries)\\n        {\\n            totalSum += elem;\\n            if(elem<low)\\n            low = elem;\\n        }\\n\\n\\n        long high = (totalSum/n)+1;\\n        long res = 0;\\n\\n        while(low<high)\\n        {\\n            long mid = low+ (high-low)/2;\\n            if(isPossible(batteries,n,mid))\\n                {\\n                    res = mid;\\n                    low = mid+1;\\n                }\\n                else\\n                    high = mid;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n\\nclass Solution {\\n    public static boolean isPossible(int []batteries,int n ,long target)\\n    {\\n        long total = n*target;\\n        long sum =0;\\n        for(int battery: batteries)\\n        {\\n            if(battery>target)\\n                sum += target;\\n                \\n            else\\n                sum += battery;\\n\\n            if(sum>=total)\\n                return true;\\n        }\\n        return (sum>=total);\\n\\n\\n    }\\n    public long maxRunTime(int n, int[] batteries) {\\n        long low = 0;\\n        long totalSum =0;\\n        for(int elem:batteries)\\n        {\\n            totalSum += elem;\\n            if(elem<low)\\n            low = elem;\\n        }\\n\\n\\n        long high = (totalSum/n)+1;\\n        long res = 0;\\n\\n        while(low<high)\\n        {\\n            long mid = low+ (high-low)/2;\\n            if(isPossible(batteries,n,mid))\\n                {\\n                    res = mid;\\n                    low = mid+1;\\n                }\\n                else\\n                    high = mid;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2291707,
                "title": "2141-maximum-running-time-of-n-computers",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& bat, long long avgtm, int n){\\n        long  duration=0;\\n        for(int it: bat){\\n            if(it <= avgtm)\\n                duration+=it;\\n            else\\n                duration+=avgtm;\\n            \\n        }\\n        return (duration >= n*avgtm);\\n        \\n    }\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        long long sum=0;\\n        for(int it : batteries)    sum+=it;\\n        long long s=0, e=sum;\\n        long long ans=0;\\n        while(s<=e){\\n            long long mid= s+(e-s)/2;\\n            \\n            if(check(batteries,mid,n)){\\n                ans = mid;\\n                s=mid+1;\\n            }\\n            else\\n                e=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& bat, long long avgtm, int n){\\n        long  duration=0;\\n        for(int it: bat){\\n            if(it <= avgtm)\\n                duration+=it;\\n            else\\n                duration+=avgtm;\\n            \\n        }\\n        return (duration >= n*avgtm);\\n        \\n    }\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        long long sum=0;\\n        for(int it : batteries)    sum+=it;\\n        long long s=0, e=sum;\\n        long long ans=0;\\n        while(s<=e){\\n            long long mid= s+(e-s)/2;\\n            \\n            if(check(batteries,mid,n)){\\n                ans = mid;\\n                s=mid+1;\\n            }\\n            else\\n                e=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260226,
                "title": "no-binary-search-simple-array-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        sort(batteries.begin(),batteries.end());\\n        ll m=batteries.size();\\n        ll sum=0;\\n        for(ll i=0;i<m-n;i++)\\n            sum+=batteries[i];\\n        \\n        ll ans=batteries[m-n];\\n        ll c=1;\\n        for(ll i=m-n+1;i<m;i++)\\n        { \\n           \\n            ll diff=batteries[i]-batteries[i-1];\\n            \\n            if(c*diff<=sum)\\n            {\\n                ans=batteries[i];\\n                sum-=(c*diff);\\n            }\\n            else\\n            {\\n                ans+=sum/c;\\n                sum=0;\\n                break;\\n            }\\n            c++;\\n        }\\n        \\n        return ans+sum/n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        sort(batteries.begin(),batteries.end());\\n        ll m=batteries.size();\\n        ll sum=0;\\n        for(ll i=0;i<m-n;i++)\\n            sum+=batteries[i];\\n        \\n        ll ans=batteries[m-n];\\n        ll c=1;\\n        for(ll i=m-n+1;i<m;i++)\\n        { \\n           \\n            ll diff=batteries[i]-batteries[i-1];\\n            \\n            if(c*diff<=sum)\\n            {\\n                ans=batteries[i];\\n                sum-=(c*diff);\\n            }\\n            else\\n            {\\n                ans+=sum/c;\\n                sum=0;\\n                break;\\n            }\\n            c++;\\n        }\\n        \\n        return ans+sum/n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2125563,
                "title": "python3-long-batteries-always-fixed-short-batteries-are-free-to-allocate-anywhere",
                "content": "Many posts are missing to explain the following important concepts: \\n1. If a battery has longest endurance, we don\\'t swith server on it. Just assign it to one server and let it stay there until the end.\\n2. If a battery has shortest endurance, and it is not assigned to any server, then we are free to break it into many small batteries with \"1\" endurance, and allocate them anywhere. Why? Because the overall server run time must be longer than this battery, this battery will have enough time to fully contribute itself to anywhere.\\n\\nBecause of this, we assign the longest \"n\" batteries to n servers and fix them there, never change them. The rest batteries are all \"smallest\" batteries, we break them all into small batteries of \"1\" endurance, and allocate them to the fixed batteries to increase their minimal values.\\n\\n**Python3**\\n```python\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        batteries.sort()\\n        free = sum(batteries[:-n])\\n        fixed_batteries = batteries[-n:]\\n        for i in range(1,n):\\n            need = (fixed_batteries[i]-fixed_batteries[i-1])*i\\n            if free>need: free-=need\\n            else: return fixed_batteries[i-1] + free//i\\n        return fixed_batteries[-1]+free//n\\n```",
                "solutionTags": [],
                "code": "```python\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        batteries.sort()\\n        free = sum(batteries[:-n])\\n        fixed_batteries = batteries[-n:]\\n        for i in range(1,n):\\n            need = (fixed_batteries[i]-fixed_batteries[i-1])*i\\n            if free>need: free-=need\\n            else: return fixed_batteries[i-1] + free//i\\n        return fixed_batteries[-1]+free//n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1995550,
                "title": "c-binary-search-observation",
                "content": "```\\n/*\\n    Ideas:\\n        search the number of minutes.\\n        check feasibility, million dollar question is, how?\\n\\n        if say all computers run x minutes,\\n\\n        \"key observation\": battery_i can only use min(x, battery_i)\\n        why? because if it uses more than x, meaning that within x minutes,\\n        it powers more than one computer at the same time.\\n\\n        why time >= n * x is the only thing we need to check?\\n        because only need to make sure a battery won\\'t be powering \\n        more than one computer at the same time, no other constrains.\\n\\n    Caveat:\\n        1. the right bound 1e14 is because if we consider 1e5 batteries with each 1e9 power, but only 1 computer.\\n    \\n*/\\n\\ntypedef long long LL;\\nclass Solution {\\n    bool check(LL x, int n, vector<int>& arr)\\n    {\\n        LL time = 0;\\n        for (LL i : arr)\\n        {\\n            time += min(i, x);\\n        }\\n        return time >= (LL)n * x;\\n    }\\npublic:\\n    long long maxRunTime(int n, vector<int>& arr) {\\n        LL l = 0, r = 1e14; // *max_element(arr.begin(), arr.end());\\n        while (l < r)\\n        {\\n            LL mid = l + r + 1 >> 1;\\n            if (check(mid, n, arr)) l = mid;\\n            else r = mid - 1;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    Ideas:\\n        search the number of minutes.\\n        check feasibility, million dollar question is, how?\\n\\n        if say all computers run x minutes,\\n\\n        \"key observation\": battery_i can only use min(x, battery_i)\\n        why? because if it uses more than x, meaning that within x minutes,\\n        it powers more than one computer at the same time.\\n\\n        why time >= n * x is the only thing we need to check?\\n        because only need to make sure a battery won\\'t be powering \\n        more than one computer at the same time, no other constrains.\\n\\n    Caveat:\\n        1. the right bound 1e14 is because if we consider 1e5 batteries with each 1e9 power, but only 1 computer.\\n    \\n*/\\n\\ntypedef long long LL;\\nclass Solution {\\n    bool check(LL x, int n, vector<int>& arr)\\n    {\\n        LL time = 0;\\n        for (LL i : arr)\\n        {\\n            time += min(i, x);\\n        }\\n        return time >= (LL)n * x;\\n    }\\npublic:\\n    long long maxRunTime(int n, vector<int>& arr) {\\n        LL l = 0, r = 1e14; // *max_element(arr.begin(), arr.end());\\n        while (l < r)\\n        {\\n            LL mid = l + r + 1 >> 1;\\n            if (check(mid, n, arr)) l = mid;\\n            else r = mid - 1;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1778663,
                "title": "c-binary-search-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(long long mid, vector<int>& batteries, int n){\\n         long long sum = 0;\\n         for(long long ele : batteries){\\n             if(ele >= mid) sum += mid;\\n             else sum += ele;\\n         }\\n        \\n         return sum / n >= mid;\\n    }\\n    \\n    \\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        \\n          sort(batteries.rbegin(), batteries.rend());\\n          \\n          if(batteries.size() == 1) return batteries[0];\\n        \\n          long long lo = batteries[n - 1];\\n          long long hi =0;\\n          for(long long ele : batteries) hi = hi + (long long) ele;\\n         if(n == 1) return hi;\\n          hi = hi / n;\\n          long long ans = 0;\\n          while(lo <= hi){\\n              long long mid = lo + (hi - lo) / 2;\\n              if(isPossible(mid, batteries, n)){\\n                  ans = mid;\\n                  lo = mid + 1;\\n              }\\n              else hi = mid - 1;\\n          }\\n          return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    bool isPossible(long long mid, vector<int>& batteries, int n){\\n         long long sum = 0;\\n         for(long long ele : batteries){\\n             if(ele >= mid) sum += mid;\\n             else sum += ele;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 1721797,
                "title": "c-easy-to-understand-simple-binary-search-solution",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    bool canFit(int n,ll mid,vector<int> &b)\\n    {\\n        ll currSum=0;\\n        ll neededSum=mid*n;\\n        for(ll i=0;i<b.size();i++)\\n        {\\n            if(b[i]>=mid)\\n            {\\n                currSum+=mid;\\n            }\\n            else\\n            {\\n                currSum+=b[i];\\n            }\\n            if(currSum>=neededSum)\\n            {\\n                return true;\\n            }\\n        }\\n        return currSum>=neededSum;\\n    }\\n    long long maxRunTime(int n, vector<int>& b) {\\n\\n        ll sum=accumulate(b.begin(),b.end(),(ll)0);\\n        ll high=(sum/n)+1;\\n        ll low=*min_element(b.begin(),b.end());\\n        ll ans=low;\\n        while(low<high)\\n        {\\n            ll mid=low+(high-low)/2;\\n            if(canFit(n,mid,b))\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    bool canFit(int n,ll mid,vector<int> &b)\\n    {\\n        ll currSum=0;\\n        ll neededSum=mid*n;\\n        for(ll i=0;i<b.size();i++)\\n        {\\n            if(b[i]>=mid)\\n            {\\n                currSum+=mid;\\n            }\\n            else\\n            {\\n                currSum+=b[i];\\n            }\\n            if(currSum>=neededSum)\\n            {\\n                return true;\\n            }\\n        }\\n        return currSum>=neededSum;\\n    }\\n    long long maxRunTime(int n, vector<int>& b) {\\n\\n        ll sum=accumulate(b.begin(),b.end(),(ll)0);\\n        ll high=(sum/n)+1;\\n        ll low=*min_element(b.begin(),b.end());\\n        ll ans=low;\\n        while(low<high)\\n        {\\n            ll mid=low+(high-low)/2;\\n            if(canFit(n,mid,b))\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1715274,
                "title": "100-faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity : O(NlogN)***\\n* ***Space Complexity : O(1)***\\n\\n```\\n    bool is_can_run(vector<int>& arr, long long k, long long mid)\\n    {\\n        int n = arr.size();\\n        \\n        long long need = (k * mid); \\n        \\n        long long curr = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(arr[i] > mid)\\n            {\\n                curr += mid;\\n            }\\n            else\\n            {\\n                curr += arr[i];\\n            }\\n        }\\n        \\n        if(curr >= need)\\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    long long maxRunTime(int k, vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        sort(arr.begin(), arr.end(), greater<int>());\\n        \\n        long long sum = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            sum += arr[i];\\n        }\\n        \\n        long long low = arr[k - 1];\\n        \\n        long long high = sum / k;\\n        \\n        long long ans = 0;\\n        \\n        while(low <= high)\\n        {\\n            long long mid = (low + high) / 2 ;\\n            \\n            if(is_can_run(arr, k, mid))\\n            {\\n                ans = mid;\\n                \\n                low = mid + 1;\\n            }\\n            else\\n            {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\n    bool is_can_run(vector<int>& arr, long long k, long long mid)\\n    {\\n        int n = arr.size();\\n        \\n        long long need = (k * mid); \\n        \\n        long long curr = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(arr[i] > mid)\\n            {\\n                curr += mid;\\n            }\\n            else\\n            {\\n                curr += arr[i];\\n            }\\n        }\\n        \\n        if(curr >= need)\\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    long long maxRunTime(int k, vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        sort(arr.begin(), arr.end(), greater<int>());\\n        \\n        long long sum = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            sum += arr[i];\\n        }\\n        \\n        long long low = arr[k - 1];\\n        \\n        long long high = sum / k;\\n        \\n        long long ans = 0;\\n        \\n        while(low <= high)\\n        {\\n            long long mid = (low + high) / 2 ;\\n            \\n            if(is_can_run(arr, k, mid))\\n            {\\n                ans = mid;\\n                \\n                low = mid + 1;\\n            }\\n            else\\n            {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1707798,
                "title": "cpp-solution-by-binary",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n   \\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        long totalSum=0,low=0;\\n\\t\\t//here i am calculating min and total sum of elements of batteries array\\n        for(int i=0;i<batteries.size();i++)\\n        {\\n            totalSum+=batteries[i];\\n            low=min_fun(batteries[i],low);\\n        }\\n        //now here setting high value\\n        long high = (totalSum/n) +1;\\n        long answer=-1;\\n        \\n        //binary search aproach\\n        while(low<high)\\n        {\\n\\t\\t//here mainlly we r using binary aproach to iterate within the range of low and high\\n            long mid=low+(high-low)/2;\\n\\t\\t\\there checking ki is it possible to operate all pcs simultanuouslly upto that much timespan or not\\n\\t\\t\\t//if possible then set answer to mid and then agsin try for some higher value otherwise seth the condition as ki we ll just come of loop \\n            if(isPossible(n,mid,batteries))\\n            {\\n                answer=mid;\\n                low=mid+1;\\n            }\\n            else{ high=mid;}\\n        }\\n        return answer;\\n    }\\n    \\n    bool isPossible(int n,long timespan,vector<int>batteries)\\n    {\\n        long currentBatSum=0;\\n        long targetBatSum=n*timespan;\\n        for(int i=0;i<batteries.size();i++)\\n        {\\n            if(batteries[i]<timespan){  currentBatSum+=batteries[i]; }\\n            else{ currentBatSum+=timespan;}          \\n            if(currentBatSum>=targetBatSum){return true;}\\n        }\\n        return currentBatSum>=targetBatSum;\\n    }\\n long min_fun(int i,long low)\\n    {\\n        if(i>low){return low;}\\n        else{return i;}\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n   \\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        long totalSum=0,low=0;\\n\\t\\t//here i am calculating min and total sum of elements of batteries array\\n        for(int i=0;i<batteries.size();i++)\\n        {\\n            totalSum+=batteries[i];\\n            low=min_fun(batteries[i],low);\\n        }\\n        //now here setting high value\\n        long high = (totalSum/n) +1;\\n        long answer=-1;\\n        \\n        //binary search aproach\\n        while(low<high)\\n        {\\n\\t\\t//here mainlly we r using binary aproach to iterate within the range of low and high\\n            long mid=low+(high-low)/2;\\n\\t\\t\\there checking ki is it possible to operate all pcs simultanuouslly upto that much timespan or not\\n\\t\\t\\t//if possible then set answer to mid and then agsin try for some higher value otherwise seth the condition as ki we ll just come of loop \\n            if(isPossible(n,mid,batteries))\\n            {\\n                answer=mid;\\n                low=mid+1;\\n            }\\n            else{ high=mid;}\\n        }\\n        return answer;\\n    }\\n    \\n    bool isPossible(int n,long timespan,vector<int>batteries)\\n    {\\n        long currentBatSum=0;\\n        long targetBatSum=n*timespan;\\n        for(int i=0;i<batteries.size();i++)\\n        {\\n            if(batteries[i]<timespan){  currentBatSum+=batteries[i]; }\\n            else{ currentBatSum+=timespan;}          \\n            if(currentBatSum>=targetBatSum){return true;}\\n        }\\n        return currentBatSum>=targetBatSum;\\n    }\\n long min_fun(int i,long low)\\n    {\\n        if(i>low){return low;}\\n        else{return i;}\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1699880,
                "title": "python-binary-search",
                "content": "```\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        m=len(batteries)\\n        if m<n: return 0\\n        def solve(val):\\n            res=0\\n            for no in batteries:\\n                if no>val: res+=val\\n                else: res+=no\\n            return res>=val*n\\n        \\n        l,h=1,sum(batteries)\\n        while l<h:\\n            mid=l+(h-l+1)//2\\n            if solve(mid):\\n                l=mid\\n            else:\\n                h=mid-1\\n        return l\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        m=len(batteries)\\n        if m<n: return 0\\n        def solve(val):\\n            res=0\\n            for no in batteries:\\n                if no>val: res+=val\\n                else: res+=no\\n            return res>=val*n\\n        \\n        l,h=1,sum(batteries)\\n        while l<h:\\n            mid=l+(h-l+1)//2\\n            if solve(mid):\\n                l=mid\\n            else:\\n                h=mid-1\\n        return l\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1696035,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(int n, long long mid, vector<int>& batteries){\\n        long long totalBatteryNeededForAllCompToRunAtMid = n * mid;\\n        long long sum = 0;\\n        for(long long num:batteries){\\n            sum += min(num, mid);\\n            if(sum >= totalBatteryNeededForAllCompToRunAtMid) return true;\\n        }\\n        return false;\\n    }\\n    \\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        if(batteries.size() < n) return 0;\\n        long long no = batteries.size(), minBatteryACompCanGet = 0, maxBatteryACompCanGet = 0, sum = 0, result = 0;\\n        sort(batteries.begin(), batteries.end());\\n        for(auto& num:batteries) sum += num;\\n        \\n\\t\\t//high = sum is also correct, but more precisely a single computer maximum can get is sum/n\\n        maxBatteryACompCanGet = sum/n, minBatteryACompCanGet  = 0;\\n        while(minBatteryACompCanGet <= maxBatteryACompCanGet){\\n            long long mid = minBatteryACompCanGet + (maxBatteryACompCanGet - minBatteryACompCanGet)/2;\\n            if(isValid(n, mid, batteries)){\\n                result = mid;\\n                minBatteryACompCanGet = mid + 1;\\n            }else maxBatteryACompCanGet = mid - 1;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int n, long long mid, vector<int>& batteries){\\n        long long totalBatteryNeededForAllCompToRunAtMid = n * mid;\\n        long long sum = 0;\\n        for(long long num:batteries){\\n            sum += min(num, mid);\\n            if(sum >= totalBatteryNeededForAllCompToRunAtMid) return true;\\n        }\\n        return false;\\n    }\\n    \\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        if(batteries.size() < n) return 0;\\n        long long no = batteries.size(), minBatteryACompCanGet = 0, maxBatteryACompCanGet = 0, sum = 0, result = 0;\\n        sort(batteries.begin(), batteries.end());\\n        for(auto& num:batteries) sum += num;\\n        \\n\\t\\t//high = sum is also correct, but more precisely a single computer maximum can get is sum/n\\n        maxBatteryACompCanGet = sum/n, minBatteryACompCanGet  = 0;\\n        while(minBatteryACompCanGet <= maxBatteryACompCanGet){\\n            long long mid = minBatteryACompCanGet + (maxBatteryACompCanGet - minBatteryACompCanGet)/2;\\n            if(isValid(n, mid, batteries)){\\n                result = mid;\\n                minBatteryACompCanGet = mid + 1;\\n            }else maxBatteryACompCanGet = mid - 1;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1695892,
                "title": "java-binary-search-on-answer-code-75-faster-with-explanation-o-mlogm",
                "content": "\\n```\\nclass Solution {\\n    // This isValidTime returns true if time required is equal to \"time\"\\n    public static boolean isValidTime(int[] bat,int n,long time,long[] sum) {\\n        for(int i=bat.length-1;i>=0;i--) {\\n            if(n==0) return true;\\n            if(bat[i]<time) {\\n                if(sum[i]/n<time) {\\n                    return false;\\n                }\\n                break;\\n            }\\n            n--;\\n        }\\n        return true;\\n    }\\n    public long maxRunTime(int n, int[] bat) {\\n        Arrays.sort(bat); // sort in Increasing Order\\n        int m = bat.length;\\n        // Our Answer always lie in Between nth largest battery power time to total sum of battery power divided by total computer , as number of computer is always less then batteries ; and this can found easily using Binary Search On Answer\\n        long lo = bat[m-n];     // nth largest battery power time i.e lower limit\\n        long[] sum = new long[m];   // stores sum of batteries starting from 0 to m-1 at every index;\\n        long hi=0;\\n        for(int i=0;i<m;i++) {\\n            hi+=(long)bat[i];\\n            sum[i]=hi;\\n        }\\n        hi/=n;  //total sum by n i.e Upper limit\\n        long ans=lo;    // set answer to low\\n        while(lo<=hi) {\\n            long mid = lo+(hi-lo)/2;\\n            if(isValidTime(bat,n,mid,sum)) {    // if mid Value of time is Valid then we search above mid to hi\\n                if(ans<mid) ans=mid;    // update our answer\\n                lo=mid+1;\\n            } else {\\n                hi=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Binary Search Tree",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    // This isValidTime returns true if time required is equal to \"time\"\\n    public static boolean isValidTime(int[] bat,int n,long time,long[] sum) {\\n        for(int i=bat.length-1;i>=0;i--) {\\n            if(n==0) return true;\\n            if(bat[i]<time) {\\n                if(sum[i]/n<time) {\\n                    return false;\\n                }\\n                break;\\n            }\\n            n--;\\n        }\\n        return true;\\n    }\\n    public long maxRunTime(int n, int[] bat) {\\n        Arrays.sort(bat); // sort in Increasing Order\\n        int m = bat.length;\\n        // Our Answer always lie in Between nth largest battery power time to total sum of battery power divided by total computer , as number of computer is always less then batteries ; and this can found easily using Binary Search On Answer\\n        long lo = bat[m-n];     // nth largest battery power time i.e lower limit\\n        long[] sum = new long[m];   // stores sum of batteries starting from 0 to m-1 at every index;\\n        long hi=0;\\n        for(int i=0;i<m;i++) {\\n            hi+=(long)bat[i];\\n            sum[i]=hi;\\n        }\\n        hi/=n;  //total sum by n i.e Upper limit\\n        long ans=lo;    // set answer to low\\n        while(lo<=hi) {\\n            long mid = lo+(hi-lo)/2;\\n            if(isValidTime(bat,n,mid,sum)) {    // if mid Value of time is Valid then we search above mid to hi\\n                if(ans<mid) ans=mid;    // update our answer\\n                lo=mid+1;\\n            } else {\\n                hi=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1695773,
                "title": "relax-then-round-python",
                "content": "I found this question pretty tricky. Here\\'s my solution. Let\\'s first consider a relaxed version of the problem: we can switch batteries in and out at fractional time steps, which is functionally equivalent to saying we can allocate fractional charge from a battery and allocate one battery across multiple computers, but we can still only allocate at most one unit of charge per unit of time from a single battery. Note that the optimal allocation for the relaxed problem is at least as big as the optimal allocation for the original problem. I will solve the relaxed problem, and then argue that we can take the integer part of the solution to the relaxed problem for the original problem.\\n\\nLet\\'s state the relaxed problem a little more formally. We are given a vector `batteries` of length `N` and an integer `n`. Our goal is to find the largest real number `T` such that there exists a function `f : [0, T] -> [0, 1]^N` such that `sum(f(t)) == n` for all `t in [0, T]` and `integral_0^T f(t)[i] <= batteries[i]` for all `i`. Let us assume without loss of generality that `batteries` is sorted. I make the following claim: suppose we replace `batteries` with `altBatteries` such that there exist `i, j` such that `i < j` and `batteries[i] < altBatteries[i] < altBatteries[j] < batteries[j]`. Then the optimal time `altT` for `altBatteries` satisfies `altT >= T`. This is a little tedious to write out, but it\\'s straightforward to adapt the optimal `f` for `batteries` to something which is optimal for `altBatteries`. \\n\\nNow let `k` and `r` be integers such that `k < n <= k + r`, so that `batteries[-k] > batteries[-k-1]`, and `batteries[-k-1] == batteries[-k-2] == ... == batteries[-k-r]`. From the result above, you can see that for small `t`, we should have `f(t)[i] == 1` for `i >= -k`. Further, we should have `f(t)[i] == 0` for `i < -k-r`. Finally, we should have `f(t)[i] == f(t)[j]` whenever `-k-r <= i < j < -k`. This specifies `f` complely until `k` and `r` change values, yielding the optimal solution to the relaxed problem. Here is the solution to the relaxed problem in Python. Note that at the end we just take the integer part to get the solution to the integer problem.\\n\\n```\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        batteries.sort()\\n        # add a battery with zero charge for convenience\\n        batteries = [0] + batteries\\n        # the first battery in the r batteries with equal lower charge\\n        lowerThresh = len(batteries) - n\\n        # the first battery in the largest k batteries with bigger charge\\n        upperThresh = len(batteries) - n + 1\\n        # the value of the charge of the r batteries\\n        lowerVal = batteries[-n]\\n        # the current time\\n        time = 0\\n        \\n        while lowerVal > 0 and upperThresh < len(batteries):\\n            numLowerBatteries = upperThresh - lowerThresh\\n            lowerPace = (n - (len(batteries) - upperThresh)) / numLowerBatteries\\n            # compute upperTime: the time before the smallest of the k batteries has\\n            # charge equal to the r batteries\\n            if upperThresh == lowerThresh + 1:\\n                upperTime = float(\\'inf\\')\\n            else:\\n                diff = batteries[upperThresh] - time - lowerVal\\n                upperTime = diff / (1 - lowerPace)\\n                \\n            # compute lowerTime: the time before the largest of the thusfar unused batteries\\n            # has charge equal to the r batteries\\n            diff = lowerVal - batteries[lowerThresh-1]\\n            lowerTime = diff / lowerPace\\n            \\n            # move time forward by the minimum of upperTime and lowerTime, and adjust k and r\\n            # appropriately\\n            if lowerTime < upperTime:\\n                time += lowerTime\\n                lowerVal -= lowerTime * lowerPace\\n                lowerThresh -= 1\\n            else:\\n                time += upperTime\\n                lowerVal -= upperTime * lowerPace\\n                upperThresh += 1\\n                \\n        # It can happen that by the end k == 0; in this case you can completely drain all of the batteries.\\n        if upperThresh == len(batteries):\\n            time = sum(batteries) / n\\n        return int(time)\\n```\\n\\nWhy does it suffice to take the integer part to get the solution to the original problem? The original problem is the same as the relaxed problem, except that we require `f(t1) == f(t2)` if `floor(t1) == floor(t2)` and also `f(t)[i] == 0` or `f(t)[i] == 1` for all `i, t`. To get an `fOrig` for the original problem such that the corresponding `TOrig == int(T)`, follow the procedure above, except in this case split the group of `r` batteries on each day into groups of size `r1` and `r2`. That is, assume `k + r1 + r2 >= n`, that we are on day `t`, that  the `r1` batteries all have the same charge `c`, and the `r2` batteries have charge `c + 1`, while the `k` batteries have charge greater than `c+1`, and the remaining batteries have charge less than `c`. Assume that on day `t`, in the relaxed problem the `r` batteries have charge `C` with `c <= C <= c+1`. Use all of the `k` batteries, up to `n-k` batteries from the `r1` batteries, and the remaining `n-k-r1` batteries from the `r2` batteries if necessary, and use those for the day. On the next day, after possibly moving some of the `k` batteries into the `r2` batteries and possibly moving some of the unused batteries into the `r1` batteries. Then it will still hold that on the next day `c <= C <= c + 1`, which implies that `TOrig == int(T)`.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        batteries.sort()\\n        # add a battery with zero charge for convenience\\n        batteries = [0] + batteries\\n        # the first battery in the r batteries with equal lower charge\\n        lowerThresh = len(batteries) - n\\n        # the first battery in the largest k batteries with bigger charge\\n        upperThresh = len(batteries) - n + 1\\n        # the value of the charge of the r batteries\\n        lowerVal = batteries[-n]\\n        # the current time\\n        time = 0\\n        \\n        while lowerVal > 0 and upperThresh < len(batteries):\\n            numLowerBatteries = upperThresh - lowerThresh\\n            lowerPace = (n - (len(batteries) - upperThresh)) / numLowerBatteries\\n            # compute upperTime: the time before the smallest of the k batteries has\\n            # charge equal to the r batteries\\n            if upperThresh == lowerThresh + 1:\\n                upperTime = float(\\'inf\\')\\n            else:\\n                diff = batteries[upperThresh] - time - lowerVal\\n                upperTime = diff / (1 - lowerPace)\\n                \\n            # compute lowerTime: the time before the largest of the thusfar unused batteries\\n            # has charge equal to the r batteries\\n            diff = lowerVal - batteries[lowerThresh-1]\\n            lowerTime = diff / lowerPace\\n            \\n            # move time forward by the minimum of upperTime and lowerTime, and adjust k and r\\n            # appropriately\\n            if lowerTime < upperTime:\\n                time += lowerTime\\n                lowerVal -= lowerTime * lowerPace\\n                lowerThresh -= 1\\n            else:\\n                time += upperTime\\n                lowerVal -= upperTime * lowerPace\\n                upperThresh += 1\\n                \\n        # It can happen that by the end k == 0; in this case you can completely drain all of the batteries.\\n        if upperThresh == len(batteries):\\n            time = sum(batteries) / n\\n        return int(time)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1695093,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& arr) {\\n            int t = arr.size();\\n            long long sum = 0;\\n            for(int i=0; i<t; i++)\\n            {\\n                sum +=arr[i];    \\n            }\\n            long long r = sum/n +1;\\n            sort(arr.begin(), arr.end());\\n            long long l = arr[t-n];\\n            long long ans = 0;\\n            while(l<r)\\n            {\\n                    long long mid = (l+r)/2;\\n                    int k = t-1;\\n                    while(k>=0 && arr[k] >= mid)\\n                    {\\n                                k--;\\n                    }\\n                    int rem = n - (t-1-k);\\n                    long long curr = 0;\\n                    while(k>=0 )\\n                    {\\n                            curr +=arr[k];\\n                            k--;\\n                    }\\n                    if(rem<=0 || rem*mid <= curr)\\n                    {\\n                            ans = max(ans, mid);\\n                            l = mid+1;\\n                    }\\n                    else\\n                    {\\n                            r = mid;\\n                    }\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& arr) {\\n            int t = arr.size();\\n            long long sum = 0;\\n            for(int i=0; i<t; i++)\\n            {\\n                sum +=arr[i];    \\n            }\\n            long long r = sum/n +1;\\n            sort(arr.begin(), arr.end());\\n            long long l = arr[t-n];\\n            long long ans = 0;\\n            while(l<r)\\n            {\\n                    long long mid = (l+r)/2;\\n                    int k = t-1;\\n                    while(k>=0 && arr[k] >= mid)\\n                    {\\n                                k--;\\n                    }\\n                    int rem = n - (t-1-k);\\n                    long long curr = 0;\\n                    while(k>=0 )\\n                    {\\n                            curr +=arr[k];\\n                            k--;\\n                    }\\n                    if(rem<=0 || rem*mid <= curr)\\n                    {\\n                            ans = max(ans, mid);\\n                            l = mid+1;\\n                    }\\n                    else\\n                    {\\n                            r = mid;\\n                    }\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694853,
                "title": "c-a-different-approach-start-filling-batters-from-minimum-possible",
                "content": "Sort the batteries in decreasing order and then from the nth battery start filling till n-1th battery. If you can reach there, start filling till n-2nd batter and so on\\n\\n```\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        sort(begin(batteries), end(batteries), greater<int>());\\n        \\n        int m = batteries.size();\\n        long long sum = 0;\\n        for(int i = n; i < m; ++i) sum += batteries[i];\\n        \\n        for(long long i = n-1; i > 0; --i){\\n            \\n            long long diff = (batteries[i-1] - batteries[i])*(n-i);\\n            \\n            if(diff > sum){\\n                return batteries[i] + (sum/(n-i));\\n            }\\n            \\n            sum -= diff;\\n        }\\n        \\n        return batteries[0] + (sum/n);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        sort(begin(batteries), end(batteries), greater<int>());\\n        \\n        int m = batteries.size();\\n        long long sum = 0;\\n        for(int i = n; i < m; ++i) sum += batteries[i];\\n        \\n        for(long long i = n-1; i > 0; --i){\\n            \\n            long long diff = (batteries[i-1] - batteries[i])*(n-i);\\n            \\n            if(diff > sum){\\n                return batteries[i] + (sum/(n-i));\\n            }\\n            \\n            sum -= diff;\\n        }\\n        \\n        return batteries[0] + (sum/n);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1694576,
                "title": "c-20-lines-beat-80-gready-ans-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        vector<int>& b= batteries;\\n        sort(b.begin(), b.end(), greater<int>());\\n        long long r=0;\\n        vector<int> to_even;\\n        long long ans=(long long)b[n-1]; \\n        for(int i=0; i<n;i++){if(b[i]==ans) {break;}to_even.push_back(b[i]);}\\n        long long cnt=1;\\n        for(int i=n;i<b.size();i++){ long long remain=(long long)b[i]+r;\\n            while(to_even.size()>0 ){ int target= to_even.back();\\n                cnt= n- to_even.size();\\n                if( remain>= (target-ans)*cnt){\\n                    remain-= (target-ans)*cnt; ans=target; to_even.pop_back();}\\n                else {break;}\\n            } \\n            cnt= n- to_even.size();\\n            ans+= (remain)/cnt;  r= (remain)%cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        vector<int>& b= batteries;\\n        sort(b.begin(), b.end(), greater<int>());\\n        long long r=0;\\n        vector<int> to_even;\\n        long long ans=(long long)b[n-1]; \\n        for(int i=0; i<n;i++){if(b[i]==ans) {break;}to_even.push_back(b[i]);}\\n        long long cnt=1;\\n        for(int i=n;i<b.size();i++){ long long remain=(long long)b[i]+r;\\n            while(to_even.size()>0 ){ int target= to_even.back();\\n                cnt= n- to_even.size();\\n                if( remain>= (target-ans)*cnt){\\n                    remain-= (target-ans)*cnt; ans=target; to_even.pop_back();}\\n                else {break;}\\n            } \\n            cnt= n- to_even.size();\\n            ans+= (remain)/cnt;  r= (remain)%cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694146,
                "title": "c-sort-solution-with-explaination-with-diagram-o-n-log-n-n",
                "content": "![image](https://assets.leetcode.com/users/images/9cdd7068-182b-4939-8d58-2ea0bd947211_1642326325.367093.png)\\n\\n\\n\\nThe simple intution is that we will take top most n powerfull battey as main battery and fill them with other left batteries starting from least powerfull among choosen ones.\\n\\nI am here trying to make least powerfull battries to the same level to the more powerfull batteries. \\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& B) {\\n        sort(B.begin(), B.end());\\n        reverse(B.begin(), B.end());\\n        long long int extra = 0, main = 0;\\n        for(int i = 0; i < n; i++){\\n            main += B[i];\\n        }\\n        for(int i = n; i < B.size(); i++) extra += B[i];\\n        \\n        long long int time = B[n-1];\\n        int i = n-1;\\n        while(i > 0 and extra > 0){\\n            if(extra >= (B[i-1] - B[i])*(n-i)){\\n                time += B[i-1] - B[i];\\n                extra -= (B[i-1] - B[i])*(n-i);\\n            }\\n            else{\\n                time += extra/(n-i);\\n                extra = 0;\\n            }\\n            i--;\\n        }\\n        time += extra/n;\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& B) {\\n        sort(B.begin(), B.end());\\n        reverse(B.begin(), B.end());\\n        long long int extra = 0, main = 0;\\n        for(int i = 0; i < n; i++){\\n            main += B[i];\\n        }\\n        for(int i = n; i < B.size(); i++) extra += B[i];\\n        \\n        long long int time = B[n-1];\\n        int i = n-1;\\n        while(i > 0 and extra > 0){\\n            if(extra >= (B[i-1] - B[i])*(n-i)){\\n                time += B[i-1] - B[i];\\n                extra -= (B[i-1] - B[i])*(n-i);\\n            }\\n            else{\\n                time += extra/(n-i);\\n                extra = 0;\\n            }\\n            i--;\\n        }\\n        time += extra/n;\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694072,
                "title": "c-binary-search-to-guess-final-result-o-m-log-m",
                "content": "I am using standard Binary Search template.\\nBut, this search is guessing a result and evaluate if this result can fit all computers.\\n\\n```\\npublic class Solution {\\n    public long MaxRunTime(int n, int[] batteries) {\\n        long sum = 0;\\n        foreach (var b in batteries)\\n            sum += b;\\n        \\n        // binary search\\n        long left = 0;\\n        long right = sum / n;\\n        \\n        while (left < right)\\n        {\\n            long mid = left + (right - left + 1) / 2;\\n            \\n            if (CanFit(n, batteries, mid))\\n                left = mid;\\n            else\\n                right = mid - 1;\\n        }\\n        \\n        return left;\\n    }\\n    \\n\\t// Bigger battery can only provide the target power.\\n\\t// Smaller batter can just provide its full power.\\n    bool CanFit(int n, int[] batteries, long target)\\n    {\\n        long sum = 0;\\n        foreach (var b in batteries)\\n        {\\n            sum += Math.Min(target, b);\\n        }\\n        \\n        return sum >= target * n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\npublic class Solution {\\n    public long MaxRunTime(int n, int[] batteries) {\\n        long sum = 0;\\n        foreach (var b in batteries)\\n            sum += b;\\n        \\n        // binary search\\n        long left = 0;\\n        long right = sum / n;\\n        \\n        while (left < right)\\n        {\\n            long mid = left + (right - left + 1) / 2;\\n            \\n            if (CanFit(n, batteries, mid))\\n                left = mid;\\n            else\\n                right = mid - 1;\\n        }\\n        \\n        return left;\\n    }\\n    \\n\\t// Bigger battery can only provide the target power.\\n\\t// Smaller batter can just provide its full power.\\n    bool CanFit(int n, int[] batteries, long target)\\n    {\\n        long sum = 0;\\n        foreach (var b in batteries)\\n        {\\n            sum += Math.Min(target, b);\\n        }\\n        \\n        return sum >= target * n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694038,
                "title": "c-greedy-solution-with-sorting-o-n-logn",
                "content": "```\\npublic class Solution \\n{\\n    public long MaxRunTime(int n, int[] batteries) \\n    {\\n        long sum = batteries.Select(x => (long) x).Sum();\\n        foreach (int battery in batteries.OrderByDescending(x => x)) \\n        {\\n            if (battery <= sum / n) return sum / n;\\n            sum -= battery;\\n            --n;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public long MaxRunTime(int n, int[] batteries) \\n    {\\n        long sum = batteries.Select(x => (long) x).Sum();\\n        foreach (int battery in batteries.OrderByDescending(x => x)) \\n        {\\n            if (battery <= sum / n) return sum / n;\\n            sum -= battery;\\n            --n;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693541,
                "title": "c-binary-search-intuition-explanation",
                "content": "```\\n\\n// --------------- Intuition for binary search-----------------------------------\\n// Let us take a value of minutes - M\\n// Now we check if it is possible to run N computers, simultaneously for M minutes\\n\\n//------------ logic for search space reduction------------------------------------\\n// If yes - we can consider this value of M as a possible ans and search on all values greater than M\\n// Note - even after getting a yes, we dont stop searching, as we want to find the Max value of M. \\n// If no - we need to reduce the value M, so we check the condition for values < M\\n\\n// -------------Deciding the range for binary search-----------------------\\n//For simplicity let\\'s keep the minimum running minutes = 0\\n//In the case where number of computers is 1, the max time for which it can run is some of runtime of all batteries, so\\n//max run time value = sum(values of batteries run time)\\n\\n//-------------- How to check this ?  \"If it is possible to run N computers, simultaneously for M minutes\" -------------\\n// total running minutes required = N comp * M ninutes = NM minutes\\n// total minutes batteries can run simulatanesouly if given max minutes as M = sum of batteries runtime values with a map cap of M minutes\\n// if total minutes batteries can run simulatanesouly if given max minutes as M  >= total running minutes required, we return yes, else false\\n\\n\\nclass Solution {\\npublic:\\n    \\n    bool canRun(vector<int>& batteries, int computers, long long M){\\n        \\n        long long requiredRunMins = computers*M;\\n        for(long long b: batteries)\\n            requiredRunMins-=min(M,b);\\n        return (requiredRunMins<=0);\\n        \\n    }\\n    \\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        \\n        long long maxMins = 0;\\n        long long possibleAns=0;\\n\\n        for(int b : batteries)\\n            maxMins+=b;\\n        \\n        long long lMins=0, rMins=maxMins;\\n        while(lMins<=rMins)\\n        {\\n            long long midMins = lMins+(rMins-lMins)/2;\\n            if(canRun(batteries, n, midMins))\\n            {\\n                possibleAns = midMins;\\n                lMins = midMins+1;\\n            }\\n            else\\n            {\\n                rMins= midMins-1;\\n            }\\n        }\\n        return possibleAns;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    bool canRun(vector<int>& batteries, int computers, long long M){\\n        \\n        long long requiredRunMins = computers*M;\\n        for(long long b: batteries)\\n            requiredRunMins-=min(M,b);\\n        return (requiredRunMins<=0);\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1693286,
                "title": "heap-solution-tle",
                "content": "Can anyone help me optimize my solution using a max-heap? I understand subtracting one from every element popped from the heap is not the most efficient, but I haven\\'t been able to find a way to improve runtime while maintaining correctness. Thank you!\\n\\n```\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        heap = []\\n\\t\\tret = 0\\n        \\n        for battery in batteries:\\n            heapq.heappush(heap, -1*battery)\\n        \\n        while len(heap) >= n:\\n            temp = []\\n            for i in range(n):\\n                top = -1*heapq.heappop(heap)\\n                temp.append(top)\\n            \\n            ret += 1\\n            for i in range(n):\\n                temp[i] -= 1\\n                if temp[i] > 0:\\n                    heapq.heappush(heap, -1*temp[i])\\n             \\n        return ret\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        heap = []\\n\\t\\tret = 0\\n        \\n        for battery in batteries:\\n            heapq.heappush(heap, -1*battery)\\n        \\n        while len(heap) >= n:\\n            temp = []\\n            for i in range(n):\\n                top = -1*heapq.heappop(heap)\\n                temp.append(top)\\n            \\n            ret += 1\\n            for i in range(n):\\n                temp[i] -= 1\\n                if temp[i] > 0:\\n                    heapq.heappush(heap, -1*temp[i])\\n             \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991448,
                "title": "intuitive-binary-search-c-code",
                "content": "# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll sum;\\n    bool f(int n,vector<int>&a, ll m){\\n        ll localsum=sum;\\n        for(int i=0;i<a.size();i++){\\n            if(a[i]>=m){\\n                localsum-=a[i];\\n                n--;\\n            }\\n            else break;\\n        }\\n        ll reqpower=long(n)*m;\\n        if(localsum>=reqpower)return true;\\n        return false;\\n    }\\n\\n    ll maxRunTime(int n, vector<int>& a) {\\n        sort(a.begin(),a.end());\\n        reverse(a.begin(),a.end());\\n        for(auto i:a)sum+=i;\\n        ll l=0, r=1e14,ans=0;\\n        while(l<=r){\\n            ll m = (l+r)/2;\\n            if(f(n,a,m)){\\n                ans=m;\\n                l=m+1;\\n            }\\n            else r=m-1;\\n        }  \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll sum;\\n    bool f(int n,vector<int>&a, ll m){\\n        ll localsum=sum;\\n        for(int i=0;i<a.size();i++){\\n            if(a[i]>=m){\\n                localsum-=a[i];\\n                n--;\\n            }\\n            else break;\\n        }\\n        ll reqpower=long(n)*m;\\n        if(localsum>=reqpower)return true;\\n        return false;\\n    }\\n\\n    ll maxRunTime(int n, vector<int>& a) {\\n        sort(a.begin(),a.end());\\n        reverse(a.begin(),a.end());\\n        for(auto i:a)sum+=i;\\n        ll l=0, r=1e14,ans=0;\\n        while(l<=r){\\n            ll m = (l+r)/2;\\n            if(f(n,a,m)){\\n                ans=m;\\n                l=m+1;\\n            }\\n            else r=m-1;\\n        }  \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950328,
                "title": "easy-bin-search-python",
                "content": "```\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        lb = len(batteries)\\n        batteries.sort(reverse=False) # ordering allows you to use the remainder of the batteries in the for cycle\\n        def check(t):\\n            g = 0\\n            z = 0\\n            for i in range(lb):\\n                z+=batteries[i]\\n                if z >= t:\\n                    g+=1\\n                    z=z%t #use remaining battery time\\n            return g >= n\\n        l = 1\\n        r = sys.maxsize\\n        while l<r:\\n            m = (l+r+1)//2\\n            if check(m):\\n                l = m\\n            else:\\n                r = m-1\\n        return l\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        lb = len(batteries)\\n        batteries.sort(reverse=False) # ordering allows you to use the remainder of the batteries in the for cycle\\n        def check(t):\\n            g = 0\\n            z = 0\\n            for i in range(lb):\\n                z+=batteries[i]\\n                if z >= t:\\n                    g+=1\\n                    z=z%t #use remaining battery time\\n            return g >= n\\n        l = 1\\n        r = sys.maxsize\\n        while l<r:\\n            m = (l+r+1)//2\\n            if check(m):\\n                l = m\\n            else:\\n                r = m-1\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947716,
                "title": "one-more-binary-search",
                "content": "```\\nuse std::cmp::min;\\n\\n\\nimpl Solution {\\n    pub fn check(batteries: & Vec<i32>, time: i64, n: i64) -> bool {\\n        let mut sum: i64 = 0;\\n        for b in batteries {\\n            sum += min(time, *b as i64)\\n        }\\n        return sum >= time * n\\n    }\\n\\n    pub fn max_run_time(n: i32, batteries: Vec<i32>) -> i64 {\\n        let mut left: i64 = 1;\\n        let mut sum: i64 = 0;\\n        for b in batteries.iter() {sum += *b as i64};\\n        let mut right: i64 = sum / n as i64;\\n        let mut time: i64;\\n        loop {\\n            println!(\"{} {}\", left, right);\\n            if left >= right {break}\\n            time = (left + right + 1) / 2;\\n            if Solution::check(&batteries, time, n as i64) {\\n                left = time\\n            }\\n            else {\\n                right = time - 1\\n            }\\n        }\\n        return left\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cmp::min;\\n\\n\\nimpl Solution {\\n    pub fn check(batteries: & Vec<i32>, time: i64, n: i64) -> bool {\\n        let mut sum: i64 = 0;\\n        for b in batteries {\\n            sum += min(time, *b as i64)\\n        }\\n        return sum >= time * n\\n    }\\n\\n    pub fn max_run_time(n: i32, batteries: Vec<i32>) -> i64 {\\n        let mut left: i64 = 1;\\n        let mut sum: i64 = 0;\\n        for b in batteries.iter() {sum += *b as i64};\\n        let mut right: i64 = sum / n as i64;\\n        let mut time: i64;\\n        loop {\\n            println!(\"{} {}\", left, right);\\n            if left >= right {break}\\n            time = (left + right + 1) / 2;\\n            if Solution::check(&batteries, time, n as i64) {\\n                left = time\\n            }\\n            else {\\n                right = time - 1\\n            }\\n        }\\n        return left\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3942774,
                "title": "simple-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nn computers. If batteries were just n, then the minimum battery is the answer. For extra batteries, we can use it to increase the minimum, if possible up to the next smallest battery. Since the batteries can be swapped around, for the extra batteries each unit power is interchangeable.\\n\\nGreedy: After sorting the batteries, we are left with leftover power which we want to maximize the use of. We try to find the next lowest battery and match all the batteries that are currently equal to the lowest value to this next lowest battery. We keep doing this for all the batteries from the lower end till we run out of power. If we reach the end of the array, then we add as much power as we can over the n batteries as possible from the remaining power. If we run out of power before reaching the end of the array we also add as much power we can over the batteries equal to the current minimum as possible.\\n\\nBinary search over answer: We binary search over the max possible time/power to run the computers. For each value of power per computer, a battery can contribute min(p, battery[i]) to the total power, as a battery with excess power cannot power any other computers (the reason that in the greedy approach we do not use the excess energy of other batteries). So if the sum of min(p, battery[i]) over battery is >= p*n then the value p is possible, else not. This comparison is a monotone function over the set of possible max possible times. The lower bound is 1 and the right boundary can be (sum of all battery values)/n. (I used max(battery) times n for overkill).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        long long ans;\\n\\n        int b = batteries.size();\\n\\n        sort(batteries.begin(), batteries.end());\\n        reverse(batteries.begin(), batteries.end());\\n\\n        long long rem = 0;\\n        ans = batteries[n-1];\\n\\n        for(int i = n; i<b; i++)\\n        {\\n            rem += batteries[i];\\n        }\\n\\n        int i = n-1;\\n\\n        while(i >= 0)\\n        {\\n            int j = i-1;\\n            while(j >= 0 && batteries[j] == batteries[i])\\n            {\\n                j--;\\n            }\\n\\n            if(j >= 0)\\n            {\\n                long long increase = batteries[j] - batteries[i];\\n                long long amount = increase*((n-1) - j);\\n\\n                if(amount <= rem)\\n                {\\n                    rem = rem-amount;\\n                    ans = batteries[j];\\n                    i = j;\\n                }\\n                else\\n                {\\n                    ans += rem/((n-1) - j);\\n                    break;\\n                }\\n            }\\n            else\\n            {\\n                ans += rem/n;\\n                break;\\n            } \\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    bool check(long long target, int n, vector<int>& batteries, long long sum)\\n    {\\n        if(target*n > sum)\\n        {\\n            return false;\\n        }\\n\\n        long long possible_target_sum = 0;\\n\\n        for(int i = 0; i<batteries.size(); i++)\\n        {\\n            possible_target_sum += min(batteries[i]*1LL, target);\\n        }\\n\\n        if(possible_target_sum >= target*n)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        long long ans = -1;\\n        long long sum = 0;\\n        long long mx = 0;\\n        int b = batteries.size();\\n\\n        for(int i = 0; i<b; i++)\\n        {\\n            sum += batteries[i]*1LL;\\n            mx = max(mx, batteries[i]*1LL);\\n        }\\n\\n        long long lo = 0;\\n        long long hi = mx*b;\\n\\n        while(lo <= hi)\\n        {\\n            long long mid = lo + (hi - lo)/2;\\n            if(check(mid, n, batteries, sum))\\n            {\\n                ans = mid;\\n                lo = mid+1;\\n            }\\n            else\\n            {\\n                hi = mid-1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        long long ans;\\n\\n        int b = batteries.size();\\n\\n        sort(batteries.begin(), batteries.end());\\n        reverse(batteries.begin(), batteries.end());\\n\\n        long long rem = 0;\\n        ans = batteries[n-1];\\n\\n        for(int i = n; i<b; i++)\\n        {\\n            rem += batteries[i];\\n        }\\n\\n        int i = n-1;\\n\\n        while(i >= 0)\\n        {\\n            int j = i-1;\\n            while(j >= 0 && batteries[j] == batteries[i])\\n            {\\n                j--;\\n            }\\n\\n            if(j >= 0)\\n            {\\n                long long increase = batteries[j] - batteries[i];\\n                long long amount = increase*((n-1) - j);\\n\\n                if(amount <= rem)\\n                {\\n                    rem = rem-amount;\\n                    ans = batteries[j];\\n                    i = j;\\n                }\\n                else\\n                {\\n                    ans += rem/((n-1) - j);\\n                    break;\\n                }\\n            }\\n            else\\n            {\\n                ans += rem/n;\\n                break;\\n            } \\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool check(long long target, int n, vector<int>& batteries, long long sum)\\n    {\\n        if(target*n > sum)\\n        {\\n            return false;\\n        }\\n\\n        long long possible_target_sum = 0;\\n\\n        for(int i = 0; i<batteries.size(); i++)\\n        {\\n            possible_target_sum += min(batteries[i]*1LL, target);\\n        }\\n\\n        if(possible_target_sum >= target*n)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        long long ans = -1;\\n        long long sum = 0;\\n        long long mx = 0;\\n        int b = batteries.size();\\n\\n        for(int i = 0; i<b; i++)\\n        {\\n            sum += batteries[i]*1LL;\\n            mx = max(mx, batteries[i]*1LL);\\n        }\\n\\n        long long lo = 0;\\n        long long hi = mx*b;\\n\\n        while(lo <= hi)\\n        {\\n            long long mid = lo + (hi - lo)/2;\\n            if(check(mid, n, batteries, sum))\\n            {\\n                ans = mid;\\n                lo = mid+1;\\n            }\\n            else\\n            {\\n                hi = mid-1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919155,
                "title": "java-simple-code-with-stepwise-explanation",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxRunTime(int n, int[] batteries) {\\n        if(n>batteries.length) return 0;\\n        Arrays.sort(batteries);\\n        long sum = 0;\\n        for(int i=0;i<batteries.length;i++)\\n        {\\n            sum += batteries[i];\\n        }\\n\\n        // this is the maximum time we can run the computer(average)\\n        long maxTime=sum/n+1;\\n        long minTime = batteries[batteries.length-n];\\n        long ans=0;\\n\\n        //now we will searching for the max time we can run \\n        while(minTime <maxTime)\\n        {\\n            //we search for the max time\\n            long mid = minTime +(maxTime-minTime)/2;\\n            //this is iterator to move from right to left\\n            int k = batteries.length-1; int runnable=0;\\n            while(k>=0 && batteries[k]>=mid)\\n            {\\n                k--;\\n                runnable++;\\n            }\\n            //This is the remaining numbers of computers\\n            long remComp = n-runnable; \\n            //This will count remaining charge and help check if remaining computers can run for (mid) time\\n            long temp =0;\\n            while(k>=0)\\n            {\\n                temp += batteries[k];\\n                k--;\\n            }\\n            //Check if it is possible to run the remaining computers\\n            if(remComp*mid<=temp)\\n            {\\n                ans = Math.max(ans,mid);\\n                minTime = mid+1;\\n            }\\n            else{\\n                maxTime = mid;\\n            }\\n\\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public long maxRunTime(int n, int[] batteries) {\\n        if(n>batteries.length) return 0;\\n        Arrays.sort(batteries);\\n        long sum = 0;\\n        for(int i=0;i<batteries.length;i++)\\n        {\\n            sum += batteries[i];\\n        }\\n\\n        // this is the maximum time we can run the computer(average)\\n        long maxTime=sum/n+1;\\n        long minTime = batteries[batteries.length-n];\\n        long ans=0;\\n\\n        //now we will searching for the max time we can run \\n        while(minTime <maxTime)\\n        {\\n            //we search for the max time\\n            long mid = minTime +(maxTime-minTime)/2;\\n            //this is iterator to move from right to left\\n            int k = batteries.length-1; int runnable=0;\\n            while(k>=0 && batteries[k]>=mid)\\n            {\\n                k--;\\n                runnable++;\\n            }\\n            //This is the remaining numbers of computers\\n            long remComp = n-runnable; \\n            //This will count remaining charge and help check if remaining computers can run for (mid) time\\n            long temp =0;\\n            while(k>=0)\\n            {\\n                temp += batteries[k];\\n                k--;\\n            }\\n            //Check if it is possible to run the remaining computers\\n            if(remComp*mid<=temp)\\n            {\\n                ans = Math.max(ans,mid);\\n                minTime = mid+1;\\n            }\\n            else{\\n                maxTime = mid;\\n            }\\n\\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919133,
                "title": "simple-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[]} batteries\\n * @return {number}\\n */\\nvar maxRunTime = function (n, batteries) {\\n    let result = 0\\n    batteries.sort((a, b) => a - b)\\n    for (let i = 0; i < batteries.length; i++) {\\n        result += batteries[i]\\n    }\\n    while (batteries.at(-1) > result / n)\\n        --n, result -= batteries.pop();\\n    return Math.floor(result / n)\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Binary Search",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[]} batteries\\n * @return {number}\\n */\\nvar maxRunTime = function (n, batteries) {\\n    let result = 0\\n    batteries.sort((a, b) => a - b)\\n    for (let i = 0; i < batteries.length; i++) {\\n        result += batteries[i]\\n    }\\n    while (batteries.at(-1) > result / n)\\n        --n, result -= batteries.pop();\\n    return Math.floor(result / n)\\n};\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3918469,
                "title": "2141-maximum-running-time-of-n-computers-solve",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxRunTime(self, n, batteries):\\n        # Sort the battery runtimes in ascending order.\\n        batteries.sort()\\n\\n        # Calculate the total extra runtime from batteries not used.\\n        extra = sum(batteries[:-n])\\n\\n        # Select the \\'n\\' largest batteries for the \\'n\\' computers.\\n        live = batteries[-n:]\\n\\n        # Distribute extra runtime among computers with small batteries.\\n        for i in range(n - 1):\\n            target_runtime = extra // (i + 1)\\n            \\n            # If extra runtime can increase the current computer\\'s runtime,\\n            # do so and return the result.\\n            if target_runtime < live[i + 1] - live[i]:\\n                return live[i] + target_runtime\\n            \\n            # Deduct the power used for extending current computer\\'s runtime.\\n            extra -= (i + 1) * (live[i + 1] - live[i])\\n\\n        # Distribute any remaining extra runtime equally among all computers.\\n        return live[-1] + extra // n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxRunTime(self, n, batteries):\\n        # Sort the battery runtimes in ascending order.\\n        batteries.sort()\\n\\n        # Calculate the total extra runtime from batteries not used.\\n        extra = sum(batteries[:-n])\\n\\n        # Select the \\'n\\' largest batteries for the \\'n\\' computers.\\n        live = batteries[-n:]\\n\\n        # Distribute extra runtime among computers with small batteries.\\n        for i in range(n - 1):\\n            target_runtime = extra // (i + 1)\\n            \\n            # If extra runtime can increase the current computer\\'s runtime,\\n            # do so and return the result.\\n            if target_runtime < live[i + 1] - live[i]:\\n                return live[i] + target_runtime\\n            \\n            # Deduct the power used for extending current computer\\'s runtime.\\n            extra -= (i + 1) * (live[i + 1] - live[i])\\n\\n        # Distribute any remaining extra runtime equally among all computers.\\n        return live[-1] + extra // n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870670,
                "title": "fast-bs-approach-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool possible(vector<int>& bat, long long mid,int numComp){\\n        long long sum=0;\\n        for(long long b:bat){\\n            if(b>=mid){\\n                sum+=mid;\\n            }else{\\n                sum+=b;\\n            }\\n        }\\n        return ((mid * numComp) <= sum);\\n    }\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        long long low=0, high=accumulate(batteries.begin(),batteries.end(),0LL);\\n        long long ans;\\n        while(low<=high){\\n            long long mid = low+(high-low)/2;\\n            if(possible(batteries,mid,n)){\\n                ans=mid;\\n                low=mid+1;\\n            }else{\\n                high=mid-1;\\n            }\\n        }return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool possible(vector<int>& bat, long long mid,int numComp){\\n        long long sum=0;\\n        for(long long b:bat){\\n            if(b>=mid){\\n                sum+=mid;\\n            }else{\\n                sum+=b;\\n            }\\n        }\\n        return ((mid * numComp) <= sum);\\n    }\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        long long low=0, high=accumulate(batteries.begin(),batteries.end(),0LL);\\n        long long ans;\\n        while(low<=high){\\n            long long mid = low+(high-low)/2;\\n            if(possible(batteries,mid,n)){\\n                ans=mid;\\n                low=mid+1;\\n            }else{\\n                high=mid-1;\\n            }\\n        }return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863663,
                "title": "efficient-battery-allocation-for-maximum-computer-runtime",
                "content": "## Intuition\\nThe problem requires maximizing the simultaneous runtime of all computers given the battery capacity. We can use binary search to efficiently find the maximum runtime and allocate the batteries to each computer greedily to achieve the desired result.\\n\\n## Approach\\n1. Calculate the sum of all battery capacities (`sm`) and sort the batteries in descending order.\\n2. Initialize `low` and `hgh` as 0 and `sm` respectively, and `ans` as -1.\\n3. Perform binary search to find the maximum runtime. In each iteration:\\n   a. Calculate `mid` as the average of `low` and `hgh`.\\n   b. Use the helper function `check` to determine if it\\'s possible to run all computers for `mid` minutes simultaneously. If possible, update `ans` and `low`, else update `hgh`.\\n4. Return the final `ans`.\\n\\n## Complexity\\n- Time complexity: O(n log sm) where n is the number of batteries and sm is the sum of all battery capacities.\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(long long sm,long long mid,vector<int>&batteries,int n){\\n        long long carry=0;\\n        int cnt=0;\\n        long long vd=0;\\n        int i=0;\\n        for(i=0;i<batteries.size();i++){\\n            vd+=max(0ll,mid-batteries[i]);     \\n            cnt++;\\n            if(cnt==n)break;\\n        }\\n       long long pf=0;\\n        for(int j=i+1;j<batteries.size();j++){\\n            pf+=batteries[j];\\n        }\\n        if(pf>=vd){\\n        return true;\\n        }\\n        return false;\\n    }\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        long long sm=0ll;\\n        for(int i=0;i<batteries.size();i++){\\n            sm+=batteries[i];\\n        }\\n        sort(batteries.rbegin(),batteries.rend());\\n        long long low=0,hgh=sm;\\n        long long ans=-1;\\n        while(low<=hgh){\\n            long long mid=(low+hgh)/2;\\n            if(!check(sm,mid,batteries,n)){\\n                hgh=mid-1;\\n            }\\n            else {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(long long sm,long long mid,vector<int>&batteries,int n){\\n        long long carry=0;\\n        int cnt=0;\\n        long long vd=0;\\n        int i=0;\\n        for(i=0;i<batteries.size();i++){\\n            vd+=max(0ll,mid-batteries[i]);     \\n            cnt++;\\n            if(cnt==n)break;\\n        }\\n       long long pf=0;\\n        for(int j=i+1;j<batteries.size();j++){\\n            pf+=batteries[j];\\n        }\\n        if(pf>=vd){\\n        return true;\\n        }\\n        return false;\\n    }\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        long long sm=0ll;\\n        for(int i=0;i<batteries.size();i++){\\n            sm+=batteries[i];\\n        }\\n        sort(batteries.rbegin(),batteries.rend());\\n        long long low=0,hgh=sm;\\n        long long ans=-1;\\n        while(low<=hgh){\\n            long long mid=(low+hgh)/2;\\n            if(!check(sm,mid,batteries,n)){\\n                hgh=mid-1;\\n            }\\n            else {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845688,
                "title": "c-binary-search-over-range",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool possible(int n, vector<int> &b, long long hrs){\\n        long long int sum = 0;\\n        for(int i=0; i<b.size(); i++){\\n            sum += b[i];\\n            if(sum >= hrs)\\n                sum -= hrs, n--;\\n            if(n==0) \\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    long long maxRunTime(int n, vector<int> &b) {\\n        long long int start=1, end=0,mid=0;\\n        for(int i=0; i<b.size(); i++) \\n            end += b[i];\\n        end /= n;\\n        \\n        sort(b.begin(), b.end());\\n        while(start < end){\\n             mid = (end+start+1)/2;\\n            if(possible(n, b, mid))\\n                start = mid;\\n            else\\n                end = mid-1;\\n        }\\n        return start;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool possible(int n, vector<int> &b, long long hrs){\\n        long long int sum = 0;\\n        for(int i=0; i<b.size(); i++){\\n            sum += b[i];\\n            if(sum >= hrs)\\n                sum -= hrs, n--;\\n            if(n==0) \\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    long long maxRunTime(int n, vector<int> &b) {\\n        long long int start=1, end=0,mid=0;\\n        for(int i=0; i<b.size(); i++) \\n            end += b[i];\\n        end /= n;\\n        \\n        sort(b.begin(), b.end());\\n        while(start < end){\\n             mid = (end+start+1)/2;\\n            if(possible(n, b, mid))\\n                start = mid;\\n            else\\n                end = mid-1;\\n        }\\n        return start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835134,
                "title": "easy-solution",
                "content": "# Complexity\\n- Time complexity: O(MlogM)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntypedef long long int ll;\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        ll low=1,high=LONG_MAX;\\n        ll ans=0;\\n        sort(batteries.begin(),batteries.end(),greater<int>());\\n        ll batteriesLeft=0;\\n        //excess batteries after n batteries\\n        for(int i=n;i<batteries.size();++i){\\n            batteriesLeft+=batteries[i];\\n        }\\n        while(low<=high){\\n            ll mid=low+(high-low)/2;\\n            cout<<mid<<endl;\\n            int j=0;\\n            int i=n;\\n            ll rem=batteriesLeft;\\n            //checking if each battery in n is greater than \\n            // mid value\\n            // or if not made equal to mid value\\n            while(j<n){\\n                if(batteries[j]>=mid){\\n                    j++;\\n                }else{\\n                    ll require=mid-batteries[j];\\n                    \\n                    if(rem>=require){\\n                        rem-=require;\\n                        j++;\\n                    }else{\\n                        break;\\n                    }\\n                }\\n            }\\n        \\n            if(j==n){\\n                low=mid+1;\\n                ans=mid;\\n            }else{\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\ntypedef long long int ll;\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& batteries) {\\n        ll low=1,high=LONG_MAX;\\n        ll ans=0;\\n        sort(batteries.begin(),batteries.end(),greater<int>());\\n        ll batteriesLeft=0;\\n        //excess batteries after n batteries\\n        for(int i=n;i<batteries.size();++i){\\n            batteriesLeft+=batteries[i];\\n        }\\n        while(low<=high){\\n            ll mid=low+(high-low)/2;\\n            cout<<mid<<endl;\\n            int j=0;\\n            int i=n;\\n            ll rem=batteriesLeft;\\n            //checking if each battery in n is greater than \\n            // mid value\\n            // or if not made equal to mid value\\n            while(j<n){\\n                if(batteries[j]>=mid){\\n                    j++;\\n                }else{\\n                    ll require=mid-batteries[j];\\n                    \\n                    if(rem>=require){\\n                        rem-=require;\\n                        j++;\\n                    }else{\\n                        break;\\n                    }\\n                }\\n            }\\n        \\n            if(j==n){\\n                low=mid+1;\\n                ans=mid;\\n            }else{\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3832109,
                "title": "7-line-super-easy-python-solution-with-time-of-o-mlogm-and-space-of-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncouple of obervasions:\\n\\n- at least n non-empty batteries are needed at any time\\n- A battery with capacity ranking within the top n can supply one computer to the end and there is no need to change it.\\n- We can imagine the other batteries with fewer capacity serving as a supply for the top n batteries, so that they can be combined together, as one single supply pool.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. sort batteries reversely.\\n2. keep the batteries with top n capacites\\n3. truncate  and sum up the capacities of the other batteries as a pool of supply.\\n4. The optimal way to use supply is to support batteries with the least capacities. And to determine how many batteries should be supported, we need to iterate through batteries list one by one and find the sweet spot.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(mlogm)\\nm stands for the length of batteries, since we need to sort it.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        if n>len(batteries):\\n            return 0\\n\\n        #sorting\\n        batteries.sort(reverse=True)\\n        \\n        #combining the batteries with least capacities as a supply pool\\n        supply=sum(batteries[n:])\\n\\n        #keep the batteries with top n capacities\\n        batteries=batteries[:n]\\n\\n        #iterate from the end of the list forwardly.\\n        #assume supply only supports all batteries behind current battery\\n        #if current battery lasts longer than batteries behind it (with supply)\\n        #then supply is used optimally.\\n        for i in range(len(batteries)-2,-2,-1):\\n            if i==-1 or batteries[i]>(sum(batteries[i+1:])+supply)//len(batteries[i+1:]):\\n                return (sum(batteries[i+1:])+supply)//len(batteries[i+1:])\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        if n>len(batteries):\\n            return 0\\n\\n        #sorting\\n        batteries.sort(reverse=True)\\n        \\n        #combining the batteries with least capacities as a supply pool\\n        supply=sum(batteries[n:])\\n\\n        #keep the batteries with top n capacities\\n        batteries=batteries[:n]\\n\\n        #iterate from the end of the list forwardly.\\n        #assume supply only supports all batteries behind current battery\\n        #if current battery lasts longer than batteries behind it (with supply)\\n        #then supply is used optimally.\\n        for i in range(len(batteries)-2,-2,-1):\\n            if i==-1 or batteries[i]>(sum(batteries[i+1:])+supply)//len(batteries[i+1:]):\\n                return (sum(batteries[i+1:])+supply)//len(batteries[i+1:])\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1988060,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "this problem sure did drain my batteries ... "
                    },
                    {
                        "username": "sushimatou",
                        "content": "one hour and a half, not even a beginning of an answer T-T"
                    },
                    {
                        "username": "yourick",
                        "content": "### More similar problems:\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/description/)\n[410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\n[668. Kth Smallest Number in Multiplication Table](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/description/)\n[719. Find K-th Smallest Pair Distance](https://leetcode.com/problems/find-k-th-smallest-pair-distance/description/)\n[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/)\n[1283. Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/description/)\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/description/)\n[1552. Magnetic Force Between Two Balls](https://leetcode.com/problems/magnetic-force-between-two-balls/description/)\n[1760. Minimum Limit of Balls in a Bag](https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/description/)\n[1802. Maximum Value at a Given Index in a Bounded Array](https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/description/)\n[1870. Minimum Speed to Arrive on Time](https://leetcode.com/problems/minimum-speed-to-arrive-on-time/description/)\n[1898. Maximum Number of Removable Characters](https://leetcode.com/problems/maximum-number-of-removable-characters/description/)\n[2064. Minimized Maximum of Products Distributed to Any Store](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/description/)\n[2071. Maximum Number of Tasks You Can Assign](https://leetcode.com/problems/maximum-number-of-tasks-you-can-assign/description/)\n[2141. Maximum Running Time of N Computers](https://leetcode.com/problems/maximum-running-time-of-n-computers/)\n[2187. Minimum Time to Complete Trips](https://leetcode.com/problems/minimum-time-to-complete-trips/description/)\n[2226. Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/description/)\n[2517. Maximum Tastiness of Candy Basket](https://leetcode.com/problems/maximum-tastiness-of-candy-basket/description/)\n[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/description/)\n[2560. House Robber IV](https://leetcode.com/problems/house-robber-iv/description/)\n[2594. Minimum Time to Repair Cars](https://leetcode.com/problems/minimum-time-to-repair-cars/description/)\n[2616. Minimize the Maximum Difference of Pairs](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/description/)\n"
                    },
                    {
                        "username": "prototye",
                        "content": "[@bparanj](/bparanj) chat gpt\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Here are 10 distinct problems that use similar underlying concepts:\\n\\n1. [Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts](https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/): This problem also involves sorting and finding maximum possible values after cuts, which is similar to our original problem of distributing charge among computers.\\n\\n2. [Task Scheduler](https://leetcode.com/problems/task-scheduler/): The task scheduling problem also uses a greedy approach to fit tasks into a schedule in a way that minimizes idle time.\\n\\n3. [Boats to Save People](https://leetcode.com/problems/boats-to-save-people/): This problem involves figuring out the minimum number of boats required to save people, a concept akin to determining the maximum running time of computers.\\n\\n4. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/): This problem also involves maximizing a certain parameter (the sum in this case) over a given set of integers.\\n\\n5. [Jump Game II](https://leetcode.com/problems/jump-game-ii/): This problem also involves maximizing a certain parameter (the number of jumps in this case) and uses a greedy algorithm approach.\\n\\n6. [Container With Most Water](https://leetcode.com/problems/container-with-most-water/): The strategy used in this problem, where we try to maximize the area of water the container can hold, is somewhat similar to our original problem where we tried to maximize the runtime.\\n\\n7. [Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/): This problem asks to divide an array into segments to minimize the maximum sum among them, which can be solved using a binary search in the same vein as the original problem.\\n\\n8. [Gas Station](https://leetcode.com/problems/gas-station/): The greedy approach used in this problem to find the starting gas station is similar to the strategy used in the original problem.\\n\\n9. [Queue Reconstruction by Height](https://leetcode.com/problems/queue-reconstruction-by-height/): The approach of sorting and then placing elements based on some condition is similar to the original problem.\\n\\n10. [Largest Number](https://leetcode.com/problems/largest-number/): The problem involves sorting and arranging elements in a certain way to maximize a value, which is a similar strategy as the original problem. \\n"
                    },
                    {
                        "username": "metaphysicalist",
                        "content": "The week of binary search?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "use biggest batteries first. All the batteries left after are your extra hours - just spread it across evenly (for ex, if u have two batteries left 2 and 3 hours it is the same as if u had 5 batteries 1 hour each)"
                    },
                    {
                        "username": "timofeev_evg",
                        "content": "[@charonme](/charonme) nothing to divide here. [100,1] + 2 extra, answer is 3"
                    },
                    {
                        "username": "charonme",
                        "content": "[@c4tdog](/c4tdog) a battery can\\'t be divided, try to apply your algo to n=2, batteries=[100,1,1,1] testcase"
                    },
                    {
                        "username": "Karthik949",
                        "content": "I went with same logic using Heaps "
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@charonme](/charonme) last one could be divided between two"
                    },
                    {
                        "username": "charonme",
                        "content": "this approach already doesn\\'t work with example 1. You\\'d use the two 3h batteries and will be left with one 3h battery for 2 computers"
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@c4tdog](/c4tdog)  okay sir !"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@omkarsk98](/omkarsk98) I used  maxHeap immediately I saw the question but hit TLE pretty fast"
                    },
                    {
                        "username": "hero080",
                        "content": "[@anuron_das](/anuron_das) \\nA much better way:\\n`[10, 10, 3, 5]` and `n = 3` is the same as `[3, 5]` and `n = 1`, we have total power of 8 so we can run 8 minutes.\\nThis also validates our point: `10 > 8` therefore these \"high power\" batteries will never be used up.\\n\\nSee the details:\\nhttps://leetcode.com/problems/maximum-running-time-of-n-computers/solutions/3822290/beat-100-o-m-nlogn-most-intuitive-solution-no-bs-no-heap/"
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@Ultron03](/Ultron03) since 5 in much less than 10, all last 3 hours goes to it, and the answer is 8. in case 10 10 10, u could split 3 among all computers and the answer would be 11"
                    },
                    {
                        "username": "anuron_das",
                        "content": "What you are saying is correct, but is very counterintuitive for me to understand. \n\nWhen we have 2 batteries of `3-hr` and `2-hr` power, we can attach these batteries to at most 2 computers at a time right? But when I am equating this to the scenario where I have 5 batteries of `1-hr` power, then I am claiming that I can attach these 2 batteries to at most 5 computers at a time. Isn't that incorrect?\n\nAlso, if it really is the case then if we start off by using the batteries with least power first, then also this approach should work. But interestingly it does not. \n\nTake the test case `[10,10,3,5]` with `n=3`. If I use the lest powered batteries first then I will attach the `3-hr`, `5-hr` and `10-hr` battery first. Now I have 1 `10-hr` battery left, which is same as having 10 `1-hr` batteries (just play along with me, even though this is a false argument). I will attach 6 `1-hr` batteries to the `1st` computer (one running on the `3-hr` battery), and the remaining 4 `1-hr` batteries to the `2nd` computer (one currently running on a `5-hr` battery).\n\nSo now the `1st` one runs for `9-hrs`, `2nd` one runs for `9-hrs` and the `3rd` one runs for `10-hrs`. So the answer we get is `9-hrs` max. Wrong answer obviously.\n\nI hope you can see my point, and would appreciate if someone corrects me.\n"
                    },
                    {
                        "username": "omkarsk98",
                        "content": "I see a priority queue here. Is it correct?"
                    },
                    {
                        "username": "Ultron03",
                        "content": "How it will correct ans for 10,10,5,3 and n=3"
                    },
                    {
                        "username": "aitachii",
                        "content": "You should try these testcases first:\n\n    3\n    [10,10,5,3]\n\n    4\n    [8, 1, 4, 8]\n\n    2\n    [31,87,85,44,47,25]\n\nHint: The 2nd one can be done in O(n) time, O(1) space."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "add this also \\n```\\n12\\n[11,89,16,32,70,67,35,35,31,24,41,29,6,53,78,83]\\n```"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "wow very clear description\\nnot like yesterday\\n"
                    },
                    {
                        "username": "fli033",
                        "content": "I originally though binary search... But I couldn\\'t figure out how to test if a target time can be met... RIP"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@moraalejandro94](/moraalejandro94) Lets consider an example  n=3 batteries=[10,10,4]   the answer here will be 4 and not the 8 but according to your concept \\n( 10+10+4=24>=3*8)   answer=8"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@moraalejandro94](/moraalejandro94) Thanks! That\\'s a great hint."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "You need to run n computers for \\'mid\\' minutes -> n*mid \"energy units\". For each battery, it can contribute at most \\'mid\\' energy units, so you can check if the sum of what each battery can contribute is more than n*mid. "
                    },
                    {
                        "username": "pramod74",
                        "content": "34/52 testcases passed using this simple logic:\n\nreturn Math.floor(sum of elements in batteries array/n)\n\n:)"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@AssortedFantasy](/AssortedFantasy) Note that the problem can actually be done without Binary search at all like the hint suggest, its even easier of you use what I\\'ve said."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is almost the entirely solution.\\n\\nIts not obvious, but being able to swap batteries around means you can indeed almost make full use out of every battery, so yes simply floor dividing the total energy by n does give you the total time $t$.\\n\\nHowever the trick is that if you do this, some of the batteries has more energy than $t$. So you need to account for this as not usable power."
                    },
                    {
                        "username": "mohit7086",
                        "content": "yeah \\uD83D\\uDE02"
                    },
                    {
                        "username": "0xJaskeerat",
                        "content": "Did the same"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There was no power at home for a half day. I really need batteries!  The example 1 is quite interesting. By a smart  way of interchanging the batteries the maximal running time is  optimized. In most cases the battery is plugged in and until it has no power!"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "how the hell can u solve this in time limit???!!!!!!"
                    },
                    {
                        "username": "EntityPlantt",
                        "content": "hints & editorial: let us introduce ourselves"
                    }
                ]
            },
            {
                "id": 1988006,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "this problem sure did drain my batteries ... "
                    },
                    {
                        "username": "sushimatou",
                        "content": "one hour and a half, not even a beginning of an answer T-T"
                    },
                    {
                        "username": "yourick",
                        "content": "### More similar problems:\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/description/)\n[410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\n[668. Kth Smallest Number in Multiplication Table](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/description/)\n[719. Find K-th Smallest Pair Distance](https://leetcode.com/problems/find-k-th-smallest-pair-distance/description/)\n[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/)\n[1283. Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/description/)\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/description/)\n[1552. Magnetic Force Between Two Balls](https://leetcode.com/problems/magnetic-force-between-two-balls/description/)\n[1760. Minimum Limit of Balls in a Bag](https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/description/)\n[1802. Maximum Value at a Given Index in a Bounded Array](https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/description/)\n[1870. Minimum Speed to Arrive on Time](https://leetcode.com/problems/minimum-speed-to-arrive-on-time/description/)\n[1898. Maximum Number of Removable Characters](https://leetcode.com/problems/maximum-number-of-removable-characters/description/)\n[2064. Minimized Maximum of Products Distributed to Any Store](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/description/)\n[2071. Maximum Number of Tasks You Can Assign](https://leetcode.com/problems/maximum-number-of-tasks-you-can-assign/description/)\n[2141. Maximum Running Time of N Computers](https://leetcode.com/problems/maximum-running-time-of-n-computers/)\n[2187. Minimum Time to Complete Trips](https://leetcode.com/problems/minimum-time-to-complete-trips/description/)\n[2226. Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/description/)\n[2517. Maximum Tastiness of Candy Basket](https://leetcode.com/problems/maximum-tastiness-of-candy-basket/description/)\n[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/description/)\n[2560. House Robber IV](https://leetcode.com/problems/house-robber-iv/description/)\n[2594. Minimum Time to Repair Cars](https://leetcode.com/problems/minimum-time-to-repair-cars/description/)\n[2616. Minimize the Maximum Difference of Pairs](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/description/)\n"
                    },
                    {
                        "username": "prototye",
                        "content": "[@bparanj](/bparanj) chat gpt\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Here are 10 distinct problems that use similar underlying concepts:\\n\\n1. [Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts](https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/): This problem also involves sorting and finding maximum possible values after cuts, which is similar to our original problem of distributing charge among computers.\\n\\n2. [Task Scheduler](https://leetcode.com/problems/task-scheduler/): The task scheduling problem also uses a greedy approach to fit tasks into a schedule in a way that minimizes idle time.\\n\\n3. [Boats to Save People](https://leetcode.com/problems/boats-to-save-people/): This problem involves figuring out the minimum number of boats required to save people, a concept akin to determining the maximum running time of computers.\\n\\n4. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/): This problem also involves maximizing a certain parameter (the sum in this case) over a given set of integers.\\n\\n5. [Jump Game II](https://leetcode.com/problems/jump-game-ii/): This problem also involves maximizing a certain parameter (the number of jumps in this case) and uses a greedy algorithm approach.\\n\\n6. [Container With Most Water](https://leetcode.com/problems/container-with-most-water/): The strategy used in this problem, where we try to maximize the area of water the container can hold, is somewhat similar to our original problem where we tried to maximize the runtime.\\n\\n7. [Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/): This problem asks to divide an array into segments to minimize the maximum sum among them, which can be solved using a binary search in the same vein as the original problem.\\n\\n8. [Gas Station](https://leetcode.com/problems/gas-station/): The greedy approach used in this problem to find the starting gas station is similar to the strategy used in the original problem.\\n\\n9. [Queue Reconstruction by Height](https://leetcode.com/problems/queue-reconstruction-by-height/): The approach of sorting and then placing elements based on some condition is similar to the original problem.\\n\\n10. [Largest Number](https://leetcode.com/problems/largest-number/): The problem involves sorting and arranging elements in a certain way to maximize a value, which is a similar strategy as the original problem. \\n"
                    },
                    {
                        "username": "metaphysicalist",
                        "content": "The week of binary search?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "use biggest batteries first. All the batteries left after are your extra hours - just spread it across evenly (for ex, if u have two batteries left 2 and 3 hours it is the same as if u had 5 batteries 1 hour each)"
                    },
                    {
                        "username": "timofeev_evg",
                        "content": "[@charonme](/charonme) nothing to divide here. [100,1] + 2 extra, answer is 3"
                    },
                    {
                        "username": "charonme",
                        "content": "[@c4tdog](/c4tdog) a battery can\\'t be divided, try to apply your algo to n=2, batteries=[100,1,1,1] testcase"
                    },
                    {
                        "username": "Karthik949",
                        "content": "I went with same logic using Heaps "
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@charonme](/charonme) last one could be divided between two"
                    },
                    {
                        "username": "charonme",
                        "content": "this approach already doesn\\'t work with example 1. You\\'d use the two 3h batteries and will be left with one 3h battery for 2 computers"
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@c4tdog](/c4tdog)  okay sir !"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@omkarsk98](/omkarsk98) I used  maxHeap immediately I saw the question but hit TLE pretty fast"
                    },
                    {
                        "username": "hero080",
                        "content": "[@anuron_das](/anuron_das) \\nA much better way:\\n`[10, 10, 3, 5]` and `n = 3` is the same as `[3, 5]` and `n = 1`, we have total power of 8 so we can run 8 minutes.\\nThis also validates our point: `10 > 8` therefore these \"high power\" batteries will never be used up.\\n\\nSee the details:\\nhttps://leetcode.com/problems/maximum-running-time-of-n-computers/solutions/3822290/beat-100-o-m-nlogn-most-intuitive-solution-no-bs-no-heap/"
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@Ultron03](/Ultron03) since 5 in much less than 10, all last 3 hours goes to it, and the answer is 8. in case 10 10 10, u could split 3 among all computers and the answer would be 11"
                    },
                    {
                        "username": "anuron_das",
                        "content": "What you are saying is correct, but is very counterintuitive for me to understand. \n\nWhen we have 2 batteries of `3-hr` and `2-hr` power, we can attach these batteries to at most 2 computers at a time right? But when I am equating this to the scenario where I have 5 batteries of `1-hr` power, then I am claiming that I can attach these 2 batteries to at most 5 computers at a time. Isn't that incorrect?\n\nAlso, if it really is the case then if we start off by using the batteries with least power first, then also this approach should work. But interestingly it does not. \n\nTake the test case `[10,10,3,5]` with `n=3`. If I use the lest powered batteries first then I will attach the `3-hr`, `5-hr` and `10-hr` battery first. Now I have 1 `10-hr` battery left, which is same as having 10 `1-hr` batteries (just play along with me, even though this is a false argument). I will attach 6 `1-hr` batteries to the `1st` computer (one running on the `3-hr` battery), and the remaining 4 `1-hr` batteries to the `2nd` computer (one currently running on a `5-hr` battery).\n\nSo now the `1st` one runs for `9-hrs`, `2nd` one runs for `9-hrs` and the `3rd` one runs for `10-hrs`. So the answer we get is `9-hrs` max. Wrong answer obviously.\n\nI hope you can see my point, and would appreciate if someone corrects me.\n"
                    },
                    {
                        "username": "omkarsk98",
                        "content": "I see a priority queue here. Is it correct?"
                    },
                    {
                        "username": "Ultron03",
                        "content": "How it will correct ans for 10,10,5,3 and n=3"
                    },
                    {
                        "username": "aitachii",
                        "content": "You should try these testcases first:\n\n    3\n    [10,10,5,3]\n\n    4\n    [8, 1, 4, 8]\n\n    2\n    [31,87,85,44,47,25]\n\nHint: The 2nd one can be done in O(n) time, O(1) space."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "add this also \\n```\\n12\\n[11,89,16,32,70,67,35,35,31,24,41,29,6,53,78,83]\\n```"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "wow very clear description\\nnot like yesterday\\n"
                    },
                    {
                        "username": "fli033",
                        "content": "I originally though binary search... But I couldn\\'t figure out how to test if a target time can be met... RIP"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@moraalejandro94](/moraalejandro94) Lets consider an example  n=3 batteries=[10,10,4]   the answer here will be 4 and not the 8 but according to your concept \\n( 10+10+4=24>=3*8)   answer=8"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@moraalejandro94](/moraalejandro94) Thanks! That\\'s a great hint."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "You need to run n computers for \\'mid\\' minutes -> n*mid \"energy units\". For each battery, it can contribute at most \\'mid\\' energy units, so you can check if the sum of what each battery can contribute is more than n*mid. "
                    },
                    {
                        "username": "pramod74",
                        "content": "34/52 testcases passed using this simple logic:\n\nreturn Math.floor(sum of elements in batteries array/n)\n\n:)"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@AssortedFantasy](/AssortedFantasy) Note that the problem can actually be done without Binary search at all like the hint suggest, its even easier of you use what I\\'ve said."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is almost the entirely solution.\\n\\nIts not obvious, but being able to swap batteries around means you can indeed almost make full use out of every battery, so yes simply floor dividing the total energy by n does give you the total time $t$.\\n\\nHowever the trick is that if you do this, some of the batteries has more energy than $t$. So you need to account for this as not usable power."
                    },
                    {
                        "username": "mohit7086",
                        "content": "yeah \\uD83D\\uDE02"
                    },
                    {
                        "username": "0xJaskeerat",
                        "content": "Did the same"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There was no power at home for a half day. I really need batteries!  The example 1 is quite interesting. By a smart  way of interchanging the batteries the maximal running time is  optimized. In most cases the battery is plugged in and until it has no power!"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "how the hell can u solve this in time limit???!!!!!!"
                    },
                    {
                        "username": "EntityPlantt",
                        "content": "hints & editorial: let us introduce ourselves"
                    }
                ]
            },
            {
                "id": 1988042,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "this problem sure did drain my batteries ... "
                    },
                    {
                        "username": "sushimatou",
                        "content": "one hour and a half, not even a beginning of an answer T-T"
                    },
                    {
                        "username": "yourick",
                        "content": "### More similar problems:\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/description/)\n[410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\n[668. Kth Smallest Number in Multiplication Table](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/description/)\n[719. Find K-th Smallest Pair Distance](https://leetcode.com/problems/find-k-th-smallest-pair-distance/description/)\n[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/)\n[1283. Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/description/)\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/description/)\n[1552. Magnetic Force Between Two Balls](https://leetcode.com/problems/magnetic-force-between-two-balls/description/)\n[1760. Minimum Limit of Balls in a Bag](https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/description/)\n[1802. Maximum Value at a Given Index in a Bounded Array](https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/description/)\n[1870. Minimum Speed to Arrive on Time](https://leetcode.com/problems/minimum-speed-to-arrive-on-time/description/)\n[1898. Maximum Number of Removable Characters](https://leetcode.com/problems/maximum-number-of-removable-characters/description/)\n[2064. Minimized Maximum of Products Distributed to Any Store](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/description/)\n[2071. Maximum Number of Tasks You Can Assign](https://leetcode.com/problems/maximum-number-of-tasks-you-can-assign/description/)\n[2141. Maximum Running Time of N Computers](https://leetcode.com/problems/maximum-running-time-of-n-computers/)\n[2187. Minimum Time to Complete Trips](https://leetcode.com/problems/minimum-time-to-complete-trips/description/)\n[2226. Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/description/)\n[2517. Maximum Tastiness of Candy Basket](https://leetcode.com/problems/maximum-tastiness-of-candy-basket/description/)\n[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/description/)\n[2560. House Robber IV](https://leetcode.com/problems/house-robber-iv/description/)\n[2594. Minimum Time to Repair Cars](https://leetcode.com/problems/minimum-time-to-repair-cars/description/)\n[2616. Minimize the Maximum Difference of Pairs](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/description/)\n"
                    },
                    {
                        "username": "prototye",
                        "content": "[@bparanj](/bparanj) chat gpt\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Here are 10 distinct problems that use similar underlying concepts:\\n\\n1. [Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts](https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/): This problem also involves sorting and finding maximum possible values after cuts, which is similar to our original problem of distributing charge among computers.\\n\\n2. [Task Scheduler](https://leetcode.com/problems/task-scheduler/): The task scheduling problem also uses a greedy approach to fit tasks into a schedule in a way that minimizes idle time.\\n\\n3. [Boats to Save People](https://leetcode.com/problems/boats-to-save-people/): This problem involves figuring out the minimum number of boats required to save people, a concept akin to determining the maximum running time of computers.\\n\\n4. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/): This problem also involves maximizing a certain parameter (the sum in this case) over a given set of integers.\\n\\n5. [Jump Game II](https://leetcode.com/problems/jump-game-ii/): This problem also involves maximizing a certain parameter (the number of jumps in this case) and uses a greedy algorithm approach.\\n\\n6. [Container With Most Water](https://leetcode.com/problems/container-with-most-water/): The strategy used in this problem, where we try to maximize the area of water the container can hold, is somewhat similar to our original problem where we tried to maximize the runtime.\\n\\n7. [Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/): This problem asks to divide an array into segments to minimize the maximum sum among them, which can be solved using a binary search in the same vein as the original problem.\\n\\n8. [Gas Station](https://leetcode.com/problems/gas-station/): The greedy approach used in this problem to find the starting gas station is similar to the strategy used in the original problem.\\n\\n9. [Queue Reconstruction by Height](https://leetcode.com/problems/queue-reconstruction-by-height/): The approach of sorting and then placing elements based on some condition is similar to the original problem.\\n\\n10. [Largest Number](https://leetcode.com/problems/largest-number/): The problem involves sorting and arranging elements in a certain way to maximize a value, which is a similar strategy as the original problem. \\n"
                    },
                    {
                        "username": "metaphysicalist",
                        "content": "The week of binary search?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "use biggest batteries first. All the batteries left after are your extra hours - just spread it across evenly (for ex, if u have two batteries left 2 and 3 hours it is the same as if u had 5 batteries 1 hour each)"
                    },
                    {
                        "username": "timofeev_evg",
                        "content": "[@charonme](/charonme) nothing to divide here. [100,1] + 2 extra, answer is 3"
                    },
                    {
                        "username": "charonme",
                        "content": "[@c4tdog](/c4tdog) a battery can\\'t be divided, try to apply your algo to n=2, batteries=[100,1,1,1] testcase"
                    },
                    {
                        "username": "Karthik949",
                        "content": "I went with same logic using Heaps "
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@charonme](/charonme) last one could be divided between two"
                    },
                    {
                        "username": "charonme",
                        "content": "this approach already doesn\\'t work with example 1. You\\'d use the two 3h batteries and will be left with one 3h battery for 2 computers"
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@c4tdog](/c4tdog)  okay sir !"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@omkarsk98](/omkarsk98) I used  maxHeap immediately I saw the question but hit TLE pretty fast"
                    },
                    {
                        "username": "hero080",
                        "content": "[@anuron_das](/anuron_das) \\nA much better way:\\n`[10, 10, 3, 5]` and `n = 3` is the same as `[3, 5]` and `n = 1`, we have total power of 8 so we can run 8 minutes.\\nThis also validates our point: `10 > 8` therefore these \"high power\" batteries will never be used up.\\n\\nSee the details:\\nhttps://leetcode.com/problems/maximum-running-time-of-n-computers/solutions/3822290/beat-100-o-m-nlogn-most-intuitive-solution-no-bs-no-heap/"
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@Ultron03](/Ultron03) since 5 in much less than 10, all last 3 hours goes to it, and the answer is 8. in case 10 10 10, u could split 3 among all computers and the answer would be 11"
                    },
                    {
                        "username": "anuron_das",
                        "content": "What you are saying is correct, but is very counterintuitive for me to understand. \n\nWhen we have 2 batteries of `3-hr` and `2-hr` power, we can attach these batteries to at most 2 computers at a time right? But when I am equating this to the scenario where I have 5 batteries of `1-hr` power, then I am claiming that I can attach these 2 batteries to at most 5 computers at a time. Isn't that incorrect?\n\nAlso, if it really is the case then if we start off by using the batteries with least power first, then also this approach should work. But interestingly it does not. \n\nTake the test case `[10,10,3,5]` with `n=3`. If I use the lest powered batteries first then I will attach the `3-hr`, `5-hr` and `10-hr` battery first. Now I have 1 `10-hr` battery left, which is same as having 10 `1-hr` batteries (just play along with me, even though this is a false argument). I will attach 6 `1-hr` batteries to the `1st` computer (one running on the `3-hr` battery), and the remaining 4 `1-hr` batteries to the `2nd` computer (one currently running on a `5-hr` battery).\n\nSo now the `1st` one runs for `9-hrs`, `2nd` one runs for `9-hrs` and the `3rd` one runs for `10-hrs`. So the answer we get is `9-hrs` max. Wrong answer obviously.\n\nI hope you can see my point, and would appreciate if someone corrects me.\n"
                    },
                    {
                        "username": "omkarsk98",
                        "content": "I see a priority queue here. Is it correct?"
                    },
                    {
                        "username": "Ultron03",
                        "content": "How it will correct ans for 10,10,5,3 and n=3"
                    },
                    {
                        "username": "aitachii",
                        "content": "You should try these testcases first:\n\n    3\n    [10,10,5,3]\n\n    4\n    [8, 1, 4, 8]\n\n    2\n    [31,87,85,44,47,25]\n\nHint: The 2nd one can be done in O(n) time, O(1) space."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "add this also \\n```\\n12\\n[11,89,16,32,70,67,35,35,31,24,41,29,6,53,78,83]\\n```"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "wow very clear description\\nnot like yesterday\\n"
                    },
                    {
                        "username": "fli033",
                        "content": "I originally though binary search... But I couldn\\'t figure out how to test if a target time can be met... RIP"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@moraalejandro94](/moraalejandro94) Lets consider an example  n=3 batteries=[10,10,4]   the answer here will be 4 and not the 8 but according to your concept \\n( 10+10+4=24>=3*8)   answer=8"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@moraalejandro94](/moraalejandro94) Thanks! That\\'s a great hint."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "You need to run n computers for \\'mid\\' minutes -> n*mid \"energy units\". For each battery, it can contribute at most \\'mid\\' energy units, so you can check if the sum of what each battery can contribute is more than n*mid. "
                    },
                    {
                        "username": "pramod74",
                        "content": "34/52 testcases passed using this simple logic:\n\nreturn Math.floor(sum of elements in batteries array/n)\n\n:)"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@AssortedFantasy](/AssortedFantasy) Note that the problem can actually be done without Binary search at all like the hint suggest, its even easier of you use what I\\'ve said."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is almost the entirely solution.\\n\\nIts not obvious, but being able to swap batteries around means you can indeed almost make full use out of every battery, so yes simply floor dividing the total energy by n does give you the total time $t$.\\n\\nHowever the trick is that if you do this, some of the batteries has more energy than $t$. So you need to account for this as not usable power."
                    },
                    {
                        "username": "mohit7086",
                        "content": "yeah \\uD83D\\uDE02"
                    },
                    {
                        "username": "0xJaskeerat",
                        "content": "Did the same"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There was no power at home for a half day. I really need batteries!  The example 1 is quite interesting. By a smart  way of interchanging the batteries the maximal running time is  optimized. In most cases the battery is plugged in and until it has no power!"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "how the hell can u solve this in time limit???!!!!!!"
                    },
                    {
                        "username": "EntityPlantt",
                        "content": "hints & editorial: let us introduce ourselves"
                    }
                ]
            },
            {
                "id": 1988043,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "this problem sure did drain my batteries ... "
                    },
                    {
                        "username": "sushimatou",
                        "content": "one hour and a half, not even a beginning of an answer T-T"
                    },
                    {
                        "username": "yourick",
                        "content": "### More similar problems:\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/description/)\n[410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\n[668. Kth Smallest Number in Multiplication Table](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/description/)\n[719. Find K-th Smallest Pair Distance](https://leetcode.com/problems/find-k-th-smallest-pair-distance/description/)\n[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/)\n[1283. Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/description/)\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/description/)\n[1552. Magnetic Force Between Two Balls](https://leetcode.com/problems/magnetic-force-between-two-balls/description/)\n[1760. Minimum Limit of Balls in a Bag](https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/description/)\n[1802. Maximum Value at a Given Index in a Bounded Array](https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/description/)\n[1870. Minimum Speed to Arrive on Time](https://leetcode.com/problems/minimum-speed-to-arrive-on-time/description/)\n[1898. Maximum Number of Removable Characters](https://leetcode.com/problems/maximum-number-of-removable-characters/description/)\n[2064. Minimized Maximum of Products Distributed to Any Store](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/description/)\n[2071. Maximum Number of Tasks You Can Assign](https://leetcode.com/problems/maximum-number-of-tasks-you-can-assign/description/)\n[2141. Maximum Running Time of N Computers](https://leetcode.com/problems/maximum-running-time-of-n-computers/)\n[2187. Minimum Time to Complete Trips](https://leetcode.com/problems/minimum-time-to-complete-trips/description/)\n[2226. Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/description/)\n[2517. Maximum Tastiness of Candy Basket](https://leetcode.com/problems/maximum-tastiness-of-candy-basket/description/)\n[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/description/)\n[2560. House Robber IV](https://leetcode.com/problems/house-robber-iv/description/)\n[2594. Minimum Time to Repair Cars](https://leetcode.com/problems/minimum-time-to-repair-cars/description/)\n[2616. Minimize the Maximum Difference of Pairs](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/description/)\n"
                    },
                    {
                        "username": "prototye",
                        "content": "[@bparanj](/bparanj) chat gpt\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Here are 10 distinct problems that use similar underlying concepts:\\n\\n1. [Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts](https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/): This problem also involves sorting and finding maximum possible values after cuts, which is similar to our original problem of distributing charge among computers.\\n\\n2. [Task Scheduler](https://leetcode.com/problems/task-scheduler/): The task scheduling problem also uses a greedy approach to fit tasks into a schedule in a way that minimizes idle time.\\n\\n3. [Boats to Save People](https://leetcode.com/problems/boats-to-save-people/): This problem involves figuring out the minimum number of boats required to save people, a concept akin to determining the maximum running time of computers.\\n\\n4. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/): This problem also involves maximizing a certain parameter (the sum in this case) over a given set of integers.\\n\\n5. [Jump Game II](https://leetcode.com/problems/jump-game-ii/): This problem also involves maximizing a certain parameter (the number of jumps in this case) and uses a greedy algorithm approach.\\n\\n6. [Container With Most Water](https://leetcode.com/problems/container-with-most-water/): The strategy used in this problem, where we try to maximize the area of water the container can hold, is somewhat similar to our original problem where we tried to maximize the runtime.\\n\\n7. [Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/): This problem asks to divide an array into segments to minimize the maximum sum among them, which can be solved using a binary search in the same vein as the original problem.\\n\\n8. [Gas Station](https://leetcode.com/problems/gas-station/): The greedy approach used in this problem to find the starting gas station is similar to the strategy used in the original problem.\\n\\n9. [Queue Reconstruction by Height](https://leetcode.com/problems/queue-reconstruction-by-height/): The approach of sorting and then placing elements based on some condition is similar to the original problem.\\n\\n10. [Largest Number](https://leetcode.com/problems/largest-number/): The problem involves sorting and arranging elements in a certain way to maximize a value, which is a similar strategy as the original problem. \\n"
                    },
                    {
                        "username": "metaphysicalist",
                        "content": "The week of binary search?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "use biggest batteries first. All the batteries left after are your extra hours - just spread it across evenly (for ex, if u have two batteries left 2 and 3 hours it is the same as if u had 5 batteries 1 hour each)"
                    },
                    {
                        "username": "timofeev_evg",
                        "content": "[@charonme](/charonme) nothing to divide here. [100,1] + 2 extra, answer is 3"
                    },
                    {
                        "username": "charonme",
                        "content": "[@c4tdog](/c4tdog) a battery can\\'t be divided, try to apply your algo to n=2, batteries=[100,1,1,1] testcase"
                    },
                    {
                        "username": "Karthik949",
                        "content": "I went with same logic using Heaps "
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@charonme](/charonme) last one could be divided between two"
                    },
                    {
                        "username": "charonme",
                        "content": "this approach already doesn\\'t work with example 1. You\\'d use the two 3h batteries and will be left with one 3h battery for 2 computers"
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@c4tdog](/c4tdog)  okay sir !"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@omkarsk98](/omkarsk98) I used  maxHeap immediately I saw the question but hit TLE pretty fast"
                    },
                    {
                        "username": "hero080",
                        "content": "[@anuron_das](/anuron_das) \\nA much better way:\\n`[10, 10, 3, 5]` and `n = 3` is the same as `[3, 5]` and `n = 1`, we have total power of 8 so we can run 8 minutes.\\nThis also validates our point: `10 > 8` therefore these \"high power\" batteries will never be used up.\\n\\nSee the details:\\nhttps://leetcode.com/problems/maximum-running-time-of-n-computers/solutions/3822290/beat-100-o-m-nlogn-most-intuitive-solution-no-bs-no-heap/"
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@Ultron03](/Ultron03) since 5 in much less than 10, all last 3 hours goes to it, and the answer is 8. in case 10 10 10, u could split 3 among all computers and the answer would be 11"
                    },
                    {
                        "username": "anuron_das",
                        "content": "What you are saying is correct, but is very counterintuitive for me to understand. \n\nWhen we have 2 batteries of `3-hr` and `2-hr` power, we can attach these batteries to at most 2 computers at a time right? But when I am equating this to the scenario where I have 5 batteries of `1-hr` power, then I am claiming that I can attach these 2 batteries to at most 5 computers at a time. Isn't that incorrect?\n\nAlso, if it really is the case then if we start off by using the batteries with least power first, then also this approach should work. But interestingly it does not. \n\nTake the test case `[10,10,3,5]` with `n=3`. If I use the lest powered batteries first then I will attach the `3-hr`, `5-hr` and `10-hr` battery first. Now I have 1 `10-hr` battery left, which is same as having 10 `1-hr` batteries (just play along with me, even though this is a false argument). I will attach 6 `1-hr` batteries to the `1st` computer (one running on the `3-hr` battery), and the remaining 4 `1-hr` batteries to the `2nd` computer (one currently running on a `5-hr` battery).\n\nSo now the `1st` one runs for `9-hrs`, `2nd` one runs for `9-hrs` and the `3rd` one runs for `10-hrs`. So the answer we get is `9-hrs` max. Wrong answer obviously.\n\nI hope you can see my point, and would appreciate if someone corrects me.\n"
                    },
                    {
                        "username": "omkarsk98",
                        "content": "I see a priority queue here. Is it correct?"
                    },
                    {
                        "username": "Ultron03",
                        "content": "How it will correct ans for 10,10,5,3 and n=3"
                    },
                    {
                        "username": "aitachii",
                        "content": "You should try these testcases first:\n\n    3\n    [10,10,5,3]\n\n    4\n    [8, 1, 4, 8]\n\n    2\n    [31,87,85,44,47,25]\n\nHint: The 2nd one can be done in O(n) time, O(1) space."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "add this also \\n```\\n12\\n[11,89,16,32,70,67,35,35,31,24,41,29,6,53,78,83]\\n```"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "wow very clear description\\nnot like yesterday\\n"
                    },
                    {
                        "username": "fli033",
                        "content": "I originally though binary search... But I couldn\\'t figure out how to test if a target time can be met... RIP"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@moraalejandro94](/moraalejandro94) Lets consider an example  n=3 batteries=[10,10,4]   the answer here will be 4 and not the 8 but according to your concept \\n( 10+10+4=24>=3*8)   answer=8"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@moraalejandro94](/moraalejandro94) Thanks! That\\'s a great hint."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "You need to run n computers for \\'mid\\' minutes -> n*mid \"energy units\". For each battery, it can contribute at most \\'mid\\' energy units, so you can check if the sum of what each battery can contribute is more than n*mid. "
                    },
                    {
                        "username": "pramod74",
                        "content": "34/52 testcases passed using this simple logic:\n\nreturn Math.floor(sum of elements in batteries array/n)\n\n:)"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@AssortedFantasy](/AssortedFantasy) Note that the problem can actually be done without Binary search at all like the hint suggest, its even easier of you use what I\\'ve said."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is almost the entirely solution.\\n\\nIts not obvious, but being able to swap batteries around means you can indeed almost make full use out of every battery, so yes simply floor dividing the total energy by n does give you the total time $t$.\\n\\nHowever the trick is that if you do this, some of the batteries has more energy than $t$. So you need to account for this as not usable power."
                    },
                    {
                        "username": "mohit7086",
                        "content": "yeah \\uD83D\\uDE02"
                    },
                    {
                        "username": "0xJaskeerat",
                        "content": "Did the same"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There was no power at home for a half day. I really need batteries!  The example 1 is quite interesting. By a smart  way of interchanging the batteries the maximal running time is  optimized. In most cases the battery is plugged in and until it has no power!"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "how the hell can u solve this in time limit???!!!!!!"
                    },
                    {
                        "username": "EntityPlantt",
                        "content": "hints & editorial: let us introduce ourselves"
                    }
                ]
            },
            {
                "id": 1988066,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "this problem sure did drain my batteries ... "
                    },
                    {
                        "username": "sushimatou",
                        "content": "one hour and a half, not even a beginning of an answer T-T"
                    },
                    {
                        "username": "yourick",
                        "content": "### More similar problems:\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/description/)\n[410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\n[668. Kth Smallest Number in Multiplication Table](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/description/)\n[719. Find K-th Smallest Pair Distance](https://leetcode.com/problems/find-k-th-smallest-pair-distance/description/)\n[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/)\n[1283. Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/description/)\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/description/)\n[1552. Magnetic Force Between Two Balls](https://leetcode.com/problems/magnetic-force-between-two-balls/description/)\n[1760. Minimum Limit of Balls in a Bag](https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/description/)\n[1802. Maximum Value at a Given Index in a Bounded Array](https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/description/)\n[1870. Minimum Speed to Arrive on Time](https://leetcode.com/problems/minimum-speed-to-arrive-on-time/description/)\n[1898. Maximum Number of Removable Characters](https://leetcode.com/problems/maximum-number-of-removable-characters/description/)\n[2064. Minimized Maximum of Products Distributed to Any Store](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/description/)\n[2071. Maximum Number of Tasks You Can Assign](https://leetcode.com/problems/maximum-number-of-tasks-you-can-assign/description/)\n[2141. Maximum Running Time of N Computers](https://leetcode.com/problems/maximum-running-time-of-n-computers/)\n[2187. Minimum Time to Complete Trips](https://leetcode.com/problems/minimum-time-to-complete-trips/description/)\n[2226. Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/description/)\n[2517. Maximum Tastiness of Candy Basket](https://leetcode.com/problems/maximum-tastiness-of-candy-basket/description/)\n[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/description/)\n[2560. House Robber IV](https://leetcode.com/problems/house-robber-iv/description/)\n[2594. Minimum Time to Repair Cars](https://leetcode.com/problems/minimum-time-to-repair-cars/description/)\n[2616. Minimize the Maximum Difference of Pairs](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/description/)\n"
                    },
                    {
                        "username": "prototye",
                        "content": "[@bparanj](/bparanj) chat gpt\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Here are 10 distinct problems that use similar underlying concepts:\\n\\n1. [Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts](https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/): This problem also involves sorting and finding maximum possible values after cuts, which is similar to our original problem of distributing charge among computers.\\n\\n2. [Task Scheduler](https://leetcode.com/problems/task-scheduler/): The task scheduling problem also uses a greedy approach to fit tasks into a schedule in a way that minimizes idle time.\\n\\n3. [Boats to Save People](https://leetcode.com/problems/boats-to-save-people/): This problem involves figuring out the minimum number of boats required to save people, a concept akin to determining the maximum running time of computers.\\n\\n4. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/): This problem also involves maximizing a certain parameter (the sum in this case) over a given set of integers.\\n\\n5. [Jump Game II](https://leetcode.com/problems/jump-game-ii/): This problem also involves maximizing a certain parameter (the number of jumps in this case) and uses a greedy algorithm approach.\\n\\n6. [Container With Most Water](https://leetcode.com/problems/container-with-most-water/): The strategy used in this problem, where we try to maximize the area of water the container can hold, is somewhat similar to our original problem where we tried to maximize the runtime.\\n\\n7. [Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/): This problem asks to divide an array into segments to minimize the maximum sum among them, which can be solved using a binary search in the same vein as the original problem.\\n\\n8. [Gas Station](https://leetcode.com/problems/gas-station/): The greedy approach used in this problem to find the starting gas station is similar to the strategy used in the original problem.\\n\\n9. [Queue Reconstruction by Height](https://leetcode.com/problems/queue-reconstruction-by-height/): The approach of sorting and then placing elements based on some condition is similar to the original problem.\\n\\n10. [Largest Number](https://leetcode.com/problems/largest-number/): The problem involves sorting and arranging elements in a certain way to maximize a value, which is a similar strategy as the original problem. \\n"
                    },
                    {
                        "username": "metaphysicalist",
                        "content": "The week of binary search?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "use biggest batteries first. All the batteries left after are your extra hours - just spread it across evenly (for ex, if u have two batteries left 2 and 3 hours it is the same as if u had 5 batteries 1 hour each)"
                    },
                    {
                        "username": "timofeev_evg",
                        "content": "[@charonme](/charonme) nothing to divide here. [100,1] + 2 extra, answer is 3"
                    },
                    {
                        "username": "charonme",
                        "content": "[@c4tdog](/c4tdog) a battery can\\'t be divided, try to apply your algo to n=2, batteries=[100,1,1,1] testcase"
                    },
                    {
                        "username": "Karthik949",
                        "content": "I went with same logic using Heaps "
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@charonme](/charonme) last one could be divided between two"
                    },
                    {
                        "username": "charonme",
                        "content": "this approach already doesn\\'t work with example 1. You\\'d use the two 3h batteries and will be left with one 3h battery for 2 computers"
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@c4tdog](/c4tdog)  okay sir !"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@omkarsk98](/omkarsk98) I used  maxHeap immediately I saw the question but hit TLE pretty fast"
                    },
                    {
                        "username": "hero080",
                        "content": "[@anuron_das](/anuron_das) \\nA much better way:\\n`[10, 10, 3, 5]` and `n = 3` is the same as `[3, 5]` and `n = 1`, we have total power of 8 so we can run 8 minutes.\\nThis also validates our point: `10 > 8` therefore these \"high power\" batteries will never be used up.\\n\\nSee the details:\\nhttps://leetcode.com/problems/maximum-running-time-of-n-computers/solutions/3822290/beat-100-o-m-nlogn-most-intuitive-solution-no-bs-no-heap/"
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@Ultron03](/Ultron03) since 5 in much less than 10, all last 3 hours goes to it, and the answer is 8. in case 10 10 10, u could split 3 among all computers and the answer would be 11"
                    },
                    {
                        "username": "anuron_das",
                        "content": "What you are saying is correct, but is very counterintuitive for me to understand. \n\nWhen we have 2 batteries of `3-hr` and `2-hr` power, we can attach these batteries to at most 2 computers at a time right? But when I am equating this to the scenario where I have 5 batteries of `1-hr` power, then I am claiming that I can attach these 2 batteries to at most 5 computers at a time. Isn't that incorrect?\n\nAlso, if it really is the case then if we start off by using the batteries with least power first, then also this approach should work. But interestingly it does not. \n\nTake the test case `[10,10,3,5]` with `n=3`. If I use the lest powered batteries first then I will attach the `3-hr`, `5-hr` and `10-hr` battery first. Now I have 1 `10-hr` battery left, which is same as having 10 `1-hr` batteries (just play along with me, even though this is a false argument). I will attach 6 `1-hr` batteries to the `1st` computer (one running on the `3-hr` battery), and the remaining 4 `1-hr` batteries to the `2nd` computer (one currently running on a `5-hr` battery).\n\nSo now the `1st` one runs for `9-hrs`, `2nd` one runs for `9-hrs` and the `3rd` one runs for `10-hrs`. So the answer we get is `9-hrs` max. Wrong answer obviously.\n\nI hope you can see my point, and would appreciate if someone corrects me.\n"
                    },
                    {
                        "username": "omkarsk98",
                        "content": "I see a priority queue here. Is it correct?"
                    },
                    {
                        "username": "Ultron03",
                        "content": "How it will correct ans for 10,10,5,3 and n=3"
                    },
                    {
                        "username": "aitachii",
                        "content": "You should try these testcases first:\n\n    3\n    [10,10,5,3]\n\n    4\n    [8, 1, 4, 8]\n\n    2\n    [31,87,85,44,47,25]\n\nHint: The 2nd one can be done in O(n) time, O(1) space."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "add this also \\n```\\n12\\n[11,89,16,32,70,67,35,35,31,24,41,29,6,53,78,83]\\n```"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "wow very clear description\\nnot like yesterday\\n"
                    },
                    {
                        "username": "fli033",
                        "content": "I originally though binary search... But I couldn\\'t figure out how to test if a target time can be met... RIP"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@moraalejandro94](/moraalejandro94) Lets consider an example  n=3 batteries=[10,10,4]   the answer here will be 4 and not the 8 but according to your concept \\n( 10+10+4=24>=3*8)   answer=8"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@moraalejandro94](/moraalejandro94) Thanks! That\\'s a great hint."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "You need to run n computers for \\'mid\\' minutes -> n*mid \"energy units\". For each battery, it can contribute at most \\'mid\\' energy units, so you can check if the sum of what each battery can contribute is more than n*mid. "
                    },
                    {
                        "username": "pramod74",
                        "content": "34/52 testcases passed using this simple logic:\n\nreturn Math.floor(sum of elements in batteries array/n)\n\n:)"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@AssortedFantasy](/AssortedFantasy) Note that the problem can actually be done without Binary search at all like the hint suggest, its even easier of you use what I\\'ve said."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is almost the entirely solution.\\n\\nIts not obvious, but being able to swap batteries around means you can indeed almost make full use out of every battery, so yes simply floor dividing the total energy by n does give you the total time $t$.\\n\\nHowever the trick is that if you do this, some of the batteries has more energy than $t$. So you need to account for this as not usable power."
                    },
                    {
                        "username": "mohit7086",
                        "content": "yeah \\uD83D\\uDE02"
                    },
                    {
                        "username": "0xJaskeerat",
                        "content": "Did the same"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There was no power at home for a half day. I really need batteries!  The example 1 is quite interesting. By a smart  way of interchanging the batteries the maximal running time is  optimized. In most cases the battery is plugged in and until it has no power!"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "how the hell can u solve this in time limit???!!!!!!"
                    },
                    {
                        "username": "EntityPlantt",
                        "content": "hints & editorial: let us introduce ourselves"
                    }
                ]
            },
            {
                "id": 1988196,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "this problem sure did drain my batteries ... "
                    },
                    {
                        "username": "sushimatou",
                        "content": "one hour and a half, not even a beginning of an answer T-T"
                    },
                    {
                        "username": "yourick",
                        "content": "### More similar problems:\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/description/)\n[410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\n[668. Kth Smallest Number in Multiplication Table](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/description/)\n[719. Find K-th Smallest Pair Distance](https://leetcode.com/problems/find-k-th-smallest-pair-distance/description/)\n[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/)\n[1283. Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/description/)\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/description/)\n[1552. Magnetic Force Between Two Balls](https://leetcode.com/problems/magnetic-force-between-two-balls/description/)\n[1760. Minimum Limit of Balls in a Bag](https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/description/)\n[1802. Maximum Value at a Given Index in a Bounded Array](https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/description/)\n[1870. Minimum Speed to Arrive on Time](https://leetcode.com/problems/minimum-speed-to-arrive-on-time/description/)\n[1898. Maximum Number of Removable Characters](https://leetcode.com/problems/maximum-number-of-removable-characters/description/)\n[2064. Minimized Maximum of Products Distributed to Any Store](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/description/)\n[2071. Maximum Number of Tasks You Can Assign](https://leetcode.com/problems/maximum-number-of-tasks-you-can-assign/description/)\n[2141. Maximum Running Time of N Computers](https://leetcode.com/problems/maximum-running-time-of-n-computers/)\n[2187. Minimum Time to Complete Trips](https://leetcode.com/problems/minimum-time-to-complete-trips/description/)\n[2226. Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/description/)\n[2517. Maximum Tastiness of Candy Basket](https://leetcode.com/problems/maximum-tastiness-of-candy-basket/description/)\n[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/description/)\n[2560. House Robber IV](https://leetcode.com/problems/house-robber-iv/description/)\n[2594. Minimum Time to Repair Cars](https://leetcode.com/problems/minimum-time-to-repair-cars/description/)\n[2616. Minimize the Maximum Difference of Pairs](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/description/)\n"
                    },
                    {
                        "username": "prototye",
                        "content": "[@bparanj](/bparanj) chat gpt\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Here are 10 distinct problems that use similar underlying concepts:\\n\\n1. [Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts](https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/): This problem also involves sorting and finding maximum possible values after cuts, which is similar to our original problem of distributing charge among computers.\\n\\n2. [Task Scheduler](https://leetcode.com/problems/task-scheduler/): The task scheduling problem also uses a greedy approach to fit tasks into a schedule in a way that minimizes idle time.\\n\\n3. [Boats to Save People](https://leetcode.com/problems/boats-to-save-people/): This problem involves figuring out the minimum number of boats required to save people, a concept akin to determining the maximum running time of computers.\\n\\n4. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/): This problem also involves maximizing a certain parameter (the sum in this case) over a given set of integers.\\n\\n5. [Jump Game II](https://leetcode.com/problems/jump-game-ii/): This problem also involves maximizing a certain parameter (the number of jumps in this case) and uses a greedy algorithm approach.\\n\\n6. [Container With Most Water](https://leetcode.com/problems/container-with-most-water/): The strategy used in this problem, where we try to maximize the area of water the container can hold, is somewhat similar to our original problem where we tried to maximize the runtime.\\n\\n7. [Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/): This problem asks to divide an array into segments to minimize the maximum sum among them, which can be solved using a binary search in the same vein as the original problem.\\n\\n8. [Gas Station](https://leetcode.com/problems/gas-station/): The greedy approach used in this problem to find the starting gas station is similar to the strategy used in the original problem.\\n\\n9. [Queue Reconstruction by Height](https://leetcode.com/problems/queue-reconstruction-by-height/): The approach of sorting and then placing elements based on some condition is similar to the original problem.\\n\\n10. [Largest Number](https://leetcode.com/problems/largest-number/): The problem involves sorting and arranging elements in a certain way to maximize a value, which is a similar strategy as the original problem. \\n"
                    },
                    {
                        "username": "metaphysicalist",
                        "content": "The week of binary search?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "use biggest batteries first. All the batteries left after are your extra hours - just spread it across evenly (for ex, if u have two batteries left 2 and 3 hours it is the same as if u had 5 batteries 1 hour each)"
                    },
                    {
                        "username": "timofeev_evg",
                        "content": "[@charonme](/charonme) nothing to divide here. [100,1] + 2 extra, answer is 3"
                    },
                    {
                        "username": "charonme",
                        "content": "[@c4tdog](/c4tdog) a battery can\\'t be divided, try to apply your algo to n=2, batteries=[100,1,1,1] testcase"
                    },
                    {
                        "username": "Karthik949",
                        "content": "I went with same logic using Heaps "
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@charonme](/charonme) last one could be divided between two"
                    },
                    {
                        "username": "charonme",
                        "content": "this approach already doesn\\'t work with example 1. You\\'d use the two 3h batteries and will be left with one 3h battery for 2 computers"
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@c4tdog](/c4tdog)  okay sir !"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@omkarsk98](/omkarsk98) I used  maxHeap immediately I saw the question but hit TLE pretty fast"
                    },
                    {
                        "username": "hero080",
                        "content": "[@anuron_das](/anuron_das) \\nA much better way:\\n`[10, 10, 3, 5]` and `n = 3` is the same as `[3, 5]` and `n = 1`, we have total power of 8 so we can run 8 minutes.\\nThis also validates our point: `10 > 8` therefore these \"high power\" batteries will never be used up.\\n\\nSee the details:\\nhttps://leetcode.com/problems/maximum-running-time-of-n-computers/solutions/3822290/beat-100-o-m-nlogn-most-intuitive-solution-no-bs-no-heap/"
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@Ultron03](/Ultron03) since 5 in much less than 10, all last 3 hours goes to it, and the answer is 8. in case 10 10 10, u could split 3 among all computers and the answer would be 11"
                    },
                    {
                        "username": "anuron_das",
                        "content": "What you are saying is correct, but is very counterintuitive for me to understand. \n\nWhen we have 2 batteries of `3-hr` and `2-hr` power, we can attach these batteries to at most 2 computers at a time right? But when I am equating this to the scenario where I have 5 batteries of `1-hr` power, then I am claiming that I can attach these 2 batteries to at most 5 computers at a time. Isn't that incorrect?\n\nAlso, if it really is the case then if we start off by using the batteries with least power first, then also this approach should work. But interestingly it does not. \n\nTake the test case `[10,10,3,5]` with `n=3`. If I use the lest powered batteries first then I will attach the `3-hr`, `5-hr` and `10-hr` battery first. Now I have 1 `10-hr` battery left, which is same as having 10 `1-hr` batteries (just play along with me, even though this is a false argument). I will attach 6 `1-hr` batteries to the `1st` computer (one running on the `3-hr` battery), and the remaining 4 `1-hr` batteries to the `2nd` computer (one currently running on a `5-hr` battery).\n\nSo now the `1st` one runs for `9-hrs`, `2nd` one runs for `9-hrs` and the `3rd` one runs for `10-hrs`. So the answer we get is `9-hrs` max. Wrong answer obviously.\n\nI hope you can see my point, and would appreciate if someone corrects me.\n"
                    },
                    {
                        "username": "omkarsk98",
                        "content": "I see a priority queue here. Is it correct?"
                    },
                    {
                        "username": "Ultron03",
                        "content": "How it will correct ans for 10,10,5,3 and n=3"
                    },
                    {
                        "username": "aitachii",
                        "content": "You should try these testcases first:\n\n    3\n    [10,10,5,3]\n\n    4\n    [8, 1, 4, 8]\n\n    2\n    [31,87,85,44,47,25]\n\nHint: The 2nd one can be done in O(n) time, O(1) space."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "add this also \\n```\\n12\\n[11,89,16,32,70,67,35,35,31,24,41,29,6,53,78,83]\\n```"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "wow very clear description\\nnot like yesterday\\n"
                    },
                    {
                        "username": "fli033",
                        "content": "I originally though binary search... But I couldn\\'t figure out how to test if a target time can be met... RIP"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@moraalejandro94](/moraalejandro94) Lets consider an example  n=3 batteries=[10,10,4]   the answer here will be 4 and not the 8 but according to your concept \\n( 10+10+4=24>=3*8)   answer=8"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@moraalejandro94](/moraalejandro94) Thanks! That\\'s a great hint."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "You need to run n computers for \\'mid\\' minutes -> n*mid \"energy units\". For each battery, it can contribute at most \\'mid\\' energy units, so you can check if the sum of what each battery can contribute is more than n*mid. "
                    },
                    {
                        "username": "pramod74",
                        "content": "34/52 testcases passed using this simple logic:\n\nreturn Math.floor(sum of elements in batteries array/n)\n\n:)"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@AssortedFantasy](/AssortedFantasy) Note that the problem can actually be done without Binary search at all like the hint suggest, its even easier of you use what I\\'ve said."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is almost the entirely solution.\\n\\nIts not obvious, but being able to swap batteries around means you can indeed almost make full use out of every battery, so yes simply floor dividing the total energy by n does give you the total time $t$.\\n\\nHowever the trick is that if you do this, some of the batteries has more energy than $t$. So you need to account for this as not usable power."
                    },
                    {
                        "username": "mohit7086",
                        "content": "yeah \\uD83D\\uDE02"
                    },
                    {
                        "username": "0xJaskeerat",
                        "content": "Did the same"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There was no power at home for a half day. I really need batteries!  The example 1 is quite interesting. By a smart  way of interchanging the batteries the maximal running time is  optimized. In most cases the battery is plugged in and until it has no power!"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "how the hell can u solve this in time limit???!!!!!!"
                    },
                    {
                        "username": "EntityPlantt",
                        "content": "hints & editorial: let us introduce ourselves"
                    }
                ]
            },
            {
                "id": 1988064,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "this problem sure did drain my batteries ... "
                    },
                    {
                        "username": "sushimatou",
                        "content": "one hour and a half, not even a beginning of an answer T-T"
                    },
                    {
                        "username": "yourick",
                        "content": "### More similar problems:\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/description/)\n[410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\n[668. Kth Smallest Number in Multiplication Table](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/description/)\n[719. Find K-th Smallest Pair Distance](https://leetcode.com/problems/find-k-th-smallest-pair-distance/description/)\n[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/)\n[1283. Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/description/)\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/description/)\n[1552. Magnetic Force Between Two Balls](https://leetcode.com/problems/magnetic-force-between-two-balls/description/)\n[1760. Minimum Limit of Balls in a Bag](https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/description/)\n[1802. Maximum Value at a Given Index in a Bounded Array](https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/description/)\n[1870. Minimum Speed to Arrive on Time](https://leetcode.com/problems/minimum-speed-to-arrive-on-time/description/)\n[1898. Maximum Number of Removable Characters](https://leetcode.com/problems/maximum-number-of-removable-characters/description/)\n[2064. Minimized Maximum of Products Distributed to Any Store](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/description/)\n[2071. Maximum Number of Tasks You Can Assign](https://leetcode.com/problems/maximum-number-of-tasks-you-can-assign/description/)\n[2141. Maximum Running Time of N Computers](https://leetcode.com/problems/maximum-running-time-of-n-computers/)\n[2187. Minimum Time to Complete Trips](https://leetcode.com/problems/minimum-time-to-complete-trips/description/)\n[2226. Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/description/)\n[2517. Maximum Tastiness of Candy Basket](https://leetcode.com/problems/maximum-tastiness-of-candy-basket/description/)\n[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/description/)\n[2560. House Robber IV](https://leetcode.com/problems/house-robber-iv/description/)\n[2594. Minimum Time to Repair Cars](https://leetcode.com/problems/minimum-time-to-repair-cars/description/)\n[2616. Minimize the Maximum Difference of Pairs](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/description/)\n"
                    },
                    {
                        "username": "prototye",
                        "content": "[@bparanj](/bparanj) chat gpt\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Here are 10 distinct problems that use similar underlying concepts:\\n\\n1. [Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts](https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/): This problem also involves sorting and finding maximum possible values after cuts, which is similar to our original problem of distributing charge among computers.\\n\\n2. [Task Scheduler](https://leetcode.com/problems/task-scheduler/): The task scheduling problem also uses a greedy approach to fit tasks into a schedule in a way that minimizes idle time.\\n\\n3. [Boats to Save People](https://leetcode.com/problems/boats-to-save-people/): This problem involves figuring out the minimum number of boats required to save people, a concept akin to determining the maximum running time of computers.\\n\\n4. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/): This problem also involves maximizing a certain parameter (the sum in this case) over a given set of integers.\\n\\n5. [Jump Game II](https://leetcode.com/problems/jump-game-ii/): This problem also involves maximizing a certain parameter (the number of jumps in this case) and uses a greedy algorithm approach.\\n\\n6. [Container With Most Water](https://leetcode.com/problems/container-with-most-water/): The strategy used in this problem, where we try to maximize the area of water the container can hold, is somewhat similar to our original problem where we tried to maximize the runtime.\\n\\n7. [Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/): This problem asks to divide an array into segments to minimize the maximum sum among them, which can be solved using a binary search in the same vein as the original problem.\\n\\n8. [Gas Station](https://leetcode.com/problems/gas-station/): The greedy approach used in this problem to find the starting gas station is similar to the strategy used in the original problem.\\n\\n9. [Queue Reconstruction by Height](https://leetcode.com/problems/queue-reconstruction-by-height/): The approach of sorting and then placing elements based on some condition is similar to the original problem.\\n\\n10. [Largest Number](https://leetcode.com/problems/largest-number/): The problem involves sorting and arranging elements in a certain way to maximize a value, which is a similar strategy as the original problem. \\n"
                    },
                    {
                        "username": "metaphysicalist",
                        "content": "The week of binary search?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "use biggest batteries first. All the batteries left after are your extra hours - just spread it across evenly (for ex, if u have two batteries left 2 and 3 hours it is the same as if u had 5 batteries 1 hour each)"
                    },
                    {
                        "username": "timofeev_evg",
                        "content": "[@charonme](/charonme) nothing to divide here. [100,1] + 2 extra, answer is 3"
                    },
                    {
                        "username": "charonme",
                        "content": "[@c4tdog](/c4tdog) a battery can\\'t be divided, try to apply your algo to n=2, batteries=[100,1,1,1] testcase"
                    },
                    {
                        "username": "Karthik949",
                        "content": "I went with same logic using Heaps "
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@charonme](/charonme) last one could be divided between two"
                    },
                    {
                        "username": "charonme",
                        "content": "this approach already doesn\\'t work with example 1. You\\'d use the two 3h batteries and will be left with one 3h battery for 2 computers"
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@c4tdog](/c4tdog)  okay sir !"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@omkarsk98](/omkarsk98) I used  maxHeap immediately I saw the question but hit TLE pretty fast"
                    },
                    {
                        "username": "hero080",
                        "content": "[@anuron_das](/anuron_das) \\nA much better way:\\n`[10, 10, 3, 5]` and `n = 3` is the same as `[3, 5]` and `n = 1`, we have total power of 8 so we can run 8 minutes.\\nThis also validates our point: `10 > 8` therefore these \"high power\" batteries will never be used up.\\n\\nSee the details:\\nhttps://leetcode.com/problems/maximum-running-time-of-n-computers/solutions/3822290/beat-100-o-m-nlogn-most-intuitive-solution-no-bs-no-heap/"
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@Ultron03](/Ultron03) since 5 in much less than 10, all last 3 hours goes to it, and the answer is 8. in case 10 10 10, u could split 3 among all computers and the answer would be 11"
                    },
                    {
                        "username": "anuron_das",
                        "content": "What you are saying is correct, but is very counterintuitive for me to understand. \n\nWhen we have 2 batteries of `3-hr` and `2-hr` power, we can attach these batteries to at most 2 computers at a time right? But when I am equating this to the scenario where I have 5 batteries of `1-hr` power, then I am claiming that I can attach these 2 batteries to at most 5 computers at a time. Isn't that incorrect?\n\nAlso, if it really is the case then if we start off by using the batteries with least power first, then also this approach should work. But interestingly it does not. \n\nTake the test case `[10,10,3,5]` with `n=3`. If I use the lest powered batteries first then I will attach the `3-hr`, `5-hr` and `10-hr` battery first. Now I have 1 `10-hr` battery left, which is same as having 10 `1-hr` batteries (just play along with me, even though this is a false argument). I will attach 6 `1-hr` batteries to the `1st` computer (one running on the `3-hr` battery), and the remaining 4 `1-hr` batteries to the `2nd` computer (one currently running on a `5-hr` battery).\n\nSo now the `1st` one runs for `9-hrs`, `2nd` one runs for `9-hrs` and the `3rd` one runs for `10-hrs`. So the answer we get is `9-hrs` max. Wrong answer obviously.\n\nI hope you can see my point, and would appreciate if someone corrects me.\n"
                    },
                    {
                        "username": "omkarsk98",
                        "content": "I see a priority queue here. Is it correct?"
                    },
                    {
                        "username": "Ultron03",
                        "content": "How it will correct ans for 10,10,5,3 and n=3"
                    },
                    {
                        "username": "aitachii",
                        "content": "You should try these testcases first:\n\n    3\n    [10,10,5,3]\n\n    4\n    [8, 1, 4, 8]\n\n    2\n    [31,87,85,44,47,25]\n\nHint: The 2nd one can be done in O(n) time, O(1) space."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "add this also \\n```\\n12\\n[11,89,16,32,70,67,35,35,31,24,41,29,6,53,78,83]\\n```"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "wow very clear description\\nnot like yesterday\\n"
                    },
                    {
                        "username": "fli033",
                        "content": "I originally though binary search... But I couldn\\'t figure out how to test if a target time can be met... RIP"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@moraalejandro94](/moraalejandro94) Lets consider an example  n=3 batteries=[10,10,4]   the answer here will be 4 and not the 8 but according to your concept \\n( 10+10+4=24>=3*8)   answer=8"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@moraalejandro94](/moraalejandro94) Thanks! That\\'s a great hint."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "You need to run n computers for \\'mid\\' minutes -> n*mid \"energy units\". For each battery, it can contribute at most \\'mid\\' energy units, so you can check if the sum of what each battery can contribute is more than n*mid. "
                    },
                    {
                        "username": "pramod74",
                        "content": "34/52 testcases passed using this simple logic:\n\nreturn Math.floor(sum of elements in batteries array/n)\n\n:)"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@AssortedFantasy](/AssortedFantasy) Note that the problem can actually be done without Binary search at all like the hint suggest, its even easier of you use what I\\'ve said."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is almost the entirely solution.\\n\\nIts not obvious, but being able to swap batteries around means you can indeed almost make full use out of every battery, so yes simply floor dividing the total energy by n does give you the total time $t$.\\n\\nHowever the trick is that if you do this, some of the batteries has more energy than $t$. So you need to account for this as not usable power."
                    },
                    {
                        "username": "mohit7086",
                        "content": "yeah \\uD83D\\uDE02"
                    },
                    {
                        "username": "0xJaskeerat",
                        "content": "Did the same"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There was no power at home for a half day. I really need batteries!  The example 1 is quite interesting. By a smart  way of interchanging the batteries the maximal running time is  optimized. In most cases the battery is plugged in and until it has no power!"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "how the hell can u solve this in time limit???!!!!!!"
                    },
                    {
                        "username": "EntityPlantt",
                        "content": "hints & editorial: let us introduce ourselves"
                    }
                ]
            },
            {
                "id": 1988867,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "this problem sure did drain my batteries ... "
                    },
                    {
                        "username": "sushimatou",
                        "content": "one hour and a half, not even a beginning of an answer T-T"
                    },
                    {
                        "username": "yourick",
                        "content": "### More similar problems:\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/description/)\n[410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\n[668. Kth Smallest Number in Multiplication Table](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/description/)\n[719. Find K-th Smallest Pair Distance](https://leetcode.com/problems/find-k-th-smallest-pair-distance/description/)\n[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/)\n[1283. Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/description/)\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/description/)\n[1552. Magnetic Force Between Two Balls](https://leetcode.com/problems/magnetic-force-between-two-balls/description/)\n[1760. Minimum Limit of Balls in a Bag](https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/description/)\n[1802. Maximum Value at a Given Index in a Bounded Array](https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/description/)\n[1870. Minimum Speed to Arrive on Time](https://leetcode.com/problems/minimum-speed-to-arrive-on-time/description/)\n[1898. Maximum Number of Removable Characters](https://leetcode.com/problems/maximum-number-of-removable-characters/description/)\n[2064. Minimized Maximum of Products Distributed to Any Store](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/description/)\n[2071. Maximum Number of Tasks You Can Assign](https://leetcode.com/problems/maximum-number-of-tasks-you-can-assign/description/)\n[2141. Maximum Running Time of N Computers](https://leetcode.com/problems/maximum-running-time-of-n-computers/)\n[2187. Minimum Time to Complete Trips](https://leetcode.com/problems/minimum-time-to-complete-trips/description/)\n[2226. Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/description/)\n[2517. Maximum Tastiness of Candy Basket](https://leetcode.com/problems/maximum-tastiness-of-candy-basket/description/)\n[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/description/)\n[2560. House Robber IV](https://leetcode.com/problems/house-robber-iv/description/)\n[2594. Minimum Time to Repair Cars](https://leetcode.com/problems/minimum-time-to-repair-cars/description/)\n[2616. Minimize the Maximum Difference of Pairs](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/description/)\n"
                    },
                    {
                        "username": "prototye",
                        "content": "[@bparanj](/bparanj) chat gpt\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Here are 10 distinct problems that use similar underlying concepts:\\n\\n1. [Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts](https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/): This problem also involves sorting and finding maximum possible values after cuts, which is similar to our original problem of distributing charge among computers.\\n\\n2. [Task Scheduler](https://leetcode.com/problems/task-scheduler/): The task scheduling problem also uses a greedy approach to fit tasks into a schedule in a way that minimizes idle time.\\n\\n3. [Boats to Save People](https://leetcode.com/problems/boats-to-save-people/): This problem involves figuring out the minimum number of boats required to save people, a concept akin to determining the maximum running time of computers.\\n\\n4. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/): This problem also involves maximizing a certain parameter (the sum in this case) over a given set of integers.\\n\\n5. [Jump Game II](https://leetcode.com/problems/jump-game-ii/): This problem also involves maximizing a certain parameter (the number of jumps in this case) and uses a greedy algorithm approach.\\n\\n6. [Container With Most Water](https://leetcode.com/problems/container-with-most-water/): The strategy used in this problem, where we try to maximize the area of water the container can hold, is somewhat similar to our original problem where we tried to maximize the runtime.\\n\\n7. [Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/): This problem asks to divide an array into segments to minimize the maximum sum among them, which can be solved using a binary search in the same vein as the original problem.\\n\\n8. [Gas Station](https://leetcode.com/problems/gas-station/): The greedy approach used in this problem to find the starting gas station is similar to the strategy used in the original problem.\\n\\n9. [Queue Reconstruction by Height](https://leetcode.com/problems/queue-reconstruction-by-height/): The approach of sorting and then placing elements based on some condition is similar to the original problem.\\n\\n10. [Largest Number](https://leetcode.com/problems/largest-number/): The problem involves sorting and arranging elements in a certain way to maximize a value, which is a similar strategy as the original problem. \\n"
                    },
                    {
                        "username": "metaphysicalist",
                        "content": "The week of binary search?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "use biggest batteries first. All the batteries left after are your extra hours - just spread it across evenly (for ex, if u have two batteries left 2 and 3 hours it is the same as if u had 5 batteries 1 hour each)"
                    },
                    {
                        "username": "timofeev_evg",
                        "content": "[@charonme](/charonme) nothing to divide here. [100,1] + 2 extra, answer is 3"
                    },
                    {
                        "username": "charonme",
                        "content": "[@c4tdog](/c4tdog) a battery can\\'t be divided, try to apply your algo to n=2, batteries=[100,1,1,1] testcase"
                    },
                    {
                        "username": "Karthik949",
                        "content": "I went with same logic using Heaps "
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@charonme](/charonme) last one could be divided between two"
                    },
                    {
                        "username": "charonme",
                        "content": "this approach already doesn\\'t work with example 1. You\\'d use the two 3h batteries and will be left with one 3h battery for 2 computers"
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@c4tdog](/c4tdog)  okay sir !"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@omkarsk98](/omkarsk98) I used  maxHeap immediately I saw the question but hit TLE pretty fast"
                    },
                    {
                        "username": "hero080",
                        "content": "[@anuron_das](/anuron_das) \\nA much better way:\\n`[10, 10, 3, 5]` and `n = 3` is the same as `[3, 5]` and `n = 1`, we have total power of 8 so we can run 8 minutes.\\nThis also validates our point: `10 > 8` therefore these \"high power\" batteries will never be used up.\\n\\nSee the details:\\nhttps://leetcode.com/problems/maximum-running-time-of-n-computers/solutions/3822290/beat-100-o-m-nlogn-most-intuitive-solution-no-bs-no-heap/"
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@Ultron03](/Ultron03) since 5 in much less than 10, all last 3 hours goes to it, and the answer is 8. in case 10 10 10, u could split 3 among all computers and the answer would be 11"
                    },
                    {
                        "username": "anuron_das",
                        "content": "What you are saying is correct, but is very counterintuitive for me to understand. \n\nWhen we have 2 batteries of `3-hr` and `2-hr` power, we can attach these batteries to at most 2 computers at a time right? But when I am equating this to the scenario where I have 5 batteries of `1-hr` power, then I am claiming that I can attach these 2 batteries to at most 5 computers at a time. Isn't that incorrect?\n\nAlso, if it really is the case then if we start off by using the batteries with least power first, then also this approach should work. But interestingly it does not. \n\nTake the test case `[10,10,3,5]` with `n=3`. If I use the lest powered batteries first then I will attach the `3-hr`, `5-hr` and `10-hr` battery first. Now I have 1 `10-hr` battery left, which is same as having 10 `1-hr` batteries (just play along with me, even though this is a false argument). I will attach 6 `1-hr` batteries to the `1st` computer (one running on the `3-hr` battery), and the remaining 4 `1-hr` batteries to the `2nd` computer (one currently running on a `5-hr` battery).\n\nSo now the `1st` one runs for `9-hrs`, `2nd` one runs for `9-hrs` and the `3rd` one runs for `10-hrs`. So the answer we get is `9-hrs` max. Wrong answer obviously.\n\nI hope you can see my point, and would appreciate if someone corrects me.\n"
                    },
                    {
                        "username": "omkarsk98",
                        "content": "I see a priority queue here. Is it correct?"
                    },
                    {
                        "username": "Ultron03",
                        "content": "How it will correct ans for 10,10,5,3 and n=3"
                    },
                    {
                        "username": "aitachii",
                        "content": "You should try these testcases first:\n\n    3\n    [10,10,5,3]\n\n    4\n    [8, 1, 4, 8]\n\n    2\n    [31,87,85,44,47,25]\n\nHint: The 2nd one can be done in O(n) time, O(1) space."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "add this also \\n```\\n12\\n[11,89,16,32,70,67,35,35,31,24,41,29,6,53,78,83]\\n```"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "wow very clear description\\nnot like yesterday\\n"
                    },
                    {
                        "username": "fli033",
                        "content": "I originally though binary search... But I couldn\\'t figure out how to test if a target time can be met... RIP"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@moraalejandro94](/moraalejandro94) Lets consider an example  n=3 batteries=[10,10,4]   the answer here will be 4 and not the 8 but according to your concept \\n( 10+10+4=24>=3*8)   answer=8"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@moraalejandro94](/moraalejandro94) Thanks! That\\'s a great hint."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "You need to run n computers for \\'mid\\' minutes -> n*mid \"energy units\". For each battery, it can contribute at most \\'mid\\' energy units, so you can check if the sum of what each battery can contribute is more than n*mid. "
                    },
                    {
                        "username": "pramod74",
                        "content": "34/52 testcases passed using this simple logic:\n\nreturn Math.floor(sum of elements in batteries array/n)\n\n:)"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@AssortedFantasy](/AssortedFantasy) Note that the problem can actually be done without Binary search at all like the hint suggest, its even easier of you use what I\\'ve said."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is almost the entirely solution.\\n\\nIts not obvious, but being able to swap batteries around means you can indeed almost make full use out of every battery, so yes simply floor dividing the total energy by n does give you the total time $t$.\\n\\nHowever the trick is that if you do this, some of the batteries has more energy than $t$. So you need to account for this as not usable power."
                    },
                    {
                        "username": "mohit7086",
                        "content": "yeah \\uD83D\\uDE02"
                    },
                    {
                        "username": "0xJaskeerat",
                        "content": "Did the same"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There was no power at home for a half day. I really need batteries!  The example 1 is quite interesting. By a smart  way of interchanging the batteries the maximal running time is  optimized. In most cases the battery is plugged in and until it has no power!"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "how the hell can u solve this in time limit???!!!!!!"
                    },
                    {
                        "username": "EntityPlantt",
                        "content": "hints & editorial: let us introduce ourselves"
                    }
                ]
            },
            {
                "id": 1988260,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "this problem sure did drain my batteries ... "
                    },
                    {
                        "username": "sushimatou",
                        "content": "one hour and a half, not even a beginning of an answer T-T"
                    },
                    {
                        "username": "yourick",
                        "content": "### More similar problems:\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/description/)\n[410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\n[668. Kth Smallest Number in Multiplication Table](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/description/)\n[719. Find K-th Smallest Pair Distance](https://leetcode.com/problems/find-k-th-smallest-pair-distance/description/)\n[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/)\n[1283. Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/description/)\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/description/)\n[1552. Magnetic Force Between Two Balls](https://leetcode.com/problems/magnetic-force-between-two-balls/description/)\n[1760. Minimum Limit of Balls in a Bag](https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/description/)\n[1802. Maximum Value at a Given Index in a Bounded Array](https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/description/)\n[1870. Minimum Speed to Arrive on Time](https://leetcode.com/problems/minimum-speed-to-arrive-on-time/description/)\n[1898. Maximum Number of Removable Characters](https://leetcode.com/problems/maximum-number-of-removable-characters/description/)\n[2064. Minimized Maximum of Products Distributed to Any Store](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/description/)\n[2071. Maximum Number of Tasks You Can Assign](https://leetcode.com/problems/maximum-number-of-tasks-you-can-assign/description/)\n[2141. Maximum Running Time of N Computers](https://leetcode.com/problems/maximum-running-time-of-n-computers/)\n[2187. Minimum Time to Complete Trips](https://leetcode.com/problems/minimum-time-to-complete-trips/description/)\n[2226. Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/description/)\n[2517. Maximum Tastiness of Candy Basket](https://leetcode.com/problems/maximum-tastiness-of-candy-basket/description/)\n[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/description/)\n[2560. House Robber IV](https://leetcode.com/problems/house-robber-iv/description/)\n[2594. Minimum Time to Repair Cars](https://leetcode.com/problems/minimum-time-to-repair-cars/description/)\n[2616. Minimize the Maximum Difference of Pairs](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/description/)\n"
                    },
                    {
                        "username": "prototye",
                        "content": "[@bparanj](/bparanj) chat gpt\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Here are 10 distinct problems that use similar underlying concepts:\\n\\n1. [Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts](https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/): This problem also involves sorting and finding maximum possible values after cuts, which is similar to our original problem of distributing charge among computers.\\n\\n2. [Task Scheduler](https://leetcode.com/problems/task-scheduler/): The task scheduling problem also uses a greedy approach to fit tasks into a schedule in a way that minimizes idle time.\\n\\n3. [Boats to Save People](https://leetcode.com/problems/boats-to-save-people/): This problem involves figuring out the minimum number of boats required to save people, a concept akin to determining the maximum running time of computers.\\n\\n4. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/): This problem also involves maximizing a certain parameter (the sum in this case) over a given set of integers.\\n\\n5. [Jump Game II](https://leetcode.com/problems/jump-game-ii/): This problem also involves maximizing a certain parameter (the number of jumps in this case) and uses a greedy algorithm approach.\\n\\n6. [Container With Most Water](https://leetcode.com/problems/container-with-most-water/): The strategy used in this problem, where we try to maximize the area of water the container can hold, is somewhat similar to our original problem where we tried to maximize the runtime.\\n\\n7. [Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/): This problem asks to divide an array into segments to minimize the maximum sum among them, which can be solved using a binary search in the same vein as the original problem.\\n\\n8. [Gas Station](https://leetcode.com/problems/gas-station/): The greedy approach used in this problem to find the starting gas station is similar to the strategy used in the original problem.\\n\\n9. [Queue Reconstruction by Height](https://leetcode.com/problems/queue-reconstruction-by-height/): The approach of sorting and then placing elements based on some condition is similar to the original problem.\\n\\n10. [Largest Number](https://leetcode.com/problems/largest-number/): The problem involves sorting and arranging elements in a certain way to maximize a value, which is a similar strategy as the original problem. \\n"
                    },
                    {
                        "username": "metaphysicalist",
                        "content": "The week of binary search?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "use biggest batteries first. All the batteries left after are your extra hours - just spread it across evenly (for ex, if u have two batteries left 2 and 3 hours it is the same as if u had 5 batteries 1 hour each)"
                    },
                    {
                        "username": "timofeev_evg",
                        "content": "[@charonme](/charonme) nothing to divide here. [100,1] + 2 extra, answer is 3"
                    },
                    {
                        "username": "charonme",
                        "content": "[@c4tdog](/c4tdog) a battery can\\'t be divided, try to apply your algo to n=2, batteries=[100,1,1,1] testcase"
                    },
                    {
                        "username": "Karthik949",
                        "content": "I went with same logic using Heaps "
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@charonme](/charonme) last one could be divided between two"
                    },
                    {
                        "username": "charonme",
                        "content": "this approach already doesn\\'t work with example 1. You\\'d use the two 3h batteries and will be left with one 3h battery for 2 computers"
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@c4tdog](/c4tdog)  okay sir !"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@omkarsk98](/omkarsk98) I used  maxHeap immediately I saw the question but hit TLE pretty fast"
                    },
                    {
                        "username": "hero080",
                        "content": "[@anuron_das](/anuron_das) \\nA much better way:\\n`[10, 10, 3, 5]` and `n = 3` is the same as `[3, 5]` and `n = 1`, we have total power of 8 so we can run 8 minutes.\\nThis also validates our point: `10 > 8` therefore these \"high power\" batteries will never be used up.\\n\\nSee the details:\\nhttps://leetcode.com/problems/maximum-running-time-of-n-computers/solutions/3822290/beat-100-o-m-nlogn-most-intuitive-solution-no-bs-no-heap/"
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@Ultron03](/Ultron03) since 5 in much less than 10, all last 3 hours goes to it, and the answer is 8. in case 10 10 10, u could split 3 among all computers and the answer would be 11"
                    },
                    {
                        "username": "anuron_das",
                        "content": "What you are saying is correct, but is very counterintuitive for me to understand. \n\nWhen we have 2 batteries of `3-hr` and `2-hr` power, we can attach these batteries to at most 2 computers at a time right? But when I am equating this to the scenario where I have 5 batteries of `1-hr` power, then I am claiming that I can attach these 2 batteries to at most 5 computers at a time. Isn't that incorrect?\n\nAlso, if it really is the case then if we start off by using the batteries with least power first, then also this approach should work. But interestingly it does not. \n\nTake the test case `[10,10,3,5]` with `n=3`. If I use the lest powered batteries first then I will attach the `3-hr`, `5-hr` and `10-hr` battery first. Now I have 1 `10-hr` battery left, which is same as having 10 `1-hr` batteries (just play along with me, even though this is a false argument). I will attach 6 `1-hr` batteries to the `1st` computer (one running on the `3-hr` battery), and the remaining 4 `1-hr` batteries to the `2nd` computer (one currently running on a `5-hr` battery).\n\nSo now the `1st` one runs for `9-hrs`, `2nd` one runs for `9-hrs` and the `3rd` one runs for `10-hrs`. So the answer we get is `9-hrs` max. Wrong answer obviously.\n\nI hope you can see my point, and would appreciate if someone corrects me.\n"
                    },
                    {
                        "username": "omkarsk98",
                        "content": "I see a priority queue here. Is it correct?"
                    },
                    {
                        "username": "Ultron03",
                        "content": "How it will correct ans for 10,10,5,3 and n=3"
                    },
                    {
                        "username": "aitachii",
                        "content": "You should try these testcases first:\n\n    3\n    [10,10,5,3]\n\n    4\n    [8, 1, 4, 8]\n\n    2\n    [31,87,85,44,47,25]\n\nHint: The 2nd one can be done in O(n) time, O(1) space."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "add this also \\n```\\n12\\n[11,89,16,32,70,67,35,35,31,24,41,29,6,53,78,83]\\n```"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "wow very clear description\\nnot like yesterday\\n"
                    },
                    {
                        "username": "fli033",
                        "content": "I originally though binary search... But I couldn\\'t figure out how to test if a target time can be met... RIP"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@moraalejandro94](/moraalejandro94) Lets consider an example  n=3 batteries=[10,10,4]   the answer here will be 4 and not the 8 but according to your concept \\n( 10+10+4=24>=3*8)   answer=8"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@moraalejandro94](/moraalejandro94) Thanks! That\\'s a great hint."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "You need to run n computers for \\'mid\\' minutes -> n*mid \"energy units\". For each battery, it can contribute at most \\'mid\\' energy units, so you can check if the sum of what each battery can contribute is more than n*mid. "
                    },
                    {
                        "username": "pramod74",
                        "content": "34/52 testcases passed using this simple logic:\n\nreturn Math.floor(sum of elements in batteries array/n)\n\n:)"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@AssortedFantasy](/AssortedFantasy) Note that the problem can actually be done without Binary search at all like the hint suggest, its even easier of you use what I\\'ve said."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is almost the entirely solution.\\n\\nIts not obvious, but being able to swap batteries around means you can indeed almost make full use out of every battery, so yes simply floor dividing the total energy by n does give you the total time $t$.\\n\\nHowever the trick is that if you do this, some of the batteries has more energy than $t$. So you need to account for this as not usable power."
                    },
                    {
                        "username": "mohit7086",
                        "content": "yeah \\uD83D\\uDE02"
                    },
                    {
                        "username": "0xJaskeerat",
                        "content": "Did the same"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There was no power at home for a half day. I really need batteries!  The example 1 is quite interesting. By a smart  way of interchanging the batteries the maximal running time is  optimized. In most cases the battery is plugged in and until it has no power!"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "how the hell can u solve this in time limit???!!!!!!"
                    },
                    {
                        "username": "EntityPlantt",
                        "content": "hints & editorial: let us introduce ourselves"
                    }
                ]
            },
            {
                "id": 1842319,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "this problem sure did drain my batteries ... "
                    },
                    {
                        "username": "sushimatou",
                        "content": "one hour and a half, not even a beginning of an answer T-T"
                    },
                    {
                        "username": "yourick",
                        "content": "### More similar problems:\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/description/)\n[410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\n[668. Kth Smallest Number in Multiplication Table](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/description/)\n[719. Find K-th Smallest Pair Distance](https://leetcode.com/problems/find-k-th-smallest-pair-distance/description/)\n[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/)\n[1283. Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/description/)\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/description/)\n[1552. Magnetic Force Between Two Balls](https://leetcode.com/problems/magnetic-force-between-two-balls/description/)\n[1760. Minimum Limit of Balls in a Bag](https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/description/)\n[1802. Maximum Value at a Given Index in a Bounded Array](https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/description/)\n[1870. Minimum Speed to Arrive on Time](https://leetcode.com/problems/minimum-speed-to-arrive-on-time/description/)\n[1898. Maximum Number of Removable Characters](https://leetcode.com/problems/maximum-number-of-removable-characters/description/)\n[2064. Minimized Maximum of Products Distributed to Any Store](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/description/)\n[2071. Maximum Number of Tasks You Can Assign](https://leetcode.com/problems/maximum-number-of-tasks-you-can-assign/description/)\n[2141. Maximum Running Time of N Computers](https://leetcode.com/problems/maximum-running-time-of-n-computers/)\n[2187. Minimum Time to Complete Trips](https://leetcode.com/problems/minimum-time-to-complete-trips/description/)\n[2226. Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/description/)\n[2517. Maximum Tastiness of Candy Basket](https://leetcode.com/problems/maximum-tastiness-of-candy-basket/description/)\n[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/description/)\n[2560. House Robber IV](https://leetcode.com/problems/house-robber-iv/description/)\n[2594. Minimum Time to Repair Cars](https://leetcode.com/problems/minimum-time-to-repair-cars/description/)\n[2616. Minimize the Maximum Difference of Pairs](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/description/)\n"
                    },
                    {
                        "username": "prototye",
                        "content": "[@bparanj](/bparanj) chat gpt\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Here are 10 distinct problems that use similar underlying concepts:\\n\\n1. [Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts](https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/): This problem also involves sorting and finding maximum possible values after cuts, which is similar to our original problem of distributing charge among computers.\\n\\n2. [Task Scheduler](https://leetcode.com/problems/task-scheduler/): The task scheduling problem also uses a greedy approach to fit tasks into a schedule in a way that minimizes idle time.\\n\\n3. [Boats to Save People](https://leetcode.com/problems/boats-to-save-people/): This problem involves figuring out the minimum number of boats required to save people, a concept akin to determining the maximum running time of computers.\\n\\n4. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/): This problem also involves maximizing a certain parameter (the sum in this case) over a given set of integers.\\n\\n5. [Jump Game II](https://leetcode.com/problems/jump-game-ii/): This problem also involves maximizing a certain parameter (the number of jumps in this case) and uses a greedy algorithm approach.\\n\\n6. [Container With Most Water](https://leetcode.com/problems/container-with-most-water/): The strategy used in this problem, where we try to maximize the area of water the container can hold, is somewhat similar to our original problem where we tried to maximize the runtime.\\n\\n7. [Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/): This problem asks to divide an array into segments to minimize the maximum sum among them, which can be solved using a binary search in the same vein as the original problem.\\n\\n8. [Gas Station](https://leetcode.com/problems/gas-station/): The greedy approach used in this problem to find the starting gas station is similar to the strategy used in the original problem.\\n\\n9. [Queue Reconstruction by Height](https://leetcode.com/problems/queue-reconstruction-by-height/): The approach of sorting and then placing elements based on some condition is similar to the original problem.\\n\\n10. [Largest Number](https://leetcode.com/problems/largest-number/): The problem involves sorting and arranging elements in a certain way to maximize a value, which is a similar strategy as the original problem. \\n"
                    },
                    {
                        "username": "metaphysicalist",
                        "content": "The week of binary search?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "use biggest batteries first. All the batteries left after are your extra hours - just spread it across evenly (for ex, if u have two batteries left 2 and 3 hours it is the same as if u had 5 batteries 1 hour each)"
                    },
                    {
                        "username": "timofeev_evg",
                        "content": "[@charonme](/charonme) nothing to divide here. [100,1] + 2 extra, answer is 3"
                    },
                    {
                        "username": "charonme",
                        "content": "[@c4tdog](/c4tdog) a battery can\\'t be divided, try to apply your algo to n=2, batteries=[100,1,1,1] testcase"
                    },
                    {
                        "username": "Karthik949",
                        "content": "I went with same logic using Heaps "
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@charonme](/charonme) last one could be divided between two"
                    },
                    {
                        "username": "charonme",
                        "content": "this approach already doesn\\'t work with example 1. You\\'d use the two 3h batteries and will be left with one 3h battery for 2 computers"
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@c4tdog](/c4tdog)  okay sir !"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@omkarsk98](/omkarsk98) I used  maxHeap immediately I saw the question but hit TLE pretty fast"
                    },
                    {
                        "username": "hero080",
                        "content": "[@anuron_das](/anuron_das) \\nA much better way:\\n`[10, 10, 3, 5]` and `n = 3` is the same as `[3, 5]` and `n = 1`, we have total power of 8 so we can run 8 minutes.\\nThis also validates our point: `10 > 8` therefore these \"high power\" batteries will never be used up.\\n\\nSee the details:\\nhttps://leetcode.com/problems/maximum-running-time-of-n-computers/solutions/3822290/beat-100-o-m-nlogn-most-intuitive-solution-no-bs-no-heap/"
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@Ultron03](/Ultron03) since 5 in much less than 10, all last 3 hours goes to it, and the answer is 8. in case 10 10 10, u could split 3 among all computers and the answer would be 11"
                    },
                    {
                        "username": "anuron_das",
                        "content": "What you are saying is correct, but is very counterintuitive for me to understand. \n\nWhen we have 2 batteries of `3-hr` and `2-hr` power, we can attach these batteries to at most 2 computers at a time right? But when I am equating this to the scenario where I have 5 batteries of `1-hr` power, then I am claiming that I can attach these 2 batteries to at most 5 computers at a time. Isn't that incorrect?\n\nAlso, if it really is the case then if we start off by using the batteries with least power first, then also this approach should work. But interestingly it does not. \n\nTake the test case `[10,10,3,5]` with `n=3`. If I use the lest powered batteries first then I will attach the `3-hr`, `5-hr` and `10-hr` battery first. Now I have 1 `10-hr` battery left, which is same as having 10 `1-hr` batteries (just play along with me, even though this is a false argument). I will attach 6 `1-hr` batteries to the `1st` computer (one running on the `3-hr` battery), and the remaining 4 `1-hr` batteries to the `2nd` computer (one currently running on a `5-hr` battery).\n\nSo now the `1st` one runs for `9-hrs`, `2nd` one runs for `9-hrs` and the `3rd` one runs for `10-hrs`. So the answer we get is `9-hrs` max. Wrong answer obviously.\n\nI hope you can see my point, and would appreciate if someone corrects me.\n"
                    },
                    {
                        "username": "omkarsk98",
                        "content": "I see a priority queue here. Is it correct?"
                    },
                    {
                        "username": "Ultron03",
                        "content": "How it will correct ans for 10,10,5,3 and n=3"
                    },
                    {
                        "username": "aitachii",
                        "content": "You should try these testcases first:\n\n    3\n    [10,10,5,3]\n\n    4\n    [8, 1, 4, 8]\n\n    2\n    [31,87,85,44,47,25]\n\nHint: The 2nd one can be done in O(n) time, O(1) space."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "add this also \\n```\\n12\\n[11,89,16,32,70,67,35,35,31,24,41,29,6,53,78,83]\\n```"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "wow very clear description\\nnot like yesterday\\n"
                    },
                    {
                        "username": "fli033",
                        "content": "I originally though binary search... But I couldn\\'t figure out how to test if a target time can be met... RIP"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@moraalejandro94](/moraalejandro94) Lets consider an example  n=3 batteries=[10,10,4]   the answer here will be 4 and not the 8 but according to your concept \\n( 10+10+4=24>=3*8)   answer=8"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@moraalejandro94](/moraalejandro94) Thanks! That\\'s a great hint."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "You need to run n computers for \\'mid\\' minutes -> n*mid \"energy units\". For each battery, it can contribute at most \\'mid\\' energy units, so you can check if the sum of what each battery can contribute is more than n*mid. "
                    },
                    {
                        "username": "pramod74",
                        "content": "34/52 testcases passed using this simple logic:\n\nreturn Math.floor(sum of elements in batteries array/n)\n\n:)"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@AssortedFantasy](/AssortedFantasy) Note that the problem can actually be done without Binary search at all like the hint suggest, its even easier of you use what I\\'ve said."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is almost the entirely solution.\\n\\nIts not obvious, but being able to swap batteries around means you can indeed almost make full use out of every battery, so yes simply floor dividing the total energy by n does give you the total time $t$.\\n\\nHowever the trick is that if you do this, some of the batteries has more energy than $t$. So you need to account for this as not usable power."
                    },
                    {
                        "username": "mohit7086",
                        "content": "yeah \\uD83D\\uDE02"
                    },
                    {
                        "username": "0xJaskeerat",
                        "content": "Did the same"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There was no power at home for a half day. I really need batteries!  The example 1 is quite interesting. By a smart  way of interchanging the batteries the maximal running time is  optimized. In most cases the battery is plugged in and until it has no power!"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "how the hell can u solve this in time limit???!!!!!!"
                    },
                    {
                        "username": "EntityPlantt",
                        "content": "hints & editorial: let us introduce ourselves"
                    }
                ]
            },
            {
                "id": 1988060,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "this problem sure did drain my batteries ... "
                    },
                    {
                        "username": "sushimatou",
                        "content": "one hour and a half, not even a beginning of an answer T-T"
                    },
                    {
                        "username": "yourick",
                        "content": "### More similar problems:\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/description/)\n[410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\n[668. Kth Smallest Number in Multiplication Table](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/description/)\n[719. Find K-th Smallest Pair Distance](https://leetcode.com/problems/find-k-th-smallest-pair-distance/description/)\n[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/)\n[1283. Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/description/)\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/description/)\n[1552. Magnetic Force Between Two Balls](https://leetcode.com/problems/magnetic-force-between-two-balls/description/)\n[1760. Minimum Limit of Balls in a Bag](https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/description/)\n[1802. Maximum Value at a Given Index in a Bounded Array](https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/description/)\n[1870. Minimum Speed to Arrive on Time](https://leetcode.com/problems/minimum-speed-to-arrive-on-time/description/)\n[1898. Maximum Number of Removable Characters](https://leetcode.com/problems/maximum-number-of-removable-characters/description/)\n[2064. Minimized Maximum of Products Distributed to Any Store](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/description/)\n[2071. Maximum Number of Tasks You Can Assign](https://leetcode.com/problems/maximum-number-of-tasks-you-can-assign/description/)\n[2141. Maximum Running Time of N Computers](https://leetcode.com/problems/maximum-running-time-of-n-computers/)\n[2187. Minimum Time to Complete Trips](https://leetcode.com/problems/minimum-time-to-complete-trips/description/)\n[2226. Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/description/)\n[2517. Maximum Tastiness of Candy Basket](https://leetcode.com/problems/maximum-tastiness-of-candy-basket/description/)\n[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/description/)\n[2560. House Robber IV](https://leetcode.com/problems/house-robber-iv/description/)\n[2594. Minimum Time to Repair Cars](https://leetcode.com/problems/minimum-time-to-repair-cars/description/)\n[2616. Minimize the Maximum Difference of Pairs](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/description/)\n"
                    },
                    {
                        "username": "prototye",
                        "content": "[@bparanj](/bparanj) chat gpt\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Here are 10 distinct problems that use similar underlying concepts:\\n\\n1. [Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts](https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/): This problem also involves sorting and finding maximum possible values after cuts, which is similar to our original problem of distributing charge among computers.\\n\\n2. [Task Scheduler](https://leetcode.com/problems/task-scheduler/): The task scheduling problem also uses a greedy approach to fit tasks into a schedule in a way that minimizes idle time.\\n\\n3. [Boats to Save People](https://leetcode.com/problems/boats-to-save-people/): This problem involves figuring out the minimum number of boats required to save people, a concept akin to determining the maximum running time of computers.\\n\\n4. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/): This problem also involves maximizing a certain parameter (the sum in this case) over a given set of integers.\\n\\n5. [Jump Game II](https://leetcode.com/problems/jump-game-ii/): This problem also involves maximizing a certain parameter (the number of jumps in this case) and uses a greedy algorithm approach.\\n\\n6. [Container With Most Water](https://leetcode.com/problems/container-with-most-water/): The strategy used in this problem, where we try to maximize the area of water the container can hold, is somewhat similar to our original problem where we tried to maximize the runtime.\\n\\n7. [Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/): This problem asks to divide an array into segments to minimize the maximum sum among them, which can be solved using a binary search in the same vein as the original problem.\\n\\n8. [Gas Station](https://leetcode.com/problems/gas-station/): The greedy approach used in this problem to find the starting gas station is similar to the strategy used in the original problem.\\n\\n9. [Queue Reconstruction by Height](https://leetcode.com/problems/queue-reconstruction-by-height/): The approach of sorting and then placing elements based on some condition is similar to the original problem.\\n\\n10. [Largest Number](https://leetcode.com/problems/largest-number/): The problem involves sorting and arranging elements in a certain way to maximize a value, which is a similar strategy as the original problem. \\n"
                    },
                    {
                        "username": "metaphysicalist",
                        "content": "The week of binary search?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "use biggest batteries first. All the batteries left after are your extra hours - just spread it across evenly (for ex, if u have two batteries left 2 and 3 hours it is the same as if u had 5 batteries 1 hour each)"
                    },
                    {
                        "username": "timofeev_evg",
                        "content": "[@charonme](/charonme) nothing to divide here. [100,1] + 2 extra, answer is 3"
                    },
                    {
                        "username": "charonme",
                        "content": "[@c4tdog](/c4tdog) a battery can\\'t be divided, try to apply your algo to n=2, batteries=[100,1,1,1] testcase"
                    },
                    {
                        "username": "Karthik949",
                        "content": "I went with same logic using Heaps "
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@charonme](/charonme) last one could be divided between two"
                    },
                    {
                        "username": "charonme",
                        "content": "this approach already doesn\\'t work with example 1. You\\'d use the two 3h batteries and will be left with one 3h battery for 2 computers"
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@c4tdog](/c4tdog)  okay sir !"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@omkarsk98](/omkarsk98) I used  maxHeap immediately I saw the question but hit TLE pretty fast"
                    },
                    {
                        "username": "hero080",
                        "content": "[@anuron_das](/anuron_das) \\nA much better way:\\n`[10, 10, 3, 5]` and `n = 3` is the same as `[3, 5]` and `n = 1`, we have total power of 8 so we can run 8 minutes.\\nThis also validates our point: `10 > 8` therefore these \"high power\" batteries will never be used up.\\n\\nSee the details:\\nhttps://leetcode.com/problems/maximum-running-time-of-n-computers/solutions/3822290/beat-100-o-m-nlogn-most-intuitive-solution-no-bs-no-heap/"
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@Ultron03](/Ultron03) since 5 in much less than 10, all last 3 hours goes to it, and the answer is 8. in case 10 10 10, u could split 3 among all computers and the answer would be 11"
                    },
                    {
                        "username": "anuron_das",
                        "content": "What you are saying is correct, but is very counterintuitive for me to understand. \n\nWhen we have 2 batteries of `3-hr` and `2-hr` power, we can attach these batteries to at most 2 computers at a time right? But when I am equating this to the scenario where I have 5 batteries of `1-hr` power, then I am claiming that I can attach these 2 batteries to at most 5 computers at a time. Isn't that incorrect?\n\nAlso, if it really is the case then if we start off by using the batteries with least power first, then also this approach should work. But interestingly it does not. \n\nTake the test case `[10,10,3,5]` with `n=3`. If I use the lest powered batteries first then I will attach the `3-hr`, `5-hr` and `10-hr` battery first. Now I have 1 `10-hr` battery left, which is same as having 10 `1-hr` batteries (just play along with me, even though this is a false argument). I will attach 6 `1-hr` batteries to the `1st` computer (one running on the `3-hr` battery), and the remaining 4 `1-hr` batteries to the `2nd` computer (one currently running on a `5-hr` battery).\n\nSo now the `1st` one runs for `9-hrs`, `2nd` one runs for `9-hrs` and the `3rd` one runs for `10-hrs`. So the answer we get is `9-hrs` max. Wrong answer obviously.\n\nI hope you can see my point, and would appreciate if someone corrects me.\n"
                    },
                    {
                        "username": "omkarsk98",
                        "content": "I see a priority queue here. Is it correct?"
                    },
                    {
                        "username": "Ultron03",
                        "content": "How it will correct ans for 10,10,5,3 and n=3"
                    },
                    {
                        "username": "aitachii",
                        "content": "You should try these testcases first:\n\n    3\n    [10,10,5,3]\n\n    4\n    [8, 1, 4, 8]\n\n    2\n    [31,87,85,44,47,25]\n\nHint: The 2nd one can be done in O(n) time, O(1) space."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "add this also \\n```\\n12\\n[11,89,16,32,70,67,35,35,31,24,41,29,6,53,78,83]\\n```"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "wow very clear description\\nnot like yesterday\\n"
                    },
                    {
                        "username": "fli033",
                        "content": "I originally though binary search... But I couldn\\'t figure out how to test if a target time can be met... RIP"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@moraalejandro94](/moraalejandro94) Lets consider an example  n=3 batteries=[10,10,4]   the answer here will be 4 and not the 8 but according to your concept \\n( 10+10+4=24>=3*8)   answer=8"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@moraalejandro94](/moraalejandro94) Thanks! That\\'s a great hint."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "You need to run n computers for \\'mid\\' minutes -> n*mid \"energy units\". For each battery, it can contribute at most \\'mid\\' energy units, so you can check if the sum of what each battery can contribute is more than n*mid. "
                    },
                    {
                        "username": "pramod74",
                        "content": "34/52 testcases passed using this simple logic:\n\nreturn Math.floor(sum of elements in batteries array/n)\n\n:)"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@AssortedFantasy](/AssortedFantasy) Note that the problem can actually be done without Binary search at all like the hint suggest, its even easier of you use what I\\'ve said."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is almost the entirely solution.\\n\\nIts not obvious, but being able to swap batteries around means you can indeed almost make full use out of every battery, so yes simply floor dividing the total energy by n does give you the total time $t$.\\n\\nHowever the trick is that if you do this, some of the batteries has more energy than $t$. So you need to account for this as not usable power."
                    },
                    {
                        "username": "mohit7086",
                        "content": "yeah \\uD83D\\uDE02"
                    },
                    {
                        "username": "0xJaskeerat",
                        "content": "Did the same"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There was no power at home for a half day. I really need batteries!  The example 1 is quite interesting. By a smart  way of interchanging the batteries the maximal running time is  optimized. In most cases the battery is plugged in and until it has no power!"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "how the hell can u solve this in time limit???!!!!!!"
                    },
                    {
                        "username": "EntityPlantt",
                        "content": "hints & editorial: let us introduce ourselves"
                    }
                ]
            },
            {
                "id": 1988006,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "this problem sure did drain my batteries ... "
                    },
                    {
                        "username": "sushimatou",
                        "content": "one hour and a half, not even a beginning of an answer T-T"
                    },
                    {
                        "username": "yourick",
                        "content": "### More similar problems:\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/description/)\n[410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\n[668. Kth Smallest Number in Multiplication Table](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/description/)\n[719. Find K-th Smallest Pair Distance](https://leetcode.com/problems/find-k-th-smallest-pair-distance/description/)\n[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/)\n[1283. Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/description/)\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/description/)\n[1552. Magnetic Force Between Two Balls](https://leetcode.com/problems/magnetic-force-between-two-balls/description/)\n[1760. Minimum Limit of Balls in a Bag](https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/description/)\n[1802. Maximum Value at a Given Index in a Bounded Array](https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/description/)\n[1870. Minimum Speed to Arrive on Time](https://leetcode.com/problems/minimum-speed-to-arrive-on-time/description/)\n[1898. Maximum Number of Removable Characters](https://leetcode.com/problems/maximum-number-of-removable-characters/description/)\n[2064. Minimized Maximum of Products Distributed to Any Store](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/description/)\n[2071. Maximum Number of Tasks You Can Assign](https://leetcode.com/problems/maximum-number-of-tasks-you-can-assign/description/)\n[2141. Maximum Running Time of N Computers](https://leetcode.com/problems/maximum-running-time-of-n-computers/)\n[2187. Minimum Time to Complete Trips](https://leetcode.com/problems/minimum-time-to-complete-trips/description/)\n[2226. Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/description/)\n[2517. Maximum Tastiness of Candy Basket](https://leetcode.com/problems/maximum-tastiness-of-candy-basket/description/)\n[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/description/)\n[2560. House Robber IV](https://leetcode.com/problems/house-robber-iv/description/)\n[2594. Minimum Time to Repair Cars](https://leetcode.com/problems/minimum-time-to-repair-cars/description/)\n[2616. Minimize the Maximum Difference of Pairs](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/description/)\n"
                    },
                    {
                        "username": "prototye",
                        "content": "[@bparanj](/bparanj) chat gpt\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Here are 10 distinct problems that use similar underlying concepts:\\n\\n1. [Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts](https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/): This problem also involves sorting and finding maximum possible values after cuts, which is similar to our original problem of distributing charge among computers.\\n\\n2. [Task Scheduler](https://leetcode.com/problems/task-scheduler/): The task scheduling problem also uses a greedy approach to fit tasks into a schedule in a way that minimizes idle time.\\n\\n3. [Boats to Save People](https://leetcode.com/problems/boats-to-save-people/): This problem involves figuring out the minimum number of boats required to save people, a concept akin to determining the maximum running time of computers.\\n\\n4. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/): This problem also involves maximizing a certain parameter (the sum in this case) over a given set of integers.\\n\\n5. [Jump Game II](https://leetcode.com/problems/jump-game-ii/): This problem also involves maximizing a certain parameter (the number of jumps in this case) and uses a greedy algorithm approach.\\n\\n6. [Container With Most Water](https://leetcode.com/problems/container-with-most-water/): The strategy used in this problem, where we try to maximize the area of water the container can hold, is somewhat similar to our original problem where we tried to maximize the runtime.\\n\\n7. [Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/): This problem asks to divide an array into segments to minimize the maximum sum among them, which can be solved using a binary search in the same vein as the original problem.\\n\\n8. [Gas Station](https://leetcode.com/problems/gas-station/): The greedy approach used in this problem to find the starting gas station is similar to the strategy used in the original problem.\\n\\n9. [Queue Reconstruction by Height](https://leetcode.com/problems/queue-reconstruction-by-height/): The approach of sorting and then placing elements based on some condition is similar to the original problem.\\n\\n10. [Largest Number](https://leetcode.com/problems/largest-number/): The problem involves sorting and arranging elements in a certain way to maximize a value, which is a similar strategy as the original problem. \\n"
                    },
                    {
                        "username": "metaphysicalist",
                        "content": "The week of binary search?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "use biggest batteries first. All the batteries left after are your extra hours - just spread it across evenly (for ex, if u have two batteries left 2 and 3 hours it is the same as if u had 5 batteries 1 hour each)"
                    },
                    {
                        "username": "timofeev_evg",
                        "content": "[@charonme](/charonme) nothing to divide here. [100,1] + 2 extra, answer is 3"
                    },
                    {
                        "username": "charonme",
                        "content": "[@c4tdog](/c4tdog) a battery can\\'t be divided, try to apply your algo to n=2, batteries=[100,1,1,1] testcase"
                    },
                    {
                        "username": "Karthik949",
                        "content": "I went with same logic using Heaps "
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@charonme](/charonme) last one could be divided between two"
                    },
                    {
                        "username": "charonme",
                        "content": "this approach already doesn\\'t work with example 1. You\\'d use the two 3h batteries and will be left with one 3h battery for 2 computers"
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@c4tdog](/c4tdog)  okay sir !"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@omkarsk98](/omkarsk98) I used  maxHeap immediately I saw the question but hit TLE pretty fast"
                    },
                    {
                        "username": "hero080",
                        "content": "[@anuron_das](/anuron_das) \\nA much better way:\\n`[10, 10, 3, 5]` and `n = 3` is the same as `[3, 5]` and `n = 1`, we have total power of 8 so we can run 8 minutes.\\nThis also validates our point: `10 > 8` therefore these \"high power\" batteries will never be used up.\\n\\nSee the details:\\nhttps://leetcode.com/problems/maximum-running-time-of-n-computers/solutions/3822290/beat-100-o-m-nlogn-most-intuitive-solution-no-bs-no-heap/"
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@Ultron03](/Ultron03) since 5 in much less than 10, all last 3 hours goes to it, and the answer is 8. in case 10 10 10, u could split 3 among all computers and the answer would be 11"
                    },
                    {
                        "username": "anuron_das",
                        "content": "What you are saying is correct, but is very counterintuitive for me to understand. \n\nWhen we have 2 batteries of `3-hr` and `2-hr` power, we can attach these batteries to at most 2 computers at a time right? But when I am equating this to the scenario where I have 5 batteries of `1-hr` power, then I am claiming that I can attach these 2 batteries to at most 5 computers at a time. Isn't that incorrect?\n\nAlso, if it really is the case then if we start off by using the batteries with least power first, then also this approach should work. But interestingly it does not. \n\nTake the test case `[10,10,3,5]` with `n=3`. If I use the lest powered batteries first then I will attach the `3-hr`, `5-hr` and `10-hr` battery first. Now I have 1 `10-hr` battery left, which is same as having 10 `1-hr` batteries (just play along with me, even though this is a false argument). I will attach 6 `1-hr` batteries to the `1st` computer (one running on the `3-hr` battery), and the remaining 4 `1-hr` batteries to the `2nd` computer (one currently running on a `5-hr` battery).\n\nSo now the `1st` one runs for `9-hrs`, `2nd` one runs for `9-hrs` and the `3rd` one runs for `10-hrs`. So the answer we get is `9-hrs` max. Wrong answer obviously.\n\nI hope you can see my point, and would appreciate if someone corrects me.\n"
                    },
                    {
                        "username": "omkarsk98",
                        "content": "I see a priority queue here. Is it correct?"
                    },
                    {
                        "username": "Ultron03",
                        "content": "How it will correct ans for 10,10,5,3 and n=3"
                    },
                    {
                        "username": "aitachii",
                        "content": "You should try these testcases first:\n\n    3\n    [10,10,5,3]\n\n    4\n    [8, 1, 4, 8]\n\n    2\n    [31,87,85,44,47,25]\n\nHint: The 2nd one can be done in O(n) time, O(1) space."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "add this also \\n```\\n12\\n[11,89,16,32,70,67,35,35,31,24,41,29,6,53,78,83]\\n```"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "wow very clear description\\nnot like yesterday\\n"
                    },
                    {
                        "username": "fli033",
                        "content": "I originally though binary search... But I couldn\\'t figure out how to test if a target time can be met... RIP"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@moraalejandro94](/moraalejandro94) Lets consider an example  n=3 batteries=[10,10,4]   the answer here will be 4 and not the 8 but according to your concept \\n( 10+10+4=24>=3*8)   answer=8"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@moraalejandro94](/moraalejandro94) Thanks! That\\'s a great hint."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "You need to run n computers for \\'mid\\' minutes -> n*mid \"energy units\". For each battery, it can contribute at most \\'mid\\' energy units, so you can check if the sum of what each battery can contribute is more than n*mid. "
                    },
                    {
                        "username": "pramod74",
                        "content": "34/52 testcases passed using this simple logic:\n\nreturn Math.floor(sum of elements in batteries array/n)\n\n:)"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@AssortedFantasy](/AssortedFantasy) Note that the problem can actually be done without Binary search at all like the hint suggest, its even easier of you use what I\\'ve said."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is almost the entirely solution.\\n\\nIts not obvious, but being able to swap batteries around means you can indeed almost make full use out of every battery, so yes simply floor dividing the total energy by n does give you the total time $t$.\\n\\nHowever the trick is that if you do this, some of the batteries has more energy than $t$. So you need to account for this as not usable power."
                    },
                    {
                        "username": "mohit7086",
                        "content": "yeah \\uD83D\\uDE02"
                    },
                    {
                        "username": "0xJaskeerat",
                        "content": "Did the same"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There was no power at home for a half day. I really need batteries!  The example 1 is quite interesting. By a smart  way of interchanging the batteries the maximal running time is  optimized. In most cases the battery is plugged in and until it has no power!"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "how the hell can u solve this in time limit???!!!!!!"
                    },
                    {
                        "username": "EntityPlantt",
                        "content": "hints & editorial: let us introduce ourselves"
                    }
                ]
            },
            {
                "id": 1988042,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "this problem sure did drain my batteries ... "
                    },
                    {
                        "username": "sushimatou",
                        "content": "one hour and a half, not even a beginning of an answer T-T"
                    },
                    {
                        "username": "yourick",
                        "content": "### More similar problems:\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/description/)\n[410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\n[668. Kth Smallest Number in Multiplication Table](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/description/)\n[719. Find K-th Smallest Pair Distance](https://leetcode.com/problems/find-k-th-smallest-pair-distance/description/)\n[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/)\n[1283. Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/description/)\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/description/)\n[1552. Magnetic Force Between Two Balls](https://leetcode.com/problems/magnetic-force-between-two-balls/description/)\n[1760. Minimum Limit of Balls in a Bag](https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/description/)\n[1802. Maximum Value at a Given Index in a Bounded Array](https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/description/)\n[1870. Minimum Speed to Arrive on Time](https://leetcode.com/problems/minimum-speed-to-arrive-on-time/description/)\n[1898. Maximum Number of Removable Characters](https://leetcode.com/problems/maximum-number-of-removable-characters/description/)\n[2064. Minimized Maximum of Products Distributed to Any Store](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/description/)\n[2071. Maximum Number of Tasks You Can Assign](https://leetcode.com/problems/maximum-number-of-tasks-you-can-assign/description/)\n[2141. Maximum Running Time of N Computers](https://leetcode.com/problems/maximum-running-time-of-n-computers/)\n[2187. Minimum Time to Complete Trips](https://leetcode.com/problems/minimum-time-to-complete-trips/description/)\n[2226. Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/description/)\n[2517. Maximum Tastiness of Candy Basket](https://leetcode.com/problems/maximum-tastiness-of-candy-basket/description/)\n[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/description/)\n[2560. House Robber IV](https://leetcode.com/problems/house-robber-iv/description/)\n[2594. Minimum Time to Repair Cars](https://leetcode.com/problems/minimum-time-to-repair-cars/description/)\n[2616. Minimize the Maximum Difference of Pairs](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/description/)\n"
                    },
                    {
                        "username": "prototye",
                        "content": "[@bparanj](/bparanj) chat gpt\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Here are 10 distinct problems that use similar underlying concepts:\\n\\n1. [Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts](https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/): This problem also involves sorting and finding maximum possible values after cuts, which is similar to our original problem of distributing charge among computers.\\n\\n2. [Task Scheduler](https://leetcode.com/problems/task-scheduler/): The task scheduling problem also uses a greedy approach to fit tasks into a schedule in a way that minimizes idle time.\\n\\n3. [Boats to Save People](https://leetcode.com/problems/boats-to-save-people/): This problem involves figuring out the minimum number of boats required to save people, a concept akin to determining the maximum running time of computers.\\n\\n4. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/): This problem also involves maximizing a certain parameter (the sum in this case) over a given set of integers.\\n\\n5. [Jump Game II](https://leetcode.com/problems/jump-game-ii/): This problem also involves maximizing a certain parameter (the number of jumps in this case) and uses a greedy algorithm approach.\\n\\n6. [Container With Most Water](https://leetcode.com/problems/container-with-most-water/): The strategy used in this problem, where we try to maximize the area of water the container can hold, is somewhat similar to our original problem where we tried to maximize the runtime.\\n\\n7. [Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/): This problem asks to divide an array into segments to minimize the maximum sum among them, which can be solved using a binary search in the same vein as the original problem.\\n\\n8. [Gas Station](https://leetcode.com/problems/gas-station/): The greedy approach used in this problem to find the starting gas station is similar to the strategy used in the original problem.\\n\\n9. [Queue Reconstruction by Height](https://leetcode.com/problems/queue-reconstruction-by-height/): The approach of sorting and then placing elements based on some condition is similar to the original problem.\\n\\n10. [Largest Number](https://leetcode.com/problems/largest-number/): The problem involves sorting and arranging elements in a certain way to maximize a value, which is a similar strategy as the original problem. \\n"
                    },
                    {
                        "username": "metaphysicalist",
                        "content": "The week of binary search?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "use biggest batteries first. All the batteries left after are your extra hours - just spread it across evenly (for ex, if u have two batteries left 2 and 3 hours it is the same as if u had 5 batteries 1 hour each)"
                    },
                    {
                        "username": "timofeev_evg",
                        "content": "[@charonme](/charonme) nothing to divide here. [100,1] + 2 extra, answer is 3"
                    },
                    {
                        "username": "charonme",
                        "content": "[@c4tdog](/c4tdog) a battery can\\'t be divided, try to apply your algo to n=2, batteries=[100,1,1,1] testcase"
                    },
                    {
                        "username": "Karthik949",
                        "content": "I went with same logic using Heaps "
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@charonme](/charonme) last one could be divided between two"
                    },
                    {
                        "username": "charonme",
                        "content": "this approach already doesn\\'t work with example 1. You\\'d use the two 3h batteries and will be left with one 3h battery for 2 computers"
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@c4tdog](/c4tdog)  okay sir !"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@omkarsk98](/omkarsk98) I used  maxHeap immediately I saw the question but hit TLE pretty fast"
                    },
                    {
                        "username": "hero080",
                        "content": "[@anuron_das](/anuron_das) \\nA much better way:\\n`[10, 10, 3, 5]` and `n = 3` is the same as `[3, 5]` and `n = 1`, we have total power of 8 so we can run 8 minutes.\\nThis also validates our point: `10 > 8` therefore these \"high power\" batteries will never be used up.\\n\\nSee the details:\\nhttps://leetcode.com/problems/maximum-running-time-of-n-computers/solutions/3822290/beat-100-o-m-nlogn-most-intuitive-solution-no-bs-no-heap/"
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@Ultron03](/Ultron03) since 5 in much less than 10, all last 3 hours goes to it, and the answer is 8. in case 10 10 10, u could split 3 among all computers and the answer would be 11"
                    },
                    {
                        "username": "anuron_das",
                        "content": "What you are saying is correct, but is very counterintuitive for me to understand. \n\nWhen we have 2 batteries of `3-hr` and `2-hr` power, we can attach these batteries to at most 2 computers at a time right? But when I am equating this to the scenario where I have 5 batteries of `1-hr` power, then I am claiming that I can attach these 2 batteries to at most 5 computers at a time. Isn't that incorrect?\n\nAlso, if it really is the case then if we start off by using the batteries with least power first, then also this approach should work. But interestingly it does not. \n\nTake the test case `[10,10,3,5]` with `n=3`. If I use the lest powered batteries first then I will attach the `3-hr`, `5-hr` and `10-hr` battery first. Now I have 1 `10-hr` battery left, which is same as having 10 `1-hr` batteries (just play along with me, even though this is a false argument). I will attach 6 `1-hr` batteries to the `1st` computer (one running on the `3-hr` battery), and the remaining 4 `1-hr` batteries to the `2nd` computer (one currently running on a `5-hr` battery).\n\nSo now the `1st` one runs for `9-hrs`, `2nd` one runs for `9-hrs` and the `3rd` one runs for `10-hrs`. So the answer we get is `9-hrs` max. Wrong answer obviously.\n\nI hope you can see my point, and would appreciate if someone corrects me.\n"
                    },
                    {
                        "username": "omkarsk98",
                        "content": "I see a priority queue here. Is it correct?"
                    },
                    {
                        "username": "Ultron03",
                        "content": "How it will correct ans for 10,10,5,3 and n=3"
                    },
                    {
                        "username": "aitachii",
                        "content": "You should try these testcases first:\n\n    3\n    [10,10,5,3]\n\n    4\n    [8, 1, 4, 8]\n\n    2\n    [31,87,85,44,47,25]\n\nHint: The 2nd one can be done in O(n) time, O(1) space."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "add this also \\n```\\n12\\n[11,89,16,32,70,67,35,35,31,24,41,29,6,53,78,83]\\n```"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "wow very clear description\\nnot like yesterday\\n"
                    },
                    {
                        "username": "fli033",
                        "content": "I originally though binary search... But I couldn\\'t figure out how to test if a target time can be met... RIP"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@moraalejandro94](/moraalejandro94) Lets consider an example  n=3 batteries=[10,10,4]   the answer here will be 4 and not the 8 but according to your concept \\n( 10+10+4=24>=3*8)   answer=8"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@moraalejandro94](/moraalejandro94) Thanks! That\\'s a great hint."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "You need to run n computers for \\'mid\\' minutes -> n*mid \"energy units\". For each battery, it can contribute at most \\'mid\\' energy units, so you can check if the sum of what each battery can contribute is more than n*mid. "
                    },
                    {
                        "username": "pramod74",
                        "content": "34/52 testcases passed using this simple logic:\n\nreturn Math.floor(sum of elements in batteries array/n)\n\n:)"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@AssortedFantasy](/AssortedFantasy) Note that the problem can actually be done without Binary search at all like the hint suggest, its even easier of you use what I\\'ve said."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is almost the entirely solution.\\n\\nIts not obvious, but being able to swap batteries around means you can indeed almost make full use out of every battery, so yes simply floor dividing the total energy by n does give you the total time $t$.\\n\\nHowever the trick is that if you do this, some of the batteries has more energy than $t$. So you need to account for this as not usable power."
                    },
                    {
                        "username": "mohit7086",
                        "content": "yeah \\uD83D\\uDE02"
                    },
                    {
                        "username": "0xJaskeerat",
                        "content": "Did the same"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There was no power at home for a half day. I really need batteries!  The example 1 is quite interesting. By a smart  way of interchanging the batteries the maximal running time is  optimized. In most cases the battery is plugged in and until it has no power!"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "how the hell can u solve this in time limit???!!!!!!"
                    },
                    {
                        "username": "EntityPlantt",
                        "content": "hints & editorial: let us introduce ourselves"
                    }
                ]
            },
            {
                "id": 1988043,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "this problem sure did drain my batteries ... "
                    },
                    {
                        "username": "sushimatou",
                        "content": "one hour and a half, not even a beginning of an answer T-T"
                    },
                    {
                        "username": "yourick",
                        "content": "### More similar problems:\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/description/)\n[410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\n[668. Kth Smallest Number in Multiplication Table](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/description/)\n[719. Find K-th Smallest Pair Distance](https://leetcode.com/problems/find-k-th-smallest-pair-distance/description/)\n[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/)\n[1283. Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/description/)\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/description/)\n[1552. Magnetic Force Between Two Balls](https://leetcode.com/problems/magnetic-force-between-two-balls/description/)\n[1760. Minimum Limit of Balls in a Bag](https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/description/)\n[1802. Maximum Value at a Given Index in a Bounded Array](https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/description/)\n[1870. Minimum Speed to Arrive on Time](https://leetcode.com/problems/minimum-speed-to-arrive-on-time/description/)\n[1898. Maximum Number of Removable Characters](https://leetcode.com/problems/maximum-number-of-removable-characters/description/)\n[2064. Minimized Maximum of Products Distributed to Any Store](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/description/)\n[2071. Maximum Number of Tasks You Can Assign](https://leetcode.com/problems/maximum-number-of-tasks-you-can-assign/description/)\n[2141. Maximum Running Time of N Computers](https://leetcode.com/problems/maximum-running-time-of-n-computers/)\n[2187. Minimum Time to Complete Trips](https://leetcode.com/problems/minimum-time-to-complete-trips/description/)\n[2226. Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/description/)\n[2517. Maximum Tastiness of Candy Basket](https://leetcode.com/problems/maximum-tastiness-of-candy-basket/description/)\n[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/description/)\n[2560. House Robber IV](https://leetcode.com/problems/house-robber-iv/description/)\n[2594. Minimum Time to Repair Cars](https://leetcode.com/problems/minimum-time-to-repair-cars/description/)\n[2616. Minimize the Maximum Difference of Pairs](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/description/)\n"
                    },
                    {
                        "username": "prototye",
                        "content": "[@bparanj](/bparanj) chat gpt\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Here are 10 distinct problems that use similar underlying concepts:\\n\\n1. [Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts](https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/): This problem also involves sorting and finding maximum possible values after cuts, which is similar to our original problem of distributing charge among computers.\\n\\n2. [Task Scheduler](https://leetcode.com/problems/task-scheduler/): The task scheduling problem also uses a greedy approach to fit tasks into a schedule in a way that minimizes idle time.\\n\\n3. [Boats to Save People](https://leetcode.com/problems/boats-to-save-people/): This problem involves figuring out the minimum number of boats required to save people, a concept akin to determining the maximum running time of computers.\\n\\n4. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/): This problem also involves maximizing a certain parameter (the sum in this case) over a given set of integers.\\n\\n5. [Jump Game II](https://leetcode.com/problems/jump-game-ii/): This problem also involves maximizing a certain parameter (the number of jumps in this case) and uses a greedy algorithm approach.\\n\\n6. [Container With Most Water](https://leetcode.com/problems/container-with-most-water/): The strategy used in this problem, where we try to maximize the area of water the container can hold, is somewhat similar to our original problem where we tried to maximize the runtime.\\n\\n7. [Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/): This problem asks to divide an array into segments to minimize the maximum sum among them, which can be solved using a binary search in the same vein as the original problem.\\n\\n8. [Gas Station](https://leetcode.com/problems/gas-station/): The greedy approach used in this problem to find the starting gas station is similar to the strategy used in the original problem.\\n\\n9. [Queue Reconstruction by Height](https://leetcode.com/problems/queue-reconstruction-by-height/): The approach of sorting and then placing elements based on some condition is similar to the original problem.\\n\\n10. [Largest Number](https://leetcode.com/problems/largest-number/): The problem involves sorting and arranging elements in a certain way to maximize a value, which is a similar strategy as the original problem. \\n"
                    },
                    {
                        "username": "metaphysicalist",
                        "content": "The week of binary search?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "use biggest batteries first. All the batteries left after are your extra hours - just spread it across evenly (for ex, if u have two batteries left 2 and 3 hours it is the same as if u had 5 batteries 1 hour each)"
                    },
                    {
                        "username": "timofeev_evg",
                        "content": "[@charonme](/charonme) nothing to divide here. [100,1] + 2 extra, answer is 3"
                    },
                    {
                        "username": "charonme",
                        "content": "[@c4tdog](/c4tdog) a battery can\\'t be divided, try to apply your algo to n=2, batteries=[100,1,1,1] testcase"
                    },
                    {
                        "username": "Karthik949",
                        "content": "I went with same logic using Heaps "
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@charonme](/charonme) last one could be divided between two"
                    },
                    {
                        "username": "charonme",
                        "content": "this approach already doesn\\'t work with example 1. You\\'d use the two 3h batteries and will be left with one 3h battery for 2 computers"
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@c4tdog](/c4tdog)  okay sir !"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@omkarsk98](/omkarsk98) I used  maxHeap immediately I saw the question but hit TLE pretty fast"
                    },
                    {
                        "username": "hero080",
                        "content": "[@anuron_das](/anuron_das) \\nA much better way:\\n`[10, 10, 3, 5]` and `n = 3` is the same as `[3, 5]` and `n = 1`, we have total power of 8 so we can run 8 minutes.\\nThis also validates our point: `10 > 8` therefore these \"high power\" batteries will never be used up.\\n\\nSee the details:\\nhttps://leetcode.com/problems/maximum-running-time-of-n-computers/solutions/3822290/beat-100-o-m-nlogn-most-intuitive-solution-no-bs-no-heap/"
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@Ultron03](/Ultron03) since 5 in much less than 10, all last 3 hours goes to it, and the answer is 8. in case 10 10 10, u could split 3 among all computers and the answer would be 11"
                    },
                    {
                        "username": "anuron_das",
                        "content": "What you are saying is correct, but is very counterintuitive for me to understand. \n\nWhen we have 2 batteries of `3-hr` and `2-hr` power, we can attach these batteries to at most 2 computers at a time right? But when I am equating this to the scenario where I have 5 batteries of `1-hr` power, then I am claiming that I can attach these 2 batteries to at most 5 computers at a time. Isn't that incorrect?\n\nAlso, if it really is the case then if we start off by using the batteries with least power first, then also this approach should work. But interestingly it does not. \n\nTake the test case `[10,10,3,5]` with `n=3`. If I use the lest powered batteries first then I will attach the `3-hr`, `5-hr` and `10-hr` battery first. Now I have 1 `10-hr` battery left, which is same as having 10 `1-hr` batteries (just play along with me, even though this is a false argument). I will attach 6 `1-hr` batteries to the `1st` computer (one running on the `3-hr` battery), and the remaining 4 `1-hr` batteries to the `2nd` computer (one currently running on a `5-hr` battery).\n\nSo now the `1st` one runs for `9-hrs`, `2nd` one runs for `9-hrs` and the `3rd` one runs for `10-hrs`. So the answer we get is `9-hrs` max. Wrong answer obviously.\n\nI hope you can see my point, and would appreciate if someone corrects me.\n"
                    },
                    {
                        "username": "omkarsk98",
                        "content": "I see a priority queue here. Is it correct?"
                    },
                    {
                        "username": "Ultron03",
                        "content": "How it will correct ans for 10,10,5,3 and n=3"
                    },
                    {
                        "username": "aitachii",
                        "content": "You should try these testcases first:\n\n    3\n    [10,10,5,3]\n\n    4\n    [8, 1, 4, 8]\n\n    2\n    [31,87,85,44,47,25]\n\nHint: The 2nd one can be done in O(n) time, O(1) space."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "add this also \\n```\\n12\\n[11,89,16,32,70,67,35,35,31,24,41,29,6,53,78,83]\\n```"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "wow very clear description\\nnot like yesterday\\n"
                    },
                    {
                        "username": "fli033",
                        "content": "I originally though binary search... But I couldn\\'t figure out how to test if a target time can be met... RIP"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@moraalejandro94](/moraalejandro94) Lets consider an example  n=3 batteries=[10,10,4]   the answer here will be 4 and not the 8 but according to your concept \\n( 10+10+4=24>=3*8)   answer=8"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@moraalejandro94](/moraalejandro94) Thanks! That\\'s a great hint."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "You need to run n computers for \\'mid\\' minutes -> n*mid \"energy units\". For each battery, it can contribute at most \\'mid\\' energy units, so you can check if the sum of what each battery can contribute is more than n*mid. "
                    },
                    {
                        "username": "pramod74",
                        "content": "34/52 testcases passed using this simple logic:\n\nreturn Math.floor(sum of elements in batteries array/n)\n\n:)"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@AssortedFantasy](/AssortedFantasy) Note that the problem can actually be done without Binary search at all like the hint suggest, its even easier of you use what I\\'ve said."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is almost the entirely solution.\\n\\nIts not obvious, but being able to swap batteries around means you can indeed almost make full use out of every battery, so yes simply floor dividing the total energy by n does give you the total time $t$.\\n\\nHowever the trick is that if you do this, some of the batteries has more energy than $t$. So you need to account for this as not usable power."
                    },
                    {
                        "username": "mohit7086",
                        "content": "yeah \\uD83D\\uDE02"
                    },
                    {
                        "username": "0xJaskeerat",
                        "content": "Did the same"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There was no power at home for a half day. I really need batteries!  The example 1 is quite interesting. By a smart  way of interchanging the batteries the maximal running time is  optimized. In most cases the battery is plugged in and until it has no power!"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "how the hell can u solve this in time limit???!!!!!!"
                    },
                    {
                        "username": "EntityPlantt",
                        "content": "hints & editorial: let us introduce ourselves"
                    }
                ]
            },
            {
                "id": 1988066,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "this problem sure did drain my batteries ... "
                    },
                    {
                        "username": "sushimatou",
                        "content": "one hour and a half, not even a beginning of an answer T-T"
                    },
                    {
                        "username": "yourick",
                        "content": "### More similar problems:\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/description/)\n[410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\n[668. Kth Smallest Number in Multiplication Table](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/description/)\n[719. Find K-th Smallest Pair Distance](https://leetcode.com/problems/find-k-th-smallest-pair-distance/description/)\n[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/)\n[1283. Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/description/)\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/description/)\n[1552. Magnetic Force Between Two Balls](https://leetcode.com/problems/magnetic-force-between-two-balls/description/)\n[1760. Minimum Limit of Balls in a Bag](https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/description/)\n[1802. Maximum Value at a Given Index in a Bounded Array](https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/description/)\n[1870. Minimum Speed to Arrive on Time](https://leetcode.com/problems/minimum-speed-to-arrive-on-time/description/)\n[1898. Maximum Number of Removable Characters](https://leetcode.com/problems/maximum-number-of-removable-characters/description/)\n[2064. Minimized Maximum of Products Distributed to Any Store](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/description/)\n[2071. Maximum Number of Tasks You Can Assign](https://leetcode.com/problems/maximum-number-of-tasks-you-can-assign/description/)\n[2141. Maximum Running Time of N Computers](https://leetcode.com/problems/maximum-running-time-of-n-computers/)\n[2187. Minimum Time to Complete Trips](https://leetcode.com/problems/minimum-time-to-complete-trips/description/)\n[2226. Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/description/)\n[2517. Maximum Tastiness of Candy Basket](https://leetcode.com/problems/maximum-tastiness-of-candy-basket/description/)\n[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/description/)\n[2560. House Robber IV](https://leetcode.com/problems/house-robber-iv/description/)\n[2594. Minimum Time to Repair Cars](https://leetcode.com/problems/minimum-time-to-repair-cars/description/)\n[2616. Minimize the Maximum Difference of Pairs](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/description/)\n"
                    },
                    {
                        "username": "prototye",
                        "content": "[@bparanj](/bparanj) chat gpt\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Here are 10 distinct problems that use similar underlying concepts:\\n\\n1. [Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts](https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/): This problem also involves sorting and finding maximum possible values after cuts, which is similar to our original problem of distributing charge among computers.\\n\\n2. [Task Scheduler](https://leetcode.com/problems/task-scheduler/): The task scheduling problem also uses a greedy approach to fit tasks into a schedule in a way that minimizes idle time.\\n\\n3. [Boats to Save People](https://leetcode.com/problems/boats-to-save-people/): This problem involves figuring out the minimum number of boats required to save people, a concept akin to determining the maximum running time of computers.\\n\\n4. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/): This problem also involves maximizing a certain parameter (the sum in this case) over a given set of integers.\\n\\n5. [Jump Game II](https://leetcode.com/problems/jump-game-ii/): This problem also involves maximizing a certain parameter (the number of jumps in this case) and uses a greedy algorithm approach.\\n\\n6. [Container With Most Water](https://leetcode.com/problems/container-with-most-water/): The strategy used in this problem, where we try to maximize the area of water the container can hold, is somewhat similar to our original problem where we tried to maximize the runtime.\\n\\n7. [Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/): This problem asks to divide an array into segments to minimize the maximum sum among them, which can be solved using a binary search in the same vein as the original problem.\\n\\n8. [Gas Station](https://leetcode.com/problems/gas-station/): The greedy approach used in this problem to find the starting gas station is similar to the strategy used in the original problem.\\n\\n9. [Queue Reconstruction by Height](https://leetcode.com/problems/queue-reconstruction-by-height/): The approach of sorting and then placing elements based on some condition is similar to the original problem.\\n\\n10. [Largest Number](https://leetcode.com/problems/largest-number/): The problem involves sorting and arranging elements in a certain way to maximize a value, which is a similar strategy as the original problem. \\n"
                    },
                    {
                        "username": "metaphysicalist",
                        "content": "The week of binary search?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "use biggest batteries first. All the batteries left after are your extra hours - just spread it across evenly (for ex, if u have two batteries left 2 and 3 hours it is the same as if u had 5 batteries 1 hour each)"
                    },
                    {
                        "username": "timofeev_evg",
                        "content": "[@charonme](/charonme) nothing to divide here. [100,1] + 2 extra, answer is 3"
                    },
                    {
                        "username": "charonme",
                        "content": "[@c4tdog](/c4tdog) a battery can\\'t be divided, try to apply your algo to n=2, batteries=[100,1,1,1] testcase"
                    },
                    {
                        "username": "Karthik949",
                        "content": "I went with same logic using Heaps "
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@charonme](/charonme) last one could be divided between two"
                    },
                    {
                        "username": "charonme",
                        "content": "this approach already doesn\\'t work with example 1. You\\'d use the two 3h batteries and will be left with one 3h battery for 2 computers"
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@c4tdog](/c4tdog)  okay sir !"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@omkarsk98](/omkarsk98) I used  maxHeap immediately I saw the question but hit TLE pretty fast"
                    },
                    {
                        "username": "hero080",
                        "content": "[@anuron_das](/anuron_das) \\nA much better way:\\n`[10, 10, 3, 5]` and `n = 3` is the same as `[3, 5]` and `n = 1`, we have total power of 8 so we can run 8 minutes.\\nThis also validates our point: `10 > 8` therefore these \"high power\" batteries will never be used up.\\n\\nSee the details:\\nhttps://leetcode.com/problems/maximum-running-time-of-n-computers/solutions/3822290/beat-100-o-m-nlogn-most-intuitive-solution-no-bs-no-heap/"
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@Ultron03](/Ultron03) since 5 in much less than 10, all last 3 hours goes to it, and the answer is 8. in case 10 10 10, u could split 3 among all computers and the answer would be 11"
                    },
                    {
                        "username": "anuron_das",
                        "content": "What you are saying is correct, but is very counterintuitive for me to understand. \n\nWhen we have 2 batteries of `3-hr` and `2-hr` power, we can attach these batteries to at most 2 computers at a time right? But when I am equating this to the scenario where I have 5 batteries of `1-hr` power, then I am claiming that I can attach these 2 batteries to at most 5 computers at a time. Isn't that incorrect?\n\nAlso, if it really is the case then if we start off by using the batteries with least power first, then also this approach should work. But interestingly it does not. \n\nTake the test case `[10,10,3,5]` with `n=3`. If I use the lest powered batteries first then I will attach the `3-hr`, `5-hr` and `10-hr` battery first. Now I have 1 `10-hr` battery left, which is same as having 10 `1-hr` batteries (just play along with me, even though this is a false argument). I will attach 6 `1-hr` batteries to the `1st` computer (one running on the `3-hr` battery), and the remaining 4 `1-hr` batteries to the `2nd` computer (one currently running on a `5-hr` battery).\n\nSo now the `1st` one runs for `9-hrs`, `2nd` one runs for `9-hrs` and the `3rd` one runs for `10-hrs`. So the answer we get is `9-hrs` max. Wrong answer obviously.\n\nI hope you can see my point, and would appreciate if someone corrects me.\n"
                    },
                    {
                        "username": "omkarsk98",
                        "content": "I see a priority queue here. Is it correct?"
                    },
                    {
                        "username": "Ultron03",
                        "content": "How it will correct ans for 10,10,5,3 and n=3"
                    },
                    {
                        "username": "aitachii",
                        "content": "You should try these testcases first:\n\n    3\n    [10,10,5,3]\n\n    4\n    [8, 1, 4, 8]\n\n    2\n    [31,87,85,44,47,25]\n\nHint: The 2nd one can be done in O(n) time, O(1) space."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "add this also \\n```\\n12\\n[11,89,16,32,70,67,35,35,31,24,41,29,6,53,78,83]\\n```"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "wow very clear description\\nnot like yesterday\\n"
                    },
                    {
                        "username": "fli033",
                        "content": "I originally though binary search... But I couldn\\'t figure out how to test if a target time can be met... RIP"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@moraalejandro94](/moraalejandro94) Lets consider an example  n=3 batteries=[10,10,4]   the answer here will be 4 and not the 8 but according to your concept \\n( 10+10+4=24>=3*8)   answer=8"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@moraalejandro94](/moraalejandro94) Thanks! That\\'s a great hint."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "You need to run n computers for \\'mid\\' minutes -> n*mid \"energy units\". For each battery, it can contribute at most \\'mid\\' energy units, so you can check if the sum of what each battery can contribute is more than n*mid. "
                    },
                    {
                        "username": "pramod74",
                        "content": "34/52 testcases passed using this simple logic:\n\nreturn Math.floor(sum of elements in batteries array/n)\n\n:)"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@AssortedFantasy](/AssortedFantasy) Note that the problem can actually be done without Binary search at all like the hint suggest, its even easier of you use what I\\'ve said."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is almost the entirely solution.\\n\\nIts not obvious, but being able to swap batteries around means you can indeed almost make full use out of every battery, so yes simply floor dividing the total energy by n does give you the total time $t$.\\n\\nHowever the trick is that if you do this, some of the batteries has more energy than $t$. So you need to account for this as not usable power."
                    },
                    {
                        "username": "mohit7086",
                        "content": "yeah \\uD83D\\uDE02"
                    },
                    {
                        "username": "0xJaskeerat",
                        "content": "Did the same"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There was no power at home for a half day. I really need batteries!  The example 1 is quite interesting. By a smart  way of interchanging the batteries the maximal running time is  optimized. In most cases the battery is plugged in and until it has no power!"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "how the hell can u solve this in time limit???!!!!!!"
                    },
                    {
                        "username": "EntityPlantt",
                        "content": "hints & editorial: let us introduce ourselves"
                    }
                ]
            },
            {
                "id": 1988196,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "this problem sure did drain my batteries ... "
                    },
                    {
                        "username": "sushimatou",
                        "content": "one hour and a half, not even a beginning of an answer T-T"
                    },
                    {
                        "username": "yourick",
                        "content": "### More similar problems:\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/description/)\n[410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\n[668. Kth Smallest Number in Multiplication Table](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/description/)\n[719. Find K-th Smallest Pair Distance](https://leetcode.com/problems/find-k-th-smallest-pair-distance/description/)\n[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/)\n[1283. Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/description/)\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/description/)\n[1552. Magnetic Force Between Two Balls](https://leetcode.com/problems/magnetic-force-between-two-balls/description/)\n[1760. Minimum Limit of Balls in a Bag](https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/description/)\n[1802. Maximum Value at a Given Index in a Bounded Array](https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/description/)\n[1870. Minimum Speed to Arrive on Time](https://leetcode.com/problems/minimum-speed-to-arrive-on-time/description/)\n[1898. Maximum Number of Removable Characters](https://leetcode.com/problems/maximum-number-of-removable-characters/description/)\n[2064. Minimized Maximum of Products Distributed to Any Store](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/description/)\n[2071. Maximum Number of Tasks You Can Assign](https://leetcode.com/problems/maximum-number-of-tasks-you-can-assign/description/)\n[2141. Maximum Running Time of N Computers](https://leetcode.com/problems/maximum-running-time-of-n-computers/)\n[2187. Minimum Time to Complete Trips](https://leetcode.com/problems/minimum-time-to-complete-trips/description/)\n[2226. Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/description/)\n[2517. Maximum Tastiness of Candy Basket](https://leetcode.com/problems/maximum-tastiness-of-candy-basket/description/)\n[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/description/)\n[2560. House Robber IV](https://leetcode.com/problems/house-robber-iv/description/)\n[2594. Minimum Time to Repair Cars](https://leetcode.com/problems/minimum-time-to-repair-cars/description/)\n[2616. Minimize the Maximum Difference of Pairs](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/description/)\n"
                    },
                    {
                        "username": "prototye",
                        "content": "[@bparanj](/bparanj) chat gpt\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Here are 10 distinct problems that use similar underlying concepts:\\n\\n1. [Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts](https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/): This problem also involves sorting and finding maximum possible values after cuts, which is similar to our original problem of distributing charge among computers.\\n\\n2. [Task Scheduler](https://leetcode.com/problems/task-scheduler/): The task scheduling problem also uses a greedy approach to fit tasks into a schedule in a way that minimizes idle time.\\n\\n3. [Boats to Save People](https://leetcode.com/problems/boats-to-save-people/): This problem involves figuring out the minimum number of boats required to save people, a concept akin to determining the maximum running time of computers.\\n\\n4. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/): This problem also involves maximizing a certain parameter (the sum in this case) over a given set of integers.\\n\\n5. [Jump Game II](https://leetcode.com/problems/jump-game-ii/): This problem also involves maximizing a certain parameter (the number of jumps in this case) and uses a greedy algorithm approach.\\n\\n6. [Container With Most Water](https://leetcode.com/problems/container-with-most-water/): The strategy used in this problem, where we try to maximize the area of water the container can hold, is somewhat similar to our original problem where we tried to maximize the runtime.\\n\\n7. [Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/): This problem asks to divide an array into segments to minimize the maximum sum among them, which can be solved using a binary search in the same vein as the original problem.\\n\\n8. [Gas Station](https://leetcode.com/problems/gas-station/): The greedy approach used in this problem to find the starting gas station is similar to the strategy used in the original problem.\\n\\n9. [Queue Reconstruction by Height](https://leetcode.com/problems/queue-reconstruction-by-height/): The approach of sorting and then placing elements based on some condition is similar to the original problem.\\n\\n10. [Largest Number](https://leetcode.com/problems/largest-number/): The problem involves sorting and arranging elements in a certain way to maximize a value, which is a similar strategy as the original problem. \\n"
                    },
                    {
                        "username": "metaphysicalist",
                        "content": "The week of binary search?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "use biggest batteries first. All the batteries left after are your extra hours - just spread it across evenly (for ex, if u have two batteries left 2 and 3 hours it is the same as if u had 5 batteries 1 hour each)"
                    },
                    {
                        "username": "timofeev_evg",
                        "content": "[@charonme](/charonme) nothing to divide here. [100,1] + 2 extra, answer is 3"
                    },
                    {
                        "username": "charonme",
                        "content": "[@c4tdog](/c4tdog) a battery can\\'t be divided, try to apply your algo to n=2, batteries=[100,1,1,1] testcase"
                    },
                    {
                        "username": "Karthik949",
                        "content": "I went with same logic using Heaps "
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@charonme](/charonme) last one could be divided between two"
                    },
                    {
                        "username": "charonme",
                        "content": "this approach already doesn\\'t work with example 1. You\\'d use the two 3h batteries and will be left with one 3h battery for 2 computers"
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@c4tdog](/c4tdog)  okay sir !"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@omkarsk98](/omkarsk98) I used  maxHeap immediately I saw the question but hit TLE pretty fast"
                    },
                    {
                        "username": "hero080",
                        "content": "[@anuron_das](/anuron_das) \\nA much better way:\\n`[10, 10, 3, 5]` and `n = 3` is the same as `[3, 5]` and `n = 1`, we have total power of 8 so we can run 8 minutes.\\nThis also validates our point: `10 > 8` therefore these \"high power\" batteries will never be used up.\\n\\nSee the details:\\nhttps://leetcode.com/problems/maximum-running-time-of-n-computers/solutions/3822290/beat-100-o-m-nlogn-most-intuitive-solution-no-bs-no-heap/"
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@Ultron03](/Ultron03) since 5 in much less than 10, all last 3 hours goes to it, and the answer is 8. in case 10 10 10, u could split 3 among all computers and the answer would be 11"
                    },
                    {
                        "username": "anuron_das",
                        "content": "What you are saying is correct, but is very counterintuitive for me to understand. \n\nWhen we have 2 batteries of `3-hr` and `2-hr` power, we can attach these batteries to at most 2 computers at a time right? But when I am equating this to the scenario where I have 5 batteries of `1-hr` power, then I am claiming that I can attach these 2 batteries to at most 5 computers at a time. Isn't that incorrect?\n\nAlso, if it really is the case then if we start off by using the batteries with least power first, then also this approach should work. But interestingly it does not. \n\nTake the test case `[10,10,3,5]` with `n=3`. If I use the lest powered batteries first then I will attach the `3-hr`, `5-hr` and `10-hr` battery first. Now I have 1 `10-hr` battery left, which is same as having 10 `1-hr` batteries (just play along with me, even though this is a false argument). I will attach 6 `1-hr` batteries to the `1st` computer (one running on the `3-hr` battery), and the remaining 4 `1-hr` batteries to the `2nd` computer (one currently running on a `5-hr` battery).\n\nSo now the `1st` one runs for `9-hrs`, `2nd` one runs for `9-hrs` and the `3rd` one runs for `10-hrs`. So the answer we get is `9-hrs` max. Wrong answer obviously.\n\nI hope you can see my point, and would appreciate if someone corrects me.\n"
                    },
                    {
                        "username": "omkarsk98",
                        "content": "I see a priority queue here. Is it correct?"
                    },
                    {
                        "username": "Ultron03",
                        "content": "How it will correct ans for 10,10,5,3 and n=3"
                    },
                    {
                        "username": "aitachii",
                        "content": "You should try these testcases first:\n\n    3\n    [10,10,5,3]\n\n    4\n    [8, 1, 4, 8]\n\n    2\n    [31,87,85,44,47,25]\n\nHint: The 2nd one can be done in O(n) time, O(1) space."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "add this also \\n```\\n12\\n[11,89,16,32,70,67,35,35,31,24,41,29,6,53,78,83]\\n```"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "wow very clear description\\nnot like yesterday\\n"
                    },
                    {
                        "username": "fli033",
                        "content": "I originally though binary search... But I couldn\\'t figure out how to test if a target time can be met... RIP"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@moraalejandro94](/moraalejandro94) Lets consider an example  n=3 batteries=[10,10,4]   the answer here will be 4 and not the 8 but according to your concept \\n( 10+10+4=24>=3*8)   answer=8"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@moraalejandro94](/moraalejandro94) Thanks! That\\'s a great hint."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "You need to run n computers for \\'mid\\' minutes -> n*mid \"energy units\". For each battery, it can contribute at most \\'mid\\' energy units, so you can check if the sum of what each battery can contribute is more than n*mid. "
                    },
                    {
                        "username": "pramod74",
                        "content": "34/52 testcases passed using this simple logic:\n\nreturn Math.floor(sum of elements in batteries array/n)\n\n:)"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@AssortedFantasy](/AssortedFantasy) Note that the problem can actually be done without Binary search at all like the hint suggest, its even easier of you use what I\\'ve said."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is almost the entirely solution.\\n\\nIts not obvious, but being able to swap batteries around means you can indeed almost make full use out of every battery, so yes simply floor dividing the total energy by n does give you the total time $t$.\\n\\nHowever the trick is that if you do this, some of the batteries has more energy than $t$. So you need to account for this as not usable power."
                    },
                    {
                        "username": "mohit7086",
                        "content": "yeah \\uD83D\\uDE02"
                    },
                    {
                        "username": "0xJaskeerat",
                        "content": "Did the same"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There was no power at home for a half day. I really need batteries!  The example 1 is quite interesting. By a smart  way of interchanging the batteries the maximal running time is  optimized. In most cases the battery is plugged in and until it has no power!"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "how the hell can u solve this in time limit???!!!!!!"
                    },
                    {
                        "username": "EntityPlantt",
                        "content": "hints & editorial: let us introduce ourselves"
                    }
                ]
            },
            {
                "id": 1988064,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "this problem sure did drain my batteries ... "
                    },
                    {
                        "username": "sushimatou",
                        "content": "one hour and a half, not even a beginning of an answer T-T"
                    },
                    {
                        "username": "yourick",
                        "content": "### More similar problems:\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/description/)\n[410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\n[668. Kth Smallest Number in Multiplication Table](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/description/)\n[719. Find K-th Smallest Pair Distance](https://leetcode.com/problems/find-k-th-smallest-pair-distance/description/)\n[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/)\n[1283. Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/description/)\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/description/)\n[1552. Magnetic Force Between Two Balls](https://leetcode.com/problems/magnetic-force-between-two-balls/description/)\n[1760. Minimum Limit of Balls in a Bag](https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/description/)\n[1802. Maximum Value at a Given Index in a Bounded Array](https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/description/)\n[1870. Minimum Speed to Arrive on Time](https://leetcode.com/problems/minimum-speed-to-arrive-on-time/description/)\n[1898. Maximum Number of Removable Characters](https://leetcode.com/problems/maximum-number-of-removable-characters/description/)\n[2064. Minimized Maximum of Products Distributed to Any Store](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/description/)\n[2071. Maximum Number of Tasks You Can Assign](https://leetcode.com/problems/maximum-number-of-tasks-you-can-assign/description/)\n[2141. Maximum Running Time of N Computers](https://leetcode.com/problems/maximum-running-time-of-n-computers/)\n[2187. Minimum Time to Complete Trips](https://leetcode.com/problems/minimum-time-to-complete-trips/description/)\n[2226. Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/description/)\n[2517. Maximum Tastiness of Candy Basket](https://leetcode.com/problems/maximum-tastiness-of-candy-basket/description/)\n[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/description/)\n[2560. House Robber IV](https://leetcode.com/problems/house-robber-iv/description/)\n[2594. Minimum Time to Repair Cars](https://leetcode.com/problems/minimum-time-to-repair-cars/description/)\n[2616. Minimize the Maximum Difference of Pairs](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/description/)\n"
                    },
                    {
                        "username": "prototye",
                        "content": "[@bparanj](/bparanj) chat gpt\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Here are 10 distinct problems that use similar underlying concepts:\\n\\n1. [Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts](https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/): This problem also involves sorting and finding maximum possible values after cuts, which is similar to our original problem of distributing charge among computers.\\n\\n2. [Task Scheduler](https://leetcode.com/problems/task-scheduler/): The task scheduling problem also uses a greedy approach to fit tasks into a schedule in a way that minimizes idle time.\\n\\n3. [Boats to Save People](https://leetcode.com/problems/boats-to-save-people/): This problem involves figuring out the minimum number of boats required to save people, a concept akin to determining the maximum running time of computers.\\n\\n4. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/): This problem also involves maximizing a certain parameter (the sum in this case) over a given set of integers.\\n\\n5. [Jump Game II](https://leetcode.com/problems/jump-game-ii/): This problem also involves maximizing a certain parameter (the number of jumps in this case) and uses a greedy algorithm approach.\\n\\n6. [Container With Most Water](https://leetcode.com/problems/container-with-most-water/): The strategy used in this problem, where we try to maximize the area of water the container can hold, is somewhat similar to our original problem where we tried to maximize the runtime.\\n\\n7. [Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/): This problem asks to divide an array into segments to minimize the maximum sum among them, which can be solved using a binary search in the same vein as the original problem.\\n\\n8. [Gas Station](https://leetcode.com/problems/gas-station/): The greedy approach used in this problem to find the starting gas station is similar to the strategy used in the original problem.\\n\\n9. [Queue Reconstruction by Height](https://leetcode.com/problems/queue-reconstruction-by-height/): The approach of sorting and then placing elements based on some condition is similar to the original problem.\\n\\n10. [Largest Number](https://leetcode.com/problems/largest-number/): The problem involves sorting and arranging elements in a certain way to maximize a value, which is a similar strategy as the original problem. \\n"
                    },
                    {
                        "username": "metaphysicalist",
                        "content": "The week of binary search?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "use biggest batteries first. All the batteries left after are your extra hours - just spread it across evenly (for ex, if u have two batteries left 2 and 3 hours it is the same as if u had 5 batteries 1 hour each)"
                    },
                    {
                        "username": "timofeev_evg",
                        "content": "[@charonme](/charonme) nothing to divide here. [100,1] + 2 extra, answer is 3"
                    },
                    {
                        "username": "charonme",
                        "content": "[@c4tdog](/c4tdog) a battery can\\'t be divided, try to apply your algo to n=2, batteries=[100,1,1,1] testcase"
                    },
                    {
                        "username": "Karthik949",
                        "content": "I went with same logic using Heaps "
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@charonme](/charonme) last one could be divided between two"
                    },
                    {
                        "username": "charonme",
                        "content": "this approach already doesn\\'t work with example 1. You\\'d use the two 3h batteries and will be left with one 3h battery for 2 computers"
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@c4tdog](/c4tdog)  okay sir !"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@omkarsk98](/omkarsk98) I used  maxHeap immediately I saw the question but hit TLE pretty fast"
                    },
                    {
                        "username": "hero080",
                        "content": "[@anuron_das](/anuron_das) \\nA much better way:\\n`[10, 10, 3, 5]` and `n = 3` is the same as `[3, 5]` and `n = 1`, we have total power of 8 so we can run 8 minutes.\\nThis also validates our point: `10 > 8` therefore these \"high power\" batteries will never be used up.\\n\\nSee the details:\\nhttps://leetcode.com/problems/maximum-running-time-of-n-computers/solutions/3822290/beat-100-o-m-nlogn-most-intuitive-solution-no-bs-no-heap/"
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@Ultron03](/Ultron03) since 5 in much less than 10, all last 3 hours goes to it, and the answer is 8. in case 10 10 10, u could split 3 among all computers and the answer would be 11"
                    },
                    {
                        "username": "anuron_das",
                        "content": "What you are saying is correct, but is very counterintuitive for me to understand. \n\nWhen we have 2 batteries of `3-hr` and `2-hr` power, we can attach these batteries to at most 2 computers at a time right? But when I am equating this to the scenario where I have 5 batteries of `1-hr` power, then I am claiming that I can attach these 2 batteries to at most 5 computers at a time. Isn't that incorrect?\n\nAlso, if it really is the case then if we start off by using the batteries with least power first, then also this approach should work. But interestingly it does not. \n\nTake the test case `[10,10,3,5]` with `n=3`. If I use the lest powered batteries first then I will attach the `3-hr`, `5-hr` and `10-hr` battery first. Now I have 1 `10-hr` battery left, which is same as having 10 `1-hr` batteries (just play along with me, even though this is a false argument). I will attach 6 `1-hr` batteries to the `1st` computer (one running on the `3-hr` battery), and the remaining 4 `1-hr` batteries to the `2nd` computer (one currently running on a `5-hr` battery).\n\nSo now the `1st` one runs for `9-hrs`, `2nd` one runs for `9-hrs` and the `3rd` one runs for `10-hrs`. So the answer we get is `9-hrs` max. Wrong answer obviously.\n\nI hope you can see my point, and would appreciate if someone corrects me.\n"
                    },
                    {
                        "username": "omkarsk98",
                        "content": "I see a priority queue here. Is it correct?"
                    },
                    {
                        "username": "Ultron03",
                        "content": "How it will correct ans for 10,10,5,3 and n=3"
                    },
                    {
                        "username": "aitachii",
                        "content": "You should try these testcases first:\n\n    3\n    [10,10,5,3]\n\n    4\n    [8, 1, 4, 8]\n\n    2\n    [31,87,85,44,47,25]\n\nHint: The 2nd one can be done in O(n) time, O(1) space."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "add this also \\n```\\n12\\n[11,89,16,32,70,67,35,35,31,24,41,29,6,53,78,83]\\n```"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "wow very clear description\\nnot like yesterday\\n"
                    },
                    {
                        "username": "fli033",
                        "content": "I originally though binary search... But I couldn\\'t figure out how to test if a target time can be met... RIP"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@moraalejandro94](/moraalejandro94) Lets consider an example  n=3 batteries=[10,10,4]   the answer here will be 4 and not the 8 but according to your concept \\n( 10+10+4=24>=3*8)   answer=8"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@moraalejandro94](/moraalejandro94) Thanks! That\\'s a great hint."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "You need to run n computers for \\'mid\\' minutes -> n*mid \"energy units\". For each battery, it can contribute at most \\'mid\\' energy units, so you can check if the sum of what each battery can contribute is more than n*mid. "
                    },
                    {
                        "username": "pramod74",
                        "content": "34/52 testcases passed using this simple logic:\n\nreturn Math.floor(sum of elements in batteries array/n)\n\n:)"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@AssortedFantasy](/AssortedFantasy) Note that the problem can actually be done without Binary search at all like the hint suggest, its even easier of you use what I\\'ve said."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is almost the entirely solution.\\n\\nIts not obvious, but being able to swap batteries around means you can indeed almost make full use out of every battery, so yes simply floor dividing the total energy by n does give you the total time $t$.\\n\\nHowever the trick is that if you do this, some of the batteries has more energy than $t$. So you need to account for this as not usable power."
                    },
                    {
                        "username": "mohit7086",
                        "content": "yeah \\uD83D\\uDE02"
                    },
                    {
                        "username": "0xJaskeerat",
                        "content": "Did the same"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There was no power at home for a half day. I really need batteries!  The example 1 is quite interesting. By a smart  way of interchanging the batteries the maximal running time is  optimized. In most cases the battery is plugged in and until it has no power!"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "how the hell can u solve this in time limit???!!!!!!"
                    },
                    {
                        "username": "EntityPlantt",
                        "content": "hints & editorial: let us introduce ourselves"
                    }
                ]
            },
            {
                "id": 1988867,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "this problem sure did drain my batteries ... "
                    },
                    {
                        "username": "sushimatou",
                        "content": "one hour and a half, not even a beginning of an answer T-T"
                    },
                    {
                        "username": "yourick",
                        "content": "### More similar problems:\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/description/)\n[410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\n[668. Kth Smallest Number in Multiplication Table](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/description/)\n[719. Find K-th Smallest Pair Distance](https://leetcode.com/problems/find-k-th-smallest-pair-distance/description/)\n[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/)\n[1283. Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/description/)\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/description/)\n[1552. Magnetic Force Between Two Balls](https://leetcode.com/problems/magnetic-force-between-two-balls/description/)\n[1760. Minimum Limit of Balls in a Bag](https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/description/)\n[1802. Maximum Value at a Given Index in a Bounded Array](https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/description/)\n[1870. Minimum Speed to Arrive on Time](https://leetcode.com/problems/minimum-speed-to-arrive-on-time/description/)\n[1898. Maximum Number of Removable Characters](https://leetcode.com/problems/maximum-number-of-removable-characters/description/)\n[2064. Minimized Maximum of Products Distributed to Any Store](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/description/)\n[2071. Maximum Number of Tasks You Can Assign](https://leetcode.com/problems/maximum-number-of-tasks-you-can-assign/description/)\n[2141. Maximum Running Time of N Computers](https://leetcode.com/problems/maximum-running-time-of-n-computers/)\n[2187. Minimum Time to Complete Trips](https://leetcode.com/problems/minimum-time-to-complete-trips/description/)\n[2226. Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/description/)\n[2517. Maximum Tastiness of Candy Basket](https://leetcode.com/problems/maximum-tastiness-of-candy-basket/description/)\n[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/description/)\n[2560. House Robber IV](https://leetcode.com/problems/house-robber-iv/description/)\n[2594. Minimum Time to Repair Cars](https://leetcode.com/problems/minimum-time-to-repair-cars/description/)\n[2616. Minimize the Maximum Difference of Pairs](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/description/)\n"
                    },
                    {
                        "username": "prototye",
                        "content": "[@bparanj](/bparanj) chat gpt\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Here are 10 distinct problems that use similar underlying concepts:\\n\\n1. [Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts](https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/): This problem also involves sorting and finding maximum possible values after cuts, which is similar to our original problem of distributing charge among computers.\\n\\n2. [Task Scheduler](https://leetcode.com/problems/task-scheduler/): The task scheduling problem also uses a greedy approach to fit tasks into a schedule in a way that minimizes idle time.\\n\\n3. [Boats to Save People](https://leetcode.com/problems/boats-to-save-people/): This problem involves figuring out the minimum number of boats required to save people, a concept akin to determining the maximum running time of computers.\\n\\n4. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/): This problem also involves maximizing a certain parameter (the sum in this case) over a given set of integers.\\n\\n5. [Jump Game II](https://leetcode.com/problems/jump-game-ii/): This problem also involves maximizing a certain parameter (the number of jumps in this case) and uses a greedy algorithm approach.\\n\\n6. [Container With Most Water](https://leetcode.com/problems/container-with-most-water/): The strategy used in this problem, where we try to maximize the area of water the container can hold, is somewhat similar to our original problem where we tried to maximize the runtime.\\n\\n7. [Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/): This problem asks to divide an array into segments to minimize the maximum sum among them, which can be solved using a binary search in the same vein as the original problem.\\n\\n8. [Gas Station](https://leetcode.com/problems/gas-station/): The greedy approach used in this problem to find the starting gas station is similar to the strategy used in the original problem.\\n\\n9. [Queue Reconstruction by Height](https://leetcode.com/problems/queue-reconstruction-by-height/): The approach of sorting and then placing elements based on some condition is similar to the original problem.\\n\\n10. [Largest Number](https://leetcode.com/problems/largest-number/): The problem involves sorting and arranging elements in a certain way to maximize a value, which is a similar strategy as the original problem. \\n"
                    },
                    {
                        "username": "metaphysicalist",
                        "content": "The week of binary search?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "use biggest batteries first. All the batteries left after are your extra hours - just spread it across evenly (for ex, if u have two batteries left 2 and 3 hours it is the same as if u had 5 batteries 1 hour each)"
                    },
                    {
                        "username": "timofeev_evg",
                        "content": "[@charonme](/charonme) nothing to divide here. [100,1] + 2 extra, answer is 3"
                    },
                    {
                        "username": "charonme",
                        "content": "[@c4tdog](/c4tdog) a battery can\\'t be divided, try to apply your algo to n=2, batteries=[100,1,1,1] testcase"
                    },
                    {
                        "username": "Karthik949",
                        "content": "I went with same logic using Heaps "
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@charonme](/charonme) last one could be divided between two"
                    },
                    {
                        "username": "charonme",
                        "content": "this approach already doesn\\'t work with example 1. You\\'d use the two 3h batteries and will be left with one 3h battery for 2 computers"
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@c4tdog](/c4tdog)  okay sir !"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@omkarsk98](/omkarsk98) I used  maxHeap immediately I saw the question but hit TLE pretty fast"
                    },
                    {
                        "username": "hero080",
                        "content": "[@anuron_das](/anuron_das) \\nA much better way:\\n`[10, 10, 3, 5]` and `n = 3` is the same as `[3, 5]` and `n = 1`, we have total power of 8 so we can run 8 minutes.\\nThis also validates our point: `10 > 8` therefore these \"high power\" batteries will never be used up.\\n\\nSee the details:\\nhttps://leetcode.com/problems/maximum-running-time-of-n-computers/solutions/3822290/beat-100-o-m-nlogn-most-intuitive-solution-no-bs-no-heap/"
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@Ultron03](/Ultron03) since 5 in much less than 10, all last 3 hours goes to it, and the answer is 8. in case 10 10 10, u could split 3 among all computers and the answer would be 11"
                    },
                    {
                        "username": "anuron_das",
                        "content": "What you are saying is correct, but is very counterintuitive for me to understand. \n\nWhen we have 2 batteries of `3-hr` and `2-hr` power, we can attach these batteries to at most 2 computers at a time right? But when I am equating this to the scenario where I have 5 batteries of `1-hr` power, then I am claiming that I can attach these 2 batteries to at most 5 computers at a time. Isn't that incorrect?\n\nAlso, if it really is the case then if we start off by using the batteries with least power first, then also this approach should work. But interestingly it does not. \n\nTake the test case `[10,10,3,5]` with `n=3`. If I use the lest powered batteries first then I will attach the `3-hr`, `5-hr` and `10-hr` battery first. Now I have 1 `10-hr` battery left, which is same as having 10 `1-hr` batteries (just play along with me, even though this is a false argument). I will attach 6 `1-hr` batteries to the `1st` computer (one running on the `3-hr` battery), and the remaining 4 `1-hr` batteries to the `2nd` computer (one currently running on a `5-hr` battery).\n\nSo now the `1st` one runs for `9-hrs`, `2nd` one runs for `9-hrs` and the `3rd` one runs for `10-hrs`. So the answer we get is `9-hrs` max. Wrong answer obviously.\n\nI hope you can see my point, and would appreciate if someone corrects me.\n"
                    },
                    {
                        "username": "omkarsk98",
                        "content": "I see a priority queue here. Is it correct?"
                    },
                    {
                        "username": "Ultron03",
                        "content": "How it will correct ans for 10,10,5,3 and n=3"
                    },
                    {
                        "username": "aitachii",
                        "content": "You should try these testcases first:\n\n    3\n    [10,10,5,3]\n\n    4\n    [8, 1, 4, 8]\n\n    2\n    [31,87,85,44,47,25]\n\nHint: The 2nd one can be done in O(n) time, O(1) space."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "add this also \\n```\\n12\\n[11,89,16,32,70,67,35,35,31,24,41,29,6,53,78,83]\\n```"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "wow very clear description\\nnot like yesterday\\n"
                    },
                    {
                        "username": "fli033",
                        "content": "I originally though binary search... But I couldn\\'t figure out how to test if a target time can be met... RIP"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@moraalejandro94](/moraalejandro94) Lets consider an example  n=3 batteries=[10,10,4]   the answer here will be 4 and not the 8 but according to your concept \\n( 10+10+4=24>=3*8)   answer=8"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@moraalejandro94](/moraalejandro94) Thanks! That\\'s a great hint."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "You need to run n computers for \\'mid\\' minutes -> n*mid \"energy units\". For each battery, it can contribute at most \\'mid\\' energy units, so you can check if the sum of what each battery can contribute is more than n*mid. "
                    },
                    {
                        "username": "pramod74",
                        "content": "34/52 testcases passed using this simple logic:\n\nreturn Math.floor(sum of elements in batteries array/n)\n\n:)"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@AssortedFantasy](/AssortedFantasy) Note that the problem can actually be done without Binary search at all like the hint suggest, its even easier of you use what I\\'ve said."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is almost the entirely solution.\\n\\nIts not obvious, but being able to swap batteries around means you can indeed almost make full use out of every battery, so yes simply floor dividing the total energy by n does give you the total time $t$.\\n\\nHowever the trick is that if you do this, some of the batteries has more energy than $t$. So you need to account for this as not usable power."
                    },
                    {
                        "username": "mohit7086",
                        "content": "yeah \\uD83D\\uDE02"
                    },
                    {
                        "username": "0xJaskeerat",
                        "content": "Did the same"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There was no power at home for a half day. I really need batteries!  The example 1 is quite interesting. By a smart  way of interchanging the batteries the maximal running time is  optimized. In most cases the battery is plugged in and until it has no power!"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "how the hell can u solve this in time limit???!!!!!!"
                    },
                    {
                        "username": "EntityPlantt",
                        "content": "hints & editorial: let us introduce ourselves"
                    }
                ]
            },
            {
                "id": 1988260,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "this problem sure did drain my batteries ... "
                    },
                    {
                        "username": "sushimatou",
                        "content": "one hour and a half, not even a beginning of an answer T-T"
                    },
                    {
                        "username": "yourick",
                        "content": "### More similar problems:\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/description/)\n[410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\n[668. Kth Smallest Number in Multiplication Table](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/description/)\n[719. Find K-th Smallest Pair Distance](https://leetcode.com/problems/find-k-th-smallest-pair-distance/description/)\n[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/)\n[1283. Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/description/)\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/description/)\n[1552. Magnetic Force Between Two Balls](https://leetcode.com/problems/magnetic-force-between-two-balls/description/)\n[1760. Minimum Limit of Balls in a Bag](https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/description/)\n[1802. Maximum Value at a Given Index in a Bounded Array](https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/description/)\n[1870. Minimum Speed to Arrive on Time](https://leetcode.com/problems/minimum-speed-to-arrive-on-time/description/)\n[1898. Maximum Number of Removable Characters](https://leetcode.com/problems/maximum-number-of-removable-characters/description/)\n[2064. Minimized Maximum of Products Distributed to Any Store](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/description/)\n[2071. Maximum Number of Tasks You Can Assign](https://leetcode.com/problems/maximum-number-of-tasks-you-can-assign/description/)\n[2141. Maximum Running Time of N Computers](https://leetcode.com/problems/maximum-running-time-of-n-computers/)\n[2187. Minimum Time to Complete Trips](https://leetcode.com/problems/minimum-time-to-complete-trips/description/)\n[2226. Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/description/)\n[2517. Maximum Tastiness of Candy Basket](https://leetcode.com/problems/maximum-tastiness-of-candy-basket/description/)\n[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/description/)\n[2560. House Robber IV](https://leetcode.com/problems/house-robber-iv/description/)\n[2594. Minimum Time to Repair Cars](https://leetcode.com/problems/minimum-time-to-repair-cars/description/)\n[2616. Minimize the Maximum Difference of Pairs](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/description/)\n"
                    },
                    {
                        "username": "prototye",
                        "content": "[@bparanj](/bparanj) chat gpt\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Here are 10 distinct problems that use similar underlying concepts:\\n\\n1. [Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts](https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/): This problem also involves sorting and finding maximum possible values after cuts, which is similar to our original problem of distributing charge among computers.\\n\\n2. [Task Scheduler](https://leetcode.com/problems/task-scheduler/): The task scheduling problem also uses a greedy approach to fit tasks into a schedule in a way that minimizes idle time.\\n\\n3. [Boats to Save People](https://leetcode.com/problems/boats-to-save-people/): This problem involves figuring out the minimum number of boats required to save people, a concept akin to determining the maximum running time of computers.\\n\\n4. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/): This problem also involves maximizing a certain parameter (the sum in this case) over a given set of integers.\\n\\n5. [Jump Game II](https://leetcode.com/problems/jump-game-ii/): This problem also involves maximizing a certain parameter (the number of jumps in this case) and uses a greedy algorithm approach.\\n\\n6. [Container With Most Water](https://leetcode.com/problems/container-with-most-water/): The strategy used in this problem, where we try to maximize the area of water the container can hold, is somewhat similar to our original problem where we tried to maximize the runtime.\\n\\n7. [Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/): This problem asks to divide an array into segments to minimize the maximum sum among them, which can be solved using a binary search in the same vein as the original problem.\\n\\n8. [Gas Station](https://leetcode.com/problems/gas-station/): The greedy approach used in this problem to find the starting gas station is similar to the strategy used in the original problem.\\n\\n9. [Queue Reconstruction by Height](https://leetcode.com/problems/queue-reconstruction-by-height/): The approach of sorting and then placing elements based on some condition is similar to the original problem.\\n\\n10. [Largest Number](https://leetcode.com/problems/largest-number/): The problem involves sorting and arranging elements in a certain way to maximize a value, which is a similar strategy as the original problem. \\n"
                    },
                    {
                        "username": "metaphysicalist",
                        "content": "The week of binary search?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "use biggest batteries first. All the batteries left after are your extra hours - just spread it across evenly (for ex, if u have two batteries left 2 and 3 hours it is the same as if u had 5 batteries 1 hour each)"
                    },
                    {
                        "username": "timofeev_evg",
                        "content": "[@charonme](/charonme) nothing to divide here. [100,1] + 2 extra, answer is 3"
                    },
                    {
                        "username": "charonme",
                        "content": "[@c4tdog](/c4tdog) a battery can\\'t be divided, try to apply your algo to n=2, batteries=[100,1,1,1] testcase"
                    },
                    {
                        "username": "Karthik949",
                        "content": "I went with same logic using Heaps "
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@charonme](/charonme) last one could be divided between two"
                    },
                    {
                        "username": "charonme",
                        "content": "this approach already doesn\\'t work with example 1. You\\'d use the two 3h batteries and will be left with one 3h battery for 2 computers"
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@c4tdog](/c4tdog)  okay sir !"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@omkarsk98](/omkarsk98) I used  maxHeap immediately I saw the question but hit TLE pretty fast"
                    },
                    {
                        "username": "hero080",
                        "content": "[@anuron_das](/anuron_das) \\nA much better way:\\n`[10, 10, 3, 5]` and `n = 3` is the same as `[3, 5]` and `n = 1`, we have total power of 8 so we can run 8 minutes.\\nThis also validates our point: `10 > 8` therefore these \"high power\" batteries will never be used up.\\n\\nSee the details:\\nhttps://leetcode.com/problems/maximum-running-time-of-n-computers/solutions/3822290/beat-100-o-m-nlogn-most-intuitive-solution-no-bs-no-heap/"
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@Ultron03](/Ultron03) since 5 in much less than 10, all last 3 hours goes to it, and the answer is 8. in case 10 10 10, u could split 3 among all computers and the answer would be 11"
                    },
                    {
                        "username": "anuron_das",
                        "content": "What you are saying is correct, but is very counterintuitive for me to understand. \n\nWhen we have 2 batteries of `3-hr` and `2-hr` power, we can attach these batteries to at most 2 computers at a time right? But when I am equating this to the scenario where I have 5 batteries of `1-hr` power, then I am claiming that I can attach these 2 batteries to at most 5 computers at a time. Isn't that incorrect?\n\nAlso, if it really is the case then if we start off by using the batteries with least power first, then also this approach should work. But interestingly it does not. \n\nTake the test case `[10,10,3,5]` with `n=3`. If I use the lest powered batteries first then I will attach the `3-hr`, `5-hr` and `10-hr` battery first. Now I have 1 `10-hr` battery left, which is same as having 10 `1-hr` batteries (just play along with me, even though this is a false argument). I will attach 6 `1-hr` batteries to the `1st` computer (one running on the `3-hr` battery), and the remaining 4 `1-hr` batteries to the `2nd` computer (one currently running on a `5-hr` battery).\n\nSo now the `1st` one runs for `9-hrs`, `2nd` one runs for `9-hrs` and the `3rd` one runs for `10-hrs`. So the answer we get is `9-hrs` max. Wrong answer obviously.\n\nI hope you can see my point, and would appreciate if someone corrects me.\n"
                    },
                    {
                        "username": "omkarsk98",
                        "content": "I see a priority queue here. Is it correct?"
                    },
                    {
                        "username": "Ultron03",
                        "content": "How it will correct ans for 10,10,5,3 and n=3"
                    },
                    {
                        "username": "aitachii",
                        "content": "You should try these testcases first:\n\n    3\n    [10,10,5,3]\n\n    4\n    [8, 1, 4, 8]\n\n    2\n    [31,87,85,44,47,25]\n\nHint: The 2nd one can be done in O(n) time, O(1) space."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "add this also \\n```\\n12\\n[11,89,16,32,70,67,35,35,31,24,41,29,6,53,78,83]\\n```"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "wow very clear description\\nnot like yesterday\\n"
                    },
                    {
                        "username": "fli033",
                        "content": "I originally though binary search... But I couldn\\'t figure out how to test if a target time can be met... RIP"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@moraalejandro94](/moraalejandro94) Lets consider an example  n=3 batteries=[10,10,4]   the answer here will be 4 and not the 8 but according to your concept \\n( 10+10+4=24>=3*8)   answer=8"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@moraalejandro94](/moraalejandro94) Thanks! That\\'s a great hint."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "You need to run n computers for \\'mid\\' minutes -> n*mid \"energy units\". For each battery, it can contribute at most \\'mid\\' energy units, so you can check if the sum of what each battery can contribute is more than n*mid. "
                    },
                    {
                        "username": "pramod74",
                        "content": "34/52 testcases passed using this simple logic:\n\nreturn Math.floor(sum of elements in batteries array/n)\n\n:)"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@AssortedFantasy](/AssortedFantasy) Note that the problem can actually be done without Binary search at all like the hint suggest, its even easier of you use what I\\'ve said."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is almost the entirely solution.\\n\\nIts not obvious, but being able to swap batteries around means you can indeed almost make full use out of every battery, so yes simply floor dividing the total energy by n does give you the total time $t$.\\n\\nHowever the trick is that if you do this, some of the batteries has more energy than $t$. So you need to account for this as not usable power."
                    },
                    {
                        "username": "mohit7086",
                        "content": "yeah \\uD83D\\uDE02"
                    },
                    {
                        "username": "0xJaskeerat",
                        "content": "Did the same"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There was no power at home for a half day. I really need batteries!  The example 1 is quite interesting. By a smart  way of interchanging the batteries the maximal running time is  optimized. In most cases the battery is plugged in and until it has no power!"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "how the hell can u solve this in time limit???!!!!!!"
                    },
                    {
                        "username": "EntityPlantt",
                        "content": "hints & editorial: let us introduce ourselves"
                    }
                ]
            },
            {
                "id": 1842319,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "this problem sure did drain my batteries ... "
                    },
                    {
                        "username": "sushimatou",
                        "content": "one hour and a half, not even a beginning of an answer T-T"
                    },
                    {
                        "username": "yourick",
                        "content": "### More similar problems:\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/description/)\n[410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\n[668. Kth Smallest Number in Multiplication Table](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/description/)\n[719. Find K-th Smallest Pair Distance](https://leetcode.com/problems/find-k-th-smallest-pair-distance/description/)\n[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/)\n[1283. Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/description/)\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/description/)\n[1552. Magnetic Force Between Two Balls](https://leetcode.com/problems/magnetic-force-between-two-balls/description/)\n[1760. Minimum Limit of Balls in a Bag](https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/description/)\n[1802. Maximum Value at a Given Index in a Bounded Array](https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/description/)\n[1870. Minimum Speed to Arrive on Time](https://leetcode.com/problems/minimum-speed-to-arrive-on-time/description/)\n[1898. Maximum Number of Removable Characters](https://leetcode.com/problems/maximum-number-of-removable-characters/description/)\n[2064. Minimized Maximum of Products Distributed to Any Store](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/description/)\n[2071. Maximum Number of Tasks You Can Assign](https://leetcode.com/problems/maximum-number-of-tasks-you-can-assign/description/)\n[2141. Maximum Running Time of N Computers](https://leetcode.com/problems/maximum-running-time-of-n-computers/)\n[2187. Minimum Time to Complete Trips](https://leetcode.com/problems/minimum-time-to-complete-trips/description/)\n[2226. Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/description/)\n[2517. Maximum Tastiness of Candy Basket](https://leetcode.com/problems/maximum-tastiness-of-candy-basket/description/)\n[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/description/)\n[2560. House Robber IV](https://leetcode.com/problems/house-robber-iv/description/)\n[2594. Minimum Time to Repair Cars](https://leetcode.com/problems/minimum-time-to-repair-cars/description/)\n[2616. Minimize the Maximum Difference of Pairs](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/description/)\n"
                    },
                    {
                        "username": "prototye",
                        "content": "[@bparanj](/bparanj) chat gpt\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Here are 10 distinct problems that use similar underlying concepts:\\n\\n1. [Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts](https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/): This problem also involves sorting and finding maximum possible values after cuts, which is similar to our original problem of distributing charge among computers.\\n\\n2. [Task Scheduler](https://leetcode.com/problems/task-scheduler/): The task scheduling problem also uses a greedy approach to fit tasks into a schedule in a way that minimizes idle time.\\n\\n3. [Boats to Save People](https://leetcode.com/problems/boats-to-save-people/): This problem involves figuring out the minimum number of boats required to save people, a concept akin to determining the maximum running time of computers.\\n\\n4. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/): This problem also involves maximizing a certain parameter (the sum in this case) over a given set of integers.\\n\\n5. [Jump Game II](https://leetcode.com/problems/jump-game-ii/): This problem also involves maximizing a certain parameter (the number of jumps in this case) and uses a greedy algorithm approach.\\n\\n6. [Container With Most Water](https://leetcode.com/problems/container-with-most-water/): The strategy used in this problem, where we try to maximize the area of water the container can hold, is somewhat similar to our original problem where we tried to maximize the runtime.\\n\\n7. [Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/): This problem asks to divide an array into segments to minimize the maximum sum among them, which can be solved using a binary search in the same vein as the original problem.\\n\\n8. [Gas Station](https://leetcode.com/problems/gas-station/): The greedy approach used in this problem to find the starting gas station is similar to the strategy used in the original problem.\\n\\n9. [Queue Reconstruction by Height](https://leetcode.com/problems/queue-reconstruction-by-height/): The approach of sorting and then placing elements based on some condition is similar to the original problem.\\n\\n10. [Largest Number](https://leetcode.com/problems/largest-number/): The problem involves sorting and arranging elements in a certain way to maximize a value, which is a similar strategy as the original problem. \\n"
                    },
                    {
                        "username": "metaphysicalist",
                        "content": "The week of binary search?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "use biggest batteries first. All the batteries left after are your extra hours - just spread it across evenly (for ex, if u have two batteries left 2 and 3 hours it is the same as if u had 5 batteries 1 hour each)"
                    },
                    {
                        "username": "timofeev_evg",
                        "content": "[@charonme](/charonme) nothing to divide here. [100,1] + 2 extra, answer is 3"
                    },
                    {
                        "username": "charonme",
                        "content": "[@c4tdog](/c4tdog) a battery can\\'t be divided, try to apply your algo to n=2, batteries=[100,1,1,1] testcase"
                    },
                    {
                        "username": "Karthik949",
                        "content": "I went with same logic using Heaps "
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@charonme](/charonme) last one could be divided between two"
                    },
                    {
                        "username": "charonme",
                        "content": "this approach already doesn\\'t work with example 1. You\\'d use the two 3h batteries and will be left with one 3h battery for 2 computers"
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@c4tdog](/c4tdog)  okay sir !"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "[@omkarsk98](/omkarsk98) I used  maxHeap immediately I saw the question but hit TLE pretty fast"
                    },
                    {
                        "username": "hero080",
                        "content": "[@anuron_das](/anuron_das) \\nA much better way:\\n`[10, 10, 3, 5]` and `n = 3` is the same as `[3, 5]` and `n = 1`, we have total power of 8 so we can run 8 minutes.\\nThis also validates our point: `10 > 8` therefore these \"high power\" batteries will never be used up.\\n\\nSee the details:\\nhttps://leetcode.com/problems/maximum-running-time-of-n-computers/solutions/3822290/beat-100-o-m-nlogn-most-intuitive-solution-no-bs-no-heap/"
                    },
                    {
                        "username": "c4tdog",
                        "content": "[@Ultron03](/Ultron03) since 5 in much less than 10, all last 3 hours goes to it, and the answer is 8. in case 10 10 10, u could split 3 among all computers and the answer would be 11"
                    },
                    {
                        "username": "anuron_das",
                        "content": "What you are saying is correct, but is very counterintuitive for me to understand. \n\nWhen we have 2 batteries of `3-hr` and `2-hr` power, we can attach these batteries to at most 2 computers at a time right? But when I am equating this to the scenario where I have 5 batteries of `1-hr` power, then I am claiming that I can attach these 2 batteries to at most 5 computers at a time. Isn't that incorrect?\n\nAlso, if it really is the case then if we start off by using the batteries with least power first, then also this approach should work. But interestingly it does not. \n\nTake the test case `[10,10,3,5]` with `n=3`. If I use the lest powered batteries first then I will attach the `3-hr`, `5-hr` and `10-hr` battery first. Now I have 1 `10-hr` battery left, which is same as having 10 `1-hr` batteries (just play along with me, even though this is a false argument). I will attach 6 `1-hr` batteries to the `1st` computer (one running on the `3-hr` battery), and the remaining 4 `1-hr` batteries to the `2nd` computer (one currently running on a `5-hr` battery).\n\nSo now the `1st` one runs for `9-hrs`, `2nd` one runs for `9-hrs` and the `3rd` one runs for `10-hrs`. So the answer we get is `9-hrs` max. Wrong answer obviously.\n\nI hope you can see my point, and would appreciate if someone corrects me.\n"
                    },
                    {
                        "username": "omkarsk98",
                        "content": "I see a priority queue here. Is it correct?"
                    },
                    {
                        "username": "Ultron03",
                        "content": "How it will correct ans for 10,10,5,3 and n=3"
                    },
                    {
                        "username": "aitachii",
                        "content": "You should try these testcases first:\n\n    3\n    [10,10,5,3]\n\n    4\n    [8, 1, 4, 8]\n\n    2\n    [31,87,85,44,47,25]\n\nHint: The 2nd one can be done in O(n) time, O(1) space."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "add this also \\n```\\n12\\n[11,89,16,32,70,67,35,35,31,24,41,29,6,53,78,83]\\n```"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "wow very clear description\\nnot like yesterday\\n"
                    },
                    {
                        "username": "fli033",
                        "content": "I originally though binary search... But I couldn\\'t figure out how to test if a target time can be met... RIP"
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "[@moraalejandro94](/moraalejandro94) Lets consider an example  n=3 batteries=[10,10,4]   the answer here will be 4 and not the 8 but according to your concept \\n( 10+10+4=24>=3*8)   answer=8"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@moraalejandro94](/moraalejandro94) Thanks! That\\'s a great hint."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "You need to run n computers for \\'mid\\' minutes -> n*mid \"energy units\". For each battery, it can contribute at most \\'mid\\' energy units, so you can check if the sum of what each battery can contribute is more than n*mid. "
                    },
                    {
                        "username": "pramod74",
                        "content": "34/52 testcases passed using this simple logic:\n\nreturn Math.floor(sum of elements in batteries array/n)\n\n:)"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "[@AssortedFantasy](/AssortedFantasy) Note that the problem can actually be done without Binary search at all like the hint suggest, its even easier of you use what I\\'ve said."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This is almost the entirely solution.\\n\\nIts not obvious, but being able to swap batteries around means you can indeed almost make full use out of every battery, so yes simply floor dividing the total energy by n does give you the total time $t$.\\n\\nHowever the trick is that if you do this, some of the batteries has more energy than $t$. So you need to account for this as not usable power."
                    },
                    {
                        "username": "mohit7086",
                        "content": "yeah \\uD83D\\uDE02"
                    },
                    {
                        "username": "0xJaskeerat",
                        "content": "Did the same"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There was no power at home for a half day. I really need batteries!  The example 1 is quite interesting. By a smart  way of interchanging the batteries the maximal running time is  optimized. In most cases the battery is plugged in and until it has no power!"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "how the hell can u solve this in time limit???!!!!!!"
                    },
                    {
                        "username": "EntityPlantt",
                        "content": "hints & editorial: let us introduce ourselves"
                    }
                ]
            },
            {
                "id": 1988485,
                "content": [
                    {
                        "username": "jason3410",
                        "content": "C\\'mon LeetCode, this is creepily difficult .\\nToday is workday."
                    },
                    {
                        "username": "amitak0707",
                        "content": "Another day another binary."
                    },
                    {
                        "username": "gandharv123",
                        "content": "Can somebody provide list of similar set of questions to ace this pattern of binary search? Thanks in advance"
                    },
                    {
                        "username": "prompt_07",
                        "content": "Koko Eating Bananas (Most IMP)\nKth Smallest Number in Multiplication Table\nMaximum Running Time of N Computers\nMinimize Deviation in Array\nCapacity To Ship Packages Within D Days\nSplit Array Largest Sum\nMaximum Candies Allocated to K Children\nEncrypt and Decrypt Strings"
                    },
                    {
                        "username": "GreenHamHam",
                        "content": "Honestly I am starting to feel more like the hints just fuck me over half the time. \\nI basically figured out the first solution but assumed it wasn\\'t good because of the hint.\\nFuck the hints, I\\'ll just figure these out on my own from now on"
                    },
                    {
                        "username": "wming9310",
                        "content": "Is it the weekend already?"
                    },
                    {
                        "username": "abhijeetkushwaha",
                        "content": "hint op\\n"
                    },
                    {
                        "username": "Romeao",
                        "content": "This question seems broken to me.  Imagine N = 3 and Batteries = [5, 7, 9, 10].  The solver says the answer is 10, but I think it should be 9.\\n\\nWe have 1 extra battery.\\n\\nWe can run to t = 7 with the three biggest batteries.  At that point the power remaining would be [5, 0, 2, 3], so we swap out the 0 with 5.  We can run for 2 more seconds (t = 9).  At that point the batteries are [3, 0, 0, 1].  How do we get to 10 s?"
                    },
                    {
                        "username": "Romeao",
                        "content": "[@Karilli](/Karilli) Yeah I realized this in a slightly different path.  I think what threw me off was the editorial skips over this issue when it says to pick the highest batteries.  My realization was \\n\\nt=0 -> [5, 7, 9, 10]\\nt=1 -> [4, 6, 9, 9]\\nt=4 -> [1, 6, 6, 6]\\nt=10 -> [1, 0, 0, 0]"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The solution described does have a flaw in the situation you\\'ve given.\\n\\nThe flaw is in the step where we remove batteries with runtimes greater than the average. The assumption that removing these batteries will always lead to a longer overall runtime is not necessarily correct.\\n\\nIn your example, we start with an average runtime of 10 (total runtime of 31 divided by 3 slots). Using the current method, the battery with a runtime of 10 is removed first. However, as you rightly pointed out, the optimal strategy would be to use the batteries with runtimes of 10, 9, and 7 first, run the device for 7 units of time, and then replace the depleted battery with the one with a runtime of 5 and run for an additional 2 units of time.\\n\\nThe algorithm fails to consider the possibility of switching out depleted batteries with remaining ones, which is a crucial part of maximizing the runtime in this scenario. \\n\\nTherefore, the solution needs to be revised to account for the possibility of switching batteries after they deplete. This might involve an additional step of sorting the batteries in descending order of runtime and then iteratively checking if replacing the depleted battery with the remaining ones increases the overall runtime."
                    },
                    {
                        "username": "Karilli",
                        "content": "-> start with [5, 7, 9, 10]\\n-> we plug in [5, 9, 10] for 3 minutes, resulting in [2, 7, 6, 7]\\n-> we plug in [2, 7, 7] for 1 minute, resulting in [1, 6, 6, 6]\\n-> we plug in [6, 6, 6] for 6 minutes\\n\\ntotal time 10 minutes, you are left with [1, 0, 0, 0]"
                    },
                    {
                        "username": "deeppatel6071",
                        "content": "why we have to use mid = (left + right +1 )/2 ??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The mid-point calculation `mid = (left + right + 1) / 2` is used when we want to favor the upper half of the search space in our binary search. In other words, when we are implementing an upper-bound binary search.\\n\\nLet\\'s consider this scenario in a binary search:\\n1. When `left = 4` and `right = 5`, if we use `mid = (left + right) / 2`, we get `mid = 4`. In this case, if our condition is not satisfied, we will update `left = mid + 1`, and `left` will become `5`.\\n2. But in the next iteration, if we again calculate `mid` using `mid = (left + right) / 2`, we will get `mid = 5`, and `left` and `mid` would remain `5` indefinitely, causing an infinite loop.\\n\\nHowever, if we use `mid = (left + right + 1) / 2`, in the first iteration `mid` will become `5`, and in the next iteration (assuming `right` doesn\\'t change), `mid` will again be `5`, allowing us to proceed without getting stuck.\\n\\nSo the `+1` in `(left + right + 1) / 2` helps to avoid potential infinite loops by ensuring progress in scenarios where `right - left = 1`. This is a trick that can be useful in certain types of binary search problems, particularly those where you\\'re looking for the upper bound of a range.\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "you can also use right-(right-left)//2\nbut i some post i have read like if we didnt use +1 it causes infinte loop . i dont know that and i havent traced out that yet......"
                    },
                    {
                        "username": "Karthik949",
                        "content": "24/52 cases passes getting TLE error I used heaps.\\n\\nI saw hints showing Binary Search but not sure how to even use Binary search in the scenario? any more hints"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Sure, here is are 2 follow up hints:\n\n1\nThe bounds are 0 and the total amount of charge of all batteries. \n\n2\nFor each point in time you can check if you can run all computer up to that point, by simply dividing the amount of charge each battery can deliver up to that point in time (if you want to check for 5 seconds, a batterie can only deliver 5 units of power, no matter how much total charge that battery has). \n\n(you don't need heaps at all, just clever binary search)"
                    },
                    {
                        "username": "bruh_",
                        "content": "Poor me :( \\nCouldn\\'t figure out whether its possible to run all systems simultaneously, given a run time"
                    }
                ]
            },
            {
                "id": 1988134,
                "content": [
                    {
                        "username": "jason3410",
                        "content": "C\\'mon LeetCode, this is creepily difficult .\\nToday is workday."
                    },
                    {
                        "username": "amitak0707",
                        "content": "Another day another binary."
                    },
                    {
                        "username": "gandharv123",
                        "content": "Can somebody provide list of similar set of questions to ace this pattern of binary search? Thanks in advance"
                    },
                    {
                        "username": "prompt_07",
                        "content": "Koko Eating Bananas (Most IMP)\nKth Smallest Number in Multiplication Table\nMaximum Running Time of N Computers\nMinimize Deviation in Array\nCapacity To Ship Packages Within D Days\nSplit Array Largest Sum\nMaximum Candies Allocated to K Children\nEncrypt and Decrypt Strings"
                    },
                    {
                        "username": "GreenHamHam",
                        "content": "Honestly I am starting to feel more like the hints just fuck me over half the time. \\nI basically figured out the first solution but assumed it wasn\\'t good because of the hint.\\nFuck the hints, I\\'ll just figure these out on my own from now on"
                    },
                    {
                        "username": "wming9310",
                        "content": "Is it the weekend already?"
                    },
                    {
                        "username": "abhijeetkushwaha",
                        "content": "hint op\\n"
                    },
                    {
                        "username": "Romeao",
                        "content": "This question seems broken to me.  Imagine N = 3 and Batteries = [5, 7, 9, 10].  The solver says the answer is 10, but I think it should be 9.\\n\\nWe have 1 extra battery.\\n\\nWe can run to t = 7 with the three biggest batteries.  At that point the power remaining would be [5, 0, 2, 3], so we swap out the 0 with 5.  We can run for 2 more seconds (t = 9).  At that point the batteries are [3, 0, 0, 1].  How do we get to 10 s?"
                    },
                    {
                        "username": "Romeao",
                        "content": "[@Karilli](/Karilli) Yeah I realized this in a slightly different path.  I think what threw me off was the editorial skips over this issue when it says to pick the highest batteries.  My realization was \\n\\nt=0 -> [5, 7, 9, 10]\\nt=1 -> [4, 6, 9, 9]\\nt=4 -> [1, 6, 6, 6]\\nt=10 -> [1, 0, 0, 0]"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The solution described does have a flaw in the situation you\\'ve given.\\n\\nThe flaw is in the step where we remove batteries with runtimes greater than the average. The assumption that removing these batteries will always lead to a longer overall runtime is not necessarily correct.\\n\\nIn your example, we start with an average runtime of 10 (total runtime of 31 divided by 3 slots). Using the current method, the battery with a runtime of 10 is removed first. However, as you rightly pointed out, the optimal strategy would be to use the batteries with runtimes of 10, 9, and 7 first, run the device for 7 units of time, and then replace the depleted battery with the one with a runtime of 5 and run for an additional 2 units of time.\\n\\nThe algorithm fails to consider the possibility of switching out depleted batteries with remaining ones, which is a crucial part of maximizing the runtime in this scenario. \\n\\nTherefore, the solution needs to be revised to account for the possibility of switching batteries after they deplete. This might involve an additional step of sorting the batteries in descending order of runtime and then iteratively checking if replacing the depleted battery with the remaining ones increases the overall runtime."
                    },
                    {
                        "username": "Karilli",
                        "content": "-> start with [5, 7, 9, 10]\\n-> we plug in [5, 9, 10] for 3 minutes, resulting in [2, 7, 6, 7]\\n-> we plug in [2, 7, 7] for 1 minute, resulting in [1, 6, 6, 6]\\n-> we plug in [6, 6, 6] for 6 minutes\\n\\ntotal time 10 minutes, you are left with [1, 0, 0, 0]"
                    },
                    {
                        "username": "deeppatel6071",
                        "content": "why we have to use mid = (left + right +1 )/2 ??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The mid-point calculation `mid = (left + right + 1) / 2` is used when we want to favor the upper half of the search space in our binary search. In other words, when we are implementing an upper-bound binary search.\\n\\nLet\\'s consider this scenario in a binary search:\\n1. When `left = 4` and `right = 5`, if we use `mid = (left + right) / 2`, we get `mid = 4`. In this case, if our condition is not satisfied, we will update `left = mid + 1`, and `left` will become `5`.\\n2. But in the next iteration, if we again calculate `mid` using `mid = (left + right) / 2`, we will get `mid = 5`, and `left` and `mid` would remain `5` indefinitely, causing an infinite loop.\\n\\nHowever, if we use `mid = (left + right + 1) / 2`, in the first iteration `mid` will become `5`, and in the next iteration (assuming `right` doesn\\'t change), `mid` will again be `5`, allowing us to proceed without getting stuck.\\n\\nSo the `+1` in `(left + right + 1) / 2` helps to avoid potential infinite loops by ensuring progress in scenarios where `right - left = 1`. This is a trick that can be useful in certain types of binary search problems, particularly those where you\\'re looking for the upper bound of a range.\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "you can also use right-(right-left)//2\nbut i some post i have read like if we didnt use +1 it causes infinte loop . i dont know that and i havent traced out that yet......"
                    },
                    {
                        "username": "Karthik949",
                        "content": "24/52 cases passes getting TLE error I used heaps.\\n\\nI saw hints showing Binary Search but not sure how to even use Binary search in the scenario? any more hints"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Sure, here is are 2 follow up hints:\n\n1\nThe bounds are 0 and the total amount of charge of all batteries. \n\n2\nFor each point in time you can check if you can run all computer up to that point, by simply dividing the amount of charge each battery can deliver up to that point in time (if you want to check for 5 seconds, a batterie can only deliver 5 units of power, no matter how much total charge that battery has). \n\n(you don't need heaps at all, just clever binary search)"
                    },
                    {
                        "username": "bruh_",
                        "content": "Poor me :( \\nCouldn\\'t figure out whether its possible to run all systems simultaneously, given a run time"
                    }
                ]
            },
            {
                "id": 1567720,
                "content": [
                    {
                        "username": "jason3410",
                        "content": "C\\'mon LeetCode, this is creepily difficult .\\nToday is workday."
                    },
                    {
                        "username": "amitak0707",
                        "content": "Another day another binary."
                    },
                    {
                        "username": "gandharv123",
                        "content": "Can somebody provide list of similar set of questions to ace this pattern of binary search? Thanks in advance"
                    },
                    {
                        "username": "prompt_07",
                        "content": "Koko Eating Bananas (Most IMP)\nKth Smallest Number in Multiplication Table\nMaximum Running Time of N Computers\nMinimize Deviation in Array\nCapacity To Ship Packages Within D Days\nSplit Array Largest Sum\nMaximum Candies Allocated to K Children\nEncrypt and Decrypt Strings"
                    },
                    {
                        "username": "GreenHamHam",
                        "content": "Honestly I am starting to feel more like the hints just fuck me over half the time. \\nI basically figured out the first solution but assumed it wasn\\'t good because of the hint.\\nFuck the hints, I\\'ll just figure these out on my own from now on"
                    },
                    {
                        "username": "wming9310",
                        "content": "Is it the weekend already?"
                    },
                    {
                        "username": "abhijeetkushwaha",
                        "content": "hint op\\n"
                    },
                    {
                        "username": "Romeao",
                        "content": "This question seems broken to me.  Imagine N = 3 and Batteries = [5, 7, 9, 10].  The solver says the answer is 10, but I think it should be 9.\\n\\nWe have 1 extra battery.\\n\\nWe can run to t = 7 with the three biggest batteries.  At that point the power remaining would be [5, 0, 2, 3], so we swap out the 0 with 5.  We can run for 2 more seconds (t = 9).  At that point the batteries are [3, 0, 0, 1].  How do we get to 10 s?"
                    },
                    {
                        "username": "Romeao",
                        "content": "[@Karilli](/Karilli) Yeah I realized this in a slightly different path.  I think what threw me off was the editorial skips over this issue when it says to pick the highest batteries.  My realization was \\n\\nt=0 -> [5, 7, 9, 10]\\nt=1 -> [4, 6, 9, 9]\\nt=4 -> [1, 6, 6, 6]\\nt=10 -> [1, 0, 0, 0]"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The solution described does have a flaw in the situation you\\'ve given.\\n\\nThe flaw is in the step where we remove batteries with runtimes greater than the average. The assumption that removing these batteries will always lead to a longer overall runtime is not necessarily correct.\\n\\nIn your example, we start with an average runtime of 10 (total runtime of 31 divided by 3 slots). Using the current method, the battery with a runtime of 10 is removed first. However, as you rightly pointed out, the optimal strategy would be to use the batteries with runtimes of 10, 9, and 7 first, run the device for 7 units of time, and then replace the depleted battery with the one with a runtime of 5 and run for an additional 2 units of time.\\n\\nThe algorithm fails to consider the possibility of switching out depleted batteries with remaining ones, which is a crucial part of maximizing the runtime in this scenario. \\n\\nTherefore, the solution needs to be revised to account for the possibility of switching batteries after they deplete. This might involve an additional step of sorting the batteries in descending order of runtime and then iteratively checking if replacing the depleted battery with the remaining ones increases the overall runtime."
                    },
                    {
                        "username": "Karilli",
                        "content": "-> start with [5, 7, 9, 10]\\n-> we plug in [5, 9, 10] for 3 minutes, resulting in [2, 7, 6, 7]\\n-> we plug in [2, 7, 7] for 1 minute, resulting in [1, 6, 6, 6]\\n-> we plug in [6, 6, 6] for 6 minutes\\n\\ntotal time 10 minutes, you are left with [1, 0, 0, 0]"
                    },
                    {
                        "username": "deeppatel6071",
                        "content": "why we have to use mid = (left + right +1 )/2 ??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The mid-point calculation `mid = (left + right + 1) / 2` is used when we want to favor the upper half of the search space in our binary search. In other words, when we are implementing an upper-bound binary search.\\n\\nLet\\'s consider this scenario in a binary search:\\n1. When `left = 4` and `right = 5`, if we use `mid = (left + right) / 2`, we get `mid = 4`. In this case, if our condition is not satisfied, we will update `left = mid + 1`, and `left` will become `5`.\\n2. But in the next iteration, if we again calculate `mid` using `mid = (left + right) / 2`, we will get `mid = 5`, and `left` and `mid` would remain `5` indefinitely, causing an infinite loop.\\n\\nHowever, if we use `mid = (left + right + 1) / 2`, in the first iteration `mid` will become `5`, and in the next iteration (assuming `right` doesn\\'t change), `mid` will again be `5`, allowing us to proceed without getting stuck.\\n\\nSo the `+1` in `(left + right + 1) / 2` helps to avoid potential infinite loops by ensuring progress in scenarios where `right - left = 1`. This is a trick that can be useful in certain types of binary search problems, particularly those where you\\'re looking for the upper bound of a range.\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "you can also use right-(right-left)//2\nbut i some post i have read like if we didnt use +1 it causes infinte loop . i dont know that and i havent traced out that yet......"
                    },
                    {
                        "username": "Karthik949",
                        "content": "24/52 cases passes getting TLE error I used heaps.\\n\\nI saw hints showing Binary Search but not sure how to even use Binary search in the scenario? any more hints"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Sure, here is are 2 follow up hints:\n\n1\nThe bounds are 0 and the total amount of charge of all batteries. \n\n2\nFor each point in time you can check if you can run all computer up to that point, by simply dividing the amount of charge each battery can deliver up to that point in time (if you want to check for 5 seconds, a batterie can only deliver 5 units of power, no matter how much total charge that battery has). \n\n(you don't need heaps at all, just clever binary search)"
                    },
                    {
                        "username": "bruh_",
                        "content": "Poor me :( \\nCouldn\\'t figure out whether its possible to run all systems simultaneously, given a run time"
                    }
                ]
            },
            {
                "id": 1988991,
                "content": [
                    {
                        "username": "jason3410",
                        "content": "C\\'mon LeetCode, this is creepily difficult .\\nToday is workday."
                    },
                    {
                        "username": "amitak0707",
                        "content": "Another day another binary."
                    },
                    {
                        "username": "gandharv123",
                        "content": "Can somebody provide list of similar set of questions to ace this pattern of binary search? Thanks in advance"
                    },
                    {
                        "username": "prompt_07",
                        "content": "Koko Eating Bananas (Most IMP)\nKth Smallest Number in Multiplication Table\nMaximum Running Time of N Computers\nMinimize Deviation in Array\nCapacity To Ship Packages Within D Days\nSplit Array Largest Sum\nMaximum Candies Allocated to K Children\nEncrypt and Decrypt Strings"
                    },
                    {
                        "username": "GreenHamHam",
                        "content": "Honestly I am starting to feel more like the hints just fuck me over half the time. \\nI basically figured out the first solution but assumed it wasn\\'t good because of the hint.\\nFuck the hints, I\\'ll just figure these out on my own from now on"
                    },
                    {
                        "username": "wming9310",
                        "content": "Is it the weekend already?"
                    },
                    {
                        "username": "abhijeetkushwaha",
                        "content": "hint op\\n"
                    },
                    {
                        "username": "Romeao",
                        "content": "This question seems broken to me.  Imagine N = 3 and Batteries = [5, 7, 9, 10].  The solver says the answer is 10, but I think it should be 9.\\n\\nWe have 1 extra battery.\\n\\nWe can run to t = 7 with the three biggest batteries.  At that point the power remaining would be [5, 0, 2, 3], so we swap out the 0 with 5.  We can run for 2 more seconds (t = 9).  At that point the batteries are [3, 0, 0, 1].  How do we get to 10 s?"
                    },
                    {
                        "username": "Romeao",
                        "content": "[@Karilli](/Karilli) Yeah I realized this in a slightly different path.  I think what threw me off was the editorial skips over this issue when it says to pick the highest batteries.  My realization was \\n\\nt=0 -> [5, 7, 9, 10]\\nt=1 -> [4, 6, 9, 9]\\nt=4 -> [1, 6, 6, 6]\\nt=10 -> [1, 0, 0, 0]"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The solution described does have a flaw in the situation you\\'ve given.\\n\\nThe flaw is in the step where we remove batteries with runtimes greater than the average. The assumption that removing these batteries will always lead to a longer overall runtime is not necessarily correct.\\n\\nIn your example, we start with an average runtime of 10 (total runtime of 31 divided by 3 slots). Using the current method, the battery with a runtime of 10 is removed first. However, as you rightly pointed out, the optimal strategy would be to use the batteries with runtimes of 10, 9, and 7 first, run the device for 7 units of time, and then replace the depleted battery with the one with a runtime of 5 and run for an additional 2 units of time.\\n\\nThe algorithm fails to consider the possibility of switching out depleted batteries with remaining ones, which is a crucial part of maximizing the runtime in this scenario. \\n\\nTherefore, the solution needs to be revised to account for the possibility of switching batteries after they deplete. This might involve an additional step of sorting the batteries in descending order of runtime and then iteratively checking if replacing the depleted battery with the remaining ones increases the overall runtime."
                    },
                    {
                        "username": "Karilli",
                        "content": "-> start with [5, 7, 9, 10]\\n-> we plug in [5, 9, 10] for 3 minutes, resulting in [2, 7, 6, 7]\\n-> we plug in [2, 7, 7] for 1 minute, resulting in [1, 6, 6, 6]\\n-> we plug in [6, 6, 6] for 6 minutes\\n\\ntotal time 10 minutes, you are left with [1, 0, 0, 0]"
                    },
                    {
                        "username": "deeppatel6071",
                        "content": "why we have to use mid = (left + right +1 )/2 ??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The mid-point calculation `mid = (left + right + 1) / 2` is used when we want to favor the upper half of the search space in our binary search. In other words, when we are implementing an upper-bound binary search.\\n\\nLet\\'s consider this scenario in a binary search:\\n1. When `left = 4` and `right = 5`, if we use `mid = (left + right) / 2`, we get `mid = 4`. In this case, if our condition is not satisfied, we will update `left = mid + 1`, and `left` will become `5`.\\n2. But in the next iteration, if we again calculate `mid` using `mid = (left + right) / 2`, we will get `mid = 5`, and `left` and `mid` would remain `5` indefinitely, causing an infinite loop.\\n\\nHowever, if we use `mid = (left + right + 1) / 2`, in the first iteration `mid` will become `5`, and in the next iteration (assuming `right` doesn\\'t change), `mid` will again be `5`, allowing us to proceed without getting stuck.\\n\\nSo the `+1` in `(left + right + 1) / 2` helps to avoid potential infinite loops by ensuring progress in scenarios where `right - left = 1`. This is a trick that can be useful in certain types of binary search problems, particularly those where you\\'re looking for the upper bound of a range.\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "you can also use right-(right-left)//2\nbut i some post i have read like if we didnt use +1 it causes infinte loop . i dont know that and i havent traced out that yet......"
                    },
                    {
                        "username": "Karthik949",
                        "content": "24/52 cases passes getting TLE error I used heaps.\\n\\nI saw hints showing Binary Search but not sure how to even use Binary search in the scenario? any more hints"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Sure, here is are 2 follow up hints:\n\n1\nThe bounds are 0 and the total amount of charge of all batteries. \n\n2\nFor each point in time you can check if you can run all computer up to that point, by simply dividing the amount of charge each battery can deliver up to that point in time (if you want to check for 5 seconds, a batterie can only deliver 5 units of power, no matter how much total charge that battery has). \n\n(you don't need heaps at all, just clever binary search)"
                    },
                    {
                        "username": "bruh_",
                        "content": "Poor me :( \\nCouldn\\'t figure out whether its possible to run all systems simultaneously, given a run time"
                    }
                ]
            },
            {
                "id": 1988031,
                "content": [
                    {
                        "username": "jason3410",
                        "content": "C\\'mon LeetCode, this is creepily difficult .\\nToday is workday."
                    },
                    {
                        "username": "amitak0707",
                        "content": "Another day another binary."
                    },
                    {
                        "username": "gandharv123",
                        "content": "Can somebody provide list of similar set of questions to ace this pattern of binary search? Thanks in advance"
                    },
                    {
                        "username": "prompt_07",
                        "content": "Koko Eating Bananas (Most IMP)\nKth Smallest Number in Multiplication Table\nMaximum Running Time of N Computers\nMinimize Deviation in Array\nCapacity To Ship Packages Within D Days\nSplit Array Largest Sum\nMaximum Candies Allocated to K Children\nEncrypt and Decrypt Strings"
                    },
                    {
                        "username": "GreenHamHam",
                        "content": "Honestly I am starting to feel more like the hints just fuck me over half the time. \\nI basically figured out the first solution but assumed it wasn\\'t good because of the hint.\\nFuck the hints, I\\'ll just figure these out on my own from now on"
                    },
                    {
                        "username": "wming9310",
                        "content": "Is it the weekend already?"
                    },
                    {
                        "username": "abhijeetkushwaha",
                        "content": "hint op\\n"
                    },
                    {
                        "username": "Romeao",
                        "content": "This question seems broken to me.  Imagine N = 3 and Batteries = [5, 7, 9, 10].  The solver says the answer is 10, but I think it should be 9.\\n\\nWe have 1 extra battery.\\n\\nWe can run to t = 7 with the three biggest batteries.  At that point the power remaining would be [5, 0, 2, 3], so we swap out the 0 with 5.  We can run for 2 more seconds (t = 9).  At that point the batteries are [3, 0, 0, 1].  How do we get to 10 s?"
                    },
                    {
                        "username": "Romeao",
                        "content": "[@Karilli](/Karilli) Yeah I realized this in a slightly different path.  I think what threw me off was the editorial skips over this issue when it says to pick the highest batteries.  My realization was \\n\\nt=0 -> [5, 7, 9, 10]\\nt=1 -> [4, 6, 9, 9]\\nt=4 -> [1, 6, 6, 6]\\nt=10 -> [1, 0, 0, 0]"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The solution described does have a flaw in the situation you\\'ve given.\\n\\nThe flaw is in the step where we remove batteries with runtimes greater than the average. The assumption that removing these batteries will always lead to a longer overall runtime is not necessarily correct.\\n\\nIn your example, we start with an average runtime of 10 (total runtime of 31 divided by 3 slots). Using the current method, the battery with a runtime of 10 is removed first. However, as you rightly pointed out, the optimal strategy would be to use the batteries with runtimes of 10, 9, and 7 first, run the device for 7 units of time, and then replace the depleted battery with the one with a runtime of 5 and run for an additional 2 units of time.\\n\\nThe algorithm fails to consider the possibility of switching out depleted batteries with remaining ones, which is a crucial part of maximizing the runtime in this scenario. \\n\\nTherefore, the solution needs to be revised to account for the possibility of switching batteries after they deplete. This might involve an additional step of sorting the batteries in descending order of runtime and then iteratively checking if replacing the depleted battery with the remaining ones increases the overall runtime."
                    },
                    {
                        "username": "Karilli",
                        "content": "-> start with [5, 7, 9, 10]\\n-> we plug in [5, 9, 10] for 3 minutes, resulting in [2, 7, 6, 7]\\n-> we plug in [2, 7, 7] for 1 minute, resulting in [1, 6, 6, 6]\\n-> we plug in [6, 6, 6] for 6 minutes\\n\\ntotal time 10 minutes, you are left with [1, 0, 0, 0]"
                    },
                    {
                        "username": "deeppatel6071",
                        "content": "why we have to use mid = (left + right +1 )/2 ??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The mid-point calculation `mid = (left + right + 1) / 2` is used when we want to favor the upper half of the search space in our binary search. In other words, when we are implementing an upper-bound binary search.\\n\\nLet\\'s consider this scenario in a binary search:\\n1. When `left = 4` and `right = 5`, if we use `mid = (left + right) / 2`, we get `mid = 4`. In this case, if our condition is not satisfied, we will update `left = mid + 1`, and `left` will become `5`.\\n2. But in the next iteration, if we again calculate `mid` using `mid = (left + right) / 2`, we will get `mid = 5`, and `left` and `mid` would remain `5` indefinitely, causing an infinite loop.\\n\\nHowever, if we use `mid = (left + right + 1) / 2`, in the first iteration `mid` will become `5`, and in the next iteration (assuming `right` doesn\\'t change), `mid` will again be `5`, allowing us to proceed without getting stuck.\\n\\nSo the `+1` in `(left + right + 1) / 2` helps to avoid potential infinite loops by ensuring progress in scenarios where `right - left = 1`. This is a trick that can be useful in certain types of binary search problems, particularly those where you\\'re looking for the upper bound of a range.\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "you can also use right-(right-left)//2\nbut i some post i have read like if we didnt use +1 it causes infinte loop . i dont know that and i havent traced out that yet......"
                    },
                    {
                        "username": "Karthik949",
                        "content": "24/52 cases passes getting TLE error I used heaps.\\n\\nI saw hints showing Binary Search but not sure how to even use Binary search in the scenario? any more hints"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Sure, here is are 2 follow up hints:\n\n1\nThe bounds are 0 and the total amount of charge of all batteries. \n\n2\nFor each point in time you can check if you can run all computer up to that point, by simply dividing the amount of charge each battery can deliver up to that point in time (if you want to check for 5 seconds, a batterie can only deliver 5 units of power, no matter how much total charge that battery has). \n\n(you don't need heaps at all, just clever binary search)"
                    },
                    {
                        "username": "bruh_",
                        "content": "Poor me :( \\nCouldn\\'t figure out whether its possible to run all systems simultaneously, given a run time"
                    }
                ]
            },
            {
                "id": 1988111,
                "content": [
                    {
                        "username": "jason3410",
                        "content": "C\\'mon LeetCode, this is creepily difficult .\\nToday is workday."
                    },
                    {
                        "username": "amitak0707",
                        "content": "Another day another binary."
                    },
                    {
                        "username": "gandharv123",
                        "content": "Can somebody provide list of similar set of questions to ace this pattern of binary search? Thanks in advance"
                    },
                    {
                        "username": "prompt_07",
                        "content": "Koko Eating Bananas (Most IMP)\nKth Smallest Number in Multiplication Table\nMaximum Running Time of N Computers\nMinimize Deviation in Array\nCapacity To Ship Packages Within D Days\nSplit Array Largest Sum\nMaximum Candies Allocated to K Children\nEncrypt and Decrypt Strings"
                    },
                    {
                        "username": "GreenHamHam",
                        "content": "Honestly I am starting to feel more like the hints just fuck me over half the time. \\nI basically figured out the first solution but assumed it wasn\\'t good because of the hint.\\nFuck the hints, I\\'ll just figure these out on my own from now on"
                    },
                    {
                        "username": "wming9310",
                        "content": "Is it the weekend already?"
                    },
                    {
                        "username": "abhijeetkushwaha",
                        "content": "hint op\\n"
                    },
                    {
                        "username": "Romeao",
                        "content": "This question seems broken to me.  Imagine N = 3 and Batteries = [5, 7, 9, 10].  The solver says the answer is 10, but I think it should be 9.\\n\\nWe have 1 extra battery.\\n\\nWe can run to t = 7 with the three biggest batteries.  At that point the power remaining would be [5, 0, 2, 3], so we swap out the 0 with 5.  We can run for 2 more seconds (t = 9).  At that point the batteries are [3, 0, 0, 1].  How do we get to 10 s?"
                    },
                    {
                        "username": "Romeao",
                        "content": "[@Karilli](/Karilli) Yeah I realized this in a slightly different path.  I think what threw me off was the editorial skips over this issue when it says to pick the highest batteries.  My realization was \\n\\nt=0 -> [5, 7, 9, 10]\\nt=1 -> [4, 6, 9, 9]\\nt=4 -> [1, 6, 6, 6]\\nt=10 -> [1, 0, 0, 0]"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The solution described does have a flaw in the situation you\\'ve given.\\n\\nThe flaw is in the step where we remove batteries with runtimes greater than the average. The assumption that removing these batteries will always lead to a longer overall runtime is not necessarily correct.\\n\\nIn your example, we start with an average runtime of 10 (total runtime of 31 divided by 3 slots). Using the current method, the battery with a runtime of 10 is removed first. However, as you rightly pointed out, the optimal strategy would be to use the batteries with runtimes of 10, 9, and 7 first, run the device for 7 units of time, and then replace the depleted battery with the one with a runtime of 5 and run for an additional 2 units of time.\\n\\nThe algorithm fails to consider the possibility of switching out depleted batteries with remaining ones, which is a crucial part of maximizing the runtime in this scenario. \\n\\nTherefore, the solution needs to be revised to account for the possibility of switching batteries after they deplete. This might involve an additional step of sorting the batteries in descending order of runtime and then iteratively checking if replacing the depleted battery with the remaining ones increases the overall runtime."
                    },
                    {
                        "username": "Karilli",
                        "content": "-> start with [5, 7, 9, 10]\\n-> we plug in [5, 9, 10] for 3 minutes, resulting in [2, 7, 6, 7]\\n-> we plug in [2, 7, 7] for 1 minute, resulting in [1, 6, 6, 6]\\n-> we plug in [6, 6, 6] for 6 minutes\\n\\ntotal time 10 minutes, you are left with [1, 0, 0, 0]"
                    },
                    {
                        "username": "deeppatel6071",
                        "content": "why we have to use mid = (left + right +1 )/2 ??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The mid-point calculation `mid = (left + right + 1) / 2` is used when we want to favor the upper half of the search space in our binary search. In other words, when we are implementing an upper-bound binary search.\\n\\nLet\\'s consider this scenario in a binary search:\\n1. When `left = 4` and `right = 5`, if we use `mid = (left + right) / 2`, we get `mid = 4`. In this case, if our condition is not satisfied, we will update `left = mid + 1`, and `left` will become `5`.\\n2. But in the next iteration, if we again calculate `mid` using `mid = (left + right) / 2`, we will get `mid = 5`, and `left` and `mid` would remain `5` indefinitely, causing an infinite loop.\\n\\nHowever, if we use `mid = (left + right + 1) / 2`, in the first iteration `mid` will become `5`, and in the next iteration (assuming `right` doesn\\'t change), `mid` will again be `5`, allowing us to proceed without getting stuck.\\n\\nSo the `+1` in `(left + right + 1) / 2` helps to avoid potential infinite loops by ensuring progress in scenarios where `right - left = 1`. This is a trick that can be useful in certain types of binary search problems, particularly those where you\\'re looking for the upper bound of a range.\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "you can also use right-(right-left)//2\nbut i some post i have read like if we didnt use +1 it causes infinte loop . i dont know that and i havent traced out that yet......"
                    },
                    {
                        "username": "Karthik949",
                        "content": "24/52 cases passes getting TLE error I used heaps.\\n\\nI saw hints showing Binary Search but not sure how to even use Binary search in the scenario? any more hints"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Sure, here is are 2 follow up hints:\n\n1\nThe bounds are 0 and the total amount of charge of all batteries. \n\n2\nFor each point in time you can check if you can run all computer up to that point, by simply dividing the amount of charge each battery can deliver up to that point in time (if you want to check for 5 seconds, a batterie can only deliver 5 units of power, no matter how much total charge that battery has). \n\n(you don't need heaps at all, just clever binary search)"
                    },
                    {
                        "username": "bruh_",
                        "content": "Poor me :( \\nCouldn\\'t figure out whether its possible to run all systems simultaneously, given a run time"
                    }
                ]
            },
            {
                "id": 1989346,
                "content": [
                    {
                        "username": "jason3410",
                        "content": "C\\'mon LeetCode, this is creepily difficult .\\nToday is workday."
                    },
                    {
                        "username": "amitak0707",
                        "content": "Another day another binary."
                    },
                    {
                        "username": "gandharv123",
                        "content": "Can somebody provide list of similar set of questions to ace this pattern of binary search? Thanks in advance"
                    },
                    {
                        "username": "prompt_07",
                        "content": "Koko Eating Bananas (Most IMP)\nKth Smallest Number in Multiplication Table\nMaximum Running Time of N Computers\nMinimize Deviation in Array\nCapacity To Ship Packages Within D Days\nSplit Array Largest Sum\nMaximum Candies Allocated to K Children\nEncrypt and Decrypt Strings"
                    },
                    {
                        "username": "GreenHamHam",
                        "content": "Honestly I am starting to feel more like the hints just fuck me over half the time. \\nI basically figured out the first solution but assumed it wasn\\'t good because of the hint.\\nFuck the hints, I\\'ll just figure these out on my own from now on"
                    },
                    {
                        "username": "wming9310",
                        "content": "Is it the weekend already?"
                    },
                    {
                        "username": "abhijeetkushwaha",
                        "content": "hint op\\n"
                    },
                    {
                        "username": "Romeao",
                        "content": "This question seems broken to me.  Imagine N = 3 and Batteries = [5, 7, 9, 10].  The solver says the answer is 10, but I think it should be 9.\\n\\nWe have 1 extra battery.\\n\\nWe can run to t = 7 with the three biggest batteries.  At that point the power remaining would be [5, 0, 2, 3], so we swap out the 0 with 5.  We can run for 2 more seconds (t = 9).  At that point the batteries are [3, 0, 0, 1].  How do we get to 10 s?"
                    },
                    {
                        "username": "Romeao",
                        "content": "[@Karilli](/Karilli) Yeah I realized this in a slightly different path.  I think what threw me off was the editorial skips over this issue when it says to pick the highest batteries.  My realization was \\n\\nt=0 -> [5, 7, 9, 10]\\nt=1 -> [4, 6, 9, 9]\\nt=4 -> [1, 6, 6, 6]\\nt=10 -> [1, 0, 0, 0]"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The solution described does have a flaw in the situation you\\'ve given.\\n\\nThe flaw is in the step where we remove batteries with runtimes greater than the average. The assumption that removing these batteries will always lead to a longer overall runtime is not necessarily correct.\\n\\nIn your example, we start with an average runtime of 10 (total runtime of 31 divided by 3 slots). Using the current method, the battery with a runtime of 10 is removed first. However, as you rightly pointed out, the optimal strategy would be to use the batteries with runtimes of 10, 9, and 7 first, run the device for 7 units of time, and then replace the depleted battery with the one with a runtime of 5 and run for an additional 2 units of time.\\n\\nThe algorithm fails to consider the possibility of switching out depleted batteries with remaining ones, which is a crucial part of maximizing the runtime in this scenario. \\n\\nTherefore, the solution needs to be revised to account for the possibility of switching batteries after they deplete. This might involve an additional step of sorting the batteries in descending order of runtime and then iteratively checking if replacing the depleted battery with the remaining ones increases the overall runtime."
                    },
                    {
                        "username": "Karilli",
                        "content": "-> start with [5, 7, 9, 10]\\n-> we plug in [5, 9, 10] for 3 minutes, resulting in [2, 7, 6, 7]\\n-> we plug in [2, 7, 7] for 1 minute, resulting in [1, 6, 6, 6]\\n-> we plug in [6, 6, 6] for 6 minutes\\n\\ntotal time 10 minutes, you are left with [1, 0, 0, 0]"
                    },
                    {
                        "username": "deeppatel6071",
                        "content": "why we have to use mid = (left + right +1 )/2 ??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The mid-point calculation `mid = (left + right + 1) / 2` is used when we want to favor the upper half of the search space in our binary search. In other words, when we are implementing an upper-bound binary search.\\n\\nLet\\'s consider this scenario in a binary search:\\n1. When `left = 4` and `right = 5`, if we use `mid = (left + right) / 2`, we get `mid = 4`. In this case, if our condition is not satisfied, we will update `left = mid + 1`, and `left` will become `5`.\\n2. But in the next iteration, if we again calculate `mid` using `mid = (left + right) / 2`, we will get `mid = 5`, and `left` and `mid` would remain `5` indefinitely, causing an infinite loop.\\n\\nHowever, if we use `mid = (left + right + 1) / 2`, in the first iteration `mid` will become `5`, and in the next iteration (assuming `right` doesn\\'t change), `mid` will again be `5`, allowing us to proceed without getting stuck.\\n\\nSo the `+1` in `(left + right + 1) / 2` helps to avoid potential infinite loops by ensuring progress in scenarios where `right - left = 1`. This is a trick that can be useful in certain types of binary search problems, particularly those where you\\'re looking for the upper bound of a range.\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "you can also use right-(right-left)//2\nbut i some post i have read like if we didnt use +1 it causes infinte loop . i dont know that and i havent traced out that yet......"
                    },
                    {
                        "username": "Karthik949",
                        "content": "24/52 cases passes getting TLE error I used heaps.\\n\\nI saw hints showing Binary Search but not sure how to even use Binary search in the scenario? any more hints"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Sure, here is are 2 follow up hints:\n\n1\nThe bounds are 0 and the total amount of charge of all batteries. \n\n2\nFor each point in time you can check if you can run all computer up to that point, by simply dividing the amount of charge each battery can deliver up to that point in time (if you want to check for 5 seconds, a batterie can only deliver 5 units of power, no matter how much total charge that battery has). \n\n(you don't need heaps at all, just clever binary search)"
                    },
                    {
                        "username": "bruh_",
                        "content": "Poor me :( \\nCouldn\\'t figure out whether its possible to run all systems simultaneously, given a run time"
                    }
                ]
            },
            {
                "id": 1989043,
                "content": [
                    {
                        "username": "jason3410",
                        "content": "C\\'mon LeetCode, this is creepily difficult .\\nToday is workday."
                    },
                    {
                        "username": "amitak0707",
                        "content": "Another day another binary."
                    },
                    {
                        "username": "gandharv123",
                        "content": "Can somebody provide list of similar set of questions to ace this pattern of binary search? Thanks in advance"
                    },
                    {
                        "username": "prompt_07",
                        "content": "Koko Eating Bananas (Most IMP)\nKth Smallest Number in Multiplication Table\nMaximum Running Time of N Computers\nMinimize Deviation in Array\nCapacity To Ship Packages Within D Days\nSplit Array Largest Sum\nMaximum Candies Allocated to K Children\nEncrypt and Decrypt Strings"
                    },
                    {
                        "username": "GreenHamHam",
                        "content": "Honestly I am starting to feel more like the hints just fuck me over half the time. \\nI basically figured out the first solution but assumed it wasn\\'t good because of the hint.\\nFuck the hints, I\\'ll just figure these out on my own from now on"
                    },
                    {
                        "username": "wming9310",
                        "content": "Is it the weekend already?"
                    },
                    {
                        "username": "abhijeetkushwaha",
                        "content": "hint op\\n"
                    },
                    {
                        "username": "Romeao",
                        "content": "This question seems broken to me.  Imagine N = 3 and Batteries = [5, 7, 9, 10].  The solver says the answer is 10, but I think it should be 9.\\n\\nWe have 1 extra battery.\\n\\nWe can run to t = 7 with the three biggest batteries.  At that point the power remaining would be [5, 0, 2, 3], so we swap out the 0 with 5.  We can run for 2 more seconds (t = 9).  At that point the batteries are [3, 0, 0, 1].  How do we get to 10 s?"
                    },
                    {
                        "username": "Romeao",
                        "content": "[@Karilli](/Karilli) Yeah I realized this in a slightly different path.  I think what threw me off was the editorial skips over this issue when it says to pick the highest batteries.  My realization was \\n\\nt=0 -> [5, 7, 9, 10]\\nt=1 -> [4, 6, 9, 9]\\nt=4 -> [1, 6, 6, 6]\\nt=10 -> [1, 0, 0, 0]"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The solution described does have a flaw in the situation you\\'ve given.\\n\\nThe flaw is in the step where we remove batteries with runtimes greater than the average. The assumption that removing these batteries will always lead to a longer overall runtime is not necessarily correct.\\n\\nIn your example, we start with an average runtime of 10 (total runtime of 31 divided by 3 slots). Using the current method, the battery with a runtime of 10 is removed first. However, as you rightly pointed out, the optimal strategy would be to use the batteries with runtimes of 10, 9, and 7 first, run the device for 7 units of time, and then replace the depleted battery with the one with a runtime of 5 and run for an additional 2 units of time.\\n\\nThe algorithm fails to consider the possibility of switching out depleted batteries with remaining ones, which is a crucial part of maximizing the runtime in this scenario. \\n\\nTherefore, the solution needs to be revised to account for the possibility of switching batteries after they deplete. This might involve an additional step of sorting the batteries in descending order of runtime and then iteratively checking if replacing the depleted battery with the remaining ones increases the overall runtime."
                    },
                    {
                        "username": "Karilli",
                        "content": "-> start with [5, 7, 9, 10]\\n-> we plug in [5, 9, 10] for 3 minutes, resulting in [2, 7, 6, 7]\\n-> we plug in [2, 7, 7] for 1 minute, resulting in [1, 6, 6, 6]\\n-> we plug in [6, 6, 6] for 6 minutes\\n\\ntotal time 10 minutes, you are left with [1, 0, 0, 0]"
                    },
                    {
                        "username": "deeppatel6071",
                        "content": "why we have to use mid = (left + right +1 )/2 ??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The mid-point calculation `mid = (left + right + 1) / 2` is used when we want to favor the upper half of the search space in our binary search. In other words, when we are implementing an upper-bound binary search.\\n\\nLet\\'s consider this scenario in a binary search:\\n1. When `left = 4` and `right = 5`, if we use `mid = (left + right) / 2`, we get `mid = 4`. In this case, if our condition is not satisfied, we will update `left = mid + 1`, and `left` will become `5`.\\n2. But in the next iteration, if we again calculate `mid` using `mid = (left + right) / 2`, we will get `mid = 5`, and `left` and `mid` would remain `5` indefinitely, causing an infinite loop.\\n\\nHowever, if we use `mid = (left + right + 1) / 2`, in the first iteration `mid` will become `5`, and in the next iteration (assuming `right` doesn\\'t change), `mid` will again be `5`, allowing us to proceed without getting stuck.\\n\\nSo the `+1` in `(left + right + 1) / 2` helps to avoid potential infinite loops by ensuring progress in scenarios where `right - left = 1`. This is a trick that can be useful in certain types of binary search problems, particularly those where you\\'re looking for the upper bound of a range.\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "you can also use right-(right-left)//2\nbut i some post i have read like if we didnt use +1 it causes infinte loop . i dont know that and i havent traced out that yet......"
                    },
                    {
                        "username": "Karthik949",
                        "content": "24/52 cases passes getting TLE error I used heaps.\\n\\nI saw hints showing Binary Search but not sure how to even use Binary search in the scenario? any more hints"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Sure, here is are 2 follow up hints:\n\n1\nThe bounds are 0 and the total amount of charge of all batteries. \n\n2\nFor each point in time you can check if you can run all computer up to that point, by simply dividing the amount of charge each battery can deliver up to that point in time (if you want to check for 5 seconds, a batterie can only deliver 5 units of power, no matter how much total charge that battery has). \n\n(you don't need heaps at all, just clever binary search)"
                    },
                    {
                        "username": "bruh_",
                        "content": "Poor me :( \\nCouldn\\'t figure out whether its possible to run all systems simultaneously, given a run time"
                    }
                ]
            },
            {
                "id": 1988990,
                "content": [
                    {
                        "username": "jason3410",
                        "content": "C\\'mon LeetCode, this is creepily difficult .\\nToday is workday."
                    },
                    {
                        "username": "amitak0707",
                        "content": "Another day another binary."
                    },
                    {
                        "username": "gandharv123",
                        "content": "Can somebody provide list of similar set of questions to ace this pattern of binary search? Thanks in advance"
                    },
                    {
                        "username": "prompt_07",
                        "content": "Koko Eating Bananas (Most IMP)\nKth Smallest Number in Multiplication Table\nMaximum Running Time of N Computers\nMinimize Deviation in Array\nCapacity To Ship Packages Within D Days\nSplit Array Largest Sum\nMaximum Candies Allocated to K Children\nEncrypt and Decrypt Strings"
                    },
                    {
                        "username": "GreenHamHam",
                        "content": "Honestly I am starting to feel more like the hints just fuck me over half the time. \\nI basically figured out the first solution but assumed it wasn\\'t good because of the hint.\\nFuck the hints, I\\'ll just figure these out on my own from now on"
                    },
                    {
                        "username": "wming9310",
                        "content": "Is it the weekend already?"
                    },
                    {
                        "username": "abhijeetkushwaha",
                        "content": "hint op\\n"
                    },
                    {
                        "username": "Romeao",
                        "content": "This question seems broken to me.  Imagine N = 3 and Batteries = [5, 7, 9, 10].  The solver says the answer is 10, but I think it should be 9.\\n\\nWe have 1 extra battery.\\n\\nWe can run to t = 7 with the three biggest batteries.  At that point the power remaining would be [5, 0, 2, 3], so we swap out the 0 with 5.  We can run for 2 more seconds (t = 9).  At that point the batteries are [3, 0, 0, 1].  How do we get to 10 s?"
                    },
                    {
                        "username": "Romeao",
                        "content": "[@Karilli](/Karilli) Yeah I realized this in a slightly different path.  I think what threw me off was the editorial skips over this issue when it says to pick the highest batteries.  My realization was \\n\\nt=0 -> [5, 7, 9, 10]\\nt=1 -> [4, 6, 9, 9]\\nt=4 -> [1, 6, 6, 6]\\nt=10 -> [1, 0, 0, 0]"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The solution described does have a flaw in the situation you\\'ve given.\\n\\nThe flaw is in the step where we remove batteries with runtimes greater than the average. The assumption that removing these batteries will always lead to a longer overall runtime is not necessarily correct.\\n\\nIn your example, we start with an average runtime of 10 (total runtime of 31 divided by 3 slots). Using the current method, the battery with a runtime of 10 is removed first. However, as you rightly pointed out, the optimal strategy would be to use the batteries with runtimes of 10, 9, and 7 first, run the device for 7 units of time, and then replace the depleted battery with the one with a runtime of 5 and run for an additional 2 units of time.\\n\\nThe algorithm fails to consider the possibility of switching out depleted batteries with remaining ones, which is a crucial part of maximizing the runtime in this scenario. \\n\\nTherefore, the solution needs to be revised to account for the possibility of switching batteries after they deplete. This might involve an additional step of sorting the batteries in descending order of runtime and then iteratively checking if replacing the depleted battery with the remaining ones increases the overall runtime."
                    },
                    {
                        "username": "Karilli",
                        "content": "-> start with [5, 7, 9, 10]\\n-> we plug in [5, 9, 10] for 3 minutes, resulting in [2, 7, 6, 7]\\n-> we plug in [2, 7, 7] for 1 minute, resulting in [1, 6, 6, 6]\\n-> we plug in [6, 6, 6] for 6 minutes\\n\\ntotal time 10 minutes, you are left with [1, 0, 0, 0]"
                    },
                    {
                        "username": "deeppatel6071",
                        "content": "why we have to use mid = (left + right +1 )/2 ??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The mid-point calculation `mid = (left + right + 1) / 2` is used when we want to favor the upper half of the search space in our binary search. In other words, when we are implementing an upper-bound binary search.\\n\\nLet\\'s consider this scenario in a binary search:\\n1. When `left = 4` and `right = 5`, if we use `mid = (left + right) / 2`, we get `mid = 4`. In this case, if our condition is not satisfied, we will update `left = mid + 1`, and `left` will become `5`.\\n2. But in the next iteration, if we again calculate `mid` using `mid = (left + right) / 2`, we will get `mid = 5`, and `left` and `mid` would remain `5` indefinitely, causing an infinite loop.\\n\\nHowever, if we use `mid = (left + right + 1) / 2`, in the first iteration `mid` will become `5`, and in the next iteration (assuming `right` doesn\\'t change), `mid` will again be `5`, allowing us to proceed without getting stuck.\\n\\nSo the `+1` in `(left + right + 1) / 2` helps to avoid potential infinite loops by ensuring progress in scenarios where `right - left = 1`. This is a trick that can be useful in certain types of binary search problems, particularly those where you\\'re looking for the upper bound of a range.\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "you can also use right-(right-left)//2\nbut i some post i have read like if we didnt use +1 it causes infinte loop . i dont know that and i havent traced out that yet......"
                    },
                    {
                        "username": "Karthik949",
                        "content": "24/52 cases passes getting TLE error I used heaps.\\n\\nI saw hints showing Binary Search but not sure how to even use Binary search in the scenario? any more hints"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Sure, here is are 2 follow up hints:\n\n1\nThe bounds are 0 and the total amount of charge of all batteries. \n\n2\nFor each point in time you can check if you can run all computer up to that point, by simply dividing the amount of charge each battery can deliver up to that point in time (if you want to check for 5 seconds, a batterie can only deliver 5 units of power, no matter how much total charge that battery has). \n\n(you don't need heaps at all, just clever binary search)"
                    },
                    {
                        "username": "bruh_",
                        "content": "Poor me :( \\nCouldn\\'t figure out whether its possible to run all systems simultaneously, given a run time"
                    }
                ]
            },
            {
                "id": 1988590,
                "content": [
                    {
                        "username": "jason3410",
                        "content": "C\\'mon LeetCode, this is creepily difficult .\\nToday is workday."
                    },
                    {
                        "username": "amitak0707",
                        "content": "Another day another binary."
                    },
                    {
                        "username": "gandharv123",
                        "content": "Can somebody provide list of similar set of questions to ace this pattern of binary search? Thanks in advance"
                    },
                    {
                        "username": "prompt_07",
                        "content": "Koko Eating Bananas (Most IMP)\nKth Smallest Number in Multiplication Table\nMaximum Running Time of N Computers\nMinimize Deviation in Array\nCapacity To Ship Packages Within D Days\nSplit Array Largest Sum\nMaximum Candies Allocated to K Children\nEncrypt and Decrypt Strings"
                    },
                    {
                        "username": "GreenHamHam",
                        "content": "Honestly I am starting to feel more like the hints just fuck me over half the time. \\nI basically figured out the first solution but assumed it wasn\\'t good because of the hint.\\nFuck the hints, I\\'ll just figure these out on my own from now on"
                    },
                    {
                        "username": "wming9310",
                        "content": "Is it the weekend already?"
                    },
                    {
                        "username": "abhijeetkushwaha",
                        "content": "hint op\\n"
                    },
                    {
                        "username": "Romeao",
                        "content": "This question seems broken to me.  Imagine N = 3 and Batteries = [5, 7, 9, 10].  The solver says the answer is 10, but I think it should be 9.\\n\\nWe have 1 extra battery.\\n\\nWe can run to t = 7 with the three biggest batteries.  At that point the power remaining would be [5, 0, 2, 3], so we swap out the 0 with 5.  We can run for 2 more seconds (t = 9).  At that point the batteries are [3, 0, 0, 1].  How do we get to 10 s?"
                    },
                    {
                        "username": "Romeao",
                        "content": "[@Karilli](/Karilli) Yeah I realized this in a slightly different path.  I think what threw me off was the editorial skips over this issue when it says to pick the highest batteries.  My realization was \\n\\nt=0 -> [5, 7, 9, 10]\\nt=1 -> [4, 6, 9, 9]\\nt=4 -> [1, 6, 6, 6]\\nt=10 -> [1, 0, 0, 0]"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re correct. The solution described does have a flaw in the situation you\\'ve given.\\n\\nThe flaw is in the step where we remove batteries with runtimes greater than the average. The assumption that removing these batteries will always lead to a longer overall runtime is not necessarily correct.\\n\\nIn your example, we start with an average runtime of 10 (total runtime of 31 divided by 3 slots). Using the current method, the battery with a runtime of 10 is removed first. However, as you rightly pointed out, the optimal strategy would be to use the batteries with runtimes of 10, 9, and 7 first, run the device for 7 units of time, and then replace the depleted battery with the one with a runtime of 5 and run for an additional 2 units of time.\\n\\nThe algorithm fails to consider the possibility of switching out depleted batteries with remaining ones, which is a crucial part of maximizing the runtime in this scenario. \\n\\nTherefore, the solution needs to be revised to account for the possibility of switching batteries after they deplete. This might involve an additional step of sorting the batteries in descending order of runtime and then iteratively checking if replacing the depleted battery with the remaining ones increases the overall runtime."
                    },
                    {
                        "username": "Karilli",
                        "content": "-> start with [5, 7, 9, 10]\\n-> we plug in [5, 9, 10] for 3 minutes, resulting in [2, 7, 6, 7]\\n-> we plug in [2, 7, 7] for 1 minute, resulting in [1, 6, 6, 6]\\n-> we plug in [6, 6, 6] for 6 minutes\\n\\ntotal time 10 minutes, you are left with [1, 0, 0, 0]"
                    },
                    {
                        "username": "deeppatel6071",
                        "content": "why we have to use mid = (left + right +1 )/2 ??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The mid-point calculation `mid = (left + right + 1) / 2` is used when we want to favor the upper half of the search space in our binary search. In other words, when we are implementing an upper-bound binary search.\\n\\nLet\\'s consider this scenario in a binary search:\\n1. When `left = 4` and `right = 5`, if we use `mid = (left + right) / 2`, we get `mid = 4`. In this case, if our condition is not satisfied, we will update `left = mid + 1`, and `left` will become `5`.\\n2. But in the next iteration, if we again calculate `mid` using `mid = (left + right) / 2`, we will get `mid = 5`, and `left` and `mid` would remain `5` indefinitely, causing an infinite loop.\\n\\nHowever, if we use `mid = (left + right + 1) / 2`, in the first iteration `mid` will become `5`, and in the next iteration (assuming `right` doesn\\'t change), `mid` will again be `5`, allowing us to proceed without getting stuck.\\n\\nSo the `+1` in `(left + right + 1) / 2` helps to avoid potential infinite loops by ensuring progress in scenarios where `right - left = 1`. This is a trick that can be useful in certain types of binary search problems, particularly those where you\\'re looking for the upper bound of a range.\\n"
                    },
                    {
                        "username": "charant587",
                        "content": "you can also use right-(right-left)//2\nbut i some post i have read like if we didnt use +1 it causes infinte loop . i dont know that and i havent traced out that yet......"
                    },
                    {
                        "username": "Karthik949",
                        "content": "24/52 cases passes getting TLE error I used heaps.\\n\\nI saw hints showing Binary Search but not sure how to even use Binary search in the scenario? any more hints"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Sure, here is are 2 follow up hints:\n\n1\nThe bounds are 0 and the total amount of charge of all batteries. \n\n2\nFor each point in time you can check if you can run all computer up to that point, by simply dividing the amount of charge each battery can deliver up to that point in time (if you want to check for 5 seconds, a batterie can only deliver 5 units of power, no matter how much total charge that battery has). \n\n(you don't need heaps at all, just clever binary search)"
                    },
                    {
                        "username": "bruh_",
                        "content": "Poor me :( \\nCouldn\\'t figure out whether its possible to run all systems simultaneously, given a run time"
                    }
                ]
            },
            {
                "id": 1988565,
                "content": [
                    {
                        "username": "thrillobit",
                        "content": "Easy coding part. Interesting algo work."
                    },
                    {
                        "username": "dfa",
                        "content": "after choosing which batteries to put in the computers, i\\'m not sure how to tell how many mins to leave them in"
                    },
                    {
                        "username": "fritzbred",
                        "content": "You could just switch the batteries over and over again and try to bring all batteries on the same level so you use all the battery power and you dont leave power behind."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Won\\'t that be O(NlogN + T*NlogN) ? where NlogN for sorting where N is the number of computers and T*NlogN ( where T is the max duration in minute ) as at every minute you\\'ll need to recompute N batteries remaining charge ( i.e. Subtract 1 min from each battery ) and then sort the result of batteries again to find top N batteries? Did I get this wrong?"
                    },
                    {
                        "username": "Anuj74151",
                        "content": "`n=3`\\n`[5, 3, 3, 2]`\\nOutput is 4 but I think it should be 3. Can anyone explain why the output is 4 ?\\n"
                    },
                    {
                        "username": "codease",
                        "content": "Numbers show allocated capacity followed by any action & numbers in parenthesis indicating original capacity & index of the battery being used\n\n```\n2(5[0])     2(3[1])                     2(3[2])                       (unused, 2[3])                \n1(5[0])     1(change, 2[3]) ``\\         1(3[2])                       (unused, 3[1])\n1(5[0])     1(restore, 3[1])     ` ->   1(change, 2[3])\n```"
                    },
                    {
                        "username": "user3721S",
                        "content": "We want to spread the use of the batteries evenly to maximize the energy.\\n- Use a priority queue (highest value at top)\\n- Pop  N (number of computers) from the queue, and reduce each value by 1 (N log N)\\n- From the N popped elements, return those who still have juice (i.e. the number after reducing it by 1, is > 0)\\n- Loop until the queue size < N\\n- The number of loops is the number of minutes"
                    },
                    {
                        "username": "webguru77777",
                        "content": "That will cause TLE. Because the time complexity is O(NlogN* M) where M = 10^9"
                    },
                    {
                        "username": "kazulerdo",
                        "content": "deja vu"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "Ah !This problem surely drained my brain after I  have given almost 2 hr ."
                    },
                    {
                        "username": "charant587",
                        "content": "try these test cases \\n3\\n[10,10,5,3]\\n4\\n[8, 1, 4, 8]\\n2\\n[31,87,85,44,47,25]\\n1\\n[53,96]"
                    },
                    {
                        "username": "isharth",
                        "content": "Can someone please explain why the ans is 9 for this testcase?\\nn = 3\\nbatteries = [2, 8, 8, 9]\\n"
                    },
                    {
                        "username": "RahulBishnoi00029",
                        "content": "use the 1st battery with 2 computer for 1 - 1 minute ,and last battery (9) for one computer.\\ninitially connect the 3 computer with 2 8 9 batteries. then after one minute batteries remaing 1 7 8 . now remove the 1st battery and connect new battery(8) Now series 8 7 8.\\nNow computer runs for 7 minute. Then exchange the drained battary with remaining 1 battery. Thus it runs again for 1 minute, So total time (1+7+1=9)."
                    },
                    {
                        "username": "mkishan",
                        "content": "Can someone please explain me why this is not a DP problem, since there is cost optimization involved, I thought its DP"
                    },
                    {
                        "username": "Karilli",
                        "content": "dp is not about cost optimization it is about subproblems\\nfor example for solving fib(n), you need to first solve fib(n-1) and fib(n-2)\\n\\nthere are no subproblems in this task => if it was dp you would solve maxRunTime(n) with something like maxRunTime(n-1) or maxRunTime(batteries) with maxRunTime(batteries[1:]), etc..."
                    }
                ]
            },
            {
                "id": 1988091,
                "content": [
                    {
                        "username": "thrillobit",
                        "content": "Easy coding part. Interesting algo work."
                    },
                    {
                        "username": "dfa",
                        "content": "after choosing which batteries to put in the computers, i\\'m not sure how to tell how many mins to leave them in"
                    },
                    {
                        "username": "fritzbred",
                        "content": "You could just switch the batteries over and over again and try to bring all batteries on the same level so you use all the battery power and you dont leave power behind."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Won\\'t that be O(NlogN + T*NlogN) ? where NlogN for sorting where N is the number of computers and T*NlogN ( where T is the max duration in minute ) as at every minute you\\'ll need to recompute N batteries remaining charge ( i.e. Subtract 1 min from each battery ) and then sort the result of batteries again to find top N batteries? Did I get this wrong?"
                    },
                    {
                        "username": "Anuj74151",
                        "content": "`n=3`\\n`[5, 3, 3, 2]`\\nOutput is 4 but I think it should be 3. Can anyone explain why the output is 4 ?\\n"
                    },
                    {
                        "username": "codease",
                        "content": "Numbers show allocated capacity followed by any action & numbers in parenthesis indicating original capacity & index of the battery being used\n\n```\n2(5[0])     2(3[1])                     2(3[2])                       (unused, 2[3])                \n1(5[0])     1(change, 2[3]) ``\\         1(3[2])                       (unused, 3[1])\n1(5[0])     1(restore, 3[1])     ` ->   1(change, 2[3])\n```"
                    },
                    {
                        "username": "user3721S",
                        "content": "We want to spread the use of the batteries evenly to maximize the energy.\\n- Use a priority queue (highest value at top)\\n- Pop  N (number of computers) from the queue, and reduce each value by 1 (N log N)\\n- From the N popped elements, return those who still have juice (i.e. the number after reducing it by 1, is > 0)\\n- Loop until the queue size < N\\n- The number of loops is the number of minutes"
                    },
                    {
                        "username": "webguru77777",
                        "content": "That will cause TLE. Because the time complexity is O(NlogN* M) where M = 10^9"
                    },
                    {
                        "username": "kazulerdo",
                        "content": "deja vu"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "Ah !This problem surely drained my brain after I  have given almost 2 hr ."
                    },
                    {
                        "username": "charant587",
                        "content": "try these test cases \\n3\\n[10,10,5,3]\\n4\\n[8, 1, 4, 8]\\n2\\n[31,87,85,44,47,25]\\n1\\n[53,96]"
                    },
                    {
                        "username": "isharth",
                        "content": "Can someone please explain why the ans is 9 for this testcase?\\nn = 3\\nbatteries = [2, 8, 8, 9]\\n"
                    },
                    {
                        "username": "RahulBishnoi00029",
                        "content": "use the 1st battery with 2 computer for 1 - 1 minute ,and last battery (9) for one computer.\\ninitially connect the 3 computer with 2 8 9 batteries. then after one minute batteries remaing 1 7 8 . now remove the 1st battery and connect new battery(8) Now series 8 7 8.\\nNow computer runs for 7 minute. Then exchange the drained battary with remaining 1 battery. Thus it runs again for 1 minute, So total time (1+7+1=9)."
                    },
                    {
                        "username": "mkishan",
                        "content": "Can someone please explain me why this is not a DP problem, since there is cost optimization involved, I thought its DP"
                    },
                    {
                        "username": "Karilli",
                        "content": "dp is not about cost optimization it is about subproblems\\nfor example for solving fib(n), you need to first solve fib(n-1) and fib(n-2)\\n\\nthere are no subproblems in this task => if it was dp you would solve maxRunTime(n) with something like maxRunTime(n-1) or maxRunTime(batteries) with maxRunTime(batteries[1:]), etc..."
                    }
                ]
            },
            {
                "id": 1988009,
                "content": [
                    {
                        "username": "thrillobit",
                        "content": "Easy coding part. Interesting algo work."
                    },
                    {
                        "username": "dfa",
                        "content": "after choosing which batteries to put in the computers, i\\'m not sure how to tell how many mins to leave them in"
                    },
                    {
                        "username": "fritzbred",
                        "content": "You could just switch the batteries over and over again and try to bring all batteries on the same level so you use all the battery power and you dont leave power behind."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Won\\'t that be O(NlogN + T*NlogN) ? where NlogN for sorting where N is the number of computers and T*NlogN ( where T is the max duration in minute ) as at every minute you\\'ll need to recompute N batteries remaining charge ( i.e. Subtract 1 min from each battery ) and then sort the result of batteries again to find top N batteries? Did I get this wrong?"
                    },
                    {
                        "username": "Anuj74151",
                        "content": "`n=3`\\n`[5, 3, 3, 2]`\\nOutput is 4 but I think it should be 3. Can anyone explain why the output is 4 ?\\n"
                    },
                    {
                        "username": "codease",
                        "content": "Numbers show allocated capacity followed by any action & numbers in parenthesis indicating original capacity & index of the battery being used\n\n```\n2(5[0])     2(3[1])                     2(3[2])                       (unused, 2[3])                \n1(5[0])     1(change, 2[3]) ``\\         1(3[2])                       (unused, 3[1])\n1(5[0])     1(restore, 3[1])     ` ->   1(change, 2[3])\n```"
                    },
                    {
                        "username": "user3721S",
                        "content": "We want to spread the use of the batteries evenly to maximize the energy.\\n- Use a priority queue (highest value at top)\\n- Pop  N (number of computers) from the queue, and reduce each value by 1 (N log N)\\n- From the N popped elements, return those who still have juice (i.e. the number after reducing it by 1, is > 0)\\n- Loop until the queue size < N\\n- The number of loops is the number of minutes"
                    },
                    {
                        "username": "webguru77777",
                        "content": "That will cause TLE. Because the time complexity is O(NlogN* M) where M = 10^9"
                    },
                    {
                        "username": "kazulerdo",
                        "content": "deja vu"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "Ah !This problem surely drained my brain after I  have given almost 2 hr ."
                    },
                    {
                        "username": "charant587",
                        "content": "try these test cases \\n3\\n[10,10,5,3]\\n4\\n[8, 1, 4, 8]\\n2\\n[31,87,85,44,47,25]\\n1\\n[53,96]"
                    },
                    {
                        "username": "isharth",
                        "content": "Can someone please explain why the ans is 9 for this testcase?\\nn = 3\\nbatteries = [2, 8, 8, 9]\\n"
                    },
                    {
                        "username": "RahulBishnoi00029",
                        "content": "use the 1st battery with 2 computer for 1 - 1 minute ,and last battery (9) for one computer.\\ninitially connect the 3 computer with 2 8 9 batteries. then after one minute batteries remaing 1 7 8 . now remove the 1st battery and connect new battery(8) Now series 8 7 8.\\nNow computer runs for 7 minute. Then exchange the drained battary with remaining 1 battery. Thus it runs again for 1 minute, So total time (1+7+1=9)."
                    },
                    {
                        "username": "mkishan",
                        "content": "Can someone please explain me why this is not a DP problem, since there is cost optimization involved, I thought its DP"
                    },
                    {
                        "username": "Karilli",
                        "content": "dp is not about cost optimization it is about subproblems\\nfor example for solving fib(n), you need to first solve fib(n-1) and fib(n-2)\\n\\nthere are no subproblems in this task => if it was dp you would solve maxRunTime(n) with something like maxRunTime(n-1) or maxRunTime(batteries) with maxRunTime(batteries[1:]), etc..."
                    }
                ]
            },
            {
                "id": 1990563,
                "content": [
                    {
                        "username": "thrillobit",
                        "content": "Easy coding part. Interesting algo work."
                    },
                    {
                        "username": "dfa",
                        "content": "after choosing which batteries to put in the computers, i\\'m not sure how to tell how many mins to leave them in"
                    },
                    {
                        "username": "fritzbred",
                        "content": "You could just switch the batteries over and over again and try to bring all batteries on the same level so you use all the battery power and you dont leave power behind."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Won\\'t that be O(NlogN + T*NlogN) ? where NlogN for sorting where N is the number of computers and T*NlogN ( where T is the max duration in minute ) as at every minute you\\'ll need to recompute N batteries remaining charge ( i.e. Subtract 1 min from each battery ) and then sort the result of batteries again to find top N batteries? Did I get this wrong?"
                    },
                    {
                        "username": "Anuj74151",
                        "content": "`n=3`\\n`[5, 3, 3, 2]`\\nOutput is 4 but I think it should be 3. Can anyone explain why the output is 4 ?\\n"
                    },
                    {
                        "username": "codease",
                        "content": "Numbers show allocated capacity followed by any action & numbers in parenthesis indicating original capacity & index of the battery being used\n\n```\n2(5[0])     2(3[1])                     2(3[2])                       (unused, 2[3])                \n1(5[0])     1(change, 2[3]) ``\\         1(3[2])                       (unused, 3[1])\n1(5[0])     1(restore, 3[1])     ` ->   1(change, 2[3])\n```"
                    },
                    {
                        "username": "user3721S",
                        "content": "We want to spread the use of the batteries evenly to maximize the energy.\\n- Use a priority queue (highest value at top)\\n- Pop  N (number of computers) from the queue, and reduce each value by 1 (N log N)\\n- From the N popped elements, return those who still have juice (i.e. the number after reducing it by 1, is > 0)\\n- Loop until the queue size < N\\n- The number of loops is the number of minutes"
                    },
                    {
                        "username": "webguru77777",
                        "content": "That will cause TLE. Because the time complexity is O(NlogN* M) where M = 10^9"
                    },
                    {
                        "username": "kazulerdo",
                        "content": "deja vu"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "Ah !This problem surely drained my brain after I  have given almost 2 hr ."
                    },
                    {
                        "username": "charant587",
                        "content": "try these test cases \\n3\\n[10,10,5,3]\\n4\\n[8, 1, 4, 8]\\n2\\n[31,87,85,44,47,25]\\n1\\n[53,96]"
                    },
                    {
                        "username": "isharth",
                        "content": "Can someone please explain why the ans is 9 for this testcase?\\nn = 3\\nbatteries = [2, 8, 8, 9]\\n"
                    },
                    {
                        "username": "RahulBishnoi00029",
                        "content": "use the 1st battery with 2 computer for 1 - 1 minute ,and last battery (9) for one computer.\\ninitially connect the 3 computer with 2 8 9 batteries. then after one minute batteries remaing 1 7 8 . now remove the 1st battery and connect new battery(8) Now series 8 7 8.\\nNow computer runs for 7 minute. Then exchange the drained battary with remaining 1 battery. Thus it runs again for 1 minute, So total time (1+7+1=9)."
                    },
                    {
                        "username": "mkishan",
                        "content": "Can someone please explain me why this is not a DP problem, since there is cost optimization involved, I thought its DP"
                    },
                    {
                        "username": "Karilli",
                        "content": "dp is not about cost optimization it is about subproblems\\nfor example for solving fib(n), you need to first solve fib(n-1) and fib(n-2)\\n\\nthere are no subproblems in this task => if it was dp you would solve maxRunTime(n) with something like maxRunTime(n-1) or maxRunTime(batteries) with maxRunTime(batteries[1:]), etc..."
                    }
                ]
            },
            {
                "id": 1990271,
                "content": [
                    {
                        "username": "thrillobit",
                        "content": "Easy coding part. Interesting algo work."
                    },
                    {
                        "username": "dfa",
                        "content": "after choosing which batteries to put in the computers, i\\'m not sure how to tell how many mins to leave them in"
                    },
                    {
                        "username": "fritzbred",
                        "content": "You could just switch the batteries over and over again and try to bring all batteries on the same level so you use all the battery power and you dont leave power behind."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Won\\'t that be O(NlogN + T*NlogN) ? where NlogN for sorting where N is the number of computers and T*NlogN ( where T is the max duration in minute ) as at every minute you\\'ll need to recompute N batteries remaining charge ( i.e. Subtract 1 min from each battery ) and then sort the result of batteries again to find top N batteries? Did I get this wrong?"
                    },
                    {
                        "username": "Anuj74151",
                        "content": "`n=3`\\n`[5, 3, 3, 2]`\\nOutput is 4 but I think it should be 3. Can anyone explain why the output is 4 ?\\n"
                    },
                    {
                        "username": "codease",
                        "content": "Numbers show allocated capacity followed by any action & numbers in parenthesis indicating original capacity & index of the battery being used\n\n```\n2(5[0])     2(3[1])                     2(3[2])                       (unused, 2[3])                \n1(5[0])     1(change, 2[3]) ``\\         1(3[2])                       (unused, 3[1])\n1(5[0])     1(restore, 3[1])     ` ->   1(change, 2[3])\n```"
                    },
                    {
                        "username": "user3721S",
                        "content": "We want to spread the use of the batteries evenly to maximize the energy.\\n- Use a priority queue (highest value at top)\\n- Pop  N (number of computers) from the queue, and reduce each value by 1 (N log N)\\n- From the N popped elements, return those who still have juice (i.e. the number after reducing it by 1, is > 0)\\n- Loop until the queue size < N\\n- The number of loops is the number of minutes"
                    },
                    {
                        "username": "webguru77777",
                        "content": "That will cause TLE. Because the time complexity is O(NlogN* M) where M = 10^9"
                    },
                    {
                        "username": "kazulerdo",
                        "content": "deja vu"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "Ah !This problem surely drained my brain after I  have given almost 2 hr ."
                    },
                    {
                        "username": "charant587",
                        "content": "try these test cases \\n3\\n[10,10,5,3]\\n4\\n[8, 1, 4, 8]\\n2\\n[31,87,85,44,47,25]\\n1\\n[53,96]"
                    },
                    {
                        "username": "isharth",
                        "content": "Can someone please explain why the ans is 9 for this testcase?\\nn = 3\\nbatteries = [2, 8, 8, 9]\\n"
                    },
                    {
                        "username": "RahulBishnoi00029",
                        "content": "use the 1st battery with 2 computer for 1 - 1 minute ,and last battery (9) for one computer.\\ninitially connect the 3 computer with 2 8 9 batteries. then after one minute batteries remaing 1 7 8 . now remove the 1st battery and connect new battery(8) Now series 8 7 8.\\nNow computer runs for 7 minute. Then exchange the drained battary with remaining 1 battery. Thus it runs again for 1 minute, So total time (1+7+1=9)."
                    },
                    {
                        "username": "mkishan",
                        "content": "Can someone please explain me why this is not a DP problem, since there is cost optimization involved, I thought its DP"
                    },
                    {
                        "username": "Karilli",
                        "content": "dp is not about cost optimization it is about subproblems\\nfor example for solving fib(n), you need to first solve fib(n-1) and fib(n-2)\\n\\nthere are no subproblems in this task => if it was dp you would solve maxRunTime(n) with something like maxRunTime(n-1) or maxRunTime(batteries) with maxRunTime(batteries[1:]), etc..."
                    }
                ]
            },
            {
                "id": 1989392,
                "content": [
                    {
                        "username": "thrillobit",
                        "content": "Easy coding part. Interesting algo work."
                    },
                    {
                        "username": "dfa",
                        "content": "after choosing which batteries to put in the computers, i\\'m not sure how to tell how many mins to leave them in"
                    },
                    {
                        "username": "fritzbred",
                        "content": "You could just switch the batteries over and over again and try to bring all batteries on the same level so you use all the battery power and you dont leave power behind."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Won\\'t that be O(NlogN + T*NlogN) ? where NlogN for sorting where N is the number of computers and T*NlogN ( where T is the max duration in minute ) as at every minute you\\'ll need to recompute N batteries remaining charge ( i.e. Subtract 1 min from each battery ) and then sort the result of batteries again to find top N batteries? Did I get this wrong?"
                    },
                    {
                        "username": "Anuj74151",
                        "content": "`n=3`\\n`[5, 3, 3, 2]`\\nOutput is 4 but I think it should be 3. Can anyone explain why the output is 4 ?\\n"
                    },
                    {
                        "username": "codease",
                        "content": "Numbers show allocated capacity followed by any action & numbers in parenthesis indicating original capacity & index of the battery being used\n\n```\n2(5[0])     2(3[1])                     2(3[2])                       (unused, 2[3])                \n1(5[0])     1(change, 2[3]) ``\\         1(3[2])                       (unused, 3[1])\n1(5[0])     1(restore, 3[1])     ` ->   1(change, 2[3])\n```"
                    },
                    {
                        "username": "user3721S",
                        "content": "We want to spread the use of the batteries evenly to maximize the energy.\\n- Use a priority queue (highest value at top)\\n- Pop  N (number of computers) from the queue, and reduce each value by 1 (N log N)\\n- From the N popped elements, return those who still have juice (i.e. the number after reducing it by 1, is > 0)\\n- Loop until the queue size < N\\n- The number of loops is the number of minutes"
                    },
                    {
                        "username": "webguru77777",
                        "content": "That will cause TLE. Because the time complexity is O(NlogN* M) where M = 10^9"
                    },
                    {
                        "username": "kazulerdo",
                        "content": "deja vu"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "Ah !This problem surely drained my brain after I  have given almost 2 hr ."
                    },
                    {
                        "username": "charant587",
                        "content": "try these test cases \\n3\\n[10,10,5,3]\\n4\\n[8, 1, 4, 8]\\n2\\n[31,87,85,44,47,25]\\n1\\n[53,96]"
                    },
                    {
                        "username": "isharth",
                        "content": "Can someone please explain why the ans is 9 for this testcase?\\nn = 3\\nbatteries = [2, 8, 8, 9]\\n"
                    },
                    {
                        "username": "RahulBishnoi00029",
                        "content": "use the 1st battery with 2 computer for 1 - 1 minute ,and last battery (9) for one computer.\\ninitially connect the 3 computer with 2 8 9 batteries. then after one minute batteries remaing 1 7 8 . now remove the 1st battery and connect new battery(8) Now series 8 7 8.\\nNow computer runs for 7 minute. Then exchange the drained battary with remaining 1 battery. Thus it runs again for 1 minute, So total time (1+7+1=9)."
                    },
                    {
                        "username": "mkishan",
                        "content": "Can someone please explain me why this is not a DP problem, since there is cost optimization involved, I thought its DP"
                    },
                    {
                        "username": "Karilli",
                        "content": "dp is not about cost optimization it is about subproblems\\nfor example for solving fib(n), you need to first solve fib(n-1) and fib(n-2)\\n\\nthere are no subproblems in this task => if it was dp you would solve maxRunTime(n) with something like maxRunTime(n-1) or maxRunTime(batteries) with maxRunTime(batteries[1:]), etc..."
                    }
                ]
            },
            {
                "id": 1989261,
                "content": [
                    {
                        "username": "thrillobit",
                        "content": "Easy coding part. Interesting algo work."
                    },
                    {
                        "username": "dfa",
                        "content": "after choosing which batteries to put in the computers, i\\'m not sure how to tell how many mins to leave them in"
                    },
                    {
                        "username": "fritzbred",
                        "content": "You could just switch the batteries over and over again and try to bring all batteries on the same level so you use all the battery power and you dont leave power behind."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Won\\'t that be O(NlogN + T*NlogN) ? where NlogN for sorting where N is the number of computers and T*NlogN ( where T is the max duration in minute ) as at every minute you\\'ll need to recompute N batteries remaining charge ( i.e. Subtract 1 min from each battery ) and then sort the result of batteries again to find top N batteries? Did I get this wrong?"
                    },
                    {
                        "username": "Anuj74151",
                        "content": "`n=3`\\n`[5, 3, 3, 2]`\\nOutput is 4 but I think it should be 3. Can anyone explain why the output is 4 ?\\n"
                    },
                    {
                        "username": "codease",
                        "content": "Numbers show allocated capacity followed by any action & numbers in parenthesis indicating original capacity & index of the battery being used\n\n```\n2(5[0])     2(3[1])                     2(3[2])                       (unused, 2[3])                \n1(5[0])     1(change, 2[3]) ``\\         1(3[2])                       (unused, 3[1])\n1(5[0])     1(restore, 3[1])     ` ->   1(change, 2[3])\n```"
                    },
                    {
                        "username": "user3721S",
                        "content": "We want to spread the use of the batteries evenly to maximize the energy.\\n- Use a priority queue (highest value at top)\\n- Pop  N (number of computers) from the queue, and reduce each value by 1 (N log N)\\n- From the N popped elements, return those who still have juice (i.e. the number after reducing it by 1, is > 0)\\n- Loop until the queue size < N\\n- The number of loops is the number of minutes"
                    },
                    {
                        "username": "webguru77777",
                        "content": "That will cause TLE. Because the time complexity is O(NlogN* M) where M = 10^9"
                    },
                    {
                        "username": "kazulerdo",
                        "content": "deja vu"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "Ah !This problem surely drained my brain after I  have given almost 2 hr ."
                    },
                    {
                        "username": "charant587",
                        "content": "try these test cases \\n3\\n[10,10,5,3]\\n4\\n[8, 1, 4, 8]\\n2\\n[31,87,85,44,47,25]\\n1\\n[53,96]"
                    },
                    {
                        "username": "isharth",
                        "content": "Can someone please explain why the ans is 9 for this testcase?\\nn = 3\\nbatteries = [2, 8, 8, 9]\\n"
                    },
                    {
                        "username": "RahulBishnoi00029",
                        "content": "use the 1st battery with 2 computer for 1 - 1 minute ,and last battery (9) for one computer.\\ninitially connect the 3 computer with 2 8 9 batteries. then after one minute batteries remaing 1 7 8 . now remove the 1st battery and connect new battery(8) Now series 8 7 8.\\nNow computer runs for 7 minute. Then exchange the drained battary with remaining 1 battery. Thus it runs again for 1 minute, So total time (1+7+1=9)."
                    },
                    {
                        "username": "mkishan",
                        "content": "Can someone please explain me why this is not a DP problem, since there is cost optimization involved, I thought its DP"
                    },
                    {
                        "username": "Karilli",
                        "content": "dp is not about cost optimization it is about subproblems\\nfor example for solving fib(n), you need to first solve fib(n-1) and fib(n-2)\\n\\nthere are no subproblems in this task => if it was dp you would solve maxRunTime(n) with something like maxRunTime(n-1) or maxRunTime(batteries) with maxRunTime(batteries[1:]), etc..."
                    }
                ]
            },
            {
                "id": 1989039,
                "content": [
                    {
                        "username": "thrillobit",
                        "content": "Easy coding part. Interesting algo work."
                    },
                    {
                        "username": "dfa",
                        "content": "after choosing which batteries to put in the computers, i\\'m not sure how to tell how many mins to leave them in"
                    },
                    {
                        "username": "fritzbred",
                        "content": "You could just switch the batteries over and over again and try to bring all batteries on the same level so you use all the battery power and you dont leave power behind."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Won\\'t that be O(NlogN + T*NlogN) ? where NlogN for sorting where N is the number of computers and T*NlogN ( where T is the max duration in minute ) as at every minute you\\'ll need to recompute N batteries remaining charge ( i.e. Subtract 1 min from each battery ) and then sort the result of batteries again to find top N batteries? Did I get this wrong?"
                    },
                    {
                        "username": "Anuj74151",
                        "content": "`n=3`\\n`[5, 3, 3, 2]`\\nOutput is 4 but I think it should be 3. Can anyone explain why the output is 4 ?\\n"
                    },
                    {
                        "username": "codease",
                        "content": "Numbers show allocated capacity followed by any action & numbers in parenthesis indicating original capacity & index of the battery being used\n\n```\n2(5[0])     2(3[1])                     2(3[2])                       (unused, 2[3])                \n1(5[0])     1(change, 2[3]) ``\\         1(3[2])                       (unused, 3[1])\n1(5[0])     1(restore, 3[1])     ` ->   1(change, 2[3])\n```"
                    },
                    {
                        "username": "user3721S",
                        "content": "We want to spread the use of the batteries evenly to maximize the energy.\\n- Use a priority queue (highest value at top)\\n- Pop  N (number of computers) from the queue, and reduce each value by 1 (N log N)\\n- From the N popped elements, return those who still have juice (i.e. the number after reducing it by 1, is > 0)\\n- Loop until the queue size < N\\n- The number of loops is the number of minutes"
                    },
                    {
                        "username": "webguru77777",
                        "content": "That will cause TLE. Because the time complexity is O(NlogN* M) where M = 10^9"
                    },
                    {
                        "username": "kazulerdo",
                        "content": "deja vu"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "Ah !This problem surely drained my brain after I  have given almost 2 hr ."
                    },
                    {
                        "username": "charant587",
                        "content": "try these test cases \\n3\\n[10,10,5,3]\\n4\\n[8, 1, 4, 8]\\n2\\n[31,87,85,44,47,25]\\n1\\n[53,96]"
                    },
                    {
                        "username": "isharth",
                        "content": "Can someone please explain why the ans is 9 for this testcase?\\nn = 3\\nbatteries = [2, 8, 8, 9]\\n"
                    },
                    {
                        "username": "RahulBishnoi00029",
                        "content": "use the 1st battery with 2 computer for 1 - 1 minute ,and last battery (9) for one computer.\\ninitially connect the 3 computer with 2 8 9 batteries. then after one minute batteries remaing 1 7 8 . now remove the 1st battery and connect new battery(8) Now series 8 7 8.\\nNow computer runs for 7 minute. Then exchange the drained battary with remaining 1 battery. Thus it runs again for 1 minute, So total time (1+7+1=9)."
                    },
                    {
                        "username": "mkishan",
                        "content": "Can someone please explain me why this is not a DP problem, since there is cost optimization involved, I thought its DP"
                    },
                    {
                        "username": "Karilli",
                        "content": "dp is not about cost optimization it is about subproblems\\nfor example for solving fib(n), you need to first solve fib(n-1) and fib(n-2)\\n\\nthere are no subproblems in this task => if it was dp you would solve maxRunTime(n) with something like maxRunTime(n-1) or maxRunTime(batteries) with maxRunTime(batteries[1:]), etc..."
                    }
                ]
            },
            {
                "id": 1989016,
                "content": [
                    {
                        "username": "thrillobit",
                        "content": "Easy coding part. Interesting algo work."
                    },
                    {
                        "username": "dfa",
                        "content": "after choosing which batteries to put in the computers, i\\'m not sure how to tell how many mins to leave them in"
                    },
                    {
                        "username": "fritzbred",
                        "content": "You could just switch the batteries over and over again and try to bring all batteries on the same level so you use all the battery power and you dont leave power behind."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Won\\'t that be O(NlogN + T*NlogN) ? where NlogN for sorting where N is the number of computers and T*NlogN ( where T is the max duration in minute ) as at every minute you\\'ll need to recompute N batteries remaining charge ( i.e. Subtract 1 min from each battery ) and then sort the result of batteries again to find top N batteries? Did I get this wrong?"
                    },
                    {
                        "username": "Anuj74151",
                        "content": "`n=3`\\n`[5, 3, 3, 2]`\\nOutput is 4 but I think it should be 3. Can anyone explain why the output is 4 ?\\n"
                    },
                    {
                        "username": "codease",
                        "content": "Numbers show allocated capacity followed by any action & numbers in parenthesis indicating original capacity & index of the battery being used\n\n```\n2(5[0])     2(3[1])                     2(3[2])                       (unused, 2[3])                \n1(5[0])     1(change, 2[3]) ``\\         1(3[2])                       (unused, 3[1])\n1(5[0])     1(restore, 3[1])     ` ->   1(change, 2[3])\n```"
                    },
                    {
                        "username": "user3721S",
                        "content": "We want to spread the use of the batteries evenly to maximize the energy.\\n- Use a priority queue (highest value at top)\\n- Pop  N (number of computers) from the queue, and reduce each value by 1 (N log N)\\n- From the N popped elements, return those who still have juice (i.e. the number after reducing it by 1, is > 0)\\n- Loop until the queue size < N\\n- The number of loops is the number of minutes"
                    },
                    {
                        "username": "webguru77777",
                        "content": "That will cause TLE. Because the time complexity is O(NlogN* M) where M = 10^9"
                    },
                    {
                        "username": "kazulerdo",
                        "content": "deja vu"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "Ah !This problem surely drained my brain after I  have given almost 2 hr ."
                    },
                    {
                        "username": "charant587",
                        "content": "try these test cases \\n3\\n[10,10,5,3]\\n4\\n[8, 1, 4, 8]\\n2\\n[31,87,85,44,47,25]\\n1\\n[53,96]"
                    },
                    {
                        "username": "isharth",
                        "content": "Can someone please explain why the ans is 9 for this testcase?\\nn = 3\\nbatteries = [2, 8, 8, 9]\\n"
                    },
                    {
                        "username": "RahulBishnoi00029",
                        "content": "use the 1st battery with 2 computer for 1 - 1 minute ,and last battery (9) for one computer.\\ninitially connect the 3 computer with 2 8 9 batteries. then after one minute batteries remaing 1 7 8 . now remove the 1st battery and connect new battery(8) Now series 8 7 8.\\nNow computer runs for 7 minute. Then exchange the drained battary with remaining 1 battery. Thus it runs again for 1 minute, So total time (1+7+1=9)."
                    },
                    {
                        "username": "mkishan",
                        "content": "Can someone please explain me why this is not a DP problem, since there is cost optimization involved, I thought its DP"
                    },
                    {
                        "username": "Karilli",
                        "content": "dp is not about cost optimization it is about subproblems\\nfor example for solving fib(n), you need to first solve fib(n-1) and fib(n-2)\\n\\nthere are no subproblems in this task => if it was dp you would solve maxRunTime(n) with something like maxRunTime(n-1) or maxRunTime(batteries) with maxRunTime(batteries[1:]), etc..."
                    }
                ]
            },
            {
                "id": 1988902,
                "content": [
                    {
                        "username": "thrillobit",
                        "content": "Easy coding part. Interesting algo work."
                    },
                    {
                        "username": "dfa",
                        "content": "after choosing which batteries to put in the computers, i\\'m not sure how to tell how many mins to leave them in"
                    },
                    {
                        "username": "fritzbred",
                        "content": "You could just switch the batteries over and over again and try to bring all batteries on the same level so you use all the battery power and you dont leave power behind."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Won\\'t that be O(NlogN + T*NlogN) ? where NlogN for sorting where N is the number of computers and T*NlogN ( where T is the max duration in minute ) as at every minute you\\'ll need to recompute N batteries remaining charge ( i.e. Subtract 1 min from each battery ) and then sort the result of batteries again to find top N batteries? Did I get this wrong?"
                    },
                    {
                        "username": "Anuj74151",
                        "content": "`n=3`\\n`[5, 3, 3, 2]`\\nOutput is 4 but I think it should be 3. Can anyone explain why the output is 4 ?\\n"
                    },
                    {
                        "username": "codease",
                        "content": "Numbers show allocated capacity followed by any action & numbers in parenthesis indicating original capacity & index of the battery being used\n\n```\n2(5[0])     2(3[1])                     2(3[2])                       (unused, 2[3])                \n1(5[0])     1(change, 2[3]) ``\\         1(3[2])                       (unused, 3[1])\n1(5[0])     1(restore, 3[1])     ` ->   1(change, 2[3])\n```"
                    },
                    {
                        "username": "user3721S",
                        "content": "We want to spread the use of the batteries evenly to maximize the energy.\\n- Use a priority queue (highest value at top)\\n- Pop  N (number of computers) from the queue, and reduce each value by 1 (N log N)\\n- From the N popped elements, return those who still have juice (i.e. the number after reducing it by 1, is > 0)\\n- Loop until the queue size < N\\n- The number of loops is the number of minutes"
                    },
                    {
                        "username": "webguru77777",
                        "content": "That will cause TLE. Because the time complexity is O(NlogN* M) where M = 10^9"
                    },
                    {
                        "username": "kazulerdo",
                        "content": "deja vu"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "Ah !This problem surely drained my brain after I  have given almost 2 hr ."
                    },
                    {
                        "username": "charant587",
                        "content": "try these test cases \\n3\\n[10,10,5,3]\\n4\\n[8, 1, 4, 8]\\n2\\n[31,87,85,44,47,25]\\n1\\n[53,96]"
                    },
                    {
                        "username": "isharth",
                        "content": "Can someone please explain why the ans is 9 for this testcase?\\nn = 3\\nbatteries = [2, 8, 8, 9]\\n"
                    },
                    {
                        "username": "RahulBishnoi00029",
                        "content": "use the 1st battery with 2 computer for 1 - 1 minute ,and last battery (9) for one computer.\\ninitially connect the 3 computer with 2 8 9 batteries. then after one minute batteries remaing 1 7 8 . now remove the 1st battery and connect new battery(8) Now series 8 7 8.\\nNow computer runs for 7 minute. Then exchange the drained battary with remaining 1 battery. Thus it runs again for 1 minute, So total time (1+7+1=9)."
                    },
                    {
                        "username": "mkishan",
                        "content": "Can someone please explain me why this is not a DP problem, since there is cost optimization involved, I thought its DP"
                    },
                    {
                        "username": "Karilli",
                        "content": "dp is not about cost optimization it is about subproblems\\nfor example for solving fib(n), you need to first solve fib(n-1) and fib(n-2)\\n\\nthere are no subproblems in this task => if it was dp you would solve maxRunTime(n) with something like maxRunTime(n-1) or maxRunTime(batteries) with maxRunTime(batteries[1:]), etc..."
                    }
                ]
            },
            {
                "id": 1988842,
                "content": [
                    {
                        "username": "RushN24",
                        "content": "Can\\'t we just wire the batteries in parallel and make this a whole lot easier? "
                    },
                    {
                        "username": "EntityPlantt",
                        "content": "I mean yeah but idk\\nSee the [editorial](editorial)"
                    },
                    {
                        "username": "Karilli",
                        "content": "Everyone got the time complexity of binary search wrong, it is $$O(nlog(s/n))$$, where $$s = sum(batteries)$$.\nIn the worst case scenario every battery power equals to $$10^9, len(batteries) = 10^5, n = 1$$, that means about $$10^5 * log2(10^{14})$$ operations instead of $$10^5 * log2(10^5)$$.\n\nI think that even the editorial guys got it kinda wrong, because saying $$max(batteries) >> len(batteries), n$$, therefore comlexity is $$O(nlog*max(batteries))$$ is at best missleading.\n\nfor reference:\n$$log2(10^{14}) ~= 46.50699332842307$$\n$$log2(10^9) ~= 29.897352853986263$$\n$$log2(10^5) ~= 16.609640474436812$$\n\nedit: On second thought, editorial is correct. You could say time complexity is $$O(nlog(m*k/n))$$, where $$k = max(batteries), m = len(batteries)$$. Because $$k > m$$ in worst case, it is also $$O(nlog(k*k/n))$$, the worst case is $$n = 1$$ => $$O(nlog(k^2))$$ => $$O(2*nlog(k))$$ => $$O(nlogk)$$"
                    },
                    {
                        "username": "mostafaelite7",
                        "content": "u know that the author is evil when u see in the two examples n=2, and all batteries are at same energy levels :D :D "
                    },
                    {
                        "username": "Chetansinha",
                        "content": "More type of Binary search (like allocate book) question :-\n1. Split Array Largest Sum\n2. Kth Smallest Number in Multiplication Table\n3. Find K-th Smallest Pair Distance\n4. Swim in Rising Water\n5. Koko Eating Bananas\n6. Capacity To Ship Packages Within D Days\n7. Ugly Number III\n8. Maximum Candies Allocated to K Children\n9. Find the Smallest Divisor Given a Threshold\n10. Encrypt and Decrypt Strings\n11. Minimum Number of Days to Make m Bouquets\n12. Magnetic Force Between Two Balls\n13. Minimum Limit of Balls in a Bag\n14. Minimum Speed to Arrive on Time\n15. Maximum Number of Removable Characters\n16. Minimized Maximum of Products Distributed to Any Store\n17. Minimum Time to Complete Trips\n18. Maximum Tastiness of Candy Basket\n19. Maximize the Minimum Powered City\n20. Minimize the Maximum of Two Arrays\n21. House Robber IV"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Apply binary search on time instances and \\nfor a particular time instance ,\\n first remove all computer which can run with batteries with time>= time instance (which you are checking )  for remaining computers take the average of remaining batteries with remaining number of computer . If it is >= given time instance then it can be a possible ans ...\\n"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Why would we take Battery from Another computer? Won\\'t it be Useless as we want all N computers to operate simultaneously? If we remove battery from One computer, that computer would still require battery... The only possible task should be to insert a new battery from remaining set."
                    },
                    {
                        "username": "Gfreitag",
                        "content": "It is a toy problem"
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "as it is mention there would be no time lapse between switching batteries, so the time in removing and injecting new batteries in negligble.."
                    },
                    {
                        "username": "psionl0",
                        "content": "This is weird.\nNormally a binary search involves a calculation like ``mid = (lo + hi) / 2`` or ``mid = lo + (hi - lo) / 2``. Yet no matter how I tampered with the boundaries, I couldn't pass all test cases. Then I looked at the editorial solution and it had the formula written like ``mid = hi - (hi - lo) / 2``. When I used that as my calculation, suddenly all of my test cases passed! Evidently the round off works the other way when you do the formula this way. I would have never guessed this version of the formula would make a difference. It leads me to wonder whether the official answers are really the correct ones."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@JHolz](/JHolz) Yes, this has been an educational experience for me. I have done quite a few binary search questions now and I have never had to worry about the ``mid`` formula before. I get why you need to round upwards - otherwise you get stuck in an endless loop. I guess I will need a little more practice to get an appreciation of when to reverse the ``mid`` formula. Thanks for the additional info."
                    },
                    {
                        "username": "JHolz",
                        "content": "As u already determined, the formula in the editorial rounds `m` up. If you round `m` down instead, you have to use `l = m + 1`  and `r = m`, so that the binary search always terminates. That can still work, but it changes the search to \"whats the smallest timeframe, that does not fullfill the requirements\" and u have to subtract by one in the end (if the answer is greater zero), to get the correct answer to the original question (and also increase our starting `r` by one)."
                    },
                    {
                        "username": "TERNION2205",
                        "content": "My solution works fine (as it seems to me)\\nbut on test case 14, it gives TLE\\nOn ide it does take time but upon checking the answer is correct.\\nAny tips on how can we minimize the search space?\\nThanks in advance"
                    },
                    {
                        "username": "iamcodebug",
                        "content": "What search space did you used ?? "
                    },
                    {
                        "username": "pavanbagade28",
                        "content": "n=3 ; batteries=[10,10,3,5]\\nanswer should be 9, but expected is 8 , please explain."
                    },
                    {
                        "username": "pavanbagade28",
                        "content": "Okay  understood i ignored this(you can run all the n computers simultaneously.)"
                    },
                    {
                        "username": "ak_3101",
                        "content": "can we do this with maxheap?\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "I used this simulation approach using maxHeap and this passed 40/52 testcases. But failed on this one\\n```\\nn=12\\n[11,89,16,32,70,67,35,35,31,24,41,29,6,53,78,83]\\n```\\n\\nCode - \\n```\\ntypedef vector<int> vi;\\ntypedef vector<vi> vvi;\\n\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& b) {\\n        priority_queue<int> pq(b.begin(), b.end());\\n        long long runtime = 0;\\n        while(pq.size() >= n) {\\n            vi bat;\\n            int bats = n;\\n            int minVal = INT_MAX;\\n            while(bats--) {\\n                int val = pq.top();\\n                pq.pop();\\n                minVal = min(minVal, val);\\n                bat.push_back(val);\\n            }\\n             if(minVal > 1) {\\n                minVal--;\\n                runtime += minVal;\\n                for(int val: bat) {\\n                    pq.push(val-minVal);\\n                }\\n            } else {\\n                runtime++;\\n                for(int val: bat) {\\n                    if(val != 1)\\n                        pq.push(val-1);\\n                }\\n            }\\n        }\\n        return runtime;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dfa",
                        "content": "[@ak_3101](/ak_3101) this strategy timed out for me"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@ak_3101](/ak_3101) ans would never be more than (sum)/n;\\nso we would pop all the elements which have power >= (sum of all power)/n.\\nnow we have batteries which can drain so we now have subproblem of remaining power and remaining batteries,\\nnow out of these remaining batteries, max time upto which we can power is (sum remaining)/n remaining;"
                    },
                    {
                        "username": "fli033",
                        "content": "i think it take too long"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@garvit_001](/garvit_001)  yeah we can maintain a max heap and keep subtracting 1 from top n elements and use heapify to again get max element on the top, its complexity should be nlog n, problem, I couldnt code it though, let me know if you have."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "i was thinking the same,, using max-min heaps"
                    }
                ]
            },
            {
                "id": 1988818,
                "content": [
                    {
                        "username": "RushN24",
                        "content": "Can\\'t we just wire the batteries in parallel and make this a whole lot easier? "
                    },
                    {
                        "username": "EntityPlantt",
                        "content": "I mean yeah but idk\\nSee the [editorial](editorial)"
                    },
                    {
                        "username": "Karilli",
                        "content": "Everyone got the time complexity of binary search wrong, it is $$O(nlog(s/n))$$, where $$s = sum(batteries)$$.\nIn the worst case scenario every battery power equals to $$10^9, len(batteries) = 10^5, n = 1$$, that means about $$10^5 * log2(10^{14})$$ operations instead of $$10^5 * log2(10^5)$$.\n\nI think that even the editorial guys got it kinda wrong, because saying $$max(batteries) >> len(batteries), n$$, therefore comlexity is $$O(nlog*max(batteries))$$ is at best missleading.\n\nfor reference:\n$$log2(10^{14}) ~= 46.50699332842307$$\n$$log2(10^9) ~= 29.897352853986263$$\n$$log2(10^5) ~= 16.609640474436812$$\n\nedit: On second thought, editorial is correct. You could say time complexity is $$O(nlog(m*k/n))$$, where $$k = max(batteries), m = len(batteries)$$. Because $$k > m$$ in worst case, it is also $$O(nlog(k*k/n))$$, the worst case is $$n = 1$$ => $$O(nlog(k^2))$$ => $$O(2*nlog(k))$$ => $$O(nlogk)$$"
                    },
                    {
                        "username": "mostafaelite7",
                        "content": "u know that the author is evil when u see in the two examples n=2, and all batteries are at same energy levels :D :D "
                    },
                    {
                        "username": "Chetansinha",
                        "content": "More type of Binary search (like allocate book) question :-\n1. Split Array Largest Sum\n2. Kth Smallest Number in Multiplication Table\n3. Find K-th Smallest Pair Distance\n4. Swim in Rising Water\n5. Koko Eating Bananas\n6. Capacity To Ship Packages Within D Days\n7. Ugly Number III\n8. Maximum Candies Allocated to K Children\n9. Find the Smallest Divisor Given a Threshold\n10. Encrypt and Decrypt Strings\n11. Minimum Number of Days to Make m Bouquets\n12. Magnetic Force Between Two Balls\n13. Minimum Limit of Balls in a Bag\n14. Minimum Speed to Arrive on Time\n15. Maximum Number of Removable Characters\n16. Minimized Maximum of Products Distributed to Any Store\n17. Minimum Time to Complete Trips\n18. Maximum Tastiness of Candy Basket\n19. Maximize the Minimum Powered City\n20. Minimize the Maximum of Two Arrays\n21. House Robber IV"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Apply binary search on time instances and \\nfor a particular time instance ,\\n first remove all computer which can run with batteries with time>= time instance (which you are checking )  for remaining computers take the average of remaining batteries with remaining number of computer . If it is >= given time instance then it can be a possible ans ...\\n"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Why would we take Battery from Another computer? Won\\'t it be Useless as we want all N computers to operate simultaneously? If we remove battery from One computer, that computer would still require battery... The only possible task should be to insert a new battery from remaining set."
                    },
                    {
                        "username": "Gfreitag",
                        "content": "It is a toy problem"
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "as it is mention there would be no time lapse between switching batteries, so the time in removing and injecting new batteries in negligble.."
                    },
                    {
                        "username": "psionl0",
                        "content": "This is weird.\nNormally a binary search involves a calculation like ``mid = (lo + hi) / 2`` or ``mid = lo + (hi - lo) / 2``. Yet no matter how I tampered with the boundaries, I couldn't pass all test cases. Then I looked at the editorial solution and it had the formula written like ``mid = hi - (hi - lo) / 2``. When I used that as my calculation, suddenly all of my test cases passed! Evidently the round off works the other way when you do the formula this way. I would have never guessed this version of the formula would make a difference. It leads me to wonder whether the official answers are really the correct ones."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@JHolz](/JHolz) Yes, this has been an educational experience for me. I have done quite a few binary search questions now and I have never had to worry about the ``mid`` formula before. I get why you need to round upwards - otherwise you get stuck in an endless loop. I guess I will need a little more practice to get an appreciation of when to reverse the ``mid`` formula. Thanks for the additional info."
                    },
                    {
                        "username": "JHolz",
                        "content": "As u already determined, the formula in the editorial rounds `m` up. If you round `m` down instead, you have to use `l = m + 1`  and `r = m`, so that the binary search always terminates. That can still work, but it changes the search to \"whats the smallest timeframe, that does not fullfill the requirements\" and u have to subtract by one in the end (if the answer is greater zero), to get the correct answer to the original question (and also increase our starting `r` by one)."
                    },
                    {
                        "username": "TERNION2205",
                        "content": "My solution works fine (as it seems to me)\\nbut on test case 14, it gives TLE\\nOn ide it does take time but upon checking the answer is correct.\\nAny tips on how can we minimize the search space?\\nThanks in advance"
                    },
                    {
                        "username": "iamcodebug",
                        "content": "What search space did you used ?? "
                    },
                    {
                        "username": "pavanbagade28",
                        "content": "n=3 ; batteries=[10,10,3,5]\\nanswer should be 9, but expected is 8 , please explain."
                    },
                    {
                        "username": "pavanbagade28",
                        "content": "Okay  understood i ignored this(you can run all the n computers simultaneously.)"
                    },
                    {
                        "username": "ak_3101",
                        "content": "can we do this with maxheap?\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "I used this simulation approach using maxHeap and this passed 40/52 testcases. But failed on this one\\n```\\nn=12\\n[11,89,16,32,70,67,35,35,31,24,41,29,6,53,78,83]\\n```\\n\\nCode - \\n```\\ntypedef vector<int> vi;\\ntypedef vector<vi> vvi;\\n\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& b) {\\n        priority_queue<int> pq(b.begin(), b.end());\\n        long long runtime = 0;\\n        while(pq.size() >= n) {\\n            vi bat;\\n            int bats = n;\\n            int minVal = INT_MAX;\\n            while(bats--) {\\n                int val = pq.top();\\n                pq.pop();\\n                minVal = min(minVal, val);\\n                bat.push_back(val);\\n            }\\n             if(minVal > 1) {\\n                minVal--;\\n                runtime += minVal;\\n                for(int val: bat) {\\n                    pq.push(val-minVal);\\n                }\\n            } else {\\n                runtime++;\\n                for(int val: bat) {\\n                    if(val != 1)\\n                        pq.push(val-1);\\n                }\\n            }\\n        }\\n        return runtime;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dfa",
                        "content": "[@ak_3101](/ak_3101) this strategy timed out for me"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@ak_3101](/ak_3101) ans would never be more than (sum)/n;\\nso we would pop all the elements which have power >= (sum of all power)/n.\\nnow we have batteries which can drain so we now have subproblem of remaining power and remaining batteries,\\nnow out of these remaining batteries, max time upto which we can power is (sum remaining)/n remaining;"
                    },
                    {
                        "username": "fli033",
                        "content": "i think it take too long"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@garvit_001](/garvit_001)  yeah we can maintain a max heap and keep subtracting 1 from top n elements and use heapify to again get max element on the top, its complexity should be nlog n, problem, I couldnt code it though, let me know if you have."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "i was thinking the same,, using max-min heaps"
                    }
                ]
            },
            {
                "id": 1988634,
                "content": [
                    {
                        "username": "RushN24",
                        "content": "Can\\'t we just wire the batteries in parallel and make this a whole lot easier? "
                    },
                    {
                        "username": "EntityPlantt",
                        "content": "I mean yeah but idk\\nSee the [editorial](editorial)"
                    },
                    {
                        "username": "Karilli",
                        "content": "Everyone got the time complexity of binary search wrong, it is $$O(nlog(s/n))$$, where $$s = sum(batteries)$$.\nIn the worst case scenario every battery power equals to $$10^9, len(batteries) = 10^5, n = 1$$, that means about $$10^5 * log2(10^{14})$$ operations instead of $$10^5 * log2(10^5)$$.\n\nI think that even the editorial guys got it kinda wrong, because saying $$max(batteries) >> len(batteries), n$$, therefore comlexity is $$O(nlog*max(batteries))$$ is at best missleading.\n\nfor reference:\n$$log2(10^{14}) ~= 46.50699332842307$$\n$$log2(10^9) ~= 29.897352853986263$$\n$$log2(10^5) ~= 16.609640474436812$$\n\nedit: On second thought, editorial is correct. You could say time complexity is $$O(nlog(m*k/n))$$, where $$k = max(batteries), m = len(batteries)$$. Because $$k > m$$ in worst case, it is also $$O(nlog(k*k/n))$$, the worst case is $$n = 1$$ => $$O(nlog(k^2))$$ => $$O(2*nlog(k))$$ => $$O(nlogk)$$"
                    },
                    {
                        "username": "mostafaelite7",
                        "content": "u know that the author is evil when u see in the two examples n=2, and all batteries are at same energy levels :D :D "
                    },
                    {
                        "username": "Chetansinha",
                        "content": "More type of Binary search (like allocate book) question :-\n1. Split Array Largest Sum\n2. Kth Smallest Number in Multiplication Table\n3. Find K-th Smallest Pair Distance\n4. Swim in Rising Water\n5. Koko Eating Bananas\n6. Capacity To Ship Packages Within D Days\n7. Ugly Number III\n8. Maximum Candies Allocated to K Children\n9. Find the Smallest Divisor Given a Threshold\n10. Encrypt and Decrypt Strings\n11. Minimum Number of Days to Make m Bouquets\n12. Magnetic Force Between Two Balls\n13. Minimum Limit of Balls in a Bag\n14. Minimum Speed to Arrive on Time\n15. Maximum Number of Removable Characters\n16. Minimized Maximum of Products Distributed to Any Store\n17. Minimum Time to Complete Trips\n18. Maximum Tastiness of Candy Basket\n19. Maximize the Minimum Powered City\n20. Minimize the Maximum of Two Arrays\n21. House Robber IV"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Apply binary search on time instances and \\nfor a particular time instance ,\\n first remove all computer which can run with batteries with time>= time instance (which you are checking )  for remaining computers take the average of remaining batteries with remaining number of computer . If it is >= given time instance then it can be a possible ans ...\\n"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Why would we take Battery from Another computer? Won\\'t it be Useless as we want all N computers to operate simultaneously? If we remove battery from One computer, that computer would still require battery... The only possible task should be to insert a new battery from remaining set."
                    },
                    {
                        "username": "Gfreitag",
                        "content": "It is a toy problem"
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "as it is mention there would be no time lapse between switching batteries, so the time in removing and injecting new batteries in negligble.."
                    },
                    {
                        "username": "psionl0",
                        "content": "This is weird.\nNormally a binary search involves a calculation like ``mid = (lo + hi) / 2`` or ``mid = lo + (hi - lo) / 2``. Yet no matter how I tampered with the boundaries, I couldn't pass all test cases. Then I looked at the editorial solution and it had the formula written like ``mid = hi - (hi - lo) / 2``. When I used that as my calculation, suddenly all of my test cases passed! Evidently the round off works the other way when you do the formula this way. I would have never guessed this version of the formula would make a difference. It leads me to wonder whether the official answers are really the correct ones."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@JHolz](/JHolz) Yes, this has been an educational experience for me. I have done quite a few binary search questions now and I have never had to worry about the ``mid`` formula before. I get why you need to round upwards - otherwise you get stuck in an endless loop. I guess I will need a little more practice to get an appreciation of when to reverse the ``mid`` formula. Thanks for the additional info."
                    },
                    {
                        "username": "JHolz",
                        "content": "As u already determined, the formula in the editorial rounds `m` up. If you round `m` down instead, you have to use `l = m + 1`  and `r = m`, so that the binary search always terminates. That can still work, but it changes the search to \"whats the smallest timeframe, that does not fullfill the requirements\" and u have to subtract by one in the end (if the answer is greater zero), to get the correct answer to the original question (and also increase our starting `r` by one)."
                    },
                    {
                        "username": "TERNION2205",
                        "content": "My solution works fine (as it seems to me)\\nbut on test case 14, it gives TLE\\nOn ide it does take time but upon checking the answer is correct.\\nAny tips on how can we minimize the search space?\\nThanks in advance"
                    },
                    {
                        "username": "iamcodebug",
                        "content": "What search space did you used ?? "
                    },
                    {
                        "username": "pavanbagade28",
                        "content": "n=3 ; batteries=[10,10,3,5]\\nanswer should be 9, but expected is 8 , please explain."
                    },
                    {
                        "username": "pavanbagade28",
                        "content": "Okay  understood i ignored this(you can run all the n computers simultaneously.)"
                    },
                    {
                        "username": "ak_3101",
                        "content": "can we do this with maxheap?\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "I used this simulation approach using maxHeap and this passed 40/52 testcases. But failed on this one\\n```\\nn=12\\n[11,89,16,32,70,67,35,35,31,24,41,29,6,53,78,83]\\n```\\n\\nCode - \\n```\\ntypedef vector<int> vi;\\ntypedef vector<vi> vvi;\\n\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& b) {\\n        priority_queue<int> pq(b.begin(), b.end());\\n        long long runtime = 0;\\n        while(pq.size() >= n) {\\n            vi bat;\\n            int bats = n;\\n            int minVal = INT_MAX;\\n            while(bats--) {\\n                int val = pq.top();\\n                pq.pop();\\n                minVal = min(minVal, val);\\n                bat.push_back(val);\\n            }\\n             if(minVal > 1) {\\n                minVal--;\\n                runtime += minVal;\\n                for(int val: bat) {\\n                    pq.push(val-minVal);\\n                }\\n            } else {\\n                runtime++;\\n                for(int val: bat) {\\n                    if(val != 1)\\n                        pq.push(val-1);\\n                }\\n            }\\n        }\\n        return runtime;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dfa",
                        "content": "[@ak_3101](/ak_3101) this strategy timed out for me"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@ak_3101](/ak_3101) ans would never be more than (sum)/n;\\nso we would pop all the elements which have power >= (sum of all power)/n.\\nnow we have batteries which can drain so we now have subproblem of remaining power and remaining batteries,\\nnow out of these remaining batteries, max time upto which we can power is (sum remaining)/n remaining;"
                    },
                    {
                        "username": "fli033",
                        "content": "i think it take too long"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@garvit_001](/garvit_001)  yeah we can maintain a max heap and keep subtracting 1 from top n elements and use heapify to again get max element on the top, its complexity should be nlog n, problem, I couldnt code it though, let me know if you have."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "i was thinking the same,, using max-min heaps"
                    }
                ]
            },
            {
                "id": 1988609,
                "content": [
                    {
                        "username": "RushN24",
                        "content": "Can\\'t we just wire the batteries in parallel and make this a whole lot easier? "
                    },
                    {
                        "username": "EntityPlantt",
                        "content": "I mean yeah but idk\\nSee the [editorial](editorial)"
                    },
                    {
                        "username": "Karilli",
                        "content": "Everyone got the time complexity of binary search wrong, it is $$O(nlog(s/n))$$, where $$s = sum(batteries)$$.\nIn the worst case scenario every battery power equals to $$10^9, len(batteries) = 10^5, n = 1$$, that means about $$10^5 * log2(10^{14})$$ operations instead of $$10^5 * log2(10^5)$$.\n\nI think that even the editorial guys got it kinda wrong, because saying $$max(batteries) >> len(batteries), n$$, therefore comlexity is $$O(nlog*max(batteries))$$ is at best missleading.\n\nfor reference:\n$$log2(10^{14}) ~= 46.50699332842307$$\n$$log2(10^9) ~= 29.897352853986263$$\n$$log2(10^5) ~= 16.609640474436812$$\n\nedit: On second thought, editorial is correct. You could say time complexity is $$O(nlog(m*k/n))$$, where $$k = max(batteries), m = len(batteries)$$. Because $$k > m$$ in worst case, it is also $$O(nlog(k*k/n))$$, the worst case is $$n = 1$$ => $$O(nlog(k^2))$$ => $$O(2*nlog(k))$$ => $$O(nlogk)$$"
                    },
                    {
                        "username": "mostafaelite7",
                        "content": "u know that the author is evil when u see in the two examples n=2, and all batteries are at same energy levels :D :D "
                    },
                    {
                        "username": "Chetansinha",
                        "content": "More type of Binary search (like allocate book) question :-\n1. Split Array Largest Sum\n2. Kth Smallest Number in Multiplication Table\n3. Find K-th Smallest Pair Distance\n4. Swim in Rising Water\n5. Koko Eating Bananas\n6. Capacity To Ship Packages Within D Days\n7. Ugly Number III\n8. Maximum Candies Allocated to K Children\n9. Find the Smallest Divisor Given a Threshold\n10. Encrypt and Decrypt Strings\n11. Minimum Number of Days to Make m Bouquets\n12. Magnetic Force Between Two Balls\n13. Minimum Limit of Balls in a Bag\n14. Minimum Speed to Arrive on Time\n15. Maximum Number of Removable Characters\n16. Minimized Maximum of Products Distributed to Any Store\n17. Minimum Time to Complete Trips\n18. Maximum Tastiness of Candy Basket\n19. Maximize the Minimum Powered City\n20. Minimize the Maximum of Two Arrays\n21. House Robber IV"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Apply binary search on time instances and \\nfor a particular time instance ,\\n first remove all computer which can run with batteries with time>= time instance (which you are checking )  for remaining computers take the average of remaining batteries with remaining number of computer . If it is >= given time instance then it can be a possible ans ...\\n"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Why would we take Battery from Another computer? Won\\'t it be Useless as we want all N computers to operate simultaneously? If we remove battery from One computer, that computer would still require battery... The only possible task should be to insert a new battery from remaining set."
                    },
                    {
                        "username": "Gfreitag",
                        "content": "It is a toy problem"
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "as it is mention there would be no time lapse between switching batteries, so the time in removing and injecting new batteries in negligble.."
                    },
                    {
                        "username": "psionl0",
                        "content": "This is weird.\nNormally a binary search involves a calculation like ``mid = (lo + hi) / 2`` or ``mid = lo + (hi - lo) / 2``. Yet no matter how I tampered with the boundaries, I couldn't pass all test cases. Then I looked at the editorial solution and it had the formula written like ``mid = hi - (hi - lo) / 2``. When I used that as my calculation, suddenly all of my test cases passed! Evidently the round off works the other way when you do the formula this way. I would have never guessed this version of the formula would make a difference. It leads me to wonder whether the official answers are really the correct ones."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@JHolz](/JHolz) Yes, this has been an educational experience for me. I have done quite a few binary search questions now and I have never had to worry about the ``mid`` formula before. I get why you need to round upwards - otherwise you get stuck in an endless loop. I guess I will need a little more practice to get an appreciation of when to reverse the ``mid`` formula. Thanks for the additional info."
                    },
                    {
                        "username": "JHolz",
                        "content": "As u already determined, the formula in the editorial rounds `m` up. If you round `m` down instead, you have to use `l = m + 1`  and `r = m`, so that the binary search always terminates. That can still work, but it changes the search to \"whats the smallest timeframe, that does not fullfill the requirements\" and u have to subtract by one in the end (if the answer is greater zero), to get the correct answer to the original question (and also increase our starting `r` by one)."
                    },
                    {
                        "username": "TERNION2205",
                        "content": "My solution works fine (as it seems to me)\\nbut on test case 14, it gives TLE\\nOn ide it does take time but upon checking the answer is correct.\\nAny tips on how can we minimize the search space?\\nThanks in advance"
                    },
                    {
                        "username": "iamcodebug",
                        "content": "What search space did you used ?? "
                    },
                    {
                        "username": "pavanbagade28",
                        "content": "n=3 ; batteries=[10,10,3,5]\\nanswer should be 9, but expected is 8 , please explain."
                    },
                    {
                        "username": "pavanbagade28",
                        "content": "Okay  understood i ignored this(you can run all the n computers simultaneously.)"
                    },
                    {
                        "username": "ak_3101",
                        "content": "can we do this with maxheap?\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "I used this simulation approach using maxHeap and this passed 40/52 testcases. But failed on this one\\n```\\nn=12\\n[11,89,16,32,70,67,35,35,31,24,41,29,6,53,78,83]\\n```\\n\\nCode - \\n```\\ntypedef vector<int> vi;\\ntypedef vector<vi> vvi;\\n\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& b) {\\n        priority_queue<int> pq(b.begin(), b.end());\\n        long long runtime = 0;\\n        while(pq.size() >= n) {\\n            vi bat;\\n            int bats = n;\\n            int minVal = INT_MAX;\\n            while(bats--) {\\n                int val = pq.top();\\n                pq.pop();\\n                minVal = min(minVal, val);\\n                bat.push_back(val);\\n            }\\n             if(minVal > 1) {\\n                minVal--;\\n                runtime += minVal;\\n                for(int val: bat) {\\n                    pq.push(val-minVal);\\n                }\\n            } else {\\n                runtime++;\\n                for(int val: bat) {\\n                    if(val != 1)\\n                        pq.push(val-1);\\n                }\\n            }\\n        }\\n        return runtime;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dfa",
                        "content": "[@ak_3101](/ak_3101) this strategy timed out for me"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@ak_3101](/ak_3101) ans would never be more than (sum)/n;\\nso we would pop all the elements which have power >= (sum of all power)/n.\\nnow we have batteries which can drain so we now have subproblem of remaining power and remaining batteries,\\nnow out of these remaining batteries, max time upto which we can power is (sum remaining)/n remaining;"
                    },
                    {
                        "username": "fli033",
                        "content": "i think it take too long"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@garvit_001](/garvit_001)  yeah we can maintain a max heap and keep subtracting 1 from top n elements and use heapify to again get max element on the top, its complexity should be nlog n, problem, I couldnt code it though, let me know if you have."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "i was thinking the same,, using max-min heaps"
                    }
                ]
            },
            {
                "id": 1988576,
                "content": [
                    {
                        "username": "RushN24",
                        "content": "Can\\'t we just wire the batteries in parallel and make this a whole lot easier? "
                    },
                    {
                        "username": "EntityPlantt",
                        "content": "I mean yeah but idk\\nSee the [editorial](editorial)"
                    },
                    {
                        "username": "Karilli",
                        "content": "Everyone got the time complexity of binary search wrong, it is $$O(nlog(s/n))$$, where $$s = sum(batteries)$$.\nIn the worst case scenario every battery power equals to $$10^9, len(batteries) = 10^5, n = 1$$, that means about $$10^5 * log2(10^{14})$$ operations instead of $$10^5 * log2(10^5)$$.\n\nI think that even the editorial guys got it kinda wrong, because saying $$max(batteries) >> len(batteries), n$$, therefore comlexity is $$O(nlog*max(batteries))$$ is at best missleading.\n\nfor reference:\n$$log2(10^{14}) ~= 46.50699332842307$$\n$$log2(10^9) ~= 29.897352853986263$$\n$$log2(10^5) ~= 16.609640474436812$$\n\nedit: On second thought, editorial is correct. You could say time complexity is $$O(nlog(m*k/n))$$, where $$k = max(batteries), m = len(batteries)$$. Because $$k > m$$ in worst case, it is also $$O(nlog(k*k/n))$$, the worst case is $$n = 1$$ => $$O(nlog(k^2))$$ => $$O(2*nlog(k))$$ => $$O(nlogk)$$"
                    },
                    {
                        "username": "mostafaelite7",
                        "content": "u know that the author is evil when u see in the two examples n=2, and all batteries are at same energy levels :D :D "
                    },
                    {
                        "username": "Chetansinha",
                        "content": "More type of Binary search (like allocate book) question :-\n1. Split Array Largest Sum\n2. Kth Smallest Number in Multiplication Table\n3. Find K-th Smallest Pair Distance\n4. Swim in Rising Water\n5. Koko Eating Bananas\n6. Capacity To Ship Packages Within D Days\n7. Ugly Number III\n8. Maximum Candies Allocated to K Children\n9. Find the Smallest Divisor Given a Threshold\n10. Encrypt and Decrypt Strings\n11. Minimum Number of Days to Make m Bouquets\n12. Magnetic Force Between Two Balls\n13. Minimum Limit of Balls in a Bag\n14. Minimum Speed to Arrive on Time\n15. Maximum Number of Removable Characters\n16. Minimized Maximum of Products Distributed to Any Store\n17. Minimum Time to Complete Trips\n18. Maximum Tastiness of Candy Basket\n19. Maximize the Minimum Powered City\n20. Minimize the Maximum of Two Arrays\n21. House Robber IV"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Apply binary search on time instances and \\nfor a particular time instance ,\\n first remove all computer which can run with batteries with time>= time instance (which you are checking )  for remaining computers take the average of remaining batteries with remaining number of computer . If it is >= given time instance then it can be a possible ans ...\\n"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Why would we take Battery from Another computer? Won\\'t it be Useless as we want all N computers to operate simultaneously? If we remove battery from One computer, that computer would still require battery... The only possible task should be to insert a new battery from remaining set."
                    },
                    {
                        "username": "Gfreitag",
                        "content": "It is a toy problem"
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "as it is mention there would be no time lapse between switching batteries, so the time in removing and injecting new batteries in negligble.."
                    },
                    {
                        "username": "psionl0",
                        "content": "This is weird.\nNormally a binary search involves a calculation like ``mid = (lo + hi) / 2`` or ``mid = lo + (hi - lo) / 2``. Yet no matter how I tampered with the boundaries, I couldn't pass all test cases. Then I looked at the editorial solution and it had the formula written like ``mid = hi - (hi - lo) / 2``. When I used that as my calculation, suddenly all of my test cases passed! Evidently the round off works the other way when you do the formula this way. I would have never guessed this version of the formula would make a difference. It leads me to wonder whether the official answers are really the correct ones."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@JHolz](/JHolz) Yes, this has been an educational experience for me. I have done quite a few binary search questions now and I have never had to worry about the ``mid`` formula before. I get why you need to round upwards - otherwise you get stuck in an endless loop. I guess I will need a little more practice to get an appreciation of when to reverse the ``mid`` formula. Thanks for the additional info."
                    },
                    {
                        "username": "JHolz",
                        "content": "As u already determined, the formula in the editorial rounds `m` up. If you round `m` down instead, you have to use `l = m + 1`  and `r = m`, so that the binary search always terminates. That can still work, but it changes the search to \"whats the smallest timeframe, that does not fullfill the requirements\" and u have to subtract by one in the end (if the answer is greater zero), to get the correct answer to the original question (and also increase our starting `r` by one)."
                    },
                    {
                        "username": "TERNION2205",
                        "content": "My solution works fine (as it seems to me)\\nbut on test case 14, it gives TLE\\nOn ide it does take time but upon checking the answer is correct.\\nAny tips on how can we minimize the search space?\\nThanks in advance"
                    },
                    {
                        "username": "iamcodebug",
                        "content": "What search space did you used ?? "
                    },
                    {
                        "username": "pavanbagade28",
                        "content": "n=3 ; batteries=[10,10,3,5]\\nanswer should be 9, but expected is 8 , please explain."
                    },
                    {
                        "username": "pavanbagade28",
                        "content": "Okay  understood i ignored this(you can run all the n computers simultaneously.)"
                    },
                    {
                        "username": "ak_3101",
                        "content": "can we do this with maxheap?\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "I used this simulation approach using maxHeap and this passed 40/52 testcases. But failed on this one\\n```\\nn=12\\n[11,89,16,32,70,67,35,35,31,24,41,29,6,53,78,83]\\n```\\n\\nCode - \\n```\\ntypedef vector<int> vi;\\ntypedef vector<vi> vvi;\\n\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& b) {\\n        priority_queue<int> pq(b.begin(), b.end());\\n        long long runtime = 0;\\n        while(pq.size() >= n) {\\n            vi bat;\\n            int bats = n;\\n            int minVal = INT_MAX;\\n            while(bats--) {\\n                int val = pq.top();\\n                pq.pop();\\n                minVal = min(minVal, val);\\n                bat.push_back(val);\\n            }\\n             if(minVal > 1) {\\n                minVal--;\\n                runtime += minVal;\\n                for(int val: bat) {\\n                    pq.push(val-minVal);\\n                }\\n            } else {\\n                runtime++;\\n                for(int val: bat) {\\n                    if(val != 1)\\n                        pq.push(val-1);\\n                }\\n            }\\n        }\\n        return runtime;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dfa",
                        "content": "[@ak_3101](/ak_3101) this strategy timed out for me"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@ak_3101](/ak_3101) ans would never be more than (sum)/n;\\nso we would pop all the elements which have power >= (sum of all power)/n.\\nnow we have batteries which can drain so we now have subproblem of remaining power and remaining batteries,\\nnow out of these remaining batteries, max time upto which we can power is (sum remaining)/n remaining;"
                    },
                    {
                        "username": "fli033",
                        "content": "i think it take too long"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@garvit_001](/garvit_001)  yeah we can maintain a max heap and keep subtracting 1 from top n elements and use heapify to again get max element on the top, its complexity should be nlog n, problem, I couldnt code it though, let me know if you have."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "i was thinking the same,, using max-min heaps"
                    }
                ]
            },
            {
                "id": 1988479,
                "content": [
                    {
                        "username": "RushN24",
                        "content": "Can\\'t we just wire the batteries in parallel and make this a whole lot easier? "
                    },
                    {
                        "username": "EntityPlantt",
                        "content": "I mean yeah but idk\\nSee the [editorial](editorial)"
                    },
                    {
                        "username": "Karilli",
                        "content": "Everyone got the time complexity of binary search wrong, it is $$O(nlog(s/n))$$, where $$s = sum(batteries)$$.\nIn the worst case scenario every battery power equals to $$10^9, len(batteries) = 10^5, n = 1$$, that means about $$10^5 * log2(10^{14})$$ operations instead of $$10^5 * log2(10^5)$$.\n\nI think that even the editorial guys got it kinda wrong, because saying $$max(batteries) >> len(batteries), n$$, therefore comlexity is $$O(nlog*max(batteries))$$ is at best missleading.\n\nfor reference:\n$$log2(10^{14}) ~= 46.50699332842307$$\n$$log2(10^9) ~= 29.897352853986263$$\n$$log2(10^5) ~= 16.609640474436812$$\n\nedit: On second thought, editorial is correct. You could say time complexity is $$O(nlog(m*k/n))$$, where $$k = max(batteries), m = len(batteries)$$. Because $$k > m$$ in worst case, it is also $$O(nlog(k*k/n))$$, the worst case is $$n = 1$$ => $$O(nlog(k^2))$$ => $$O(2*nlog(k))$$ => $$O(nlogk)$$"
                    },
                    {
                        "username": "mostafaelite7",
                        "content": "u know that the author is evil when u see in the two examples n=2, and all batteries are at same energy levels :D :D "
                    },
                    {
                        "username": "Chetansinha",
                        "content": "More type of Binary search (like allocate book) question :-\n1. Split Array Largest Sum\n2. Kth Smallest Number in Multiplication Table\n3. Find K-th Smallest Pair Distance\n4. Swim in Rising Water\n5. Koko Eating Bananas\n6. Capacity To Ship Packages Within D Days\n7. Ugly Number III\n8. Maximum Candies Allocated to K Children\n9. Find the Smallest Divisor Given a Threshold\n10. Encrypt and Decrypt Strings\n11. Minimum Number of Days to Make m Bouquets\n12. Magnetic Force Between Two Balls\n13. Minimum Limit of Balls in a Bag\n14. Minimum Speed to Arrive on Time\n15. Maximum Number of Removable Characters\n16. Minimized Maximum of Products Distributed to Any Store\n17. Minimum Time to Complete Trips\n18. Maximum Tastiness of Candy Basket\n19. Maximize the Minimum Powered City\n20. Minimize the Maximum of Two Arrays\n21. House Robber IV"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Apply binary search on time instances and \\nfor a particular time instance ,\\n first remove all computer which can run with batteries with time>= time instance (which you are checking )  for remaining computers take the average of remaining batteries with remaining number of computer . If it is >= given time instance then it can be a possible ans ...\\n"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Why would we take Battery from Another computer? Won\\'t it be Useless as we want all N computers to operate simultaneously? If we remove battery from One computer, that computer would still require battery... The only possible task should be to insert a new battery from remaining set."
                    },
                    {
                        "username": "Gfreitag",
                        "content": "It is a toy problem"
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "as it is mention there would be no time lapse between switching batteries, so the time in removing and injecting new batteries in negligble.."
                    },
                    {
                        "username": "psionl0",
                        "content": "This is weird.\nNormally a binary search involves a calculation like ``mid = (lo + hi) / 2`` or ``mid = lo + (hi - lo) / 2``. Yet no matter how I tampered with the boundaries, I couldn't pass all test cases. Then I looked at the editorial solution and it had the formula written like ``mid = hi - (hi - lo) / 2``. When I used that as my calculation, suddenly all of my test cases passed! Evidently the round off works the other way when you do the formula this way. I would have never guessed this version of the formula would make a difference. It leads me to wonder whether the official answers are really the correct ones."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@JHolz](/JHolz) Yes, this has been an educational experience for me. I have done quite a few binary search questions now and I have never had to worry about the ``mid`` formula before. I get why you need to round upwards - otherwise you get stuck in an endless loop. I guess I will need a little more practice to get an appreciation of when to reverse the ``mid`` formula. Thanks for the additional info."
                    },
                    {
                        "username": "JHolz",
                        "content": "As u already determined, the formula in the editorial rounds `m` up. If you round `m` down instead, you have to use `l = m + 1`  and `r = m`, so that the binary search always terminates. That can still work, but it changes the search to \"whats the smallest timeframe, that does not fullfill the requirements\" and u have to subtract by one in the end (if the answer is greater zero), to get the correct answer to the original question (and also increase our starting `r` by one)."
                    },
                    {
                        "username": "TERNION2205",
                        "content": "My solution works fine (as it seems to me)\\nbut on test case 14, it gives TLE\\nOn ide it does take time but upon checking the answer is correct.\\nAny tips on how can we minimize the search space?\\nThanks in advance"
                    },
                    {
                        "username": "iamcodebug",
                        "content": "What search space did you used ?? "
                    },
                    {
                        "username": "pavanbagade28",
                        "content": "n=3 ; batteries=[10,10,3,5]\\nanswer should be 9, but expected is 8 , please explain."
                    },
                    {
                        "username": "pavanbagade28",
                        "content": "Okay  understood i ignored this(you can run all the n computers simultaneously.)"
                    },
                    {
                        "username": "ak_3101",
                        "content": "can we do this with maxheap?\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "I used this simulation approach using maxHeap and this passed 40/52 testcases. But failed on this one\\n```\\nn=12\\n[11,89,16,32,70,67,35,35,31,24,41,29,6,53,78,83]\\n```\\n\\nCode - \\n```\\ntypedef vector<int> vi;\\ntypedef vector<vi> vvi;\\n\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& b) {\\n        priority_queue<int> pq(b.begin(), b.end());\\n        long long runtime = 0;\\n        while(pq.size() >= n) {\\n            vi bat;\\n            int bats = n;\\n            int minVal = INT_MAX;\\n            while(bats--) {\\n                int val = pq.top();\\n                pq.pop();\\n                minVal = min(minVal, val);\\n                bat.push_back(val);\\n            }\\n             if(minVal > 1) {\\n                minVal--;\\n                runtime += minVal;\\n                for(int val: bat) {\\n                    pq.push(val-minVal);\\n                }\\n            } else {\\n                runtime++;\\n                for(int val: bat) {\\n                    if(val != 1)\\n                        pq.push(val-1);\\n                }\\n            }\\n        }\\n        return runtime;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dfa",
                        "content": "[@ak_3101](/ak_3101) this strategy timed out for me"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@ak_3101](/ak_3101) ans would never be more than (sum)/n;\\nso we would pop all the elements which have power >= (sum of all power)/n.\\nnow we have batteries which can drain so we now have subproblem of remaining power and remaining batteries,\\nnow out of these remaining batteries, max time upto which we can power is (sum remaining)/n remaining;"
                    },
                    {
                        "username": "fli033",
                        "content": "i think it take too long"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@garvit_001](/garvit_001)  yeah we can maintain a max heap and keep subtracting 1 from top n elements and use heapify to again get max element on the top, its complexity should be nlog n, problem, I couldnt code it though, let me know if you have."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "i was thinking the same,, using max-min heaps"
                    }
                ]
            },
            {
                "id": 1988463,
                "content": [
                    {
                        "username": "RushN24",
                        "content": "Can\\'t we just wire the batteries in parallel and make this a whole lot easier? "
                    },
                    {
                        "username": "EntityPlantt",
                        "content": "I mean yeah but idk\\nSee the [editorial](editorial)"
                    },
                    {
                        "username": "Karilli",
                        "content": "Everyone got the time complexity of binary search wrong, it is $$O(nlog(s/n))$$, where $$s = sum(batteries)$$.\nIn the worst case scenario every battery power equals to $$10^9, len(batteries) = 10^5, n = 1$$, that means about $$10^5 * log2(10^{14})$$ operations instead of $$10^5 * log2(10^5)$$.\n\nI think that even the editorial guys got it kinda wrong, because saying $$max(batteries) >> len(batteries), n$$, therefore comlexity is $$O(nlog*max(batteries))$$ is at best missleading.\n\nfor reference:\n$$log2(10^{14}) ~= 46.50699332842307$$\n$$log2(10^9) ~= 29.897352853986263$$\n$$log2(10^5) ~= 16.609640474436812$$\n\nedit: On second thought, editorial is correct. You could say time complexity is $$O(nlog(m*k/n))$$, where $$k = max(batteries), m = len(batteries)$$. Because $$k > m$$ in worst case, it is also $$O(nlog(k*k/n))$$, the worst case is $$n = 1$$ => $$O(nlog(k^2))$$ => $$O(2*nlog(k))$$ => $$O(nlogk)$$"
                    },
                    {
                        "username": "mostafaelite7",
                        "content": "u know that the author is evil when u see in the two examples n=2, and all batteries are at same energy levels :D :D "
                    },
                    {
                        "username": "Chetansinha",
                        "content": "More type of Binary search (like allocate book) question :-\n1. Split Array Largest Sum\n2. Kth Smallest Number in Multiplication Table\n3. Find K-th Smallest Pair Distance\n4. Swim in Rising Water\n5. Koko Eating Bananas\n6. Capacity To Ship Packages Within D Days\n7. Ugly Number III\n8. Maximum Candies Allocated to K Children\n9. Find the Smallest Divisor Given a Threshold\n10. Encrypt and Decrypt Strings\n11. Minimum Number of Days to Make m Bouquets\n12. Magnetic Force Between Two Balls\n13. Minimum Limit of Balls in a Bag\n14. Minimum Speed to Arrive on Time\n15. Maximum Number of Removable Characters\n16. Minimized Maximum of Products Distributed to Any Store\n17. Minimum Time to Complete Trips\n18. Maximum Tastiness of Candy Basket\n19. Maximize the Minimum Powered City\n20. Minimize the Maximum of Two Arrays\n21. House Robber IV"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Apply binary search on time instances and \\nfor a particular time instance ,\\n first remove all computer which can run with batteries with time>= time instance (which you are checking )  for remaining computers take the average of remaining batteries with remaining number of computer . If it is >= given time instance then it can be a possible ans ...\\n"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Why would we take Battery from Another computer? Won\\'t it be Useless as we want all N computers to operate simultaneously? If we remove battery from One computer, that computer would still require battery... The only possible task should be to insert a new battery from remaining set."
                    },
                    {
                        "username": "Gfreitag",
                        "content": "It is a toy problem"
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "as it is mention there would be no time lapse between switching batteries, so the time in removing and injecting new batteries in negligble.."
                    },
                    {
                        "username": "psionl0",
                        "content": "This is weird.\nNormally a binary search involves a calculation like ``mid = (lo + hi) / 2`` or ``mid = lo + (hi - lo) / 2``. Yet no matter how I tampered with the boundaries, I couldn't pass all test cases. Then I looked at the editorial solution and it had the formula written like ``mid = hi - (hi - lo) / 2``. When I used that as my calculation, suddenly all of my test cases passed! Evidently the round off works the other way when you do the formula this way. I would have never guessed this version of the formula would make a difference. It leads me to wonder whether the official answers are really the correct ones."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@JHolz](/JHolz) Yes, this has been an educational experience for me. I have done quite a few binary search questions now and I have never had to worry about the ``mid`` formula before. I get why you need to round upwards - otherwise you get stuck in an endless loop. I guess I will need a little more practice to get an appreciation of when to reverse the ``mid`` formula. Thanks for the additional info."
                    },
                    {
                        "username": "JHolz",
                        "content": "As u already determined, the formula in the editorial rounds `m` up. If you round `m` down instead, you have to use `l = m + 1`  and `r = m`, so that the binary search always terminates. That can still work, but it changes the search to \"whats the smallest timeframe, that does not fullfill the requirements\" and u have to subtract by one in the end (if the answer is greater zero), to get the correct answer to the original question (and also increase our starting `r` by one)."
                    },
                    {
                        "username": "TERNION2205",
                        "content": "My solution works fine (as it seems to me)\\nbut on test case 14, it gives TLE\\nOn ide it does take time but upon checking the answer is correct.\\nAny tips on how can we minimize the search space?\\nThanks in advance"
                    },
                    {
                        "username": "iamcodebug",
                        "content": "What search space did you used ?? "
                    },
                    {
                        "username": "pavanbagade28",
                        "content": "n=3 ; batteries=[10,10,3,5]\\nanswer should be 9, but expected is 8 , please explain."
                    },
                    {
                        "username": "pavanbagade28",
                        "content": "Okay  understood i ignored this(you can run all the n computers simultaneously.)"
                    },
                    {
                        "username": "ak_3101",
                        "content": "can we do this with maxheap?\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "I used this simulation approach using maxHeap and this passed 40/52 testcases. But failed on this one\\n```\\nn=12\\n[11,89,16,32,70,67,35,35,31,24,41,29,6,53,78,83]\\n```\\n\\nCode - \\n```\\ntypedef vector<int> vi;\\ntypedef vector<vi> vvi;\\n\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& b) {\\n        priority_queue<int> pq(b.begin(), b.end());\\n        long long runtime = 0;\\n        while(pq.size() >= n) {\\n            vi bat;\\n            int bats = n;\\n            int minVal = INT_MAX;\\n            while(bats--) {\\n                int val = pq.top();\\n                pq.pop();\\n                minVal = min(minVal, val);\\n                bat.push_back(val);\\n            }\\n             if(minVal > 1) {\\n                minVal--;\\n                runtime += minVal;\\n                for(int val: bat) {\\n                    pq.push(val-minVal);\\n                }\\n            } else {\\n                runtime++;\\n                for(int val: bat) {\\n                    if(val != 1)\\n                        pq.push(val-1);\\n                }\\n            }\\n        }\\n        return runtime;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dfa",
                        "content": "[@ak_3101](/ak_3101) this strategy timed out for me"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@ak_3101](/ak_3101) ans would never be more than (sum)/n;\\nso we would pop all the elements which have power >= (sum of all power)/n.\\nnow we have batteries which can drain so we now have subproblem of remaining power and remaining batteries,\\nnow out of these remaining batteries, max time upto which we can power is (sum remaining)/n remaining;"
                    },
                    {
                        "username": "fli033",
                        "content": "i think it take too long"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@garvit_001](/garvit_001)  yeah we can maintain a max heap and keep subtracting 1 from top n elements and use heapify to again get max element on the top, its complexity should be nlog n, problem, I couldnt code it though, let me know if you have."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "i was thinking the same,, using max-min heaps"
                    }
                ]
            },
            {
                "id": 1988458,
                "content": [
                    {
                        "username": "RushN24",
                        "content": "Can\\'t we just wire the batteries in parallel and make this a whole lot easier? "
                    },
                    {
                        "username": "EntityPlantt",
                        "content": "I mean yeah but idk\\nSee the [editorial](editorial)"
                    },
                    {
                        "username": "Karilli",
                        "content": "Everyone got the time complexity of binary search wrong, it is $$O(nlog(s/n))$$, where $$s = sum(batteries)$$.\nIn the worst case scenario every battery power equals to $$10^9, len(batteries) = 10^5, n = 1$$, that means about $$10^5 * log2(10^{14})$$ operations instead of $$10^5 * log2(10^5)$$.\n\nI think that even the editorial guys got it kinda wrong, because saying $$max(batteries) >> len(batteries), n$$, therefore comlexity is $$O(nlog*max(batteries))$$ is at best missleading.\n\nfor reference:\n$$log2(10^{14}) ~= 46.50699332842307$$\n$$log2(10^9) ~= 29.897352853986263$$\n$$log2(10^5) ~= 16.609640474436812$$\n\nedit: On second thought, editorial is correct. You could say time complexity is $$O(nlog(m*k/n))$$, where $$k = max(batteries), m = len(batteries)$$. Because $$k > m$$ in worst case, it is also $$O(nlog(k*k/n))$$, the worst case is $$n = 1$$ => $$O(nlog(k^2))$$ => $$O(2*nlog(k))$$ => $$O(nlogk)$$"
                    },
                    {
                        "username": "mostafaelite7",
                        "content": "u know that the author is evil when u see in the two examples n=2, and all batteries are at same energy levels :D :D "
                    },
                    {
                        "username": "Chetansinha",
                        "content": "More type of Binary search (like allocate book) question :-\n1. Split Array Largest Sum\n2. Kth Smallest Number in Multiplication Table\n3. Find K-th Smallest Pair Distance\n4. Swim in Rising Water\n5. Koko Eating Bananas\n6. Capacity To Ship Packages Within D Days\n7. Ugly Number III\n8. Maximum Candies Allocated to K Children\n9. Find the Smallest Divisor Given a Threshold\n10. Encrypt and Decrypt Strings\n11. Minimum Number of Days to Make m Bouquets\n12. Magnetic Force Between Two Balls\n13. Minimum Limit of Balls in a Bag\n14. Minimum Speed to Arrive on Time\n15. Maximum Number of Removable Characters\n16. Minimized Maximum of Products Distributed to Any Store\n17. Minimum Time to Complete Trips\n18. Maximum Tastiness of Candy Basket\n19. Maximize the Minimum Powered City\n20. Minimize the Maximum of Two Arrays\n21. House Robber IV"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Apply binary search on time instances and \\nfor a particular time instance ,\\n first remove all computer which can run with batteries with time>= time instance (which you are checking )  for remaining computers take the average of remaining batteries with remaining number of computer . If it is >= given time instance then it can be a possible ans ...\\n"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Why would we take Battery from Another computer? Won\\'t it be Useless as we want all N computers to operate simultaneously? If we remove battery from One computer, that computer would still require battery... The only possible task should be to insert a new battery from remaining set."
                    },
                    {
                        "username": "Gfreitag",
                        "content": "It is a toy problem"
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "as it is mention there would be no time lapse between switching batteries, so the time in removing and injecting new batteries in negligble.."
                    },
                    {
                        "username": "psionl0",
                        "content": "This is weird.\nNormally a binary search involves a calculation like ``mid = (lo + hi) / 2`` or ``mid = lo + (hi - lo) / 2``. Yet no matter how I tampered with the boundaries, I couldn't pass all test cases. Then I looked at the editorial solution and it had the formula written like ``mid = hi - (hi - lo) / 2``. When I used that as my calculation, suddenly all of my test cases passed! Evidently the round off works the other way when you do the formula this way. I would have never guessed this version of the formula would make a difference. It leads me to wonder whether the official answers are really the correct ones."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@JHolz](/JHolz) Yes, this has been an educational experience for me. I have done quite a few binary search questions now and I have never had to worry about the ``mid`` formula before. I get why you need to round upwards - otherwise you get stuck in an endless loop. I guess I will need a little more practice to get an appreciation of when to reverse the ``mid`` formula. Thanks for the additional info."
                    },
                    {
                        "username": "JHolz",
                        "content": "As u already determined, the formula in the editorial rounds `m` up. If you round `m` down instead, you have to use `l = m + 1`  and `r = m`, so that the binary search always terminates. That can still work, but it changes the search to \"whats the smallest timeframe, that does not fullfill the requirements\" and u have to subtract by one in the end (if the answer is greater zero), to get the correct answer to the original question (and also increase our starting `r` by one)."
                    },
                    {
                        "username": "TERNION2205",
                        "content": "My solution works fine (as it seems to me)\\nbut on test case 14, it gives TLE\\nOn ide it does take time but upon checking the answer is correct.\\nAny tips on how can we minimize the search space?\\nThanks in advance"
                    },
                    {
                        "username": "iamcodebug",
                        "content": "What search space did you used ?? "
                    },
                    {
                        "username": "pavanbagade28",
                        "content": "n=3 ; batteries=[10,10,3,5]\\nanswer should be 9, but expected is 8 , please explain."
                    },
                    {
                        "username": "pavanbagade28",
                        "content": "Okay  understood i ignored this(you can run all the n computers simultaneously.)"
                    },
                    {
                        "username": "ak_3101",
                        "content": "can we do this with maxheap?\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "I used this simulation approach using maxHeap and this passed 40/52 testcases. But failed on this one\\n```\\nn=12\\n[11,89,16,32,70,67,35,35,31,24,41,29,6,53,78,83]\\n```\\n\\nCode - \\n```\\ntypedef vector<int> vi;\\ntypedef vector<vi> vvi;\\n\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& b) {\\n        priority_queue<int> pq(b.begin(), b.end());\\n        long long runtime = 0;\\n        while(pq.size() >= n) {\\n            vi bat;\\n            int bats = n;\\n            int minVal = INT_MAX;\\n            while(bats--) {\\n                int val = pq.top();\\n                pq.pop();\\n                minVal = min(minVal, val);\\n                bat.push_back(val);\\n            }\\n             if(minVal > 1) {\\n                minVal--;\\n                runtime += minVal;\\n                for(int val: bat) {\\n                    pq.push(val-minVal);\\n                }\\n            } else {\\n                runtime++;\\n                for(int val: bat) {\\n                    if(val != 1)\\n                        pq.push(val-1);\\n                }\\n            }\\n        }\\n        return runtime;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dfa",
                        "content": "[@ak_3101](/ak_3101) this strategy timed out for me"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@ak_3101](/ak_3101) ans would never be more than (sum)/n;\\nso we would pop all the elements which have power >= (sum of all power)/n.\\nnow we have batteries which can drain so we now have subproblem of remaining power and remaining batteries,\\nnow out of these remaining batteries, max time upto which we can power is (sum remaining)/n remaining;"
                    },
                    {
                        "username": "fli033",
                        "content": "i think it take too long"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@garvit_001](/garvit_001)  yeah we can maintain a max heap and keep subtracting 1 from top n elements and use heapify to again get max element on the top, its complexity should be nlog n, problem, I couldnt code it though, let me know if you have."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "i was thinking the same,, using max-min heaps"
                    }
                ]
            },
            {
                "id": 1988335,
                "content": [
                    {
                        "username": "RushN24",
                        "content": "Can\\'t we just wire the batteries in parallel and make this a whole lot easier? "
                    },
                    {
                        "username": "EntityPlantt",
                        "content": "I mean yeah but idk\\nSee the [editorial](editorial)"
                    },
                    {
                        "username": "Karilli",
                        "content": "Everyone got the time complexity of binary search wrong, it is $$O(nlog(s/n))$$, where $$s = sum(batteries)$$.\nIn the worst case scenario every battery power equals to $$10^9, len(batteries) = 10^5, n = 1$$, that means about $$10^5 * log2(10^{14})$$ operations instead of $$10^5 * log2(10^5)$$.\n\nI think that even the editorial guys got it kinda wrong, because saying $$max(batteries) >> len(batteries), n$$, therefore comlexity is $$O(nlog*max(batteries))$$ is at best missleading.\n\nfor reference:\n$$log2(10^{14}) ~= 46.50699332842307$$\n$$log2(10^9) ~= 29.897352853986263$$\n$$log2(10^5) ~= 16.609640474436812$$\n\nedit: On second thought, editorial is correct. You could say time complexity is $$O(nlog(m*k/n))$$, where $$k = max(batteries), m = len(batteries)$$. Because $$k > m$$ in worst case, it is also $$O(nlog(k*k/n))$$, the worst case is $$n = 1$$ => $$O(nlog(k^2))$$ => $$O(2*nlog(k))$$ => $$O(nlogk)$$"
                    },
                    {
                        "username": "mostafaelite7",
                        "content": "u know that the author is evil when u see in the two examples n=2, and all batteries are at same energy levels :D :D "
                    },
                    {
                        "username": "Chetansinha",
                        "content": "More type of Binary search (like allocate book) question :-\n1. Split Array Largest Sum\n2. Kth Smallest Number in Multiplication Table\n3. Find K-th Smallest Pair Distance\n4. Swim in Rising Water\n5. Koko Eating Bananas\n6. Capacity To Ship Packages Within D Days\n7. Ugly Number III\n8. Maximum Candies Allocated to K Children\n9. Find the Smallest Divisor Given a Threshold\n10. Encrypt and Decrypt Strings\n11. Minimum Number of Days to Make m Bouquets\n12. Magnetic Force Between Two Balls\n13. Minimum Limit of Balls in a Bag\n14. Minimum Speed to Arrive on Time\n15. Maximum Number of Removable Characters\n16. Minimized Maximum of Products Distributed to Any Store\n17. Minimum Time to Complete Trips\n18. Maximum Tastiness of Candy Basket\n19. Maximize the Minimum Powered City\n20. Minimize the Maximum of Two Arrays\n21. House Robber IV"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Apply binary search on time instances and \\nfor a particular time instance ,\\n first remove all computer which can run with batteries with time>= time instance (which you are checking )  for remaining computers take the average of remaining batteries with remaining number of computer . If it is >= given time instance then it can be a possible ans ...\\n"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Why would we take Battery from Another computer? Won\\'t it be Useless as we want all N computers to operate simultaneously? If we remove battery from One computer, that computer would still require battery... The only possible task should be to insert a new battery from remaining set."
                    },
                    {
                        "username": "Gfreitag",
                        "content": "It is a toy problem"
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "as it is mention there would be no time lapse between switching batteries, so the time in removing and injecting new batteries in negligble.."
                    },
                    {
                        "username": "psionl0",
                        "content": "This is weird.\nNormally a binary search involves a calculation like ``mid = (lo + hi) / 2`` or ``mid = lo + (hi - lo) / 2``. Yet no matter how I tampered with the boundaries, I couldn't pass all test cases. Then I looked at the editorial solution and it had the formula written like ``mid = hi - (hi - lo) / 2``. When I used that as my calculation, suddenly all of my test cases passed! Evidently the round off works the other way when you do the formula this way. I would have never guessed this version of the formula would make a difference. It leads me to wonder whether the official answers are really the correct ones."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@JHolz](/JHolz) Yes, this has been an educational experience for me. I have done quite a few binary search questions now and I have never had to worry about the ``mid`` formula before. I get why you need to round upwards - otherwise you get stuck in an endless loop. I guess I will need a little more practice to get an appreciation of when to reverse the ``mid`` formula. Thanks for the additional info."
                    },
                    {
                        "username": "JHolz",
                        "content": "As u already determined, the formula in the editorial rounds `m` up. If you round `m` down instead, you have to use `l = m + 1`  and `r = m`, so that the binary search always terminates. That can still work, but it changes the search to \"whats the smallest timeframe, that does not fullfill the requirements\" and u have to subtract by one in the end (if the answer is greater zero), to get the correct answer to the original question (and also increase our starting `r` by one)."
                    },
                    {
                        "username": "TERNION2205",
                        "content": "My solution works fine (as it seems to me)\\nbut on test case 14, it gives TLE\\nOn ide it does take time but upon checking the answer is correct.\\nAny tips on how can we minimize the search space?\\nThanks in advance"
                    },
                    {
                        "username": "iamcodebug",
                        "content": "What search space did you used ?? "
                    },
                    {
                        "username": "pavanbagade28",
                        "content": "n=3 ; batteries=[10,10,3,5]\\nanswer should be 9, but expected is 8 , please explain."
                    },
                    {
                        "username": "pavanbagade28",
                        "content": "Okay  understood i ignored this(you can run all the n computers simultaneously.)"
                    },
                    {
                        "username": "ak_3101",
                        "content": "can we do this with maxheap?\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "I used this simulation approach using maxHeap and this passed 40/52 testcases. But failed on this one\\n```\\nn=12\\n[11,89,16,32,70,67,35,35,31,24,41,29,6,53,78,83]\\n```\\n\\nCode - \\n```\\ntypedef vector<int> vi;\\ntypedef vector<vi> vvi;\\n\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& b) {\\n        priority_queue<int> pq(b.begin(), b.end());\\n        long long runtime = 0;\\n        while(pq.size() >= n) {\\n            vi bat;\\n            int bats = n;\\n            int minVal = INT_MAX;\\n            while(bats--) {\\n                int val = pq.top();\\n                pq.pop();\\n                minVal = min(minVal, val);\\n                bat.push_back(val);\\n            }\\n             if(minVal > 1) {\\n                minVal--;\\n                runtime += minVal;\\n                for(int val: bat) {\\n                    pq.push(val-minVal);\\n                }\\n            } else {\\n                runtime++;\\n                for(int val: bat) {\\n                    if(val != 1)\\n                        pq.push(val-1);\\n                }\\n            }\\n        }\\n        return runtime;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dfa",
                        "content": "[@ak_3101](/ak_3101) this strategy timed out for me"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@ak_3101](/ak_3101) ans would never be more than (sum)/n;\\nso we would pop all the elements which have power >= (sum of all power)/n.\\nnow we have batteries which can drain so we now have subproblem of remaining power and remaining batteries,\\nnow out of these remaining batteries, max time upto which we can power is (sum remaining)/n remaining;"
                    },
                    {
                        "username": "fli033",
                        "content": "i think it take too long"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@garvit_001](/garvit_001)  yeah we can maintain a max heap and keep subtracting 1 from top n elements and use heapify to again get max element on the top, its complexity should be nlog n, problem, I couldnt code it though, let me know if you have."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "i was thinking the same,, using max-min heaps"
                    }
                ]
            },
            {
                "id": 1988236,
                "content": [
                    {
                        "username": "RushN24",
                        "content": "Can\\'t we just wire the batteries in parallel and make this a whole lot easier? "
                    },
                    {
                        "username": "EntityPlantt",
                        "content": "I mean yeah but idk\\nSee the [editorial](editorial)"
                    },
                    {
                        "username": "Karilli",
                        "content": "Everyone got the time complexity of binary search wrong, it is $$O(nlog(s/n))$$, where $$s = sum(batteries)$$.\nIn the worst case scenario every battery power equals to $$10^9, len(batteries) = 10^5, n = 1$$, that means about $$10^5 * log2(10^{14})$$ operations instead of $$10^5 * log2(10^5)$$.\n\nI think that even the editorial guys got it kinda wrong, because saying $$max(batteries) >> len(batteries), n$$, therefore comlexity is $$O(nlog*max(batteries))$$ is at best missleading.\n\nfor reference:\n$$log2(10^{14}) ~= 46.50699332842307$$\n$$log2(10^9) ~= 29.897352853986263$$\n$$log2(10^5) ~= 16.609640474436812$$\n\nedit: On second thought, editorial is correct. You could say time complexity is $$O(nlog(m*k/n))$$, where $$k = max(batteries), m = len(batteries)$$. Because $$k > m$$ in worst case, it is also $$O(nlog(k*k/n))$$, the worst case is $$n = 1$$ => $$O(nlog(k^2))$$ => $$O(2*nlog(k))$$ => $$O(nlogk)$$"
                    },
                    {
                        "username": "mostafaelite7",
                        "content": "u know that the author is evil when u see in the two examples n=2, and all batteries are at same energy levels :D :D "
                    },
                    {
                        "username": "Chetansinha",
                        "content": "More type of Binary search (like allocate book) question :-\n1. Split Array Largest Sum\n2. Kth Smallest Number in Multiplication Table\n3. Find K-th Smallest Pair Distance\n4. Swim in Rising Water\n5. Koko Eating Bananas\n6. Capacity To Ship Packages Within D Days\n7. Ugly Number III\n8. Maximum Candies Allocated to K Children\n9. Find the Smallest Divisor Given a Threshold\n10. Encrypt and Decrypt Strings\n11. Minimum Number of Days to Make m Bouquets\n12. Magnetic Force Between Two Balls\n13. Minimum Limit of Balls in a Bag\n14. Minimum Speed to Arrive on Time\n15. Maximum Number of Removable Characters\n16. Minimized Maximum of Products Distributed to Any Store\n17. Minimum Time to Complete Trips\n18. Maximum Tastiness of Candy Basket\n19. Maximize the Minimum Powered City\n20. Minimize the Maximum of Two Arrays\n21. House Robber IV"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Apply binary search on time instances and \\nfor a particular time instance ,\\n first remove all computer which can run with batteries with time>= time instance (which you are checking )  for remaining computers take the average of remaining batteries with remaining number of computer . If it is >= given time instance then it can be a possible ans ...\\n"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Why would we take Battery from Another computer? Won\\'t it be Useless as we want all N computers to operate simultaneously? If we remove battery from One computer, that computer would still require battery... The only possible task should be to insert a new battery from remaining set."
                    },
                    {
                        "username": "Gfreitag",
                        "content": "It is a toy problem"
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "as it is mention there would be no time lapse between switching batteries, so the time in removing and injecting new batteries in negligble.."
                    },
                    {
                        "username": "psionl0",
                        "content": "This is weird.\nNormally a binary search involves a calculation like ``mid = (lo + hi) / 2`` or ``mid = lo + (hi - lo) / 2``. Yet no matter how I tampered with the boundaries, I couldn't pass all test cases. Then I looked at the editorial solution and it had the formula written like ``mid = hi - (hi - lo) / 2``. When I used that as my calculation, suddenly all of my test cases passed! Evidently the round off works the other way when you do the formula this way. I would have never guessed this version of the formula would make a difference. It leads me to wonder whether the official answers are really the correct ones."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@JHolz](/JHolz) Yes, this has been an educational experience for me. I have done quite a few binary search questions now and I have never had to worry about the ``mid`` formula before. I get why you need to round upwards - otherwise you get stuck in an endless loop. I guess I will need a little more practice to get an appreciation of when to reverse the ``mid`` formula. Thanks for the additional info."
                    },
                    {
                        "username": "JHolz",
                        "content": "As u already determined, the formula in the editorial rounds `m` up. If you round `m` down instead, you have to use `l = m + 1`  and `r = m`, so that the binary search always terminates. That can still work, but it changes the search to \"whats the smallest timeframe, that does not fullfill the requirements\" and u have to subtract by one in the end (if the answer is greater zero), to get the correct answer to the original question (and also increase our starting `r` by one)."
                    },
                    {
                        "username": "TERNION2205",
                        "content": "My solution works fine (as it seems to me)\\nbut on test case 14, it gives TLE\\nOn ide it does take time but upon checking the answer is correct.\\nAny tips on how can we minimize the search space?\\nThanks in advance"
                    },
                    {
                        "username": "iamcodebug",
                        "content": "What search space did you used ?? "
                    },
                    {
                        "username": "pavanbagade28",
                        "content": "n=3 ; batteries=[10,10,3,5]\\nanswer should be 9, but expected is 8 , please explain."
                    },
                    {
                        "username": "pavanbagade28",
                        "content": "Okay  understood i ignored this(you can run all the n computers simultaneously.)"
                    },
                    {
                        "username": "ak_3101",
                        "content": "can we do this with maxheap?\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "I used this simulation approach using maxHeap and this passed 40/52 testcases. But failed on this one\\n```\\nn=12\\n[11,89,16,32,70,67,35,35,31,24,41,29,6,53,78,83]\\n```\\n\\nCode - \\n```\\ntypedef vector<int> vi;\\ntypedef vector<vi> vvi;\\n\\nclass Solution {\\npublic:\\n    long long maxRunTime(int n, vector<int>& b) {\\n        priority_queue<int> pq(b.begin(), b.end());\\n        long long runtime = 0;\\n        while(pq.size() >= n) {\\n            vi bat;\\n            int bats = n;\\n            int minVal = INT_MAX;\\n            while(bats--) {\\n                int val = pq.top();\\n                pq.pop();\\n                minVal = min(minVal, val);\\n                bat.push_back(val);\\n            }\\n             if(minVal > 1) {\\n                minVal--;\\n                runtime += minVal;\\n                for(int val: bat) {\\n                    pq.push(val-minVal);\\n                }\\n            } else {\\n                runtime++;\\n                for(int val: bat) {\\n                    if(val != 1)\\n                        pq.push(val-1);\\n                }\\n            }\\n        }\\n        return runtime;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dfa",
                        "content": "[@ak_3101](/ak_3101) this strategy timed out for me"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@ak_3101](/ak_3101) ans would never be more than (sum)/n;\\nso we would pop all the elements which have power >= (sum of all power)/n.\\nnow we have batteries which can drain so we now have subproblem of remaining power and remaining batteries,\\nnow out of these remaining batteries, max time upto which we can power is (sum remaining)/n remaining;"
                    },
                    {
                        "username": "fli033",
                        "content": "i think it take too long"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@garvit_001](/garvit_001)  yeah we can maintain a max heap and keep subtracting 1 from top n elements and use heapify to again get max element on the top, its complexity should be nlog n, problem, I couldnt code it though, let me know if you have."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "i was thinking the same,, using max-min heaps"
                    }
                ]
            }
        ]
    }
]