[
    {
        "title": "Jump Game II",
        "question_content": "You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0].\nEach element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where:\n\n\t0 <= j <= nums[i] and\n\ti + j < n\n\nReturn the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1].\n&nbsp;\nExample 1:\n\nInput: nums = [2,3,1,1,4]\nOutput: 2\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\nExample 2:\n\nInput: nums = [2,3,0,1,4]\nOutput: 2\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 104\n\t0 <= nums[i] <= 1000\n\tIt's guaranteed that you can reach nums[n - 1].",
        "solutions": [
            {
                "id": 18014,
                "title": "concise-o-n-one-loop-java-solution-based-on-greedy",
                "content": "**Explanation**\\n\\nThe main idea is based on greedy. Let's say the range of the current jump is [curBegin, curEnd], curFarthest is the farthest point that all points in [curBegin, curEnd] can reach.  Once the current point reaches curEnd, then trigger another jump, and set the new curEnd with curFarthest, then keep the above steps, as the following:\\n\\n    public int jump(int[] A) {\\n    \\tint jumps = 0, curEnd = 0, curFarthest = 0;\\n    \\tfor (int i = 0; i < A.length - 1; i++) {\\n    \\t\\tcurFarthest = Math.max(curFarthest, i + A[i]);\\n    \\t\\tif (i == curEnd) {\\n    \\t\\t\\tjumps++;\\n    \\t\\t\\tcurEnd = curFarthest;\\n    \\t\\t}\\n    \\t}\\n    \\treturn jumps;\\n    }",
                "solutionTags": [],
                "code": "**Explanation**\\n\\nThe main idea is based on greedy. Let's say the range of the current jump is [curBegin, curEnd], curFarthest is the farthest point that all points in [curBegin, curEnd] can reach.  Once the current point reaches curEnd, then trigger another jump, and set the new curEnd with curFarthest, then keep the above steps, as the following:\\n\\n    public int jump(int[] A) {\\n    \\tint jumps = 0, curEnd = 0, curFarthest = 0;\\n    \\tfor (int i = 0; i < A.length - 1; i++) {\\n    \\t\\tcurFarthest = Math.max(curFarthest, i + A[i]);\\n    \\t\\tif (i == curEnd) {\\n    \\t\\t\\tjumps++;\\n    \\t\\t\\tcurEnd = curFarthest;\\n    \\t\\t}\\n    \\t}\\n    \\treturn jumps;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1192401,
                "title": "easy-solutions-w-explanation-optimizations-from-brute-force-to-dp-to-greedy-bfs",
                "content": "\\u274C ***Solution - I (Brute Force) [Rejected]***\\n\\nWe start at index 0 and are required to reach index `n - 1` (where `n = nums.size()`). We can\\'t always do the maximum jump at each index. This can be easily verified by looking at the example test cases.\\n\\nSo, at each position, we can use a jump size of anywhere in the range *`[1, nums[pos]]`*. The final answer will be the minimum jumps required. We can recursively solve this problem as -\\n\\n* If we reach index *`n-1`* return 0, signifying that we need 0 more jumps.\\n* Else recurse for each jump size possible from the current index and return the answer in which we require the minimum number of jumps\\n\\n\\n```\\nint jump(vector<int>& nums, int pos = 0) {\\n\\tif(pos >= size(nums) - 1) return 0;        \\n\\tint minJumps = 10001;  // initialising to max possible jumps + 1\\n\\tfor(int j = 1; j <= nums[pos]; j++)  // explore all possible jump sizes from current position\\n\\t\\tminJumps = min(minJumps, 1 + jump(nums, pos + j));        \\n\\treturn minJumps;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N!)`**. At each index `i` we have `N-i` choices and we recursively explore each of them till end. So we require `O(N*(N-1)*(N-2)...1) = O(N!)`. \\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n\\n\\u2714\\uFE0F ***Solution - II (Recursive Dynamic Programming - Memoization) [Accepted]***\\n\\nWe can see that for a given position, we are repeatedly calculating the same answer over and over again. The jumps required to reach for a given index on the path remains fixed and can be stored in *`dp`* array to avoid re-calculations.\\n\\nThe solution is similar as the brute force with just the change that we are storing the solutions for each *`pos`* and returning it if it is already calculated.\\n\\n```\\nint jump(vector<int>& nums) {\\n\\tvector<int> dp(size(nums), 10001); // initialise all to max possible jumps + 1 denoting dp[i] hasn\\'t been computed yet\\n\\treturn solve(nums, dp, 0);\\n}\\n// recursive solver to find min jumps to reach end\\nint solve(vector<int>& nums, vector<int>& dp, int pos) {\\n\\tif(pos >= size(nums) - 1) return 0;    // when we reach end, return 0 denoting no more jumps required\\n\\tif(dp[pos] != 10001) return dp[pos];    // number of jumps from pos to end is already calculated, so just return it\\n\\t// explore all possible jump sizes from current position. Store & return min jumps required\\n\\tfor(int j = 1; j <= nums[pos]; j++)\\n\\t\\tdp[pos] = min(dp[pos], 1 + solve(nums, dp, pos + j));        \\n\\treturn dp[pos];\\n}\\n```\\n\\n***Time Complexity :*** **`O(N^2)`**\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Iterative Dynamic Programming - Tabulation) [Accepted]***\\n\\nWe can solve this iteratively as well. For this, we start from the last index. We need 0 jumps from `nums[n-1]` to reach the end. We store this as *`dp[n - 1] = 0`* and then iteratively solve this for each previous index till the 0th index. Here *`dp[i]`* denotes minimum jumps required from current index to reach till the end.\\n\\n1. For each index, we explore all the possible jump sizes available with us. \\n2. The minimum jumps required to reach the end from the current index would be - **`min(dp[jumpLen])`**, where *`1 <= jumpLen <= nums[currentPostion]`*\\n\\n```\\nint jump(vector<int>& nums) {\\n\\tint n = size(nums);\\n\\tvector<int> dp(n, 10001);\\n\\tdp[n - 1] = 0;  // start from last index. No jumps required to reach end if we are already here\\n\\t// same as above. For each index, explore all jump sizes and use the one requiring minimum jumps to reach end\\n\\tfor(int i = n - 2; i >= 0; i--) \\n\\t\\tfor(int jumpLen = 1; jumpLen <= nums[i]; jumpLen++) \\n\\t\\t\\tdp[i] = min(dp[i], 1 + dp[min(n - 1, i + jumpLen)]);  // min(n-1, i + jumpLen) for bounds handling\\n\\treturn dp[0];\\n}\\n```\\n\\n***Time Complexity :*** **`O(N^2)`**\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution IV (Greedy BFS)***\\n\\nWe can iterate over all indices maintaining the furthest reachable position from current index - *`maxReachable`* and currently furthest reached position - *`lastJumpedPos`*. Everytime we will try to update *`lastJumpedPos`* to furthest possible reachable index - `maxReachable`.\\n\\nUpdating the `lastJumpedPos` separately from *`maxReachable`* allows us to maintain track of minimum *`jumps`* required. Each time `lastJumpedPos` is updated, ***`jumps`*** will also be updated and store the minimum jumps required to reach `lastJumpedPos` (On the contrary, updating `jumps` with `maxReachable` won\\'t give the optimal (minimum possible) value of jumps required). \\n\\nWe will just return it as soon as *`lastJumpedPos`* reaches(or exceeds) last index.\\n\\nWe can try to understand the steps in code below as analogous to those in BFS as -\\n\\n1. **`maxReachable = max(maxReachable, i + nums[i])`** : Updating the range of next level. Similar to  *`queue.push(node)`* step of BFS but here we are only greedily storing the max reachable index on next level.\\n\\n\\n2. **`i == lastJumpedPos`** :  When it becomes true, current level iteration has been completed.\\n3. **`lastJumpedPos = maxReachable`** : Set range till which we need to iterate the next level\\n4. **`jumps++`** : Move on to the next level.\\n\\n5. **`return jumps`** : The final answer will be number of levels in BFS traversal.\\n\\nFor eg. Take the example : `nums = [2,3,1,4,1,1,1,2]`. This approach proceeds as illustrated in image below -\\n\\n<p align=center>\\n<img src=https://assets.leetcode.com/users/images/4e5cbbb4-a6d0-4523-a945-261ee4b53f72_1620216977.5849538.png /></p>\\n\\n\\n```\\nint jump(vector<int>& nums) {\\n\\tint n = size(nums), i = 0, maxReachable = 0, lastJumpedPos = 0, jumps = 0;\\n\\twhile(lastJumpedPos < n - 1) {  // loop till last jump hasn\\'t taken us till the end\\n\\t\\tmaxReachable = max(maxReachable, i + nums[i]);  // furthest index reachable on the next level from current level\\n\\t\\tif(i == lastJumpedPos) {\\t\\t\\t  // current level has been iterated & maxReachable position on next level has been finalised\\n\\t\\t\\tlastJumpedPos = maxReachable;     // so just move to that maxReachable position\\n\\t\\t\\tjumps++;                          // and increment the level\\n\\t// NOTE: jump^ only gets updated after we iterate all possible jumps from previous level\\n\\t//       This ensures jumps will only store minimum jump required to reach lastJumpedPos\\n\\t\\t}            \\n\\t\\ti++;\\n\\t}\\n\\treturn jumps;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N)`**\\n***Space Complexity :*** **`O(1)`**\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint jump(vector<int>& nums, int pos = 0) {\\n\\tif(pos >= size(nums) - 1) return 0;        \\n\\tint minJumps = 10001;  // initialising to max possible jumps + 1\\n\\tfor(int j = 1; j <= nums[pos]; j++)  // explore all possible jump sizes from current position\\n\\t\\tminJumps = min(minJumps, 1 + jump(nums, pos + j));        \\n\\treturn minJumps;\\n}\\n```\n```\\nint jump(vector<int>& nums) {\\n\\tvector<int> dp(size(nums), 10001); // initialise all to max possible jumps + 1 denoting dp[i] hasn\\'t been computed yet\\n\\treturn solve(nums, dp, 0);\\n}\\n// recursive solver to find min jumps to reach end\\nint solve(vector<int>& nums, vector<int>& dp, int pos) {\\n\\tif(pos >= size(nums) - 1) return 0;    // when we reach end, return 0 denoting no more jumps required\\n\\tif(dp[pos] != 10001) return dp[pos];    // number of jumps from pos to end is already calculated, so just return it\\n\\t// explore all possible jump sizes from current position. Store & return min jumps required\\n\\tfor(int j = 1; j <= nums[pos]; j++)\\n\\t\\tdp[pos] = min(dp[pos], 1 + solve(nums, dp, pos + j));        \\n\\treturn dp[pos];\\n}\\n```\n```\\nint jump(vector<int>& nums) {\\n\\tint n = size(nums);\\n\\tvector<int> dp(n, 10001);\\n\\tdp[n - 1] = 0;  // start from last index. No jumps required to reach end if we are already here\\n\\t// same as above. For each index, explore all jump sizes and use the one requiring minimum jumps to reach end\\n\\tfor(int i = n - 2; i >= 0; i--) \\n\\t\\tfor(int jumpLen = 1; jumpLen <= nums[i]; jumpLen++) \\n\\t\\t\\tdp[i] = min(dp[i], 1 + dp[min(n - 1, i + jumpLen)]);  // min(n-1, i + jumpLen) for bounds handling\\n\\treturn dp[0];\\n}\\n```\n```\\nint jump(vector<int>& nums) {\\n\\tint n = size(nums), i = 0, maxReachable = 0, lastJumpedPos = 0, jumps = 0;\\n\\twhile(lastJumpedPos < n - 1) {  // loop till last jump hasn\\'t taken us till the end\\n\\t\\tmaxReachable = max(maxReachable, i + nums[i]);  // furthest index reachable on the next level from current level\\n\\t\\tif(i == lastJumpedPos) {\\t\\t\\t  // current level has been iterated & maxReachable position on next level has been finalised\\n\\t\\t\\tlastJumpedPos = maxReachable;     // so just move to that maxReachable position\\n\\t\\t\\tjumps++;                          // and increment the level\\n\\t// NOTE: jump^ only gets updated after we iterate all possible jumps from previous level\\n\\t//       This ensures jumps will only store minimum jump required to reach lastJumpedPos\\n\\t\\t}            \\n\\t\\ti++;\\n\\t}\\n\\treturn jumps;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 18028,
                "title": "o-n-bfs-solution",
                "content": "I try to change this problem to a BFS problem, where nodes in level i are all the nodes that can be reached in i-1th jump. for example.   2 3 1 1 4 , is \\n                   2||\\n               3   1||\\n               1   4  || \\n\\nclearly,  the minimum jump of 4 is 2 since 4 is in level 3.  my ac code.\\n\\n\\n\\n     int jump(int A[], int n) {\\n    \\t if(n<2)return 0;\\n    \\t int level=0,currentMax=0,i=0,nextMax=0;\\n    \\n    \\t while(currentMax-i+1>0){\\t\\t//nodes count of current level>0\\n    \\t\\t level++;\\n    \\t\\t for(;i<=currentMax;i++){\\t//traverse current level , and update the max reach of next level\\n    \\t\\t\\tnextMax=max(nextMax,A[i]+i);\\n    \\t\\t\\tif(nextMax>=n-1)return level;   // if last element is in level+1,  then the min jump=level \\n    \\t\\t }\\n    \\t\\t currentMax=nextMax;\\n    \\t }\\n    \\t return 0;\\n     }",
                "solutionTags": [],
                "code": "I try to change this problem to a BFS problem, where nodes in level i are all the nodes that can be reached in i-1th jump. for example.   2 3 1 1 4 , is \\n                   2||\\n               3   1||\\n               1   4  || \\n\\nclearly,  the minimum jump of 4 is 2 since 4 is in level 3.  my ac code.\\n\\n\\n\\n     int jump(int A[], int n) {\\n    \\t if(n<2)return 0;\\n    \\t int level=0,currentMax=0,i=0,nextMax=0;\\n    \\n    \\t while(currentMax-i+1>0){\\t\\t//nodes count of current level>0\\n    \\t\\t level++;\\n    \\t\\t for(;i<=currentMax;i++){\\t//traverse current level , and update the max reach of next level\\n    \\t\\t\\tnextMax=max(nextMax,A[i]+i);\\n    \\t\\t\\tif(nextMax>=n-1)return level;   // if last element is in level+1,  then the min jump=level \\n    \\t\\t }\\n    \\t\\t currentMax=nextMax;\\n    \\t }\\n    \\t return 0;\\n     }",
                "codeTag": "Unknown"
            },
            {
                "id": 170518,
                "title": "8-lines-in-python-easiest-solution",
                "content": "The idea is to maintain two pointers `left` and `right`, where left initialy set to be `0` and `right` set to be `nums[0]`.\\nSo points between `0` and `nums[0]` are the ones you can reach by using just 1 jump.\\nNext, we want to find points I can reach using 2 jumps, so our new  `left` will be set equal to `right`, and our new `right` will be set equal to the farest point we can reach by `two` jumps. which is:\\n`right = max(i + nums[i] for i in range(left, right + 1)`\\n\\nCode:\\n```python\\n    def jump(self, nums):\\n        if len(nums) <= 1: return 0\\n        l, r = 0, nums[0]\\n        times = 1\\n        while r < len(nums) - 1:\\n            times += 1\\n            nxt = max(i + nums[i] for i in range(l, r + 1))\\n            l, r = r, nxt\\n        return times\\n```",
                "solutionTags": [],
                "code": "```python\\n    def jump(self, nums):\\n        if len(nums) <= 1: return 0\\n        l, r = 0, nums[0]\\n        times = 1\\n        while r < len(nums) - 1:\\n            times += 1\\n            nxt = max(i + nums[i] for i in range(l, r + 1))\\n            l, r = r, nxt\\n        return times\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 18019,
                "title": "10-lines-c-16ms-python-bfs-solutions-with-explanations",
                "content": "This problem has a nice BFS structure. Let's illustrate it using the example `nums = [2, 3, 1, 1, 4]` in the problem statement. We are initially at position `0`. Then we can move at most `nums[0]` steps from it. So, after one move, we may reach `nums[1] = 3` or `nums[2] = 1`. So these nodes are reachable in `1` move. From these nodes, we can further move to `nums[3] = 1` and `nums[4] = 4`. Now you can see that the target `nums[4] = 4` is reachable in `2` moves. \\n\\nPutting these into codes, we keep two pointers `start` and `end` that record the current range of the starting nodes. Each time after we make a move, update `start` to be `end  + 1` and `end` to be the farthest index that can be reached in `1` move from the current `[start, end]`. \\n \\nTo get an accepted solution, it is important to handle all the edge cases. And the following codes handle all of them in a unified way without using the unclean `if` statements :-)\\n \\n----------\\n**C++**\\n\\n    class Solution {\\n    public:\\n        int jump(vector<int>& nums) {\\n            int n = nums.size(), step = 0, start = 0, end = 0;\\n            while (end < n - 1) {\\n                step++; \\n    \\t\\t\\tint maxend = end + 1;\\n    \\t\\t\\tfor (int i = start; i <= end; i++) {\\n                    if (i + nums[i] >= n - 1) return step;\\n    \\t\\t\\t\\tmaxend = max(maxend, i + nums[i]);\\n    \\t\\t\\t}\\n                start = end + 1;\\n                end = maxend;\\n            }\\n    \\t\\treturn step;\\n        }\\n    };\\n\\n----------\\n**Python** \\n\\n    class Solution:\\n        # @param {integer[]} nums\\n        # @return {integer}\\n        def jump(self, nums):\\n            n, start, end, step = len(nums), 0, 0, 0\\n            while end < n - 1:\\n                step += 1\\n                maxend = end + 1\\n                for i in range(start, end + 1):\\n                    if i + nums[i] >= n - 1:\\n                        return step\\n                    maxend = max(maxend, i + nums[i])\\n                start, end = end + 1, maxend\\n            return step",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    public:\\n        int jump(vector<int>& nums) {\\n            int n = nums.size(), step = 0, start = 0, end = 0;\\n            while (end < n - 1) {\\n                step++; \\n    \\t\\t\\tint maxend = end + 1;\\n    \\t\\t\\tfor (int i = start; i <= end; i++) {\\n                    if (i + nums[i] >= n - 1) return step;\\n    \\t\\t\\t\\tmaxend = max(maxend, i + nums[i]);\\n    \\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3158218,
                "title": "c-faster-than-75-straight-forward-method-clean-and-concise-code",
                "content": "\\n# Code\\n\\n# Please Do Upvote!!!!\\n##### Connect with me on Linkedin -> https://www.linkedin.com/in/md-kamran-55b98521a/\\n```\\n\\nclass Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n\\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i] + i, nums[i-1]);\\n      }\\n\\n      int ind = 0;\\n      int ans = 0;\\n\\n      while(ind < nums.size() - 1)\\n      {\\n        ans++;\\n        ind = nums[ind];\\n      }\\n\\n      return ans;\\n    }\\n};\\n\\n\\n```\\n![b62ab1be-232a-438f-9524-7d8ca4dbd5fe_1675328166.1161866.png](https://assets.leetcode.com/users/images/24f080eb-397a-4a09-a9f5-6a9a315c955f_1675822350.8603303.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n\\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i] + i, nums[i-1]);\\n      }\\n\\n      int ind = 0;\\n      int ans = 0;\\n\\n      while(ind < nums.size() - 1)\\n      {\\n        ans++;\\n        ind = nums[ind];\\n      }\\n\\n      return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18023,
                "title": "single-loop-simple-java-solution",
                "content": "    public int jump(int[] A) {\\n        int sc = 0;\\n        int e = 0;\\n        int max = 0;\\n        for(int i=0; i<A.length-1; i++) {\\n            max = Math.max(max, i+A[i]);\\n            if( i == e ) {\\n                sc++;\\n                e = max;\\n            } \\n        }\\n        return sc;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int jump(int[] A) {\\n        int sc = 0;\\n        int e = 0;\\n        int max = 0;\\n        for(int i=0; i<A.length-1; i++) {\\n            max = Math.max(max, i+A[i]);\\n            if( i == e ) {\\n                sc++;\\n                e = max;\\n            } \\n        }\\n        return sc;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3158169,
                "title": "clean-codes-full-explanation-implicit-bfs-c-java-python3",
                "content": "# Intuition :\\n- We have to find the minimum number of jumps required to reach the end of a given array of non-negative integers i.e the shortest number of jumps needed to reach the end of an array of numbers.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Explanation to Approach :\\n- We are using a search algorithm that works by moving forward in steps and counting each step as a jump. \\n- The algorithm keeps track of the farthest reachable position at each step and updates the number of jumps needed to reach that farthest position. \\n- The algorithm returns the minimum number of jumps needed to reach the end of the array.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity :\\n- Time complexity : O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\\n\\n# Codes [C++ |Java |Python3] with Comments :\\n```C++ []\\nclass Solution {\\n public:\\n  int jump(vector<int>& nums) {\\n    int ans = 0;\\n    int end = 0;\\n    int farthest = 0;\\n\\n    // Implicit BFS\\n    for (int i = 0; i < nums.size() - 1; ++i) {\\n      farthest = max(farthest, i + nums[i]);\\n      if (farthest >= nums.size() - 1) {\\n        ++ans;\\n        break;\\n      }\\n      if (i == end) {    // Visited all the items on the current level\\n        ++ans;           // Increment the level\\n        end = farthest;  // Make the queue size for the next level\\n      }\\n    }\\n\\n    return ans;\\n  }\\n};\\n```\\n```Java []\\nclass Solution {\\n  public int jump(int[] nums) {\\n    int ans = 0;\\n    int end = 0;\\n    int farthest = 0;\\n\\n    // Implicit BFS\\n    for (int i = 0; i < nums.length - 1; ++i) {\\n      farthest = Math.max(farthest, i + nums[i]);\\n      if (farthest >= nums.length - 1) {\\n        ++ans;\\n        break;\\n      }\\n      if (i == end) {   // Visited all the items on the current level\\n        ++ans;          // Increment the level\\n        end = farthest; // Make the queue size for the next level\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n  def jump(self, nums: List[int]) -> int:\\n    ans = 0\\n    end = 0\\n    farthest = 0\\n\\n    # Implicit BFS\\n    for i in range(len(nums) - 1):\\n      farthest = max(farthest, i + nums[i])\\n      if farthest >= len(nums) - 1:\\n        ans += 1\\n        break\\n      if i == end:      # Visited all the items on the current level\\n        ans += 1        # Increment the level\\n        end = farthest  # Make the queue size for the next level\\n\\n    return ans\\n```\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n![ezgif-3-22a360561c.gif](https://assets.leetcode.com/users/images/de42de8f-f353-42b7-b09c-6408c3aa214b_1675820540.1398566.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\n```C++ []\\nclass Solution {\\n public:\\n  int jump(vector<int>& nums) {\\n    int ans = 0;\\n    int end = 0;\\n    int farthest = 0;\\n\\n    // Implicit BFS\\n    for (int i = 0; i < nums.size() - 1; ++i) {\\n      farthest = max(farthest, i + nums[i]);\\n      if (farthest >= nums.size() - 1) {\\n        ++ans;\\n        break;\\n      }\\n      if (i == end) {    // Visited all the items on the current level\\n        ++ans;           // Increment the level\\n        end = farthest;  // Make the queue size for the next level\\n      }\\n    }\\n\\n    return ans;\\n  }\\n};\\n```\n```Java []\\nclass Solution {\\n  public int jump(int[] nums) {\\n    int ans = 0;\\n    int end = 0;\\n    int farthest = 0;\\n\\n    // Implicit BFS\\n    for (int i = 0; i < nums.length - 1; ++i) {\\n      farthest = Math.max(farthest, i + nums[i]);\\n      if (farthest >= nums.length - 1) {\\n        ++ans;\\n        break;\\n      }\\n      if (i == end) {   // Visited all the items on the current level\\n        ++ans;          // Increment the level\\n        end = farthest; // Make the queue size for the next level\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n```\n```Python3 []\\nclass Solution:\\n  def jump(self, nums: List[int]) -> int:\\n    ans = 0\\n    end = 0\\n    farthest = 0\\n\\n    # Implicit BFS\\n    for i in range(len(nums) - 1):\\n      farthest = max(farthest, i + nums[i])\\n      if farthest >= len(nums) - 1:\\n        ans += 1\\n        break\\n      if i == end:      # Visited all the items on the current level\\n        ans += 1        # Increment the level\\n        end = farthest  # Make the queue size for the next level\\n\\n    return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 770191,
                "title": "cpp-recursive-memoization-o-n-three-solution-easy-to-understand",
                "content": "***Resources: https://github.com/AJAYKR00KJ/LeetCode_Solution***\\n\\n**Here is step by step three solution recursive , memoization solution and finally O(n) solution**\\n\\n**1. Recursive solution but it will give TLE:**\\n```\\nclass Solution {\\npublic:\\n \\n   long long int jump(vector<int> nums , int curr, int dest)\\n    {       \\n            if(curr>=dest) return 0; \\n            long long int tmp=INT_MAX;\\n\\t\\t\\t\\n            //Try Every jump 1 to nums[curr] jump\\n            //and find minimum steps need to reach to end\\n\\t\\t\\t\\n            for(int i=1;i<=nums[curr];i++)\\n            {\\n                tmp=min(tmp,1+jump(nums,curr+i,dest));  \\n            } \\n         return tmp;  \\n    }\\n    \\n    int jump(vector<int>& nums) { \\n         return jump(nums,0,nums.size()-1);\\n    }\\n};\\n```\\n**Time Complexity: O(k^n)**, Where,  **k** is max element of nums and **n** is size of nums.\\n**Space Complexity: O(1).**\\nBecause every time inside the recursive function it is calling itself nums[i] times and this is happening for every element (i.e n elements).  \\n\\n\\n**2. Memoization of recursive solution but it may give TLE.**\\n\\n```\\nclass Solution {\\npublic:\\n \\n   long long int jump(vector<int> &nums , int curr, int dest,vector<int> &dp)\\n    {       \\n            if(curr==dest) return 0;\\n            if(dp[curr]!=-1) return dp[curr];\\n            //cout<<curr<<\" \";\\n            long long int tmp=INT_MAX;\\n     \\n            for(int i=1;i<=nums[curr];i++)\\n            {   if(i+curr>dest) break;\\n                tmp=min(tmp,1+jump(nums,curr+i,dest,dp));  \\n            }\\n         dp[curr]=tmp;\\n         return tmp;  \\n    }\\n    \\n    int jump(vector<int>& nums) {\\n         vector<int> dp(nums.size(),-1);\\n         return jump(nums,0,nums.size()-1,dp);\\n    }\\n};\\n\\n```\\n**Time Complexity: O(k * n)**, Where,  **k** is max element of nums and **n** is size of nums.\\n**Space Complexity: O(n).**\\nBecause every time inside the recursive function it is calling itself nums[i] times and this is happening for every element (i.e n elements). But here we have stored previous calculated result, so there will be no repeation.  \\n\\n\\n\\n**3. O(n) Solution (accepted)**\\n\\n**We run loop from 0 to size()-1 because we have to reach at last index, think just previous stage when we take jump and reach to last index (size()-1) the we have counted our jump previously and we reach to last index hence we end our journey.**\\n\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        \\n        if(nums.size()<2) return 0;   //base case\\n        \\n        //initialize jump=1 , we are taking jump from 0th index to the range mxjump\\n        //currjump, we can take jump from particular  index\\n\\t\\t//mxjump , we cango up to maximum\\n\\t\\t// jump to count no. of jump\\n        int jump=1,n=nums.size(),currjmp=nums[0],mxjmp=nums[0];\\n        \\n        int i=0;\\n\\t\\t\\n\\t\\t//till we reach last index, NOTE: Not necessary to cross last index\\n        while(i<n-1)\\n        {\\n            mxjmp=max(mxjmp,i+nums[i]);\\n             \\n            if(currjmp==i) //we have to take jump now because our currjump now ends.\\n            {\\n                jump++;//increment in jump\\n                currjmp=mxjmp; //assign new maxjmp to currjmp\\n            }\\n            i++;\\n        }\\n        return jump;\\n    }\\n};\\n```\\n\\n**Time Complexity: O(n)**, Where,  **n** is size of nums.\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n \\n   long long int jump(vector<int> nums , int curr, int dest)\\n    {       \\n            if(curr>=dest) return 0; \\n            long long int tmp=INT_MAX;\\n\\t\\t\\t\\n            //Try Every jump 1 to nums[curr] jump\\n            //and find minimum steps need to reach to end\\n\\t\\t\\t\\n            for(int i=1;i<=nums[curr];i++)\\n            {\\n                tmp=min(tmp,1+jump(nums,curr+i,dest));  \\n            } \\n         return tmp;  \\n    }\\n    \\n    int jump(vector<int>& nums) { \\n         return jump(nums,0,nums.size()-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n \\n   long long int jump(vector<int> &nums , int curr, int dest,vector<int> &dp)\\n    {       \\n            if(curr==dest) return 0;\\n            if(dp[curr]!=-1) return dp[curr];\\n            //cout<<curr<<\" \";\\n            long long int tmp=INT_MAX;\\n     \\n            for(int i=1;i<=nums[curr];i++)\\n            {   if(i+curr>dest) break;\\n                tmp=min(tmp,1+jump(nums,curr+i,dest,dp));  \\n            }\\n         dp[curr]=tmp;\\n         return tmp;  \\n    }\\n    \\n    int jump(vector<int>& nums) {\\n         vector<int> dp(nums.size(),-1);\\n         return jump(nums,0,nums.size()-1,dp);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        \\n        if(nums.size()<2) return 0;   //base case\\n        \\n        //initialize jump=1 , we are taking jump from 0th index to the range mxjump\\n        //currjump, we can take jump from particular  index\\n\\t\\t//mxjump , we cango up to maximum\\n\\t\\t// jump to count no. of jump\\n        int jump=1,n=nums.size(),currjmp=nums[0],mxjmp=nums[0];\\n        \\n        int i=0;\\n\\t\\t\\n\\t\\t//till we reach last index, NOTE: Not necessary to cross last index\\n        while(i<n-1)\\n        {\\n            mxjmp=max(mxjmp,i+nums[i]);\\n             \\n            if(currjmp==i) //we have to take jump now because our currjump now ends.\\n            {\\n                jump++;//increment in jump\\n                currjmp=mxjmp; //assign new maxjmp to currjmp\\n            }\\n            i++;\\n        }\\n        return jump;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 485780,
                "title": "python-java-js-c-o-n-sol-based-on-greedy-of-coverage-with-explanation",
                "content": "O( n ) sol. based on greedy of coverage.\\n\\n---\\n\\n**Python**:\\n\\n```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        \\n        size = len(nums)\\n        \\n        # destination is last index\\n        destination = size - 1\\n        \\n        # record of current coverage, record of last jump index\\n        cur_coverage, last_jump_index = 0, 0\\n        \\n        # counter for jump\\n        times_of_jump = 0\\n        \\n         # Quick response if start index == destination index == 0\\n        if size == 1:\\n            return 0\\n        \\n        \\n        # Greedy strategy: extend coverage as long as possible with lazy jump\\n        for i in range( 0, size):\\n            \\n            # extend current coverage as further as possible\\n            cur_coverage = max( cur_coverage, i + nums[i] )\\n            \\n\\n            # forced to jump (by lazy jump) to extend coverage  \\n            if i == last_jump_index:\\n            \\n                # update last jump index\\n                last_jump_index = cur_coverage\\n                \\n                # update counter of jump by +1\\n                times_of_jump += 1\\n                \\n                # check if reached destination already\\n                if cur_coverage >= destination:\\n                        return times_of_jump\\n                \\n        return times_of_jump\\n```\\n\\n---\\n\\n**Javascript**:\\n\\n```\\nvar jump = function(nums) {\\n\\n    const size = nums.length;\\n\\n    // destination is last index\\n    let destination = size-1;\\n\\n    let curCoverage = 0, lastJumpIdx = 0;\\n\\n    // counter of jump\\n    let timesOfJump = 0;\\n\\n    // Quick response if start index == destination index == 0\\n    if( size == 1 ){\\n        return 0;\\n    }\\n\\n\\n    // Greedy stragegy: extend coverage as long as possible with lazp jump\\n    for( let i = 0 ; i < size ; i++){\\n\\n        // extend coverage\\n        curCoverage = Math.max(curCoverage, i + nums[i] );\\n\\n        // forced to jump (by lazy jump) to extend coverage\\n        if( i == lastJumpIdx ){\\n\\n            lastJumpIdx = curCoverage;\\n\\n            timesOfJump++;\\n\\n            // check if we reached destination already\\n            if( curCoverage >= destination){\\n                return timesOfJump;\\n            }\\n        }\\n    }\\n\\n    return timesOfJump;\\n    \\n\\n};\\n```\\n\\n---\\n\\n**C++**:\\n\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        \\n        const int size = nums.size();\\n        \\n        // destination is last index\\n        int destination = size-1;\\n        \\n        int curCoverage = 0, lastJumpIdx = 0;\\n        \\n        // counter of jump\\n        int timesOfJump = 0;\\n        \\n        // Quick response if start index == destination index == 0\\n        if( size == 1 ){\\n            return 0;\\n        }\\n            \\n        \\n        // Greedy stragegy: extend coverage as long as possible with lazp jump\\n        for( int i = 0 ; i < size ; i++){\\n            \\n            // extend coverage\\n            curCoverage = max(curCoverage, i + nums[i] );\\n            \\n            // forced to jump (by lazy jump) to extend coverage\\n            if( i == lastJumpIdx ){\\n                \\n                lastJumpIdx = curCoverage;\\n                \\n                timesOfJump++;\\n                \\n                // check if we reached destination already\\n                if( curCoverage >= destination){\\n                    return timesOfJump;\\n                }\\n            }\\n        }\\n        \\n        return timesOfJump;\\n    }\\n};\\n```\\n\\n---\\n\\n**Java**:\\n\\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        final int size = nums.length;\\n\\n        // destination is last index\\n        int destination = size-1;\\n\\n        int curCoverage = 0, lastJumpIdx = 0;\\n\\n        // counter of jump\\n        int timesOfJump = 0;\\n\\n        // Quick response if start index == destination index == 0\\n        if( size == 1 ){\\n            return 0;\\n        }\\n\\n\\n        // Greedy stragegy: extend coverage as long as possible with lazp jump\\n        for( int i = 0 ; i < size ; i++){\\n\\n            // extend coverage\\n            curCoverage = Math.max(curCoverage, i + nums[i] );\\n\\n            // forced to jump (by lazy jump) to extend coverage\\n            if( i == lastJumpIdx ){\\n\\n                lastJumpIdx = curCoverage;\\n\\n                timesOfJump++;\\n\\n                // check if we reached destination already\\n                if( curCoverage >= destination){\\n                    return timesOfJump;\\n                }\\n            }\\n        }\\n\\n        return timesOfJump;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        \\n        size = len(nums)\\n        \\n        # destination is last index\\n        destination = size - 1\\n        \\n        # record of current coverage, record of last jump index\\n        cur_coverage, last_jump_index = 0, 0\\n        \\n        # counter for jump\\n        times_of_jump = 0\\n        \\n         # Quick response if start index == destination index == 0\\n        if size == 1:\\n            return 0\\n        \\n        \\n        # Greedy strategy: extend coverage as long as possible with lazy jump\\n        for i in range( 0, size):\\n            \\n            # extend current coverage as further as possible\\n            cur_coverage = max( cur_coverage, i + nums[i] )\\n            \\n\\n            # forced to jump (by lazy jump) to extend coverage  \\n            if i == last_jump_index:\\n            \\n                # update last jump index\\n                last_jump_index = cur_coverage\\n                \\n                # update counter of jump by +1\\n                times_of_jump += 1\\n                \\n                # check if reached destination already\\n                if cur_coverage >= destination:\\n                        return times_of_jump\\n                \\n        return times_of_jump\\n```\n```\\nvar jump = function(nums) {\\n\\n    const size = nums.length;\\n\\n    // destination is last index\\n    let destination = size-1;\\n\\n    let curCoverage = 0, lastJumpIdx = 0;\\n\\n    // counter of jump\\n    let timesOfJump = 0;\\n\\n    // Quick response if start index == destination index == 0\\n    if( size == 1 ){\\n        return 0;\\n    }\\n\\n\\n    // Greedy stragegy: extend coverage as long as possible with lazp jump\\n    for( let i = 0 ; i < size ; i++){\\n\\n        // extend coverage\\n        curCoverage = Math.max(curCoverage, i + nums[i] );\\n\\n        // forced to jump (by lazy jump) to extend coverage\\n        if( i == lastJumpIdx ){\\n\\n            lastJumpIdx = curCoverage;\\n\\n            timesOfJump++;\\n\\n            // check if we reached destination already\\n            if( curCoverage >= destination){\\n                return timesOfJump;\\n            }\\n        }\\n    }\\n\\n    return timesOfJump;\\n    \\n\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        \\n        const int size = nums.size();\\n        \\n        // destination is last index\\n        int destination = size-1;\\n        \\n        int curCoverage = 0, lastJumpIdx = 0;\\n        \\n        // counter of jump\\n        int timesOfJump = 0;\\n        \\n        // Quick response if start index == destination index == 0\\n        if( size == 1 ){\\n            return 0;\\n        }\\n            \\n        \\n        // Greedy stragegy: extend coverage as long as possible with lazp jump\\n        for( int i = 0 ; i < size ; i++){\\n            \\n            // extend coverage\\n            curCoverage = max(curCoverage, i + nums[i] );\\n            \\n            // forced to jump (by lazy jump) to extend coverage\\n            if( i == lastJumpIdx ){\\n                \\n                lastJumpIdx = curCoverage;\\n                \\n                timesOfJump++;\\n                \\n                // check if we reached destination already\\n                if( curCoverage >= destination){\\n                    return timesOfJump;\\n                }\\n            }\\n        }\\n        \\n        return timesOfJump;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        final int size = nums.length;\\n\\n        // destination is last index\\n        int destination = size-1;\\n\\n        int curCoverage = 0, lastJumpIdx = 0;\\n\\n        // counter of jump\\n        int timesOfJump = 0;\\n\\n        // Quick response if start index == destination index == 0\\n        if( size == 1 ){\\n            return 0;\\n        }\\n\\n\\n        // Greedy stragegy: extend coverage as long as possible with lazp jump\\n        for( int i = 0 ; i < size ; i++){\\n\\n            // extend coverage\\n            curCoverage = Math.max(curCoverage, i + nums[i] );\\n\\n            // forced to jump (by lazy jump) to extend coverage\\n            if( i == lastJumpIdx ){\\n\\n                lastJumpIdx = curCoverage;\\n\\n                timesOfJump++;\\n\\n                // check if we reached destination already\\n                if( curCoverage >= destination){\\n                    return timesOfJump;\\n                }\\n            }\\n        }\\n\\n        return timesOfJump;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1192396,
                "title": "js-python-java-c-simple-o-1-space-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nSince each element of our input array (**N**) represents the maximum jump length and not the definite jump length, that means we can visit any index between the current index (**i**) and **i + N[i]**. Stretching that to its logical conclusion, we can safely iterate through **N** while keeping track of the furthest index reachable (**next**) at any given moment (**next = max(next, i + N[i])**). We\\'ll know we\\'ve found our solution once **next** reaches or passes the last index (**next >= N.length - 1**).\\n\\nThe difficulty then lies in keeping track of how many jumps it takes to reach that point. We can\\'t simply count the number of times we update **next**, as we may see that happen more than once while still in the current jump\\'s range. In fact, we can\\'t be sure of the best next jump until we reach the end of the current jump\\'s range.\\n\\nSo in addition to **next**, we\\'ll also need to keep track of the current jump\\'s endpoint (**curr**) as well as the number of jumps taken so far (**ans**).\\n\\nSince we\\'ll want to **return ans** at the earliest possibility, we should base it on **next**, as noted earlier. With careful initial definitions for **curr** and **next**, we can start our iteration at **i = 0** and **ans = 0** without the need for edge case return expressions.\\n\\n - _**Time Complexity: O(N)** where N is the length of N_\\n - _**Space Cmplexity: O(1)**_\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThere are only minor differences in the code of all four languages.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **72ms / 37.7MB** (beats 95% / 100%).\\n```javascript\\nvar jump = function(N) {\\n    let len = N.length - 1, curr = -1, next = 0, ans = 0\\n    for (let i = 0; next < len; i++) {\\n        if (i > curr) ans++, curr = next\\n        next = Math.max(next, N[i] + i)\\n    }\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **16ms / 14.0MB** (beats 100% / 99%).\\n```python\\nclass Solution:\\n    def jump(self, N: List[int]) -> int:\\n        Nlen, curr, nxt, ans, i = len(N) - 1, -1, 0, 0, 0\\n        while nxt < Nlen:\\n            if i > curr:\\n                ans += 1\\n                curr = nxt\\n            nxt = max(nxt, N[i] + i)\\n            i += 1\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 36.1MB** (beats 100% / 85%).\\n```java\\nclass Solution {\\n    public int jump(int[] N) {\\n        int len = N.length - 1, curr = -1, next = 0, ans = 0;\\n        for (int i = 0; next < len; i++) {\\n            if (i > curr) {\\n                ans++;\\n                curr = next;\\n            };\\n            next = Math.max(next, N[i] + i);\\n        };\\n        return ans;\\n    };\\n};\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 7.9MB** (beats 100% / 100%).\\n```c++\\nclass Solution {\\npublic:\\n    int jump(vector<int>& N) {\\n        int len = N.size() - 1, curr = -1, next = 0, ans = 0;\\n        for (int i = 0; next < len; i++) {\\n            if (i > curr) ans++, curr = next;\\n            next = max(next, N[i] + i);\\n        };\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar jump = function(N) {\\n    let len = N.length - 1, curr = -1, next = 0, ans = 0\\n    for (let i = 0; next < len; i++) {\\n        if (i > curr) ans++, curr = next\\n        next = Math.max(next, N[i] + i)\\n    }\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def jump(self, N: List[int]) -> int:\\n        Nlen, curr, nxt, ans, i = len(N) - 1, -1, 0, 0, 0\\n        while nxt < Nlen:\\n            if i > curr:\\n                ans += 1\\n                curr = nxt\\n            nxt = max(nxt, N[i] + i)\\n            i += 1\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int jump(int[] N) {\\n        int len = N.length - 1, curr = -1, next = 0, ans = 0;\\n        for (int i = 0; next < len; i++) {\\n            if (i > curr) {\\n                ans++;\\n                curr = next;\\n            };\\n            next = Math.max(next, N[i] + i);\\n        };\\n        return ans;\\n    };\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    int jump(vector<int>& N) {\\n        int len = N.size() - 1, curr = -1, next = 0, ans = 0;\\n        for (int i = 0; next < len; i++) {\\n            if (i > curr) ans++, curr = next;\\n            next = max(next, N[i] + i);\\n        };\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18089,
                "title": "evolve-from-brute-force-to-optimal",
                "content": "If we cannot come up with the optimal solution at first thought, we may think about the brute force method and improve it.\\n1. Brute force O(2^n), this is the most straight forward solution, just try all the moves.\\n* java\\n```\\n\\tpublic int jump(int[] nums) {\\n        return jump(0,nums);        \\n    }\\n    private int jump(int p, int[] nums) {\\n        int n = nums.length;\\n        if(p>=n-1)\\n            return 0;\\n        int minSteps = n;\\n        for(int i=1;i<=nums[p];i++) \\n            minSteps = Math.min(minSteps, 1+jump(p+i, nums));\\n        return minSteps;\\n    }\\n```\\n* c++\\n```\\n    int jump(vector<int>& nums) {\\n        return jump(0,nums);    \\n    }\\n    int jump(int p, vector<int>& nums) {\\n        int n = nums.size();\\n        if(p == n-1) return 0; //end is reached\\n        int range = p+nums[p];\\n        if(range >= n-1) return 1; //end can be reached by 1 jump from p\\n        int ret = n, mj; // n is larger than max jumps (n-1)\\n        for(int i=range;i>p;i--) {\\n            if ((mj = jump(i,nums)) == 1) return 2; //end can be reached by 2 jumps from p\\n            ret = min(ret,mj);\\n        }\\n        return ret+1;\\n    }\\n```\\n2. Memoization O(n^2)\\n* java\\n```\\n\\tInteger[] mem;\\n    public int jump(int[] nums) {\\n        mem=new Integer[nums.length];\\n        return jump(0,nums);        \\n    }\\n    private int jump(int p, int[] nums) {\\n        int n = nums.length;\\n        if(p>=n-1)\\n            return 0;\\n        if(mem[p]!=null)\\n            return mem[p];\\n        int minSteps = n;\\n        for(int i=1;i<=nums[p];i++) \\n            minSteps = Math.min(minSteps, 1+jump(p+i, nums));\\n        return mem[p]=minSteps;\\n    }\\n```\\n* c++\\n```\\n    int jump(vector<int>& nums) {\\n        vector<int> mem(nums.size(),-1);\\n        return jump(0,nums,mem);    \\n    }\\n    int jump(int p, vector<int>& nums, vector<int>& mem) {\\n        int n = nums.size();\\n        if(p == n-1) return 0;\\n        int range = p+nums[p];\\n        if(range >= n-1) return 1;\\n        if(mem[p]>=0) return mem[p];\\n        int ret = n, mj;\\n        for(int i=range;i>p;i--) {\\n            if ((mj = jump(i,nums,mem)) == 1) return mem[p]=2;\\n            ret = min(ret,mj);\\n        }\\n        return mem[p] = ret+1;\\n    }\\n```\\n3. dp O(n^2)\\n* java\\n```\\n\\tpublic int jump(int[] nums) {\\n        int n = nums.length;\\n        int[] dp=new int[n];\\n        for(int i=n-2;i>=0;i--) {\\n            dp[i]=n;\\n            for(int j=1;j<=nums[i]&&i+j<n;j++) \\n                dp[i]=Math.min(dp[i],1+dp[i+j]);\\n        }\\n        return dp[0];        \\n    }\\n```\\n* c++\\n```\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n,n);\\n        dp[n-1]=0;\\n        for(int i=n-2;i>=0;i--) {\\n            int range = i+nums[i];\\n            if (range >= n-1) { \\n                dp[i]=1;\\n                continue;\\n            }\\n            for(int j = range; j > i; j--) {\\n                if(dp[j]==1) {\\n                    dp[i]=2;\\n                    break;\\n                }\\n                dp[i] = min(dp[i],dp[j]+1);\\n            }\\n        }\\n        return dp[0];    \\n    }\\n```\\n4. Greedy O(n). There are redundancy in the above approaches. From a position, the number of steps to jump is the one that can go furthest after the jump. Because it covers all the options of the other choices.\\n* java\\n```\\n\\tpublic int jump(int[] nums) {\\n        return jump(0,nums);        \\n    }\\n    private int jump(int p, int[] nums) {\\n        int n = nums.length;\\n        if(p>=n-1)\\n            return 0;\\n        if(p+nums[p]>=n-1)\\n            return 1;\\n        int max=0, steps=0;\\n        for(int i=1;i<=nums[p];i++) {\\n            int jump2 = i+nums[p+i];\\n            if(jump2>max) {\\n                max = jump2;\\n                steps = i;\\n            }   \\n        }\\n        return 1+jump(p+steps, nums);\\n    }\\n```\\n* c++\\n```\\n    int jump(vector<int>& nums) {\\n        return jump(0,nums);    \\n    }\\n    int jump(int p, vector<int>& nums) {\\n        int n = nums.size();\\n        if(p == n-1) return 0;\\n        int range = p+nums[p];\\n        if(range >= n-1) return 1;\\n        int nxt, max_reach = -1, reach;\\n        for(int i=range; i>p;i--) {\\n            if((reach=i+nums[i]) >= n-1) return 2;\\n            if(reach > max_reach) {\\n                max_reach = reach;\\n                nxt = i;\\n            }\\n        }\\n        return 1+jump(nxt,nums);\\n    }\\n```\\n5. BFS O(n) Time, O(1) Space. The problem asks for shortest path and it is natrual to think of BFS. Nodes are array elements. For an element, neighbors are the elements that are within its max jump length. Given nodes in current level, we generate all nodes in the next level. Nodes are traversed level by level.\\n```\\n\\tpublic int jump(int[] nums) {\\n        int steps = 0, curLevelEnd = 0, nxtLevelEnd = 0;\\n        for(int i=0;i<nums.length;i++) {\\n            if(i>curLevelEnd) {\\n                steps++;\\n                curLevelEnd = nxtLevelEnd;\\n            }    \\n            nxtLevelEnd = Math.max(nxtLevelEnd, i+nums[i]);\\n        }\\n        return steps;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\tpublic int jump(int[] nums) {\\n        return jump(0,nums);        \\n    }\\n    private int jump(int p, int[] nums) {\\n        int n = nums.length;\\n        if(p>=n-1)\\n            return 0;\\n        int minSteps = n;\\n        for(int i=1;i<=nums[p];i++) \\n            minSteps = Math.min(minSteps, 1+jump(p+i, nums));\\n        return minSteps;\\n    }\\n```\n```\\n    int jump(vector<int>& nums) {\\n        return jump(0,nums);    \\n    }\\n    int jump(int p, vector<int>& nums) {\\n        int n = nums.size();\\n        if(p == n-1) return 0; //end is reached\\n        int range = p+nums[p];\\n        if(range >= n-1) return 1; //end can be reached by 1 jump from p\\n        int ret = n, mj; // n is larger than max jumps (n-1)\\n        for(int i=range;i>p;i--) {\\n            if ((mj = jump(i,nums)) == 1) return 2; //end can be reached by 2 jumps from p\\n            ret = min(ret,mj);\\n        }\\n        return ret+1;\\n    }\\n```\n```\\n\\tInteger[] mem;\\n    public int jump(int[] nums) {\\n        mem=new Integer[nums.length];\\n        return jump(0,nums);        \\n    }\\n    private int jump(int p, int[] nums) {\\n        int n = nums.length;\\n        if(p>=n-1)\\n            return 0;\\n        if(mem[p]!=null)\\n            return mem[p];\\n        int minSteps = n;\\n        for(int i=1;i<=nums[p];i++) \\n            minSteps = Math.min(minSteps, 1+jump(p+i, nums));\\n        return mem[p]=minSteps;\\n    }\\n```\n```\\n    int jump(vector<int>& nums) {\\n        vector<int> mem(nums.size(),-1);\\n        return jump(0,nums,mem);    \\n    }\\n    int jump(int p, vector<int>& nums, vector<int>& mem) {\\n        int n = nums.size();\\n        if(p == n-1) return 0;\\n        int range = p+nums[p];\\n        if(range >= n-1) return 1;\\n        if(mem[p]>=0) return mem[p];\\n        int ret = n, mj;\\n        for(int i=range;i>p;i--) {\\n            if ((mj = jump(i,nums,mem)) == 1) return mem[p]=2;\\n            ret = min(ret,mj);\\n        }\\n        return mem[p] = ret+1;\\n    }\\n```\n```\\n\\tpublic int jump(int[] nums) {\\n        int n = nums.length;\\n        int[] dp=new int[n];\\n        for(int i=n-2;i>=0;i--) {\\n            dp[i]=n;\\n            for(int j=1;j<=nums[i]&&i+j<n;j++) \\n                dp[i]=Math.min(dp[i],1+dp[i+j]);\\n        }\\n        return dp[0];        \\n    }\\n```\n```\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n,n);\\n        dp[n-1]=0;\\n        for(int i=n-2;i>=0;i--) {\\n            int range = i+nums[i];\\n            if (range >= n-1) { \\n                dp[i]=1;\\n                continue;\\n            }\\n            for(int j = range; j > i; j--) {\\n                if(dp[j]==1) {\\n                    dp[i]=2;\\n                    break;\\n                }\\n                dp[i] = min(dp[i],dp[j]+1);\\n            }\\n        }\\n        return dp[0];    \\n    }\\n```\n```\\n\\tpublic int jump(int[] nums) {\\n        return jump(0,nums);        \\n    }\\n    private int jump(int p, int[] nums) {\\n        int n = nums.length;\\n        if(p>=n-1)\\n            return 0;\\n        if(p+nums[p]>=n-1)\\n            return 1;\\n        int max=0, steps=0;\\n        for(int i=1;i<=nums[p];i++) {\\n            int jump2 = i+nums[p+i];\\n            if(jump2>max) {\\n                max = jump2;\\n                steps = i;\\n            }   \\n        }\\n        return 1+jump(p+steps, nums);\\n    }\\n```\n```\\n    int jump(vector<int>& nums) {\\n        return jump(0,nums);    \\n    }\\n    int jump(int p, vector<int>& nums) {\\n        int n = nums.size();\\n        if(p == n-1) return 0;\\n        int range = p+nums[p];\\n        if(range >= n-1) return 1;\\n        int nxt, max_reach = -1, reach;\\n        for(int i=range; i>p;i--) {\\n            if((reach=i+nums[i]) >= n-1) return 2;\\n            if(reach > max_reach) {\\n                max_reach = reach;\\n                nxt = i;\\n            }\\n        }\\n        return 1+jump(nxt,nums);\\n    }\\n```\n```\\n\\tpublic int jump(int[] nums) {\\n        int steps = 0, curLevelEnd = 0, nxtLevelEnd = 0;\\n        for(int i=0;i<nums.length;i++) {\\n            if(i>curLevelEnd) {\\n                steps++;\\n                curLevelEnd = nxtLevelEnd;\\n            }    \\n            nxtLevelEnd = Math.max(nxtLevelEnd, i+nums[i]);\\n        }\\n        return steps;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1192457,
                "title": "java-python-dp-greedy-solutions-time-o-n-space-o-1",
                "content": "**\\u2714\\uFE0F Solution 1: Top-Down DP (Some time TLE)**\\n- Let `dp(i)` denote the minimum number of steps to reach the `i`th index, starting from index `0`.\\n- Then `dp(0)` is our result.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n\\n        @lru_cache(None)\\n        def dp(i):\\n            if i == n - 1: return 0  # Reached to last index\\n            ans = math.inf\\n            maxJump = min(n - 1, i + nums[i])\\n            for j in range(i + 1, maxJump + 1):\\n                ans = min(ans, dp(j) + 1)\\n            return ans\\n\\n        return dp(0)\\n```\\n\\n**Complexity**\\n- Time: `O(N^2)`, where `N <= 10^4` is the length of array `nums`\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Top-Down DP**\\n- Let `dp[i]` denote the minimum number of steps to reach the `i`th index, starting from index `0`.\\n- Then `dp[0]` is our result.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [math.inf] * n\\n        dp[n-1] = 0\\n        \\n        for i in range(n-2, -1, -1):\\n            maxJump = min(i+nums[i], n-1)\\n            for j in range(i+1, maxJump+1):\\n                dp[i] = min(dp[i], dp[j] + 1)\\n                \\n        return dp[0]\\n```\\n\\n**Complexity**\\n- Time: `O(N^2)`, where `N <= 10^4` is the length of array `nums`\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 3: Greedy**\\n- The main idea is based on greedy. \\n- Step 1: Let\\'s say the range of the current jump is `[left, right]`, `farthest` is the farthest position that all positions in `[left, right]` can reach.\\n- Step 2: Once we reach to `right`, we trigger another jump with `left = right + 1`, `right = farthest`, then repeat step 1 util we reach at the end.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        jumps = 0\\n        farthest = 0\\n        left = right = 0\\n        while right < len(nums) - 1:\\n            for i in range(left, right + 1):\\n                farthest = max(farthest, i + nums[i])\\n            left = right + 1\\n            right = farthest\\n            jumps += 1\\n            \\n        return jumps\\n```\\n\\n**Java**\\n```java\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int jumps = 0, farthest = 0;\\n        int left = 0, right = 0;\\n        while (right < nums.length - 1) {\\n            for (int i = left; i <= right; ++i)\\n                farthest = Math.max(farthest, i + nums[i]);\\n            left = right + 1;\\n            right = farthest;\\n            ++jumps;\\n        }\\n        return jumps;\\n    }\\n}\\n```\\n\\n**Complexity**\\n- Time: `O(N)`, where `N <= 10^4` is the length of array `nums`\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n\\n        @lru_cache(None)\\n        def dp(i):\\n            if i == n - 1: return 0  # Reached to last index\\n            ans = math.inf\\n            maxJump = min(n - 1, i + nums[i])\\n            for j in range(i + 1, maxJump + 1):\\n                ans = min(ans, dp(j) + 1)\\n            return ans\\n\\n        return dp(0)\\n```\n```python\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [math.inf] * n\\n        dp[n-1] = 0\\n        \\n        for i in range(n-2, -1, -1):\\n            maxJump = min(i+nums[i], n-1)\\n            for j in range(i+1, maxJump+1):\\n                dp[i] = min(dp[i], dp[j] + 1)\\n                \\n        return dp[0]\\n```\n```python\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        jumps = 0\\n        farthest = 0\\n        left = right = 0\\n        while right < len(nums) - 1:\\n            for i in range(left, right + 1):\\n                farthest = max(farthest, i + nums[i])\\n            left = right + 1\\n            right = farthest\\n            jumps += 1\\n            \\n        return jumps\\n```\n```java\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int jumps = 0, farthest = 0;\\n        int left = 0, right = 0;\\n        while (right < nums.length - 1) {\\n            for (int i = left; i <= right; ++i)\\n                farthest = Math.max(farthest, i + nums[i]);\\n            left = right + 1;\\n            right = farthest;\\n            ++jumps;\\n        }\\n        return jumps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1197063,
                "title": "intuitive-explanation-w-solution-analysis-java-beginner-dp",
                "content": "This problem is one of the simplest and best problems for beginners to understand one of the most difficult yet rewarding algorithm - **Dynamic Programming**. The aim of the post is not to just throw away with a working solution, rather provide a new perspective for beginners and potential learners on how to deconstruct a problem statement to understand the crux of it and reconstruct back into a working algorithm. Let\\'s quickly get into the process of understanding the problem and coming up with some intuitions and solutions.\\n\\n**INTUITION**\\n1. **It is mentioned in the problem that we start from the initial position and we can always reach the end position. We need to reach them with minimum possible steps.**\\nThis means that from the start position, there can be one or many possible ways of jumps (traversing through multiple sets of indices) to reach the end point. Hence it will be initially necessary to have a data structure that stores the optimum number of jumps to reach any particular index. Since the constraints states that the input array length will be less than 1000 *(1 <= nums.length <= 1000)*, we create an output array of length 1000 *(ideally length of input array)* and maintain the minimum jumps required to reach each position.\\n\\n2. **All indices are unreachable initially.**\\nSince we start from the first position, it is impossible to reach all the other indices without making the first move. So all of them can be initialized with some maximum value *(1e9 or Integer.MAX_VALUE)*. However, since we are standing in the first position, it is reachable by default without making any move. Hence we initialize the value of the first index in the output array as 0.\\n\\n**CODE & EXPLANTION**\\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int i,n,j;\\n        n=nums.length;\\n        int [] pre = new int[n];\\n        for(i=0;i<n;i++)\\n        {\\n            // Initialize all the index position with some max value to denote it is unreachable\\n            pre[i] = Integer.MAX_VALUE;\\n        }\\n        \\n        // Make the first position value as 0 as it is the default place where we start\\n        pre[0] = 0;\\n\\t\\t// Main condition check goes here.\\n        for(i=0;i<n;i++)\\n        {\\n            for(j=i;j<=i+nums[i] && j<n;j++)\\n            {\\n                pre[j] = Math.min(pre[j], pre[i]+1);\\n            }\\n        }\\n        return pre[n-1];\\n    }\\n}\\n```\\n\\nLet\\'s try to understand the loop where the main condition check happens. Each value in the nums array specifies the jump that is possible to take from the current position. So if the value in the ith index is nums[i], then it is understandable that from **(ith) position to (i+nums[i])th position** *(i, i+1, i+2, ...., i+nums[i])*, it can be reached in a single jump. However as already mentioned, since a particular position can be reached from various other position, we need to store the minimum possible jump value to reach the position.\\n*pre[j] = Math.min(pre[j], pre[i]+1)*.\\n\\nBy filling it this way, we can naturally fill the way the last element is reached also and return the pre[n-1] value directly.\\n\\nThere goes around a popular saying that *\\'When one learns things right, he learns them only once\\'*. There could be many people (including me :P) who would have done hundreds of problems and still finds it difficult to crack the next one because of a gap in the understanding and ability to convert that into code. Lets make use of this post to address some basic intuitions and approaches along with constructing a solution for this problem.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int i,n,j;\\n        n=nums.length;\\n        int [] pre = new int[n];\\n        for(i=0;i<n;i++)\\n        {\\n            // Initialize all the index position with some max value to denote it is unreachable\\n            pre[i] = Integer.MAX_VALUE;\\n        }\\n        \\n        // Make the first position value as 0 as it is the default place where we start\\n        pre[0] = 0;\\n\\t\\t// Main condition check goes here.\\n        for(i=0;i<n;i++)\\n        {\\n            for(j=i;j<=i+nums[i] && j<n;j++)\\n            {\\n                pre[j] = Math.min(pre[j], pre[i]+1);\\n            }\\n        }\\n        return pre[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18207,
                "title": "sharing-my-straightforward-c-solution",
                "content": "    int jump(int A[], int n) {\\n        if(n == 0){\\n            return 0;\\n        }\\n        int maxReachPos = A[0];\\n        int curMaxReachPos = A[0];\\n        int curStep = 1;\\n        for(int i = 1; i <= min(n, maxReachPos); i++){\\n            curMaxReachPos = max(curMaxReachPos, i + A[i]);\\n            if(i == n - 1){\\n                return curStep;\\n            }\\n            if(i == maxReachPos){\\n                maxReachPos = curMaxReachPos;\\n                curStep++;\\n            }\\n        }\\n        return 0;\\n    }\\n\\nThe variable maxReachPos indicates the farthest reachable position and the variable curMaxReachPos indicates the current farthest reachable position.\\n\\nAt the very beginning, both maxReachPos and curMaxReachPos are equal to A[0].\\n\\nIn the For loop, we keep updating curMaxReachPos while i <= maxReachPos. However, if( i == n - 1), we return curStep, which is the minimum step. If i reaches the maxReachPos, we update maxReachPos with curMaxReachPos and increment curStep by one. \\n\\nFinally, if we can't reach the end point, just return 0.",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "    int jump(int A[], int n) {\\n        if(n == 0){\\n            return 0;\\n        }\\n        int maxReachPos = A[0];\\n        int curMaxReachPos = A[0];\\n        int curStep = 1;\\n        for(int i = 1; i <= min(n, maxReachPos); i++){\\n            curMaxReachPos = max(curMaxReachPos, i + A[i]);\\n            if(i == n - 1){\\n                return curStep;\\n            }\\n            if(i == maxReachPos){\\n                maxReachPos = curMaxReachPos;\\n                curStep++;\\n            }\\n        }\\n        return 0;\\n    }\\n\\nThe variable maxReachPos indicates the farthest reachable position and the variable curMaxReachPos indicates the current farthest reachable position.\\n\\nAt the very beginning, both maxReachPos and curMaxReachPos are equal to A[0].\\n\\nIn the For loop, we keep updating curMaxReachPos while i <= maxReachPos. However, if( i == n - 1), we return curStep, which is the minimum step. If i reaches the maxReachPos, we update maxReachPos with curMaxReachPos and increment curStep by one. \\n\\nFinally, if we can't reach the end point, just return 0.",
                "codeTag": "Unknown"
            },
            {
                "id": 3158205,
                "title": "super-easy-solution-fully-explained-c-python-commented",
                "content": "# Consider\\uD83D\\uDC4D\\n```\\n                    Please Upvote If You Find It Helpful\\n```\\n\\n# Intuition\\nIn this question we have to find the minimum number of jumps to reach the last index.\\nSo, we calculate the maximum index we can reach from the current index.\\nIf our pointer `i` reaches the last index that can be reached with current number of jumps then we have to make a jumps.\\nSo, we increase the `count`. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : Greedy Approach\\n    Example\\n    nums = [2,3,1,1,4]\\n    Here at index `0` reach become 2 and `i` == `last`. \\n    So increase the `count`(1)\\n    At index `1` `reach` becomes `4`.\\n    So, when `i` becomes `2` it becomes equal to last.\\n    We update last with current maximum jump(`reach`) last = 4.\\n    And increase `count`.\\n    So, answer  = 2.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int reach=0, count=0, last=0;  // reach: maximum reachable index from current position\\n    // count: number of jumps made so far\\n    // last: rightmost index that has been reached so far\\n        for(int i=0;i<nums.size()-1;i++){  // loop through the array excluding the last element\\n            reach = max(reach, i+nums[i]);  // update reach to the maximum between reach and i+nums[i]\\n            if(i==last){  // if i has reached the last index that can be reached with the current number of jumps\\n                last = reach;  // update last to the new maximum reachable index\\n                count++;  // increment the number of jumps made so far\\n            }\\n        }\\n        return count;  // return the minimum number of jumps required\\n    }\\n};\\n\\n```\\n```python []\\nclass Solution:\\n    def jump(self, nums):\\n        # Initialize reach (maximum reachable index), count (number of jumps), and last (rightmost index reached)\\n        reach, count, last = 0, 0, 0\\n        \\n        # Loop through the array excluding the last element\\n        for i in range(len(nums)-1):    \\n            # Update reach to the maximum between reach and i + nums[i]\\n            reach = max(reach, i + nums[i])\\n        \\n            # If i has reached the last index that can be reached with the current number of jumps\\n            if i == last:\\n                # Update last to the new maximum reachable index\\n                last = reach\\n                # Increment the number of jumps made so far\\n                count += 1\\n        \\n        # Return the minimum number of jumps required\\n        return count\\n\\n```\\n\\n```\\n              Give a \\uD83D\\uDC4D. It motivates me alot\\n```\\nLet\\'s Connect On [Linkedin](https://www.linkedin.com/in/naman-agarwal-0551aa1aa/)",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\n                    Please Upvote If You Find It Helpful\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int reach=0, count=0, last=0;  // reach: maximum reachable index from current position\\n    // count: number of jumps made so far\\n    // last: rightmost index that has been reached so far\\n        for(int i=0;i<nums.size()-1;i++){  // loop through the array excluding the last element\\n            reach = max(reach, i+nums[i]);  // update reach to the maximum between reach and i+nums[i]\\n            if(i==last){  // if i has reached the last index that can be reached with the current number of jumps\\n                last = reach;  // update last to the new maximum reachable index\\n                count++;  // increment the number of jumps made so far\\n            }\\n        }\\n        return count;  // return the minimum number of jumps required\\n    }\\n};\\n\\n```\n```python []\\nclass Solution:\\n    def jump(self, nums):\\n        # Initialize reach (maximum reachable index), count (number of jumps), and last (rightmost index reached)\\n        reach, count, last = 0, 0, 0\\n        \\n        # Loop through the array excluding the last element\\n        for i in range(len(nums)-1):    \\n            # Update reach to the maximum between reach and i + nums[i]\\n            reach = max(reach, i + nums[i])\\n        \\n            # If i has reached the last index that can be reached with the current number of jumps\\n            if i == last:\\n                # Update last to the new maximum reachable index\\n                last = reach\\n                # Increment the number of jumps made so far\\n                count += 1\\n        \\n        # Return the minimum number of jumps required\\n        return count\\n\\n```\n```\\n              Give a \\uD83D\\uDC4D. It motivates me alot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18152,
                "title": "java-solution-with-explanation",
                "content": "    public class Solution {\\n    public int jump(int[] nums) {\\n        // If nums.length < 2, means that we do not\\n        // need to move at all.\\n        if (nums == null || nums.length < 2) {\\n            return 0;\\n        }\\n\\n        // First set up current region, which is\\n        // from 0 to nums[0].\\n        int l = 0;\\n        int r = nums[0];\\n        // Since the length of nums is greater than\\n        // 1, we need at least 1 step.\\n        int step = 1;\\n\\n        // We go through all elements in the region.\\n        while (l <= r) {\\n\\n            // If the right of current region is greater\\n            // than nums.length - 1, that means we are done.\\n            if (r >= nums.length - 1) {\\n                return step;\\n            }\\n\\n            // We should know how far can we reach in current\\n            // region.\\n            int max = Integer.MIN_VALUE;\\n            for (; l <= r; l++) {\\n                max = Math.max(max, l + nums[l]);\\n            }\\n\\n            // If we can reach far more in this round, we update\\n            // the boundary of current region, and also add a step.\\n            if (max > r) {\\n                l = r;\\n                r = max;\\n                step++;\\n            }\\n        }\\n\\n        // We can not finish the job.\\n        return -1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int jump(int[] nums) {\\n        // If nums.length < 2, means that we do not\\n        // need to move at all.\\n        if (nums == null || nums.length < 2) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1192398,
                "title": "jump-game-ii-js-python-java-c-simple-o-1-space-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nSince each element of our input array (**N**) represents the maximum jump length and not the definite jump length, that means we can visit any index between the current index (**i**) and **i + N[i]**. Stretching that to its logical conclusion, we can safely iterate through **N** while keeping track of the furthest index reachable (**next**) at any given moment (**next = max(next, i + N[i])**). We\\'ll know we\\'ve found our solution once **next** reaches or passes the last index (**next >= N.length - 1**).\\n\\nThe difficulty then lies in keeping track of how many jumps it takes to reach that point. We can\\'t simply count the number of times we update **next**, as we may see that happen more than once while still in the current jump\\'s range. In fact, we can\\'t be sure of the best next jump until we reach the end of the current jump\\'s range.\\n\\nSo in addition to **next**, we\\'ll also need to keep track of the current jump\\'s endpoint (**curr**) as well as the number of jumps taken so far (**ans**).\\n\\nSince we\\'ll want to **return ans** at the earliest possibility, we should base it on **next**, as noted earlier. With careful initial definitions for **curr** and **next**, we can start our iteration at **i = 0** and **ans = 0** without the need for edge case return expressions.\\n\\n - _**Time Complexity: O(N)** where N is the length of N_\\n - _**Space Cmplexity: O(1)**_\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThere are only minor differences in the code of all four languages.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **72ms / 37.7MB** (beats 95% / 100%).\\n```javascript\\nvar jump = function(N) {\\n    let len = N.length - 1, curr = -1, next = 0, ans = 0\\n    for (let i = 0; next < len; i++) {\\n        if (i > curr) ans++, curr = next\\n        next = Math.max(next, N[i] + i)\\n    }\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **16ms / 14.0MB** (beats 100% / 99%).\\n```python\\nclass Solution:\\n    def jump(self, N: List[int]) -> int:\\n        Nlen, curr, nxt, ans, i = len(N) - 1, -1, 0, 0, 0\\n        while nxt < Nlen:\\n            if i > curr:\\n                ans += 1\\n                curr = nxt\\n            nxt = max(nxt, N[i] + i)\\n            i += 1\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 36.1MB** (beats 100% / 85%).\\n```java\\nclass Solution {\\n    public int jump(int[] N) {\\n        int len = N.length - 1, curr = -1, next = 0, ans = 0;\\n        for (int i = 0; next < len; i++) {\\n            if (i > curr) {\\n                ans++;\\n                curr = next;\\n            };\\n            next = Math.max(next, N[i] + i);\\n        };\\n        return ans;\\n    };\\n};\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 7.9MB** (beats 100% / 100%).\\n```c++\\nclass Solution {\\npublic:\\n    int jump(vector<int>& N) {\\n        int len = N.size() - 1, curr = -1, next = 0, ans = 0;\\n        for (int i = 0; next < len; i++) {\\n            if (i > curr) ans++, curr = next;\\n            next = max(next, N[i] + i);\\n        };\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar jump = function(N) {\\n    let len = N.length - 1, curr = -1, next = 0, ans = 0\\n    for (let i = 0; next < len; i++) {\\n        if (i > curr) ans++, curr = next\\n        next = Math.max(next, N[i] + i)\\n    }\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def jump(self, N: List[int]) -> int:\\n        Nlen, curr, nxt, ans, i = len(N) - 1, -1, 0, 0, 0\\n        while nxt < Nlen:\\n            if i > curr:\\n                ans += 1\\n                curr = nxt\\n            nxt = max(nxt, N[i] + i)\\n            i += 1\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int jump(int[] N) {\\n        int len = N.length - 1, curr = -1, next = 0, ans = 0;\\n        for (int i = 0; next < len; i++) {\\n            if (i > curr) {\\n                ans++;\\n                curr = next;\\n            };\\n            next = Math.max(next, N[i] + i);\\n        };\\n        return ans;\\n    };\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    int jump(vector<int>& N) {\\n        int len = N.size() - 1, curr = -1, next = 0, ans = 0;\\n        for (int i = 0; next < len; i++) {\\n            if (i > curr) ans++, curr = next;\\n            next = max(next, N[i] + i);\\n        };\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1098179,
                "title": "fully-commented-and-explained-greedy-approach-in-6-liner-code",
                "content": "```\\nint jump(vector<int>& nums) {\\n        \\n        int numOfJumps = 0, currentIntervalEnd = 0, farthestReachFoundSoFar = 0;\\n        \\n        for(int i = 0 ; i < nums.size() - 1 ; i++) {     // Because you can stop the work once youve\\n                                                                            // reached the last index\\n            farthestReachFoundSoFar = max(farthestReachFoundSoFar, i + nums[i]);    // maximize our                                                                                                    \\n                                                                                    // reach\\n            if(i == currentIntervalEnd) {                // When we reach the end of current intervals\\n                                                         // end, we need to make our next jump and\\n                numOfJumps++;                            // and update our current interval end with       \\n                currentIntervalEnd = farthestReachFoundSoFar;   // the farthest reach found so far\\n                                                         // We made sure this was the best possible jump\\n            }                                            // because we traversed th whole interval and \\n        }                                                // maximized our reach and now we are sure\\n        return numOfJumps;                               // where our next jump will be. Greedy!\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nint jump(vector<int>& nums) {\\n        \\n        int numOfJumps = 0, currentIntervalEnd = 0, farthestReachFoundSoFar = 0;\\n        \\n        for(int i = 0 ; i < nums.size() - 1 ; i++) {     // Because you can stop the work once youve\\n                                                                            // reached the last index\\n            farthestReachFoundSoFar = max(farthestReachFoundSoFar, i + nums[i]);    // maximize our                                                                                                    \\n                                                                                    // reach\\n            if(i == currentIntervalEnd) {                // When we reach the end of current intervals\\n                                                         // end, we need to make our next jump and\\n                numOfJumps++;                            // and update our current interval end with       \\n                currentIntervalEnd = farthestReachFoundSoFar;   // the farthest reach found so far\\n                                                         // We made sure this was the best possible jump\\n            }                                            // because we traversed th whole interval and \\n        }                                                // maximized our reach and now we are sure\\n        return numOfJumps;                               // where our next jump will be. Greedy!\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 18093,
                "title": "sharing-my-ac-java-solution",
                "content": "Hi All, below is my AC solution:\\n \\n>     public int jump(int[] A) {\\n>         int maxReach = A[0];\\n>         int edge = 0;\\n>         int minstep = 0;\\n>         \\n>         for(int i = 1; i < A.length; i++) {\\n>             if (i > edge) {\\n>                 minstep += 1;\\n>                 edge = maxReach;\\n>                 if(edge > A.length - 1)\\n>                     return minstep;\\n>             }\\n>             maxReach = Math.max(maxReach, A[i] + i);\\n>             if (maxReach == i):\\n>                 return -1;\\n>         }\\n>         \\n>         return minstep;\\n>     } \\n\\nWhen iterate the array, I set an edge for the Search phase, which means that if I exceeds the edge, the minstep must add one and the maxReach will be update. And when the last index is within the range of the edge, output the minstep.\\n\\n[2, 3, 1, 1, 4]\\n\\nFirst, the edge is 0;\\nSecond, after start iterate the array, it exceeds the edge 0 when reaching the A[0] and update the edge to 2;\\nThird, after it reach the A[2], it exceeds the edge 2 and update the new edge to the maxReach 4.\\nFinally, end of the array is inside the edge, output the minstep.",
                "solutionTags": [],
                "code": "Hi All, below is my AC solution:\\n \\n>     public int jump(int[] A) {\\n>         int maxReach = A[0];\\n>         int edge = 0;\\n>         int minstep = 0;\\n>         \\n>         for(int i = 1; i < A.length; i++) {\\n>             if (i > edge) {\\n>                 minstep += 1;\\n>                 edge = maxReach;\\n>                 if(edge > A.length - 1)\\n>                     return minstep;\\n>             }\\n>             maxReach = Math.max(maxReach, A[i] + i);\\n>             if (maxReach == i):\\n>                 return -1;\\n>         }\\n>         \\n>         return minstep;\\n>     } \\n\\nWhen iterate the array, I set an edge for the Search phase, which means that if I exceeds the edge, the minstep must add one and the maxReach will be update. And when the last index is within the range of the edge, output the minstep.\\n\\n[2, 3, 1, 1, 4]\\n\\nFirst, the edge is 0;\\nSecond, after start iterate the array, it exceeds the edge 0 when reaching the A[0] and update the edge to 2;\\nThird, after it reach the A[2], it exceeds the edge 2 and update the new edge to the maxReach 4.\\nFinally, end of the array is inside the edge, output the minstep.",
                "codeTag": "Unknown"
            },
            {
                "id": 2591598,
                "title": "recursion-memoization-tabulation-o-n-with-constant-space",
                "content": "# Recursion\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        return f(0, n, nums);\\n    }\\n\\t\\n\\tint f(int ind, int n, vector<int>& nums) {\\n        if(ind == n-1) return 0;\\n        \\n        int jump = nums[ind], mini = 1e9;\\n        for(int i = ind + 1; i <= min(ind+jump, n-1); i++) {\\n            int val = 1 + f(i, n, nums);\\n            mini = min(mini, val);\\n        }\\n        return mini;\\n    }\\n\\t\\n# \\tMemoization\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, -1);\\n        return f(0, n, nums, dp);\\n    }\\n\\t\\n\\tint f(int ind, int n, vector<int>& nums, vector<int>& dp) {\\n        if(ind == n-1) return 0;\\n        if(dp[ind] != -1) return dp[ind];\\n        \\n        int jump = nums[ind], mini = 1e9;\\n        for(int i = ind + 1; i <= min(ind+jump, n-1); i++) {\\n            int val = 1 + f(i, n, nums, dp);\\n            mini = min(mini, val);\\n        }\\n        return dp[ind] = mini;\\n    }\\n\\t\\n# \\tTabulation\\n```\\nint jump(vector<int>& nums) {\\n\\tint n = nums.size();\\n\\tvector<int> dp(n, 0);\\n\\n\\tfor(int ind = n-2; ind >= 0; ind--) {\\n\\t\\tint jump = nums[ind], mini = 1e9;\\n\\t\\tfor(int i = ind + 1; i <= min(ind+jump, n-1); i++) {\\n\\t\\t\\tint val = 1 + dp[i];\\n\\t\\t\\tmini = min(mini, val);\\n\\t\\t}\\n\\t\\tdp[ind] = mini;\\n\\t}\\n\\treturn dp[0];\\n}\\n```\\n\\n# Optimal\\n```\\nint jump(vector<int>& nums) {\\n\\tint jump_cnt = 0, curLimit = 0, limit = 0;\\n\\tfor(int i = 0; i < nums.size() - 1; i++) {\\n\\t\\tlimit = max(limit, i + nums[i]);\\n\\t\\tif(i == curLimit){\\n\\t\\t\\tjump_cnt++;\\n\\t\\t\\tcurLimit = limit;\\n\\t\\t}\\n\\t}\\n\\treturn jump_cnt;\\n}\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nint jump(vector<int>& nums) {\\n\\tint n = nums.size();\\n\\tvector<int> dp(n, 0);\\n\\n\\tfor(int ind = n-2; ind >= 0; ind--) {\\n\\t\\tint jump = nums[ind], mini = 1e9;\\n\\t\\tfor(int i = ind + 1; i <= min(ind+jump, n-1); i++) {\\n\\t\\t\\tint val = 1 + dp[i];\\n\\t\\t\\tmini = min(mini, val);\\n\\t\\t}\\n\\t\\tdp[ind] = mini;\\n\\t}\\n\\treturn dp[0];\\n}\\n```\n```\\nint jump(vector<int>& nums) {\\n\\tint jump_cnt = 0, curLimit = 0, limit = 0;\\n\\tfor(int i = 0; i < nums.size() - 1; i++) {\\n\\t\\tlimit = max(limit, i + nums[i]);\\n\\t\\tif(i == curLimit){\\n\\t\\t\\tjump_cnt++;\\n\\t\\t\\tcurLimit = limit;\\n\\t\\t}\\n\\t}\\n\\treturn jump_cnt;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 18035,
                "title": "easy-python-greedy-solution-with-explanation",
                "content": "    class Solution:\\n    # @param A, a list of integers\\n    # @return an integer\\n    def jump(self, A):\\n        last_max_reach, current_max_reach = 0 , 0\\n        njump , i = 0 , 0\\n        while current_max_reach < len(A)-1:\\n            while i <= last_max_reach:\\n                current_max_reach = max(i+A[i],current_max_reach)\\n                i+=1\\n            if last_max_reach == current_max_reach:\\n                return -1\\n            last_max_reach = current_max_reach\\n            njump+=1\\n        return njump\\n\\n\\nThe basic thoughts underline is a greedy style. Every one more jump, you want to jump as far as possible.\\nIn Jump Game I, when you at position i, you care about what is the furthest position could be reached from i th position. but here in Jump Game II, instead you care about what would be the next furthest jump could be made when you could reach as far as ith position from last jump.  So you iterate all positions could be reached from last jump till i th position to find it out.",
                "solutionTags": [],
                "code": "    class Solution:\\n    # @param A, a list of integers\\n    # @return an integer\\n    def jump(self, A):\\n        last_max_reach, current_max_reach = 0 , 0\\n        njump , i = 0 , 0\\n        while current_max_reach < len(A)-1:\\n            while i <= last_max_reach:\\n                current_max_reach = max(i+A[i],current_max_reach)\\n                i+=1\\n            if last_max_reach == current_max_reach:\\n                return -1\\n            last_max_reach = current_max_reach\\n            njump+=1\\n        return njump\\n\\n\\nThe basic thoughts underline is a greedy style. Every one more jump, you want to jump as far as possible.\\nIn Jump Game I, when you at position i, you care about what is the furthest position could be reached from i th position. but here in Jump Game II, instead you care about what would be the next furthest jump could be made when you could reach as far as ith position from last jump.  So you iterate all positions could be reached from last jump till i th position to find it out.",
                "codeTag": "Java"
            },
            {
                "id": 1355952,
                "title": "swift-jump-game-ii-test-cases",
                "content": "```swift\\nclass Solution {\\n    func jump(_ nums: [Int]) -> Int {\\n        guard 1 <= nums.count && nums.count <= Int(10e4) else { return 0 }\\n        var step = 0, end = 0, maxPos = 0\\n        for i in 0..<nums.count - 1 {\\n            maxPos = max(maxPos, i + nums[i])\\n            if i == end { end = maxPos; step += 1 }\\n        }\\n        return step\\n    }\\n}\\n```\\n\\n```swift\\nimport XCTest\\n\\n// Executed 2 tests, with 0 failures (0 unexpected) in 0.005 (0.007) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        let res = s.jump([2,3,1,1,4])\\n        XCTAssertEqual(res, 2)\\n    }\\n    func test1() {\\n        let res = s.jump([2,3,0,1,4])\\n        XCTAssertEqual(res, 2)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func jump(_ nums: [Int]) -> Int {\\n        guard 1 <= nums.count && nums.count <= Int(10e4) else { return 0 }\\n        var step = 0, end = 0, maxPos = 0\\n        for i in 0..<nums.count - 1 {\\n            maxPos = max(maxPos, i + nums[i])\\n            if i == end { end = maxPos; step += 1 }\\n        }\\n        return step\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 2 tests, with 0 failures (0 unexpected) in 0.005 (0.007) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        let res = s.jump([2,3,1,1,4])\\n        XCTAssertEqual(res, 2)\\n    }\\n    func test1() {\\n        let res = s.jump([2,3,0,1,4])\\n        XCTAssertEqual(res, 2)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383112,
                "title": "to-all-my-struggling-friends-don-t-worry-its-fine",
                "content": "If you are not able to do it, its completely fine. I have also went over 10+ solutions and finally compiled below solution. \\nPut this code in the IDE and debug step by step. I bet you will understand it. \\n# ***Explanation:*** \\nSince we are already at nums[0]. The no of steps to reach on nums[0] is 0.\\nFrom n = 1 to nums.length-1, do this: \\nAt each step, calculate min steps to reach that step i.e. if you are at step 1, loop from begining and get the min jumps to reach step1. Similarly if you are at step 2, calculate min steps needed to reach step 2 by looping from begining and get min steps. \\n\\n```\\npublic int jump(int[] nums) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        Arrays.fill(dp, Integer.MAX_VALUE); //Initially we do not know, what is min steps, hence initialize all with Integer.MAX_Value.\\n        dp[0] = 0;\\n        for (int i = 1; i < n; i++) { //Start from 1 to n\\n            for (int j = 0; j < i; j++) { //At each index, get min steps to reach dp[i] by looping from begining (i.e. start from 0 till i)\\n                if (j + nums[j] >= i) { //if j+nums[j] >=i, then from \\'j\\' index we can have j+nums[j] jump, which can reach (or go over) nums[i]. This means we can jump from index \\'j\\'.\\n                    dp[i] = Math.min(dp[i], dp[j] + 1); //Check if the this is min.\\n                }\\n            }\\n        }\\n        return dp[n - 1];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int jump(int[] nums) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        Arrays.fill(dp, Integer.MAX_VALUE); //Initially we do not know, what is min steps, hence initialize all with Integer.MAX_Value.\\n        dp[0] = 0;\\n        for (int i = 1; i < n; i++) { //Start from 1 to n\\n            for (int j = 0; j < i; j++) { //At each index, get min steps to reach dp[i] by looping from begining (i.e. start from 0 till i)\\n                if (j + nums[j] >= i) { //if j+nums[j] >=i, then from \\'j\\' index we can have j+nums[j] jump, which can reach (or go over) nums[i]. This means we can jump from index \\'j\\'.\\n                    dp[i] = Math.min(dp[i], dp[j] + 1); //Check if the this is min.\\n                }\\n            }\\n        }\\n        return dp[n - 1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 774616,
                "title": "easy-linear-time-o-n-and-space-o-1-explanation",
                "content": "1. We start travering the array from start\\n2. While traversing, we keep a track on maximum reachable index and update it accordingly.\\n3. If we reach the previous reachable index, this implies we have reached this index with current jumps and now we can reach the next maximum possible index by  **current jumps+1** jumps and update the previous reachable index to maximum reachable index. Now, if updated previous reachable index is greater than equal to last index, just return the jump count.  \\n\\n```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        if len(nums)==1: return 0\\n        \\n        reachableIndex = 0\\n        previousReachableIndex = 0\\n        jump = 0\\n\\n        for curr in range(len(nums)):\\n            if curr + nums[curr] >= reachableIndex:\\n                reachableIndex = curr + nums[curr]\\n\\n            if curr == previousReachableIndex:\\n                jump += 1\\n                previousReachableIndex = reachableIndex\\n                if previousReachableIndex >= len(nums) - 1:\\n                    return jump\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        if len(nums)==1: return 0\\n        \\n        reachableIndex = 0\\n        previousReachableIndex = 0\\n        jump = 0\\n\\n        for curr in range(len(nums)):\\n            if curr + nums[curr] >= reachableIndex:\\n                reachableIndex = curr + nums[curr]\\n\\n            if curr == previousReachableIndex:\\n                jump += 1\\n                previousReachableIndex = reachableIndex\\n                if previousReachableIndex >= len(nums) - 1:\\n                    return jump\\n```",
                "codeTag": "Java"
            },
            {
                "id": 659010,
                "title": "easiest-step-by-step-bfs-solution-o-n",
                "content": "This problem can be changed to a tree problem, with the search tree looks like below:\\n![image](https://assets.leetcode.com/users/leih/image_1590776042.png)\\nOur goal is to find the shortest path from root to a target node, sounds like a traditional BFS question? This leads to our first solution:\\n```\\nfrom collections import deque\\nclass Solution(object):\\n    def jump(self, nums):\\n        n = len(nums)\\n        visited, queue = [False for i in range(n)], deque()\\n        queue.append((0, 0))\\n        visited[0] = True\\n        while queue:\\n            pos, step = queue.popleft()\\n            if pos == n - 1:\\n                return step\\n            for jump in range(1, min(nums[pos] + 1, n - pos)):\\n                if not visited[pos + jump]:\\n                    queue.append((pos + jump, step + 1))\\n                    visited[pos + jump] = True\\n```\\nThis solution gets TLE with time complexity `O(n^2)`. Where is the bottleneck? We know the time complexity of the best solution could NOT be less than `O(n)` since we need to jump step by step in the case of [1, 1, 1, 1, ....., 1, 1]. For each position, do we really need to check its every possible next postion with 1 jump?  The answer is NO, because some of such positions have been visited.\\n\\nIn solution 1, we used a `visited` array to record these positions, but we actually can just ignore these positions and only consider the positions that have not been visited. Note that the visited positions are consecutive, which means if position `j + 1` has been visited, position `j` also has been visited. We can use a variable `maxVisitedPos` to keep tracking the largest position that has been visited. For the jump at a position, we just check the positions that are further than `maxVisitedPos`. As such, each position will be operated at most twice (append and popleft), which gives us `O(n)` complexity and we know there cannot be a better solution.\\n\\n```\\nfrom collections import deque\\nclass Solution(object):\\n    def jump(self, nums):\\n        n, queue = len(nums), deque()\\n        queue.append((0, 0))\\n        maxVisitedPos = 0\\n        while queue:\\n            pos, step = queue.popleft()\\n            if pos == n - 1:\\n                return step\\n            for jump in range(maxVisitedPos - pos + 1, min(nums[pos] + 1, n - pos)):\\n                queue.append((pos + jump, step + 1))\\n                maxVisitedPos = pos + jump\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution(object):\\n    def jump(self, nums):\\n        n = len(nums)\\n        visited, queue = [False for i in range(n)], deque()\\n        queue.append((0, 0))\\n        visited[0] = True\\n        while queue:\\n            pos, step = queue.popleft()\\n            if pos == n - 1:\\n                return step\\n            for jump in range(1, min(nums[pos] + 1, n - pos)):\\n                if not visited[pos + jump]:\\n                    queue.append((pos + jump, step + 1))\\n                    visited[pos + jump] = True\\n```\n```\\nfrom collections import deque\\nclass Solution(object):\\n    def jump(self, nums):\\n        n, queue = len(nums), deque()\\n        queue.append((0, 0))\\n        maxVisitedPos = 0\\n        while queue:\\n            pos, step = queue.popleft()\\n            if pos == n - 1:\\n                return step\\n            for jump in range(maxVisitedPos - pos + 1, min(nums[pos] + 1, n - pos)):\\n                queue.append((pos + jump, step + 1))\\n                maxVisitedPos = pos + jump\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158986,
                "title": "java-solution-fast-1ms-runtime",
                "content": "# JAVA Code\\n\\n99% faster code [1ms runtime]\\n\\n``` JAVA []\\nclass Solution {\\n    public int jump(int[] N) {\\n        int len = N.length - 1, curr = -1, next = 0, ans = 0;\\n        for (int i = 0; next < len; i++) {\\n            if (i > curr) {\\n                ans++;\\n                curr = next;\\n            };\\n            next = Math.max(next, N[i] + i);\\n        };\\n        return ans;\\n    };\\n};\\n```\\n\\n![kitty.jpeg](https://assets.leetcode.com/users/images/94908bb9-b442-4096-9b26-4debb918ed16_1675838156.0297992.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` JAVA []\\nclass Solution {\\n    public int jump(int[] N) {\\n        int len = N.length - 1, curr = -1, next = 0, ans = 0;\\n        for (int i = 0; next < len; i++) {\\n            if (i > curr) {\\n                ans++;\\n                curr = next;\\n            };\\n            next = Math.max(next, N[i] + i);\\n        };\\n        return ans;\\n    };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18177,
                "title": "concise-o-n-java-solution-with-explanation",
                "content": "For each step of jump, there is a range you can reach. \\nThen try jumping from each position in current range, you will get a new range where the next step can reach.\\nRepeat this process util the range covers the last index.\\n\\n    public class Solution {\\n        public int jump(int[] nums){\\n            int step = 0;\\n            for(int l = 0, r = 0; r < nums.length - 1; step++){\\n            \\tint rNew = 0;\\n            \\tfor(int i = l; i <= r; i++) rNew = Math.max(rNew, i + nums[i]);\\n            \\tl = r + 1;\\n            \\tr = rNew;\\n            }\\n            return step;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int jump(int[] nums){\\n            int step = 0;\\n            for(int l = 0, r = 0; r < nums.length - 1; step++){\\n            \\tint rNew = 0;\\n            \\tfor(int i = l; i <= r; i++) rNew = Math.max(rNew, i + nums[i]);\\n            \\tl = r + 1;\\n            \\tr = rNew;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3758457,
                "title": "java-0ms-100-easy-solution",
                "content": "The main idea is based on greedy. Let\\'s say the range of the current jump is [curBegin, curEnd], curFarthest is the farthest point that all points in [curBegin, curEnd] can reach. Once the current point reaches curEnd, then trigger another jump, and set the new curEnd with curFarthest, then keep the above steps, as the following:\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n      int jumps = 0, currEnd = 0, currFarthest = 0;\\n      for(int i = 0; i < nums.length - 1; i ++) {\\n          currFarthest = Math.max(currFarthest, i + nums[i]);\\n          if(i == currEnd) {\\n              currEnd = currFarthest;\\n              jumps ++;\\n          }\\n      }  \\n      return jumps;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n      int jumps = 0, currEnd = 0, currFarthest = 0;\\n      for(int i = 0; i < nums.length - 1; i ++) {\\n          currFarthest = Math.max(currFarthest, i + nums[i]);\\n          if(i == currEnd) {\\n              currEnd = currFarthest;\\n              jumps ++;\\n          }\\n      }  \\n      return jumps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204682,
                "title": "easy-c-greedy-faster-than-100",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int jumps = 0;\\n        int maxReach = 0;\\n        int currReach = 0;\\n        \\n        for(int i=0; i<n-1; i++)\\n        {\\n            maxReach = max(maxReach, i+nums[i]);\\n            \\n            if(i==currReach)\\n            {\\n                jumps++;\\n                currReach = maxReach;\\n            }\\n            \\n        }\\n        \\n        return jumps;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int jumps = 0;\\n        int maxReach = 0;\\n        int currReach = 0;\\n        \\n        for(int i=0; i<n-1; i++)\\n        {\\n            maxReach = max(maxReach, i+nums[i]);\\n            \\n            if(i==currReach)\\n            {\\n                jumps++;\\n                currReach = maxReach;\\n            }\\n            \\n        }\\n        \\n        return jumps;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1192404,
                "title": "jump-game-ii-easy-solutions-w-explanation-optimization-from-brute-force-to-dp-to-greedy-bfs",
                "content": "\\u274C ***Solution - I (Brute Force) [Rejected]***\\n\\nWe start at index 0 and are required to reach index `n - 1` (where `n = nums.size()`). We can\\'t always do the maximum jump at each index. This can be easily verified by looking at the example test cases.\\n\\nSo, at each position, we can use a jump size of anywhere in the range *`[1, nums[pos]]`*. The final answer will be the minimum jumps required. We can recursively solve this problem as -\\n\\n* If we reach index *`n-1`* return 0, signifying that we need 0 more jumps.\\n* Else recurse for each jump size possible from the current index and return the answer in which we require the minimum number of jumps\\n\\n\\n```\\nint jump(vector<int>& nums, int pos = 0) {\\n\\tif(pos >= size(nums) - 1) return 0;        \\n\\tint minJumps = 1001;  // initialising to max possible jumps + 1\\n\\tfor(int j = 1; j <= nums[pos]; j++)  // explore all possible jump sizes from current position\\n\\t\\tminJumps = min(minJumps, 1 + jump(nums, pos + j));        \\n\\treturn minJumps;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N!)`**. At each index `i` we have `N-i` choices and we recursively explore each of them till end. So we require `O(N*(N-1)*(N-2)...1) = O(N!)`. \\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n\\n\\u2714\\uFE0F ***Solution - II (Recursive Dynamic Programming - Memoization) [Accepted]***\\n\\nWe can see that for a given position, we are repeatedly calculating the same answer over and over again. The jumps required to reach for a given index on the path remains fixed and can be stored in *`dp`* array to avoid re-calculations.\\n\\nThe solution is similar as the brute force with just the change that we are storing the solutions for each *`pos`* and returning it if it is already calculated.\\n\\n```\\nint jump(vector<int>& nums) {\\n\\tvector<int> dp(size(nums), 1001); // initialise all to max possible jumps + 1 denoting dp[i] hasn\\'t been computed yet\\n\\treturn solve(nums, dp, 0);\\n}\\n// recursive solver to find min jumps to reach end\\nint solve(vector<int>& nums, vector<int>& dp, int pos) {\\n\\tif(pos >= size(nums) - 1) return 0;    // when we reach end, return 0 denoting no more jumps required\\n\\tif(dp[pos] != 1001) return dp[pos];    // number of jumps from pos to end is already calculated, so just return it\\n\\t// explore all possible jump sizes from current position. Store & return min jumps required\\n\\tfor(int j = 1; j <= nums[pos]; j++)\\n\\t\\tdp[pos] = min(dp[pos], 1 + solve(nums, dp, pos + j));        \\n\\treturn dp[pos];\\n}\\n```\\n\\n***Time Complexity :*** **`O(N^2)`**\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Iterative Dynamic Programming - Tabulation) [Accepted]***\\n\\nWe can solve this iteratively as well. For this, we start from the last index. We need 0 jumps from `nums[n-1]` to reach the end. We store this as *`dp[n - 1] = 0`* and then iteratively solve this for each previous index till the 0th index. Here *`dp[i]`* denotes minimum jumps required from current index to reach till the end.\\n\\n1. For each index, we explore all the possible jump sizes available with us. \\n2. The minimum jumps required to reach the end from the current index would be - **`min(dp[jumpLen])`**, where *`1 <= jumpLen <= nums[currentPostion]`*\\n\\n```\\nint jump(vector<int>& nums) {\\n\\tint n = size(nums);\\n\\tvector<int> dp(n, 1001);\\n\\tdp[n - 1] = 0;  // start from last index. No jumps required to reach end if we are already here\\n\\t// same as above. For each index, explore all jump sizes and use the one requiring minimum jumps to reach end\\n\\tfor(int i = n - 2; i >= 0; i--) \\n\\t\\tfor(int jumpLen = 1; jumpLen <= nums[i]; jumpLen++) \\n\\t\\t\\tdp[i] = min(dp[i], 1 + dp[min(n - 1, i + jumpLen)]);  // min(n-1, i + jumpLen) for bounds handling\\n\\treturn dp[0];\\n}\\n```\\n\\n***Time Complexity :*** **`O(N^2)`**\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution IV (BFS)***\\n\\nWe can iterate over all indices maintaining the furthest reachable position from current index - *`maxReachable`* and currently furthest reached position - *`lastJumpedPos`*. Everytime we will try to update *`lastJumpedPos`* to furthest possible reachable index - `maxReachable`.\\n\\nUpdating the `lastJumpedPos` separately from *`maxReachable`* allows us to maintain track of minimum *`jumps`* required. Each time `lastJumpedPos` is updated, ***`jumps`*** will also be updated and store the minimum jumps required to reach `lastJumpedPos` (On the contrary, updating `jumps` with `maxReachable` won\\'t give the optimal (minimum possible) value of jumps required). \\n\\nWe will just return it as soon as *`lastJumpedPos`* reaches(or exceeds) last index.\\n\\nWe can try to understand the steps in code below as analogous to those in BFS as -\\n\\n1. **`maxReachable = max(maxReachable, i + nums[i])`** : Updating the range of next level. Similar to  *`queue.push(node)`* step of BFS but here we are only greedily storing the max reachable index on next level.\\n\\n\\n2. **`i == lastJumpedPos`** :  When it becomes true, current level iteration has been completed.\\n3. **`lastJumpedPos = maxReachable`** : Set range till which we need to iterate the next level\\n4. **`jumps++`** : Move on to the next level.\\n\\n5. **`return jumps`** : The final answer will be number of levels in BFS traversal.\\n\\nFor eg. Take the example : `nums = [2,3,1,4,1,1,1,2]`. This approach proceeds as illustrated in image below -\\n\\n<p align=center>\\n<img src=https://assets.leetcode.com/users/images/4e5cbbb4-a6d0-4523-a945-261ee4b53f72_1620216977.5849538.png /></p>\\n\\n\\n```\\nint jump(vector<int>& nums) {\\n\\tint n = size(nums), i = 0, maxReachable = 0, lastJumpedPos = 0, jumps = 0;\\n\\twhile(lastJumpedPos < n - 1) {  // loop till last jump hasn\\'t taken us till the end\\n\\t\\tmaxReachable = max(maxReachable, i + nums[i]);  // furthest index reachable on the next level from current level\\n\\t\\tif(i == lastJumpedPos) {\\t\\t\\t  // current level has been iterated & maxReachable position on next level has been finalised\\n\\t\\t\\tlastJumpedPos = maxReachable;     // so just move to that maxReachable position\\n\\t\\t\\tjumps++;                          // and increment the level\\n\\t// NOTE: jump^ only gets updated after we iterate all possible jumps from previous level\\n\\t//       This ensures jumps will only store minimum jump required to reach lastJumpedPos\\n\\t\\t}            \\n\\t\\ti++;\\n\\t}\\n\\treturn jumps;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N)`**\\n***Space Complexity :*** **`O(1)`**\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint jump(vector<int>& nums, int pos = 0) {\\n\\tif(pos >= size(nums) - 1) return 0;        \\n\\tint minJumps = 1001;  // initialising to max possible jumps + 1\\n\\tfor(int j = 1; j <= nums[pos]; j++)  // explore all possible jump sizes from current position\\n\\t\\tminJumps = min(minJumps, 1 + jump(nums, pos + j));        \\n\\treturn minJumps;\\n}\\n```\n```\\nint jump(vector<int>& nums) {\\n\\tvector<int> dp(size(nums), 1001); // initialise all to max possible jumps + 1 denoting dp[i] hasn\\'t been computed yet\\n\\treturn solve(nums, dp, 0);\\n}\\n// recursive solver to find min jumps to reach end\\nint solve(vector<int>& nums, vector<int>& dp, int pos) {\\n\\tif(pos >= size(nums) - 1) return 0;    // when we reach end, return 0 denoting no more jumps required\\n\\tif(dp[pos] != 1001) return dp[pos];    // number of jumps from pos to end is already calculated, so just return it\\n\\t// explore all possible jump sizes from current position. Store & return min jumps required\\n\\tfor(int j = 1; j <= nums[pos]; j++)\\n\\t\\tdp[pos] = min(dp[pos], 1 + solve(nums, dp, pos + j));        \\n\\treturn dp[pos];\\n}\\n```\n```\\nint jump(vector<int>& nums) {\\n\\tint n = size(nums);\\n\\tvector<int> dp(n, 1001);\\n\\tdp[n - 1] = 0;  // start from last index. No jumps required to reach end if we are already here\\n\\t// same as above. For each index, explore all jump sizes and use the one requiring minimum jumps to reach end\\n\\tfor(int i = n - 2; i >= 0; i--) \\n\\t\\tfor(int jumpLen = 1; jumpLen <= nums[i]; jumpLen++) \\n\\t\\t\\tdp[i] = min(dp[i], 1 + dp[min(n - 1, i + jumpLen)]);  // min(n-1, i + jumpLen) for bounds handling\\n\\treturn dp[0];\\n}\\n```\n```\\nint jump(vector<int>& nums) {\\n\\tint n = size(nums), i = 0, maxReachable = 0, lastJumpedPos = 0, jumps = 0;\\n\\twhile(lastJumpedPos < n - 1) {  // loop till last jump hasn\\'t taken us till the end\\n\\t\\tmaxReachable = max(maxReachable, i + nums[i]);  // furthest index reachable on the next level from current level\\n\\t\\tif(i == lastJumpedPos) {\\t\\t\\t  // current level has been iterated & maxReachable position on next level has been finalised\\n\\t\\t\\tlastJumpedPos = maxReachable;     // so just move to that maxReachable position\\n\\t\\t\\tjumps++;                          // and increment the level\\n\\t// NOTE: jump^ only gets updated after we iterate all possible jumps from previous level\\n\\t//       This ensures jumps will only store minimum jump required to reach lastJumpedPos\\n\\t\\t}            \\n\\t\\ti++;\\n\\t}\\n\\treturn jumps;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1192521,
                "title": "python-greedy-o-n-solution-epxlained",
                "content": "There are two algorithms: one is dp with complexity `O(n^2)`, where `dp(i)` is the minimum number of steps to reach position `i` and on each step we need to check potentially `O(n)` jumps. \\n\\nHowever there is a solution with better complexity, using `greedy` idea: we need to look at `i + nums[i]` values and look at running maximum of these values. Then all we need to do is to start from the zero index and do `ind = t[ind]` until we reach the ending point or bigger. \\n\\nWe can look at our process like this: what is the biggest index we can reach after say `i` jumps. Then if we have new index to traverse we update our range. For example for `nums = [2, 3, 0, 1, 4]` we have `t = [2, 4, 4, 4, 8]` and after `1` jump we can reach index `2` and after each new index processed we expand our window if we have bigger value than the end of window and increase total number of steps or we do not do anything.\\n\\n#### Complexity\\nTime complexity is `O(n)`, space is `O(n)` as well, it can be made `O(1)`, if we calculate cumulative maximum on the fly.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def jump(self, nums):\\n        t = list(accumulate([i + num for i, num in enumerate(nums)], max))\\n        ind, q = 0, 0\\n        while ind < len(nums) - 1:\\n            ind = t[ind]\\n            q += 1\\n        return q\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```python\\nclass Solution:\\n    def jump(self, nums):\\n        t = list(accumulate([i + num for i, num in enumerate(nums)], max))\\n        ind, q = 0, 0\\n        while ind < len(nums) - 1:\\n            ind = t[ind]\\n            q += 1\\n        return q\\n```",
                "codeTag": "Java"
            },
            {
                "id": 443098,
                "title": "javascript-solution-w-explanation",
                "content": "### The idea\\n1. We know that every point is reachable, so we are only looking for the relationship between the maximum reach of each index and the number of jumps\\n2. `oldMax` is the previous jump\\'s maximum reach, if we are at the old max, that means no matter how we move, the next move will cost an extra jump, thus we increment  jump, at the same time, we update the `oldMax` to the current global max. This max, indicates the maximum reach we will have by having an extra jump.\\n``` javascript\\nvar jump = function(nums) {\\n    let newMax = 0;\\n    let jump = 0;\\n    let oldMax = 0;\\n    for (let i=0;i<nums.length-1;i++) {\\n        newMax = Math.max(newMax, i+nums[i]);\\n        if (i == oldMax) {\\n            jump++;\\n            oldMax = newMax;\\n        }\\n    }\\n    return jump;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar jump = function(nums) {\\n    let newMax = 0;\\n    let jump = 0;\\n    let oldMax = 0;\\n    for (let i=0;i<nums.length-1;i++) {\\n        newMax = Math.max(newMax, i+nums[i]);\\n        if (i == oldMax) {\\n            jump++;\\n            oldMax = newMax;\\n        }\\n    }\\n    return jump;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 18144,
                "title": "demonstrate-the-detailed-flow-process-of-my-thinking",
                "content": "    one example:\\n    index      0  1  2  3  4  5  6  7  8  9  10  11\\n    value      5  9  3  2  1  0  2  3  3  1  0   0\\n    farthest   5  10 10 10 10 10 10 10 11 11 11  11\\n        \\n        my thought -- scan from right to left.\\n        \\n            -- to reach index 11, we have to first reach (try best to jump forward)\\n                -- index 0, 0+5=5, no\\n                -- index 1, 1+9=10, no\\n                -- index 2, 2+3=5, no\\n                -- index 3, 3+2=5, no\\n                -- index 4, 4+1=5, no\\n                -- index 5, 5+0=5, no\\n                -- index 6, 6+2=8, no\\n                -- index 7, 7+3=10, no\\n                -- index 8, 8+3=11, yes!\\n                thus we have to first reach index 8.\\n            -- to reach index 8, we have to first reach (try best to jump forward)\\n                -- index 0, 0+5=5, no\\n                -- index 1, 1+9=10, yes\\n                thus we have to first reach index 1.\\n            -- to reach index 1, we have to first reach (try best to jump forward)\\n                -- index 0, 0+5=5, yes\\n                thus we have to first reach index 0.\\n            \\n            therefore, 3 steps in total.\\n            \\n        one issue i thought about.\\n            -- when scanning from left to right to search for the \"viable\" index, we take the first \"viable\" index.\\n               what if this first \"viable\" index is not reachable?\\n               \\n               for example:\\n               index  0  1  2  3  4  5  6  7  8  9  10  11\\n               value  1  6  5  4  3  2  1  3  3  1  1   0\\n               \\n               scanned from left to right, the first \"viable\" index is 8, the second \"viable\" index is 10.\\n               what if we cannot reach index 8 but we can reach index 10?\\n                    -- silly question, lol\\n               will it take more steps to choose index 8 than 10?\\n                    -- 8-->11 and 10-->11 both take 1 step\\n                    -- will it take more steps to reach index 8 than 10?\\n                        -- the answer is **NO**.\\n                           if reaching index 10 takes **n** steps, we can definitely reach index 8 in **<=n** steps.\\n               \\n               therefore we have no problem to choose the first \"viable\" index.\\n               such is the correctness of the algorithm.",
                "solutionTags": [],
                "code": "    one example:\\n    index      0  1  2  3  4  5  6  7  8  9  10  11\\n    value      5  9  3  2  1  0  2  3  3  1  0   0\\n    farthest   5  10 10 10 10 10 10 10 11 11 11  11\\n        \\n        my thought -- scan from right to left.\\n        \\n            -- to reach index 11, we have to first reach (try best to jump forward)\\n                -- index 0, 0+5=5, no\\n                -- index 1, 1+9=10, no\\n                -- index 2, 2+3=5, no\\n                -- index 3, 3+2=5, no\\n                -- index 4, 4+1=5, no\\n                -- index 5, 5+0=5, no\\n                -- index 6, 6+2=8, no\\n                -- index 7, 7+3=10, no\\n                -- index 8, 8+3=11, yes!\\n                thus we have to first reach index 8.\\n            -- to reach index 8, we have to first reach (try best to jump forward)\\n                -- index 0, 0+5=5, no\\n                -- index 1, 1+9=10, yes\\n                thus we have to first reach index 1.\\n            -- to reach index 1, we have to first reach (try best to jump forward)\\n                -- index 0, 0+5=5, yes\\n                thus we have to first reach index 0.\\n            \\n            therefore, 3 steps in total.\\n            \\n        one issue i thought about.\\n            -- when scanning from left to right to search for the \"viable\" index, we take the first \"viable\" index.\\n               what if this first \"viable\" index is not reachable?\\n               \\n               for example:\\n               index  0  1  2  3  4  5  6  7  8  9  10  11\\n               value  1  6  5  4  3  2  1  3  3  1  1   0\\n               \\n               scanned from left to right, the first \"viable\" index is 8, the second \"viable\" index is 10.\\n               what if we cannot reach index 8 but we can reach index 10?\\n                    -- silly question, lol\\n               will it take more steps to choose index 8 than 10?\\n                    -- 8-->11 and 10-->11 both take 1 step\\n                    -- will it take more steps to reach index 8 than 10?\\n                        -- the answer is **NO**.\\n                           if reaching index 10 takes **n** steps, we can definitely reach index 8 in **<=n** steps.\\n               \\n               therefore we have no problem to choose the first \"viable\" index.\\n               such is the correctness of the algorithm.",
                "codeTag": "Unknown"
            },
            {
                "id": 3158214,
                "title": "putta-easy-solution-c-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minjump(int i,vector<int>& nums,vector<int>& dp){\\n        if(i >= nums.size()-1){\\n            return 0;\\n        }\\n        if (dp[i] != -1 ) return dp[i];\\n        int mini= 1e9;\\n        for(int k=i+1;k<=i+nums[i];k++){\\n            mini = min(mini,1+minjump(k,nums,dp));\\n        }\\n        return dp[i]=mini;\\n    }\\n    int jump(vector<int>& nums) {\\n        vector<int> dp(nums.size()+1,-1);\\n        return minjump(0,nums,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minjump(int i,vector<int>& nums,vector<int>& dp){\\n        if(i >= nums.size()-1){\\n            return 0;\\n        }\\n        if (dp[i] != -1 ) return dp[i];\\n        int mini= 1e9;\\n        for(int k=i+1;k<=i+nums[i];k++){\\n            mini = min(mini,1+minjump(k,nums,dp));\\n        }\\n        return dp[i]=mini;\\n    }\\n    int jump(vector<int>& nums) {\\n        vector<int> dp(nums.size()+1,-1);\\n        return minjump(0,nums,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2208416,
                "title": "python-intuitive-bfs-solution-with-a-deque-explained",
                "content": "What is minimum number of jump in other words? Shortest path! What is shortest path? It is BFS!\\n```\\ndef jump(self, nums: List[int]) -> int:\\n        \\n        n = len(nums)\\n\\t\\t\\n\\t\\t# queue stores index and number jump to reach it\\n        q = deque([(0,0)])\\n\\t\\t\\n\\t\\t# created visited set to stored visited indices\\n\\t\\t# this set is needed to avoid duplicate work and to protect you from TLE :-)\\n\\t\\t# we initialize it with the first index because it will be inevitably visited.\\n        visited = set([0])\\n        \\n        while q:\\n            \\n\\t\\t\\t# don\\'t forget to use popleft instead of pop to get desired first in first out behavior\\n            cur, jumps = q.popleft()\\n            \\n\\t\\t\\t# if we\\'ve reached the last index we are done\\n\\t\\t\\t# And because BFS is shortest path we just return corresponding number of jumps\\n            if cur == n - 1:\\n                return jumps\\n            \\n\\t\\t\\t# jump for each possible index from current position according to available number of jumps\\n\\t\\t\\t# min(cur+nums[cur]+1,n) just cuts jumps which are out of bound of our array\\n            for i in range(cur + 1, min(cur+nums[cur]+1,n)):\\n\\t\\t\\t\\n\\t\\t\\t\\t# jump only if we haven\\'t visited this index already\\n                if i not in visited:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# if jump mark index as visited\\n                    visited.add(i)\\n                    q.append((i,jumps+1))\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\ndef jump(self, nums: List[int]) -> int:\\n        \\n        n = len(nums)\\n\\t\\t\\n\\t\\t# queue stores index and number jump to reach it\\n        q = deque([(0,0)])\\n\\t\\t\\n\\t\\t# created visited set to stored visited indices\\n\\t\\t# this set is needed to avoid duplicate work and to protect you from TLE :-)\\n\\t\\t# we initialize it with the first index because it will be inevitably visited.\\n        visited = set([0])\\n        \\n        while q:\\n            \\n\\t\\t\\t# don\\'t forget to use popleft instead of pop to get desired first in first out behavior\\n            cur, jumps = q.popleft()\\n            \\n\\t\\t\\t# if we\\'ve reached the last index we are done\\n\\t\\t\\t# And because BFS is shortest path we just return corresponding number of jumps\\n            if cur == n - 1:\\n                return jumps\\n            \\n\\t\\t\\t# jump for each possible index from current position according to available number of jumps\\n\\t\\t\\t# min(cur+nums[cur]+1,n) just cuts jumps which are out of bound of our array\\n            for i in range(cur + 1, min(cur+nums[cur]+1,n)):\\n\\t\\t\\t\\n\\t\\t\\t\\t# jump only if we haven\\'t visited this index already\\n                if i not in visited:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# if jump mark index as visited\\n                    visited.add(i)\\n                    q.append((i,jumps+1))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1701773,
                "title": "c-solution-using-dp-skipping-wrong-answer",
                "content": "\\n> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Using ***Recursive Dynamic Programming - Memoization.***\\n- **Remember while initializing the array with 10001, if we do 1001 then it will give the wrong answer for large values.**\\n- We take a dp array to store recursive solutions.\\n- Help array for the recursion, base case when start index is greater than size of the array.\\n- From 1 to the num position we\\u2019ll calculate the minimum value & update the dp array.\\n- Finally return the value dp[start].\\n- **Time complexity:** O(n^2).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        vector<int> dp(size(nums), 10001);\\n        return help(nums, dp, 0);\\n    }\\n    int help(vector<int>& nums,  vector<int>& dp, int start){\\n        if(start >= size(nums)-1) return 0;\\n        if(dp[start] != 10001) return dp[start];\\n        \\n        for(int i=1; i<=nums[start]; i++){\\n            dp[start] = min(dp[start], 1+help(nums, dp, start+i));\\n        }\\n        return dp[start];\\n    } \\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        vector<int> dp(size(nums), 10001);\\n        return help(nums, dp, 0);\\n    }\\n    int help(vector<int>& nums,  vector<int>& dp, int start){\\n        if(start >= size(nums)-1) return 0;\\n        if(dp[start] != 10001) return dp[start];\\n        \\n        for(int i=1; i<=nums[start]; i++){\\n            dp[start] = min(dp[start], 1+help(nums, dp, start+i));\\n        }\\n        return dp[start];\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1469752,
                "title": "python-3-recursion-memoization-self-understandable-easy-understading",
                "content": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        memo={}\\n        def min_jumps(index):\\n            if index>=len(nums)-1:\\n                return 0\\n            if index in memo:\\n                return memo[index]\\n            ans=float(\\'inf\\')\\n            for i in range(index,index+nums[index]):\\n                ans=min(ans,1+min_jumps(i+1))\\n            memo[index]=ans\\n            return ans\\n        return min_jumps(0)\\n                \\n                    \\n```\\n\\n***Do Upvote if you found my solution helpful :)***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        memo={}\\n        def min_jumps(index):\\n            if index>=len(nums)-1:\\n                return 0\\n            if index in memo:\\n                return memo[index]\\n            ans=float(\\'inf\\')\\n            for i in range(index,index+nums[index]):\\n                ans=min(ans,1+min_jumps(i+1))\\n            memo[index]=ans\\n            return ans\\n        return min_jumps(0)\\n                \\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1192566,
                "title": "c-solution-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int dp[10001];\\n    int solve(vector<int>& nums, int curridx, int lidx)\\n    {\\n        if(curridx == lidx) return 0;\\n        if(curridx > lidx || nums[curridx] == 0) return 1e6;\\n        \\n        if(dp[curridx] < 1e6) return dp[curridx];\\n        \\n        for(int i=1;i<=nums[curridx];++i)\\n        {\\n            dp[curridx] = min(dp[curridx], solve(nums,curridx+i,lidx));\\n        }\\n        \\n        dp[curridx]+=1;\\n        return dp[curridx];\\n    }\\n    \\n    int jump(vector<int>& nums) {\\n        memset(dp,1e6,sizeof(dp));\\n        int ans = solve(nums,0,nums.size()-1);\\n        if(ans == 1e6) return 0;\\n        else return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dp[10001];\\n    int solve(vector<int>& nums, int curridx, int lidx)\\n    {\\n        if(curridx == lidx) return 0;\\n        if(curridx > lidx || nums[curridx] == 0) return 1e6;\\n        \\n        if(dp[curridx] < 1e6) return dp[curridx];\\n        \\n        for(int i=1;i<=nums[curridx];++i)\\n        {\\n            dp[curridx] = min(dp[curridx], solve(nums,curridx+i,lidx));\\n        }\\n        \\n        dp[curridx]+=1;\\n        return dp[curridx];\\n    }\\n    \\n    int jump(vector<int>& nums) {\\n        memset(dp,1e6,sizeof(dp));\\n        int ans = solve(nums,0,nums.size()-1);\\n        if(ans == 1e6) return 0;\\n        else return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1017980,
                "title": "c-dp-based-solution-100-time-100-space",
                "content": "I thought everybody would solve this problem with a sheer DP approach, but it looks like I was wrong and greedy was the most popular one.\\n\\nWell, good for me: I got to practice a pattern and will learn even more reading other people\\'s approaches :)\\n\\nOur core idea here is to create an array of the same size as `nums` and progress so that each slot of it will represent the minimum amount of steps to reach that position.\\n\\nTo do so, we will create just 2 variables:\\n* `len` will store the length of our input;\\n* `steps` is the array we mentioned above.\\n\\nWe will initialised all cells of `steps` to `INT_MAX`, but the first one, set to `0` (since we start there and it takes no movement to reach it).\\n\\nThen we go for the main loop, going with `i` from `0` up to the last element of our input and we will:\\n* loop with `j` from the minimum value between `len - 1` (last element of the array) and `i + nums[i])` (last element you can reach with the current jump) up to `i` (excluded);\\n* check if the current value of `step[j]` is greater than what we can achieve jumping from the currently considered cell (`step[i] + 1`) and in case update `step[j]` to a smaller, more convenient value;\\n* otherwise, since we know that we cannot offer anything better to both `step[j]` and all the cells left on the left of `j`, we break out of the inner loop and move on with another value of `i`.\\n\\nOnce we are done, we can just return the last value of `steps` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        // support variables\\n        int len = nums.size(), steps[len];\\n        // presetting steps\\n        for (int i = 1; i < len; i++) {\\n            steps[i] = INT_MAX;\\n        }\\n        steps[0] = 0;\\n        // populating steps with the lowest possible values\\n        for (int i = 0; i < len; i++) {\\n            for (int lmt = i, j = min(len - 1, i + nums[i]); j > lmt; j--) {\\n                if (steps[j] > steps[i] + 1) steps[j] = steps[i] + 1;\\n                else break;\\n            }\\n        }\\n        return steps[len - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        // support variables\\n        int len = nums.size(), steps[len];\\n        // presetting steps\\n        for (int i = 1; i < len; i++) {\\n            steps[i] = INT_MAX;\\n        }\\n        steps[0] = 0;\\n        // populating steps with the lowest possible values\\n        for (int i = 0; i < len; i++) {\\n            for (int lmt = i, j = min(len - 1, i + nums[i]); j > lmt; j--) {\\n                if (steps[j] > steps[i] + 1) steps[j] = steps[i] + 1;\\n                else break;\\n            }\\n        }\\n        return steps[len - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18024,
                "title": "my-c-bfs-solution-o-n-time-o-1-space",
                "content": "This minimum path problem is a typical BFS problem. Each step, expand all the nodes at the same level (i.e. i in (curEnd, newEnd])\\n\\n\\n    class Solution {\\n    public:\\n        int jump(vector<int>& nums) {\\n            int steps =1, i, curEnd = 0, newEnd=0, len = nums.size();\\n            if(len<=1) return 0;\\n            for(i=0; i<=curEnd; ++i)\\n            {\\n                newEnd = max(newEnd, i+nums[i]);\\n                if(newEnd>=(len-1)) return steps;\\n                if(i==curEnd)  // end of the current level, move to the next level\\n                {\\n                    curEnd = newEnd;\\n                    ++steps;\\n                }\\n            }\\n            return INT_MAX; // curEnd = newEnd, can not reach the end\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int jump(vector<int>& nums) {\\n            int steps =1, i, curEnd = 0, newEnd=0, len = nums.size();\\n            if(len<=1) return 0;\\n            for(i=0; i<=curEnd; ++i)\\n            {\\n                newEnd = max(newEnd, i+nums[i]);\\n                if(newEnd>=(len-1)) return steps;\\n                if(i==curEnd)  // end of the current level, move to the next level\\n                {\\n                    curEnd = newEnd;\\n                    ++steps;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2027340,
                "title": "python-dynamic-programming-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if n == 1:\\n            return 0\\n        \\n        # dp[i] means the minimum number of jumps to reach index i\\n        # for each dp[i]\\uFF0Cwe need to find the earliest j that can reach i from j\\n        # dp[i] = dp[j] + 1\\n        \\n        dp = [0] * n\\n        j = 0\\n        for i in range(1, n):\\n            while j + nums[j] < i:\\n                j += 1\\n            dp[i] = dp[j] + 1\\n        \\n        return dp[-1]",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if n == 1:\\n            return 0\\n        \\n        # dp[i] means the minimum number of jumps to reach index i\\n        # for each dp[i]\\uFF0Cwe need to find the earliest j that can reach i from j\\n        # dp[i] = dp[j] + 1\\n        \\n        dp = [0] * n\\n        j = 0\\n        for i in range(1, n):\\n            while j + nums[j] < i:\\n                j += 1\\n            dp[i] = dp[j] + 1\\n        \\n        return dp[-1]",
                "codeTag": "Java"
            },
            {
                "id": 1621483,
                "title": "c-greedy-approach-o-n-w-explanation",
                "content": "**APPROACH :**\\nAt any index i in ```nums```, we can jump a maximum of ```nums[i]``` steps and we need to reach the last index in the minimum number of jumps. \\nThis approach can be solved using DP but that requires O(N^2) time and O(N) space. \\nSo, we\\'ll solve it using Greedy approach. \\n\\nLet\\'s consider the array :\\n```nums = [1, 3, 5, 8, 6, 2, 6, 7, 6, 8, 9]```\\n(The minumum number of jumps to reach the end of the array is 3 ```(0--->1--->4--->10)``` )\\n\\n* We maintain 3 variables ```max_reach```, ```curr_reach```, ```jumps```. \\n* The idea is to jump the maximum no. of steps we can from an index, and update the ```max_reach``` and ```curr_reach``` to the index we jump to, increment ```jumps``` each time we jump (ie. each time we reach the max. index that could be reached from the starting index.)\\n* For the intermediate indices, we check if we can go farther than that from the index we started with and if yes, we update ```max_reach``` (Greedy Approach).\\n* When we reach the end of a segment (segment is the range of indices we can jump to from a given index), we see if ```max_reach``` is greater than the ```curr_reach``` and update ```curr_reach``` and increment ```jumps```, because we\\'ve reached the end of a segment and will the take the next jump.\\n* We continue this until the last but one index and then return ```jumps``` as the minimum value.\\n ![image](https://assets.leetcode.com/users/images/e4c49f12-2a3e-4af6-aa0f-76a916875c52_1639141695.0349996.jpeg)\\n In the above example, the segments are : index - 1, index - 2 to 4, index - 4 to 10.\\n\\n**Time Complexity :** O(N)\\n\\n**Space Complexity :** O(1)\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int max_reach=0, curr_reach=0, jumps=0;\\n        \\n        for(int i=0;i<nums.size()-1;i++){\\n            max_reach = max(max_reach, nums[i]+i);\\n            if(i==curr_reach) curr_reach = max_reach, jumps++;   \\n        }\\n        return jumps;\\n    }\\n};\\n```\\n\\nPlease upvote if you like it!\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```nums```\n```nums[i]```\n```nums = [1, 3, 5, 8, 6, 2, 6, 7, 6, 8, 9]```\n```(0--->1--->4--->10)```\n```max_reach```\n```curr_reach```\n```jumps```\n```max_reach```\n```curr_reach```\n```jumps```\n```max_reach```\n```max_reach```\n```curr_reach```\n```curr_reach```\n```jumps```\n```jumps```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int max_reach=0, curr_reach=0, jumps=0;\\n        \\n        for(int i=0;i<nums.size()-1;i++){\\n            max_reach = max(max_reach, nums[i]+i);\\n            if(i==curr_reach) curr_reach = max_reach, jumps++;   \\n        }\\n        return jumps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158343,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord Study Group](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=O46mFXtuGJY&list=PLBu4Bche1aEU-8z7xl3-B9lfw_DJtT_xs&index=8) if you are interested.\\n\\n<iframe src=\"https://leetcode.com/playground/QhdE2L8F/shared\" frameBorder=\"0\" width=\"100%\" height=\"600\"></iframe>",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord Study Group](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=O46mFXtuGJY&list=PLBu4Bche1aEU-8z7xl3-B9lfw_DJtT_xs&index=8) if you are interested.\\n\\n<iframe src=\"https://leetcode.com/playground/QhdE2L8F/shared\" frameBorder=\"0\" width=\"100%\" height=\"600\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 1193170,
                "title": "c-0ms-dp-approach-explained-logic",
                "content": "Initialize dp vector with max value (10000, from constraints). This vector will keep track of minimum jumps needed to reach to that position.\\nTo reach to first index, needed jumps =0\\nGet the value at nums[i]\\nFor the next nums[i] index, the needed jumps would be minimum of jumps at ith index+1, or jumps stored at dp[i]\\n\\n```\\nint jump(vector<int>& nums) {\\n        int i, j, index;\\n        vector<int> dp(nums.size(), 10000);\\n        dp[0]=0;            // to reach 1st index, jumps needed=0\\n        for(i=0; i<nums.size(); i++)\\n        {\\n            index=i+1;          // if nums[i]=2 and i=5, index will start from 6 and go till 8th position\\n            while(index<i+nums[i]+1)\\n            {\\n                if(index >= nums.size())        \\n                    break;\\n                dp[index] = min(dp[index], dp[i]+1);\\n                index++;\\n            }\\n        }\\n        return dp[nums.size()-1];\\n    }\\n```\\nPlease UPVOTE if my approach helped you.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint jump(vector<int>& nums) {\\n        int i, j, index;\\n        vector<int> dp(nums.size(), 10000);\\n        dp[0]=0;            // to reach 1st index, jumps needed=0\\n        for(i=0; i<nums.size(); i++)\\n        {\\n            index=i+1;          // if nums[i]=2 and i=5, index will start from 6 and go till 8th position\\n            while(index<i+nums[i]+1)\\n            {\\n                if(index >= nums.size())        \\n                    break;\\n                dp[index] = min(dp[index], dp[i]+1);\\n                index++;\\n            }\\n        }\\n        return dp[nums.size()-1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3159250,
                "title": "c-greedy-bfs-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst of all don\\'t worry about greedy it is not compulsory that it should come to our mind at first .. So initially we can think of brute force i.e recursive + backtracking then we can optimize using dp. So this is normally how to aproach the problem . There is no need to worry about greedy ..\\n-  Now after doing dp if we want like how the greedy will work for this we can give it some time and try to take it as a shortest path problem like we do in graph by bfs. In the similar way we can check at some level what can be the maximum jump we can take and we also check in between the maximum jump so far till curr_max (if there is some more we can get) . \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Greedy:** So In greedy we can take two pointers  [max_so_far , curr_maxi]\\n- Then we check one by one upto our curr maximum what can be maximum jump i.e max_so_far and after checking upto our curr_maxi we will upafte our curr_maxi with max_so_far and also we will incraese counter by 1 becuse 1 jump is taken .\\n- This will run upto our max_so_far become >=n-1 i.e end point so after that we will return the answer (no. of jumps till now).\\n- There are two  ways of doing greedy like shown below : First one seems like more bfs type but both are actually implicit bfs ,idea is same incremnet the level and check in curr level the  max jump we can take  and when max > n-1 we will return the no .of levels  till now.\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**Dynamic Programming O(n^2)**\\n```\\nint solve(vector<int>&arr,int ind,vector<int>&dp){\\n        if(ind>=arr.size()-1)return 0;\\n        if(dp[ind]!=10001)return dp[ind];\\n        for(int i=1;i<=arr[ind];i++){\\n            dp[ind]=min(dp[ind],1+solve(arr,i+ind,dp));\\n        }\\n        return dp[ind];\\n    }\\n    int jump(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>dp(n+1,10001);\\n        return solve(arr,0,dp);\\n    }\\n```\\n**Greedy I**\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& arr) {\\n        int n=arr.size();\\n        if(n==1)return 0;\\n        int max_so_far=0,ans=0,maxi=0;\\n        int i=0;\\n        while(maxi-i+1>0){\\n           ans++;\\n            for(i;i<=maxi;i++){\\n                max_so_far=max(max_so_far,i+arr[i]);\\n                if(max_so_far>=n-1)return ans;\\n            }\\n            maxi=max_so_far;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n**Greedy II**\\n```\\nint jump(vector<int>& arr) {\\n        int n=arr.size(),sum=0,c=0;\\n        if(n==1)return 0;\\n        int currFar=0,currEnd=0;\\n        for(int i=0;i<n-1;i++){\\n            currFar=max(currFar,arr[i]+i);\\n            if(i==currEnd){\\n                c++;\\n                currEnd=currFar;\\n            }\\n        }\\n        \\n        return c;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nint solve(vector<int>&arr,int ind,vector<int>&dp){\\n        if(ind>=arr.size()-1)return 0;\\n        if(dp[ind]!=10001)return dp[ind];\\n        for(int i=1;i<=arr[ind];i++){\\n            dp[ind]=min(dp[ind],1+solve(arr,i+ind,dp));\\n        }\\n        return dp[ind];\\n    }\\n    int jump(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>dp(n+1,10001);\\n        return solve(arr,0,dp);\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& arr) {\\n        int n=arr.size();\\n        if(n==1)return 0;\\n        int max_so_far=0,ans=0,maxi=0;\\n        int i=0;\\n        while(maxi-i+1>0){\\n           ans++;\\n            for(i;i<=maxi;i++){\\n                max_so_far=max(max_so_far,i+arr[i]);\\n                if(max_so_far>=n-1)return ans;\\n            }\\n            maxi=max_so_far;\\n        }\\n        return 0;\\n    }\\n};\\n```\n```\\nint jump(vector<int>& arr) {\\n        int n=arr.size(),sum=0,c=0;\\n        if(n==1)return 0;\\n        int currFar=0,currEnd=0;\\n        for(int i=0;i<n-1;i++){\\n            currFar=max(currFar,arr[i]+i);\\n            if(i==currEnd){\\n                c++;\\n                currEnd=currFar;\\n            }\\n        }\\n        \\n        return c;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2697195,
                "title": "c-easy-fast-short-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> dp(n,INT_MAX);\\n        dp[0]=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int step = nums[i];\\n            for(int j=1;j<=step and i+j<n;j++)\\n            {\\n                dp[i+j]=min(dp[i+j], dp[i]+1);\\n            }\\n        }\\n        \\n        return dp[n-1];\\n    }\\n};\\n```\\n**UPVOTE**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> dp(n,INT_MAX);\\n        dp[0]=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int step = nums[i];\\n            for(int j=1;j<=step and i+j<n;j++)\\n            {\\n                dp[i+j]=min(dp[i+j], dp[i]+1);\\n            }\\n        }\\n        \\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909415,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func jump(_ nums: [Int]) -> Int {\\n\\t\\tguard nums.count > 1 else { return 0 }\\n\\t\\tvar maxIndex: [Int] = [1]\\n\\n\\t\\tfor i in 0..<nums.count {\\n\\t\\t\\tvar max = 0\\n\\n\\t\\t\\tfor j in 0..<maxIndex[i] {\\n\\t\\t\\t\\tif (j >= nums.count) { break }\\n\\t\\t\\t\\tlet index = j + nums[j] + 1\\n\\n\\t\\t\\t\\tmax = max > index ? max : index\\n\\t\\t\\t\\tif max >= nums.count { return i + 1 }\\n\\t\\t\\t}\\n\\n\\t\\t\\tmaxIndex.append(max)\\n\\t\\t}\\n        return 0\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func jump(_ nums: [Int]) -> Int {\\n\\t\\tguard nums.count > 1 else { return 0 }\\n\\t\\tvar maxIndex: [Int] = [1]\\n\\n\\t\\tfor i in 0..<nums.count {\\n\\t\\t\\tvar max = 0\\n\\n\\t\\t\\tfor j in 0..<maxIndex[i] {\\n\\t\\t\\t\\tif (j >= nums.count) { break }\\n\\t\\t\\t\\tlet index = j + nums[j] + 1\\n\\n\\t\\t\\t\\tmax = max > index ? max : index\\n\\t\\t\\t\\tif max >= nums.count { return i + 1 }\\n\\t\\t\\t}\\n\\n\\t\\t\\tmaxIndex.append(max)\\n\\t\\t}\\n        return 0\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160405,
                "title": "easy-java-solution-greedy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem can be solved using a greedy approach. We can keep track of the maximum reachable index in each iteration and jump to that index in the next iteration. The minimum number of jumps can be calculated by counting the number of iterations needed to reach the end of the array.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int n = nums.length; // length of the nums array\\n        int jumps = 0; // number of jumps needed to reach the end\\n        int curEnd = 0; // farthest index that can be reached with the current number of jumps\\n        int curFarthest = 0; // farthest index that can be reached from the current index\\n        \\n        // iterate over the nums array from 0 to n - 1\\n        for (int i = 0; i < n - 1; i++) {\\n            curFarthest = Math.max(curFarthest, i + nums[i]); // update curFarthest with the maximum distance that can be reached from this index\\n            \\n            // if i is equal to curEnd, we have reached the farthest possible index with the current number of jumps\\n            if (i == curEnd) {\\n                jumps++; // increment jumps by 1\\n                curEnd = curFarthest; // update curEnd with the new farthest index\\n            }\\n        }\\n        return jumps;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int n = nums.length; // length of the nums array\\n        int jumps = 0; // number of jumps needed to reach the end\\n        int curEnd = 0; // farthest index that can be reached with the current number of jumps\\n        int curFarthest = 0; // farthest index that can be reached from the current index\\n        \\n        // iterate over the nums array from 0 to n - 1\\n        for (int i = 0; i < n - 1; i++) {\\n            curFarthest = Math.max(curFarthest, i + nums[i]); // update curFarthest with the maximum distance that can be reached from this index\\n            \\n            // if i is equal to curEnd, we have reached the farthest possible index with the current number of jumps\\n            if (i == curEnd) {\\n                jumps++; // increment jumps by 1\\n                curEnd = curFarthest; // update curEnd with the new farthest index\\n            }\\n        }\\n        return jumps;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159282,
                "title": "4-best-approaches-recursion-memorization-tabulation-most-optimized-approach",
                "content": "# **Please Upvote if you like these approaches**\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRecursion\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRecursive Approach\\n\\n# Complexity\\n- **Time complexity:**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity: O(K^n)\\nWhere K = maxElementOf(nums)\\n\\n- **Space complexity:**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity: O(n)\\nO(n) for recursive call stack space\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int jump(int[] nums) {\\n        return recJump(nums, 0);\\n    }\\n\\n     public int recJump(int [] nums, int idx){\\n         if(idx == nums.length - 1)\\n             return 0;\\n\\n         int min = 99999;\\n         for(int i = idx+1; (i <= idx + nums[idx] && i < nums.length); i++){\\n             min = Math.min(min, recJump(nums, i)+1);\\n         }\\n         return min;\\n     }\\n\\n\\n```\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMemorization\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMemorization Approach\\n\\n# Complexity\\n- **Time complexity:**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity: O(K*n)\\nWhere K = maxElementOf(nums)\\n\\n- **Space complexity:**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity: O(n)\\n```\\n\\nclass Solution {\\n    \\n    public int jump(int[] nums) {\\n        int [] dp = new int[nums.length];\\n        Arrays.fill(dp, -1);\\n        return memoJump(nums, 0, dp);\\n    }\\n\\n     public int memoJump(int [] nums, int idx, int [] dp){\\n         if(idx == nums.length - 1)\\n             return dp[idx] = 0;\\n        \\n         if(dp[idx] != -1)\\n             return dp[idx];\\n\\n         int min = 99999;\\n         for(int i = idx+1; (i <= idx + nums[idx] && i < nums.length); i++){\\n             min = Math.min(min, memoJump(nums, i, dp)+1);\\n         }\\n         return dp[idx] = min;\\n     }\\n}\\n```\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTabulation\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTabulation Approach\\n\\n# Complexity\\n- **Time complexity:**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity: O(K*n)\\nWhere K = maxElementOf(nums)\\n\\n- **Space complexity:**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity: O(n)\\n```\\nclass Solution {\\n    \\n    public int jump(int[] nums) {\\n        int [] dp = new int[nums.length];\\n        Arrays.fill(dp, -1);\\n        return memoJump(nums, 0, dp);\\n    }\\n    public int tabJump(int [] nums, int idx, int [] dp){\\n        for(idx = nums.length - 1; idx>=0; idx--){\\n            if(idx == nums.length-1){\\n                dp[idx] = 0;\\n                continue;\\n            }\\n\\n            int min = 99999;\\n            for(int i = idx+1; (i <= idx + nums[idx] && i < nums.length); i++){\\n                min = Math.min(min, dp[i]+1);\\n            }\\n\\n            dp[idx] = min;\\n        }\\n        return dp[0];\\n    }\\n}\\n```\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTwo Pointers\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTwo Pointers Approach\\n\\n# Complexity\\n- **Time complexity:**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity: O(n)\\n\\n- **Space complexity:**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity: O(1)\\n```\\nclass Solution {\\n    \\n    public int jump(int[] nums){\\n        int end = 0, farthest = 0;\\n        int jump = 0;\\n\\n        for(int i = 0; i < nums.length-1; i++){\\n            farthest = Math.max(farthest, i + nums[i]);\\n            if(i == end){\\n                jump++;\\n                end = farthest;\\n            }\\n        }\\n        return jump;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int jump(int[] nums) {\\n        return recJump(nums, 0);\\n    }\\n\\n     public int recJump(int [] nums, int idx){\\n         if(idx == nums.length - 1)\\n             return 0;\\n\\n         int min = 99999;\\n         for(int i = idx+1; (i <= idx + nums[idx] && i < nums.length); i++){\\n             min = Math.min(min, recJump(nums, i)+1);\\n         }\\n         return min;\\n     }\\n\\n\\n```\n```\\n\\nclass Solution {\\n    \\n    public int jump(int[] nums) {\\n        int [] dp = new int[nums.length];\\n        Arrays.fill(dp, -1);\\n        return memoJump(nums, 0, dp);\\n    }\\n\\n     public int memoJump(int [] nums, int idx, int [] dp){\\n         if(idx == nums.length - 1)\\n             return dp[idx] = 0;\\n        \\n         if(dp[idx] != -1)\\n             return dp[idx];\\n\\n         int min = 99999;\\n         for(int i = idx+1; (i <= idx + nums[idx] && i < nums.length); i++){\\n             min = Math.min(min, memoJump(nums, i, dp)+1);\\n         }\\n         return dp[idx] = min;\\n     }\\n}\\n```\n```\\nclass Solution {\\n    \\n    public int jump(int[] nums) {\\n        int [] dp = new int[nums.length];\\n        Arrays.fill(dp, -1);\\n        return memoJump(nums, 0, dp);\\n    }\\n    public int tabJump(int [] nums, int idx, int [] dp){\\n        for(idx = nums.length - 1; idx>=0; idx--){\\n            if(idx == nums.length-1){\\n                dp[idx] = 0;\\n                continue;\\n            }\\n\\n            int min = 99999;\\n            for(int i = idx+1; (i <= idx + nums[idx] && i < nums.length); i++){\\n                min = Math.min(min, dp[i]+1);\\n            }\\n\\n            dp[idx] = min;\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158322,
                "title": "easy-memoised-solution-c",
                "content": "\\n# Code Approach 1\\n```\\nclass Solution {\\npublic:\\n    int f(vector<int> &nums,int idx,int n,vector<int> &dp){\\n        //base case\\n        if(idx >= n-1) return 0;\\n        \\n        if(dp[idx] != 10001) return dp[idx];\\n        \\n        int jumps=10001;\\n        for(int i=1; i <= nums[idx]; i++){\\n            jumps = min(jumps,1 + f(nums,idx + i,n,dp));\\n        }\\n        \\n        return dp[idx] = jumps;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        vector<int> dp(n,10001);\\n        return f(nums,0,n,dp);\\n    }\\n};\\n```\\n# Code Approach 2 [greedy]\\n```\\nclass Solution {\\npublic:\\n//app 2: greedy\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0,maxReachable=0,curLevelReach=0;\\n        int jumps=0;\\n\\n        while(i<n-1){\\n            maxReachable = max(maxReachable,i+nums[i]);\\n\\n            if(i == curLevelReach){\\n                curLevelReach = maxReachable;\\n                jumps++;\\n            }\\n            i++;\\n        }\\n\\n        return jumps;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(vector<int> &nums,int idx,int n,vector<int> &dp){\\n        //base case\\n        if(idx >= n-1) return 0;\\n        \\n        if(dp[idx] != 10001) return dp[idx];\\n        \\n        int jumps=10001;\\n        for(int i=1; i <= nums[idx]; i++){\\n            jumps = min(jumps,1 + f(nums,idx + i,n,dp));\\n        }\\n        \\n        return dp[idx] = jumps;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        vector<int> dp(n,10001);\\n        return f(nums,0,n,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n//app 2: greedy\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0,maxReachable=0,curLevelReach=0;\\n        int jumps=0;\\n\\n        while(i<n-1){\\n            maxReachable = max(maxReachable,i+nums[i]);\\n\\n            if(i == curLevelReach){\\n                curLevelReach = maxReachable;\\n                jumps++;\\n            }\\n            i++;\\n        }\\n\\n        return jumps;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2306691,
                "title": "all-methods-recursive-dp-memoization-dp-tabulation-greedy-dfs-c",
                "content": "**Recursive Method**\\nTime Complexity: O(2^n)\\nSpace Complexity: O(1)\\nAuxilary Space Complexity for Recursive Stack Space: O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    int getMinJump(int i, vector<int> &nums){\\n        if(i>=nums.size()-1) return 0;\\n        int minJump=nums.size();\\n        for(int index=i+1; index<=i+nums[i]; index++){\\n            minJump=min(minJump, 1+getMinJump(index, nums));\\n        }\\n        return minJump;\\n    }\\n    int jump(vector<int>& nums) {\\n        return getMinJump(0, nums);\\n    }\\n};\\n```\\n**DP- Memoization**\\nTime Complexity: O(n^2)\\nSpace Complexity: O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    int getMinJump(int i, vector<int> &nums, vector<int> &dp){\\n        if(i>=nums.size()-1) return 0;\\n        if(dp[i]!=-1) return dp[i];\\n        int minJump=nums.size();\\n        for(int index=i+1; index<=i+nums[i]; index++){\\n            minJump=min(minJump, 1+getMinJump(index, nums, dp));\\n        }\\n        return dp[i]=minJump;\\n    }\\n    int jump(vector<int>& nums) {\\n        vector<int> dp(nums.size(), -1);\\n        return getMinJump(0, nums, dp);\\n    }\\n};\\n```\\n**DP- Tabulation**\\nTime Complexity: O(n^2)\\nSpace Complexity: O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> dp(n, n);\\n        dp[0]=0;\\n        for(int i{}; i<n-1; i++){\\n            for(int j=i+1; j<=i+nums[i]&&j<n; j++){\\n                dp[j]=min(dp[j], 1+dp[i]);\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```\\n**Greedy Method**\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        int farthest=0, jumps=0, current=0;\\n        for(int i=0; i<n; ++i){\\n            if(i>current){\\n                current=farthest;\\n                jumps++;\\n            }\\n            farthest=max(farthest, i+nums[i]);\\n        }\\n        return jumps;\\n    }\\n};\\n```\\n\\n***If you like this post, Please Upvote this post***",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Greedy",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinJump(int i, vector<int> &nums){\\n        if(i>=nums.size()-1) return 0;\\n        int minJump=nums.size();\\n        for(int index=i+1; index<=i+nums[i]; index++){\\n            minJump=min(minJump, 1+getMinJump(index, nums));\\n        }\\n        return minJump;\\n    }\\n    int jump(vector<int>& nums) {\\n        return getMinJump(0, nums);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int getMinJump(int i, vector<int> &nums, vector<int> &dp){\\n        if(i>=nums.size()-1) return 0;\\n        if(dp[i]!=-1) return dp[i];\\n        int minJump=nums.size();\\n        for(int index=i+1; index<=i+nums[i]; index++){\\n            minJump=min(minJump, 1+getMinJump(index, nums, dp));\\n        }\\n        return dp[i]=minJump;\\n    }\\n    int jump(vector<int>& nums) {\\n        vector<int> dp(nums.size(), -1);\\n        return getMinJump(0, nums, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> dp(n, n);\\n        dp[0]=0;\\n        for(int i{}; i<n-1; i++){\\n            for(int j=i+1; j<=i+nums[i]&&j<n; j++){\\n                dp[j]=min(dp[j], 1+dp[i]);\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        int farthest=0, jumps=0, current=0;\\n        for(int i=0; i<n; ++i){\\n            if(i>current){\\n                current=farthest;\\n                jumps++;\\n            }\\n            farthest=max(farthest, i+nums[i]);\\n        }\\n        return jumps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677863,
                "title": "java-solution-4-approaches-from-recursive-to-top-down-to-botton-up-and-finally-greedy",
                "content": "In question it is mentioned that answer will always exists. \\nlast element of array does not matter also as even if its value is 0 we don\\'t need to hop further.\\n**Brute Force-**\\nstart from i=0 to n-2 and foreach element i check at how many position we can go and for each valid posiiton again check how many locations we can go. keep on returning min for each path. once we reach last index we have the desired answer.\\n\\n```\\npublic int bruteForce(int[] nums) {\\n\\t\\treturn bruteForceRec(nums, 0);\\n\\t}\\n\\n\\tprivate int bruteForceRec(int[] nums, int start) {\\n\\t\\tif (start >= nums.length - 1) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tint min = 10001;//max value can be 1000\\n\\t\\tfor (int i = start + 1; i <= nums[start] + start; i++) {\\n\\t\\t\\tmin = Math.min(min, 1 + bruteForceRec(nums, i));\\n\\t\\t}\\n\\t\\treturn min;\\n\\t}\\n```\\n\\n**Top Down -**\\nIn above approach we are visiting every branch and at most of the times same branch is re-calucated. to save that take output array and before calling method check if for that index output array already has some data. if yes return directly else call method.\\n\\n```\\n\\tpublic int topDownDp(int[] nums) {\\n\\t\\treturn topDownRec(nums, 0, new int[nums.length]);\\n\\t}\\n\\n\\tprivate int topDownRec(int[] nums, int start, int[] output) {\\n\\t\\tif (start >= nums.length - 1) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tif (output[start] != 0) {\\n\\t\\t\\treturn output[start];\\n\\t\\t}\\n\\t\\tint min = 10001; // max possible jump is 10^4\\n\\t\\tfor (int i = start + 1; i <= nums[start] + start; i++) {\\n\\t\\t\\tmin = Math.min(min, 1 + topDownRec(nums, i, output));\\n\\t\\t}\\n\\t\\toutput[start] = min;\\n\\t\\treturn min;\\n\\t}\\n\\n```\\n\\n**Bottom Up->**\\nwe can just reverse the outer loop and can make recursive solution to iterative.\\n```\\n\\tpublic int bottomUpDp(int[] nums) {\\n\\t\\tint n = nums.length;\\n\\t\\tint[] output = new int[n];\\n\\t\\tfor (int start = n - 2; start >= 0; start--) {\\n\\t\\t\\tint min = 10001;\\n\\t\\t\\tfor (int i = start + 1; i <= start + nums[start]; i++) {\\n\\t\\t\\t\\tmin = Math.min(min, 1 + (i>=n ? 0 : output[i]));\\n\\t\\t\\t}\\n\\t\\t\\toutput[start] = min;\\n\\t\\t}\\n\\t\\treturn output[0];\\n\\t}\\n```\\n\\n**Greedy Approach ->**\\nwe can make use of greedy idea + sliding window concept also and can reduce the complexity from o(n^2) to o(n)\\nfor that keep maintaing left and right pointers to hold the window size on which we can go from each step.\\njump will store total jump needed to reach from first window till last window.\\ninitially set l=r=jump=0\\nnow loop till right< n-1\\ncheck for item starting from left till right what is max value i.e.\\nmax=Math.max(max,i+nums[i]);\\nonce inner loop finsihes we have max hops that we can go. now, increment jump, and left and right boundary also.\\nonce outer loop finishes jump has the desired answer.\\n```\\npublic int greedy(int[] nums) {\\n\\t\\tint jump = 0;\\n\\t\\tint left = 0;\\n\\t\\tint right = 0;\\n\\t\\t//till we reach end of the array\\n\\t\\twhile (right < nums.length - 1) {\\n\\t\\t\\tint max = 0;\\n\\t\\t\\t//find max reach (in range of indexes left and right)\\n\\t\\t\\tfor (int i = left; i <= right; i++) {\\n\\t\\t\\t\\tmax = Math.max(nums[i] + i, max);\\n\\t\\t\\t}\\n\\t\\t\\t//update new boundaries\\n\\t\\t\\tleft = right + 1;\\n\\t\\t\\tright = max;\\n\\t\\t\\tjump++;\\n\\t\\t}\\n\\t\\treturn jump;\\n\\t}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\npublic int bruteForce(int[] nums) {\\n\\t\\treturn bruteForceRec(nums, 0);\\n\\t}\\n\\n\\tprivate int bruteForceRec(int[] nums, int start) {\\n\\t\\tif (start >= nums.length - 1) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tint min = 10001;//max value can be 1000\\n\\t\\tfor (int i = start + 1; i <= nums[start] + start; i++) {\\n\\t\\t\\tmin = Math.min(min, 1 + bruteForceRec(nums, i));\\n\\t\\t}\\n\\t\\treturn min;\\n\\t}\\n```\n```\\n\\tpublic int topDownDp(int[] nums) {\\n\\t\\treturn topDownRec(nums, 0, new int[nums.length]);\\n\\t}\\n\\n\\tprivate int topDownRec(int[] nums, int start, int[] output) {\\n\\t\\tif (start >= nums.length - 1) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tif (output[start] != 0) {\\n\\t\\t\\treturn output[start];\\n\\t\\t}\\n\\t\\tint min = 10001; // max possible jump is 10^4\\n\\t\\tfor (int i = start + 1; i <= nums[start] + start; i++) {\\n\\t\\t\\tmin = Math.min(min, 1 + topDownRec(nums, i, output));\\n\\t\\t}\\n\\t\\toutput[start] = min;\\n\\t\\treturn min;\\n\\t}\\n\\n```\n```\\n\\tpublic int bottomUpDp(int[] nums) {\\n\\t\\tint n = nums.length;\\n\\t\\tint[] output = new int[n];\\n\\t\\tfor (int start = n - 2; start >= 0; start--) {\\n\\t\\t\\tint min = 10001;\\n\\t\\t\\tfor (int i = start + 1; i <= start + nums[start]; i++) {\\n\\t\\t\\t\\tmin = Math.min(min, 1 + (i>=n ? 0 : output[i]));\\n\\t\\t\\t}\\n\\t\\t\\toutput[start] = min;\\n\\t\\t}\\n\\t\\treturn output[0];\\n\\t}\\n```\n```\\npublic int greedy(int[] nums) {\\n\\t\\tint jump = 0;\\n\\t\\tint left = 0;\\n\\t\\tint right = 0;\\n\\t\\t//till we reach end of the array\\n\\t\\twhile (right < nums.length - 1) {\\n\\t\\t\\tint max = 0;\\n\\t\\t\\t//find max reach (in range of indexes left and right)\\n\\t\\t\\tfor (int i = left; i <= right; i++) {\\n\\t\\t\\t\\tmax = Math.max(nums[i] + i, max);\\n\\t\\t\\t}\\n\\t\\t\\t//update new boundaries\\n\\t\\t\\tleft = right + 1;\\n\\t\\t\\tright = max;\\n\\t\\t\\tjump++;\\n\\t\\t}\\n\\t\\treturn jump;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1640734,
                "title": "0ms-o-n-solution-faster-than-100-users-less-memory-than-97-java-users-explained",
                "content": "\\n\\n```\\nclass Solution {\\n\\n    public int jump(int[] a) {\\n        int n = a.length;\\n\\n        // Check Base Conditions\\n        if (n == 0 || n == 1) {\\n            return 0;\\n        } else if (a[0] >= n - 1) {\\n            return 1;\\n        }\\n\\n        // Keeps count of number of jumps\\n        int count = 1;\\n\\n        // 2 pointers to loop through the array\\n        int current_pos = 0; // stores the current position\\n        int parsed_pos = -1; // stores the last index of the position that have been parsed\\n\\n        //stores the position of the max value one can jump to between the parsed position and the current position\\n        int jumpTo = current_pos + a[current_pos];\\n\\n        // while not reached destination/end\\n        while (jumpTo < n - 1) {\\n            int arr[] = nextJump(a, current_pos, parsed_pos);\\n            current_pos = arr[0];\\n            parsed_pos = arr[1];\\n            jumpTo = arr[2];\\n            count += 1;\\n        }\\n\\n        return count;\\n    }\\n\\n    //finds the best index to jump from, between parsed_pos and max index reachable from current_pos\\n    static int[] nextJump(int[] a, int current_pos, int parsed_pos) {\\n        // stores the best position to jump from, between parsed_pos and max index reachable from current_pos \\n        int new_pos = current_pos;\\n\\n        // iterate parsed_pos and max index reachable from current_pos and find the index that can jump the farthest and set that as new_pos\\n        for (int i = parsed_pos + 1; i <= current_pos + a[current_pos]; i++) {\\n            if (i + a[i] >= new_pos + a[new_pos]) {\\n                new_pos = i;\\n            }\\n        }\\n\\n        //contains the new position to jump to, last index parsed in this iteration(new parsed_pos), maximum index reachable from the new position \\n        int arr[] = { new_pos, current_pos + a[current_pos], new_pos + a[new_pos] };\\n        return arr;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int jump(int[] a) {\\n        int n = a.length;\\n\\n        // Check Base Conditions\\n        if (n == 0 || n == 1) {\\n            return 0;\\n        } else if (a[0] >= n - 1) {\\n            return 1;\\n        }\\n\\n        // Keeps count of number of jumps\\n        int count = 1;\\n\\n        // 2 pointers to loop through the array\\n        int current_pos = 0; // stores the current position\\n        int parsed_pos = -1; // stores the last index of the position that have been parsed\\n\\n        //stores the position of the max value one can jump to between the parsed position and the current position\\n        int jumpTo = current_pos + a[current_pos];\\n\\n        // while not reached destination/end\\n        while (jumpTo < n - 1) {\\n            int arr[] = nextJump(a, current_pos, parsed_pos);\\n            current_pos = arr[0];\\n            parsed_pos = arr[1];\\n            jumpTo = arr[2];\\n            count += 1;\\n        }\\n\\n        return count;\\n    }\\n\\n    //finds the best index to jump from, between parsed_pos and max index reachable from current_pos\\n    static int[] nextJump(int[] a, int current_pos, int parsed_pos) {\\n        // stores the best position to jump from, between parsed_pos and max index reachable from current_pos \\n        int new_pos = current_pos;\\n\\n        // iterate parsed_pos and max index reachable from current_pos and find the index that can jump the farthest and set that as new_pos\\n        for (int i = parsed_pos + 1; i <= current_pos + a[current_pos]; i++) {\\n            if (i + a[i] >= new_pos + a[new_pos]) {\\n                new_pos = i;\\n            }\\n        }\\n\\n        //contains the new position to jump to, last index parsed in this iteration(new parsed_pos), maximum index reachable from the new position \\n        int arr[] = { new_pos, current_pos + a[current_pos], new_pos + a[new_pos] };\\n        return arr;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1193341,
                "title": "o-n-golang-solution-beats-100",
                "content": "```\\nfunc jump(nums []int) int {\\n\\tcurJump, farthestJump, jumps := 0, 0, 0\\n\\tfor i := 0; i < len(nums)-1; i++ {\\n\\t    // push index of furthest jump during current iteration\\n\\t\\tif i+nums[i] > farthestJump {\\n\\t\\t\\tfarthestJump = i + nums[i]\\n\\t\\t}\\n\\n\\t\\t// if current iteration is ended - setup the next one\\n\\t\\tif i == curJump {\\n\\t\\t\\tjumps, curJump = jumps+1, farthestJump\\n\\n\\t\\t\\tif curJump >= len(nums)-1 {\\n\\t\\t\\t\\treturn jumps\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// it\\'s guaranteed to never hit it\\n\\treturn 0\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc jump(nums []int) int {\\n\\tcurJump, farthestJump, jumps := 0, 0, 0\\n\\tfor i := 0; i < len(nums)-1; i++ {\\n\\t    // push index of furthest jump during current iteration\\n\\t\\tif i+nums[i] > farthestJump {\\n\\t\\t\\tfarthestJump = i + nums[i]\\n\\t\\t}\\n\\n\\t\\t// if current iteration is ended - setup the next one\\n\\t\\tif i == curJump {\\n\\t\\t\\tjumps, curJump = jumps+1, farthestJump\\n\\n\\t\\t\\tif curJump >= len(nums)-1 {\\n\\t\\t\\t\\treturn jumps\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// it\\'s guaranteed to never hit it\\n\\treturn 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 18149,
                "title": "my-python-solution",
                "content": "    class Solution(object):\\n    def jump(self, nums):\\n        res = 0\\n        edge = 0\\n        maxEdge = 0\\n        for i in range(len(nums)):\\n            if i > edge:\\n                edge = maxEdge\\n                res += 1\\n            maxEdge = max(maxEdge,i+nums[i])\\n        return res",
                "solutionTags": [],
                "code": "    class Solution(object):\\n    def jump(self, nums):\\n        res = 0\\n        edge = 0\\n        maxEdge = 0\\n        for i in range(len(nums)):\\n            if i > edge:\\n                edge = maxEdge\\n                res += 1\\n            maxEdge = max(maxEdge,i+nums[i])\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 18201,
                "title": "17ms-ac-c-code-very-easy-to-understand",
                "content": "    int jump(int A[], int n) {\\n    \\t\\tint i = 0, j = 1, cnt = 0, mx;\\n    \\n    \\t\\tif (n == 1) return 0;\\n    \\n    \\t\\twhile (i < n - 1 && i + A[i] < n - 1) {\\n    \\t\\t\\tfor (mx = j; j <= i + A[i]; j++) { mx = (mx + A[mx] <= j + A[j]) ? j : mx; }\\n    \\t\\t\\ti = mx; cnt++;\\n    \\t\\t}\\n    \\t\\treturn ++cnt; /* One more step to last index. */\\n    \\t}\\n\\nAll we have to do is to iterate though all positions we can jump from where we standing, find the largest i + A[i] (greedy) and jump to that index. O(n) in time and constant space.",
                "solutionTags": [],
                "code": "    int jump(int A[], int n) {\\n    \\t\\tint i = 0, j = 1, cnt = 0, mx;\\n    \\n    \\t\\tif (n == 1) return 0;\\n    \\n    \\t\\twhile (i < n - 1 && i + A[i] < n - 1) {\\n    \\t\\t\\tfor (mx = j; j <= i + A[i]; j++) { mx = (mx + A[mx] <= j + A[j]) ? j : mx; }\\n    \\t\\t\\ti = mx; cnt++;\\n    \\t\\t}\\n    \\t\\treturn ++cnt; /* One more step to last index. */\\n    \\t}\\n\\nAll we have to do is to iterate though all positions we can jump from where we standing, find the largest i + A[i] (greedy) and jump to that index. O(n) in time and constant space.",
                "codeTag": "Unknown"
            },
            {
                "id": 1668826,
                "title": "dp-greedy-c-soln",
                "content": "**Greedy**\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n    int res = 0 , currmax = 0 , reach = 0;\\n        \\n        for(int index = 0 ; index < nums.size() - 1 ; index++)\\n        {\\n            if(index + nums[index] > currmax)\\n                currmax = index + nums[index];\\n            \\n            if(index == reach)\\n            {\\n                res++;\\n                reach = currmax;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n***DP***\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, INT_MAX-1);\\n        dp[n - 1] = 0;  \\n        for(int i = n - 2; i >= 0; i--) \\n            for(int j = 1; j <= nums[i]; j++) \\n                dp[i] = min(dp[i], 1 + dp[min(n - 1, i + j)]);  \\n        return dp[0];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n    int res = 0 , currmax = 0 , reach = 0;\\n        \\n        for(int index = 0 ; index < nums.size() - 1 ; index++)\\n        {\\n            if(index + nums[index] > currmax)\\n                currmax = index + nums[index];\\n            \\n            if(index == reach)\\n            {\\n                res++;\\n                reach = currmax;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, INT_MAX-1);\\n        dp[n - 1] = 0;  \\n        for(int i = n - 2; i >= 0; i--) \\n            for(int j = 1; j <= nums[i]; j++) \\n                dp[i] = min(dp[i], 1 + dp[min(n - 1, i + j)]);  \\n        return dp[0];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1439932,
                "title": "simple-python-o-n-greedy-solution",
                "content": "The idea is that we only jump when we absolutely have to, this way the total number of jumps will be minimized.\\n**next_jump_max**: the furtherest we can jump next time\\n**cur_jump_max**: the furtherest we reach from previous jump\\n```Python\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        cur_jump_max = next_jump_max = ret = 0\\n        for i in range(len(nums)-1):\\n            next_jump_max = max(next_jump_max, i+nums[i])\\n            if i == cur_jump_max:\\n                ret += 1\\n                cur_jump_max = next_jump_max\\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```Python\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        cur_jump_max = next_jump_max = ret = 0\\n        for i in range(len(nums)-1):\\n            next_jump_max = max(next_jump_max, i+nums[i])\\n            if i == cur_jump_max:\\n                ret += 1\\n                cur_jump_max = next_jump_max\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 915437,
                "title": "hurray",
                "content": "**Approach**: I solved the problem with greedy approach. For the last couple of days i was practicing and studying greedy aprroach heavily. This topic always bothered me. But after with enough study and practicing common greedy problems now i can detect which problems to tackle with greedy approach and device a way how to solve.\\n\\nMy approach for this particular problem is to get the indices from nums which **minimises the distance from the end.**\\n```\\n\\t\\t\\tint a = nums.length - (nums[i] + i);\\n            if(a<aMin){\\n                min = nums[i];\\n                pos = i;\\n                aMin = a;\\n            }\\n```\\nThis block of code achives this.\\n\\nOverall Code:\\n\\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        if (nums.length <= 1) return 0;\\n        int max = nums[0];\\n        int i = 0;\\n        int count = 1;\\n        while (i <= nums.length) {\\n            if (i + max >= nums.length - 1) return count;\\n            int[] res = helper(nums, i + 1, i + max);\\n            max = res[0];\\n            i = res[1];\\n            count++;\\n        }\\n        return 0;\\n    }\\n    \\n     private int[] helper(int[] nums, int start, int end) {\\n        int min = Integer.MAX_VALUE;\\n        int aMin = Integer.MAX_VALUE;\\n        int pos = -1;\\n        for (int i = end; i >=start ; i--) {\\n            int a = nums.length - (nums[i] + i);\\n            if(a<aMin){\\n                min = nums[i];\\n                pos = i;\\n                aMin = a;\\n            }\\n\\n        }\\n        return new int[]{min, pos};\\n    }\\n}\\n```\\n\\nTime taken is 2ms. I think the TC is **O(N)**. Cause in the worst case this program can process an elment max two times. I cant find a worse case that in an elemnt will be processed multiple times. Can anyone help me here if am right or wrong here?\\n\\nNevertheless thanks everyone to the discuss channel contributers which helps me a lot to progress. <3",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\n\\t\\t\\tint a = nums.length - (nums[i] + i);\\n            if(a<aMin){\\n                min = nums[i];\\n                pos = i;\\n                aMin = a;\\n            }\\n```\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        if (nums.length <= 1) return 0;\\n        int max = nums[0];\\n        int i = 0;\\n        int count = 1;\\n        while (i <= nums.length) {\\n            if (i + max >= nums.length - 1) return count;\\n            int[] res = helper(nums, i + 1, i + max);\\n            max = res[0];\\n            i = res[1];\\n            count++;\\n        }\\n        return 0;\\n    }\\n    \\n     private int[] helper(int[] nums, int start, int end) {\\n        int min = Integer.MAX_VALUE;\\n        int aMin = Integer.MAX_VALUE;\\n        int pos = -1;\\n        for (int i = end; i >=start ; i--) {\\n            int a = nums.length - (nums[i] + i);\\n            if(a<aMin){\\n                min = nums[i];\\n                pos = i;\\n                aMin = a;\\n            }\\n\\n        }\\n        return new int[]{min, pos};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158252,
                "title": "c-java-simple-solution-easy-to-understand-code-with-comments",
                "content": "# Intuition\\nAdvice: Frist ,You need to analyse the question to which data structure to apply for this solution,It will come automatically,when you solve more problems.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nMy first Approach was Dynammic programming,but solution beats 50%.\\nI moved to greedy method and Beats 95%.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//Greedy Approach\\npublic class Solution {\\n    public int Jump(int[] nums) {\\n        int length=nums.Length;\\n\\n        int highJump=0;\\n        int jump=0;\\n        int currPos=0;\\n        // corner case :only one positio don\\'t need jump\\n        if(length==1){\\n            return 0;\\n        }\\n        // base case : If start position given range,you won\\'t jump more So,return -1;\\n        if(nums[0]==0){\\n            return -1;\\n        }\\n        //Loop through steps \\n        for(int i=0;i<length;i++){\\n            highJump=Math.Max(highJump, i+nums[i]);\\n            // When the jump reaches the end return the total jumps\\n            if(highJump>=length-1){\\n                return jump+1;\\n            }\\n            if(i==currPos){\\n                currPos=highJump;\\n                jump++;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```UPVOTE THE POST (Upvote karo masth.. Karo bhaiye..)\\n    //Dynammic Programming\\n    int length=nums.Length;\\n    //It\\'s the way to assign value to all indexes\\n    int[] dp = Enumerable.Repeat(Int32.MaxValue,length).ToArray();\\n    dp[0] = 0;\\n    for(int i = 0; i <length; i++) {\\n        for(int j = 0; j <= nums[i] && i + j < length; j++) {\\n            dp[i+j] = Math.Min(dp[i+j], dp[i] + 1);                \\n        }\\n    }\\n    return dp[length - 1];\\n",
                "solutionTags": [
                    "Java",
                    "C#",
                    "Dynamic Programming",
                    "Greedy",
                    "Breadth-First Search"
                ],
                "code": "```\\n//Greedy Approach\\npublic class Solution {\\n    public int Jump(int[] nums) {\\n        int length=nums.Length;\\n\\n        int highJump=0;\\n        int jump=0;\\n        int currPos=0;\\n        // corner case :only one positio don\\'t need jump\\n        if(length==1){\\n            return 0;\\n        }\\n        // base case : If start position given range,you won\\'t jump more So,return -1;\\n        if(nums[0]==0){\\n            return -1;\\n        }\\n        //Loop through steps \\n        for(int i=0;i<length;i++){\\n            highJump=Math.Max(highJump, i+nums[i]);\\n            // When the jump reaches the end return the total jumps\\n            if(highJump>=length-1){\\n                return jump+1;\\n            }\\n            if(i==currPos){\\n                currPos=highJump;\\n                jump++;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327160,
                "title": "very-easy-100-fully-explained-c-java-javascript-c",
                "content": "# **C++ Solution:**\\n```\\n**// Using Optimal Greedy Approach...**\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        //Initialize left and right pointers to point to the start and end of a segment...\\n        //segment refers to the steps a particular index can move...\\n        //Initialize jumps variable to store the number of jumps made so far which will be the minimum...\\n        int left = 0, right = 0, jump = 0;\\n        // While right pointer is not at the end of the list...\\n        while(right < nums.size() - 1){\\n            int maxi = 0;\\n            //Loop through the segment and maximize the reach...\\n            for(int i = left; i < right + 1; i++)\\n                maxi = max(maxi, nums[i] + i);\\n            // Update the pointers...\\n            // left pointer to be at right + 1...\\n            left = right + 1;\\n            // right pointer to be at the maximum reach...\\n            right = maxi;\\n            jump += 1;\\n        }\\n        return jump;\\n    }\\n};\\n```\\n\\n# **Java Solution:**\\n```\\n**// Using Dynamic Programming Approach...**\\nclass Solution {\\n    public int jump(int[] nums) {\\n        //Create an auxiliary array to store minimum jumps needed to reach nums[i] from nums[0].\\n        int[] jump = new int[nums.length];\\n        jump[0] = 0;\\n        //Implement a nested loop to traverse the whole list.\\n        for (int i = 1; i < nums.length; i++) {\\n            jump[i] = Integer.MAX_VALUE;\\n            //traverse the segments and stores the minimum jumps to an index in the auxiliary array.\\n            for(int j = 0; j < i; j++){\\n                // Find the minimum number of jumps to reach nums[i] from the start\\n                // And add this value to the auxiliary array.\\n                if(i <= nums[j] + j && jump[j] != Integer.MAX_VALUE) {\\n                    jump[i] = Math.min(jump[i], jump[j] + 1);\\n                }\\n            }\\n        }\\n        return jump[nums.length - 1];   //Return the minimum number of jumps.\\n    }\\n}\\n```\\n\\n# **JavaScript Solution:**\\n```\\n**//Time Complexity : O(n),   Space Complexity: O(1)**\\nvar jump = function(nums) {\\n    var jump = 0;\\n    var prev = 0;\\n    var max = 0;\\n    for (var i = 0; i < nums.length - 1; i++) {\\n        // Keep track of the maximum jump\\n        max = Math.max(max, i + nums[i]);\\n        // When we get to the index where we had our previous maximum jump, we increase our jump...\\n        if (i === prev) {\\n            jump++;\\n            prev = max;\\n        }\\n    }\\n    return jump;\\n};\\n```\\n\\n# **C Language:**\\n```\\n// Another approach is here...\\nint jump(int* nums, int numsSize){\\n    int pos = 0;\\n    int n = 0;\\n    while(pos < numsSize-1) {\\n        int next_pos=-1;\\n        if(pos+nums[pos]<numsSize-1) {\\n            for(int i=1; i<=nums[pos]; i++) {\\n                if(next_pos == -1 || (pos+i<numsSize && nums[next_pos]+(next_pos-pos) <= nums[pos+i]+i))\\n                    next_pos = pos+i;\\n            }\\n        }else\\n            next_pos = pos+nums[pos];\\n            pos = next_pos;\\n            n++;\\n    }\\n    return n;\\n}\\n```\\n**I am working hard for you guys...\\nPlease upvote if you find any help with this code...**",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\n**// Using Optimal Greedy Approach...**\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        //Initialize left and right pointers to point to the start and end of a segment...\\n        //segment refers to the steps a particular index can move...\\n        //Initialize jumps variable to store the number of jumps made so far which will be the minimum...\\n        int left = 0, right = 0, jump = 0;\\n        // While right pointer is not at the end of the list...\\n        while(right < nums.size() - 1){\\n            int maxi = 0;\\n            //Loop through the segment and maximize the reach...\\n            for(int i = left; i < right + 1; i++)\\n                maxi = max(maxi, nums[i] + i);\\n            // Update the pointers...\\n            // left pointer to be at right + 1...\\n            left = right + 1;\\n            // right pointer to be at the maximum reach...\\n            right = maxi;\\n            jump += 1;\\n        }\\n        return jump;\\n    }\\n};\\n```\n```\\n**// Using Dynamic Programming Approach...**\\nclass Solution {\\n    public int jump(int[] nums) {\\n        //Create an auxiliary array to store minimum jumps needed to reach nums[i] from nums[0].\\n        int[] jump = new int[nums.length];\\n        jump[0] = 0;\\n        //Implement a nested loop to traverse the whole list.\\n        for (int i = 1; i < nums.length; i++) {\\n            jump[i] = Integer.MAX_VALUE;\\n            //traverse the segments and stores the minimum jumps to an index in the auxiliary array.\\n            for(int j = 0; j < i; j++){\\n                // Find the minimum number of jumps to reach nums[i] from the start\\n                // And add this value to the auxiliary array.\\n                if(i <= nums[j] + j && jump[j] != Integer.MAX_VALUE) {\\n                    jump[i] = Math.min(jump[i], jump[j] + 1);\\n                }\\n            }\\n        }\\n        return jump[nums.length - 1];   //Return the minimum number of jumps.\\n    }\\n}\\n```\n```\\n**//Time Complexity : O(n),   Space Complexity: O(1)**\\nvar jump = function(nums) {\\n    var jump = 0;\\n    var prev = 0;\\n    var max = 0;\\n    for (var i = 0; i < nums.length - 1; i++) {\\n        // Keep track of the maximum jump\\n        max = Math.max(max, i + nums[i]);\\n        // When we get to the index where we had our previous maximum jump, we increase our jump...\\n        if (i === prev) {\\n            jump++;\\n            prev = max;\\n        }\\n    }\\n    return jump;\\n};\\n```\n```\\n// Another approach is here...\\nint jump(int* nums, int numsSize){\\n    int pos = 0;\\n    int n = 0;\\n    while(pos < numsSize-1) {\\n        int next_pos=-1;\\n        if(pos+nums[pos]<numsSize-1) {\\n            for(int i=1; i<=nums[pos]; i++) {\\n                if(next_pos == -1 || (pos+i<numsSize && nums[next_pos]+(next_pos-pos) <= nums[pos+i]+i))\\n                    next_pos = pos+i;\\n            }\\n        }else\\n            next_pos = pos+nums[pos];\\n            pos = next_pos;\\n            n++;\\n    }\\n    return n;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732493,
                "title": "linear-and-easy-bfs-solution-in-c",
                "content": "```\\nint jump(vector<int>& nums) {\\n        \\n        int current=0,farthest=0,jumps=0;\\n        \\n        for(int i=0;i<nums.size()-1;i++) {\\n            \\n            farthest=max(farthest, nums[i]+i);\\n            if(i==current) {\\n                current=farthest; jumps++;\\n            }\\n        }\\n        return jumps;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Breadth-First Search"
                ],
                "code": "```\\nint jump(vector<int>& nums) {\\n        \\n        int current=0,farthest=0,jumps=0;\\n        \\n        for(int i=0;i<nums.size()-1;i++) {\\n            \\n            farthest=max(farthest, nums[i]+i);\\n            if(i==current) {\\n                current=farthest; jumps++;\\n            }\\n        }\\n        return jumps;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 527262,
                "title": "python-dp-ezpz-10-line-solution-91-20",
                "content": "```\\n    def jump(self, nums: List[int]) -> int:\\n        if len(nums) == 1: return 0\\n        dp = [0]*len(nums)\\n        frontier = 0\\n        for i, n in enumerate(nums):\\n            if i + n > frontier:\\n                dp[frontier + 1:i + n + 1] = [dp[i] + 1] * (i + n - frontier)\\n                frontier = i + n\\n                if i + n >= len(nums) - 1: break\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\n    def jump(self, nums: List[int]) -> int:\\n        if len(nums) == 1: return 0\\n        dp = [0]*len(nums)\\n        frontier = 0\\n        for i, n in enumerate(nums):\\n            if i + n > frontier:\\n                dp[frontier + 1:i + n + 1] = [dp[i] + 1] * (i + n - frontier)\\n                frontier = i + n\\n                if i + n >= len(nums) - 1: break\\n        return dp[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 18082,
                "title": "5-lines-o-n-python-with-explanation",
                "content": "Check comments in the code. \\n\\n    def jump2(self, A):\\n        \"\"\"\\n        Basically it's a shortest-path problem. \\n        As an unweighted graph, BFS should be able to solve it in O(|E|).\\n        But as it's an array with non-negative numbers, we can't jump backward. \\n        So we can do better here.\\n        Suppose we devided the arrays into segments depending on the elment \\n        in the array. So for each segment, we find the farthest index we can \\n        jump. For example, the first segment is always A[0]. The second will be\\n        from A[1] to A[A[0]]. The third will be from A[A[0]] to the farthest \\n        index we can find in the second segment. We start looking between \\n        the end of the last segment and the begin of the next segment.\\n        \"\"\"\\n        ans = lastIdx = nextIdx = 0\\n        while nextIdx < len(A) - 1:\\n            ans += 1\\n            lastIdx, nextIdx = nextIdx, max(i + A[i] for i in xrange(lastIdx, nextIdx + 1))\\n        return ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "Check comments in the code. \\n\\n    def jump2(self, A):\\n        \"\"\"\\n        Basically it's a shortest-path problem. \\n        As an unweighted graph, BFS should be able to solve it in O(|E|).\\n        But as it's an array with non-negative numbers, we can't jump backward. \\n        So we can do better here.\\n        Suppose we devided the arrays into segments depending on the elment \\n        in the array. So for each segment, we find the farthest index we can \\n        jump. For example, the first segment is always A[0]. The second will be\\n        from A[1] to A[A[0]]. The third will be from A[A[0]] to the farthest \\n        index we can find in the second segment. We start looking between \\n        the end of the last segment and the begin of the next segment.\\n        \"\"\"\\n        ans = lastIdx = nextIdx = 0\\n        while nextIdx < len(A) - 1:\\n            ans += 1\\n            lastIdx, nextIdx = nextIdx, max(i + A[i] for i in xrange(lastIdx, nextIdx + 1))\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 3158368,
                "title": "beginner-friendly-solution-easy-greedy-approach",
                "content": "# Intuition\\nGreddy Approach\\n\\n# Approach\\n- take three integer values jumps,curr_end and curr_Farthest  \\n- iterate through  loop to update curr_farthest and curr_end\\n- update curr_Farthest with max between curr_Farthest and i+nums[i]\\n- update curr_end when i is equal to curr_End and increase jumps\\n- return jumps\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code in C++\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n\\tint jumps = 0, curr_End = 0, curr_Farthest = 0;\\n\\tfor (int i = 0; i < nums.size() - 1; i++) {\\n\\t\\tcurr_Farthest = max(curr_Farthest, i + nums[i]);\\n\\t\\tif (i == curr_End) {\\n\\t\\t\\tjumps++;\\n\\t\\t\\tcurr_End = curr_Farthest;\\n\\t\\t}\\n\\t}\\n\\treturn jumps;\\n\\n    }\\n};\\n```\\n# Code in Python\\n```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        jumps=0\\n        curr_end=0\\n        curr_farthest=0\\n        n=len(nums)\\n        for i in range(n-1):\\n            curr_farthest=max(curr_farthest,i+nums[i])\\n            if(i==curr_end):\\n                jumps+=1\\n                curr_end=curr_farthest\\n        return jumps\\n```\\n\\n# DON\\'T FORGET TO UPVOTE !",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n\\tint jumps = 0, curr_End = 0, curr_Farthest = 0;\\n\\tfor (int i = 0; i < nums.size() - 1; i++) {\\n\\t\\tcurr_Farthest = max(curr_Farthest, i + nums[i]);\\n\\t\\tif (i == curr_End) {\\n\\t\\t\\tjumps++;\\n\\t\\t\\tcurr_End = curr_Farthest;\\n\\t\\t}\\n\\t}\\n\\treturn jumps;\\n\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        jumps=0\\n        curr_end=0\\n        curr_farthest=0\\n        n=len(nums)\\n        for i in range(n-1):\\n            curr_farthest=max(curr_farthest,i+nums[i])\\n            if(i==curr_end):\\n                jumps+=1\\n                curr_end=curr_farthest\\n        return jumps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1522839,
                "title": "o-n-single-pass-well-explained-ladder-steps-technique",
                "content": "Ladder Analogy\\n-\\n___\\nTake an iterator ``itr`` pointing to first element. We\\'ll move this over the array.\\n\\nFrom an element at position ``itr``, we can jump steps less than equal to ``nums[itr]``.\\nSo, we can move from ``itr`` to ``itr + nums[itr]`` (and stop anywhere in between)\\n\\nConsider this as a ladder connecting`` itr`` to ``itr + nums[itr]``, where we can stop at any step of this ladder.\\n\\nAlso, for every ``itr``, we have a seperate ladder going till ``itr + nums[itr]``.\\nFollowing figure shows all ladders connecting the elements in ``[3, 2, 2, 1, 4, 5]``\\n\\n![image](https://assets.leetcode.com/users/images/5b8ca20f-4d49-4eb4-bfcb-61de1a02345c_1634322078.0108702.png)\\n\\nSo, as ``itr`` moves from start to end, we can say that we are moving along a ladder or jumping from one ladder to another and moving along it.\\n\\nEach ladder change is analogous to a jump, so we need to reach the end with minimum ladder changes.\\nFollowing figure shows a path (in green) with minimum ladder changes.\\n\\n![image](https://assets.leetcode.com/users/images/28840ca0-3d48-4837-b7aa-72b11cf01020_1634322104.7879624.png)\\n\\nApproach\\n-\\n___\\n\\nMove along a ladder till we reach its end.\\n\\nWhile moving ahead find the ladder that has the farthest end and save it.\\n\\nWhen the current ladder ends, jump to the ladder that takes you the farthest.\\n\\nRepeat the same till we reach the end of ``nums``.\\n\\nCode\\n-\\n___\\n\\n``steps``: Number of steps in current ladder\\n\\n``ladder``:  Ending index of the ladder that takes us to the farthest point\\n\\n``jumps``: Number of ladder switches done till now\\n\\n``itr``: Iterator that moves across the array\\n\\n```\\ndef jump(self, nums: List[int]) -> int:\\n\\n\\t# Boundary case\\n\\tn = len(nums)\\n\\tif n == 1:\\n\\t\\treturn 0\\n\\n\\t# Initialize variables\\n\\tjumps = 1\\n\\tladder = nums[0]\\n\\tsteps = ladder\\n\\titr = 0\\n\\n\\t# Move over the current ladder\\n\\twhile steps >= 0:\\n\\n\\t\\t# Terminal condition - reached end of nums\\n\\t\\tif itr == n - 1:\\n\\t\\t\\treturn jumps\\n\\n\\t\\t# Update ladder endpoint if a longer one is found\\n\\t\\tladder = max( itr + nums[itr], ladder )\\n\\n\\t\\t# Current ladder has ended\\n\\t\\tif steps == 0:\\n\\t\\t\\tsteps = ladder - itr     # move to new ladder\\n\\t\\t\\tjumps += 1               # and update jumps\\n\\t\\t\\n\\t\\t# Continue moving ahead\\n\\t\\telse:\\n\\t\\t\\tsteps -= 1\\n\\t\\t\\titr += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\ndef jump(self, nums: List[int]) -> int:\\n\\n\\t# Boundary case\\n\\tn = len(nums)\\n\\tif n == 1:\\n\\t\\treturn 0\\n\\n\\t# Initialize variables\\n\\tjumps = 1\\n\\tladder = nums[0]\\n\\tsteps = ladder\\n\\titr = 0\\n\\n\\t# Move over the current ladder\\n\\twhile steps >= 0:\\n\\n\\t\\t# Terminal condition - reached end of nums\\n\\t\\tif itr == n - 1:\\n\\t\\t\\treturn jumps\\n\\n\\t\\t# Update ladder endpoint if a longer one is found\\n\\t\\tladder = max( itr + nums[itr], ladder )\\n\\n\\t\\t# Current ladder has ended\\n\\t\\tif steps == 0:\\n\\t\\t\\tsteps = ladder - itr     # move to new ladder\\n\\t\\t\\tjumps += 1               # and update jumps\\n\\t\\t\\n\\t\\t# Continue moving ahead\\n\\t\\telse:\\n\\t\\t\\tsteps -= 1\\n\\t\\t\\titr += 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 672805,
                "title": "easy-to-understand-faster-simple-python-solution",
                "content": "```\\n    def jump(self, nums: List[int]) -> int:\\n        dp = []\\n        curr = 0\\n        prev = -1\\n        while curr < len(nums) - 1:\\n            max_reach = self.get_max_reach(nums[prev+1:curr+1])\\n            dp.append(max_reach)\\n            prev = curr\\n            curr += dp[-1]\\n            if curr == prev: return 0\\n        return len(dp)\\n    \\n    def get_max_reach(self, arr):\\n        out = 0\\n        for i,v in enumerate(arr):\\n            out = max(out, (i+1+v) - len(arr))\\n        return out\\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\n    def jump(self, nums: List[int]) -> int:\\n        dp = []\\n        curr = 0\\n        prev = -1\\n        while curr < len(nums) - 1:\\n            max_reach = self.get_max_reach(nums[prev+1:curr+1])\\n            dp.append(max_reach)\\n            prev = curr\\n            curr += dp[-1]\\n            if curr == prev: return 0\\n        return len(dp)\\n    \\n    def get_max_reach(self, arr):\\n        out = 0\\n        for i,v in enumerate(arr):\\n            out = max(out, (i+1+v) - len(arr))\\n        return out\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 459329,
                "title": "c-concise-solution-beats-97",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint jump(vector<int>& nums) {\\n\\t\\t\\tint far=0;\\n\\t\\t\\tint res=0;\\n\\t\\t\\tint MAX=0;\\n\\t\\t\\tfor(int i=0;i<nums.size()-1;i++){\\n\\t\\t\\t\\tMAX=max(MAX,i+nums[i]);\\n\\t\\t\\t\\tif(far<=i){\\n\\t\\t\\t\\t\\tres++;\\n\\t\\t\\t\\t\\tfar=MAX;\\n\\t\\t\\t\\t\\tMAX=0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint jump(vector<int>& nums) {\\n\\t\\t\\tint far=0;\\n\\t\\t\\tint res=0;\\n\\t\\t\\tint MAX=0;\\n\\t\\t\\tfor(int i=0;i<nums.size()-1;i++){\\n\\t\\t\\t\\tMAX=max(MAX,i+nums[i]);\\n\\t\\t\\t\\tif(far<=i){\\n\\t\\t\\t\\t\\tres++;\\n\\t\\t\\t\\t\\tfar=MAX;\\n\\t\\t\\t\\t\\tMAX=0;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 18107,
                "title": "the-most-intuitive-solution-yet-still-accepted-as-best-in-c-well-explained",
                "content": "Using greedy method is quite strai\\nght-forward here, we need to finish this jumping as soon as possible but the question is what should be the factor for us to be greedy for:  <font color=\"#ff0000\">**the farthest jump**</font> \\n\\nOnce we are in a position **i** the farthest position we can reach is **i+nums[i]** and within this range we should find the most potential index **j** which will give us the biggest **j+nums[j]** and then we move to the most potential position **j** and then on and on till we move to the last or over it.\\n\\n    int next = 0, maxDes = 0;\\n    for(int j = i+1; j <= i+nums[i]; ++j)\\n    {\\n        if(nums[j]+j > maxDes) \\n        next = j, maxDes = nums[j]+j;   \\n    }\\n\\nQuite direct and simple though some details should be cared about. \\n\\n\\n----------\\n\\n\\n    class Solution {\\n    public:\\n        //AC - 16ms - greedy method selecting the proper factor to be greedy for;\\n        int jump(vector<int>& nums) \\n        {\\n            int i = 0, jumps = 0, size = nums.size();\\n            if(size == 1) return 0;\\n            while(i < size)\\n            {\\n                if(i+nums[i] > size-2) return ++jumps; //the last jump to or over the last;\\n                int next = 0, maxDes = 0;\\n                for(int j = i+1; j <= i+nums[i]; ++j) //searching for the most potential position;\\n                {\\n                    if(nums[j]+j > maxDes) \\n                        next = j, maxDes = nums[j]+j;\\n                }\\n                i = next; //jump to the most potential position;\\n                jumps++; //count the jump;\\n            }\\n            return 0; //for compilation matter, actually this statement will never be invoked;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        //AC - 16ms - greedy method selecting the proper factor to be greedy for;\\n        int jump(vector<int>& nums) \\n        {\\n            int i = 0, jumps = 0, size = nums.size();\\n            if(size == 1) return 0;\\n            while(i < size)\\n            {\\n                if(i+nums[i] > size-2) return ++jumps; //the last jump to or over the last;\\n                int next = 0, maxDes = 0;\\n                for(int j = i+1; j <= i+nums[i]; ++j) //searching for the most potential position;\\n                {\\n                    if(nums[j]+j > maxDes) \\n                        next = j, maxDes = nums[j]+j;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 18131,
                "title": "easy-understand-o-n-time-o-1-space-code",
                "content": "The main idea is using 2 integer to record the longest distance of current jump can arrive.\\nIf n jump cannot arrive at index i, it must jump one more time. Which means, the least jump time to get index i is (n+1).    \\n\\n\\n     int jump(vector<int>& nums) {\\n        if (n <= 1)\\n            return 0;\\n        int i, n = nums.size(), lc, ln, step = 1;\\n        // lc means the longest distance can achieve by current jump\\n        // ln means the longest distance can achieve by next jump\\n\\n        lc = nums[0], ln = nums[0]; //Initialize to index 0, the start point.\\n        for (i = 1; i < n; ++i)\\n        {\\n            if (i > lc) //current jump cannot get index i -->>> must jump one more time.\\n            {\\n                lc = ln;\\n                step++;\\n            }\\n            if (i + nums[i] > ln) //maintain the furthest distance of next jump can get\\n                ln = i + nums[i];\\n            if (lc >= n - 1) //current jump can achieve the last index\\n                return step;\\n        }\\n    }",
                "solutionTags": [],
                "code": "The main idea is using 2 integer to record the longest distance of current jump can arrive.\\nIf n jump cannot arrive at index i, it must jump one more time. Which means, the least jump time to get index i is (n+1).    \\n\\n\\n     int jump(vector<int>& nums) {\\n        if (n <= 1)\\n            return 0;\\n        int i, n = nums.size(), lc, ln, step = 1;\\n        // lc means the longest distance can achieve by current jump\\n        // ln means the longest distance can achieve by next jump\\n\\n        lc = nums[0], ln = nums[0]; //Initialize to index 0, the start point.\\n        for (i = 1; i < n; ++i)\\n        {\\n            if (i > lc) //current jump cannot get index i -->>> must jump one more time.\\n            {\\n                lc = ln;\\n                step++;\\n            }\\n            if (i + nums[i] > ln) //maintain the furthest distance of next jump can get\\n                ln = i + nums[i];\\n            if (lc >= n - 1) //current jump can achieve the last index\\n                return step;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 18156,
                "title": "python-o-n-solution",
                "content": "    class Solution:\\n        # @param {integer[]} nums\\n        # @return {integer}\\n        def jump(self, nums):\\n            n, cur_max, next_max, steps = len(nums), 0, 0, 0\\n            for i in xrange(n):\\n                if i > cur_max:\\n                    steps += 1\\n                    cur_max = next_max\\n                    if cur_max >= n: break\\n                next_max = max(next_max, nums[i] + i)\\n            return steps",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 3314558,
                "title": "start-and-end-approach-simple-to-understand",
                "content": "\\n\\n# 1.Start and End Approach\\n```\\nclass Solution:\\n    def jump(self,nums:List[int])->int:\\n        start,end,count=0,0,0\\n        for i in range(len(nums)-1):\\n            start=max(start,i+nums[i])\\n            if end==i:\\n                end=start\\n                count+=1\\n        return count\\n    #please upvote me it would encourage me alot\\n       \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def jump(self,nums:List[int])->int:\\n        start,end,count=0,0,0\\n        for i in range(len(nums)-1):\\n            start=max(start,i+nums[i])\\n            if end==i:\\n                end=start\\n                count+=1\\n        return count\\n    #please upvote me it would encourage me alot\\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158892,
                "title": "day-39-c-greedy-easiest-beginner-friendly-sol-o-n-time-and-o-1-space",
                "content": "# Intuition of this Problem:\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem:\\n1. Create two variables, jumps and maxReach, to keep track of the minimum number of jumps and the maximum reach from the current position.\\n2. Loop through the array.\\n3. For each index i, update maxReach to be the maximum between maxReach and i + nums[i].\\n4. If the current position i is equal to the current reach curReach, increment the number of jumps and update curReach to be the value of maxReach.\\n5. If curReach is greater than or equal to the last index of the array, return jumps.\\n6. If i is greater than or equal to maxReach, return 0 as it means it cannot reach the end.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Humble Request:\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Code:\\n```C++ []\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        int jumps = 0;\\n        int maxReach = 0; \\n        int curReach = 0;\\n        for (int i = 0; i < n - 1; i++) {\\n            maxReach = max(maxReach, i + nums[i]);\\n            if (i == curReach) {\\n                jumps++;\\n                curReach = maxReach;\\n                if (curReach >= n-1)\\n                    return jumps;\\n                //I added below two statements to cover if it will not reach to end of the array then return 0...but Actualy this case is out of scope but it is helpful for followups problem. If you want you can remove for this this problem\\n                // ex - [1,2,1,0,0]\\n                if (i >= maxReach) \\n                    return 0; // Cannot reach the end\\n            }\\n        }\\n        return jumps;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\npublic \\n    int jump(int[] nums) {\\n        int n = nums.length;\\n        int jumps = 0;\\n        int maxReach = 0;\\n        int curReach = 0;\\n        for (int i = 0; i < n - 1; i++) {\\n            maxReach = Math.max(maxReach, i + nums[i]);\\n            if (i == curReach) {\\n                jumps++;\\n                curReach = maxReach;\\n                if (curReach >= n-1)\\n                    return jumps;\\n                if (i >= maxReach)\\n                    return 0;\\n            }\\n        }\\n        return jumps;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        jumps = 0\\n        maxReach = 0\\n        curReach = 0\\n        for i in range(n - 1):\\n            maxReach = max(maxReach, i + nums[i])\\n            if i == curReach:\\n                jumps += 1\\n                curReach = maxReach\\n            if curReach >= n - 1:\\n                return jumps\\n            if i >= maxReach:\\n                return 0\\n        return jumps\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Greedy"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        int jumps = 0;\\n        int maxReach = 0; \\n        int curReach = 0;\\n        for (int i = 0; i < n - 1; i++) {\\n            maxReach = max(maxReach, i + nums[i]);\\n            if (i == curReach) {\\n                jumps++;\\n                curReach = maxReach;\\n                if (curReach >= n-1)\\n                    return jumps;\\n                //I added below two statements to cover if it will not reach to end of the array then return 0...but Actualy this case is out of scope but it is helpful for followups problem. If you want you can remove for this this problem\\n                // ex - [1,2,1,0,0]\\n                if (i >= maxReach) \\n                    return 0; // Cannot reach the end\\n            }\\n        }\\n        return jumps;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\npublic \\n    int jump(int[] nums) {\\n        int n = nums.length;\\n        int jumps = 0;\\n        int maxReach = 0;\\n        int curReach = 0;\\n        for (int i = 0; i < n - 1; i++) {\\n            maxReach = Math.max(maxReach, i + nums[i]);\\n            if (i == curReach) {\\n                jumps++;\\n                curReach = maxReach;\\n                if (curReach >= n-1)\\n                    return jumps;\\n                if (i >= maxReach)\\n                    return 0;\\n            }\\n        }\\n        return jumps;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        jumps = 0\\n        maxReach = 0\\n        curReach = 0\\n        for i in range(n - 1):\\n            maxReach = max(maxReach, i + nums[i])\\n            if i == curReach:\\n                jumps += 1\\n                curReach = maxReach\\n            if curReach >= n - 1:\\n                return jumps\\n            if i >= maxReach:\\n                return 0\\n        return jumps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115905,
                "title": "how-to-build-up-to-the-optimal-solution-backtracking-dp-greedy-detailed-explanation",
                "content": "# Approach\\nGenerally, for problems consisting of subproblems, we can use the following approach find the optimal algorithm:\\n1. Write the most intuitive recursive backtracking algorithm\\n2. Memoize repeated work using top-down dynamic programming\\n3. Eliminate recursion by using bottom-up dynamic programming\\n4. Apply final tricks\\n\\nIn the end, this problem can be solved with a simple but hard-to-find greedy algorithm.\\n\\nLet\\'s walk through each step.\\n\\n\\n# Recursive Backtracking\\nAlright, so how to approach this problem? The most intuitive way is to, at each index, check every index you can go to. Then, consider every index you can go to from there. At the end, the candidate with the least indices is our answer. We can make an optimization by discarding any candidates of length greater than what we\\'ve already found to be the best, but this algorithm is still exponential.\\n```\\n# Backtracking\\n# O(2^n) - Times out\\ndef jump0(self, nums: List[int]) -> int:\\n    self.best = math.inf\\n    def backtrack(candidate, end):\\n        if candidate >= self.best:\\n            return\\n        if end <= 0:\\n            self.best = candidate\\n        for i in range(end)[::-1]:\\n            if nums[i] + i >= end:\\n                backtrack(candidate + 1, i)\\n\\n    backtrack(0, len(nums)-1)\\n    return self.best\\n```\\n\\n# Top-Down Dynamic Programming\\nClearly there is a lot of repeated work in the above algorithm. It calculates `backtrack(candidate + i, i)` for identical values of `candidate` and `i` repeatedly. By memoizing every result, we can bring the time complexity down to polynomial time, as the maximum number of iterations will be `candidate` (<=n) times `i` (=n).\\n```\\n# Memoized backtracking (Top-down DP)\\n# O(n^2) - Times out\\ndef jump00(self, nums: List[int]) -> int:\\n    self.best = math.inf\\n    memo = {}\\n    def backtrack(candidate, end):\\n        if (candidate, end) in memo:\\n            return memo[candidate, end]\\n        if candidate >= self.best:\\n            return\\n        if end <= 0:\\n            self.best = candidate\\n        for i in range(end)[::-1]:\\n            if nums[i] + i >= end:\\n                backtrack(candidate + 1, i)\\n\\n        memo[(candidate, end)] = self.best\\n        return memo[(candidate, end)]\\n\\n    backtrack(0, len(nums)-1)\\n    return self.best\\n```\\nNow we get to around test case 100 before timing out. Progress, but still not good enough.\\n\\n# Bottom-Up DP\\nThe input arrays are extremely large. If we want to pass, we need to eliminate recursion.\\n\\nLet\\'s make an observation about the top-down DP: we are memoizing values that do not need to be memoized. The key intuition here is that if we have a score for index_start and index_end, we need not recompute values in the middle. Why? Well, if we can get to a certain ending index, then we can necessarily get to every index before that too.\\n\\n```\\n# Bottom-Up DP\\n# O(nm) - Passes\\n#   * n = len(nums) = max # of jumps\\n#   * m = max(jumps) = max jump length\\n# At each jump, jump to the index that gives us the farthest possible next jump\\n# This works because even if the optimal next jump isn\\'t the farthest, it will be contained in range(farthest)\\n# Optimal jump will always be at an index less than or equal to the farthest possible jump\\n# dp[i+1] = max_i(nums[j]+j for j in range(dp[i]+1))\\ndef jump(self, nums: List[int]) -> int:\\n    if len(nums) == 1: return 0\\n    dp = [0]\\n    for i in range(len(nums)):\\n        dp.append(max((nums[j]+j for j in range(dp[i]+1))))\\n        if dp[i+1] >= len(nums)-1:\\n            break\\n\\n    return len(dp) - 1\\n```\\n\\n\\nOur algorithm finally passes! Why is it so much faster than the one above? After converting to bottom-up, we see that this approach is actually greedy! \\n\\nLet\\'s do even better.\\n\\n# Final Greedy Solution\\nFinally, we can get rid of trivial repeated work in order to optimize to linear time and constant space.\\n\\nWhy loop from 0 each time? Just loop from the last farthest index, which is the end of the last jump. And why store all values of dp? We only need two at a time.\\n```\\n# Now the algorithm is O(n) time and O(1) space\\ndef jump(self, nums: List[int]) -> int:\\n    if len(nums) == 1: return 0\\n    last = next = 0\\n    count = 1\\n    for i in range(len(nums)):\\n        temp = next\\n        next = max((nums[j]+j for j in range(last, next+1)))\\n        if next >= len(nums)-1:\\n            break\\n        count += 1\\n        last = temp\\n\\n    return count\\n```\\n\\n# Complexity\\n- Time complexity: O(n). We effectively loop over the list twice. Once with the outer loop, and only once with the inner loop because it considers each value in nums only once due to it moving.\\n\\n- Space complexity: O(1). We only keep track of 4 integers.\\n# Performance\\n![x](https://assets.leetcode.com/users/images/8a2c6528-eb64-42e8-af3d-22c166ede68b_1675047170.0640862.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Backtracking",
                    "Greedy"
                ],
                "code": "```\\n# Backtracking\\n# O(2^n) - Times out\\ndef jump0(self, nums: List[int]) -> int:\\n    self.best = math.inf\\n    def backtrack(candidate, end):\\n        if candidate >= self.best:\\n            return\\n        if end <= 0:\\n            self.best = candidate\\n        for i in range(end)[::-1]:\\n            if nums[i] + i >= end:\\n                backtrack(candidate + 1, i)\\n\\n    backtrack(0, len(nums)-1)\\n    return self.best\\n```\n```\\n# Memoized backtracking (Top-down DP)\\n# O(n^2) - Times out\\ndef jump00(self, nums: List[int]) -> int:\\n    self.best = math.inf\\n    memo = {}\\n    def backtrack(candidate, end):\\n        if (candidate, end) in memo:\\n            return memo[candidate, end]\\n        if candidate >= self.best:\\n            return\\n        if end <= 0:\\n            self.best = candidate\\n        for i in range(end)[::-1]:\\n            if nums[i] + i >= end:\\n                backtrack(candidate + 1, i)\\n\\n        memo[(candidate, end)] = self.best\\n        return memo[(candidate, end)]\\n\\n    backtrack(0, len(nums)-1)\\n    return self.best\\n```\n```\\n# Bottom-Up DP\\n# O(nm) - Passes\\n#   * n = len(nums) = max # of jumps\\n#   * m = max(jumps) = max jump length\\n# At each jump, jump to the index that gives us the farthest possible next jump\\n# This works because even if the optimal next jump isn\\'t the farthest, it will be contained in range(farthest)\\n# Optimal jump will always be at an index less than or equal to the farthest possible jump\\n# dp[i+1] = max_i(nums[j]+j for j in range(dp[i]+1))\\ndef jump(self, nums: List[int]) -> int:\\n    if len(nums) == 1: return 0\\n    dp = [0]\\n    for i in range(len(nums)):\\n        dp.append(max((nums[j]+j for j in range(dp[i]+1))))\\n        if dp[i+1] >= len(nums)-1:\\n            break\\n\\n    return len(dp) - 1\\n```\n```\\n# Now the algorithm is O(n) time and O(1) space\\ndef jump(self, nums: List[int]) -> int:\\n    if len(nums) == 1: return 0\\n    last = next = 0\\n    count = 1\\n    for i in range(len(nums)):\\n        temp = next\\n        next = max((nums[j]+j for j in range(last, next+1)))\\n        if next >= len(nums)-1:\\n            break\\n        count += 1\\n        last = temp\\n\\n    return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2671506,
                "title": "6-liner-c-very-easy-o-n-faster-than-93-solutions",
                "content": "```\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<2) return 0;\\n        int jump=1, maxi=nums[0], curr=nums[0];\\n        for(int i=0;i<n-1;i++)\\n        {\\n            maxi=max(maxi, nums[i]+i);\\n            if(curr==i)\\n            {\\n                jump++;\\n                curr=maxi;\\n            }\\n        }\\n        return jump;\\n    }\\n```\\n\\n**PLEASE UPVOTE IF YOU LIKE IT!!**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<2) return 0;\\n        int jump=1, maxi=nums[0], curr=nums[0];\\n        for(int i=0;i<n-1;i++)\\n        {\\n            maxi=max(maxi, nums[i]+i);\\n            if(curr==i)\\n            {\\n                jump++;\\n                curr=maxi;\\n            }\\n        }\\n        return jump;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2600578,
                "title": "java-easiest-code-time-complexity-o-n",
                "content": "Hi Coders,\\n\\nPlease have a look into the code with Proper comment, it will helps you to understand the code\\n\\n```\\n\\t\\tpublic int jump(int[] nums) {\\n       \\n        int n = nums.length;\\n        if (n == 1) return 0;\\n        \\n        // max steps that we can make in one window\\n        int max_steps = 0;\\n        int cur = 0;\\n        \\n        // jumps that we need to calculate\\n        int jumps = 0;\\n        \\n        // till n-1 because we have to reach at the end point which is n-1\\n        \\n        \\n        for (int i=0;i<n-1;i++){\\n            // calculating the max at every point\\n            max_steps = Math.max(max_steps,i + nums[i]);\\n            // whenever you reached the point where you dont have steps\\n            // you need to update the step with the max_steps till this index\\n            if (cur == i){\\n                cur = max_steps;\\n                jumps++;\\n            }\\n            \\n            // if you already reached to end then no need to iterate further\\n            if (cur>n-1) return jumps;\\n            \\n        }\\n        return jumps;\\n        \\n        \\n    }\\n```\\n\\nPlease Please Please Upvote the code if you liked\\nThanks!!!\\n",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\n\\t\\tpublic int jump(int[] nums) {\\n       \\n        int n = nums.length;\\n        if (n == 1) return 0;\\n        \\n        // max steps that we can make in one window\\n        int max_steps = 0;\\n        int cur = 0;\\n        \\n        // jumps that we need to calculate\\n        int jumps = 0;\\n        \\n        // till n-1 because we have to reach at the end point which is n-1\\n        \\n        \\n        for (int i=0;i<n-1;i++){\\n            // calculating the max at every point\\n            max_steps = Math.max(max_steps,i + nums[i]);\\n            // whenever you reached the point where you dont have steps\\n            // you need to update the step with the max_steps till this index\\n            if (cur == i){\\n                cur = max_steps;\\n                jumps++;\\n            }\\n            \\n            // if you already reached to end then no need to iterate further\\n            if (cur>n-1) return jumps;\\n            \\n        }\\n        return jumps;\\n        \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2045834,
                "title": "5-simple-c-solutions-brute-force-recursion-memoization-dp-bfs-greedy",
                "content": "### Approach 1 : Recursion (Brute Force)\\n```\\nclass Solution {\\npublic:\\n    int helper(int inx, vector<int>& nums){\\n        if(inx >= nums.size()-1){\\n            return 0;\\n        }\\n        int minJumps = 10e5;\\n        for(int i=1; i<=nums[inx]; i++){\\n            minJumps = min(minJumps, 1 + helper(i + inx, nums));\\n        }\\n        return minJumps;\\n    }\\n    int jump(vector<int>& nums) {\\n        return helper(0, nums);\\n    }\\n};\\n```\\n\\nTime Complexity - O(k^n) Where k is the max value in nums\\nSpace Complexity - O(n) Recursive Stack Space\\n\\n### Approach 2 - Recursion + Memoization\\n```\\nclass Solution {\\npublic:\\n    int helper(int inx, vector<int>& nums, vector<int>& dp){\\n        if(inx >= nums.size()-1){\\n            return 0;\\n        }\\n        \\n        if(dp[inx] != -1) return dp[inx];\\n        int minJumps = 10e5;\\n        for(int i=1; i<=nums[inx]; i++){\\n            minJumps = min(minJumps, 1 + helper(i + inx, nums, dp));\\n        }\\n        \\n        return dp[inx] = minJumps;\\n    }\\n    int jump(vector<int>& nums) {\\n        vector<int> dp(nums.size(), -1);\\n        return helper(0, nums, dp);\\n    }\\n};\\n```\\n\\nTime Complexity - O(k*n) Where k is the max value in nums\\nSpace Complexity - O(n + n) Recursive Stack Space + memoization table\\n\\n### Approach 3 - Tabulation\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        vector<int> dp(nums.size(), 0);\\n        \\n        for(int inx = nums.size()-2; inx>=0; inx--){\\n            int minJumps = 10e5;\\n            for(int i=1; i<=nums[inx]; i++){\\n                if(i + inx < nums.size()) minJumps = min(minJumps, 1 + dp[i + inx]);\\n            }\\n            dp[inx] = minJumps;\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```\\n\\nTime Complexity - O(k*n) Where k is the max value in nums\\nSpace Complexity - O(n) Dp table\\n\\n### Approach 4 - BFS\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        queue<int> q;\\n        q.push(0);\\n        unordered_set<int> vis = {0};\\n        int minMoves = 0;\\n        while(!q.empty()){\\n            int qsize = q.size();\\n            while(qsize--){\\n                int inx = q.front(); q.pop();\\n                if(inx >= nums.size()-1) return minMoves;\\n                for(int i=1; i<=nums[inx]; i++){\\n                    int newInx = i + inx;\\n                    if(vis.count(newInx)) continue;\\n                    vis.insert(newInx);\\n                    q.push(newInx);\\n                }\\n            }\\n            minMoves++;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\nTime Complexity - O(k*n) Where k is the max value in nums\\nSpace Complexity - O(k) BFS queue\\n\\n###  Approach 5 - Greedy\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        pair<int,int> jumpRange = {0,0};\\n        int ans = 0;\\n        while(jumpRange.second < nums.size()-1){\\n            int maxJump = 0;\\n            for(int i=jumpRange.first; i<=jumpRange.second; i++){\\n                maxJump = max(maxJump, i + nums[i]);\\n            }\\n            jumpRange = {jumpRange.second+1, maxJump};\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nTime Complexity - O(n)\\nSpace Complexity - O(1)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Greedy",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int inx, vector<int>& nums){\\n        if(inx >= nums.size()-1){\\n            return 0;\\n        }\\n        int minJumps = 10e5;\\n        for(int i=1; i<=nums[inx]; i++){\\n            minJumps = min(minJumps, 1 + helper(i + inx, nums));\\n        }\\n        return minJumps;\\n    }\\n    int jump(vector<int>& nums) {\\n        return helper(0, nums);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int helper(int inx, vector<int>& nums, vector<int>& dp){\\n        if(inx >= nums.size()-1){\\n            return 0;\\n        }\\n        \\n        if(dp[inx] != -1) return dp[inx];\\n        int minJumps = 10e5;\\n        for(int i=1; i<=nums[inx]; i++){\\n            minJumps = min(minJumps, 1 + helper(i + inx, nums, dp));\\n        }\\n        \\n        return dp[inx] = minJumps;\\n    }\\n    int jump(vector<int>& nums) {\\n        vector<int> dp(nums.size(), -1);\\n        return helper(0, nums, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        vector<int> dp(nums.size(), 0);\\n        \\n        for(int inx = nums.size()-2; inx>=0; inx--){\\n            int minJumps = 10e5;\\n            for(int i=1; i<=nums[inx]; i++){\\n                if(i + inx < nums.size()) minJumps = min(minJumps, 1 + dp[i + inx]);\\n            }\\n            dp[inx] = minJumps;\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        queue<int> q;\\n        q.push(0);\\n        unordered_set<int> vis = {0};\\n        int minMoves = 0;\\n        while(!q.empty()){\\n            int qsize = q.size();\\n            while(qsize--){\\n                int inx = q.front(); q.pop();\\n                if(inx >= nums.size()-1) return minMoves;\\n                for(int i=1; i<=nums[inx]; i++){\\n                    int newInx = i + inx;\\n                    if(vis.count(newInx)) continue;\\n                    vis.insert(newInx);\\n                    q.push(newInx);\\n                }\\n            }\\n            minMoves++;\\n        }\\n        return 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        pair<int,int> jumpRange = {0,0};\\n        int ans = 0;\\n        while(jumpRange.second < nums.size()-1){\\n            int maxJump = 0;\\n            for(int i=jumpRange.first; i<=jumpRange.second; i++){\\n                maxJump = max(maxJump, i + nums[i]);\\n            }\\n            jumpRange = {jumpRange.second+1, maxJump};\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806520,
                "title": "java-with-comments-100-faster-o-n-time",
                "content": "* O(n) time\\n* O(1) space\\n* easy explanation\\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        \\n        //start from 0\\n        //maximum jump we can do is nums[0] or in other words i+nums[i] (i==0)\\n        //steps taken is 1\\n        //don\\'t worry for length 1 (we are at the end so no need to jump, steps 0)\\n        int n=nums.length, max_long_jump=nums[0], longest_jump=nums[0], steps=1;\\n        \\n        for(int i=1;i<n-1;i++){\\n            \\n            //maximum longest jump we can make is this (same as case i==0)\\n            max_long_jump=Math.max(max_long_jump,i+nums[i]);\\n            \\n            //if our longest jump is done\\n            if(i==longest_jump){\\n                \\n                //means we need to make one more jump\\n                steps++;\\n                //now our longest jump is \"maximum longest jump\" (which we are updating everytime)\\n                longest_jump=max_long_jump;\\n            \\n            }\\n            \\n            // (in addition : if you understood so far, i assume you already get this - if longest_jump == the last element i.e. n-1, so we are done and break also)\\n        \\n        }\\n        \\n        return n==1?0:steps;\\n    }\\n}\\n```\\n**Don\\'t forgot to upvote, it will help others**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        \\n        //start from 0\\n        //maximum jump we can do is nums[0] or in other words i+nums[i] (i==0)\\n        //steps taken is 1\\n        //don\\'t worry for length 1 (we are at the end so no need to jump, steps 0)\\n        int n=nums.length, max_long_jump=nums[0], longest_jump=nums[0], steps=1;\\n        \\n        for(int i=1;i<n-1;i++){\\n            \\n            //maximum longest jump we can make is this (same as case i==0)\\n            max_long_jump=Math.max(max_long_jump,i+nums[i]);\\n            \\n            //if our longest jump is done\\n            if(i==longest_jump){\\n                \\n                //means we need to make one more jump\\n                steps++;\\n                //now our longest jump is \"maximum longest jump\" (which we are updating everytime)\\n                longest_jump=max_long_jump;\\n            \\n            }\\n            \\n            // (in addition : if you understood so far, i assume you already get this - if longest_jump == the last element i.e. n-1, so we are done and break also)\\n        \\n        }\\n        \\n        return n==1?0:steps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1642940,
                "title": "o-n-d-p-solution-c",
                "content": "class Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n        int curr_reach=0,max_reach=0,jumps=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            max_reach=max(max_reach,i+nums[i]);\\n            if(i==curr_reach)\\n            {\\n                curr_reach=max_reach;\\n                jumps++;\\n            }      \\n        }\\n        return jumps;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n        int curr_reach=0,max_reach=0,jumps=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            max_reach=max(max_reach,i+nums[i]);\\n            if(i==curr_reach)\\n            {\\n                curr_reach=max_reach;\\n                jumps++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1121800,
                "title": "faster-than-any-submitted-python-code-beats-100-time-and-space-complexity",
                "content": "O(N^2) time and O(N) Space DP Solution\\n```\\nclass Solution:\\n    def jump(self, array: List[int]) -> int:\\n        minJumps = [float(\"inf\") for _ in array]\\n        minJumps[0] = 0\\n        for index in range(1, len(array)):\\n            for idx in range(index):\\n                if array[idx] >= index - idx:\\n                    minJumps[index] = min(minJumps[index], minJumps[idx] +1)\\n        return minJumps[-1]\\n\\t\\t\\n```\\nEdit: Above Method Leads To TLE Now. Used Below Optimised Method.\\n\\nO(N) Time and O(1) space solution\\n```\\nclass Solution:\\n    def jump(self, array):\\n        if len(array) == 1:\\n            return 0\\n        jumps, maxReach, steps = 0, array[0], array[0]\\n        for idx in range(1, len(array)-1):\\n            maxReach = max(maxReach, idx+array[idx])\\n            steps -= 1\\n            if steps == 0:\\n                jumps += 1\\n                steps = maxReach-idx\\n        return jumps+1\\n\\t```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def jump(self, array: List[int]) -> int:\\n        minJumps = [float(\"inf\") for _ in array]\\n        minJumps[0] = 0\\n        for index in range(1, len(array)):\\n            for idx in range(index):\\n                if array[idx] >= index - idx:\\n                    minJumps[index] = min(minJumps[index], minJumps[idx] +1)\\n        return minJumps[-1]\\n\\t\\t\\n```\n```\\nclass Solution:\\n    def jump(self, array):\\n        if len(array) == 1:\\n            return 0\\n        jumps, maxReach, steps = 0, array[0], array[0]\\n        for idx in range(1, len(array)-1):\\n            maxReach = max(maxReach, idx+array[idx])\\n            steps -= 1\\n            if steps == 0:\\n                jumps += 1\\n                steps = maxReach-idx\\n        return jumps+1\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 949270,
                "title": "python3-o-n-solution-with-detailed-explanations",
                "content": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        \\n        if len(nums) < 2: return 0                      # corner case\\n        \\n        jump = 1                                        # if not corner case, at least 1 jump is needed\\n        curr_max = max_reach = nums[0]                  # max_reach to record the max index can be reached with current # of jump\\n                                                        # curr_max to record the max index can be reached from the current index\\n        \\n        \\n        for i in range(1, len(nums)):                   # we start from index 1 if not corner case, but including 0 still works\\n            if max_reach >= len(nums) - 1:              # termination check\\n                return jump\\n            if i < max_reach:                           # if i is within the reach of current jump\\n                if i + nums[i] > curr_max:              # we update the current max reach if a larger one exists\\n                    curr_max = i + nums[i]              \\n                    if curr_max >= len(nums) - 1:       # early terminatin check, but solution still works even without this\\n                        return jump + 1                 # remember to add 1 to current jump if you use early termination\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    # here we dont jump yet until we figure out the max range we can reach \\n                                                        # if we jump one more time\\n                        \\n            else:                                       # when we enter this else statement, it means max_reach is not the end of list\\n                                                        # thus we have to jump now\\n                max_reach = max(curr_max, i + nums[i])  # we update our max_reach using the curr_max recorded so far or i + nums[i]\\n                jump += 1                               # and we add 1 to jump to add this jump\\n        \\n        return jump\\n    \\n    # TC: O(n)\\n    # n is the len(nums), as we only scan the list once\\n    \\n    # SC: O(1)\\n    # we only init 3 variables, thus space is constant\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        \\n        if len(nums) < 2: return 0                      # corner case\\n        \\n        jump = 1                                        # if not corner case, at least 1 jump is needed\\n        curr_max = max_reach = nums[0]                  # max_reach to record the max index can be reached with current # of jump\\n                                                        # curr_max to record the max index can be reached from the current index\\n        \\n        \\n        for i in range(1, len(nums)):                   # we start from index 1 if not corner case, but including 0 still works\\n            if max_reach >= len(nums) - 1:              # termination check\\n                return jump\\n            if i < max_reach:                           # if i is within the reach of current jump\\n                if i + nums[i] > curr_max:              # we update the current max reach if a larger one exists\\n                    curr_max = i + nums[i]              \\n                    if curr_max >= len(nums) - 1:       # early terminatin check, but solution still works even without this\\n                        return jump + 1                 # remember to add 1 to current jump if you use early termination\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    # here we dont jump yet until we figure out the max range we can reach \\n                                                        # if we jump one more time\\n                        \\n            else:                                       # when we enter this else statement, it means max_reach is not the end of list\\n                                                        # thus we have to jump now\\n                max_reach = max(curr_max, i + nums[i])  # we update our max_reach using the curr_max recorded so far or i + nums[i]\\n                jump += 1                               # and we add 1 to jump to add this jump\\n        \\n        return jump\\n    \\n    # TC: O(n)\\n    # n is the len(nums), as we only scan the list once\\n    \\n    # SC: O(1)\\n    # we only init 3 variables, thus space is constant\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645404,
                "title": "all-approach-from-brute-force-memoization-bottom-up-and-finally-greedy",
                "content": "***Brute Force***\\n```\\nlong long  min(long long a,long long b){\\n    if(a > b)   return b;\\n    return a;\\n}\\n\\n//assume that answer always exist\\nlong long decideJump(vector<int>& nums,int n,int currPos){\\n    if(currPos >= n-1){\\n        return 0;\\n    }\\n    \\n    long long answer = INT_MAX;\\n    \\n    int maxSteps = nums[currPos];\\n    \\n    \\n    while(maxSteps > 0){\\n        answer = min(answer,1 + decideJump(nums,n,currPos+maxSteps));\\n        maxSteps--;\\n    }\\n    \\n    return answer;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        return (int)decideJump(nums,n,0);   \\n    }\\n};\\n```\\n***Memorization***\\n```\\nlong long  min(long long a,long long b){\\n    if(a > b)   return b;\\n    return a;\\n}\\n//assume that answer always exist\\nlong long decideJump(vector<int>& nums,int n,int currPos,vector<int>& dp){\\n    if(currPos >= n-1){\\n        return 0;\\n    }\\n    \\n    if(dp[currPos] != -1){\\n        return dp[currPos];\\n    }\\n    \\n    long long answer = INT_MAX;\\n    \\n    int maxSteps = nums[currPos];\\n    \\n    \\n    while(maxSteps > 0){\\n        answer = min(answer,1 + decideJump(nums,n,currPos+maxSteps,dp));\\n        maxSteps--;\\n    }\\n    \\n    return dp[currPos] = answer;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n+10,-1);\\n        return (int)decideJump(nums,n,0,dp);   \\n    }\\n};\\n```\\n***Bottom-Up***\\n```\\n//bottom up approach to this problem\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> dp(n,INT_MAX);\\n        \\n        dp[n-1] = 0;\\n        \\n        for(int i=n-2;i>=0;i--){\\n            for(int j=1;j<=nums[i];j++){\\n                if(i+j < n){\\n                    dp[i] = min(dp[i],1+dp[i+j]);\\n                }\\n            }\\n        }\\n        \\n        return (int)dp[0];\\n    }\\n};\\n```\\n***Greedy***\\n```\\n//now our only hope left is greedy solution that will run in O(n) time complexity and\\n//O(1) space complexity\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        if(n == 0){\\n            return 1;\\n        }\\n        \\n        int maxReach = nums[0];\\n        int jump = 1;\\n        int step = nums[0];\\n        \\n        for(int i=1;i<n;i++){\\n            \\n            if(i == n-1){\\n                return jump;\\n            }\\n            step--;\\n            maxReach = max(maxReach,i+nums[i]);\\n            \\n            if(step == 0){\\n                if(i >= maxReach){\\n                    return -1;\\n                }\\n                jump++;\\n                step = maxReach - i;\\n            }\\n            \\n        }\\n        \\n        return 0;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Memoization"
                ],
                "code": "```\\nlong long  min(long long a,long long b){\\n    if(a > b)   return b;\\n    return a;\\n}\\n\\n//assume that answer always exist\\nlong long decideJump(vector<int>& nums,int n,int currPos){\\n    if(currPos >= n-1){\\n        return 0;\\n    }\\n    \\n    long long answer = INT_MAX;\\n    \\n    int maxSteps = nums[currPos];\\n    \\n    \\n    while(maxSteps > 0){\\n        answer = min(answer,1 + decideJump(nums,n,currPos+maxSteps));\\n        maxSteps--;\\n    }\\n    \\n    return answer;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        return (int)decideJump(nums,n,0);   \\n    }\\n};\\n```\n```\\nlong long  min(long long a,long long b){\\n    if(a > b)   return b;\\n    return a;\\n}\\n//assume that answer always exist\\nlong long decideJump(vector<int>& nums,int n,int currPos,vector<int>& dp){\\n    if(currPos >= n-1){\\n        return 0;\\n    }\\n    \\n    if(dp[currPos] != -1){\\n        return dp[currPos];\\n    }\\n    \\n    long long answer = INT_MAX;\\n    \\n    int maxSteps = nums[currPos];\\n    \\n    \\n    while(maxSteps > 0){\\n        answer = min(answer,1 + decideJump(nums,n,currPos+maxSteps,dp));\\n        maxSteps--;\\n    }\\n    \\n    return dp[currPos] = answer;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n+10,-1);\\n        return (int)decideJump(nums,n,0,dp);   \\n    }\\n};\\n```\n```\\n//bottom up approach to this problem\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> dp(n,INT_MAX);\\n        \\n        dp[n-1] = 0;\\n        \\n        for(int i=n-2;i>=0;i--){\\n            for(int j=1;j<=nums[i];j++){\\n                if(i+j < n){\\n                    dp[i] = min(dp[i],1+dp[i+j]);\\n                }\\n            }\\n        }\\n        \\n        return (int)dp[0];\\n    }\\n};\\n```\n```\\n//now our only hope left is greedy solution that will run in O(n) time complexity and\\n//O(1) space complexity\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        if(n == 0){\\n            return 1;\\n        }\\n        \\n        int maxReach = nums[0];\\n        int jump = 1;\\n        int step = nums[0];\\n        \\n        for(int i=1;i<n;i++){\\n            \\n            if(i == n-1){\\n                return jump;\\n            }\\n            step--;\\n            maxReach = max(maxReach,i+nums[i]);\\n            \\n            if(step == 0){\\n                if(i >= maxReach){\\n                    return -1;\\n                }\\n                jump++;\\n                step = maxReach - i;\\n            }\\n            \\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 502009,
                "title": "javascript-o-n-time-and-o-1-space-extended-notes",
                "content": "To tackle this we...\\n\\n* Set the number of steps we are allowed to take from the first value in the array\\n* Iterate through the array once\\n* At each index we set a maxReach variable ( the further place in the array we can reach)\\n* At the same time, for each index we reduce the number of steps by one\\n* If we run out of steps it means we must have taken a jump to get to our current location\\n* So... we need to update the number of steps... to do this we look at how far we are from our maxReach and subtract our current index\\n* When we reach the final index we return the number of jumps it\\'s taken us to arrive there PLUS ONE . This is because we have not consumed all our final steps. \\n\\nThe iteration pattern plays out like this...\\n\\n**INITIAL SETUP**\\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//   ^ \\n//   |  \\n// \\n// Max Reach: 3\\n//     Steps: 3\\n//     Jumps: 0\\n```\\n\\n**1ST ITERATION**\\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//      ^ \\n//      |  \\n// \\n// Max Reach: 5\\n//     Steps: 2\\n//     Jumps: 0\\n```\\n\\n**2ND ITERATION**\\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//         ^ \\n//         |  \\n// \\n// Max Reach: 5\\n//     Steps: 1\\n//     Jumps: 0\\n```\\n\\n**3RD ITERATION**\\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//            ^ \\n//            |  \\n// \\n// Max Reach: 5\\n//     Steps: 0 --> Resets to 2 (maxReach of 5 minus current index of 3)\\n//     Jumps: 1\\n```\\n\\n**4TH ITERATION**\\n```\\n//               ^ \\n//               |  \\n// \\n// Max Reach: 6\\n//     Steps: 1\\n//     Jumps: 1\\n```\\n\\n**5TH ITERATION**\\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                  ^ \\n//                  |  \\n// \\n// Max Reach: 8\\n//     Steps: 0 --> Resets to 3 (maxReach of 8 minus current index of 5)\\n//     Jumps: 2\\n```\\n\\n**6TH ITERATION**\\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                     ^ \\n//                     |  \\n// \\n// Max Reach: 13\\n//     Steps: 2\\n//     Jumps: 2\\n```\\n\\n**7TH ITERATION**\\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                        ^ \\n//                        |  \\n// \\n// Max Reach: 13\\n//     Steps: 1\\n//     Jumps: 2\\n```\\n\\n**8TH ITERATION**\\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                           ^ \\n//                           |  \\n// \\n// Max Reach: 13\\n//     Steps: 0 --> Resets to 5 (maxReach 13 minus current index of 8)\\n//     Jumps: 3\\n```\\n\\n**9THITERATION**\\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                              ^ \\n//                              |  \\n// \\n// Max Reach: 13\\n//     Steps: 4 \\n//     Jumps: 3\\n```\\n\\n**10TH ITERATION**\\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                                 ^ \\n//                                 |  \\n// \\n// Max Reach: 13\\n//     Steps: 3 \\n//     Jumps: 3\\n```\\n\\n**POST ITERATION**\\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                                     ^ \\n//                                     |  \\n// \\n// Max Reach: 13\\n//     Steps: 2\\n//     Jumps: 3\\n// At this point we have unconsumed steps meaning we need to add ONE to our jump total to represent the consumption of the remaining steps (imagine jumping from value 7 to the end)\\n```\\n\\n\\n\\n\\n**SOLUTION**\\n```\\nvar jump = function(nums) {\\n\\tif(nums.length === 1) return 0;\\n\\tlet jumps = 0;\\n\\tlet maxReach = nums[0];\\n\\tlet steps = nums[0];\\n\\tfor(let i = 1; i < nums.length - 1; i++){\\n\\t\\tmaxReach = Math.max(maxReach, i + nums[i])\\n\\t\\tsteps--;\\n\\t\\tif(steps === 0){\\n\\t\\t\\tjumps++;\\n\\t\\t\\tsteps = maxReach - i;\\n\\t\\t}\\n\\t}\\n\\treturn jumps + 1;  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//   ^ \\n//   |  \\n// \\n// Max Reach: 3\\n//     Steps: 3\\n//     Jumps: 0\\n```\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//      ^ \\n//      |  \\n// \\n// Max Reach: 5\\n//     Steps: 2\\n//     Jumps: 0\\n```\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//         ^ \\n//         |  \\n// \\n// Max Reach: 5\\n//     Steps: 1\\n//     Jumps: 0\\n```\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//            ^ \\n//            |  \\n// \\n// Max Reach: 5\\n//     Steps: 0 --> Resets to 2 (maxReach of 5 minus current index of 3)\\n//     Jumps: 1\\n```\n```\\n//               ^ \\n//               |  \\n// \\n// Max Reach: 6\\n//     Steps: 1\\n//     Jumps: 1\\n```\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                  ^ \\n//                  |  \\n// \\n// Max Reach: 8\\n//     Steps: 0 --> Resets to 3 (maxReach of 8 minus current index of 5)\\n//     Jumps: 2\\n```\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                     ^ \\n//                     |  \\n// \\n// Max Reach: 13\\n//     Steps: 2\\n//     Jumps: 2\\n```\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                        ^ \\n//                        |  \\n// \\n// Max Reach: 13\\n//     Steps: 1\\n//     Jumps: 2\\n```\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                           ^ \\n//                           |  \\n// \\n// Max Reach: 13\\n//     Steps: 0 --> Resets to 5 (maxReach 13 minus current index of 8)\\n//     Jumps: 3\\n```\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                              ^ \\n//                              |  \\n// \\n// Max Reach: 13\\n//     Steps: 4 \\n//     Jumps: 3\\n```\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                                 ^ \\n//                                 |  \\n// \\n// Max Reach: 13\\n//     Steps: 3 \\n//     Jumps: 3\\n```\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                                     ^ \\n//                                     |  \\n// \\n// Max Reach: 13\\n//     Steps: 2\\n//     Jumps: 3\\n// At this point we have unconsumed steps meaning we need to add ONE to our jump total to represent the consumption of the remaining steps (imagine jumping from value 7 to the end)\\n```\n```\\nvar jump = function(nums) {\\n\\tif(nums.length === 1) return 0;\\n\\tlet jumps = 0;\\n\\tlet maxReach = nums[0];\\n\\tlet steps = nums[0];\\n\\tfor(let i = 1; i < nums.length - 1; i++){\\n\\t\\tmaxReach = Math.max(maxReach, i + nums[i])\\n\\t\\tsteps--;\\n\\t\\tif(steps === 0){\\n\\t\\t\\tjumps++;\\n\\t\\t\\tsteps = maxReach - i;\\n\\t\\t}\\n\\t}\\n\\treturn jumps + 1;  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 380429,
                "title": "java-dynamic-programming-bottom-up-solution",
                "content": "cache[i] represents the minimum number of steps taken to reach the ith index\\n\\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int[] cache = new int[nums.length];\\n        \\n        cache[0] = 0;\\n        \\n        for (int i = 1; i < cache.length; i++) {\\n            cache[i] = Integer.MAX_VALUE;\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = 1; j <= nums[i]; j++) {\\n                int next = Math.min(i+j, nums.length-1);\\n        \\n                cache[next] = Math.min(cache[next], 1 + cache[i]);\\n            }\\n        }\\n        \\n        return cache[nums.length-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int[] cache = new int[nums.length];\\n        \\n        cache[0] = 0;\\n        \\n        for (int i = 1; i < cache.length; i++) {\\n            cache[i] = Integer.MAX_VALUE;\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = 1; j <= nums[i]; j++) {\\n                int next = Math.min(i+j, nums.length-1);\\n        \\n                cache[next] = Math.min(cache[next], 1 + cache[i]);\\n            }\\n        }\\n        \\n        return cache[nums.length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340334,
                "title": "simple-dp-very-simple-pruning-and-it-works-12ms",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, n+1);\\n        dp[0] = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (i > 0 && nums[i] < nums[i-1])\\n                continue;\\n            for (int j = 1; j <= nums[i] && (i+j) < n; j++)\\n                dp[i+j] = min(dp[i+j], dp[i]+1);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, n+1);\\n        dp[0] = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (i > 0 && nums[i] < nums[i-1])\\n                continue;\\n            for (int j = 1; j <= nums[i] && (i+j) < n; j++)\\n                dp[i+j] = min(dp[i+j], dp[i]+1);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 304289,
                "title": "c-greedy-boy-solution-use-magic-lasers-and-pew-pew-kitty-cats",
                "content": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        \\n        int aJumps = 0;\\n        int aEnd = 0;\\n        int aFarthest = 0;\\n        \\n        for (int i=0;i<(nums.size()-1);i++) {\\n            aFarthest = max(aFarthest, i + nums[i]);\\n            if (i == aEnd) {\\n                aJumps++;\\n                aEnd = aFarthest;\\n            }   \\n        }\\n        return aJumps;\\n        \\n    }\\n};\\n```\\n\\nO(N)\\n\\nWhy it works? Magic!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        \\n        int aJumps = 0;\\n        int aEnd = 0;\\n        int aFarthest = 0;\\n        \\n        for (int i=0;i<(nums.size()-1);i++) {\\n            aFarthest = max(aFarthest, i + nums[i]);\\n            if (i == aEnd) {\\n                aJumps++;\\n                aEnd = aFarthest;\\n            }   \\n        }\\n        return aJumps;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18205,
                "title": "is-there-better-solution-for-jump-game-ii",
                "content": "my solution exceeds time limit.\\nI use an array to track the min step at i . It seems my solution is not efficient enough. You guys have better solution?\\n\\n    class Solution {\\n    public:\\n        int jump(int A[], int n) {\\n            vector<int> track(n, 0);\\n            \\n            for(int i=1; i<n; i++){\\n                int min = INT_MAX;\\n                for(int j=0; j<i; j++){\\n                    if(track[j] < min && A[j]+j >= i)\\n                        min = track[j];\\n                }\\n                track[i] = min+1;\\n            }\\n            return track[n-1];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int jump(int A[], int n) {\\n            vector<int> track(n, 0);\\n            \\n            for(int i=1; i<n; i++){\\n                int min = INT_MAX;\\n                for(int j=0; j<i; j++){\\n                    if(track[j] < min && A[j]+j >= i)\\n                        min = track[j];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3372877,
                "title": "easy-clear-solution-python3",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        dp=[-1 for _ in range(n-1)]\\n        dp+=[0]\\n        for i in range(n-2,-1,-1):\\n            for j in range(i+1,min(n,i+nums[i]+1)):\\n                if dp[j]!=-1:\\n                    if dp[i]==-1:\\n                        dp[i]=dp[j]+1\\n                    else:\\n                        dp[i]=min(dp[i],dp[j]+1)\\n        return dp[0]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        dp=[-1 for _ in range(n-1)]\\n        dp+=[0]\\n        for i in range(n-2,-1,-1):\\n            for j in range(i+1,min(n,i+nums[i]+1)):\\n                if dp[j]!=-1:\\n                    if dp[i]==-1:\\n                        dp[i]=dp[j]+1\\n                    else:\\n                        dp[i]=min(dp[i],dp[j]+1)\\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159174,
                "title": "sundar-susheel-ubla-hua-ekdum-simple-sada-garam-garam-code",
                "content": "# Intuition\\nThe problem is similar to jump game with atmost k jumps. Here instead of knowing the k before hand , we will get the k dynamically by nums[ind]\\n\\n# Approach\\nFirst we will write the recursive logic and later memoise it.\\nFrom the 0th index we need to reach n-1 index in minimal possible steps.\\n- The base condition is that if we reach the end then return 0\\n- We will take a variable mini which will store the minimal jumps required to reach a particular index. We will initialise it with a large value.\\n- nums[ind] will define us how many steps atmost we can jump forward.\\nSo we will have a loop from ind till ind+ k , (k=nums[ind]) and we will jump till there and update the mini.\\n(We need to take care that we do not jump out of the nums vector. ind+i <=n)\\n```\\n//Attaching recursive code\\nint dfs(int ind,int n,vector<int>&nums)\\n    {\\n        if(ind==n)return 0;\\n        int mini=1e9;\\n        int k=nums[ind];\\n        for(int i=1;i<=k;i++)\\n        {\\n            if(ind+i<=n)\\n            {\\n                int jump=1+dfs(ind+i,n,nums);\\n                mini=min(mini,jump);\\n            }\\n        }\\n        return mini;\\n    }\\n\\n``` \\nWe will memoise it for optimisation.\\n**In main function we will pass dfs(0,n-1,nums)**\\n0 is the start index \\nn-1 is the the last index of the nums (Mentioned in ques we need to jump till n-1th index)\\n\\n# Complexity\\n- **Time complexity**:\\nTC would be O(n*k) where n is size of vector and k is the number of jumps we can take at each index.\\n\\n- **Space complexity**:\\nWe are doing recursion , so SC O(n) for recursion stack and a dp vector of O(n) space. Overall SC O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int ind,int n,vector<int>&nums,vector<int>&dp)\\n    {\\n        if(ind==n)return 0;\\n        int mini=1e9;\\n        if(dp[ind]!=-1)return dp[ind];\\n        int k=nums[ind];\\n        for(int i=1;i<=k;i++)\\n        {\\n            if(ind+i<=n)\\n            {\\n                int jump=1+dfs(ind+i,n,nums,dp);\\n                mini=min(mini,jump);\\n            }\\n        }\\n        return dp[ind]=mini;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>dp(n,-1);\\n        return dfs(0,n-1,nums,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n//Attaching recursive code\\nint dfs(int ind,int n,vector<int>&nums)\\n    {\\n        if(ind==n)return 0;\\n        int mini=1e9;\\n        int k=nums[ind];\\n        for(int i=1;i<=k;i++)\\n        {\\n            if(ind+i<=n)\\n            {\\n                int jump=1+dfs(ind+i,n,nums);\\n                mini=min(mini,jump);\\n            }\\n        }\\n        return mini;\\n    }\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int dfs(int ind,int n,vector<int>&nums,vector<int>&dp)\\n    {\\n        if(ind==n)return 0;\\n        int mini=1e9;\\n        if(dp[ind]!=-1)return dp[ind];\\n        int k=nums[ind];\\n        for(int i=1;i<=k;i++)\\n        {\\n            if(ind+i<=n)\\n            {\\n                int jump=1+dfs(ind+i,n,nums,dp);\\n                mini=min(mini,jump);\\n            }\\n        }\\n        return dp[ind]=mini;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>dp(n,-1);\\n        return dfs(0,n-1,nums,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158649,
                "title": "c-greedy-approach-constant-space-comments-added-easy",
                "content": "# Complexity\\n- Time complexity:\\n**O(N)**\\n\\n- Space complexity:\\n**O(1)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums)\\n    {\\n        int n=nums.size();\\n        int jump=0;\\n        \\n        int maximum_reach=0;\\n        int max_pos=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==n-1) return jump;\\n            maximum_reach = max(maximum_reach,i+nums[i]);      // for each particular idx storing the max jump\\n\\n            // If i has reached to it\\'s max position then we need to jump to go on next\\n            if(i==max_pos)\\n            {\\n                jump++;                          // increase jump\\n                max_pos = maximum_reach;         // assign max_reach as a max_pos for this jump\\n            }\\n        }\\n        return jump;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums)\\n    {\\n        int n=nums.size();\\n        int jump=0;\\n        \\n        int maximum_reach=0;\\n        int max_pos=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==n-1) return jump;\\n            maximum_reach = max(maximum_reach,i+nums[i]);      // for each particular idx storing the max jump\\n\\n            // If i has reached to it\\'s max position then we need to jump to go on next\\n            if(i==max_pos)\\n            {\\n                jump++;                          // increase jump\\n                max_pos = maximum_reach;         // assign max_reach as a max_pos for this jump\\n            }\\n        }\\n        return jump;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874337,
                "title": "easy-java-solution-using-sliding-window-beats-99-89",
                "content": "The solution illustrates **BFS** using **sliding window**.\\n\\n![3549-pepepopcorn.png](https://assets.leetcode.com/users/images/96d98a88-b29c-4c80-b21f-860c9f50897d_1675846588.2118175.png)\\n\\nSubmission Link: https://leetcode.com/submissions/detail/854067528/\\n\\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int res = 0;\\n        int l, r, farthest;\\n        l = r = farthest = 0;\\n        while(r < nums.length - 1){\\n            farthest = 0;\\n\\t\\t\\t// r+1 because we also need to include position r\\n            for(int i=l; i<r+1; i++){\\n                farthest = Math.max(farthest, i + nums[i]);\\n            }\\n            l = r+1;\\n            r = farthest;\\n            res++;\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/c3a43b2e-2e21-4ddd-bb40-4e52fb2a0e1c_1670099721.8790011.png)\\n\\n![No Upvotes, Have a Good Day.png](https://assets.leetcode.com/users/images/6e4aad28-ca17-420f-a665-eface165310a_1675846567.4085553.png)\\n",
                "solutionTags": [
                    "Breadth-First Search",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int res = 0;\\n        int l, r, farthest;\\n        l = r = farthest = 0;\\n        while(r < nums.length - 1){\\n            farthest = 0;\\n\\t\\t\\t// r+1 because we also need to include position r\\n            for(int i=l; i<r+1; i++){\\n                farthest = Math.max(farthest, i + nums[i]);\\n            }\\n            l = r+1;\\n            r = farthest;\\n            res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2356813,
                "title": "c-beats-99-cpp-solutions-easy-understanding-ladder-approach-linear-0-n-no-space",
                "content": "The approach which we are going to use is that we will try to move along a ladder and check that what maximum distance we can travel using ladder and while travelling the current ladder what is the maximum value ladder we get\\n\\nSteps-\\n1. steps = 0, ladder = 0\\n2. iterate the loop\\n\\t1. if ladder < i, it means ladder can not reach position i so we return -1(unreachable)\\n\\t2. if ladder >= n-1, ladder has reached the end of the array so we return steps\\n\\t3. we will iterate through i to ladder and update the ladder length and while updating we will keep track that whether we update the ladder length while traversing the ladder \\n\\t4. if yes(we are increasing the length of ladder, it means we are making a step), so we increase the step count\\n\\t\\n  3.return steps\\n\\n```\\nint jump(vector<int> &arr){\\n        int n = arr.size();\\n        int ladder = 0;\\n        int steps = 0;\\n        for(int i = 0 ; i < n ; ){\\n            if(ladder >= n-1){\\n                return steps;\\n            }\\n            if(ladder < i){\\n                return -1;\\n            }\\n           \\n            bool increaseSteps = false;\\n            int k = ladder;\\n            for( ; i <= k && i < n ; i++){\\n                if(i + arr[i] > ladder && ladder < n-1){\\n                    ladder = i + arr[i];\\n                    increaseSteps = true;\\n                }   \\n            }\\n            if(increaseSteps == true){\\n                steps += 1;\\n            }\\n            \\n        }\\n        return steps;\\n    }\\n```\\n\\nTime Complexity - O(N)\\nSpace Complexity - O(1)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nint jump(vector<int> &arr){\\n        int n = arr.size();\\n        int ladder = 0;\\n        int steps = 0;\\n        for(int i = 0 ; i < n ; ){\\n            if(ladder >= n-1){\\n                return steps;\\n            }\\n            if(ladder < i){\\n                return -1;\\n            }\\n           \\n            bool increaseSteps = false;\\n            int k = ladder;\\n            for( ; i <= k && i < n ; i++){\\n                if(i + arr[i] > ladder && ladder < n-1){\\n                    ladder = i + arr[i];\\n                    increaseSteps = true;\\n                }   \\n            }\\n            if(increaseSteps == true){\\n                steps += 1;\\n            }\\n            \\n        }\\n        return steps;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2257911,
                "title": "dekho-bhai-ye-koi-medium-problem-nhi-hain-ye-tum-nirbhar-karta-hain-ki-kaise-sochte-ho",
                "content": "**Dekho bhai, es problem me humlog dp bhie laga sakte hain or greedy bhie, greedy ka approach bhie dekh lo ek baar in O(N) time complexity & O(1) space complexity\\nAgar phir bhi koi probelm hain to humlog Dp bhie use kar skate hain yaha par**\\nInput ke anusar humlog guess kar skate hain Achhe se.....\\nYe arha greedy ka code\\n\\n```\\n class Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        int reach=0; // Reach at that position after jumping from previous index\\n        int max_jump=0;  // It is in form of index only to jump at max num[max_jump]\\n        int mini_step=0;  // To count the number of step to reach at end of the index\\n        \\n            \\n            // Corner case\\n        if(n==1)\\n            return 0;\\n        \\n        for(int i=0;i<nums.size()-1;i++){\\n            \\n            max_jump=max(max_jump,i+nums[i]);\\n            \\n            if(reach==i){ \\n                mini_step++;\\n                reach=max_jump;\\n            } \\n         }\\n         return mini_step;\\n    }\\n};\\n```\\n**Sikhte raho bhailog hamesa\\nor agar aapko ye appraoch achha laga hoga to like jaroor kare dhaynewaad bhailog!!**",
                "solutionTags": [],
                "code": "```\\n class Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        int reach=0; // Reach at that position after jumping from previous index\\n        int max_jump=0;  // It is in form of index only to jump at max num[max_jump]\\n        int mini_step=0;  // To count the number of step to reach at end of the index\\n        \\n            \\n            // Corner case\\n        if(n==1)\\n            return 0;\\n        \\n        for(int i=0;i<nums.size()-1;i++){\\n            \\n            max_jump=max(max_jump,i+nums[i]);\\n            \\n            if(reach==i){ \\n                mini_step++;\\n                reach=max_jump;\\n            } \\n         }\\n         return mini_step;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2189064,
                "title": "java-greedy-in-depth-explanation",
                "content": "If you haven\\'t completed **LC.55 Jump Game**, I\\'d recommend you to do Jump Game first. You can find [my solution](https://leetcode.com/problems/jump-game/discuss/2188884/Java-or-In-depth-Explanation-or-O(n)-time-and-O(1)-space) to Jump Game here.\\n  \\n  We also use Greedy algorithm in the solution. We need three variales `max_reach` the farthest index we can reach, `jumps` the min number of jumps to last index, `currentJumpEnd` the end index that we can jump to from the previous jump. \\n  \\n  The key point is we need to update both `jumps` and `currentJumpEnd` when `i == currentJumpEnd`. Why? We need to do so because we already reach the farthest index from previous jump. Hence, we need to jump again!\\n  \\n  ```\\n  class Solution\\n{\\n    // return the min required jumps to last index\\n    public int jump(int[] nums) \\n    {\\n        // Greedy Algorithm\\n        // O(n) time | O(1) space\\n        int max_reach = 0;\\n        int jumps = 0;\\n        int currentJumpEnd = 0;\\n        \\n        for(int i = 0; i < nums.length-1; i++)\\n        {\\n            max_reach = Math.max(max_reach, i + nums[i]);\\n            \\n            if(i == currentJumpEnd)\\n            {\\n                jumps += 1;\\n                currentJumpEnd = max_reach;\\n            }\\n        }\\n        return jumps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\n  class Solution\\n{\\n    // return the min required jumps to last index\\n    public int jump(int[] nums) \\n    {\\n        // Greedy Algorithm\\n        // O(n) time | O(1) space\\n        int max_reach = 0;\\n        int jumps = 0;\\n        int currentJumpEnd = 0;\\n        \\n        for(int i = 0; i < nums.length-1; i++)\\n        {\\n            max_reach = Math.max(max_reach, i + nums[i]);\\n            \\n            if(i == currentJumpEnd)\\n            {\\n                jumps += 1;\\n                currentJumpEnd = max_reach;\\n            }\\n        }\\n        return jumps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2102498,
                "title": "java-o-n-linear-solution-greedy",
                "content": "https://leetcode.com/problems/jump-game/\\n**55. Jump Game: `TC: / SC: O(n) / O(1)`**\\n```\\n    public boolean canJump(int[] nums) {\\n        int max_reach = 0;\\n        \\n        for(int i =0; i < nums.length; i++) {\\n            if(i > max_reach) return false;\\n            \\n            max_reach = Math.max(max_reach, i + nums[i]);\\n        }\\n        \\n        return true;\\n    }\\n```\\nhttps://leetcode.com/problems/jump-game-ii/\\n\\u2705**45. Jump Game II: `TC: / SC: O(n) / O(1)`**\\n```\\n    public int jump(int[] nums) {\\n        if(nums.length == 1) return 0;\\n        \\n        int temp = 0, max = 0, count = 0;\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            if(i > temp) {\\n                temp = max;\\n                max = 0;\\n                count++;\\n            }\\n            max = Math.max(max, nums[i] + i);\\n        }\\n        \\n        return count;\\n    }\\n```\\nhttps://leetcode.com/problems/jump-game-iii/\\n**1306. Jump Game III: `TC: / SC: O(n) / O(n)`**\\n```\\n    public static boolean[] jumped;\\n    public boolean canReach(int[] arr, int start) {\\n        jumped = new boolean[arr.length];\\n        \\n        return check(arr, start);\\n    }\\n    public boolean check(int[] arr, int i) {\\n        if(i >= arr.length || i < 0 || jumped[i]) return false;\\n        if(arr[i] == 0) return true;\\n        jumped[i] = true;\\n        \\n        return check(arr, i + arr[i]) || check(arr, i - arr[i]);\\n    }\\n```\\nhttps://leetcode.com/problems/jump-game-iv/\\n**1345. Jump Game IV: `TC: / SC: O(n) / O(n)`**\\n```\\n    public int minJumps(int[] arr) {\\n        int steps = 0;\\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\\n        \\n        for(int i = 0; i < arr.length; i++) \\n            map.computeIfAbsent(arr[i], li -> new ArrayList()).add(i);\\n        \\n        boolean[] jumped = new boolean[arr.length]; \\n        jumped[0] = true;\\n        Queue<Integer> q = new LinkedList<>(); \\n        q.offer(0);\\n        \\n        while(!q.isEmpty()) {\\n            for(int i = q.size(); i > 0; i--) {\\n                int temp = q.poll();\\n                if(temp == arr.length - 1) return steps;\\n                \\n                List<Integer> li = map.get(arr[temp]);\\n                if(temp != 0) li.add(temp - 1);\\n                if(temp != arr.length) li.add(temp + 1);\\n                \\n                for(int j : li) {\\n                    if(!jumped[j]) {\\n                        jumped[j] = true;\\n                        q.offer(j);\\n                    }\\n                }\\n                li.clear();\\n            }\\n            steps++;\\n        }\\n        \\n        return 0;\\n    }\\n```\\nhttps://leetcode.com/problems/jump-game-vi/submissions/\\n**1696. Jump Game VI: `TC: / SC: O(n) / O(n)`**\\n```\\n    public int maxResult(int[] nums, int k) {\\n        Deque<Integer> dq = new ArrayDeque<>();\\n        dq.offer(0);\\n        \\n        for(int i = 1; i < nums.length; i++) {\\n            nums[i] += nums[dq.peekFirst()];\\n            \\n            while(!dq.isEmpty() && nums[dq.peekLast()] <= nums[i])\\n                dq.pollLast();\\n            dq.offer(i);\\n            \\n            if(i - dq.peekFirst() >= k) dq.pollFirst();\\n        } \\n        \\n        return nums[nums.length - 1];\\n    }\\n```\\nhttps://leetcode.com/problems/jump-game-vii/submissions/\\n**1871. Jump Game VII: `TC: / SC: O(n) / O(n)`**\\n```\\n    public boolean canReach(String s, int minJump, int maxJump) {\\n        int n = s.length(), available = 0;\\n        if(s.charAt(n - 1) == \\'1\\') return false;\\n        \\n        boolean[] dp = new boolean[n];\\n        dp[0] = true;\\n        \\n        for(int i = 1; i < n; i++) {\\n            if(i >= minJump) available += dp[i - minJump] ? 1 : 0;\\n            if(i > maxJump) available -= dp[i - maxJump - 1] ? 1 : 0;\\n            \\n            dp[i] = available > 0 && s.charAt(i) == \\'0\\';\\n        }\\n        \\n        return dp[n - 1];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\n    public boolean canJump(int[] nums) {\\n        int max_reach = 0;\\n        \\n        for(int i =0; i < nums.length; i++) {\\n            if(i > max_reach) return false;\\n            \\n            max_reach = Math.max(max_reach, i + nums[i]);\\n        }\\n        \\n        return true;\\n    }\\n```\n```\\n    public int jump(int[] nums) {\\n        if(nums.length == 1) return 0;\\n        \\n        int temp = 0, max = 0, count = 0;\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            if(i > temp) {\\n                temp = max;\\n                max = 0;\\n                count++;\\n            }\\n            max = Math.max(max, nums[i] + i);\\n        }\\n        \\n        return count;\\n    }\\n```\n```\\n    public static boolean[] jumped;\\n    public boolean canReach(int[] arr, int start) {\\n        jumped = new boolean[arr.length];\\n        \\n        return check(arr, start);\\n    }\\n    public boolean check(int[] arr, int i) {\\n        if(i >= arr.length || i < 0 || jumped[i]) return false;\\n        if(arr[i] == 0) return true;\\n        jumped[i] = true;\\n        \\n        return check(arr, i + arr[i]) || check(arr, i - arr[i]);\\n    }\\n```\n```\\n    public int minJumps(int[] arr) {\\n        int steps = 0;\\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\\n        \\n        for(int i = 0; i < arr.length; i++) \\n            map.computeIfAbsent(arr[i], li -> new ArrayList()).add(i);\\n        \\n        boolean[] jumped = new boolean[arr.length]; \\n        jumped[0] = true;\\n        Queue<Integer> q = new LinkedList<>(); \\n        q.offer(0);\\n        \\n        while(!q.isEmpty()) {\\n            for(int i = q.size(); i > 0; i--) {\\n                int temp = q.poll();\\n                if(temp == arr.length - 1) return steps;\\n                \\n                List<Integer> li = map.get(arr[temp]);\\n                if(temp != 0) li.add(temp - 1);\\n                if(temp != arr.length) li.add(temp + 1);\\n                \\n                for(int j : li) {\\n                    if(!jumped[j]) {\\n                        jumped[j] = true;\\n                        q.offer(j);\\n                    }\\n                }\\n                li.clear();\\n            }\\n            steps++;\\n        }\\n        \\n        return 0;\\n    }\\n```\n```\\n    public int maxResult(int[] nums, int k) {\\n        Deque<Integer> dq = new ArrayDeque<>();\\n        dq.offer(0);\\n        \\n        for(int i = 1; i < nums.length; i++) {\\n            nums[i] += nums[dq.peekFirst()];\\n            \\n            while(!dq.isEmpty() && nums[dq.peekLast()] <= nums[i])\\n                dq.pollLast();\\n            dq.offer(i);\\n            \\n            if(i - dq.peekFirst() >= k) dq.pollFirst();\\n        } \\n        \\n        return nums[nums.length - 1];\\n    }\\n```\n```\\n    public boolean canReach(String s, int minJump, int maxJump) {\\n        int n = s.length(), available = 0;\\n        if(s.charAt(n - 1) == \\'1\\') return false;\\n        \\n        boolean[] dp = new boolean[n];\\n        dp[0] = true;\\n        \\n        for(int i = 1; i < n; i++) {\\n            if(i >= minJump) available += dp[i - minJump] ? 1 : 0;\\n            if(i > maxJump) available -= dp[i - maxJump - 1] ? 1 : 0;\\n            \\n            dp[i] = available > 0 && s.charAt(i) == \\'0\\';\\n        }\\n        \\n        return dp[n - 1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1752007,
                "title": "simple-intuitive-short-solution-o-n-c",
                "content": "```\\n    public int Jump(int[] nums) {\\n        int count = 0;        \\n        int max = 0;\\n        int cur = 0;\\n        for (int i=0; i<nums.Length-1; i++)\\n        {\\n            max = Math.Max(max, i+nums[i]);\\n            if (i == cur)\\n            {\\n                count++;\\n                cur = max;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int Jump(int[] nums) {\\n        int count = 0;        \\n        int max = 0;\\n        int cur = 0;\\n        for (int i=0; i<nums.Length-1; i++)\\n        {\\n            max = Math.Max(max, i+nums[i]);\\n            if (i == cur)\\n            {\\n                count++;\\n                cur = max;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1517689,
                "title": "concise-o-n-c-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n       if(nums.size()<2) return 0;   //base case\\n        \\n        //initialize jump=1 , we are taking jump from 0th index to the range mxjump\\n        //currjump =>we can take jump from particular  index\\n\\t\\t//mxjump => we cango up to maximum\\n\\t\\t// jump => to count no. of jump\\n        int jump=1,n=nums.size(),currjmp=nums[0],mxjmp=nums[0];\\n        \\n        int i=0;\\n\\t\\t\\n\\t\\t//till we reach last index, NOTE: Not necessary to cross last index\\n        while(i<n-1)\\n        {\\n            mxjmp=max(mxjmp,i+nums[i]);\\n             \\n            if(currjmp==i) //we have to take jump now because our currjump now ends.\\n            {\\n                jump++;//increment in jump\\n                currjmp=mxjmp; //assign new maxjmp to currjmp\\n            }\\n            i++;\\n        }\\n        if(currjmp<n-1)return -1; //we are not able to reach at the end of array because there may be some zeroes are present in given array so that we cannot move further\\n        return jump;\\n    }\\n    };\\n\\t\\n\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n       if(nums.size()<2) return 0;   //base case\\n        \\n        //initialize jump=1 , we are taking jump from 0th index to the range mxjump\\n        //currjump =>we can take jump from particular  index\\n\\t\\t//mxjump => we cango up to maximum\\n\\t\\t// jump => to count no. of jump\\n        int jump=1,n=nums.size(),currjmp=nums[0],mxjmp=nums[0];\\n        \\n        int i=0;\\n\\t\\t\\n\\t\\t//till we reach last index, NOTE: Not necessary to cross last index\\n        while(i<n-1)\\n        {\\n            mxjmp=max(mxjmp,i+nums[i]);\\n             \\n            if(currjmp==i) //we have to take jump now because our currjump now ends.\\n            {\\n                jump++;//increment in jump\\n                currjmp=mxjmp; //assign new maxjmp to currjmp\\n            }\\n            i++;\\n        }\\n        if(currjmp<n-1)return -1; //we are not able to reach at the end of array because there may be some zeroes are present in given array so that we cannot move further\\n        return jump;\\n    }\\n    };\\n\\t\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1352149,
                "title": "greedy-dp-solutions-c-explanation",
                "content": "### DP Solution : TC = O(N^2) SC = O(N)\\n```\\nclass Solution {\\npublic:\\n    \\n    int jump(vector<int>& nums) {\\n        int count = 0;\\n        int n = nums.size();\\n        vector<int> dp(n+1,INT_MAX);\\n        dp[0] = 0;\\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                if(j+nums[j] >= i){\\n                    dp[i] = min(dp[i],dp[j]+1);\\n                }\\n            }\\n        }\\n        // for(auto it: dp){\\n        //     cout<<it<<\" \";\\n        // }\\n        return dp[n-1];\\n    }\\n};\\n```\\n\\n### Greedy Solution : TC = O(N)   SC = O(1)\\ncurFarthest stores the farthest value till whch the jump can be made. curEnd stores the last value of upto which last jump was made.\\n``` \\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int count = 0;\\n        int n = nums.size();\\n        int curFarthest = 0;\\n        int curEnd = 0;\\n        for(int i=0; i<n-1; i++){\\n            curFarthest = max(i+nums[i],curFarthest);\\n            if(i==curEnd){\\n                count++;\\n                curEnd = curFarthest;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Greedy",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int jump(vector<int>& nums) {\\n        int count = 0;\\n        int n = nums.size();\\n        vector<int> dp(n+1,INT_MAX);\\n        dp[0] = 0;\\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                if(j+nums[j] >= i){\\n                    dp[i] = min(dp[i],dp[j]+1);\\n                }\\n            }\\n        }\\n        // for(auto it: dp){\\n        //     cout<<it<<\" \";\\n        // }\\n        return dp[n-1];\\n    }\\n};\\n```\n``` \\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int count = 0;\\n        int n = nums.size();\\n        int curFarthest = 0;\\n        int curEnd = 0;\\n        for(int i=0; i<n-1; i++){\\n            curFarthest = max(i+nums[i],curFarthest);\\n            if(i==curEnd){\\n                count++;\\n                curEnd = curFarthest;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1200738,
                "title": "3-approaches-explained-greedy-bfs-dp-o-n-solution",
                "content": "```\\n\\n/*\\n\\nHarshit Gupta | 11th May, 2021\\n---------------------------------\\n\\nC++ program for\\n\\nGiven an array of non-negative integers nums, you are initially positioned at the first index of the array.\\nEach element in the array represents your maximum jump length at that position.\\nYour goal is to reach the last index in the minimum number of jumps.\\n\\nYou can assume that you can always reach the last index.\\n\\nInput: nums = [2,3,1,1,4]\\nOutput: 2\\nExplanation: The minimum number of jumps to reach the last index is 2. \\n\\tJump 1 step from index 0 to 1, then 3 steps to the last index.\\n\\nhttps://leetcode.com/problems/jump-game-ii/\\n\\nSimilar Questions:\\n    1. https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/\\n    2. https://leetcode.com/problems/video-stitching/\\n\\n------\\n\\nSolution: This can be solved by BFS or DP\\n\\n    1. Greedy: Imagine that you are at index i in the array, the element in your current position \\n        defines the maximum distance that you can jump. Therefore, your next step will fall somewhere \\n        in the range [start, end], where start is the place right next to you and end is i + nums[i]. \\n        Then the question is, where to jump?\\n        Our next move will fall somewhere between [start : end] and to find the minimum number of jumps \\n        to reach the end of the array, we must determine which place will take us the farthest in the next jump.\\n        - We use a variable currEnd which tells us about the end of the current Jump\\n        - We use a variable currFarthest which tells us about the farthest jump I can make till now.\\n        - Iterate over the array & keep keep calculating the farthest jump you can make\\n            - Once you reach the currEnd, it means that this was all you can travel without any jumps\\n                but you know that you can take a jump and reach till the currFarthest point.\\n            - So if you reach the currEnd, you take that jump (so jump++) and now your currEnd will\\n                become your currentFarthest since you can travel till that point without any jumps\\n            - You keep calculating the new currentFarthest now and once reach the currEnd again\\n                you take another jump till the new currentFarthest and this goes on till you reach the end\\n        - We see that we take a greedy approach to always delay the jump and know the max we can reach without\\n            any jumps by using currentFarthest\\n\\n    Time Complexity: O(n)\\n    Space Complexity: O(1)  \\n\\n\\t2. BFS: Since we want to get to the last index in MINIMUM number fo steps, BFS comes to mind.\\n\\t\\t- Save the index and value in a queue and keep on inserting the pair<i, arr[i]> which are reachable.\\n\\t\\t- Check if it is the last index then return num of moves\\n\\t\\t- Have a visited[] array so that you do not traverse a node more than once.\\n\\n    Time Complexity: O(n)\\n    Space Complexity: O(n)\\n\\n\\t3. DP: Create a DP array and fill it with a large number (n+1 if n is the last index, we will save indexes so n+1 is a safe large index!)\\n\\t\\t- dp[i] will store the minimum number of steps to reach dp[i]\\n\\t\\t- dp[0] = 0 since you are already standing at 0 index.\\n\\t\\t- [GIVEN] For each index the arr[i] will tell you the maximum num of steps you can take\\n\\t\\t- Loop for \\'i\\' from 0 till n\\n\\t\\t\\t- Loop \\'j\\' from start = i till end = i+arr[i] (These are all jumpable from index i)\\n\\t\\t\\t- dp[j] = minimum of \\n\\t\\t\\t\\thowever you can reach j till now (dp[j]),\\n\\t\\t\\t\\thowever you can reach \\'start\\' + 1 step (dp[start] + 1)\\n\\n    Time Complexity: O(n2)\\n    Space Complexity: O(n)\\n---\\n  NOTE: \\n*/\\n\\n// ------------------\\n// Approach 1: Greedy\\n// ------------------\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size(), currEnd=0, currFarthest=0, jumps=0;\\n        for(int i=0; i<n-1;i++) {\\n            currFarthest = max(currFarthest, i+nums[i]);\\n            if (i == currEnd){\\n                jumps++;\\n                currEnd = currFarthest;\\n                if(currEnd >= n-1)\\n                    break;\\n            }\\n        }\\n        return jumps;\\n    }\\n};\\n\\n// ------------------------\\n// Approach 2: BFS SOLUTION\\n// ------------------------\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n==1)\\n            return 0;\\n        int jump = 0;\\n        \\n        queue<pair<int,int>> q;\\n        vector<int>visited(n, 0);\\n        q.push(make_pair(0,nums[0]));\\n        visited[0] =1;\\n\\n        while(!q.empty()){\\n            int size=q.size();\\n\\n            for(int i=0;i<size;i++){\\n                pair<int, int> f = q.front();\\n                q.pop();\\n                for(int i=f.first+1;i<=f.first+f.second; i++){\\n                    if(i==n-1)\\n                        return jump+1;\\n                    if (visited[i] == 0){\\n                        q.push(make_pair(i, nums[i]));\\n                        visited[i] = 1;\\n                    }\\n                }\\n            }\\n            jump++;\\n        }\\n        return jump;\\n    }\\n};\\n\\n\\n\\n\\n// ------------------------\\n// Approach 3: DP SOLUTION\\n// ------------------------\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n==1)\\n            return 0;\\n        int jump = 0;\\n\\n        int len = nums.size();\\n        int dp[len];\\n        dp[0] = 0;\\n\\n        // Initialize it to len+1\\n        for (int i = 1; i < len; i++) {\\n            dp[i] =len+1;\\n        }\\n        \\n        for (int i = 0; i < len; i++) {\\n            int start = i;\\n            int end = min(i + nums[i], len - 1);\\n            \\n            for (int j = start; j <= end; j++) {\\n                dp[j] = min(dp[j], dp[start] + 1);\\n            }\\n        }\\n\\n        return dp[len - 1] == len + 1 ? -1 : dp[len - 1];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\n\\n/*\\n\\nHarshit Gupta | 11th May, 2021\\n---------------------------------\\n\\nC++ program for\\n\\nGiven an array of non-negative integers nums, you are initially positioned at the first index of the array.\\nEach element in the array represents your maximum jump length at that position.\\nYour goal is to reach the last index in the minimum number of jumps.\\n\\nYou can assume that you can always reach the last index.\\n\\nInput: nums = [2,3,1,1,4]\\nOutput: 2\\nExplanation: The minimum number of jumps to reach the last index is 2. \\n\\tJump 1 step from index 0 to 1, then 3 steps to the last index.\\n\\nhttps://leetcode.com/problems/jump-game-ii/\\n\\nSimilar Questions:\\n    1. https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/\\n    2. https://leetcode.com/problems/video-stitching/\\n\\n------\\n\\nSolution: This can be solved by BFS or DP\\n\\n    1. Greedy: Imagine that you are at index i in the array, the element in your current position \\n        defines the maximum distance that you can jump. Therefore, your next step will fall somewhere \\n        in the range [start, end], where start is the place right next to you and end is i + nums[i]. \\n        Then the question is, where to jump?\\n        Our next move will fall somewhere between [start : end] and to find the minimum number of jumps \\n        to reach the end of the array, we must determine which place will take us the farthest in the next jump.\\n        - We use a variable currEnd which tells us about the end of the current Jump\\n        - We use a variable currFarthest which tells us about the farthest jump I can make till now.\\n        - Iterate over the array & keep keep calculating the farthest jump you can make\\n            - Once you reach the currEnd, it means that this was all you can travel without any jumps\\n                but you know that you can take a jump and reach till the currFarthest point.\\n            - So if you reach the currEnd, you take that jump (so jump++) and now your currEnd will\\n                become your currentFarthest since you can travel till that point without any jumps\\n            - You keep calculating the new currentFarthest now and once reach the currEnd again\\n                you take another jump till the new currentFarthest and this goes on till you reach the end\\n        - We see that we take a greedy approach to always delay the jump and know the max we can reach without\\n            any jumps by using currentFarthest\\n\\n    Time Complexity: O(n)\\n    Space Complexity: O(1)  \\n\\n\\t2. BFS: Since we want to get to the last index in MINIMUM number fo steps, BFS comes to mind.\\n\\t\\t- Save the index and value in a queue and keep on inserting the pair<i, arr[i]> which are reachable.\\n\\t\\t- Check if it is the last index then return num of moves\\n\\t\\t- Have a visited[] array so that you do not traverse a node more than once.\\n\\n    Time Complexity: O(n)\\n    Space Complexity: O(n)\\n\\n\\t3. DP: Create a DP array and fill it with a large number (n+1 if n is the last index, we will save indexes so n+1 is a safe large index!)\\n\\t\\t- dp[i] will store the minimum number of steps to reach dp[i]\\n\\t\\t- dp[0] = 0 since you are already standing at 0 index.\\n\\t\\t- [GIVEN] For each index the arr[i] will tell you the maximum num of steps you can take\\n\\t\\t- Loop for \\'i\\' from 0 till n\\n\\t\\t\\t- Loop \\'j\\' from start = i till end = i+arr[i] (These are all jumpable from index i)\\n\\t\\t\\t- dp[j] = minimum of \\n\\t\\t\\t\\thowever you can reach j till now (dp[j]),\\n\\t\\t\\t\\thowever you can reach \\'start\\' + 1 step (dp[start] + 1)\\n\\n    Time Complexity: O(n2)\\n    Space Complexity: O(n)\\n---\\n  NOTE: \\n*/\\n\\n// ------------------\\n// Approach 1: Greedy\\n// ------------------\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size(), currEnd=0, currFarthest=0, jumps=0;\\n        for(int i=0; i<n-1;i++) {\\n            currFarthest = max(currFarthest, i+nums[i]);\\n            if (i == currEnd){\\n                jumps++;\\n                currEnd = currFarthest;\\n                if(currEnd >= n-1)\\n                    break;\\n            }\\n        }\\n        return jumps;\\n    }\\n};\\n\\n// ------------------------\\n// Approach 2: BFS SOLUTION\\n// ------------------------\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n==1)\\n            return 0;\\n        int jump = 0;\\n        \\n        queue<pair<int,int>> q;\\n        vector<int>visited(n, 0);\\n        q.push(make_pair(0,nums[0]));\\n        visited[0] =1;\\n\\n        while(!q.empty()){\\n            int size=q.size();\\n\\n            for(int i=0;i<size;i++){\\n                pair<int, int> f = q.front();\\n                q.pop();\\n                for(int i=f.first+1;i<=f.first+f.second; i++){\\n                    if(i==n-1)\\n                        return jump+1;\\n                    if (visited[i] == 0){\\n                        q.push(make_pair(i, nums[i]));\\n                        visited[i] = 1;\\n                    }\\n                }\\n            }\\n            jump++;\\n        }\\n        return jump;\\n    }\\n};\\n\\n\\n\\n\\n// ------------------------\\n// Approach 3: DP SOLUTION\\n// ------------------------\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n==1)\\n            return 0;\\n        int jump = 0;\\n\\n        int len = nums.size();\\n        int dp[len];\\n        dp[0] = 0;\\n\\n        // Initialize it to len+1\\n        for (int i = 1; i < len; i++) {\\n            dp[i] =len+1;\\n        }\\n        \\n        for (int i = 0; i < len; i++) {\\n            int start = i;\\n            int end = min(i + nums[i], len - 1);\\n            \\n            for (int j = start; j <= end; j++) {\\n                dp[j] = min(dp[j], dp[start] + 1);\\n            }\\n        }\\n\\n        return dp[len - 1] == len + 1 ? -1 : dp[len - 1];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1193120,
                "title": "python3-solution-24-ms-faster-than-97",
                "content": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        curr_pos=0\\n        distance=0\\n        jumps=0\\n        for i in range(len(nums)-1):\\n            distance=max(distance,i+nums[i])\\n            if curr_pos==i:\\n                jumps+=1\\n                curr_pos=distance\\n        return(jumps)        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        curr_pos=0\\n        distance=0\\n        jumps=0\\n        for i in range(len(nums)-1):\\n            distance=max(distance,i+nums[i])\\n            if curr_pos==i:\\n                jumps+=1\\n                curr_pos=distance\\n        return(jumps)        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1192505,
                "title": "java-easiest-clear-7-lines-solution-0-ms-faster-than-100-00",
                "content": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int count = 0, end = 0, maxFar = nums[0];\\n        for ( int index = 0; index + 1 < nums.length; ++index ) {\\n            maxFar = Math.max(index + nums[index], maxFar);\\n            if ( index == end ) {\\n                ++count;\\n                end = maxFar;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int jump(int[] nums) {\\n        int count = 0, end = 0, maxFar = nums[0];\\n        for ( int index = 0; index + 1 < nums.length; ++index ) {\\n            maxFar = Math.max(index + nums[index], maxFar);\\n            if ( index == end ) {\\n                ++count;\\n                end = maxFar;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 996519,
                "title": "c-dp-with-full-explanation-and-comments-o-n-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n      \\n        int largestLadderLen = nums[0]; // signifies where max u can reach using this ladder ...\\n        int stepsLeftOnLadder = nums[0]; // main thing ... explained more below\\n        \\n        int jumps = 1; // already jumped on first ladder\\n\\t\\t// why ? coz - if there are more than 1 element in array u will atleast make 1 jump ....\\n\\t\\t// handle one element case separately below\\n        \\n        if(nums.size()==1)\\n            return 0;\\n        \\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(i==nums.size()-1)\\n                return jumps;\\n            \\n            stepsLeftOnLadder--; // took a step to reach here ...\\n            \\n            int newLadder = i+nums[i];\\n            \\n            if(newLadder > largestLadderLen)\\n                largestLadderLen = newLadder;\\n\\n\\t\\t\\t\\t//once u find a bigger ladder u just store it n dont start using it rightaway .. \\n\\t\\t\\t\\t//use it only when u find prev ladder is exhausted .. \\n\\t\\t\\t\\t//now because u had found a \"biggr\" ladder that means that bigger ladder would\\n\\t\\t\\t\\t//give u atleast one step extra ...use the bigger ladder to move fwd ... \\n            \\n            if(stepsLeftOnLadder==0){\\n\\t\\t\\t   //prev ladder is exhausted\\n                jumps++; // jump on to a new ladder\\n\\t\\t\\t\\t\\n                 // steps left on new ladder\\n\\t\\t\\t\\t \\n                stepsLeftOnLadder =  largestLadderLen-i; \\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// u might have already used some steps on last ladder\\n\\t\\t\\t\\t// now bigger ladder wont be used from start from where it ws originated ..\\n\\t\\t\\t\\t//it would be used from where current is exhauseted .. or in other words .. \\n\\t\\t\\t\\t//on what step u are  .. use from that step ...\\n                \\n            }\\n           \\n                    \\n        }\\n        \\n        return jumps;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n      \\n        int largestLadderLen = nums[0]; // signifies where max u can reach using this ladder ...\\n        int stepsLeftOnLadder = nums[0]; // main thing ... explained more below\\n        \\n        int jumps = 1; // already jumped on first ladder\\n\\t\\t// why ? coz - if there are more than 1 element in array u will atleast make 1 jump ....\\n\\t\\t// handle one element case separately below\\n        \\n        if(nums.size()==1)\\n            return 0;\\n        \\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(i==nums.size()-1)\\n                return jumps;\\n            \\n            stepsLeftOnLadder--; // took a step to reach here ...\\n            \\n            int newLadder = i+nums[i];\\n            \\n            if(newLadder > largestLadderLen)\\n                largestLadderLen = newLadder;\\n\\n\\t\\t\\t\\t//once u find a bigger ladder u just store it n dont start using it rightaway .. \\n\\t\\t\\t\\t//use it only when u find prev ladder is exhausted .. \\n\\t\\t\\t\\t//now because u had found a \"biggr\" ladder that means that bigger ladder would\\n\\t\\t\\t\\t//give u atleast one step extra ...use the bigger ladder to move fwd ... \\n            \\n            if(stepsLeftOnLadder==0){\\n\\t\\t\\t   //prev ladder is exhausted\\n                jumps++; // jump on to a new ladder\\n\\t\\t\\t\\t\\n                 // steps left on new ladder\\n\\t\\t\\t\\t \\n                stepsLeftOnLadder =  largestLadderLen-i; \\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// u might have already used some steps on last ladder\\n\\t\\t\\t\\t// now bigger ladder wont be used from start from where it ws originated ..\\n\\t\\t\\t\\t//it would be used from where current is exhauseted .. or in other words .. \\n\\t\\t\\t\\t//on what step u are  .. use from that step ...\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 541548,
                "title": "dp-and-greedy",
                "content": "Derived from [https://leetcode.com/problems/jump-game/discuss/541554/DP-and-Greedy](https://leetcode.com/problems/jump-game/discuss/541554/DP-and-Greedy).\\n### DP\\nDefine **state(i)** as the minimum jumps to reach i\\n**state(i) = min(1 + state(j))** for each j that can jump to i.\\nThe goal state is **state(nums.length - 1)**.\\n```\\n    public int jump(int[] nums) {\\n        int[] state = new int[nums.length];\\n        Arrays.fill(state, Integer.MAX_VALUE);\\n        state[0] = 0;\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[j] + j >= i) { // j can jump to i\\n                    state[i] = Math.min(state[i], state[j] + 1);\\n                }\\n            }\\n        }\\n        \\n        return state[nums.length - 1];\\n    }\\n```\\n### Greedy\\nJump when we have to jump, and jump to the furthest position.\\n```\\n    public int jump(int[] nums) {\\n        if (nums.length < 2) {\\n            return 0;\\n        }\\n        int toJump = 0, numJumps = 0;\\n        \\n        // Build maxReach array\\n        int[] maxReach = new int[nums.length];\\n        maxReach[0] = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            // Assuming we can jump to nums[i], we can reach up to maxReach[i]\\n            maxReach[i] = Math.max(maxReach[i - 1], nums[i] + i);\\n        }\\n        \\n        // Jump when we have to and count the jumps\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i == toJump) {\\n                numJumps++;\\n                if (maxReach[i] >= nums.length - 1) {\\n                    break;\\n                }\\n                toJump = maxReach[i]; // Greedy\\n            }\\n        }\\n        \\n        return numJumps;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int jump(int[] nums) {\\n        int[] state = new int[nums.length];\\n        Arrays.fill(state, Integer.MAX_VALUE);\\n        state[0] = 0;\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[j] + j >= i) { // j can jump to i\\n                    state[i] = Math.min(state[i], state[j] + 1);\\n                }\\n            }\\n        }\\n        \\n        return state[nums.length - 1];\\n    }\\n```\n```\\n    public int jump(int[] nums) {\\n        if (nums.length < 2) {\\n            return 0;\\n        }\\n        int toJump = 0, numJumps = 0;\\n        \\n        // Build maxReach array\\n        int[] maxReach = new int[nums.length];\\n        maxReach[0] = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            // Assuming we can jump to nums[i], we can reach up to maxReach[i]\\n            maxReach[i] = Math.max(maxReach[i - 1], nums[i] + i);\\n        }\\n        \\n        // Jump when we have to and count the jumps\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i == toJump) {\\n                numJumps++;\\n                if (maxReach[i] >= nums.length - 1) {\\n                    break;\\n                }\\n                toJump = maxReach[i]; // Greedy\\n            }\\n        }\\n        \\n        return numJumps;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 515463,
                "title": "java-100-time",
                "content": "```\\npublic int jump(int[] nums) {\\n        int res = 0, prev = 0, cur = 0;\\n        for (int i=0; i<nums.length-1;++i) {\\n            cur = Math.max(i+nums[i], cur);\\n            if (i==prev) {\\n                ++res;\\n                prev = cur;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int jump(int[] nums) {\\n        int res = 0, prev = 0, cur = 0;\\n        for (int i=0; i<nums.length-1;++i) {\\n            cur = Math.max(i+nums[i], cur);\\n            if (i==prev) {\\n                ++res;\\n                prev = cur;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 18055,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Jump Game II** https://leetcode.com/problems/jump-game-ii/\\n\\n**Dynamic Programming With Memoization**\\n* Sketch the recursion tree and implement the simple solution\\n* Base case: i == N-1, return 0. i > N-1, return float('inf')\\n* Recurse through all possible jumps from index i and find the minimum\\n* Use a cache to memoize\\n* This solution gives you a run time error: maximum recursion depth exceeded while calling a Py object!\\n* Time Complexity: O(N^2). Also Space complexity: O(N).\\n\\n```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def helper(self, i, nums, cache):\\n        if i == len(nums)-1:\\n            return 0\\n        elif i > len(nums)-1:\\n            return float('inf')\\n        elif i in cache:\\n            return cache[i]\\n        else:\\n            cache[i] = float('inf')\\n            for j in range(1, nums[i]+1):\\n                cache[i] = min(cache[i], self.helper(i+j, nums, cache)+1)\\n            return cache[i]\\n    \\n    def jump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        cache = defaultdict(int)\\n        return self.helper(0, nums, cache)\\n```\\n\\n**Dynamic Programming With Cache**\\n* What is minimum cost to reach index i? Minimum cost to reach index 0 is 0. \\n* For indexi, lets find all indices j less than i. Now we can take a jump from index j if and only if (i-j)<=nums[j].\\n* Time Complexity: O(N^2). Also Space complexity: O(N).\\n* This solution gives a TLE\\n\\n```\\nclass Solution(object):\\n    def jump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        cache = [float('inf')]*len(nums)\\n        cache[0] = 0\\n        for i in range(1, len(nums)):\\n            for j in range(i):\\n                if i - j <= nums[j]: # Can I take a jump from position j and reach i?\\n                    cache[i] = min(cache[i], cache[j] + 1)\\n        return cache[-1]\\n```\\n\\n**BFS Solution to Find the Minimum Jump**\\n* Model it like graph search problem and apply BFS to solve it\\n* Even this method gives TLE since it is N^2 solution.\\n\\n```\\nclass Solution(object):\\n    def jump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        q, levels = [0], -1\\n        while len(q):\\n            levels, new_level= levels + 1, []\\n            for x in q:\\n                for j in range(1, nums[x]+1):\\n                    if x + j == len(nums)-1:\\n                        return levels + 1\\n                    elif x + j < len(nums)-1:\\n                        new_level.append(x+j)\\n                    else:\\n                        break\\n            q = new_level\\n        return levels\\n```\\n\\n\\n**Greedy Approach which uses \"Ladder Idea from Ideserve\"**\\n* https://www.youtube.com/playlist?list=PLamzFoFxwoNgG0Q5rqfTY6ovWSTAC9mbz\\n* The invariant is that at a start index, we already know the maximum jump index that can be reached.\\n* We therefore move from index start to current_max_index and test whether we can reach further than current_max_index. Infact, we try to be greedy - we want to pick the next start point which would make us reach the farthest from current_max_index.\\n* Once we update the next start point, we recognize that we took a single jump.\\n* Take special note of initial conditions: current_max_index, start, jumps = 0, 0, 0. This initialization helps us to tackle cases likes nums =[1]. Other when length of nums is more than 1, the first jump takes us to start index 0 and sets current_max_index to nums[0].\\n\\n```\\nclass Solution(object):\\n    def jump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        current_max_index, start, jumps = 0, 0, 0\\n        while start < len(nums):\\n            if current_max_index >= len(nums)-1:\\n                return jumps            \\n            for i in range(start, current_max_index+1):\\n                if nums[i] + i > current_max_index:\\n                    start, current_max_index = i, nums[i]+i\\n            jumps += 1\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def helper(self, i, nums, cache):\\n        if i == len(nums)-1:\\n            return 0\\n        elif i > len(nums)-1:\\n            return float('inf')\\n        elif i in cache:\\n            return cache[i]\\n        else:\\n            cache[i] = float('inf')\\n            for j in range(1, nums[i]+1):\\n                cache[i] = min(cache[i], self.helper(i+j, nums, cache)+1)\\n            return cache[i]\\n    \\n    def jump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        cache = defaultdict(int)\\n        return self.helper(0, nums, cache)\\n```\n```\\nclass Solution(object):\\n    def jump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        cache = [float('inf')]*len(nums)\\n        cache[0] = 0\\n        for i in range(1, len(nums)):\\n            for j in range(i):\\n                if i - j <= nums[j]: # Can I take a jump from position j and reach i?\\n                    cache[i] = min(cache[i], cache[j] + 1)\\n        return cache[-1]\\n```\n```\\nclass Solution(object):\\n    def jump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        q, levels = [0], -1\\n        while len(q):\\n            levels, new_level= levels + 1, []\\n            for x in q:\\n                for j in range(1, nums[x]+1):\\n                    if x + j == len(nums)-1:\\n                        return levels + 1\\n                    elif x + j < len(nums)-1:\\n                        new_level.append(x+j)\\n                    else:\\n                        break\\n            q = new_level\\n        return levels\\n```\n```\\nclass Solution(object):\\n    def jump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        current_max_index, start, jumps = 0, 0, 0\\n        while start < len(nums):\\n            if current_max_index >= len(nums)-1:\\n                return jumps            \\n            for i in range(start, current_max_index+1):\\n                if nums[i] + i > current_max_index:\\n                    start, current_max_index = i, nums[i]+i\\n            jumps += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18060,
                "title": "share-my-greedy-solution-and-proof-for-greedy-choice-property",
                "content": "I first come up with a dp solution but after some analysis, I figured out it can be reduced to a greedy problem. My idea is borrowed from one of the great top solutions (https://discuss.leetcode.com/topic/28470/concise-o-n-one-loop-java-solution-based-on-greedy) \\n\\nHowever, it seems no one gave a formal proof that it can be solved by greedy strategy. Here is my proof:\\n\\n**Greedy choice property**\\nFor position ```t```, there exists an optimal solution in which the minimum steps is obtained by jumping from position ```i```, where ```i + nums[i] == t```.\\n\\nProof by contradiction:\\n```1)```Suppose there exist a position ```j```, ```i < j```, and ```j + nums[j] >= t```, such that the minimum steps of jumping from ```j``` to ```t``` will lower than that of jumping from ```i``` to ```t```.\\n```2)``` Let ```minSteps(k)``` denotes minimum steps at position ```k```;\\n```3)``` Such that we have ``` i < j < t``` and ``` minSteps(i) > minSteps(j)``` obtained from step ```1)```\\n```4)``` Because ``` t - i > t - j ```, it implies that ```nums[i] > nums[j]```. Therefore, ```minSteps(i) <= minSteps(j)```, which contradicts the supposition that ``` minSteps(i) > minSteps(j)```\\n\\n\\n\\n```\\npublic class Solution {\\n    public int jump(int[] nums) {\\n        if(nums.length <= 1) return 0;\\n        int minSteps = 0;\\n        int upperBound = 0;\\n        int reachable = 0;\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            reachable = Math.max(i + nums[i], reachable);\\n            if(i > upperBound){\\n                minSteps++;\\n                upperBound = reachable;\\n                if(upperBound >= nums.length - 1)\\n                    return minSteps;\\n            }\\n        }\\n        return minSteps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```t```\n```i```\n```i + nums[i] == t```\n```1)```\n```j```\n```i < j```\n```j + nums[j] >= t```\n```j```\n```t```\n```i```\n```t```\n```2)```\n```minSteps(k)```\n```k```\n```3)```\n``` i < j < t```\n``` minSteps(i) > minSteps(j)```\n```1)```\n```4)```\n``` t - i > t - j ```\n```nums[i] > nums[j]```\n```minSteps(i) <= minSteps(j)```\n``` minSteps(i) > minSteps(j)```\n```\\npublic class Solution {\\n    public int jump(int[] nums) {\\n        if(nums.length <= 1) return 0;\\n        int minSteps = 0;\\n        int upperBound = 0;\\n        int reachable = 0;\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            reachable = Math.max(i + nums[i], reachable);\\n            if(i > upperBound){\\n                minSteps++;\\n                upperBound = reachable;\\n                if(upperBound >= nums.length - 1)\\n                    return minSteps;\\n            }\\n        }\\n        return minSteps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18109,
                "title": "my-very-simple-c-solution",
                "content": "    class Solution {\\n    public:\\n        int jump(vector<int>& nums) {\\n            int steps = 0, s1 = 0, s2 = 0;// take steps can reach s1, take steps+1 can reach s2\\n            for (int i = 0; i < nums.size(); ++i) {\\n                if (s1 >= nums.size()-1) return steps;\\n                s2 = max(nums[i]+i,s2);\\n                if (i >= s1) {//steps is not enough, update s1 to s2 and increase steps\\n                    s1 = s2;\\n                    steps++;\\n                }\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "class Solution {\\n    public:\\n        int jump(vector<int>& nums) {\\n            int steps = 0, s1 = 0, s2 = 0;// take steps can reach s1, take steps+1 can reach s2\\n            for (int i = 0; i < nums.size(); ++i) {\\n                if (s1 >= nums.size()-1) return steps;\\n                s2 = max(nums[i]+i,s2);\\n                if (i >= s1) {//steps is not enough, update s1 to s2 and increase steps\\n                    s1 = s2;\\n                    steps++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 18160,
                "title": "concise-c-solution-bfs-16ms-20-lines",
                "content": "    class Solution {\\n    public:\\n        int jump(vector<int>& nums) {\\n            int level = 0;\\n            int cur_begin = 0;\\n            int cur_end = 0;\\n            int next_end = 0;\\n            while (cur_end < nums.size() - 1) {\\n                // search [cur_begin, cur_end]\\n                for (int index = cur_begin; index <= cur_end; ++index) {\\n                    next_end = max(next_end, index + nums[index]);\\n                }\\n                // move to next level.\\n                ++level;\\n                cur_begin = cur_end + 1;\\n                cur_end = next_end;\\n            }\\n            return level;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    public:\\n        int jump(vector<int>& nums) {\\n            int level = 0;\\n            int cur_begin = 0;\\n            int cur_end = 0;\\n            int next_end = 0;\\n            while (cur_end < nums.size() - 1) {\\n                // search [cur_begin, cur_end]\\n                for (int index = cur_begin; index <= cur_end; ++index) {\\n                    next_end = max(next_end, index + nums[index]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3834147,
                "title": "python-beats-99-99-easy-solution",
                "content": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n\\n        x = [nums[i]+i for i in range(len(nums))]  \\n        # each element in this represent max index that can be reached from the current index \\n\\n        l,r,jumps = 0,0,0\\n\\n        while r < len(nums)-1 :\\n            jumps += 1\\n            l,r = r+1,max(x[l:r+1]) \\n\\n        return jumps\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n\\n        x = [nums[i]+i for i in range(len(nums))]  \\n        # each element in this represent max index that can be reached from the current index \\n\\n        l,r,jumps = 0,0,0\\n\\n        while r < len(nums)-1 :\\n            jumps += 1\\n            l,r = r+1,max(x[l:r+1]) \\n\\n        return jumps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653821,
                "title": "python-dp-memo-solution",
                "content": "# Approach\\nCreate an array containing minimum steps you need to take to get to the i-th position.\\nWe can simply go through all elements of the array and then iterate over all possible jump lengths updating information in our array.\\nWe can either jump from our current position, or some other position that we considered earlier. Take the minimum of these two and you will get an answer.\\n\\n# Complexity\\n- Time complexity: $$O(nk)$$, where k is a sum of all jumps (sum of nums array)\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        dp=[float(\\'inf\\') for _ in range(n)]\\n        dp[0]=0\\n        for i in range(n):\\n            for j in range(1,nums[i]+1):\\n                if i+j<n:\\n                    dp[i+j]=min(dp[i+j],dp[i]+1)\\n        return dp[n-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        dp=[float(\\'inf\\') for _ in range(n)]\\n        dp[0]=0\\n        for i in range(n):\\n            for j in range(1,nums[i]+1):\\n                if i+j<n:\\n                    dp[i+j]=min(dp[i+j],dp[i]+1)\\n        return dp[n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166620,
                "title": "python-3-7-lines-greedy-w-example-t-m-91-90",
                "content": "Here\\'s the plan: \\n- We iterate through`nums`(with the exception of`nums[-1]` because at that point we have reached the target)\\n- We use`mx`to determine the most efficient jump on each iteration.\\n- We increment`ans`for each iteration\\n- We return`ans` once done with this iteration. \\n\\n```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n                                            #          0 1 2 3 4\\n        ans, mx, end = 0, 0, 0              #  nums = [2,3,0,1,4]  \\n        \\n        for i, num in enumerate(nums[:-1]): #  i    num   mx    end   ans\\n                                            # \\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\n            mx = max(mx, i + num)           #  0     2     2     2     1\\n                                            #  1     3     4     2     1\\n            if i == end:                    #  2     0     4     4     2     \\n                ans += 1                    #  3     1     4     4     2                \\n                end = mx \\n\\n        return ans \\n```\\n[](http://)\\n\\nPython 3   ||   7 lines, greedy,  w/ example   ||   T/M: 91% / 90%\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n                                            #          0 1 2 3 4\\n        ans, mx, end = 0, 0, 0              #  nums = [2,3,0,1,4]  \\n        \\n        for i, num in enumerate(nums[:-1]): #  i    num   mx    end   ans\\n                                            # \\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\n            mx = max(mx, i + num)           #  0     2     2     2     1\\n                                            #  1     3     4     2     1\\n            if i == end:                    #  2     0     4     4     2     \\n                ans += 1                    #  3     1     4     4     2                \\n                end = mx \\n\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3161559,
                "title": "greedy-approach-0-n-time-and-0-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGreddy Approach\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n0(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int currreach =0;\\n        int jumps = 0;\\n        int maxreach = 0;\\n        int max = 0;\\n        for(int i = 0; i < nums.length - 1; i++)\\n        {\\n            if(i + nums[i] > maxreach)\\n                maxreach = i + nums[i];\\n            if(i == currreach)\\n            {\\n                jumps++;\\n                currreach = maxreach;\\n            }\\n        }\\n        return jumps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int currreach =0;\\n        int jumps = 0;\\n        int maxreach = 0;\\n        int max = 0;\\n        for(int i = 0; i < nums.length - 1; i++)\\n        {\\n            if(i + nums[i] > maxreach)\\n                maxreach = i + nums[i];\\n            if(i == currreach)\\n            {\\n                jumps++;\\n                currreach = maxreach;\\n            }\\n        }\\n        return jumps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158465,
                "title": "c-easy-greedy-approach-5-liner-code-faster-than-85-of-solution",
                "content": "# Code\\n# **PLEASE DO UPVOTE !**\\n**CONNECT WITH ME ON LINKEDIN : https://www.linkedin.com/in/kunal-shaw-/**\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size(),i=0,ans=0;\\n        for(int i=1;i<n;i++)nums[i]=max(nums[i]+i,nums[i-1]);\\n        while(i<n-1){\\n            ans++;\\n            i=nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![memer-cat.jpg](https://assets.leetcode.com/users/images/dfc2018d-01d8-43da-9889-af2896179f15_1675779280.3429081.jpeg)",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size(),i=0,ans=0;\\n        for(int i=1;i<n;i++)nums[i]=max(nums[i]+i,nums[i-1]);\\n        while(i<n-1){\\n            ans++;\\n            i=nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158364,
                "title": "c-solution-faster-than-96-45",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBASIC APPROACH & EASY TO UNDERSTAND\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int count=0;\\n        if(nums.size()==1 &&nums[0]==1)\\n        return 0;\\n\\n        \\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i-1],nums[i] + i);\\n      }\\n\\n      \\n      for(int j=0;j<nums.size()-1;j=nums[j])\\n      {\\n          count++;\\n      }\\n\\n      return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int count=0;\\n        if(nums.size()==1 &&nums[0]==1)\\n        return 0;\\n\\n        \\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i-1],nums[i] + i);\\n      }\\n\\n      \\n      for(int j=0;j<nums.size()-1;j=nums[j])\\n      {\\n          count++;\\n      }\\n\\n      return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158003,
                "title": "daily-leetcoding-challenge-february-day-8",
                "content": "This problem is the Daily LeetCoding Challenge for February, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3095921,
                "title": "99-45-javascript-fast-very-very-easy-to-understand-with-video-explanation-en-kr",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\nEnglish video!\\n\\nhttps://youtu.be/wmjGaq7baTM\\n\\nKorean video!\\n\\nhttps://youtu.be/6LdZUdBZGv4\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar jump = function(nums) {\\n    let left = 0;\\n    let right = 0;\\n    let res = 0;\\n\\n    while(right<nums.length-1){\\n        let max = 0;\\n\\n        for(let i = left; i<=right;i++){\\n            max = Math.max(nums[i]+i,max)\\n        }\\n        left = right+1;\\n        right = max;\\n\\n        res++\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar jump = function(nums) {\\n    let left = 0;\\n    let right = 0;\\n    let res = 0;\\n\\n    while(right<nums.length-1){\\n        let max = 0;\\n\\n        for(let i = left; i<=right;i++){\\n            max = Math.max(nums[i]+i,max)\\n        }\\n        left = right+1;\\n        right = max;\\n\\n        res++\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2637851,
                "title": "java-complete-solution",
                "content": "Pre-requisite : https://leetcode.com/problems/jump-game/\\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        if(nums.length == 1){\\n            return 0;\\n        }\\n        int max = 0;\\n        int curr = 0;\\n        int count = 0;\\n        for(int i = 0 ; i < nums.length - 1 ; i++){\\n            max = Math.max(max , i + nums[i]);\\n            \\n            if(curr == i){\\n                curr = max;\\n                count++;\\n            }\\n            if(curr>nums.length-1){\\n                return count;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        if(nums.length == 1){\\n            return 0;\\n        }\\n        int max = 0;\\n        int curr = 0;\\n        int count = 0;\\n        for(int i = 0 ; i < nums.length - 1 ; i++){\\n            max = Math.max(max , i + nums[i]);\\n            \\n            if(curr == i){\\n                curr = max;\\n                count++;\\n            }\\n            if(curr>nums.length-1){\\n                return count;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2580276,
                "title": "c-3-solutions-recursive-memoised-tabulation-code",
                "content": "**If it helps, please UPVOTE : )**\\n\\n**RECURSIVE code:**\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int solve(int i, vector<int> &nums)\\n    {\\n        if(i == n-1)  //if reached last index then no need to move further so no steps required\\n            return 0;\\n       \\n        int mini = INT_MAX-1;                       //-1 bc in loop 1 + solve(), if solve() returns INT_MAX, 1+INT_MAX will result stack overflow\\n        for(int j=1; j<=min(n-1 - i, nums[i]); j++) //possible steps we can take from i\\n        {\\n            int temp = 1 + solve(i+j, nums); //at i take 1 step of length j, so we reach i+j\\n            mini = min(mini, temp);          //we take minimum of all steps from i to reach n-1\\n        }\\n        \\n        return mini;  //if not reached n-1, then it will not go in loop and return mini = INT_MAX-1 at some step where further going forward is not possible, back trackingto previous call temp = 1 + INT_MAX-1, mini = min(mini, INT_MAX), so we see for current j it will get INT_MAX as temp ans, while taking minimum it won\\'t affect the answer\\n    }\\n    \\n    int jump(vector<int>& nums) \\n    {\\n        n = nums.size();\\n        \\n        return solve(0, nums, dp);\\n    }\\n};\\n```\\n\\n**MEMOISED code:**\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int solve(int i, vector<int> &nums, vector<int> &dp)\\n    {\\n        if(i == n-1)\\n            return 0;\\n        \\n        if(dp[i] != -1)\\n            return dp[i];\\n        \\n        int mini = INT_MAX-1;\\n        for(int j=1; j<=min(n-1 - i, nums[i]); j++)  //steps we can take\\n        {\\n            int temp = 1 + solve(i+j, nums, dp);\\n            mini = min(mini, temp);\\n        }\\n        \\n        return dp[i] = mini;  //agar n-1 tk nhi bhi pahucha, then it will not go in loop and return mini = INT_MAX \\n    }\\n    \\n    int jump(vector<int>& nums) \\n    {\\n        n = nums.size();\\n        vector<int> dp(n-1, -1);\\n        \\n        return solve(0, nums, dp);\\n    }\\n};\\n```\\n\\n**TABULATION BOTTOM-UP code:**\\n```\\nclass Solution {\\npublic:\\n\\tint jump(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<int> dp(n, 0);\\n        //base case for i=n-1 is 0\\n        \\n        for(int i=n-2; i>=0; i--)\\n        {\\n            int mini = INT_MAX-1;\\n            for(int j=1; j<=min(n-1 - i, nums[i]); j++)  //steps we can take\\n            {\\n                int temp = 1 + dp[i+j];\\n                mini = min(mini, temp);\\n            }\\n\\n            dp[i] = mini;  //agar n-1 tk nhi pahucha, it will return INT_MAX as min steps\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int solve(int i, vector<int> &nums)\\n    {\\n        if(i == n-1)  //if reached last index then no need to move further so no steps required\\n            return 0;\\n       \\n        int mini = INT_MAX-1;                       //-1 bc in loop 1 + solve(), if solve() returns INT_MAX, 1+INT_MAX will result stack overflow\\n        for(int j=1; j<=min(n-1 - i, nums[i]); j++) //possible steps we can take from i\\n        {\\n            int temp = 1 + solve(i+j, nums); //at i take 1 step of length j, so we reach i+j\\n            mini = min(mini, temp);          //we take minimum of all steps from i to reach n-1\\n        }\\n        \\n        return mini;  //if not reached n-1, then it will not go in loop and return mini = INT_MAX-1 at some step where further going forward is not possible, back trackingto previous call temp = 1 + INT_MAX-1, mini = min(mini, INT_MAX), so we see for current j it will get INT_MAX as temp ans, while taking minimum it won\\'t affect the answer\\n    }\\n    \\n    int jump(vector<int>& nums) \\n    {\\n        n = nums.size();\\n        \\n        return solve(0, nums, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int solve(int i, vector<int> &nums, vector<int> &dp)\\n    {\\n        if(i == n-1)\\n            return 0;\\n        \\n        if(dp[i] != -1)\\n            return dp[i];\\n        \\n        int mini = INT_MAX-1;\\n        for(int j=1; j<=min(n-1 - i, nums[i]); j++)  //steps we can take\\n        {\\n            int temp = 1 + solve(i+j, nums, dp);\\n            mini = min(mini, temp);\\n        }\\n        \\n        return dp[i] = mini;  //agar n-1 tk nhi bhi pahucha, then it will not go in loop and return mini = INT_MAX \\n    }\\n    \\n    int jump(vector<int>& nums) \\n    {\\n        n = nums.size();\\n        vector<int> dp(n-1, -1);\\n        \\n        return solve(0, nums, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\tint jump(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<int> dp(n, 0);\\n        //base case for i=n-1 is 0\\n        \\n        for(int i=n-2; i>=0; i--)\\n        {\\n            int mini = INT_MAX-1;\\n            for(int j=1; j<=min(n-1 - i, nums[i]); j++)  //steps we can take\\n            {\\n                int temp = 1 + dp[i+j];\\n                mini = min(mini, temp);\\n            }\\n\\n            dp[i] = mini;  //agar n-1 tk nhi pahucha, it will return INT_MAX as min steps\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2471981,
                "title": "c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int pos=0;\\n        int des=0;\\n        int jmp=0;\\n        \\n        for(int i=0;i<nums.size()-1;i++){\\n            des=max(des,i+nums[i]);\\n            \\n            if(pos==i){\\n                pos=des;\\n                jmp++;\\n            }\\n        }\\n        return jmp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int pos=0;\\n        int des=0;\\n        int jmp=0;\\n        \\n        for(int i=0;i<nums.size()-1;i++){\\n            des=max(des,i+nums[i]);\\n            \\n            if(pos==i){\\n                pos=des;\\n                jmp++;\\n            }\\n        }\\n        return jmp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2378987,
                "title": "c-two-approaches-dp-greedy-must-see-explained",
                "content": "**This problem can be solve using both dp and greedy techniques.\\nSo, just trying to explain you both the techniques**\\n\\n\\u2714\\u2714  **DYNAMIC PROGRAMMING**\\n\\nclass Solution {\\npublic:\\n \\n\\t int solve(int index,vector<int>& nums,vector<int>&dp)\\n\\t\\t{\\n       \\n\\t   if(index>=nums.size()-1) //base condition if we reached at last index or beyond it \\n        {\\n            return 0;\\n        }\\n        if(nums[index]==0) // if index element is zero then it is not possible to move further  return ing  large value \\n        {\\n            return 1e5;\\n        }\\n        if(dp[index]!=-1)\\n        {\\n            return dp[index];\\n        }\\n        int ans=1e5;\\n        for(int i=1;i<=nums[index];++i)// trying all possible ways \\n        {\\n            ans=min(ans,1+solve(index+i,nums,dp)); //taking min ans\\n        }\\n        return dp[index]=ans;\\n    }\\n    int jump(vector<int>& nums) {\\n        vector<int>dp(nums.size(),-1); //dp array\\n        return solve(0,nums,dp);\\n    }\\n};\\n**Time complexity=0(N^2)\\nSpace complexity=O(N)**\\n\\n\\n \\uD83D\\uDD25\\uD83D\\uDD25 **Greedy SOlution**\\n  \\n     class Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n\\t\\n     //simple just having maxsofar and currso far at each currso far we will update our jump\\n        int n=nums.size();\\n        int mxfar=nums[0];\\n        int currfar=nums[0];\\n        int jump=1;\\n        if(nums[0]==0 ||n==1)\\n        {\\n            return 0;\\n        }\\n        for(int i=1;i<n;++i)\\n        {\\n            \\n            mxfar=max(mxfar,nums[i]+i); // each time take max possible\\n\\t\\t\\t\\n            if(mxfar<=i) //check if we can reach the end though not necessary for this problem\\n            {\\n                return -1;\\n            }\\n            if(currfar==n-1) // if we can reach at last we curr max\\n            {\\n                return jump;\\n            }\\n            if(currfar==i) //if currfar limit reached then again need to take a jump\\n            {\\n                currfar=mxfar;\\n                jump++;\\n            }\\n        }\\n        return jump;\\n    }\\n};\\n**Time complexity=0(N)\\nSpace complexity=O(1)**\\n**DO Upvote if it helped**\\uD83D\\uDE03\\uD83D\\uDE03",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n \\n\\t int solve(int index,vector<int>& nums,vector<int>&dp)\\n\\t\\t{\\n       \\n\\t   if(index>=nums.size()-1) //base condition if we reached at last index or beyond it \\n        {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2260220,
                "title": "c-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int maxReach=0;\\n        int current=0;\\n        int jumps=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            maxReach=max(maxReach,i+nums[i]);\\n            if(current==i)\\n            {\\n                jumps++;\\n                current=maxReach;\\n            }            \\n        }\\n        return jumps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int maxReach=0;\\n        int current=0;\\n        int jumps=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            maxReach=max(maxReach,i+nums[i]);\\n            if(current==i)\\n            {\\n                jumps++;\\n                current=maxReach;\\n            }            \\n        }\\n        return jumps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866723,
                "title": "golang-simple-solution",
                "content": "```\\nfunc jump(nums []int) int {\\n    if len(nums) == 0 {\\n        return 0\\n    }\\n    \\n    if len(nums) == 1 {\\n        return 0\\n    }\\n    \\n    record := make(map[int]int)\\n    // key: index of num\\n    // value: min amount of steps to reach the end\\n    \\n    lastIdx := len(nums) - 1\\n    \\n    for i := lastIdx - 1; i > -1; i-- {\\n        if nums[i] >= lastIdx - i {\\n            record[i] = 1\\n        } else {\\n            for key, value := range record {\\n                if nums[i] >= key - i {\\n                    if _, exist := record[i]; exist {\\n                        record[i] = min(value + 1, record[i])\\n                    } else {\\n                        record[i] = value + 1\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    return record[0]\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc jump(nums []int) int {\\n    if len(nums) == 0 {\\n        return 0\\n    }\\n    \\n    if len(nums) == 1 {\\n        return 0\\n    }\\n    \\n    record := make(map[int]int)\\n    // key: index of num\\n    // value: min amount of steps to reach the end\\n    \\n    lastIdx := len(nums) - 1\\n    \\n    for i := lastIdx - 1; i > -1; i-- {\\n        if nums[i] >= lastIdx - i {\\n            record[i] = 1\\n        } else {\\n            for key, value := range record {\\n                if nums[i] >= key - i {\\n                    if _, exist := record[i]; exist {\\n                        record[i] = min(value + 1, record[i])\\n                    } else {\\n                        record[i] = value + 1\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    return record[0]\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1814490,
                "title": "easy-to-understand-java-1ms",
                "content": "Given \\n**You can assume that you can always reach the last index.** \\nwe defintely reach end and we need to find min jumps\\n\\n**Example**\\n\\t\\t\\t\\tnums\\t=[2, 3, 1, 1, 4]\\nmaxreachablepos = [2, 4, 3, 4, 8]\\n\\t\\t\\t\\t\\tindex = [0, 1, 2, 3, 4]\\n\\t\\t\\t\\t\\t\\nintially at **index0**, we can reach upto **index2(1)**, store in max reachable pos, **increment ans**\\nat **index1**, we can can reach upto **index4**, store in cur_max\\nat **index2** we can reach upto index max reachable pos is **3** current index is **2** but we already know if we choose **index1** then we can reach **index4** which is stored in cur_max, so store that cur_max in max_reachable pos.. **increment ans**.    4 means we reaches **end** \\n\\nso we need **2** jumps to reach end\\n\\n\\n\\n\\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int maxReachablePos=0, cur_max=0, ans=0;\\n        for(int i=0; i<nums.length-1; i++){\\n            cur_max = Math.max(cur_max, i+nums[i]);\\n            if(i==maxReachablePos){\\n                ans++;\\n                maxReachablePos=cur_max;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nIf you have any **doubts**, feel **free to ask**...\\nIf you understand the **concept**. Dont Forget to **upvote**\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int maxReachablePos=0, cur_max=0, ans=0;\\n        for(int i=0; i<nums.length-1; i++){\\n            cur_max = Math.max(cur_max, i+nums[i]);\\n            if(i==maxReachablePos){\\n                ans++;\\n                maxReachablePos=cur_max;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1804268,
                "title": "o-n2-easy-dynamic-programming-javascript-solution-with-o-n-extra-space",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar jump = function(nums) {\\n    //jump[i] is the jumps required to reach from first element of aray to i\\'th position\\n    const jump = new Array(nums.length).fill(Infinity);\\n    jump[0] = 0; //Since we are already at index 0 initially\\n\\n    //Outer loop to calculate & store minimum jumps to  reach position i\\n    for( let i = 1; i < nums.length; i++) {\\n        /** Inner loop will run from 0\\'th index to i-1 index, We need to figure out\\n        * if we can jump directly from j\\'th position to i\\'th position, \\n        * if we can, then minimum jump to reach index i will be minimum of jump[i], jump[j]+1\\n        * Here \"+1\" in \"jump[j] + 1\" is for one more jump from j\\'th index\\n        **/\\n        for (let j = 0; j < i; j++) {\\n            if(nums[j] >= i-j) {\\n               jump[i] = Math.min(jump[i], jump[j]+1);\\n               }\\n        }\\n    }\\n    return jump[nums.length-1];\\n}\\n\\n```\\nFor suport, Hit Upvote :)\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar jump = function(nums) {\\n    //jump[i] is the jumps required to reach from first element of aray to i\\'th position\\n    const jump = new Array(nums.length).fill(Infinity);\\n    jump[0] = 0; //Since we are already at index 0 initially\\n\\n    //Outer loop to calculate & store minimum jumps to  reach position i\\n    for( let i = 1; i < nums.length; i++) {\\n        /** Inner loop will run from 0\\'th index to i-1 index, We need to figure out\\n        * if we can jump directly from j\\'th position to i\\'th position, \\n        * if we can, then minimum jump to reach index i will be minimum of jump[i], jump[j]+1\\n        * Here \"+1\" in \"jump[j] + 1\" is for one more jump from j\\'th index\\n        **/\\n        for (let j = 0; j < i; j++) {\\n            if(nums[j] >= i-j) {\\n               jump[i] = Math.min(jump[i], jump[j]+1);\\n               }\\n        }\\n    }\\n    return jump[nums.length-1];\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1745102,
                "title": "easy-recursice-memoization-top-down-tabulation-solution-bottom-up",
                "content": "**Recursive Approach: Try to make recursive tree for each step**\\n```\\nclass Solution {\\nprivate:\\n    int solve(int ind, int n, vector<int> &nums){\\n        \\n        if(ind >= n){\\n            return 0;\\n        }\\n        int paths = 1e9;\\n        for(int i = 1; i<=nums[ind]; i++){\\n            paths = min(paths,1+ solve(ind+i, n, nums));\\n        }\\n        return paths;\\n    }\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return 0;\\n        return solve(0,n-1, nums);\\n    }\\n};\\n```\\n**Memoization: Recusion has overlapping subproblem, so we will memoize it**\\n**TC: O(n), Solving every state only once**\\n**SC: O(n) + O(n), Stack space + dp**\\n```\\nclass Solution {\\nprivate:\\n    int solve(int ind, int n,vector<int> &dp, vector<int> &nums){\\n        \\n        if(ind >= n){\\n            return 0;\\n        }\\n        if(dp[ind] != -1) return dp[ind];\\n        int paths = 1e9;\\n        for(int i = 1; i<=nums[ind]; i++){\\n            paths = min(paths,1+ solve(ind+i, n,dp, nums));\\n        }\\n        return dp[ind] = paths;\\n    }\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return 0;\\n        vector<int> dp(n, -1);\\n        return solve(0,n-1, dp,nums);\\n    }\\n};\\n```\\n**Tabulation: we know about the base case. ie. If we are at the last step...there is no path to go**\\n**TC: O(n), Solving every state only once**\\n**SC: O(n) , dp**\\n```\\nclass Solution {\\nprivate:    \\n    int solveTab(int n, vector<int> &nums){\\n        vector<int> dp(n);\\n        dp[n-1] = 0;\\n        for(int i=n-2; i>=0; i--){\\n            int step = 1e9;\\n            for(int j = 1; j<= nums[i]; j++){\\n                if(i+j < n){\\n                    step = min(step, 1+dp[i+j]);\\n                }\\n            }\\n            dp[i] = step;\\n        }\\n        return dp[0];\\n    }\\n    \\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return 0;\\n        return solveTab(n, nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(int ind, int n, vector<int> &nums){\\n        \\n        if(ind >= n){\\n            return 0;\\n        }\\n        int paths = 1e9;\\n        for(int i = 1; i<=nums[ind]; i++){\\n            paths = min(paths,1+ solve(ind+i, n, nums));\\n        }\\n        return paths;\\n    }\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return 0;\\n        return solve(0,n-1, nums);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int solve(int ind, int n,vector<int> &dp, vector<int> &nums){\\n        \\n        if(ind >= n){\\n            return 0;\\n        }\\n        if(dp[ind] != -1) return dp[ind];\\n        int paths = 1e9;\\n        for(int i = 1; i<=nums[ind]; i++){\\n            paths = min(paths,1+ solve(ind+i, n,dp, nums));\\n        }\\n        return dp[ind] = paths;\\n    }\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return 0;\\n        vector<int> dp(n, -1);\\n        return solve(0,n-1, dp,nums);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:    \\n    int solveTab(int n, vector<int> &nums){\\n        vector<int> dp(n);\\n        dp[n-1] = 0;\\n        for(int i=n-2; i>=0; i--){\\n            int step = 1e9;\\n            for(int j = 1; j<= nums[i]; j++){\\n                if(i+j < n){\\n                    step = min(step, 1+dp[i+j]);\\n                }\\n            }\\n            dp[i] = step;\\n        }\\n        return dp[0];\\n    }\\n    \\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return 0;\\n        return solveTab(n, nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1583901,
                "title": "c-faster-than-99-o-n-timecomplexity-greedy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int curr_reach=0,max_reach=0,jumps=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            max_reach=max(max_reach,i+nums[i]);\\n            if(i==curr_reach)\\n            {\\n                curr_reach=max_reach;\\n                jumps++;\\n            }      \\n        }\\n        return jumps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int curr_reach=0,max_reach=0,jumps=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            max_reach=max(max_reach,i+nums[i]);\\n            if(i==curr_reach)\\n            {\\n                curr_reach=max_reach;\\n                jumps++;\\n            }      \\n        }\\n        return jumps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1505576,
                "title": "short-clean-java",
                "content": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int count = 0;\\n        int current_jump = 0;\\n        int last_jump = 0;\\n        for(int i = 0; i < nums.length-1; i++){\\n            current_jump = Math.max(current_jump , i+nums[i]);\\n            if(i == last_jump){\\n                count++;\\n                last_jump = current_jump;\\n            }\\n        }\\n        return count;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int count = 0;\\n        int current_jump = 0;\\n        int last_jump = 0;\\n        for(int i = 0; i < nums.length-1; i++){\\n            current_jump = Math.max(current_jump , i+nums[i]);\\n            if(i == last_jump){\\n                count++;\\n                last_jump = current_jump;\\n            }\\n        }\\n        return count;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1192374,
                "title": "c-simple-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        if (nums.size() == 1 || nums[0] == 0) return 0;\\n        \\n        int jumps = 0, curr = 1, reach = 0, n = nums.size(), i;\\n        \\n        while (reach < n-1 && reach + nums[reach] < n - 1) {\\n            for (i = curr; curr <= reach + nums[reach]; curr++) {\\n                if (curr + nums[curr] >= i + nums[i])\\n                    i = curr;\\n            }\\n            jumps++;\\n            reach = i;\\n        }\\n        return ++jumps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        if (nums.size() == 1 || nums[0] == 0) return 0;\\n        \\n        int jumps = 0, curr = 1, reach = 0, n = nums.size(), i;\\n        \\n        while (reach < n-1 && reach + nums[reach] < n - 1) {\\n            for (i = curr; curr <= reach + nums[reach]; curr++) {\\n                if (curr + nums[curr] >= i + nums[i])\\n                    i = curr;\\n            }\\n            jumps++;\\n            reach = i;\\n        }\\n        return ++jumps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1170736,
                "title": "java-greedy-beats-100-in-both-memory-and-time-0ms-t-c-o-n-s-c-o-1",
                "content": "\\n    // O(nums.length) O(1)\\n\\tpublic int jump(int[] nums) {\\n\\n\\t\\tif (nums.length == 1)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tint len = nums.length, curr_reach = 0, max_reach = 0, jumps = 0;\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\n\\t\\t\\tif (i + nums[i] >= len - 1)\\n\\t\\t\\t\\treturn jumps + 1;\\n\\n\\t\\t\\tif (i + nums[i] > max_reach)\\n\\t\\t\\t\\tmax_reach = i + nums[i];\\n\\n\\t\\t\\tif (i == curr_reach) {\\n\\t\\t\\t\\tjumps++;\\n\\t\\t\\t\\tcurr_reach = max_reach;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t}",
                "solutionTags": [],
                "code": "\\n    // O(nums.length) O(1)\\n\\tpublic int jump(int[] nums) {\\n\\n\\t\\tif (nums.length == 1)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tint len = nums.length, curr_reach = 0, max_reach = 0, jumps = 0;\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\n\\t\\t\\tif (i + nums[i] >= len - 1)\\n\\t\\t\\t\\treturn jumps + 1;\\n\\n\\t\\t\\tif (i + nums[i] > max_reach)\\n\\t\\t\\t\\tmax_reach = i + nums[i];\\n\\n\\t\\t\\tif (i == curr_reach) {\\n\\t\\t\\t\\tjumps++;\\n\\t\\t\\t\\tcurr_reach = max_reach;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1048278,
                "title": "c-dp-time-and-space-o-n",
                "content": "```public class Solution {\\n    public int Jump(int[] nums) {\\n        if(nums.Length < 2) {\\n            return 0;\\n        }\\n        \\n        int[] dp = new int[nums.Length];\\n        dp[0] = nums[0];\\n        \\n        for(int i = 1; i < nums.Length; i++) {\\n\\t\\t   //Figure out the max jump at index i\\n            dp[i] = Math.Max(dp[i-1]-1, nums[i]);\\n        }\\n        \\n        int index = 0;\\n        int count = 0;\\n\\t\\t//using max jump, figure out how many jumps to hit last index\\n        while(index < nums.Length-1) {\\n            index += dp[index];\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int Jump(int[] nums) {\\n        if(nums.Length < 2) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 714429,
                "title": "c-and-go-o-n-easiest-solution-10-lines",
                "content": "C++ \\nclass Solution {\\npublic:\\n    int jump(vector<int>& arr) {\\n    \\n        int ans=0,cend=0,cmax=arr[0], n = arr.size();\\n        \\n        for(int i=0;i<n;i++){\\n            if(cend<i){\\n                ans++;\\n                cend = cmax;\\n            } \\n              cmax = max(cmax,i+arr[i]);\\n        } \\n        return ans;\\n    }\\n};\\n\\nGO Solution for the same logic.\\nfunc max(a int,b int) int {\\n    \\n    if(a > b){\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc jump(nums []int) int {\\n    \\n    n := len(nums)\\n    if (n==1) {\\n        return 0;\\n    }\\n    var ewall, cwall, jump int\\n    for i:=0; i<n; i++ {\\n        cwall = max(cwall,i+nums[i])\\n        if i == ewall {\\n            ewall = cwall\\n            jump++\\n        \\n            if ewall >= n-1 {\\n                break; \\n            }\\n        }\\n    }  \\n    return jump\\n}",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int jump(vector<int>& arr) {\\n    \\n        int ans=0,cend=0,cmax=arr[0], n = arr.size();\\n        \\n        for(int i=0;i<n;i++){\\n            if(cend<i){\\n                ans++;\\n                cend = cmax;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 559701,
                "title": "java-simple-clean-code-100-12lines-python-10line",
                "content": "Java\\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int res=0,next=0,max=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            max=Math.max(max,i+nums[i]);\\n            if(i==next){\\n                next=max;res++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\npython\\n```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        arr=[0,0,0]\\n        for i in range(len(nums)-1):\\n            arr[2]=max(arr[2],nums[i]+i)\\n            if i==arr[1]:\\n                arr[1]=arr[2]\\n                arr[0]+=1\\n        return arr[0]\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int res=0,next=0,max=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            max=Math.max(max,i+nums[i]);\\n            if(i==next){\\n                next=max;res++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        arr=[0,0,0]\\n        for i in range(len(nums)-1):\\n            arr[2]=max(arr[2],nums[i]+i)\\n            if i==arr[1]:\\n                arr[1]=arr[2]\\n                arr[0]+=1\\n        return arr[0]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 507246,
                "title": "java-2-methods-dp-bfs-both-with-time-o-n-space-o-1",
                "content": "DP:\\n```Java\\n\\t\\t/**\\n         * maxStep means the farthest position you can get to\\n         * lastMax means the farthest position you can get to with the min step now\\n         * minVal means the minimum steps it would take right now\\n         */\\n\\t\\tif (nums == null || nums.length < 2) return 0;\\n        int maxStep = nums[0], lastMax = nums[0], minVal = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n            maxStep = Math.max(maxStep, nums[i] + i);\\n            if (i == lastMax && i != nums.length - 1) {\\n                lastMax = maxStep;\\n                minVal += 1;\\n            }\\n        }\\n        return minVal;\\n```\\n\\nBFS:\\n```Java\\n\\t\\tif (nums == null || nums.length < 2) return 0;\\n        int maxStep = 0, lastMax = 0, minVal = 0, i = 0;\\n        while (lastMax - i + 1 > 0) {\\n            minVal++;\\n            for(; i <= lastMax; i++) {\\n                maxStep = Math.max(maxStep, nums[i] + i);\\n                if (maxStep >= nums.length - 1) return minVal;\\n            }\\n            lastMax = maxStep;\\n        }\\n        return 0;\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```Java\\n\\t\\t/**\\n         * maxStep means the farthest position you can get to\\n         * lastMax means the farthest position you can get to with the min step now\\n         * minVal means the minimum steps it would take right now\\n         */\\n\\t\\tif (nums == null || nums.length < 2) return 0;\\n        int maxStep = nums[0], lastMax = nums[0], minVal = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n            maxStep = Math.max(maxStep, nums[i] + i);\\n            if (i == lastMax && i != nums.length - 1) {\\n                lastMax = maxStep;\\n                minVal += 1;\\n            }\\n        }\\n        return minVal;\\n```\n```Java\\n\\t\\tif (nums == null || nums.length < 2) return 0;\\n        int maxStep = 0, lastMax = 0, minVal = 0, i = 0;\\n        while (lastMax - i + 1 > 0) {\\n            minVal++;\\n            for(; i <= lastMax; i++) {\\n                maxStep = Math.max(maxStep, nums[i] + i);\\n                if (maxStep >= nums.length - 1) return minVal;\\n            }\\n            lastMax = maxStep;\\n        }\\n        return 0;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 383980,
                "title": "easy-peasy-python-o-n-one-pass-o-1-memory-solution",
                "content": "\\t# I will start from a position and look at the position I can go from here\\n\\t# now, I know that from current position to the position where I can go I just need to make one jump for each point between these two positions\\n\\t# now I will look at the point from where I can make the max jump between these two points(including the end)\\n\\t# and I will keep on carrying this.\\n\\t# Basically I will look between the current position and the max position and find the next jump that I can make.\\n\\t# So basically adding 1 jump at a time.\\n\\t\\n\\tdef jump(self, nums: List[int]) -> int:\\n        ln = len(nums)\\n        if ln <= 1:\\n            return 0\\n        \\n        cnt = till = 0\\n        maxIdx = 0 \\n        for i in range(ln):\\n            maxIdx = max(maxIdx, i + nums[i])\\n            if i == till:\\n                cnt += 1\\n                till = maxIdx \\n            \\n            if till >= ln-1:\\n                return cnt",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "\\t# I will start from a position and look at the position I can go from here\\n\\t# now, I know that from current position to the position where I can go I just need to make one jump for each point between these two positions\\n\\t# now I will look at the point from where I can make the max jump between these two points(including the end)\\n\\t# and I will keep on carrying this.\\n\\t# Basically I will look between the current position and the max position and find the next jump that I can make.\\n\\t# So basically adding 1 jump at a time.\\n\\t\\n\\tdef jump(self, nums: List[int]) -> int:\\n        ln = len(nums)\\n        if ln <= 1:\\n            return 0\\n        \\n        cnt = till = 0\\n        maxIdx = 0 \\n        for i in range(ln):\\n            maxIdx = max(maxIdx, i + nums[i])\\n            if i == till:\\n                cnt += 1\\n                till = maxIdx \\n            \\n            if till >= ln-1:\\n                return cnt",
                "codeTag": "Python3"
            },
            {
                "id": 324594,
                "title": "java-o-n-100-time-o-1-100-space-loop-solution",
                "content": "The first idea is that we are not interested in the path, but only the number of jumps. The greedy approach fails if we jumps over an index with a huge jump capacity.\\n\\nThe first loop transforms the problem to one where the greedy approach does succeed. It does this by realizing that if `nums[i] < nums[i-1] - 1`, then jumping to index i  is never optimal (unless it is the last index), because jumping to index i-1 will allow a farther jump. So setting `nums[i] = nums[i-1]-1` does not change the minimal number of jumps required. However, doing this for every index solves the issue of jumping over interesting indices and thus a greedy algorithm can be applied.\\n\\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int N = nums.length;\\n        for(int i = 1; i < N; ++i) {\\n            nums[i] = Math.max(nums[i], nums[i-1] - 1);\\n        }\\n        \\n        int jumps = 0;\\n        int index = 0;\\n        while(index < N - 1) {\\n            ++jumps;\\n            index+=nums[index];\\n        }\\n        \\n        return jumps;\\n    }\\n}\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int N = nums.length;\\n        for(int i = 1; i < N; ++i) {\\n            nums[i] = Math.max(nums[i], nums[i-1] - 1);\\n        }\\n        \\n        int jumps = 0;\\n        int index = 0;\\n        while(index < N - 1) {\\n            ++jumps;\\n            index+=nums[index];\\n        }\\n        \\n        return jumps;\\n    }\\n}\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 271097,
                "title": "java-1ms-greedy-solution-which-beats-100",
                "content": "We use three varaibles:\\n* ```furthest``` to record the furthest place previous step can reach\\n* ```max``` to record the furthest place current step can reach.\\n* ``` result``` to record the minimum step we need to reach the last place.\\nTraverse the array to update ```max```. Update ```furthest```  with ```max``` and ```result``` with ```result + 1```  each time current place reach the ```furthest```. Keep traversing until we reach the last place.\\n```\\npublic int jump(int[] nums) {\\n\\tint furthest = 0, result = 0, i = 0;\\n\\twhile( i < nums.length && furthest < nums.length - 1 ) {\\n\\t\\tint max = 0;\\n\\t\\twhile( i <= furthest ) {\\n\\t\\t\\tmax = Math.max(max, nums[i] + i);\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\tfurthest = max;\\n\\t\\tresult++;\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```furthest```\n```max```\n``` result```\n```max```\n```furthest```\n```max```\n```result```\n```result + 1```\n```furthest```\n```\\npublic int jump(int[] nums) {\\n\\tint furthest = 0, result = 0, i = 0;\\n\\twhile( i < nums.length && furthest < nums.length - 1 ) {\\n\\t\\tint max = 0;\\n\\t\\twhile( i <= furthest ) {\\n\\t\\t\\tmax = Math.max(max, nums[i] + i);\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\tfurthest = max;\\n\\t\\tresult++;\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 242676,
                "title": "python-o-n",
                "content": "```\\n\\ndef minJumps(arr):\\n    if len(arr) < 2:\\n            return 0\\n    jump = 1\\n    step = arr[0]\\n    reach = arr[0]\\n    for i in range(1,len(arr)):\\n        if i > step:\\n            jump += 1\\n            step = reach\\n        reach = max(reach, i+arr[i])\\n\\n    return jump\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\ndef minJumps(arr):\\n    if len(arr) < 2:\\n            return 0\\n    jump = 1\\n    step = arr[0]\\n    reach = arr[0]\\n    for i in range(1,len(arr)):\\n        if i > step:\\n            jump += 1\\n            step = reach\\n        reach = max(reach, i+arr[i])\\n\\n    return jump\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 18017,
                "title": "possibly-the-simplest-o-n-solution-with-explanation-9-lines-in-c",
                "content": "My solution is based on the observation that if you can reach index `i`, then you are always able to reach index `i - 1` too (**proof:** think of the last jump taken to reach index `i`. If it was of length `1`, then you were already at index `i - 1`. If it was of length ` >= 2`, then you could have taken a 1-unit smaller jump to land on `i -1` instead of `i`). Furthermore, following the same reasoning, if you can reach index `i` in `w` jumps, you can also reach index `i-1` using no more than `w` jumps (but perhaps even less).\\n\\nLet `reach[i]` be the farthest you can reach in the next jump assuming you are able to reach index `i`. (Remember, if you can reach in `i` in `w` jumps, then you can also reach any smaller index in no more than `w` jumps).  Therefore, `reach[i]` is simply `max(k + nums[k])` for all `k` with `0 <= k <= i`). \\n\\nYou can precompute `reach[i]` in O(n) for all `i`'s. (Note that in my code I reuse `nums` to precompute it and avoid defining a new array to save some memory.)\\n\\nAfter that you just simulate the jumps, always reaching as far as you can until you reach the end.\\n\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n      int n = nums.size();\\n      for (int i = 1; i < n; ++i) {\\n        nums[i] = max(nums[i - 1], i + nums[i]);\\n      }\\n      int jumps = 0;\\n      for (int at = 0; at < n - 1; at = nums[at]) {\\n        jumps++;\\n      }\\n      return jumps;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n      int n = nums.size();\\n      for (int i = 1; i < n; ++i) {\\n        nums[i] = max(nums[i - 1], i + nums[i]);\\n      }\\n      int jumps = 0;\\n      for (int at = 0; at < n - 1; at = nums[at]) {\\n        jumps++;\\n      }\\n      return jumps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18213,
                "title": "o-n-runtime-o-1-space-java-solution",
                "content": "Use two pointer to keep track of lower bound and upper bound each time I move forward.\\n\\n    public int jump(int[] A) {\\n            int step = 0;\\n            int low = 0;\\n            int high = 0;\\n            while(high < A.length-1){\\n                int preLow = low;\\n                int preHigh = high;\\n                for(int t = preLow;t <= preHigh;t++)\\n                    high = Math.max(t+A[t], high);\\n                low = preHigh+1;\\n                step++;\\n            }\\n            return step;\\n        }",
                "solutionTags": [],
                "code": "Use two pointer to keep track of lower bound and upper bound each time I move forward.\\n\\n    public int jump(int[] A) {\\n            int step = 0;\\n            int low = 0;\\n            int high = 0;\\n            while(high < A.length-1){\\n                int preLow = low;\\n                int preHigh = high;\\n                for(int t = preLow;t <= preHigh;t++)\\n                    high = Math.max(t+A[t], high);\\n                low = preHigh+1;\\n                step++;\\n            }\\n            return step;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 18099,
                "title": "sharing-my-accepted-python-code",
                "content": "I think the runtime should be O(N) and space complexity is O(1).\\n\\n    def jump(self, A):\\n        if len(A) <= 1:\\n            return 0\\n        end = 0 + A[0]\\n        start = 0\\n        step = 1\\n        maxDis = 0 + A[0]\\n        while end < len(A)-1:\\n            for i in range(start+1, end+1):\\n                maxDis = max(maxDis, A[i]+i)\\n            start = end\\n            end = maxDis\\n            step += 1\\n            \\n        return step",
                "solutionTags": [],
                "code": "I think the runtime should be O(N) and space complexity is O(1).\\n\\n    def jump(self, A):\\n        if len(A) <= 1:\\n            return 0\\n        end = 0 + A[0]\\n        start = 0\\n        step = 1\\n        maxDis = 0 + A[0]\\n        while end < len(A)-1:\\n            for i in range(start+1, end+1):\\n                maxDis = max(maxDis, A[i]+i)\\n            start = end\\n            end = maxDis\\n            step += 1\\n            \\n        return step",
                "codeTag": "Python3"
            },
            {
                "id": 3791862,
                "title": "c-easy-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGo on every step and check for maximum reach.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf there is only one step then return 1 or if you can not take any step return -1. Initially we will start from index 1, and traverse the array and keep updating the maximum reach and decrease steps.\\n 1. Suppose you are on index 1 (i.e. nums[1] is equal to 3) so you can take 1/2/3 steps and for every step you take max of reach.\\n 2. When step==0 i.e. you can not take any more step, so you will increment the jump by 1.\\n 3. And update step by step=max_reach-1. (simple maths)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = 1;\\n        int step = nums[0];\\n        if(n<=1) return 0; \\n        if(step==0) return -1; \\n        int max_reach=nums[0];\\n        for(int i=1;i<n;i++){\\n            if(i==n-1) return ans;\\n            max_reach=max(max_reach,i+nums[i]);\\n            step--;\\n            if(step==0){\\n                ans++;\\n                if(i>= max_reach) return -1;\\n                step=max_reach-i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = 1;\\n        int step = nums[0];\\n        if(n<=1) return 0; \\n        if(step==0) return -1; \\n        int max_reach=nums[0];\\n        for(int i=1;i<n;i++){\\n            if(i==n-1) return ans;\\n            max_reach=max(max_reach,i+nums[i]);\\n            step--;\\n            if(step==0){\\n                ans++;\\n                if(i>= max_reach) return -1;\\n                step=max_reach-i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782140,
                "title": "c-recursive-memoized-and-tabulated-detailed-solution-with-example",
                "content": "# Intuition\\nWe have to start with index `0`, and we can jump upto `0+nums[0]`, and the process goes on. Thus we have to explore all the possible ways to reach the end index in order to get minimum jumps. We will use recursion to explore all the possibilities, and then go on to the memoization and tabulation approaches.\\n\\n# Recursive Approach\\nWe will start with index 0, and will try every possible jump i.e. till nums[i] for index `i`, and count the ways (if possible) to reach end index. Here it may be possible that we land at an index greater than `n-1`, thus the base case will be `if(j>=nums.size()-1) return 0;`. \\nThe approach is simple, the possible steps from current index are `j=i+nums[i]`, we initialise `mini` to `1e7` a big number (not to INT_MAX to avoid overflow) and we explore all jumps possible from `i+1` to `j`, compare the jumps/steps achieved for each jump to mini, and store it if we get comparatively less jumps. In the end we return **res+1**, consider this example: `nums:[1,4]` this will return 0, but we know we need atleat 1 jump to reach destination, so we return **result+1**.\\n\\n```\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1) return 0;\\n        return f(0,nums,dp)+1;\\n}\\n\\nint f(int i, vector<int>& nums){\\n    int j=i+nums[i];\\n    if(j>=nums.size()-1) return 0;\\n    \\n    int mini=1e7;\\n    for(int k=i+1;k<=j;k++){\\n        int steps=1+f(k,nums);\\n        mini=min(mini, steps);\\n    }\\n\\n    return mini;\\n}\\n```\\n\\n---\\n\\n\\n# Memoization\\nIn memoization we avoid repeating recursive calls, thus we declare a vector `dp` of size `n`. And as here we are taking the array to be of size n, there will be slight modification in the base case: `dp[n-1]=1`. Before computing just check if it is precomputed or not and before returning store the data in the data structure.\\n```\\nint jump(vector<int>& nums) {\\n    if(n==1) return 0;\\n    vector<int> dp(n, -1);\\n    return f(0,nums,dp)+1;\\n}\\n\\nint solve(int ind,vector<int>&nums,int minJump,vector<int>&dp){\\n    int f(int i, vector<int>& nums, vector<int> &dp){\\n        int j=i+nums[i];\\n        if(j>=nums.size()-1) return 0;\\n\\n        if(dp[i]!=-1) return dp[i];\\n        \\n        int mini=1e7;\\n        for(int k=i+1;k<=j;k++){\\n            int steps=1+f(k,nums,dp);\\n            mini=min(mini, steps);\\n        }\\n\\n        return dp[i]=mini;\\n    }\\n}\\n```\\n\\n---\\n\\n\\n# Tabulation\\nThere are 3 rules for tabulation: \\n1. Write the base cases.\\n2. Reverse the looping of the changing params.\\n3. Copy the recurrence relation.\\n\\nBase case will be `dp[n-1]=0`, and the *i* loop will run from `n-2` to `0` and we copy the recurrence relation.\\n\\n## Example\\nConsider nums to be [2, 3, 1, 1, 4]\\n- Start from the second-to-last position(n-2), \\n- At i=3, j=i+nums[i] = 3+1 = 4. We can jump to position 4. Now, we need to find the minimum jumps from positions 4.\\n- At i=2, j = i+nums[i] = 2+1 = 3. We can jump to position 3 or 4.\\n- The minimum jumps needed from position 3 is dp[3] = 0 (already known). The minimum jumps needed from position 4 is dp[4] = 0 (last index, no jumps needed). Since there\\'s only one jump needed from position 3 to position 4, the minimum jumps needed from position 2 is Update dp[2] = 1.\\n- At i=1, j = i+nums[i] = 1+3 = 4. We can jump to position 4.The minimum jumps needed from position 4 is dp[4]=0 (last index, no jumps needed).Since there\\'s only one jump needed from position 1 to position 4, the minimum jumps needed from position 1 is 1+1 = 2 Update dp[1]=2.\\n- At i=0, j = i+nums[i] = 0+2 = 2. We can jump to position 2. The minimum jumps needed from position 2 is dp[2]=1. Since there\\'s only one jump needed from position 0 to position 2, the minimum jumps needed from position 0 is 1+2=3. Update dp[0]=3. \\n- The dp array is now [3, 2, 1, 1, 0]. \\n- The minimum jumps needed to reach the last index (starting from position 0) is dp[0] = 3.\\n\\n**In the iterative version, the dp array correctly represents the minimum number of jumps needed to reach the last index from each position. There\\'s no need to add +1 again at the end because the dp array already contains the correct count of jumps.**\\n\\n\\n```\\nint jump(vector<int>& nums) {\\n    //O(n)\\n    //O(n)\\n    int n=nums.size();\\n    if(n==1) return 0;\\n    vector<int> dp(n, 0);\\n    dp[n-1]=0;\\n\\n    for(int i=n-2;i>=0;i--){\\n        int j=min(n-1,i+nums[i]);\\n        int mini=1e7;\\n        for(int k=i+1;k<=j;k++){\\n            int steps=1+dp[k];\\n            mini=min(mini, steps);\\n        }\\n\\n        dp[i] = mini;\\n    }\\n\\n    return dp[0]+1;\\n}\\n```\\n\\nUpvote if u liked :)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1) return 0;\\n        return f(0,nums,dp)+1;\\n}\\n\\nint f(int i, vector<int>& nums){\\n    int j=i+nums[i];\\n    if(j>=nums.size()-1) return 0;\\n    \\n    int mini=1e7;\\n    for(int k=i+1;k<=j;k++){\\n        int steps=1+f(k,nums);\\n        mini=min(mini, steps);\\n    }\\n\\n    return mini;\\n}\\n```\n```\\nint jump(vector<int>& nums) {\\n    if(n==1) return 0;\\n    vector<int> dp(n, -1);\\n    return f(0,nums,dp)+1;\\n}\\n\\nint solve(int ind,vector<int>&nums,int minJump,vector<int>&dp){\\n    int f(int i, vector<int>& nums, vector<int> &dp){\\n        int j=i+nums[i];\\n        if(j>=nums.size()-1) return 0;\\n\\n        if(dp[i]!=-1) return dp[i];\\n        \\n        int mini=1e7;\\n        for(int k=i+1;k<=j;k++){\\n            int steps=1+f(k,nums,dp);\\n            mini=min(mini, steps);\\n        }\\n\\n        return dp[i]=mini;\\n    }\\n}\\n```\n```\\nint jump(vector<int>& nums) {\\n    //O(n)\\n    //O(n)\\n    int n=nums.size();\\n    if(n==1) return 0;\\n    vector<int> dp(n, 0);\\n    dp[n-1]=0;\\n\\n    for(int i=n-2;i>=0;i--){\\n        int j=min(n-1,i+nums[i]);\\n        int mini=1e7;\\n        for(int k=i+1;k<=j;k++){\\n            int steps=1+dp[k];\\n            mini=min(mini, steps);\\n        }\\n\\n        dp[i] = mini;\\n    }\\n\\n    return dp[0]+1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3781653,
                "title": "super-simple-solution",
                "content": "# Intuition:\\nThe approach to solving this problem involves utilizing the Greedy algorithm technique. The main idea is to keep track of the farthest reachable index at each step and update it accordingly. We also maintain a variable current, which represents the current boundary of the next jump. Whenever we reach this boundary (i.e., when i equals current), we update current to the farthest reachable index found so far and increment the jump count.\\n\\n# Algorithm:\\n\\nInitialize three variables: farthest, current, and jump to 0. farthest keeps track of the farthest reachable index, current represents the current boundary of the next jump, and jump is used to count the number of jumps taken.\\nIterate through the nums array from index 0 to n-2 (since we don\\'t need to jump from the last index).\\na. Update farthest as the maximum of the current farthest value and the sum of the current element nums[i] and the current index i. This is because we can reach nums[i] + i from index i.\\nb. Check if we have reached the current boundary current, which means we need to make the next jump. If i equals current, update current to the current value of farthest (as it represents the farthest index reachable from the previous jump), and increment the jump count.\\nAfter processing all elements, return the final value of jump, which represents the minimum number of jumps to reach the last index.\\nComplexity Analysis:\\n\\n# Time Complexity:\\n The algorithm iterates through the nums array once, performing constant time operations at each step. Therefore, the time complexity is O(n), where n is the length of the input array nums.\\n# Space Complexity:\\n The algorithm uses only a constant amount of extra space to store the variables farthest, current, and jump, so the space complexity is O(1).\\nOverall, the algorithm has a linear time complexity of O(n) and a constant space complexity of O(1). It efficiently finds the minimum number of jumps required to reach the last index from the first index.\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int farthest=0,current=0,jump=0;\\n        for(int i=0;i<nums.size()-1;i++){\\n            farthest=max(farthest,nums[i]+i);\\n            if(i==current){\\n                current=farthest;\\n                jump++;\\n            }\\n        }\\n        return jump;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int farthest=0,current=0,jump=0;\\n        for(int i=0;i<nums.size()-1;i++){\\n            farthest=max(farthest,nums[i]+i);\\n            if(i==current){\\n                current=farthest;\\n                jump++;\\n            }\\n        }\\n        return jump;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687480,
                "title": "beats-100-explained-greedy-approach-c",
                "content": "\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe initial intuition for this approach is to use the greedy strategy to find the minimum number of jumps required to reach the last index of the input vector `nums`. The idea is to iteratively update the current farthest index that can be reached from each index, while keeping track of the current end index. Whenever the current index reaches the current end index, it means we have reached the maximum position we can jump from the previous indices. In that case, we increment the jump count and update the current end index to the current farthest index. By doing this, we move forward in the vector and continue the process until we reach the last index.\\n\\nThe intuition behind this approach is that by greedily selecting the farthest index we can reach at each step, we can optimize the number of jumps needed to reach the end. This is based on the observation that if we can reach a certain index, we can also reach all the indices before it. Therefore, we can keep track of the current farthest index and update it whenever we find a farther index to jump to.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Easily Understandable Code\\n```\\n-int jump(vector<int> &nums)\\n-{\\n-    int n = nums.size();\\n-    if (n == 1)\\n-        return 0;\\n-    int left = 0, right = 0;\\n-    int jump = 0;\\n-    while (right < n - 1)\\n-    {\\n-        int farthest = 0;\\n-        for (int i = left; i < right + 1; ++i)\\n-            farthest = max(farthest, i + nums[i]);\\n-        left = right + 1;\\n-        right = farthest;\\n-        ++jump;\\n-    }\\n-    return jump;\\n-}\\n```\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n// This function calculates the minimum number of jumps required to reach the last index \\n// of the input vector.\\n\\nint jump(vector<int>& nums) {\\n    \\n    // Store the size of the input vector.\\n    int n = nums.size();\\n    \\n    // Declare and initialize variables for jumps, current end index, and current farthest index.\\n    int jumps = 0, currEnd = 0, currFarthest = 0;\\n    \\n    // Loop through the vector until the second to last element.\\n    for(int i = 0; i < n - 1; i++) {\\n        \\n        // Calculate the farthest index we can reach from the current index.\\n        currFarthest = max(currFarthest, i + nums[i]);\\n        \\n        // If we reach the current end index, we need to jump to the next furthest index.\\n        if(i == currEnd) {\\n            jumps++;\\n            currEnd = currFarthest;\\n        }\\n    } \\n    \\n    // Return the number of jumps required to reach the last index.\\n    return jumps;\\n}\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\n-int jump(vector<int> &nums)\\n-{\\n-    int n = nums.size();\\n-    if (n == 1)\\n-        return 0;\\n-    int left = 0, right = 0;\\n-    int jump = 0;\\n-    while (right < n - 1)\\n-    {\\n-        int farthest = 0;\\n-        for (int i = left; i < right + 1; ++i)\\n-            farthest = max(farthest, i + nums[i]);\\n-        left = right + 1;\\n-        right = farthest;\\n-        ++jump;\\n-    }\\n-    return jump;\\n-}\\n```\n```\\nclass Solution\\n{\\npublic:\\n// This function calculates the minimum number of jumps required to reach the last index \\n// of the input vector.\\n\\nint jump(vector<int>& nums) {\\n    \\n    // Store the size of the input vector.\\n    int n = nums.size();\\n    \\n    // Declare and initialize variables for jumps, current end index, and current farthest index.\\n    int jumps = 0, currEnd = 0, currFarthest = 0;\\n    \\n    // Loop through the vector until the second to last element.\\n    for(int i = 0; i < n - 1; i++) {\\n        \\n        // Calculate the farthest index we can reach from the current index.\\n        currFarthest = max(currFarthest, i + nums[i]);\\n        \\n        // If we reach the current end index, we need to jump to the next furthest index.\\n        if(i == currEnd) {\\n            jumps++;\\n            currEnd = currFarthest;\\n        }\\n    } \\n    \\n    // Return the number of jumps required to reach the last index.\\n    return jumps;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580174,
                "title": "simple-o-n-time-o-1-space-solution",
                "content": "# Intuition\\nLooks like a greedy problem. Select the maximum index you can reach for each jump.\\nFor this, we will require to keep track of the current maximum index we can reach with given number of jumps and the farthest index we can reach if we consider to take another jump. \\n\\n# Approach\\n1. Initialize currmax = 0, farthest = 0 and the number of jumps as 0.\\n\\n2. Interate over nums, for each index i, the farthest index we can reach from i is i + nums[i]. We update farthest = max(farthest, i + nums[i]).\\n\\n3. If i = currmax, it means we have finished the current jump, and should move on to the next jump. Increment jumps, and set currentmax = farthest as we can reach till farthest with the another jump. Repeat from step 2.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int jumps=0,currmax=0,farthest=0;\\n\\n        for(int i=0;i<nums.size()-1;i++){\\n            farthest=max(farthest,nums[i]+i);\\n            if(i==currmax){\\n                currmax=farthest;\\n                jumps++;\\n            }\\n        }\\n        return jumps;\\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int jumps=0,currmax=0,farthest=0;\\n\\n        for(int i=0;i<nums.size()-1;i++){\\n            farthest=max(farthest,nums[i]+i);\\n            if(i==currmax){\\n                currmax=farthest;\\n                jumps++;\\n            }\\n        }\\n        return jumps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3161869,
                "title": "c-4-approaches-explained-recursive-dp-straight-forward",
                "content": "# Intuition\\nHere, future decisions depend upon past decisions. Also bigger problems can be broken and thus solved in smaller parts hence, we can use DP here.\\n\\n# Approach 1 - Recursive (TLE)\\n\\n## Complexity\\n- Time complexity: $$O(k*n)$$ \\nwhere k = largest element\\n- Space complexity: $$O(1)$$\\n\\n## Code\\n\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        return func(0, nums);\\n    }\\n\\n    long long int func(int ind, vector<int> &nums){\\n        if(ind>=nums.size()-1)\\n            return 0;\\n\\n        long long int steps=INT_MAX;\\n        for(int i=1; i<=nums[ind]; i++)\\n            steps=min(steps, 1+func(ind+i, nums));\\n\\n        return steps;\\n    }\\n};\\n```\\n\\n# Approach 2 - Top Down DP\\n\\n## Complexity\\n- Time complexity: $$O(k*n)$$ \\nwhere k = largest element\\n- Space complexity: $$O(n)$$\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        vector <int> dp(nums.size(), -1);\\n        return func(0, nums, dp);\\n    }\\n\\n    long long int func(int ind, vector<int> &nums, vector<int> &dp){\\n        if(ind>=nums.size()-1)\\n            return 0;\\n\\n        if(dp[ind] != -1)   return dp[ind];\\n\\n        long long int steps=INT_MAX;\\n        for(int i=1; i<=nums[ind]; i++)\\n            steps=min(steps, 1+func(ind+i, nums, dp));\\n\\n        return dp[ind]=steps;\\n    }\\n};\\n```\\n\\n# Approach 3 - Bottom Up DP\\n\\n## Complexity\\n- Time complexity: $$O(n*n)$$ \\nwhere k = largest element\\n- Space complexity: $$O(n)$$\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> dp(n, INT_MAX);\\n        dp[n-1]=0;\\n\\n        for(int i=n-2; i>=0; i--)\\n            for(int j=1; j<=nums[i]; j++) \\n                dp[i]=min(dp[i], 1+dp[min(n-1, i+j)]);\\n\\n        return dp[0];\\n    }\\n};\\n```\\n\\n# Approach 4 - Straight forward logic\\n\\n## Complexity\\n- Time complexity: $$O(n)$$ \\n- Space complexity: $$O(1)$$\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n      for(int i=1; i<nums.size(); i++)\\n        nums[i]=max(nums[i]+i, nums[i-1]);\\n\\n      int ind=0, ans=0;\\n\\n      while(ind<nums.size()-1){\\n        ind = nums[ind];\\n        ans++;\\n      }\\n\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        return func(0, nums);\\n    }\\n\\n    long long int func(int ind, vector<int> &nums){\\n        if(ind>=nums.size()-1)\\n            return 0;\\n\\n        long long int steps=INT_MAX;\\n        for(int i=1; i<=nums[ind]; i++)\\n            steps=min(steps, 1+func(ind+i, nums));\\n\\n        return steps;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        vector <int> dp(nums.size(), -1);\\n        return func(0, nums, dp);\\n    }\\n\\n    long long int func(int ind, vector<int> &nums, vector<int> &dp){\\n        if(ind>=nums.size()-1)\\n            return 0;\\n\\n        if(dp[ind] != -1)   return dp[ind];\\n\\n        long long int steps=INT_MAX;\\n        for(int i=1; i<=nums[ind]; i++)\\n            steps=min(steps, 1+func(ind+i, nums, dp));\\n\\n        return dp[ind]=steps;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> dp(n, INT_MAX);\\n        dp[n-1]=0;\\n\\n        for(int i=n-2; i>=0; i--)\\n            for(int j=1; j<=nums[i]; j++) \\n                dp[i]=min(dp[i], 1+dp[min(n-1, i+j)]);\\n\\n        return dp[0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n      for(int i=1; i<nums.size(); i++)\\n        nums[i]=max(nums[i]+i, nums[i-1]);\\n\\n      int ind=0, ans=0;\\n\\n      while(ind<nums.size()-1){\\n        ind = nums[ind];\\n        ans++;\\n      }\\n\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160826,
                "title": "c-greedy-solution-with-approach",
                "content": "# Approach\\n1. We can use a greedy approach to solve this problem. We can keep track of the current farthest index we can reach and the current end of the current jump.\\n2. We can keep track of the current farthest index we can reach by taking the maximum of the current farthest index and the current index + the value at the current index.\\n3. If the current index is equal to the current end of the current jump, we can increment the number of jumps and set the current end of the current jump to the current farthest index.\\n4. We can return the number of jumps.\\n\\n# Complexity\\n![image.png](https://assets.leetcode.com/users/images/bb65f298-e499-471b-a3f9-f2391d44c899_1675870238.6241379.png)\\n\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution \\n{\\n    public int Jump(int[] nums)\\n    {\\n        int jumps = 0, curEnd = 0, curFarthest = 0;\\n        for (int i = 0; i < nums.Length - 1; i++)\\n        {\\n            curFarthest = Math.Max(curFarthest, i + nums[i]);\\n            if (i == curEnd)\\n            {\\n                jumps++;\\n                curEnd = curFarthest;\\n            }\\n        }\\n        return jumps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Greedy"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int Jump(int[] nums)\\n    {\\n        int jumps = 0, curEnd = 0, curFarthest = 0;\\n        for (int i = 0; i < nums.Length - 1; i++)\\n        {\\n            curFarthest = Math.Max(curFarthest, i + nums[i]);\\n            if (i == curEnd)\\n            {\\n                jumps++;\\n                curEnd = curFarthest;\\n            }\\n        }\\n        return jumps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159922,
                "title": "clean-code-jump-game-ii",
                "content": "# Intuition\\nMINIMIZATION PROBLEM WHERE WE HAVE TO MINIMIZE NO OF JUMPS TO REACH \\nTHE END OF ARRAY.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>dp;\\n\\n    int util(vector<int>& nums, int idx){\\n        if(idx>=nums.size()-1){\\n            return 0;\\n\\n        }\\n        if(dp[idx]!=-1)return dp[idx];\\n\\n        if(nums[idx]==0)return (int)1e5+5;\\n\\n        int ans= 1e5+5;\\n        for(int i= nums[idx]; i>=1; i--){\\n            ans= min(ans, util(nums, idx+i)+1);\\n        }\\n        return dp[idx]= ans;\\n    }\\n    int jump(vector<int>& nums) {\\n        dp.resize(nums.size()+1, -1);\\n\\n        return util(nums, 0);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>dp;\\n\\n    int util(vector<int>& nums, int idx){\\n        if(idx>=nums.size()-1){\\n            return 0;\\n\\n        }\\n        if(dp[idx]!=-1)return dp[idx];\\n\\n        if(nums[idx]==0)return (int)1e5+5;\\n\\n        int ans= 1e5+5;\\n        for(int i= nums[idx]; i>=1; i--){\\n            ans= min(ans, util(nums, idx+i)+1);\\n        }\\n        return dp[idx]= ans;\\n    }\\n    int jump(vector<int>& nums) {\\n        dp.resize(nums.size()+1, -1);\\n\\n        return util(nums, 0);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158946,
                "title": "python3-o-n-easiest-solution-beats-97-runtime-89-memory",
                "content": "# Approach\\n1. The aim is to get to the second last index, so a variable `n` with value of one less than length of `nums` list is inialized.\\n2. Three more variables are initialized with their value as zero : \\n    - `max_jump_index` : it will help in getting the maximum index to which jumping is possible.\\n    - `jumps` : count of jumps\\n    - `finish` : the end index from a particular jump\\n3. Iterate through the range `0` to `n` while calculating : \\n    - `max_jump_index` as maximum of itself or sum of current index and index till jumping is possible.\\n    - if the index is equal to the finish then `jumps` is incremented.\\n    - the new `finish` is the `max_jump_index`\\n4. After all the iterations `jumps` is returned.\\n\\n# Complexity\\n- Time complexity : $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python []\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n= len(nums)- 1\\n\\n        max_jump_index, jumps, finish= 0, 0, 0\\n\\n        for i in range(n):\\n            max_jump_index= max(max_jump_index, i+ nums[i])\\n\\n            if i== finish:\\n                jumps+= 1\\n                finish= max_jump_index\\n\\n        return jumps\\n```\\n---\\n\\n### Happy Coding \\uD83D\\uDC68\\u200D\\uD83D\\uDCBB\\n\\n---\\n\\n### If this solution helped you then do consider Upvoting \\u2B06.\\n#### You can connect with me on LinkedIn : [Om Anand](https://www.linkedin.com/in/om-anand-38341a1ba/)",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```python []\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n= len(nums)- 1\\n\\n        max_jump_index, jumps, finish= 0, 0, 0\\n\\n        for i in range(n):\\n            max_jump_index= max(max_jump_index, i+ nums[i])\\n\\n            if i== finish:\\n                jumps+= 1\\n                finish= max_jump_index\\n\\n        return jumps\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1711786,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1566472,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1569596,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1570678,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1568248,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1568727,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1569674,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1575543,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1573427,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1568870,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1711786,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1566472,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1569596,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1570678,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1568248,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1568727,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1569674,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1575543,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1573427,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1568870,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1815653,
                "content": [
                    {
                        "username": "user5425SM",
                        "content": "typo in question phrase \"Return the minimum number of jumps to reach nums[n - 1].\" should be \".... number of jumps to reach n-1\""
                    },
                    {
                        "username": "The_error",
                        "content": "I think the question is correct. there can be multiple ways to jump and reach n-1, but it is asking to return the min jump required."
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Instead of going back to front... trying going front to back."
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "Yeah\\nI want to know whether it is possible to solve this with Bottom up approach at all??"
                    },
                    {
                        "username": "abhijat_gupta",
                        "content": "Use case:\\n[4,1,1,3,1,1,1]\\n\\nMentioned expected output:2 jumps\\nCorrect expected output:3 jumps \\n\\nExplanation:\\n\\nwhen at index=0, i.e element=4, once can jump to index=4, i.e., element=1 => jumps=1\\nwhen at index=4, i.e element=1, once can jump to index=5, i.e., element=1 => jumps=2\\nwhen at index=5, i.e element=1, once can jump to index=6, i.e., element=1 => jumps=3\\n\\n\\nFeel free to correct me if I am wrong somewhere.\\n\\nthanks,\\nAbhijat\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "nums[0] -> nums [3] / nums [3] -> nums[6]\n= 2 jumps. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "[@Ankroh](/Ankroh) yah je is correct the value of nums[0] is the maximum jump and the selection of you need not be the maximum;"
                    },
                    {
                        "username": "Ankroh",
                        "content": "you can jump from 1 to 4 ,not only 4 !!\\nso you will jump to index 3 and from there to last index!"
                    },
                    {
                        "username": "miosokic",
                        "content": "goal it to reach n-1 not nums[n-1]"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "How come this testcase evaluates to the wrong answer for me:\\n\\nnums = [3,2,1]\\noutput = 2\\nexpected = 1\\n\\nHow can you make one jump from index 0 to index 2, when the nums[0] == 3 ?\\n\\nCan somebody please explain this ?"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "Yup realized it later, thanks!"
                    },
                    {
                        "username": "spf4000",
                        "content": "Actually re-read it, 3 is the MAX number of jumps, you can still jump less"
                    },
                    {
                        "username": "spf4000",
                        "content": "I have the same issue. Half the test cases expect you to jump by nums[i] and the other half nums[i]-1"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I found the easiest solution for this was to start at the back end of the array and see what the furthest point towards the front you could reach and then repeat from there. Don\\'t need to worry about 0s or which point reaches further or anything really. Just search the array to find the max value and use that as your maximum steps back."
                    },
                    {
                        "username": "olegmak",
                        "content": "Is this a valid test case?\\n[2,1]\\nI think not because problem states that i + j < n but 0 + 2 < 2 is false (i = 0; j = 2; n = 2)"
                    },
                    {
                        "username": "Kikimora",
                        "content": "May I see all test cases if submit is successful?"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "don\\'t you think that this daily challange was the 3rd greedy problem in a row ...\\nanyways happy leetcode journey to one who is reading."
                    },
                    {
                        "username": "huanda1412",
                        "content": "I interpreted the question as a shortest path question without weightage, so I did a BFS with a queue. Turns out it is not efficient."
                    },
                    {
                        "username": "MaddyM",
                        "content": "It\\'s not the fastest, but it does get a correct solution \\uD83E\\uDEE1"
                    }
                ]
            },
            {
                "id": 1754394,
                "content": [
                    {
                        "username": "user5425SM",
                        "content": "typo in question phrase \"Return the minimum number of jumps to reach nums[n - 1].\" should be \".... number of jumps to reach n-1\""
                    },
                    {
                        "username": "The_error",
                        "content": "I think the question is correct. there can be multiple ways to jump and reach n-1, but it is asking to return the min jump required."
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Instead of going back to front... trying going front to back."
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "Yeah\\nI want to know whether it is possible to solve this with Bottom up approach at all??"
                    },
                    {
                        "username": "abhijat_gupta",
                        "content": "Use case:\\n[4,1,1,3,1,1,1]\\n\\nMentioned expected output:2 jumps\\nCorrect expected output:3 jumps \\n\\nExplanation:\\n\\nwhen at index=0, i.e element=4, once can jump to index=4, i.e., element=1 => jumps=1\\nwhen at index=4, i.e element=1, once can jump to index=5, i.e., element=1 => jumps=2\\nwhen at index=5, i.e element=1, once can jump to index=6, i.e., element=1 => jumps=3\\n\\n\\nFeel free to correct me if I am wrong somewhere.\\n\\nthanks,\\nAbhijat\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "nums[0] -> nums [3] / nums [3] -> nums[6]\n= 2 jumps. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "[@Ankroh](/Ankroh) yah je is correct the value of nums[0] is the maximum jump and the selection of you need not be the maximum;"
                    },
                    {
                        "username": "Ankroh",
                        "content": "you can jump from 1 to 4 ,not only 4 !!\\nso you will jump to index 3 and from there to last index!"
                    },
                    {
                        "username": "miosokic",
                        "content": "goal it to reach n-1 not nums[n-1]"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "How come this testcase evaluates to the wrong answer for me:\\n\\nnums = [3,2,1]\\noutput = 2\\nexpected = 1\\n\\nHow can you make one jump from index 0 to index 2, when the nums[0] == 3 ?\\n\\nCan somebody please explain this ?"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "Yup realized it later, thanks!"
                    },
                    {
                        "username": "spf4000",
                        "content": "Actually re-read it, 3 is the MAX number of jumps, you can still jump less"
                    },
                    {
                        "username": "spf4000",
                        "content": "I have the same issue. Half the test cases expect you to jump by nums[i] and the other half nums[i]-1"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I found the easiest solution for this was to start at the back end of the array and see what the furthest point towards the front you could reach and then repeat from there. Don\\'t need to worry about 0s or which point reaches further or anything really. Just search the array to find the max value and use that as your maximum steps back."
                    },
                    {
                        "username": "olegmak",
                        "content": "Is this a valid test case?\\n[2,1]\\nI think not because problem states that i + j < n but 0 + 2 < 2 is false (i = 0; j = 2; n = 2)"
                    },
                    {
                        "username": "Kikimora",
                        "content": "May I see all test cases if submit is successful?"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "don\\'t you think that this daily challange was the 3rd greedy problem in a row ...\\nanyways happy leetcode journey to one who is reading."
                    },
                    {
                        "username": "huanda1412",
                        "content": "I interpreted the question as a shortest path question without weightage, so I did a BFS with a queue. Turns out it is not efficient."
                    },
                    {
                        "username": "MaddyM",
                        "content": "It\\'s not the fastest, but it does get a correct solution \\uD83E\\uDEE1"
                    }
                ]
            },
            {
                "id": 1576567,
                "content": [
                    {
                        "username": "user5425SM",
                        "content": "typo in question phrase \"Return the minimum number of jumps to reach nums[n - 1].\" should be \".... number of jumps to reach n-1\""
                    },
                    {
                        "username": "The_error",
                        "content": "I think the question is correct. there can be multiple ways to jump and reach n-1, but it is asking to return the min jump required."
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Instead of going back to front... trying going front to back."
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "Yeah\\nI want to know whether it is possible to solve this with Bottom up approach at all??"
                    },
                    {
                        "username": "abhijat_gupta",
                        "content": "Use case:\\n[4,1,1,3,1,1,1]\\n\\nMentioned expected output:2 jumps\\nCorrect expected output:3 jumps \\n\\nExplanation:\\n\\nwhen at index=0, i.e element=4, once can jump to index=4, i.e., element=1 => jumps=1\\nwhen at index=4, i.e element=1, once can jump to index=5, i.e., element=1 => jumps=2\\nwhen at index=5, i.e element=1, once can jump to index=6, i.e., element=1 => jumps=3\\n\\n\\nFeel free to correct me if I am wrong somewhere.\\n\\nthanks,\\nAbhijat\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "nums[0] -> nums [3] / nums [3] -> nums[6]\n= 2 jumps. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "[@Ankroh](/Ankroh) yah je is correct the value of nums[0] is the maximum jump and the selection of you need not be the maximum;"
                    },
                    {
                        "username": "Ankroh",
                        "content": "you can jump from 1 to 4 ,not only 4 !!\\nso you will jump to index 3 and from there to last index!"
                    },
                    {
                        "username": "miosokic",
                        "content": "goal it to reach n-1 not nums[n-1]"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "How come this testcase evaluates to the wrong answer for me:\\n\\nnums = [3,2,1]\\noutput = 2\\nexpected = 1\\n\\nHow can you make one jump from index 0 to index 2, when the nums[0] == 3 ?\\n\\nCan somebody please explain this ?"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "Yup realized it later, thanks!"
                    },
                    {
                        "username": "spf4000",
                        "content": "Actually re-read it, 3 is the MAX number of jumps, you can still jump less"
                    },
                    {
                        "username": "spf4000",
                        "content": "I have the same issue. Half the test cases expect you to jump by nums[i] and the other half nums[i]-1"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I found the easiest solution for this was to start at the back end of the array and see what the furthest point towards the front you could reach and then repeat from there. Don\\'t need to worry about 0s or which point reaches further or anything really. Just search the array to find the max value and use that as your maximum steps back."
                    },
                    {
                        "username": "olegmak",
                        "content": "Is this a valid test case?\\n[2,1]\\nI think not because problem states that i + j < n but 0 + 2 < 2 is false (i = 0; j = 2; n = 2)"
                    },
                    {
                        "username": "Kikimora",
                        "content": "May I see all test cases if submit is successful?"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "don\\'t you think that this daily challange was the 3rd greedy problem in a row ...\\nanyways happy leetcode journey to one who is reading."
                    },
                    {
                        "username": "huanda1412",
                        "content": "I interpreted the question as a shortest path question without weightage, so I did a BFS with a queue. Turns out it is not efficient."
                    },
                    {
                        "username": "MaddyM",
                        "content": "It\\'s not the fastest, but it does get a correct solution \\uD83E\\uDEE1"
                    }
                ]
            },
            {
                "id": 1724178,
                "content": [
                    {
                        "username": "user5425SM",
                        "content": "typo in question phrase \"Return the minimum number of jumps to reach nums[n - 1].\" should be \".... number of jumps to reach n-1\""
                    },
                    {
                        "username": "The_error",
                        "content": "I think the question is correct. there can be multiple ways to jump and reach n-1, but it is asking to return the min jump required."
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Instead of going back to front... trying going front to back."
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "Yeah\\nI want to know whether it is possible to solve this with Bottom up approach at all??"
                    },
                    {
                        "username": "abhijat_gupta",
                        "content": "Use case:\\n[4,1,1,3,1,1,1]\\n\\nMentioned expected output:2 jumps\\nCorrect expected output:3 jumps \\n\\nExplanation:\\n\\nwhen at index=0, i.e element=4, once can jump to index=4, i.e., element=1 => jumps=1\\nwhen at index=4, i.e element=1, once can jump to index=5, i.e., element=1 => jumps=2\\nwhen at index=5, i.e element=1, once can jump to index=6, i.e., element=1 => jumps=3\\n\\n\\nFeel free to correct me if I am wrong somewhere.\\n\\nthanks,\\nAbhijat\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "nums[0] -> nums [3] / nums [3] -> nums[6]\n= 2 jumps. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "[@Ankroh](/Ankroh) yah je is correct the value of nums[0] is the maximum jump and the selection of you need not be the maximum;"
                    },
                    {
                        "username": "Ankroh",
                        "content": "you can jump from 1 to 4 ,not only 4 !!\\nso you will jump to index 3 and from there to last index!"
                    },
                    {
                        "username": "miosokic",
                        "content": "goal it to reach n-1 not nums[n-1]"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "How come this testcase evaluates to the wrong answer for me:\\n\\nnums = [3,2,1]\\noutput = 2\\nexpected = 1\\n\\nHow can you make one jump from index 0 to index 2, when the nums[0] == 3 ?\\n\\nCan somebody please explain this ?"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "Yup realized it later, thanks!"
                    },
                    {
                        "username": "spf4000",
                        "content": "Actually re-read it, 3 is the MAX number of jumps, you can still jump less"
                    },
                    {
                        "username": "spf4000",
                        "content": "I have the same issue. Half the test cases expect you to jump by nums[i] and the other half nums[i]-1"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I found the easiest solution for this was to start at the back end of the array and see what the furthest point towards the front you could reach and then repeat from there. Don\\'t need to worry about 0s or which point reaches further or anything really. Just search the array to find the max value and use that as your maximum steps back."
                    },
                    {
                        "username": "olegmak",
                        "content": "Is this a valid test case?\\n[2,1]\\nI think not because problem states that i + j < n but 0 + 2 < 2 is false (i = 0; j = 2; n = 2)"
                    },
                    {
                        "username": "Kikimora",
                        "content": "May I see all test cases if submit is successful?"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "don\\'t you think that this daily challange was the 3rd greedy problem in a row ...\\nanyways happy leetcode journey to one who is reading."
                    },
                    {
                        "username": "huanda1412",
                        "content": "I interpreted the question as a shortest path question without weightage, so I did a BFS with a queue. Turns out it is not efficient."
                    },
                    {
                        "username": "MaddyM",
                        "content": "It\\'s not the fastest, but it does get a correct solution \\uD83E\\uDEE1"
                    }
                ]
            },
            {
                "id": 1978121,
                "content": [
                    {
                        "username": "user5425SM",
                        "content": "typo in question phrase \"Return the minimum number of jumps to reach nums[n - 1].\" should be \".... number of jumps to reach n-1\""
                    },
                    {
                        "username": "The_error",
                        "content": "I think the question is correct. there can be multiple ways to jump and reach n-1, but it is asking to return the min jump required."
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Instead of going back to front... trying going front to back."
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "Yeah\\nI want to know whether it is possible to solve this with Bottom up approach at all??"
                    },
                    {
                        "username": "abhijat_gupta",
                        "content": "Use case:\\n[4,1,1,3,1,1,1]\\n\\nMentioned expected output:2 jumps\\nCorrect expected output:3 jumps \\n\\nExplanation:\\n\\nwhen at index=0, i.e element=4, once can jump to index=4, i.e., element=1 => jumps=1\\nwhen at index=4, i.e element=1, once can jump to index=5, i.e., element=1 => jumps=2\\nwhen at index=5, i.e element=1, once can jump to index=6, i.e., element=1 => jumps=3\\n\\n\\nFeel free to correct me if I am wrong somewhere.\\n\\nthanks,\\nAbhijat\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "nums[0] -> nums [3] / nums [3] -> nums[6]\n= 2 jumps. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "[@Ankroh](/Ankroh) yah je is correct the value of nums[0] is the maximum jump and the selection of you need not be the maximum;"
                    },
                    {
                        "username": "Ankroh",
                        "content": "you can jump from 1 to 4 ,not only 4 !!\\nso you will jump to index 3 and from there to last index!"
                    },
                    {
                        "username": "miosokic",
                        "content": "goal it to reach n-1 not nums[n-1]"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "How come this testcase evaluates to the wrong answer for me:\\n\\nnums = [3,2,1]\\noutput = 2\\nexpected = 1\\n\\nHow can you make one jump from index 0 to index 2, when the nums[0] == 3 ?\\n\\nCan somebody please explain this ?"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "Yup realized it later, thanks!"
                    },
                    {
                        "username": "spf4000",
                        "content": "Actually re-read it, 3 is the MAX number of jumps, you can still jump less"
                    },
                    {
                        "username": "spf4000",
                        "content": "I have the same issue. Half the test cases expect you to jump by nums[i] and the other half nums[i]-1"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I found the easiest solution for this was to start at the back end of the array and see what the furthest point towards the front you could reach and then repeat from there. Don\\'t need to worry about 0s or which point reaches further or anything really. Just search the array to find the max value and use that as your maximum steps back."
                    },
                    {
                        "username": "olegmak",
                        "content": "Is this a valid test case?\\n[2,1]\\nI think not because problem states that i + j < n but 0 + 2 < 2 is false (i = 0; j = 2; n = 2)"
                    },
                    {
                        "username": "Kikimora",
                        "content": "May I see all test cases if submit is successful?"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "don\\'t you think that this daily challange was the 3rd greedy problem in a row ...\\nanyways happy leetcode journey to one who is reading."
                    },
                    {
                        "username": "huanda1412",
                        "content": "I interpreted the question as a shortest path question without weightage, so I did a BFS with a queue. Turns out it is not efficient."
                    },
                    {
                        "username": "MaddyM",
                        "content": "It\\'s not the fastest, but it does get a correct solution \\uD83E\\uDEE1"
                    }
                ]
            },
            {
                "id": 1967279,
                "content": [
                    {
                        "username": "user5425SM",
                        "content": "typo in question phrase \"Return the minimum number of jumps to reach nums[n - 1].\" should be \".... number of jumps to reach n-1\""
                    },
                    {
                        "username": "The_error",
                        "content": "I think the question is correct. there can be multiple ways to jump and reach n-1, but it is asking to return the min jump required."
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Instead of going back to front... trying going front to back."
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "Yeah\\nI want to know whether it is possible to solve this with Bottom up approach at all??"
                    },
                    {
                        "username": "abhijat_gupta",
                        "content": "Use case:\\n[4,1,1,3,1,1,1]\\n\\nMentioned expected output:2 jumps\\nCorrect expected output:3 jumps \\n\\nExplanation:\\n\\nwhen at index=0, i.e element=4, once can jump to index=4, i.e., element=1 => jumps=1\\nwhen at index=4, i.e element=1, once can jump to index=5, i.e., element=1 => jumps=2\\nwhen at index=5, i.e element=1, once can jump to index=6, i.e., element=1 => jumps=3\\n\\n\\nFeel free to correct me if I am wrong somewhere.\\n\\nthanks,\\nAbhijat\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "nums[0] -> nums [3] / nums [3] -> nums[6]\n= 2 jumps. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "[@Ankroh](/Ankroh) yah je is correct the value of nums[0] is the maximum jump and the selection of you need not be the maximum;"
                    },
                    {
                        "username": "Ankroh",
                        "content": "you can jump from 1 to 4 ,not only 4 !!\\nso you will jump to index 3 and from there to last index!"
                    },
                    {
                        "username": "miosokic",
                        "content": "goal it to reach n-1 not nums[n-1]"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "How come this testcase evaluates to the wrong answer for me:\\n\\nnums = [3,2,1]\\noutput = 2\\nexpected = 1\\n\\nHow can you make one jump from index 0 to index 2, when the nums[0] == 3 ?\\n\\nCan somebody please explain this ?"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "Yup realized it later, thanks!"
                    },
                    {
                        "username": "spf4000",
                        "content": "Actually re-read it, 3 is the MAX number of jumps, you can still jump less"
                    },
                    {
                        "username": "spf4000",
                        "content": "I have the same issue. Half the test cases expect you to jump by nums[i] and the other half nums[i]-1"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I found the easiest solution for this was to start at the back end of the array and see what the furthest point towards the front you could reach and then repeat from there. Don\\'t need to worry about 0s or which point reaches further or anything really. Just search the array to find the max value and use that as your maximum steps back."
                    },
                    {
                        "username": "olegmak",
                        "content": "Is this a valid test case?\\n[2,1]\\nI think not because problem states that i + j < n but 0 + 2 < 2 is false (i = 0; j = 2; n = 2)"
                    },
                    {
                        "username": "Kikimora",
                        "content": "May I see all test cases if submit is successful?"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "don\\'t you think that this daily challange was the 3rd greedy problem in a row ...\\nanyways happy leetcode journey to one who is reading."
                    },
                    {
                        "username": "huanda1412",
                        "content": "I interpreted the question as a shortest path question without weightage, so I did a BFS with a queue. Turns out it is not efficient."
                    },
                    {
                        "username": "MaddyM",
                        "content": "It\\'s not the fastest, but it does get a correct solution \\uD83E\\uDEE1"
                    }
                ]
            },
            {
                "id": 1872396,
                "content": [
                    {
                        "username": "user5425SM",
                        "content": "typo in question phrase \"Return the minimum number of jumps to reach nums[n - 1].\" should be \".... number of jumps to reach n-1\""
                    },
                    {
                        "username": "The_error",
                        "content": "I think the question is correct. there can be multiple ways to jump and reach n-1, but it is asking to return the min jump required."
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Instead of going back to front... trying going front to back."
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "Yeah\\nI want to know whether it is possible to solve this with Bottom up approach at all??"
                    },
                    {
                        "username": "abhijat_gupta",
                        "content": "Use case:\\n[4,1,1,3,1,1,1]\\n\\nMentioned expected output:2 jumps\\nCorrect expected output:3 jumps \\n\\nExplanation:\\n\\nwhen at index=0, i.e element=4, once can jump to index=4, i.e., element=1 => jumps=1\\nwhen at index=4, i.e element=1, once can jump to index=5, i.e., element=1 => jumps=2\\nwhen at index=5, i.e element=1, once can jump to index=6, i.e., element=1 => jumps=3\\n\\n\\nFeel free to correct me if I am wrong somewhere.\\n\\nthanks,\\nAbhijat\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "nums[0] -> nums [3] / nums [3] -> nums[6]\n= 2 jumps. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "[@Ankroh](/Ankroh) yah je is correct the value of nums[0] is the maximum jump and the selection of you need not be the maximum;"
                    },
                    {
                        "username": "Ankroh",
                        "content": "you can jump from 1 to 4 ,not only 4 !!\\nso you will jump to index 3 and from there to last index!"
                    },
                    {
                        "username": "miosokic",
                        "content": "goal it to reach n-1 not nums[n-1]"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "How come this testcase evaluates to the wrong answer for me:\\n\\nnums = [3,2,1]\\noutput = 2\\nexpected = 1\\n\\nHow can you make one jump from index 0 to index 2, when the nums[0] == 3 ?\\n\\nCan somebody please explain this ?"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "Yup realized it later, thanks!"
                    },
                    {
                        "username": "spf4000",
                        "content": "Actually re-read it, 3 is the MAX number of jumps, you can still jump less"
                    },
                    {
                        "username": "spf4000",
                        "content": "I have the same issue. Half the test cases expect you to jump by nums[i] and the other half nums[i]-1"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I found the easiest solution for this was to start at the back end of the array and see what the furthest point towards the front you could reach and then repeat from there. Don\\'t need to worry about 0s or which point reaches further or anything really. Just search the array to find the max value and use that as your maximum steps back."
                    },
                    {
                        "username": "olegmak",
                        "content": "Is this a valid test case?\\n[2,1]\\nI think not because problem states that i + j < n but 0 + 2 < 2 is false (i = 0; j = 2; n = 2)"
                    },
                    {
                        "username": "Kikimora",
                        "content": "May I see all test cases if submit is successful?"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "don\\'t you think that this daily challange was the 3rd greedy problem in a row ...\\nanyways happy leetcode journey to one who is reading."
                    },
                    {
                        "username": "huanda1412",
                        "content": "I interpreted the question as a shortest path question without weightage, so I did a BFS with a queue. Turns out it is not efficient."
                    },
                    {
                        "username": "MaddyM",
                        "content": "It\\'s not the fastest, but it does get a correct solution \\uD83E\\uDEE1"
                    }
                ]
            },
            {
                "id": 1793015,
                "content": [
                    {
                        "username": "user5425SM",
                        "content": "typo in question phrase \"Return the minimum number of jumps to reach nums[n - 1].\" should be \".... number of jumps to reach n-1\""
                    },
                    {
                        "username": "The_error",
                        "content": "I think the question is correct. there can be multiple ways to jump and reach n-1, but it is asking to return the min jump required."
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Instead of going back to front... trying going front to back."
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "Yeah\\nI want to know whether it is possible to solve this with Bottom up approach at all??"
                    },
                    {
                        "username": "abhijat_gupta",
                        "content": "Use case:\\n[4,1,1,3,1,1,1]\\n\\nMentioned expected output:2 jumps\\nCorrect expected output:3 jumps \\n\\nExplanation:\\n\\nwhen at index=0, i.e element=4, once can jump to index=4, i.e., element=1 => jumps=1\\nwhen at index=4, i.e element=1, once can jump to index=5, i.e., element=1 => jumps=2\\nwhen at index=5, i.e element=1, once can jump to index=6, i.e., element=1 => jumps=3\\n\\n\\nFeel free to correct me if I am wrong somewhere.\\n\\nthanks,\\nAbhijat\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "nums[0] -> nums [3] / nums [3] -> nums[6]\n= 2 jumps. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "[@Ankroh](/Ankroh) yah je is correct the value of nums[0] is the maximum jump and the selection of you need not be the maximum;"
                    },
                    {
                        "username": "Ankroh",
                        "content": "you can jump from 1 to 4 ,not only 4 !!\\nso you will jump to index 3 and from there to last index!"
                    },
                    {
                        "username": "miosokic",
                        "content": "goal it to reach n-1 not nums[n-1]"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "How come this testcase evaluates to the wrong answer for me:\\n\\nnums = [3,2,1]\\noutput = 2\\nexpected = 1\\n\\nHow can you make one jump from index 0 to index 2, when the nums[0] == 3 ?\\n\\nCan somebody please explain this ?"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "Yup realized it later, thanks!"
                    },
                    {
                        "username": "spf4000",
                        "content": "Actually re-read it, 3 is the MAX number of jumps, you can still jump less"
                    },
                    {
                        "username": "spf4000",
                        "content": "I have the same issue. Half the test cases expect you to jump by nums[i] and the other half nums[i]-1"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I found the easiest solution for this was to start at the back end of the array and see what the furthest point towards the front you could reach and then repeat from there. Don\\'t need to worry about 0s or which point reaches further or anything really. Just search the array to find the max value and use that as your maximum steps back."
                    },
                    {
                        "username": "olegmak",
                        "content": "Is this a valid test case?\\n[2,1]\\nI think not because problem states that i + j < n but 0 + 2 < 2 is false (i = 0; j = 2; n = 2)"
                    },
                    {
                        "username": "Kikimora",
                        "content": "May I see all test cases if submit is successful?"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "don\\'t you think that this daily challange was the 3rd greedy problem in a row ...\\nanyways happy leetcode journey to one who is reading."
                    },
                    {
                        "username": "huanda1412",
                        "content": "I interpreted the question as a shortest path question without weightage, so I did a BFS with a queue. Turns out it is not efficient."
                    },
                    {
                        "username": "MaddyM",
                        "content": "It\\'s not the fastest, but it does get a correct solution \\uD83E\\uDEE1"
                    }
                ]
            },
            {
                "id": 1792990,
                "content": [
                    {
                        "username": "user5425SM",
                        "content": "typo in question phrase \"Return the minimum number of jumps to reach nums[n - 1].\" should be \".... number of jumps to reach n-1\""
                    },
                    {
                        "username": "The_error",
                        "content": "I think the question is correct. there can be multiple ways to jump and reach n-1, but it is asking to return the min jump required."
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Instead of going back to front... trying going front to back."
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "Yeah\\nI want to know whether it is possible to solve this with Bottom up approach at all??"
                    },
                    {
                        "username": "abhijat_gupta",
                        "content": "Use case:\\n[4,1,1,3,1,1,1]\\n\\nMentioned expected output:2 jumps\\nCorrect expected output:3 jumps \\n\\nExplanation:\\n\\nwhen at index=0, i.e element=4, once can jump to index=4, i.e., element=1 => jumps=1\\nwhen at index=4, i.e element=1, once can jump to index=5, i.e., element=1 => jumps=2\\nwhen at index=5, i.e element=1, once can jump to index=6, i.e., element=1 => jumps=3\\n\\n\\nFeel free to correct me if I am wrong somewhere.\\n\\nthanks,\\nAbhijat\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "nums[0] -> nums [3] / nums [3] -> nums[6]\n= 2 jumps. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "[@Ankroh](/Ankroh) yah je is correct the value of nums[0] is the maximum jump and the selection of you need not be the maximum;"
                    },
                    {
                        "username": "Ankroh",
                        "content": "you can jump from 1 to 4 ,not only 4 !!\\nso you will jump to index 3 and from there to last index!"
                    },
                    {
                        "username": "miosokic",
                        "content": "goal it to reach n-1 not nums[n-1]"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "How come this testcase evaluates to the wrong answer for me:\\n\\nnums = [3,2,1]\\noutput = 2\\nexpected = 1\\n\\nHow can you make one jump from index 0 to index 2, when the nums[0] == 3 ?\\n\\nCan somebody please explain this ?"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "Yup realized it later, thanks!"
                    },
                    {
                        "username": "spf4000",
                        "content": "Actually re-read it, 3 is the MAX number of jumps, you can still jump less"
                    },
                    {
                        "username": "spf4000",
                        "content": "I have the same issue. Half the test cases expect you to jump by nums[i] and the other half nums[i]-1"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I found the easiest solution for this was to start at the back end of the array and see what the furthest point towards the front you could reach and then repeat from there. Don\\'t need to worry about 0s or which point reaches further or anything really. Just search the array to find the max value and use that as your maximum steps back."
                    },
                    {
                        "username": "olegmak",
                        "content": "Is this a valid test case?\\n[2,1]\\nI think not because problem states that i + j < n but 0 + 2 < 2 is false (i = 0; j = 2; n = 2)"
                    },
                    {
                        "username": "Kikimora",
                        "content": "May I see all test cases if submit is successful?"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "don\\'t you think that this daily challange was the 3rd greedy problem in a row ...\\nanyways happy leetcode journey to one who is reading."
                    },
                    {
                        "username": "huanda1412",
                        "content": "I interpreted the question as a shortest path question without weightage, so I did a BFS with a queue. Turns out it is not efficient."
                    },
                    {
                        "username": "MaddyM",
                        "content": "It\\'s not the fastest, but it does get a correct solution \\uD83E\\uDEE1"
                    }
                ]
            },
            {
                "id": 1760231,
                "content": [
                    {
                        "username": "user5425SM",
                        "content": "typo in question phrase \"Return the minimum number of jumps to reach nums[n - 1].\" should be \".... number of jumps to reach n-1\""
                    },
                    {
                        "username": "The_error",
                        "content": "I think the question is correct. there can be multiple ways to jump and reach n-1, but it is asking to return the min jump required."
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Instead of going back to front... trying going front to back."
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "Yeah\\nI want to know whether it is possible to solve this with Bottom up approach at all??"
                    },
                    {
                        "username": "abhijat_gupta",
                        "content": "Use case:\\n[4,1,1,3,1,1,1]\\n\\nMentioned expected output:2 jumps\\nCorrect expected output:3 jumps \\n\\nExplanation:\\n\\nwhen at index=0, i.e element=4, once can jump to index=4, i.e., element=1 => jumps=1\\nwhen at index=4, i.e element=1, once can jump to index=5, i.e., element=1 => jumps=2\\nwhen at index=5, i.e element=1, once can jump to index=6, i.e., element=1 => jumps=3\\n\\n\\nFeel free to correct me if I am wrong somewhere.\\n\\nthanks,\\nAbhijat\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "nums[0] -> nums [3] / nums [3] -> nums[6]\n= 2 jumps. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "[@Ankroh](/Ankroh) yah je is correct the value of nums[0] is the maximum jump and the selection of you need not be the maximum;"
                    },
                    {
                        "username": "Ankroh",
                        "content": "you can jump from 1 to 4 ,not only 4 !!\\nso you will jump to index 3 and from there to last index!"
                    },
                    {
                        "username": "miosokic",
                        "content": "goal it to reach n-1 not nums[n-1]"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "How come this testcase evaluates to the wrong answer for me:\\n\\nnums = [3,2,1]\\noutput = 2\\nexpected = 1\\n\\nHow can you make one jump from index 0 to index 2, when the nums[0] == 3 ?\\n\\nCan somebody please explain this ?"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "Yup realized it later, thanks!"
                    },
                    {
                        "username": "spf4000",
                        "content": "Actually re-read it, 3 is the MAX number of jumps, you can still jump less"
                    },
                    {
                        "username": "spf4000",
                        "content": "I have the same issue. Half the test cases expect you to jump by nums[i] and the other half nums[i]-1"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I found the easiest solution for this was to start at the back end of the array and see what the furthest point towards the front you could reach and then repeat from there. Don\\'t need to worry about 0s or which point reaches further or anything really. Just search the array to find the max value and use that as your maximum steps back."
                    },
                    {
                        "username": "olegmak",
                        "content": "Is this a valid test case?\\n[2,1]\\nI think not because problem states that i + j < n but 0 + 2 < 2 is false (i = 0; j = 2; n = 2)"
                    },
                    {
                        "username": "Kikimora",
                        "content": "May I see all test cases if submit is successful?"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "don\\'t you think that this daily challange was the 3rd greedy problem in a row ...\\nanyways happy leetcode journey to one who is reading."
                    },
                    {
                        "username": "huanda1412",
                        "content": "I interpreted the question as a shortest path question without weightage, so I did a BFS with a queue. Turns out it is not efficient."
                    },
                    {
                        "username": "MaddyM",
                        "content": "It\\'s not the fastest, but it does get a correct solution \\uD83E\\uDEE1"
                    }
                ]
            },
            {
                "id": 1715945,
                "content": [
                    {
                        "username": "leopoldkot",
                        "content": "Could someone help with a formal DP recurrent equations for this problem and show what is the optimal subproblem here? I don\\'t see an official submission here and all solutions I found in the solutions are very hand wavy (e.g. using hidden inner loops inside `min` functions) and don\\'t look like DP, especially don\\'t look like a tabulated solution where you would look up a fixed index offset in the past.\\n\\n(Mine solution is a `O(n)` greedy one, but I want to learn to discover DP optimal substructures)."
                    },
                    {
                        "username": "MaddyM",
                        "content": "Breadth first search maybe? Not particularly fast because of how many \"edges\" you can get, but tracking the distance for each visited index is somewhat DPish"
                    },
                    {
                        "username": "andvalsol",
                        "content": "According to the example 1 provided in the example we have the following\\n**Input**: [2,3,1,1,4]\\n**Output**: 2\\n\\nThe previous logic would be choose the first index (2), jump only once and the use the second value (3) and jump three times, ending at the last index, two jumps were needed, therefore the output is two.\\nHowever, for the following:\\n**Input**: [3,2,1]\\n**Output**:  1 \\nAs we can see the expected output is 1, using the same logic the value choosen was 3 which if chosen would jump over the index that we want.\\nDoes this means that it doesn\\xB4t matter if we jump over the last index?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The value is the **maximum** jumping distance. You can jump **up to** that distance. In this case you can jump up to 3 places, but you only need to jump 2 places to land on nums[n-1]. "
                    },
                    {
                        "username": "jlee243",
                        "content": "on the note it says: `You can assume that you can always reach the last index.`, so the description should mention positive integers instead of non-negative integers.  cases like [3,2,1,0,1] should be illegal following the rules that each element in the array represents your max jump length"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Not really. You can design cases with zeros in the array where you'll still be able to reach the last index (check the second example). That's all the description says and it's accurate."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "The problem description says the array has non-negative integers. This means it can has 0. When it evaluates the test cases, if you move into 0 it treats it like a 1. (You can find out this behaviour by running [0,0] and observe the expected answer of 2.) \\n\\nThis reduces the difficulty of the problem and makes the greedy one-pass solution possible to solve all test cases. This makes DP, BFS, DFS, backtrack, etc. over kill.\\n\\nIn my opinion, this problem only deserves a \"hard\" rating if it removes the assumption that the last position can always be reached and requires you to return -1 when it is impossible to move to the last position. And the evaluation has to respect that moving into a 0 means \"you\\'re stuck\".\\n"
                    },
                    {
                        "username": "fengshenfeilian",
                        "content": "You can try to reach max position in every step and update the max position until you reach the last point."
                    },
                    {
                        "username": "superplane",
                        "content": "For input [0,0,0,0,0], the test case gives solution of 4, while the destination can't be reached. Do we assume that the final index can always be reached?"
                    },
                    {
                        "username": "nph87903",
                        "content": "As it is mentioned, all the numbers are non-negative. If we include \"0\". most of the solution would fail.\\n\\nwish to consider this condition or change the description."
                    },
                    {
                        "username": "zhukov",
                        "content": "Since the array may contain 0, it is possible that n -1 is unreachable from 0, e.g.,\\nA[] = {0, 1, 2, 3} or {1, 0, 2, 3}.\\n\\nIf the array only contains positive integers, there always exists a minimum number of steps which is not greater than n - 1 since each step we can advance at least 1 index."
                    },
                    {
                        "username": "MickShow",
                        "content": "![image](https://assets.leetcode.com/users/images/2ecbe54e-b3e5-4c9b-a06a-12351fb5b731_1649493744.2732766.png)\\n"
                    },
                    {
                        "username": "NishchaySharma",
                        "content": "this code cleared 49/109 test cases, is there any possibility to make it pass all of them? what changes can help? \\n\\nvar jump = function(nums) {\\n    let count = 0\\n    if(nums.length <= 1)\\n    return 0\\n    for(let i=0; i<nums.length;i++){\\n        if(nums[i] == nums[0]){\\n            nums[i] = nums[i+1]\\n            ++count;\\n        }\\n    }\\n    return count\\n};"
                    }
                ]
            },
            {
                "id": 1576140,
                "content": [
                    {
                        "username": "leopoldkot",
                        "content": "Could someone help with a formal DP recurrent equations for this problem and show what is the optimal subproblem here? I don\\'t see an official submission here and all solutions I found in the solutions are very hand wavy (e.g. using hidden inner loops inside `min` functions) and don\\'t look like DP, especially don\\'t look like a tabulated solution where you would look up a fixed index offset in the past.\\n\\n(Mine solution is a `O(n)` greedy one, but I want to learn to discover DP optimal substructures)."
                    },
                    {
                        "username": "MaddyM",
                        "content": "Breadth first search maybe? Not particularly fast because of how many \"edges\" you can get, but tracking the distance for each visited index is somewhat DPish"
                    },
                    {
                        "username": "andvalsol",
                        "content": "According to the example 1 provided in the example we have the following\\n**Input**: [2,3,1,1,4]\\n**Output**: 2\\n\\nThe previous logic would be choose the first index (2), jump only once and the use the second value (3) and jump three times, ending at the last index, two jumps were needed, therefore the output is two.\\nHowever, for the following:\\n**Input**: [3,2,1]\\n**Output**:  1 \\nAs we can see the expected output is 1, using the same logic the value choosen was 3 which if chosen would jump over the index that we want.\\nDoes this means that it doesn\\xB4t matter if we jump over the last index?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The value is the **maximum** jumping distance. You can jump **up to** that distance. In this case you can jump up to 3 places, but you only need to jump 2 places to land on nums[n-1]. "
                    },
                    {
                        "username": "jlee243",
                        "content": "on the note it says: `You can assume that you can always reach the last index.`, so the description should mention positive integers instead of non-negative integers.  cases like [3,2,1,0,1] should be illegal following the rules that each element in the array represents your max jump length"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Not really. You can design cases with zeros in the array where you'll still be able to reach the last index (check the second example). That's all the description says and it's accurate."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "The problem description says the array has non-negative integers. This means it can has 0. When it evaluates the test cases, if you move into 0 it treats it like a 1. (You can find out this behaviour by running [0,0] and observe the expected answer of 2.) \\n\\nThis reduces the difficulty of the problem and makes the greedy one-pass solution possible to solve all test cases. This makes DP, BFS, DFS, backtrack, etc. over kill.\\n\\nIn my opinion, this problem only deserves a \"hard\" rating if it removes the assumption that the last position can always be reached and requires you to return -1 when it is impossible to move to the last position. And the evaluation has to respect that moving into a 0 means \"you\\'re stuck\".\\n"
                    },
                    {
                        "username": "fengshenfeilian",
                        "content": "You can try to reach max position in every step and update the max position until you reach the last point."
                    },
                    {
                        "username": "superplane",
                        "content": "For input [0,0,0,0,0], the test case gives solution of 4, while the destination can't be reached. Do we assume that the final index can always be reached?"
                    },
                    {
                        "username": "nph87903",
                        "content": "As it is mentioned, all the numbers are non-negative. If we include \"0\". most of the solution would fail.\\n\\nwish to consider this condition or change the description."
                    },
                    {
                        "username": "zhukov",
                        "content": "Since the array may contain 0, it is possible that n -1 is unreachable from 0, e.g.,\\nA[] = {0, 1, 2, 3} or {1, 0, 2, 3}.\\n\\nIf the array only contains positive integers, there always exists a minimum number of steps which is not greater than n - 1 since each step we can advance at least 1 index."
                    },
                    {
                        "username": "MickShow",
                        "content": "![image](https://assets.leetcode.com/users/images/2ecbe54e-b3e5-4c9b-a06a-12351fb5b731_1649493744.2732766.png)\\n"
                    },
                    {
                        "username": "NishchaySharma",
                        "content": "this code cleared 49/109 test cases, is there any possibility to make it pass all of them? what changes can help? \\n\\nvar jump = function(nums) {\\n    let count = 0\\n    if(nums.length <= 1)\\n    return 0\\n    for(let i=0; i<nums.length;i++){\\n        if(nums[i] == nums[0]){\\n            nums[i] = nums[i+1]\\n            ++count;\\n        }\\n    }\\n    return count\\n};"
                    }
                ]
            },
            {
                "id": 1572683,
                "content": [
                    {
                        "username": "leopoldkot",
                        "content": "Could someone help with a formal DP recurrent equations for this problem and show what is the optimal subproblem here? I don\\'t see an official submission here and all solutions I found in the solutions are very hand wavy (e.g. using hidden inner loops inside `min` functions) and don\\'t look like DP, especially don\\'t look like a tabulated solution where you would look up a fixed index offset in the past.\\n\\n(Mine solution is a `O(n)` greedy one, but I want to learn to discover DP optimal substructures)."
                    },
                    {
                        "username": "MaddyM",
                        "content": "Breadth first search maybe? Not particularly fast because of how many \"edges\" you can get, but tracking the distance for each visited index is somewhat DPish"
                    },
                    {
                        "username": "andvalsol",
                        "content": "According to the example 1 provided in the example we have the following\\n**Input**: [2,3,1,1,4]\\n**Output**: 2\\n\\nThe previous logic would be choose the first index (2), jump only once and the use the second value (3) and jump three times, ending at the last index, two jumps were needed, therefore the output is two.\\nHowever, for the following:\\n**Input**: [3,2,1]\\n**Output**:  1 \\nAs we can see the expected output is 1, using the same logic the value choosen was 3 which if chosen would jump over the index that we want.\\nDoes this means that it doesn\\xB4t matter if we jump over the last index?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The value is the **maximum** jumping distance. You can jump **up to** that distance. In this case you can jump up to 3 places, but you only need to jump 2 places to land on nums[n-1]. "
                    },
                    {
                        "username": "jlee243",
                        "content": "on the note it says: `You can assume that you can always reach the last index.`, so the description should mention positive integers instead of non-negative integers.  cases like [3,2,1,0,1] should be illegal following the rules that each element in the array represents your max jump length"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Not really. You can design cases with zeros in the array where you'll still be able to reach the last index (check the second example). That's all the description says and it's accurate."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "The problem description says the array has non-negative integers. This means it can has 0. When it evaluates the test cases, if you move into 0 it treats it like a 1. (You can find out this behaviour by running [0,0] and observe the expected answer of 2.) \\n\\nThis reduces the difficulty of the problem and makes the greedy one-pass solution possible to solve all test cases. This makes DP, BFS, DFS, backtrack, etc. over kill.\\n\\nIn my opinion, this problem only deserves a \"hard\" rating if it removes the assumption that the last position can always be reached and requires you to return -1 when it is impossible to move to the last position. And the evaluation has to respect that moving into a 0 means \"you\\'re stuck\".\\n"
                    },
                    {
                        "username": "fengshenfeilian",
                        "content": "You can try to reach max position in every step and update the max position until you reach the last point."
                    },
                    {
                        "username": "superplane",
                        "content": "For input [0,0,0,0,0], the test case gives solution of 4, while the destination can't be reached. Do we assume that the final index can always be reached?"
                    },
                    {
                        "username": "nph87903",
                        "content": "As it is mentioned, all the numbers are non-negative. If we include \"0\". most of the solution would fail.\\n\\nwish to consider this condition or change the description."
                    },
                    {
                        "username": "zhukov",
                        "content": "Since the array may contain 0, it is possible that n -1 is unreachable from 0, e.g.,\\nA[] = {0, 1, 2, 3} or {1, 0, 2, 3}.\\n\\nIf the array only contains positive integers, there always exists a minimum number of steps which is not greater than n - 1 since each step we can advance at least 1 index."
                    },
                    {
                        "username": "MickShow",
                        "content": "![image](https://assets.leetcode.com/users/images/2ecbe54e-b3e5-4c9b-a06a-12351fb5b731_1649493744.2732766.png)\\n"
                    },
                    {
                        "username": "NishchaySharma",
                        "content": "this code cleared 49/109 test cases, is there any possibility to make it pass all of them? what changes can help? \\n\\nvar jump = function(nums) {\\n    let count = 0\\n    if(nums.length <= 1)\\n    return 0\\n    for(let i=0; i<nums.length;i++){\\n        if(nums[i] == nums[0]){\\n            nums[i] = nums[i+1]\\n            ++count;\\n        }\\n    }\\n    return count\\n};"
                    }
                ]
            },
            {
                "id": 1572500,
                "content": [
                    {
                        "username": "leopoldkot",
                        "content": "Could someone help with a formal DP recurrent equations for this problem and show what is the optimal subproblem here? I don\\'t see an official submission here and all solutions I found in the solutions are very hand wavy (e.g. using hidden inner loops inside `min` functions) and don\\'t look like DP, especially don\\'t look like a tabulated solution where you would look up a fixed index offset in the past.\\n\\n(Mine solution is a `O(n)` greedy one, but I want to learn to discover DP optimal substructures)."
                    },
                    {
                        "username": "MaddyM",
                        "content": "Breadth first search maybe? Not particularly fast because of how many \"edges\" you can get, but tracking the distance for each visited index is somewhat DPish"
                    },
                    {
                        "username": "andvalsol",
                        "content": "According to the example 1 provided in the example we have the following\\n**Input**: [2,3,1,1,4]\\n**Output**: 2\\n\\nThe previous logic would be choose the first index (2), jump only once and the use the second value (3) and jump three times, ending at the last index, two jumps were needed, therefore the output is two.\\nHowever, for the following:\\n**Input**: [3,2,1]\\n**Output**:  1 \\nAs we can see the expected output is 1, using the same logic the value choosen was 3 which if chosen would jump over the index that we want.\\nDoes this means that it doesn\\xB4t matter if we jump over the last index?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The value is the **maximum** jumping distance. You can jump **up to** that distance. In this case you can jump up to 3 places, but you only need to jump 2 places to land on nums[n-1]. "
                    },
                    {
                        "username": "jlee243",
                        "content": "on the note it says: `You can assume that you can always reach the last index.`, so the description should mention positive integers instead of non-negative integers.  cases like [3,2,1,0,1] should be illegal following the rules that each element in the array represents your max jump length"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Not really. You can design cases with zeros in the array where you'll still be able to reach the last index (check the second example). That's all the description says and it's accurate."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "The problem description says the array has non-negative integers. This means it can has 0. When it evaluates the test cases, if you move into 0 it treats it like a 1. (You can find out this behaviour by running [0,0] and observe the expected answer of 2.) \\n\\nThis reduces the difficulty of the problem and makes the greedy one-pass solution possible to solve all test cases. This makes DP, BFS, DFS, backtrack, etc. over kill.\\n\\nIn my opinion, this problem only deserves a \"hard\" rating if it removes the assumption that the last position can always be reached and requires you to return -1 when it is impossible to move to the last position. And the evaluation has to respect that moving into a 0 means \"you\\'re stuck\".\\n"
                    },
                    {
                        "username": "fengshenfeilian",
                        "content": "You can try to reach max position in every step and update the max position until you reach the last point."
                    },
                    {
                        "username": "superplane",
                        "content": "For input [0,0,0,0,0], the test case gives solution of 4, while the destination can't be reached. Do we assume that the final index can always be reached?"
                    },
                    {
                        "username": "nph87903",
                        "content": "As it is mentioned, all the numbers are non-negative. If we include \"0\". most of the solution would fail.\\n\\nwish to consider this condition or change the description."
                    },
                    {
                        "username": "zhukov",
                        "content": "Since the array may contain 0, it is possible that n -1 is unreachable from 0, e.g.,\\nA[] = {0, 1, 2, 3} or {1, 0, 2, 3}.\\n\\nIf the array only contains positive integers, there always exists a minimum number of steps which is not greater than n - 1 since each step we can advance at least 1 index."
                    },
                    {
                        "username": "MickShow",
                        "content": "![image](https://assets.leetcode.com/users/images/2ecbe54e-b3e5-4c9b-a06a-12351fb5b731_1649493744.2732766.png)\\n"
                    },
                    {
                        "username": "NishchaySharma",
                        "content": "this code cleared 49/109 test cases, is there any possibility to make it pass all of them? what changes can help? \\n\\nvar jump = function(nums) {\\n    let count = 0\\n    if(nums.length <= 1)\\n    return 0\\n    for(let i=0; i<nums.length;i++){\\n        if(nums[i] == nums[0]){\\n            nums[i] = nums[i+1]\\n            ++count;\\n        }\\n    }\\n    return count\\n};"
                    }
                ]
            },
            {
                "id": 1572142,
                "content": [
                    {
                        "username": "leopoldkot",
                        "content": "Could someone help with a formal DP recurrent equations for this problem and show what is the optimal subproblem here? I don\\'t see an official submission here and all solutions I found in the solutions are very hand wavy (e.g. using hidden inner loops inside `min` functions) and don\\'t look like DP, especially don\\'t look like a tabulated solution where you would look up a fixed index offset in the past.\\n\\n(Mine solution is a `O(n)` greedy one, but I want to learn to discover DP optimal substructures)."
                    },
                    {
                        "username": "MaddyM",
                        "content": "Breadth first search maybe? Not particularly fast because of how many \"edges\" you can get, but tracking the distance for each visited index is somewhat DPish"
                    },
                    {
                        "username": "andvalsol",
                        "content": "According to the example 1 provided in the example we have the following\\n**Input**: [2,3,1,1,4]\\n**Output**: 2\\n\\nThe previous logic would be choose the first index (2), jump only once and the use the second value (3) and jump three times, ending at the last index, two jumps were needed, therefore the output is two.\\nHowever, for the following:\\n**Input**: [3,2,1]\\n**Output**:  1 \\nAs we can see the expected output is 1, using the same logic the value choosen was 3 which if chosen would jump over the index that we want.\\nDoes this means that it doesn\\xB4t matter if we jump over the last index?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The value is the **maximum** jumping distance. You can jump **up to** that distance. In this case you can jump up to 3 places, but you only need to jump 2 places to land on nums[n-1]. "
                    },
                    {
                        "username": "jlee243",
                        "content": "on the note it says: `You can assume that you can always reach the last index.`, so the description should mention positive integers instead of non-negative integers.  cases like [3,2,1,0,1] should be illegal following the rules that each element in the array represents your max jump length"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Not really. You can design cases with zeros in the array where you'll still be able to reach the last index (check the second example). That's all the description says and it's accurate."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "The problem description says the array has non-negative integers. This means it can has 0. When it evaluates the test cases, if you move into 0 it treats it like a 1. (You can find out this behaviour by running [0,0] and observe the expected answer of 2.) \\n\\nThis reduces the difficulty of the problem and makes the greedy one-pass solution possible to solve all test cases. This makes DP, BFS, DFS, backtrack, etc. over kill.\\n\\nIn my opinion, this problem only deserves a \"hard\" rating if it removes the assumption that the last position can always be reached and requires you to return -1 when it is impossible to move to the last position. And the evaluation has to respect that moving into a 0 means \"you\\'re stuck\".\\n"
                    },
                    {
                        "username": "fengshenfeilian",
                        "content": "You can try to reach max position in every step and update the max position until you reach the last point."
                    },
                    {
                        "username": "superplane",
                        "content": "For input [0,0,0,0,0], the test case gives solution of 4, while the destination can't be reached. Do we assume that the final index can always be reached?"
                    },
                    {
                        "username": "nph87903",
                        "content": "As it is mentioned, all the numbers are non-negative. If we include \"0\". most of the solution would fail.\\n\\nwish to consider this condition or change the description."
                    },
                    {
                        "username": "zhukov",
                        "content": "Since the array may contain 0, it is possible that n -1 is unreachable from 0, e.g.,\\nA[] = {0, 1, 2, 3} or {1, 0, 2, 3}.\\n\\nIf the array only contains positive integers, there always exists a minimum number of steps which is not greater than n - 1 since each step we can advance at least 1 index."
                    },
                    {
                        "username": "MickShow",
                        "content": "![image](https://assets.leetcode.com/users/images/2ecbe54e-b3e5-4c9b-a06a-12351fb5b731_1649493744.2732766.png)\\n"
                    },
                    {
                        "username": "NishchaySharma",
                        "content": "this code cleared 49/109 test cases, is there any possibility to make it pass all of them? what changes can help? \\n\\nvar jump = function(nums) {\\n    let count = 0\\n    if(nums.length <= 1)\\n    return 0\\n    for(let i=0; i<nums.length;i++){\\n        if(nums[i] == nums[0]){\\n            nums[i] = nums[i+1]\\n            ++count;\\n        }\\n    }\\n    return count\\n};"
                    }
                ]
            },
            {
                "id": 1571110,
                "content": [
                    {
                        "username": "leopoldkot",
                        "content": "Could someone help with a formal DP recurrent equations for this problem and show what is the optimal subproblem here? I don\\'t see an official submission here and all solutions I found in the solutions are very hand wavy (e.g. using hidden inner loops inside `min` functions) and don\\'t look like DP, especially don\\'t look like a tabulated solution where you would look up a fixed index offset in the past.\\n\\n(Mine solution is a `O(n)` greedy one, but I want to learn to discover DP optimal substructures)."
                    },
                    {
                        "username": "MaddyM",
                        "content": "Breadth first search maybe? Not particularly fast because of how many \"edges\" you can get, but tracking the distance for each visited index is somewhat DPish"
                    },
                    {
                        "username": "andvalsol",
                        "content": "According to the example 1 provided in the example we have the following\\n**Input**: [2,3,1,1,4]\\n**Output**: 2\\n\\nThe previous logic would be choose the first index (2), jump only once and the use the second value (3) and jump three times, ending at the last index, two jumps were needed, therefore the output is two.\\nHowever, for the following:\\n**Input**: [3,2,1]\\n**Output**:  1 \\nAs we can see the expected output is 1, using the same logic the value choosen was 3 which if chosen would jump over the index that we want.\\nDoes this means that it doesn\\xB4t matter if we jump over the last index?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The value is the **maximum** jumping distance. You can jump **up to** that distance. In this case you can jump up to 3 places, but you only need to jump 2 places to land on nums[n-1]. "
                    },
                    {
                        "username": "jlee243",
                        "content": "on the note it says: `You can assume that you can always reach the last index.`, so the description should mention positive integers instead of non-negative integers.  cases like [3,2,1,0,1] should be illegal following the rules that each element in the array represents your max jump length"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Not really. You can design cases with zeros in the array where you'll still be able to reach the last index (check the second example). That's all the description says and it's accurate."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "The problem description says the array has non-negative integers. This means it can has 0. When it evaluates the test cases, if you move into 0 it treats it like a 1. (You can find out this behaviour by running [0,0] and observe the expected answer of 2.) \\n\\nThis reduces the difficulty of the problem and makes the greedy one-pass solution possible to solve all test cases. This makes DP, BFS, DFS, backtrack, etc. over kill.\\n\\nIn my opinion, this problem only deserves a \"hard\" rating if it removes the assumption that the last position can always be reached and requires you to return -1 when it is impossible to move to the last position. And the evaluation has to respect that moving into a 0 means \"you\\'re stuck\".\\n"
                    },
                    {
                        "username": "fengshenfeilian",
                        "content": "You can try to reach max position in every step and update the max position until you reach the last point."
                    },
                    {
                        "username": "superplane",
                        "content": "For input [0,0,0,0,0], the test case gives solution of 4, while the destination can't be reached. Do we assume that the final index can always be reached?"
                    },
                    {
                        "username": "nph87903",
                        "content": "As it is mentioned, all the numbers are non-negative. If we include \"0\". most of the solution would fail.\\n\\nwish to consider this condition or change the description."
                    },
                    {
                        "username": "zhukov",
                        "content": "Since the array may contain 0, it is possible that n -1 is unreachable from 0, e.g.,\\nA[] = {0, 1, 2, 3} or {1, 0, 2, 3}.\\n\\nIf the array only contains positive integers, there always exists a minimum number of steps which is not greater than n - 1 since each step we can advance at least 1 index."
                    },
                    {
                        "username": "MickShow",
                        "content": "![image](https://assets.leetcode.com/users/images/2ecbe54e-b3e5-4c9b-a06a-12351fb5b731_1649493744.2732766.png)\\n"
                    },
                    {
                        "username": "NishchaySharma",
                        "content": "this code cleared 49/109 test cases, is there any possibility to make it pass all of them? what changes can help? \\n\\nvar jump = function(nums) {\\n    let count = 0\\n    if(nums.length <= 1)\\n    return 0\\n    for(let i=0; i<nums.length;i++){\\n        if(nums[i] == nums[0]){\\n            nums[i] = nums[i+1]\\n            ++count;\\n        }\\n    }\\n    return count\\n};"
                    }
                ]
            },
            {
                "id": 1571111,
                "content": [
                    {
                        "username": "leopoldkot",
                        "content": "Could someone help with a formal DP recurrent equations for this problem and show what is the optimal subproblem here? I don\\'t see an official submission here and all solutions I found in the solutions are very hand wavy (e.g. using hidden inner loops inside `min` functions) and don\\'t look like DP, especially don\\'t look like a tabulated solution where you would look up a fixed index offset in the past.\\n\\n(Mine solution is a `O(n)` greedy one, but I want to learn to discover DP optimal substructures)."
                    },
                    {
                        "username": "MaddyM",
                        "content": "Breadth first search maybe? Not particularly fast because of how many \"edges\" you can get, but tracking the distance for each visited index is somewhat DPish"
                    },
                    {
                        "username": "andvalsol",
                        "content": "According to the example 1 provided in the example we have the following\\n**Input**: [2,3,1,1,4]\\n**Output**: 2\\n\\nThe previous logic would be choose the first index (2), jump only once and the use the second value (3) and jump three times, ending at the last index, two jumps were needed, therefore the output is two.\\nHowever, for the following:\\n**Input**: [3,2,1]\\n**Output**:  1 \\nAs we can see the expected output is 1, using the same logic the value choosen was 3 which if chosen would jump over the index that we want.\\nDoes this means that it doesn\\xB4t matter if we jump over the last index?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The value is the **maximum** jumping distance. You can jump **up to** that distance. In this case you can jump up to 3 places, but you only need to jump 2 places to land on nums[n-1]. "
                    },
                    {
                        "username": "jlee243",
                        "content": "on the note it says: `You can assume that you can always reach the last index.`, so the description should mention positive integers instead of non-negative integers.  cases like [3,2,1,0,1] should be illegal following the rules that each element in the array represents your max jump length"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Not really. You can design cases with zeros in the array where you'll still be able to reach the last index (check the second example). That's all the description says and it's accurate."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "The problem description says the array has non-negative integers. This means it can has 0. When it evaluates the test cases, if you move into 0 it treats it like a 1. (You can find out this behaviour by running [0,0] and observe the expected answer of 2.) \\n\\nThis reduces the difficulty of the problem and makes the greedy one-pass solution possible to solve all test cases. This makes DP, BFS, DFS, backtrack, etc. over kill.\\n\\nIn my opinion, this problem only deserves a \"hard\" rating if it removes the assumption that the last position can always be reached and requires you to return -1 when it is impossible to move to the last position. And the evaluation has to respect that moving into a 0 means \"you\\'re stuck\".\\n"
                    },
                    {
                        "username": "fengshenfeilian",
                        "content": "You can try to reach max position in every step and update the max position until you reach the last point."
                    },
                    {
                        "username": "superplane",
                        "content": "For input [0,0,0,0,0], the test case gives solution of 4, while the destination can't be reached. Do we assume that the final index can always be reached?"
                    },
                    {
                        "username": "nph87903",
                        "content": "As it is mentioned, all the numbers are non-negative. If we include \"0\". most of the solution would fail.\\n\\nwish to consider this condition or change the description."
                    },
                    {
                        "username": "zhukov",
                        "content": "Since the array may contain 0, it is possible that n -1 is unreachable from 0, e.g.,\\nA[] = {0, 1, 2, 3} or {1, 0, 2, 3}.\\n\\nIf the array only contains positive integers, there always exists a minimum number of steps which is not greater than n - 1 since each step we can advance at least 1 index."
                    },
                    {
                        "username": "MickShow",
                        "content": "![image](https://assets.leetcode.com/users/images/2ecbe54e-b3e5-4c9b-a06a-12351fb5b731_1649493744.2732766.png)\\n"
                    },
                    {
                        "username": "NishchaySharma",
                        "content": "this code cleared 49/109 test cases, is there any possibility to make it pass all of them? what changes can help? \\n\\nvar jump = function(nums) {\\n    let count = 0\\n    if(nums.length <= 1)\\n    return 0\\n    for(let i=0; i<nums.length;i++){\\n        if(nums[i] == nums[0]){\\n            nums[i] = nums[i+1]\\n            ++count;\\n        }\\n    }\\n    return count\\n};"
                    }
                ]
            },
            {
                "id": 1571112,
                "content": [
                    {
                        "username": "leopoldkot",
                        "content": "Could someone help with a formal DP recurrent equations for this problem and show what is the optimal subproblem here? I don\\'t see an official submission here and all solutions I found in the solutions are very hand wavy (e.g. using hidden inner loops inside `min` functions) and don\\'t look like DP, especially don\\'t look like a tabulated solution where you would look up a fixed index offset in the past.\\n\\n(Mine solution is a `O(n)` greedy one, but I want to learn to discover DP optimal substructures)."
                    },
                    {
                        "username": "MaddyM",
                        "content": "Breadth first search maybe? Not particularly fast because of how many \"edges\" you can get, but tracking the distance for each visited index is somewhat DPish"
                    },
                    {
                        "username": "andvalsol",
                        "content": "According to the example 1 provided in the example we have the following\\n**Input**: [2,3,1,1,4]\\n**Output**: 2\\n\\nThe previous logic would be choose the first index (2), jump only once and the use the second value (3) and jump three times, ending at the last index, two jumps were needed, therefore the output is two.\\nHowever, for the following:\\n**Input**: [3,2,1]\\n**Output**:  1 \\nAs we can see the expected output is 1, using the same logic the value choosen was 3 which if chosen would jump over the index that we want.\\nDoes this means that it doesn\\xB4t matter if we jump over the last index?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The value is the **maximum** jumping distance. You can jump **up to** that distance. In this case you can jump up to 3 places, but you only need to jump 2 places to land on nums[n-1]. "
                    },
                    {
                        "username": "jlee243",
                        "content": "on the note it says: `You can assume that you can always reach the last index.`, so the description should mention positive integers instead of non-negative integers.  cases like [3,2,1,0,1] should be illegal following the rules that each element in the array represents your max jump length"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Not really. You can design cases with zeros in the array where you'll still be able to reach the last index (check the second example). That's all the description says and it's accurate."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "The problem description says the array has non-negative integers. This means it can has 0. When it evaluates the test cases, if you move into 0 it treats it like a 1. (You can find out this behaviour by running [0,0] and observe the expected answer of 2.) \\n\\nThis reduces the difficulty of the problem and makes the greedy one-pass solution possible to solve all test cases. This makes DP, BFS, DFS, backtrack, etc. over kill.\\n\\nIn my opinion, this problem only deserves a \"hard\" rating if it removes the assumption that the last position can always be reached and requires you to return -1 when it is impossible to move to the last position. And the evaluation has to respect that moving into a 0 means \"you\\'re stuck\".\\n"
                    },
                    {
                        "username": "fengshenfeilian",
                        "content": "You can try to reach max position in every step and update the max position until you reach the last point."
                    },
                    {
                        "username": "superplane",
                        "content": "For input [0,0,0,0,0], the test case gives solution of 4, while the destination can't be reached. Do we assume that the final index can always be reached?"
                    },
                    {
                        "username": "nph87903",
                        "content": "As it is mentioned, all the numbers are non-negative. If we include \"0\". most of the solution would fail.\\n\\nwish to consider this condition or change the description."
                    },
                    {
                        "username": "zhukov",
                        "content": "Since the array may contain 0, it is possible that n -1 is unreachable from 0, e.g.,\\nA[] = {0, 1, 2, 3} or {1, 0, 2, 3}.\\n\\nIf the array only contains positive integers, there always exists a minimum number of steps which is not greater than n - 1 since each step we can advance at least 1 index."
                    },
                    {
                        "username": "MickShow",
                        "content": "![image](https://assets.leetcode.com/users/images/2ecbe54e-b3e5-4c9b-a06a-12351fb5b731_1649493744.2732766.png)\\n"
                    },
                    {
                        "username": "NishchaySharma",
                        "content": "this code cleared 49/109 test cases, is there any possibility to make it pass all of them? what changes can help? \\n\\nvar jump = function(nums) {\\n    let count = 0\\n    if(nums.length <= 1)\\n    return 0\\n    for(let i=0; i<nums.length;i++){\\n        if(nums[i] == nums[0]){\\n            nums[i] = nums[i+1]\\n            ++count;\\n        }\\n    }\\n    return count\\n};"
                    }
                ]
            },
            {
                "id": 1576598,
                "content": [
                    {
                        "username": "leopoldkot",
                        "content": "Could someone help with a formal DP recurrent equations for this problem and show what is the optimal subproblem here? I don\\'t see an official submission here and all solutions I found in the solutions are very hand wavy (e.g. using hidden inner loops inside `min` functions) and don\\'t look like DP, especially don\\'t look like a tabulated solution where you would look up a fixed index offset in the past.\\n\\n(Mine solution is a `O(n)` greedy one, but I want to learn to discover DP optimal substructures)."
                    },
                    {
                        "username": "MaddyM",
                        "content": "Breadth first search maybe? Not particularly fast because of how many \"edges\" you can get, but tracking the distance for each visited index is somewhat DPish"
                    },
                    {
                        "username": "andvalsol",
                        "content": "According to the example 1 provided in the example we have the following\\n**Input**: [2,3,1,1,4]\\n**Output**: 2\\n\\nThe previous logic would be choose the first index (2), jump only once and the use the second value (3) and jump three times, ending at the last index, two jumps were needed, therefore the output is two.\\nHowever, for the following:\\n**Input**: [3,2,1]\\n**Output**:  1 \\nAs we can see the expected output is 1, using the same logic the value choosen was 3 which if chosen would jump over the index that we want.\\nDoes this means that it doesn\\xB4t matter if we jump over the last index?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The value is the **maximum** jumping distance. You can jump **up to** that distance. In this case you can jump up to 3 places, but you only need to jump 2 places to land on nums[n-1]. "
                    },
                    {
                        "username": "jlee243",
                        "content": "on the note it says: `You can assume that you can always reach the last index.`, so the description should mention positive integers instead of non-negative integers.  cases like [3,2,1,0,1] should be illegal following the rules that each element in the array represents your max jump length"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Not really. You can design cases with zeros in the array where you'll still be able to reach the last index (check the second example). That's all the description says and it's accurate."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "The problem description says the array has non-negative integers. This means it can has 0. When it evaluates the test cases, if you move into 0 it treats it like a 1. (You can find out this behaviour by running [0,0] and observe the expected answer of 2.) \\n\\nThis reduces the difficulty of the problem and makes the greedy one-pass solution possible to solve all test cases. This makes DP, BFS, DFS, backtrack, etc. over kill.\\n\\nIn my opinion, this problem only deserves a \"hard\" rating if it removes the assumption that the last position can always be reached and requires you to return -1 when it is impossible to move to the last position. And the evaluation has to respect that moving into a 0 means \"you\\'re stuck\".\\n"
                    },
                    {
                        "username": "fengshenfeilian",
                        "content": "You can try to reach max position in every step and update the max position until you reach the last point."
                    },
                    {
                        "username": "superplane",
                        "content": "For input [0,0,0,0,0], the test case gives solution of 4, while the destination can't be reached. Do we assume that the final index can always be reached?"
                    },
                    {
                        "username": "nph87903",
                        "content": "As it is mentioned, all the numbers are non-negative. If we include \"0\". most of the solution would fail.\\n\\nwish to consider this condition or change the description."
                    },
                    {
                        "username": "zhukov",
                        "content": "Since the array may contain 0, it is possible that n -1 is unreachable from 0, e.g.,\\nA[] = {0, 1, 2, 3} or {1, 0, 2, 3}.\\n\\nIf the array only contains positive integers, there always exists a minimum number of steps which is not greater than n - 1 since each step we can advance at least 1 index."
                    },
                    {
                        "username": "MickShow",
                        "content": "![image](https://assets.leetcode.com/users/images/2ecbe54e-b3e5-4c9b-a06a-12351fb5b731_1649493744.2732766.png)\\n"
                    },
                    {
                        "username": "NishchaySharma",
                        "content": "this code cleared 49/109 test cases, is there any possibility to make it pass all of them? what changes can help? \\n\\nvar jump = function(nums) {\\n    let count = 0\\n    if(nums.length <= 1)\\n    return 0\\n    for(let i=0; i<nums.length;i++){\\n        if(nums[i] == nums[0]){\\n            nums[i] = nums[i+1]\\n            ++count;\\n        }\\n    }\\n    return count\\n};"
                    }
                ]
            },
            {
                "id": 2041431,
                "content": [
                    {
                        "username": "leopoldkot",
                        "content": "Could someone help with a formal DP recurrent equations for this problem and show what is the optimal subproblem here? I don\\'t see an official submission here and all solutions I found in the solutions are very hand wavy (e.g. using hidden inner loops inside `min` functions) and don\\'t look like DP, especially don\\'t look like a tabulated solution where you would look up a fixed index offset in the past.\\n\\n(Mine solution is a `O(n)` greedy one, but I want to learn to discover DP optimal substructures)."
                    },
                    {
                        "username": "MaddyM",
                        "content": "Breadth first search maybe? Not particularly fast because of how many \"edges\" you can get, but tracking the distance for each visited index is somewhat DPish"
                    },
                    {
                        "username": "andvalsol",
                        "content": "According to the example 1 provided in the example we have the following\\n**Input**: [2,3,1,1,4]\\n**Output**: 2\\n\\nThe previous logic would be choose the first index (2), jump only once and the use the second value (3) and jump three times, ending at the last index, two jumps were needed, therefore the output is two.\\nHowever, for the following:\\n**Input**: [3,2,1]\\n**Output**:  1 \\nAs we can see the expected output is 1, using the same logic the value choosen was 3 which if chosen would jump over the index that we want.\\nDoes this means that it doesn\\xB4t matter if we jump over the last index?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The value is the **maximum** jumping distance. You can jump **up to** that distance. In this case you can jump up to 3 places, but you only need to jump 2 places to land on nums[n-1]. "
                    },
                    {
                        "username": "jlee243",
                        "content": "on the note it says: `You can assume that you can always reach the last index.`, so the description should mention positive integers instead of non-negative integers.  cases like [3,2,1,0,1] should be illegal following the rules that each element in the array represents your max jump length"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Not really. You can design cases with zeros in the array where you'll still be able to reach the last index (check the second example). That's all the description says and it's accurate."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "The problem description says the array has non-negative integers. This means it can has 0. When it evaluates the test cases, if you move into 0 it treats it like a 1. (You can find out this behaviour by running [0,0] and observe the expected answer of 2.) \\n\\nThis reduces the difficulty of the problem and makes the greedy one-pass solution possible to solve all test cases. This makes DP, BFS, DFS, backtrack, etc. over kill.\\n\\nIn my opinion, this problem only deserves a \"hard\" rating if it removes the assumption that the last position can always be reached and requires you to return -1 when it is impossible to move to the last position. And the evaluation has to respect that moving into a 0 means \"you\\'re stuck\".\\n"
                    },
                    {
                        "username": "fengshenfeilian",
                        "content": "You can try to reach max position in every step and update the max position until you reach the last point."
                    },
                    {
                        "username": "superplane",
                        "content": "For input [0,0,0,0,0], the test case gives solution of 4, while the destination can't be reached. Do we assume that the final index can always be reached?"
                    },
                    {
                        "username": "nph87903",
                        "content": "As it is mentioned, all the numbers are non-negative. If we include \"0\". most of the solution would fail.\\n\\nwish to consider this condition or change the description."
                    },
                    {
                        "username": "zhukov",
                        "content": "Since the array may contain 0, it is possible that n -1 is unreachable from 0, e.g.,\\nA[] = {0, 1, 2, 3} or {1, 0, 2, 3}.\\n\\nIf the array only contains positive integers, there always exists a minimum number of steps which is not greater than n - 1 since each step we can advance at least 1 index."
                    },
                    {
                        "username": "MickShow",
                        "content": "![image](https://assets.leetcode.com/users/images/2ecbe54e-b3e5-4c9b-a06a-12351fb5b731_1649493744.2732766.png)\\n"
                    },
                    {
                        "username": "NishchaySharma",
                        "content": "this code cleared 49/109 test cases, is there any possibility to make it pass all of them? what changes can help? \\n\\nvar jump = function(nums) {\\n    let count = 0\\n    if(nums.length <= 1)\\n    return 0\\n    for(let i=0; i<nums.length;i++){\\n        if(nums[i] == nums[0]){\\n            nums[i] = nums[i+1]\\n            ++count;\\n        }\\n    }\\n    return count\\n};"
                    }
                ]
            },
            {
                "id": 2038617,
                "content": [
                    {
                        "username": "JOON1234",
                        "content": "Anyone have tips on how I can optimize my BFS code? I already solved problem using bottom-up DP so I am trying to solve it in an alternative approach. I am getting \"Memory Exceeded Error\" on some inputs: \n\n ```\nfrom collections import deque \nclass Solution:\n    def jump(self, nums: List[int]) -> int:\n        #can also solve using bfs traversal => keep track of nodes labeled by index positions\n        #using queue data structure! The first index position that equals end (n-1) one that \n        #is reachable in fewest number of edges from root to itself in rec. decision tree =>\n        #implies is reacahble in fewest # of jumps! \n        n = len(nums)\n        q = deque()\n        #start off bfs starting from index = 0! \n        q.append(0)\n        #now, process continuously as long as queue is non-empty! \n        minJumps = 0 \n        while q: \n            #at the very beginning, we should get length of queue => tell us # nodes\n            #we must go through at current level! \n            numNodes = len(q)\n            #process all nodes \n            while numNodes: \n                #current index! \n                cur = q.popleft()\n                #check if cur == n-1! If so, we reached end! \n                if cur == n-1:\n                    return minJumps \n                #from current index, see max upper bound for jump quantity! \n                maxJump = nums[cur]\n                #I can simply add next positions we can reach by jumping various quantities\n                #ranging from [1, maxJump]. Make sure we jump positive quantity or we stay still! \n                for i in range(1, maxJump+1):\n                    #add to queue to process lateR! \n                    q.append(cur + i)\n                #before we move to next iteration and expand our cur node's children, we should\n                #increment minJumps count since we move to next level of rec. dec. tree graph\n                #in bfs traversal! \n                numNodes -= 1 \n            minJumps += 1 \n        return minJumps \n```"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "class Solution {\\npublic:\\n    long long int func(int i,int n,vector<int> nums,long long int& temp,int v,vector<long long int>& dp){\\n        if(i>=n-1){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        v++;\\n        // cout<<v;\\n        for(int ind = 1;ind<=nums[i];ind++){\\n            temp = min(temp,v+func(ind+i,n,nums,temp,v,dp));\\n        }\\n        return dp[i] = temp;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n =nums.size();\\n        long long int temp = INT_MAX;;\\n        vector<long long int> dp(n,-1);\\n        return func(0,n,nums,temp,0,dp);\\n    }\\n};\\nthe same code when used with recursion is giving expected output but while using memoisation it is giving wrong value \\none example for this is [2,3,3,0,1,2]\\ncan anyone share their opinion on this about where the code is missing the trick"
                    },
                    {
                        "username": "jukov",
                        "content": "Me: want to train DP.\\nSolution: greedy.\\n\\nThanks for proper tagging."
                    },
                    {
                        "username": "kapilchn7",
                        "content": "what the hell is wrong with this test case, \\n[4,1,1,3,1,1,1], my answer is 3 expected is 2,\\n\\nIf we start from 0th index, then we would land at 1 next to 3 not on 3, \\n\\n[2,3,0,1,4] another example, my answer is 2 expected is 2\\nwe first take 1 step to reach 3, then we take 3 steps to reach 4"
                    },
                    {
                        "username": "kapilchn7",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thank you, I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each element nums[i] represents the **maximum** length of a forward jump.  \\nYou can do smaller jumps if that\\'s advantageous.  \\nIn your first example you can just 3 to get to index 3, then another 3 to get to 6, the target.  \\nIn your second example you can jump 1 to get to index 1, then 3 to get to index 4, the target."
                    },
                    {
                        "username": "rameshwar_prasad",
                        "content": "unable to get problem task please help me understand this problem."
                    },
                    {
                        "username": "RazPatel",
                        "content": "Try to use BFS"
                    },
                    {
                        "username": "ketkiambekar",
                        "content": "In the question statement,\n\n `you can jump to any nums[i + j] where`\n\nshould actually be\n\n `you can jump to any nums[i]+j where`\n\nThat should reduce the confusion\n"
                    },
                    {
                        "username": "Mostafaabdallah_",
                        "content": "why in the case of nums = [1,2,3] the output is 2 not 1 ? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "At index 0, we have 2 choices, either jump 0 step or jump 1 step.\\nWe will jump 1 step and reach index 1. // 1st Jump\\nAt index 1 we have 3 choices, jump 0,1,2 steps.\\nWe will jump 1 step and reach index n-1. // 2nd Jump\\n\\nSo output is 2, we need to make minimum 2 jumps."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "everyone, try O(n) solution, greedy BFS approach.\\nFeeling good after solving."
                    },
                    {
                        "username": "rayancsdc",
                        "content": "The recommended approach in this scenario is to use breadth-first search (BFS), which involves considering all possible nodes that can be reached in one step and then expanding those nodes to determine the range of possibilities for the next step.\n\nLet's examine a counterexample to demonstrate the potential inefficiency of a BFS solution:\n\nConsider the following sequence:\n\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until the end of a 10000-length array)]\n\nKey observations:\n\nDuring the first step, the first 5000 elements of the array are visible.\nIn all subsequent steps, the first 5000 elements do not contribute to pushing the right pointer any further; it only moves forward by one element each step.\nThe left pointer also moves forward by only one element each step, as all possibilities must be considered. For example, even if nums[i] is 50, nums[i+1] still needs to be evaluated as it could be 10000.\nConsidering these factors, it appears that the algor[i](https://yumzlab.com/collections/mushroom-gummies-amanita-muscaria)thm would need to execute 5000 steps, with each step considering 5000 nodes. This suggests an O(n^2) behavior rather than O(n). Did I overlook something?\n\nI acknowledge that this is a contrived input I created through adversarial thinking. However, if I recall correctly, big O notation represents the \"worst-case\" scenari"
                    }
                ]
            },
            {
                "id": 2031441,
                "content": [
                    {
                        "username": "JOON1234",
                        "content": "Anyone have tips on how I can optimize my BFS code? I already solved problem using bottom-up DP so I am trying to solve it in an alternative approach. I am getting \"Memory Exceeded Error\" on some inputs: \n\n ```\nfrom collections import deque \nclass Solution:\n    def jump(self, nums: List[int]) -> int:\n        #can also solve using bfs traversal => keep track of nodes labeled by index positions\n        #using queue data structure! The first index position that equals end (n-1) one that \n        #is reachable in fewest number of edges from root to itself in rec. decision tree =>\n        #implies is reacahble in fewest # of jumps! \n        n = len(nums)\n        q = deque()\n        #start off bfs starting from index = 0! \n        q.append(0)\n        #now, process continuously as long as queue is non-empty! \n        minJumps = 0 \n        while q: \n            #at the very beginning, we should get length of queue => tell us # nodes\n            #we must go through at current level! \n            numNodes = len(q)\n            #process all nodes \n            while numNodes: \n                #current index! \n                cur = q.popleft()\n                #check if cur == n-1! If so, we reached end! \n                if cur == n-1:\n                    return minJumps \n                #from current index, see max upper bound for jump quantity! \n                maxJump = nums[cur]\n                #I can simply add next positions we can reach by jumping various quantities\n                #ranging from [1, maxJump]. Make sure we jump positive quantity or we stay still! \n                for i in range(1, maxJump+1):\n                    #add to queue to process lateR! \n                    q.append(cur + i)\n                #before we move to next iteration and expand our cur node's children, we should\n                #increment minJumps count since we move to next level of rec. dec. tree graph\n                #in bfs traversal! \n                numNodes -= 1 \n            minJumps += 1 \n        return minJumps \n```"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "class Solution {\\npublic:\\n    long long int func(int i,int n,vector<int> nums,long long int& temp,int v,vector<long long int>& dp){\\n        if(i>=n-1){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        v++;\\n        // cout<<v;\\n        for(int ind = 1;ind<=nums[i];ind++){\\n            temp = min(temp,v+func(ind+i,n,nums,temp,v,dp));\\n        }\\n        return dp[i] = temp;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n =nums.size();\\n        long long int temp = INT_MAX;;\\n        vector<long long int> dp(n,-1);\\n        return func(0,n,nums,temp,0,dp);\\n    }\\n};\\nthe same code when used with recursion is giving expected output but while using memoisation it is giving wrong value \\none example for this is [2,3,3,0,1,2]\\ncan anyone share their opinion on this about where the code is missing the trick"
                    },
                    {
                        "username": "jukov",
                        "content": "Me: want to train DP.\\nSolution: greedy.\\n\\nThanks for proper tagging."
                    },
                    {
                        "username": "kapilchn7",
                        "content": "what the hell is wrong with this test case, \\n[4,1,1,3,1,1,1], my answer is 3 expected is 2,\\n\\nIf we start from 0th index, then we would land at 1 next to 3 not on 3, \\n\\n[2,3,0,1,4] another example, my answer is 2 expected is 2\\nwe first take 1 step to reach 3, then we take 3 steps to reach 4"
                    },
                    {
                        "username": "kapilchn7",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thank you, I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each element nums[i] represents the **maximum** length of a forward jump.  \\nYou can do smaller jumps if that\\'s advantageous.  \\nIn your first example you can just 3 to get to index 3, then another 3 to get to 6, the target.  \\nIn your second example you can jump 1 to get to index 1, then 3 to get to index 4, the target."
                    },
                    {
                        "username": "rameshwar_prasad",
                        "content": "unable to get problem task please help me understand this problem."
                    },
                    {
                        "username": "RazPatel",
                        "content": "Try to use BFS"
                    },
                    {
                        "username": "ketkiambekar",
                        "content": "In the question statement,\n\n `you can jump to any nums[i + j] where`\n\nshould actually be\n\n `you can jump to any nums[i]+j where`\n\nThat should reduce the confusion\n"
                    },
                    {
                        "username": "Mostafaabdallah_",
                        "content": "why in the case of nums = [1,2,3] the output is 2 not 1 ? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "At index 0, we have 2 choices, either jump 0 step or jump 1 step.\\nWe will jump 1 step and reach index 1. // 1st Jump\\nAt index 1 we have 3 choices, jump 0,1,2 steps.\\nWe will jump 1 step and reach index n-1. // 2nd Jump\\n\\nSo output is 2, we need to make minimum 2 jumps."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "everyone, try O(n) solution, greedy BFS approach.\\nFeeling good after solving."
                    },
                    {
                        "username": "rayancsdc",
                        "content": "The recommended approach in this scenario is to use breadth-first search (BFS), which involves considering all possible nodes that can be reached in one step and then expanding those nodes to determine the range of possibilities for the next step.\n\nLet's examine a counterexample to demonstrate the potential inefficiency of a BFS solution:\n\nConsider the following sequence:\n\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until the end of a 10000-length array)]\n\nKey observations:\n\nDuring the first step, the first 5000 elements of the array are visible.\nIn all subsequent steps, the first 5000 elements do not contribute to pushing the right pointer any further; it only moves forward by one element each step.\nThe left pointer also moves forward by only one element each step, as all possibilities must be considered. For example, even if nums[i] is 50, nums[i+1] still needs to be evaluated as it could be 10000.\nConsidering these factors, it appears that the algor[i](https://yumzlab.com/collections/mushroom-gummies-amanita-muscaria)thm would need to execute 5000 steps, with each step considering 5000 nodes. This suggests an O(n^2) behavior rather than O(n). Did I overlook something?\n\nI acknowledge that this is a contrived input I created through adversarial thinking. However, if I recall correctly, big O notation represents the \"worst-case\" scenari"
                    }
                ]
            },
            {
                "id": 2027619,
                "content": [
                    {
                        "username": "JOON1234",
                        "content": "Anyone have tips on how I can optimize my BFS code? I already solved problem using bottom-up DP so I am trying to solve it in an alternative approach. I am getting \"Memory Exceeded Error\" on some inputs: \n\n ```\nfrom collections import deque \nclass Solution:\n    def jump(self, nums: List[int]) -> int:\n        #can also solve using bfs traversal => keep track of nodes labeled by index positions\n        #using queue data structure! The first index position that equals end (n-1) one that \n        #is reachable in fewest number of edges from root to itself in rec. decision tree =>\n        #implies is reacahble in fewest # of jumps! \n        n = len(nums)\n        q = deque()\n        #start off bfs starting from index = 0! \n        q.append(0)\n        #now, process continuously as long as queue is non-empty! \n        minJumps = 0 \n        while q: \n            #at the very beginning, we should get length of queue => tell us # nodes\n            #we must go through at current level! \n            numNodes = len(q)\n            #process all nodes \n            while numNodes: \n                #current index! \n                cur = q.popleft()\n                #check if cur == n-1! If so, we reached end! \n                if cur == n-1:\n                    return minJumps \n                #from current index, see max upper bound for jump quantity! \n                maxJump = nums[cur]\n                #I can simply add next positions we can reach by jumping various quantities\n                #ranging from [1, maxJump]. Make sure we jump positive quantity or we stay still! \n                for i in range(1, maxJump+1):\n                    #add to queue to process lateR! \n                    q.append(cur + i)\n                #before we move to next iteration and expand our cur node's children, we should\n                #increment minJumps count since we move to next level of rec. dec. tree graph\n                #in bfs traversal! \n                numNodes -= 1 \n            minJumps += 1 \n        return minJumps \n```"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "class Solution {\\npublic:\\n    long long int func(int i,int n,vector<int> nums,long long int& temp,int v,vector<long long int>& dp){\\n        if(i>=n-1){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        v++;\\n        // cout<<v;\\n        for(int ind = 1;ind<=nums[i];ind++){\\n            temp = min(temp,v+func(ind+i,n,nums,temp,v,dp));\\n        }\\n        return dp[i] = temp;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n =nums.size();\\n        long long int temp = INT_MAX;;\\n        vector<long long int> dp(n,-1);\\n        return func(0,n,nums,temp,0,dp);\\n    }\\n};\\nthe same code when used with recursion is giving expected output but while using memoisation it is giving wrong value \\none example for this is [2,3,3,0,1,2]\\ncan anyone share their opinion on this about where the code is missing the trick"
                    },
                    {
                        "username": "jukov",
                        "content": "Me: want to train DP.\\nSolution: greedy.\\n\\nThanks for proper tagging."
                    },
                    {
                        "username": "kapilchn7",
                        "content": "what the hell is wrong with this test case, \\n[4,1,1,3,1,1,1], my answer is 3 expected is 2,\\n\\nIf we start from 0th index, then we would land at 1 next to 3 not on 3, \\n\\n[2,3,0,1,4] another example, my answer is 2 expected is 2\\nwe first take 1 step to reach 3, then we take 3 steps to reach 4"
                    },
                    {
                        "username": "kapilchn7",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thank you, I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each element nums[i] represents the **maximum** length of a forward jump.  \\nYou can do smaller jumps if that\\'s advantageous.  \\nIn your first example you can just 3 to get to index 3, then another 3 to get to 6, the target.  \\nIn your second example you can jump 1 to get to index 1, then 3 to get to index 4, the target."
                    },
                    {
                        "username": "rameshwar_prasad",
                        "content": "unable to get problem task please help me understand this problem."
                    },
                    {
                        "username": "RazPatel",
                        "content": "Try to use BFS"
                    },
                    {
                        "username": "ketkiambekar",
                        "content": "In the question statement,\n\n `you can jump to any nums[i + j] where`\n\nshould actually be\n\n `you can jump to any nums[i]+j where`\n\nThat should reduce the confusion\n"
                    },
                    {
                        "username": "Mostafaabdallah_",
                        "content": "why in the case of nums = [1,2,3] the output is 2 not 1 ? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "At index 0, we have 2 choices, either jump 0 step or jump 1 step.\\nWe will jump 1 step and reach index 1. // 1st Jump\\nAt index 1 we have 3 choices, jump 0,1,2 steps.\\nWe will jump 1 step and reach index n-1. // 2nd Jump\\n\\nSo output is 2, we need to make minimum 2 jumps."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "everyone, try O(n) solution, greedy BFS approach.\\nFeeling good after solving."
                    },
                    {
                        "username": "rayancsdc",
                        "content": "The recommended approach in this scenario is to use breadth-first search (BFS), which involves considering all possible nodes that can be reached in one step and then expanding those nodes to determine the range of possibilities for the next step.\n\nLet's examine a counterexample to demonstrate the potential inefficiency of a BFS solution:\n\nConsider the following sequence:\n\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until the end of a 10000-length array)]\n\nKey observations:\n\nDuring the first step, the first 5000 elements of the array are visible.\nIn all subsequent steps, the first 5000 elements do not contribute to pushing the right pointer any further; it only moves forward by one element each step.\nThe left pointer also moves forward by only one element each step, as all possibilities must be considered. For example, even if nums[i] is 50, nums[i+1] still needs to be evaluated as it could be 10000.\nConsidering these factors, it appears that the algor[i](https://yumzlab.com/collections/mushroom-gummies-amanita-muscaria)thm would need to execute 5000 steps, with each step considering 5000 nodes. This suggests an O(n^2) behavior rather than O(n). Did I overlook something?\n\nI acknowledge that this is a contrived input I created through adversarial thinking. However, if I recall correctly, big O notation represents the \"worst-case\" scenari"
                    }
                ]
            },
            {
                "id": 2023096,
                "content": [
                    {
                        "username": "JOON1234",
                        "content": "Anyone have tips on how I can optimize my BFS code? I already solved problem using bottom-up DP so I am trying to solve it in an alternative approach. I am getting \"Memory Exceeded Error\" on some inputs: \n\n ```\nfrom collections import deque \nclass Solution:\n    def jump(self, nums: List[int]) -> int:\n        #can also solve using bfs traversal => keep track of nodes labeled by index positions\n        #using queue data structure! The first index position that equals end (n-1) one that \n        #is reachable in fewest number of edges from root to itself in rec. decision tree =>\n        #implies is reacahble in fewest # of jumps! \n        n = len(nums)\n        q = deque()\n        #start off bfs starting from index = 0! \n        q.append(0)\n        #now, process continuously as long as queue is non-empty! \n        minJumps = 0 \n        while q: \n            #at the very beginning, we should get length of queue => tell us # nodes\n            #we must go through at current level! \n            numNodes = len(q)\n            #process all nodes \n            while numNodes: \n                #current index! \n                cur = q.popleft()\n                #check if cur == n-1! If so, we reached end! \n                if cur == n-1:\n                    return minJumps \n                #from current index, see max upper bound for jump quantity! \n                maxJump = nums[cur]\n                #I can simply add next positions we can reach by jumping various quantities\n                #ranging from [1, maxJump]. Make sure we jump positive quantity or we stay still! \n                for i in range(1, maxJump+1):\n                    #add to queue to process lateR! \n                    q.append(cur + i)\n                #before we move to next iteration and expand our cur node's children, we should\n                #increment minJumps count since we move to next level of rec. dec. tree graph\n                #in bfs traversal! \n                numNodes -= 1 \n            minJumps += 1 \n        return minJumps \n```"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "class Solution {\\npublic:\\n    long long int func(int i,int n,vector<int> nums,long long int& temp,int v,vector<long long int>& dp){\\n        if(i>=n-1){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        v++;\\n        // cout<<v;\\n        for(int ind = 1;ind<=nums[i];ind++){\\n            temp = min(temp,v+func(ind+i,n,nums,temp,v,dp));\\n        }\\n        return dp[i] = temp;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n =nums.size();\\n        long long int temp = INT_MAX;;\\n        vector<long long int> dp(n,-1);\\n        return func(0,n,nums,temp,0,dp);\\n    }\\n};\\nthe same code when used with recursion is giving expected output but while using memoisation it is giving wrong value \\none example for this is [2,3,3,0,1,2]\\ncan anyone share their opinion on this about where the code is missing the trick"
                    },
                    {
                        "username": "jukov",
                        "content": "Me: want to train DP.\\nSolution: greedy.\\n\\nThanks for proper tagging."
                    },
                    {
                        "username": "kapilchn7",
                        "content": "what the hell is wrong with this test case, \\n[4,1,1,3,1,1,1], my answer is 3 expected is 2,\\n\\nIf we start from 0th index, then we would land at 1 next to 3 not on 3, \\n\\n[2,3,0,1,4] another example, my answer is 2 expected is 2\\nwe first take 1 step to reach 3, then we take 3 steps to reach 4"
                    },
                    {
                        "username": "kapilchn7",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thank you, I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each element nums[i] represents the **maximum** length of a forward jump.  \\nYou can do smaller jumps if that\\'s advantageous.  \\nIn your first example you can just 3 to get to index 3, then another 3 to get to 6, the target.  \\nIn your second example you can jump 1 to get to index 1, then 3 to get to index 4, the target."
                    },
                    {
                        "username": "rameshwar_prasad",
                        "content": "unable to get problem task please help me understand this problem."
                    },
                    {
                        "username": "RazPatel",
                        "content": "Try to use BFS"
                    },
                    {
                        "username": "ketkiambekar",
                        "content": "In the question statement,\n\n `you can jump to any nums[i + j] where`\n\nshould actually be\n\n `you can jump to any nums[i]+j where`\n\nThat should reduce the confusion\n"
                    },
                    {
                        "username": "Mostafaabdallah_",
                        "content": "why in the case of nums = [1,2,3] the output is 2 not 1 ? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "At index 0, we have 2 choices, either jump 0 step or jump 1 step.\\nWe will jump 1 step and reach index 1. // 1st Jump\\nAt index 1 we have 3 choices, jump 0,1,2 steps.\\nWe will jump 1 step and reach index n-1. // 2nd Jump\\n\\nSo output is 2, we need to make minimum 2 jumps."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "everyone, try O(n) solution, greedy BFS approach.\\nFeeling good after solving."
                    },
                    {
                        "username": "rayancsdc",
                        "content": "The recommended approach in this scenario is to use breadth-first search (BFS), which involves considering all possible nodes that can be reached in one step and then expanding those nodes to determine the range of possibilities for the next step.\n\nLet's examine a counterexample to demonstrate the potential inefficiency of a BFS solution:\n\nConsider the following sequence:\n\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until the end of a 10000-length array)]\n\nKey observations:\n\nDuring the first step, the first 5000 elements of the array are visible.\nIn all subsequent steps, the first 5000 elements do not contribute to pushing the right pointer any further; it only moves forward by one element each step.\nThe left pointer also moves forward by only one element each step, as all possibilities must be considered. For example, even if nums[i] is 50, nums[i+1] still needs to be evaluated as it could be 10000.\nConsidering these factors, it appears that the algor[i](https://yumzlab.com/collections/mushroom-gummies-amanita-muscaria)thm would need to execute 5000 steps, with each step considering 5000 nodes. This suggests an O(n^2) behavior rather than O(n). Did I overlook something?\n\nI acknowledge that this is a contrived input I created through adversarial thinking. However, if I recall correctly, big O notation represents the \"worst-case\" scenari"
                    }
                ]
            },
            {
                "id": 2010645,
                "content": [
                    {
                        "username": "JOON1234",
                        "content": "Anyone have tips on how I can optimize my BFS code? I already solved problem using bottom-up DP so I am trying to solve it in an alternative approach. I am getting \"Memory Exceeded Error\" on some inputs: \n\n ```\nfrom collections import deque \nclass Solution:\n    def jump(self, nums: List[int]) -> int:\n        #can also solve using bfs traversal => keep track of nodes labeled by index positions\n        #using queue data structure! The first index position that equals end (n-1) one that \n        #is reachable in fewest number of edges from root to itself in rec. decision tree =>\n        #implies is reacahble in fewest # of jumps! \n        n = len(nums)\n        q = deque()\n        #start off bfs starting from index = 0! \n        q.append(0)\n        #now, process continuously as long as queue is non-empty! \n        minJumps = 0 \n        while q: \n            #at the very beginning, we should get length of queue => tell us # nodes\n            #we must go through at current level! \n            numNodes = len(q)\n            #process all nodes \n            while numNodes: \n                #current index! \n                cur = q.popleft()\n                #check if cur == n-1! If so, we reached end! \n                if cur == n-1:\n                    return minJumps \n                #from current index, see max upper bound for jump quantity! \n                maxJump = nums[cur]\n                #I can simply add next positions we can reach by jumping various quantities\n                #ranging from [1, maxJump]. Make sure we jump positive quantity or we stay still! \n                for i in range(1, maxJump+1):\n                    #add to queue to process lateR! \n                    q.append(cur + i)\n                #before we move to next iteration and expand our cur node's children, we should\n                #increment minJumps count since we move to next level of rec. dec. tree graph\n                #in bfs traversal! \n                numNodes -= 1 \n            minJumps += 1 \n        return minJumps \n```"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "class Solution {\\npublic:\\n    long long int func(int i,int n,vector<int> nums,long long int& temp,int v,vector<long long int>& dp){\\n        if(i>=n-1){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        v++;\\n        // cout<<v;\\n        for(int ind = 1;ind<=nums[i];ind++){\\n            temp = min(temp,v+func(ind+i,n,nums,temp,v,dp));\\n        }\\n        return dp[i] = temp;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n =nums.size();\\n        long long int temp = INT_MAX;;\\n        vector<long long int> dp(n,-1);\\n        return func(0,n,nums,temp,0,dp);\\n    }\\n};\\nthe same code when used with recursion is giving expected output but while using memoisation it is giving wrong value \\none example for this is [2,3,3,0,1,2]\\ncan anyone share their opinion on this about where the code is missing the trick"
                    },
                    {
                        "username": "jukov",
                        "content": "Me: want to train DP.\\nSolution: greedy.\\n\\nThanks for proper tagging."
                    },
                    {
                        "username": "kapilchn7",
                        "content": "what the hell is wrong with this test case, \\n[4,1,1,3,1,1,1], my answer is 3 expected is 2,\\n\\nIf we start from 0th index, then we would land at 1 next to 3 not on 3, \\n\\n[2,3,0,1,4] another example, my answer is 2 expected is 2\\nwe first take 1 step to reach 3, then we take 3 steps to reach 4"
                    },
                    {
                        "username": "kapilchn7",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thank you, I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each element nums[i] represents the **maximum** length of a forward jump.  \\nYou can do smaller jumps if that\\'s advantageous.  \\nIn your first example you can just 3 to get to index 3, then another 3 to get to 6, the target.  \\nIn your second example you can jump 1 to get to index 1, then 3 to get to index 4, the target."
                    },
                    {
                        "username": "rameshwar_prasad",
                        "content": "unable to get problem task please help me understand this problem."
                    },
                    {
                        "username": "RazPatel",
                        "content": "Try to use BFS"
                    },
                    {
                        "username": "ketkiambekar",
                        "content": "In the question statement,\n\n `you can jump to any nums[i + j] where`\n\nshould actually be\n\n `you can jump to any nums[i]+j where`\n\nThat should reduce the confusion\n"
                    },
                    {
                        "username": "Mostafaabdallah_",
                        "content": "why in the case of nums = [1,2,3] the output is 2 not 1 ? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "At index 0, we have 2 choices, either jump 0 step or jump 1 step.\\nWe will jump 1 step and reach index 1. // 1st Jump\\nAt index 1 we have 3 choices, jump 0,1,2 steps.\\nWe will jump 1 step and reach index n-1. // 2nd Jump\\n\\nSo output is 2, we need to make minimum 2 jumps."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "everyone, try O(n) solution, greedy BFS approach.\\nFeeling good after solving."
                    },
                    {
                        "username": "rayancsdc",
                        "content": "The recommended approach in this scenario is to use breadth-first search (BFS), which involves considering all possible nodes that can be reached in one step and then expanding those nodes to determine the range of possibilities for the next step.\n\nLet's examine a counterexample to demonstrate the potential inefficiency of a BFS solution:\n\nConsider the following sequence:\n\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until the end of a 10000-length array)]\n\nKey observations:\n\nDuring the first step, the first 5000 elements of the array are visible.\nIn all subsequent steps, the first 5000 elements do not contribute to pushing the right pointer any further; it only moves forward by one element each step.\nThe left pointer also moves forward by only one element each step, as all possibilities must be considered. For example, even if nums[i] is 50, nums[i+1] still needs to be evaluated as it could be 10000.\nConsidering these factors, it appears that the algor[i](https://yumzlab.com/collections/mushroom-gummies-amanita-muscaria)thm would need to execute 5000 steps, with each step considering 5000 nodes. This suggests an O(n^2) behavior rather than O(n). Did I overlook something?\n\nI acknowledge that this is a contrived input I created through adversarial thinking. However, if I recall correctly, big O notation represents the \"worst-case\" scenari"
                    }
                ]
            },
            {
                "id": 2003821,
                "content": [
                    {
                        "username": "JOON1234",
                        "content": "Anyone have tips on how I can optimize my BFS code? I already solved problem using bottom-up DP so I am trying to solve it in an alternative approach. I am getting \"Memory Exceeded Error\" on some inputs: \n\n ```\nfrom collections import deque \nclass Solution:\n    def jump(self, nums: List[int]) -> int:\n        #can also solve using bfs traversal => keep track of nodes labeled by index positions\n        #using queue data structure! The first index position that equals end (n-1) one that \n        #is reachable in fewest number of edges from root to itself in rec. decision tree =>\n        #implies is reacahble in fewest # of jumps! \n        n = len(nums)\n        q = deque()\n        #start off bfs starting from index = 0! \n        q.append(0)\n        #now, process continuously as long as queue is non-empty! \n        minJumps = 0 \n        while q: \n            #at the very beginning, we should get length of queue => tell us # nodes\n            #we must go through at current level! \n            numNodes = len(q)\n            #process all nodes \n            while numNodes: \n                #current index! \n                cur = q.popleft()\n                #check if cur == n-1! If so, we reached end! \n                if cur == n-1:\n                    return minJumps \n                #from current index, see max upper bound for jump quantity! \n                maxJump = nums[cur]\n                #I can simply add next positions we can reach by jumping various quantities\n                #ranging from [1, maxJump]. Make sure we jump positive quantity or we stay still! \n                for i in range(1, maxJump+1):\n                    #add to queue to process lateR! \n                    q.append(cur + i)\n                #before we move to next iteration and expand our cur node's children, we should\n                #increment minJumps count since we move to next level of rec. dec. tree graph\n                #in bfs traversal! \n                numNodes -= 1 \n            minJumps += 1 \n        return minJumps \n```"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "class Solution {\\npublic:\\n    long long int func(int i,int n,vector<int> nums,long long int& temp,int v,vector<long long int>& dp){\\n        if(i>=n-1){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        v++;\\n        // cout<<v;\\n        for(int ind = 1;ind<=nums[i];ind++){\\n            temp = min(temp,v+func(ind+i,n,nums,temp,v,dp));\\n        }\\n        return dp[i] = temp;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n =nums.size();\\n        long long int temp = INT_MAX;;\\n        vector<long long int> dp(n,-1);\\n        return func(0,n,nums,temp,0,dp);\\n    }\\n};\\nthe same code when used with recursion is giving expected output but while using memoisation it is giving wrong value \\none example for this is [2,3,3,0,1,2]\\ncan anyone share their opinion on this about where the code is missing the trick"
                    },
                    {
                        "username": "jukov",
                        "content": "Me: want to train DP.\\nSolution: greedy.\\n\\nThanks for proper tagging."
                    },
                    {
                        "username": "kapilchn7",
                        "content": "what the hell is wrong with this test case, \\n[4,1,1,3,1,1,1], my answer is 3 expected is 2,\\n\\nIf we start from 0th index, then we would land at 1 next to 3 not on 3, \\n\\n[2,3,0,1,4] another example, my answer is 2 expected is 2\\nwe first take 1 step to reach 3, then we take 3 steps to reach 4"
                    },
                    {
                        "username": "kapilchn7",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thank you, I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each element nums[i] represents the **maximum** length of a forward jump.  \\nYou can do smaller jumps if that\\'s advantageous.  \\nIn your first example you can just 3 to get to index 3, then another 3 to get to 6, the target.  \\nIn your second example you can jump 1 to get to index 1, then 3 to get to index 4, the target."
                    },
                    {
                        "username": "rameshwar_prasad",
                        "content": "unable to get problem task please help me understand this problem."
                    },
                    {
                        "username": "RazPatel",
                        "content": "Try to use BFS"
                    },
                    {
                        "username": "ketkiambekar",
                        "content": "In the question statement,\n\n `you can jump to any nums[i + j] where`\n\nshould actually be\n\n `you can jump to any nums[i]+j where`\n\nThat should reduce the confusion\n"
                    },
                    {
                        "username": "Mostafaabdallah_",
                        "content": "why in the case of nums = [1,2,3] the output is 2 not 1 ? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "At index 0, we have 2 choices, either jump 0 step or jump 1 step.\\nWe will jump 1 step and reach index 1. // 1st Jump\\nAt index 1 we have 3 choices, jump 0,1,2 steps.\\nWe will jump 1 step and reach index n-1. // 2nd Jump\\n\\nSo output is 2, we need to make minimum 2 jumps."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "everyone, try O(n) solution, greedy BFS approach.\\nFeeling good after solving."
                    },
                    {
                        "username": "rayancsdc",
                        "content": "The recommended approach in this scenario is to use breadth-first search (BFS), which involves considering all possible nodes that can be reached in one step and then expanding those nodes to determine the range of possibilities for the next step.\n\nLet's examine a counterexample to demonstrate the potential inefficiency of a BFS solution:\n\nConsider the following sequence:\n\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until the end of a 10000-length array)]\n\nKey observations:\n\nDuring the first step, the first 5000 elements of the array are visible.\nIn all subsequent steps, the first 5000 elements do not contribute to pushing the right pointer any further; it only moves forward by one element each step.\nThe left pointer also moves forward by only one element each step, as all possibilities must be considered. For example, even if nums[i] is 50, nums[i+1] still needs to be evaluated as it could be 10000.\nConsidering these factors, it appears that the algor[i](https://yumzlab.com/collections/mushroom-gummies-amanita-muscaria)thm would need to execute 5000 steps, with each step considering 5000 nodes. This suggests an O(n^2) behavior rather than O(n). Did I overlook something?\n\nI acknowledge that this is a contrived input I created through adversarial thinking. However, if I recall correctly, big O notation represents the \"worst-case\" scenari"
                    }
                ]
            },
            {
                "id": 1971719,
                "content": [
                    {
                        "username": "JOON1234",
                        "content": "Anyone have tips on how I can optimize my BFS code? I already solved problem using bottom-up DP so I am trying to solve it in an alternative approach. I am getting \"Memory Exceeded Error\" on some inputs: \n\n ```\nfrom collections import deque \nclass Solution:\n    def jump(self, nums: List[int]) -> int:\n        #can also solve using bfs traversal => keep track of nodes labeled by index positions\n        #using queue data structure! The first index position that equals end (n-1) one that \n        #is reachable in fewest number of edges from root to itself in rec. decision tree =>\n        #implies is reacahble in fewest # of jumps! \n        n = len(nums)\n        q = deque()\n        #start off bfs starting from index = 0! \n        q.append(0)\n        #now, process continuously as long as queue is non-empty! \n        minJumps = 0 \n        while q: \n            #at the very beginning, we should get length of queue => tell us # nodes\n            #we must go through at current level! \n            numNodes = len(q)\n            #process all nodes \n            while numNodes: \n                #current index! \n                cur = q.popleft()\n                #check if cur == n-1! If so, we reached end! \n                if cur == n-1:\n                    return minJumps \n                #from current index, see max upper bound for jump quantity! \n                maxJump = nums[cur]\n                #I can simply add next positions we can reach by jumping various quantities\n                #ranging from [1, maxJump]. Make sure we jump positive quantity or we stay still! \n                for i in range(1, maxJump+1):\n                    #add to queue to process lateR! \n                    q.append(cur + i)\n                #before we move to next iteration and expand our cur node's children, we should\n                #increment minJumps count since we move to next level of rec. dec. tree graph\n                #in bfs traversal! \n                numNodes -= 1 \n            minJumps += 1 \n        return minJumps \n```"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "class Solution {\\npublic:\\n    long long int func(int i,int n,vector<int> nums,long long int& temp,int v,vector<long long int>& dp){\\n        if(i>=n-1){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        v++;\\n        // cout<<v;\\n        for(int ind = 1;ind<=nums[i];ind++){\\n            temp = min(temp,v+func(ind+i,n,nums,temp,v,dp));\\n        }\\n        return dp[i] = temp;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n =nums.size();\\n        long long int temp = INT_MAX;;\\n        vector<long long int> dp(n,-1);\\n        return func(0,n,nums,temp,0,dp);\\n    }\\n};\\nthe same code when used with recursion is giving expected output but while using memoisation it is giving wrong value \\none example for this is [2,3,3,0,1,2]\\ncan anyone share their opinion on this about where the code is missing the trick"
                    },
                    {
                        "username": "jukov",
                        "content": "Me: want to train DP.\\nSolution: greedy.\\n\\nThanks for proper tagging."
                    },
                    {
                        "username": "kapilchn7",
                        "content": "what the hell is wrong with this test case, \\n[4,1,1,3,1,1,1], my answer is 3 expected is 2,\\n\\nIf we start from 0th index, then we would land at 1 next to 3 not on 3, \\n\\n[2,3,0,1,4] another example, my answer is 2 expected is 2\\nwe first take 1 step to reach 3, then we take 3 steps to reach 4"
                    },
                    {
                        "username": "kapilchn7",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thank you, I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each element nums[i] represents the **maximum** length of a forward jump.  \\nYou can do smaller jumps if that\\'s advantageous.  \\nIn your first example you can just 3 to get to index 3, then another 3 to get to 6, the target.  \\nIn your second example you can jump 1 to get to index 1, then 3 to get to index 4, the target."
                    },
                    {
                        "username": "rameshwar_prasad",
                        "content": "unable to get problem task please help me understand this problem."
                    },
                    {
                        "username": "RazPatel",
                        "content": "Try to use BFS"
                    },
                    {
                        "username": "ketkiambekar",
                        "content": "In the question statement,\n\n `you can jump to any nums[i + j] where`\n\nshould actually be\n\n `you can jump to any nums[i]+j where`\n\nThat should reduce the confusion\n"
                    },
                    {
                        "username": "Mostafaabdallah_",
                        "content": "why in the case of nums = [1,2,3] the output is 2 not 1 ? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "At index 0, we have 2 choices, either jump 0 step or jump 1 step.\\nWe will jump 1 step and reach index 1. // 1st Jump\\nAt index 1 we have 3 choices, jump 0,1,2 steps.\\nWe will jump 1 step and reach index n-1. // 2nd Jump\\n\\nSo output is 2, we need to make minimum 2 jumps."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "everyone, try O(n) solution, greedy BFS approach.\\nFeeling good after solving."
                    },
                    {
                        "username": "rayancsdc",
                        "content": "The recommended approach in this scenario is to use breadth-first search (BFS), which involves considering all possible nodes that can be reached in one step and then expanding those nodes to determine the range of possibilities for the next step.\n\nLet's examine a counterexample to demonstrate the potential inefficiency of a BFS solution:\n\nConsider the following sequence:\n\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until the end of a 10000-length array)]\n\nKey observations:\n\nDuring the first step, the first 5000 elements of the array are visible.\nIn all subsequent steps, the first 5000 elements do not contribute to pushing the right pointer any further; it only moves forward by one element each step.\nThe left pointer also moves forward by only one element each step, as all possibilities must be considered. For example, even if nums[i] is 50, nums[i+1] still needs to be evaluated as it could be 10000.\nConsidering these factors, it appears that the algor[i](https://yumzlab.com/collections/mushroom-gummies-amanita-muscaria)thm would need to execute 5000 steps, with each step considering 5000 nodes. This suggests an O(n^2) behavior rather than O(n). Did I overlook something?\n\nI acknowledge that this is a contrived input I created through adversarial thinking. However, if I recall correctly, big O notation represents the \"worst-case\" scenari"
                    }
                ]
            },
            {
                "id": 1968525,
                "content": [
                    {
                        "username": "JOON1234",
                        "content": "Anyone have tips on how I can optimize my BFS code? I already solved problem using bottom-up DP so I am trying to solve it in an alternative approach. I am getting \"Memory Exceeded Error\" on some inputs: \n\n ```\nfrom collections import deque \nclass Solution:\n    def jump(self, nums: List[int]) -> int:\n        #can also solve using bfs traversal => keep track of nodes labeled by index positions\n        #using queue data structure! The first index position that equals end (n-1) one that \n        #is reachable in fewest number of edges from root to itself in rec. decision tree =>\n        #implies is reacahble in fewest # of jumps! \n        n = len(nums)\n        q = deque()\n        #start off bfs starting from index = 0! \n        q.append(0)\n        #now, process continuously as long as queue is non-empty! \n        minJumps = 0 \n        while q: \n            #at the very beginning, we should get length of queue => tell us # nodes\n            #we must go through at current level! \n            numNodes = len(q)\n            #process all nodes \n            while numNodes: \n                #current index! \n                cur = q.popleft()\n                #check if cur == n-1! If so, we reached end! \n                if cur == n-1:\n                    return minJumps \n                #from current index, see max upper bound for jump quantity! \n                maxJump = nums[cur]\n                #I can simply add next positions we can reach by jumping various quantities\n                #ranging from [1, maxJump]. Make sure we jump positive quantity or we stay still! \n                for i in range(1, maxJump+1):\n                    #add to queue to process lateR! \n                    q.append(cur + i)\n                #before we move to next iteration and expand our cur node's children, we should\n                #increment minJumps count since we move to next level of rec. dec. tree graph\n                #in bfs traversal! \n                numNodes -= 1 \n            minJumps += 1 \n        return minJumps \n```"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "class Solution {\\npublic:\\n    long long int func(int i,int n,vector<int> nums,long long int& temp,int v,vector<long long int>& dp){\\n        if(i>=n-1){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        v++;\\n        // cout<<v;\\n        for(int ind = 1;ind<=nums[i];ind++){\\n            temp = min(temp,v+func(ind+i,n,nums,temp,v,dp));\\n        }\\n        return dp[i] = temp;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n =nums.size();\\n        long long int temp = INT_MAX;;\\n        vector<long long int> dp(n,-1);\\n        return func(0,n,nums,temp,0,dp);\\n    }\\n};\\nthe same code when used with recursion is giving expected output but while using memoisation it is giving wrong value \\none example for this is [2,3,3,0,1,2]\\ncan anyone share their opinion on this about where the code is missing the trick"
                    },
                    {
                        "username": "jukov",
                        "content": "Me: want to train DP.\\nSolution: greedy.\\n\\nThanks for proper tagging."
                    },
                    {
                        "username": "kapilchn7",
                        "content": "what the hell is wrong with this test case, \\n[4,1,1,3,1,1,1], my answer is 3 expected is 2,\\n\\nIf we start from 0th index, then we would land at 1 next to 3 not on 3, \\n\\n[2,3,0,1,4] another example, my answer is 2 expected is 2\\nwe first take 1 step to reach 3, then we take 3 steps to reach 4"
                    },
                    {
                        "username": "kapilchn7",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thank you, I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each element nums[i] represents the **maximum** length of a forward jump.  \\nYou can do smaller jumps if that\\'s advantageous.  \\nIn your first example you can just 3 to get to index 3, then another 3 to get to 6, the target.  \\nIn your second example you can jump 1 to get to index 1, then 3 to get to index 4, the target."
                    },
                    {
                        "username": "rameshwar_prasad",
                        "content": "unable to get problem task please help me understand this problem."
                    },
                    {
                        "username": "RazPatel",
                        "content": "Try to use BFS"
                    },
                    {
                        "username": "ketkiambekar",
                        "content": "In the question statement,\n\n `you can jump to any nums[i + j] where`\n\nshould actually be\n\n `you can jump to any nums[i]+j where`\n\nThat should reduce the confusion\n"
                    },
                    {
                        "username": "Mostafaabdallah_",
                        "content": "why in the case of nums = [1,2,3] the output is 2 not 1 ? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "At index 0, we have 2 choices, either jump 0 step or jump 1 step.\\nWe will jump 1 step and reach index 1. // 1st Jump\\nAt index 1 we have 3 choices, jump 0,1,2 steps.\\nWe will jump 1 step and reach index n-1. // 2nd Jump\\n\\nSo output is 2, we need to make minimum 2 jumps."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "everyone, try O(n) solution, greedy BFS approach.\\nFeeling good after solving."
                    },
                    {
                        "username": "rayancsdc",
                        "content": "The recommended approach in this scenario is to use breadth-first search (BFS), which involves considering all possible nodes that can be reached in one step and then expanding those nodes to determine the range of possibilities for the next step.\n\nLet's examine a counterexample to demonstrate the potential inefficiency of a BFS solution:\n\nConsider the following sequence:\n\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until the end of a 10000-length array)]\n\nKey observations:\n\nDuring the first step, the first 5000 elements of the array are visible.\nIn all subsequent steps, the first 5000 elements do not contribute to pushing the right pointer any further; it only moves forward by one element each step.\nThe left pointer also moves forward by only one element each step, as all possibilities must be considered. For example, even if nums[i] is 50, nums[i+1] still needs to be evaluated as it could be 10000.\nConsidering these factors, it appears that the algor[i](https://yumzlab.com/collections/mushroom-gummies-amanita-muscaria)thm would need to execute 5000 steps, with each step considering 5000 nodes. This suggests an O(n^2) behavior rather than O(n). Did I overlook something?\n\nI acknowledge that this is a contrived input I created through adversarial thinking. However, if I recall correctly, big O notation represents the \"worst-case\" scenari"
                    }
                ]
            },
            {
                "id": 1967322,
                "content": [
                    {
                        "username": "JOON1234",
                        "content": "Anyone have tips on how I can optimize my BFS code? I already solved problem using bottom-up DP so I am trying to solve it in an alternative approach. I am getting \"Memory Exceeded Error\" on some inputs: \n\n ```\nfrom collections import deque \nclass Solution:\n    def jump(self, nums: List[int]) -> int:\n        #can also solve using bfs traversal => keep track of nodes labeled by index positions\n        #using queue data structure! The first index position that equals end (n-1) one that \n        #is reachable in fewest number of edges from root to itself in rec. decision tree =>\n        #implies is reacahble in fewest # of jumps! \n        n = len(nums)\n        q = deque()\n        #start off bfs starting from index = 0! \n        q.append(0)\n        #now, process continuously as long as queue is non-empty! \n        minJumps = 0 \n        while q: \n            #at the very beginning, we should get length of queue => tell us # nodes\n            #we must go through at current level! \n            numNodes = len(q)\n            #process all nodes \n            while numNodes: \n                #current index! \n                cur = q.popleft()\n                #check if cur == n-1! If so, we reached end! \n                if cur == n-1:\n                    return minJumps \n                #from current index, see max upper bound for jump quantity! \n                maxJump = nums[cur]\n                #I can simply add next positions we can reach by jumping various quantities\n                #ranging from [1, maxJump]. Make sure we jump positive quantity or we stay still! \n                for i in range(1, maxJump+1):\n                    #add to queue to process lateR! \n                    q.append(cur + i)\n                #before we move to next iteration and expand our cur node's children, we should\n                #increment minJumps count since we move to next level of rec. dec. tree graph\n                #in bfs traversal! \n                numNodes -= 1 \n            minJumps += 1 \n        return minJumps \n```"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "class Solution {\\npublic:\\n    long long int func(int i,int n,vector<int> nums,long long int& temp,int v,vector<long long int>& dp){\\n        if(i>=n-1){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        v++;\\n        // cout<<v;\\n        for(int ind = 1;ind<=nums[i];ind++){\\n            temp = min(temp,v+func(ind+i,n,nums,temp,v,dp));\\n        }\\n        return dp[i] = temp;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n =nums.size();\\n        long long int temp = INT_MAX;;\\n        vector<long long int> dp(n,-1);\\n        return func(0,n,nums,temp,0,dp);\\n    }\\n};\\nthe same code when used with recursion is giving expected output but while using memoisation it is giving wrong value \\none example for this is [2,3,3,0,1,2]\\ncan anyone share their opinion on this about where the code is missing the trick"
                    },
                    {
                        "username": "jukov",
                        "content": "Me: want to train DP.\\nSolution: greedy.\\n\\nThanks for proper tagging."
                    },
                    {
                        "username": "kapilchn7",
                        "content": "what the hell is wrong with this test case, \\n[4,1,1,3,1,1,1], my answer is 3 expected is 2,\\n\\nIf we start from 0th index, then we would land at 1 next to 3 not on 3, \\n\\n[2,3,0,1,4] another example, my answer is 2 expected is 2\\nwe first take 1 step to reach 3, then we take 3 steps to reach 4"
                    },
                    {
                        "username": "kapilchn7",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thank you, I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each element nums[i] represents the **maximum** length of a forward jump.  \\nYou can do smaller jumps if that\\'s advantageous.  \\nIn your first example you can just 3 to get to index 3, then another 3 to get to 6, the target.  \\nIn your second example you can jump 1 to get to index 1, then 3 to get to index 4, the target."
                    },
                    {
                        "username": "rameshwar_prasad",
                        "content": "unable to get problem task please help me understand this problem."
                    },
                    {
                        "username": "RazPatel",
                        "content": "Try to use BFS"
                    },
                    {
                        "username": "ketkiambekar",
                        "content": "In the question statement,\n\n `you can jump to any nums[i + j] where`\n\nshould actually be\n\n `you can jump to any nums[i]+j where`\n\nThat should reduce the confusion\n"
                    },
                    {
                        "username": "Mostafaabdallah_",
                        "content": "why in the case of nums = [1,2,3] the output is 2 not 1 ? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "At index 0, we have 2 choices, either jump 0 step or jump 1 step.\\nWe will jump 1 step and reach index 1. // 1st Jump\\nAt index 1 we have 3 choices, jump 0,1,2 steps.\\nWe will jump 1 step and reach index n-1. // 2nd Jump\\n\\nSo output is 2, we need to make minimum 2 jumps."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "everyone, try O(n) solution, greedy BFS approach.\\nFeeling good after solving."
                    },
                    {
                        "username": "rayancsdc",
                        "content": "The recommended approach in this scenario is to use breadth-first search (BFS), which involves considering all possible nodes that can be reached in one step and then expanding those nodes to determine the range of possibilities for the next step.\n\nLet's examine a counterexample to demonstrate the potential inefficiency of a BFS solution:\n\nConsider the following sequence:\n\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until the end of a 10000-length array)]\n\nKey observations:\n\nDuring the first step, the first 5000 elements of the array are visible.\nIn all subsequent steps, the first 5000 elements do not contribute to pushing the right pointer any further; it only moves forward by one element each step.\nThe left pointer also moves forward by only one element each step, as all possibilities must be considered. For example, even if nums[i] is 50, nums[i+1] still needs to be evaluated as it could be 10000.\nConsidering these factors, it appears that the algor[i](https://yumzlab.com/collections/mushroom-gummies-amanita-muscaria)thm would need to execute 5000 steps, with each step considering 5000 nodes. This suggests an O(n^2) behavior rather than O(n). Did I overlook something?\n\nI acknowledge that this is a contrived input I created through adversarial thinking. However, if I recall correctly, big O notation represents the \"worst-case\" scenari"
                    }
                ]
            },
            {
                "id": 1967271,
                "content": [
                    {
                        "username": "JOON1234",
                        "content": "Anyone have tips on how I can optimize my BFS code? I already solved problem using bottom-up DP so I am trying to solve it in an alternative approach. I am getting \"Memory Exceeded Error\" on some inputs: \n\n ```\nfrom collections import deque \nclass Solution:\n    def jump(self, nums: List[int]) -> int:\n        #can also solve using bfs traversal => keep track of nodes labeled by index positions\n        #using queue data structure! The first index position that equals end (n-1) one that \n        #is reachable in fewest number of edges from root to itself in rec. decision tree =>\n        #implies is reacahble in fewest # of jumps! \n        n = len(nums)\n        q = deque()\n        #start off bfs starting from index = 0! \n        q.append(0)\n        #now, process continuously as long as queue is non-empty! \n        minJumps = 0 \n        while q: \n            #at the very beginning, we should get length of queue => tell us # nodes\n            #we must go through at current level! \n            numNodes = len(q)\n            #process all nodes \n            while numNodes: \n                #current index! \n                cur = q.popleft()\n                #check if cur == n-1! If so, we reached end! \n                if cur == n-1:\n                    return minJumps \n                #from current index, see max upper bound for jump quantity! \n                maxJump = nums[cur]\n                #I can simply add next positions we can reach by jumping various quantities\n                #ranging from [1, maxJump]. Make sure we jump positive quantity or we stay still! \n                for i in range(1, maxJump+1):\n                    #add to queue to process lateR! \n                    q.append(cur + i)\n                #before we move to next iteration and expand our cur node's children, we should\n                #increment minJumps count since we move to next level of rec. dec. tree graph\n                #in bfs traversal! \n                numNodes -= 1 \n            minJumps += 1 \n        return minJumps \n```"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "class Solution {\\npublic:\\n    long long int func(int i,int n,vector<int> nums,long long int& temp,int v,vector<long long int>& dp){\\n        if(i>=n-1){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        v++;\\n        // cout<<v;\\n        for(int ind = 1;ind<=nums[i];ind++){\\n            temp = min(temp,v+func(ind+i,n,nums,temp,v,dp));\\n        }\\n        return dp[i] = temp;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n =nums.size();\\n        long long int temp = INT_MAX;;\\n        vector<long long int> dp(n,-1);\\n        return func(0,n,nums,temp,0,dp);\\n    }\\n};\\nthe same code when used with recursion is giving expected output but while using memoisation it is giving wrong value \\none example for this is [2,3,3,0,1,2]\\ncan anyone share their opinion on this about where the code is missing the trick"
                    },
                    {
                        "username": "jukov",
                        "content": "Me: want to train DP.\\nSolution: greedy.\\n\\nThanks for proper tagging."
                    },
                    {
                        "username": "kapilchn7",
                        "content": "what the hell is wrong with this test case, \\n[4,1,1,3,1,1,1], my answer is 3 expected is 2,\\n\\nIf we start from 0th index, then we would land at 1 next to 3 not on 3, \\n\\n[2,3,0,1,4] another example, my answer is 2 expected is 2\\nwe first take 1 step to reach 3, then we take 3 steps to reach 4"
                    },
                    {
                        "username": "kapilchn7",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thank you, I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each element nums[i] represents the **maximum** length of a forward jump.  \\nYou can do smaller jumps if that\\'s advantageous.  \\nIn your first example you can just 3 to get to index 3, then another 3 to get to 6, the target.  \\nIn your second example you can jump 1 to get to index 1, then 3 to get to index 4, the target."
                    },
                    {
                        "username": "rameshwar_prasad",
                        "content": "unable to get problem task please help me understand this problem."
                    },
                    {
                        "username": "RazPatel",
                        "content": "Try to use BFS"
                    },
                    {
                        "username": "ketkiambekar",
                        "content": "In the question statement,\n\n `you can jump to any nums[i + j] where`\n\nshould actually be\n\n `you can jump to any nums[i]+j where`\n\nThat should reduce the confusion\n"
                    },
                    {
                        "username": "Mostafaabdallah_",
                        "content": "why in the case of nums = [1,2,3] the output is 2 not 1 ? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "At index 0, we have 2 choices, either jump 0 step or jump 1 step.\\nWe will jump 1 step and reach index 1. // 1st Jump\\nAt index 1 we have 3 choices, jump 0,1,2 steps.\\nWe will jump 1 step and reach index n-1. // 2nd Jump\\n\\nSo output is 2, we need to make minimum 2 jumps."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "everyone, try O(n) solution, greedy BFS approach.\\nFeeling good after solving."
                    },
                    {
                        "username": "rayancsdc",
                        "content": "The recommended approach in this scenario is to use breadth-first search (BFS), which involves considering all possible nodes that can be reached in one step and then expanding those nodes to determine the range of possibilities for the next step.\n\nLet's examine a counterexample to demonstrate the potential inefficiency of a BFS solution:\n\nConsider the following sequence:\n\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until the end of a 10000-length array)]\n\nKey observations:\n\nDuring the first step, the first 5000 elements of the array are visible.\nIn all subsequent steps, the first 5000 elements do not contribute to pushing the right pointer any further; it only moves forward by one element each step.\nThe left pointer also moves forward by only one element each step, as all possibilities must be considered. For example, even if nums[i] is 50, nums[i+1] still needs to be evaluated as it could be 10000.\nConsidering these factors, it appears that the algor[i](https://yumzlab.com/collections/mushroom-gummies-amanita-muscaria)thm would need to execute 5000 steps, with each step considering 5000 nodes. This suggests an O(n^2) behavior rather than O(n). Did I overlook something?\n\nI acknowledge that this is a contrived input I created through adversarial thinking. However, if I recall correctly, big O notation represents the \"worst-case\" scenari"
                    }
                ]
            },
            {
                "id": 1960871,
                "content": [
                    {
                        "username": "Haneet_Arya",
                        "content": "Always remember a concatenated print statement can create TLE"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I have solution in java if you want to see, follow this link: https://leetcode.com/problems/jump-game-ii/submissions/987677306/"
                    },
                    {
                        "username": "YonatanHen",
                        "content": "Using the following solution:\n\nclass Solution:\n    def jump(self, nums: List[int], x:int = 0) -> int:\n        # if array length == 1 return jumps\n        if(len(nums) == 1):\n            print(nums)\n            if(x==0):\n                return x\n            return x+1\n        elif(len(nums) == 0):\n            return 0\n        # find the distant index from the last value in the array\n        # slice the array from start to the index found\n        # run the function again by adding the jump number\n        indices = \n        return self.jump(nums[:min([i for (y, i) in zip(nums, range(len(nums)-1)) if len(nums) - i -1 <= nums[i]])], x + 1)\n\nWhy [1,2] did not return the expected results? what is wrong?"
                    },
                    {
                        "username": "miha4406",
                        "content": "They just want you to choose an option with longest reach, so if it\\'s [2,3,1,1,4], you have to choose 3, coz it\\'s index+value is larger than in case of 1: (1+3)>(2+1).  That\\'s all.  About [0], you need 0 steps to reach the last element, so it\\'s 0.  "
                    },
                    {
                        "username": "Django_Developer",
                        "content": "can someone explain to me what is \"j\" in that problem? Why people are so obsessed with giving variables such an abnormal names?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "From the instructions: \"if you are at `nums[i]`, you can jump to any `nums[i + j]` where: `0 <= j <= nums[i]` and `i + j < n`\"  \nIn other words: If you are at `nums[i]` you can choose the length of your jump within the range `[0, nums[i]]` (but not jump beyone the end of `nums`.)\n"
                    },
                    {
                        "username": "aelrouby",
                        "content": "[4,1,1,3,1,1,1] this test case does not look correct.\\nit is expecting 2, while the correct answer is 3"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I have found what appear to be incorrect test cases in previous problems and so have just tested for them before starting the function and returning the expected output even if it\\'s wrong "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You start at index `0`. From there you can jump at most `4` positions.  \\nYou jump `3` positions to index `3`. From there you can jum at most `3` positions.  \\nYou jump `3` positions to the index `6`, the goal.  \\nThat\\'s two jumps."
                    },
                    {
                        "username": "aelrouby",
                        "content": "[3,2,1] this test case is giving wrong expectation.\\nthe system expected 1, while the correct is 2.\\n1 means that the first element takes us to the end of the array, while the first element (3) takes us outside of the array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "\"Each element `nums[i]` represents the **maximum** length of a forward jump from index `i`.\""
                    },
                    {
                        "username": "Shrutipandey16",
                        "content": "why num.sum()-1,and when we have to return true or false then only it is num.size()?????"
                    },
                    {
                        "username": "Uttam-Gupta",
                        "content": "EZ ITERATION APPROACH\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        if (nums.size()==1)\\n        return 0;\\n        int jump=1,i=1;\\n        int point1=nums[0],point2=nums[1],check=0;\\n        while(i<nums.size()-1){\\n            point1--;\\n            if((point2-i+check)<=nums[i]){\\n                check=i;\\n                point2=nums[i];\\n            }\\n            if(point1==0){\\n                point1=point2-i+check;\\n                point2=nums[i+1];\\n                jump++;\\n            }\\n            i++;\\n        }\\n        return jump;\\n    }\\n};"
                    },
                    {
                        "username": "yashk_07",
                        "content": "class Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n\\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i] + i, nums[i-1]);\\n      }\\n\\n      int index = 0;\\n      int answer = 0;\\n\\n      while(index < nums.size() - 1)\\n      {\\n        answer++;\\n        index = nums[index];\\n      }\\n\\n      return answer;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1958603,
                "content": [
                    {
                        "username": "Haneet_Arya",
                        "content": "Always remember a concatenated print statement can create TLE"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I have solution in java if you want to see, follow this link: https://leetcode.com/problems/jump-game-ii/submissions/987677306/"
                    },
                    {
                        "username": "YonatanHen",
                        "content": "Using the following solution:\n\nclass Solution:\n    def jump(self, nums: List[int], x:int = 0) -> int:\n        # if array length == 1 return jumps\n        if(len(nums) == 1):\n            print(nums)\n            if(x==0):\n                return x\n            return x+1\n        elif(len(nums) == 0):\n            return 0\n        # find the distant index from the last value in the array\n        # slice the array from start to the index found\n        # run the function again by adding the jump number\n        indices = \n        return self.jump(nums[:min([i for (y, i) in zip(nums, range(len(nums)-1)) if len(nums) - i -1 <= nums[i]])], x + 1)\n\nWhy [1,2] did not return the expected results? what is wrong?"
                    },
                    {
                        "username": "miha4406",
                        "content": "They just want you to choose an option with longest reach, so if it\\'s [2,3,1,1,4], you have to choose 3, coz it\\'s index+value is larger than in case of 1: (1+3)>(2+1).  That\\'s all.  About [0], you need 0 steps to reach the last element, so it\\'s 0.  "
                    },
                    {
                        "username": "Django_Developer",
                        "content": "can someone explain to me what is \"j\" in that problem? Why people are so obsessed with giving variables such an abnormal names?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "From the instructions: \"if you are at `nums[i]`, you can jump to any `nums[i + j]` where: `0 <= j <= nums[i]` and `i + j < n`\"  \nIn other words: If you are at `nums[i]` you can choose the length of your jump within the range `[0, nums[i]]` (but not jump beyone the end of `nums`.)\n"
                    },
                    {
                        "username": "aelrouby",
                        "content": "[4,1,1,3,1,1,1] this test case does not look correct.\\nit is expecting 2, while the correct answer is 3"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I have found what appear to be incorrect test cases in previous problems and so have just tested for them before starting the function and returning the expected output even if it\\'s wrong "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You start at index `0`. From there you can jump at most `4` positions.  \\nYou jump `3` positions to index `3`. From there you can jum at most `3` positions.  \\nYou jump `3` positions to the index `6`, the goal.  \\nThat\\'s two jumps."
                    },
                    {
                        "username": "aelrouby",
                        "content": "[3,2,1] this test case is giving wrong expectation.\\nthe system expected 1, while the correct is 2.\\n1 means that the first element takes us to the end of the array, while the first element (3) takes us outside of the array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "\"Each element `nums[i]` represents the **maximum** length of a forward jump from index `i`.\""
                    },
                    {
                        "username": "Shrutipandey16",
                        "content": "why num.sum()-1,and when we have to return true or false then only it is num.size()?????"
                    },
                    {
                        "username": "Uttam-Gupta",
                        "content": "EZ ITERATION APPROACH\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        if (nums.size()==1)\\n        return 0;\\n        int jump=1,i=1;\\n        int point1=nums[0],point2=nums[1],check=0;\\n        while(i<nums.size()-1){\\n            point1--;\\n            if((point2-i+check)<=nums[i]){\\n                check=i;\\n                point2=nums[i];\\n            }\\n            if(point1==0){\\n                point1=point2-i+check;\\n                point2=nums[i+1];\\n                jump++;\\n            }\\n            i++;\\n        }\\n        return jump;\\n    }\\n};"
                    },
                    {
                        "username": "yashk_07",
                        "content": "class Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n\\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i] + i, nums[i-1]);\\n      }\\n\\n      int index = 0;\\n      int answer = 0;\\n\\n      while(index < nums.size() - 1)\\n      {\\n        answer++;\\n        index = nums[index];\\n      }\\n\\n      return answer;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1918874,
                "content": [
                    {
                        "username": "Haneet_Arya",
                        "content": "Always remember a concatenated print statement can create TLE"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I have solution in java if you want to see, follow this link: https://leetcode.com/problems/jump-game-ii/submissions/987677306/"
                    },
                    {
                        "username": "YonatanHen",
                        "content": "Using the following solution:\n\nclass Solution:\n    def jump(self, nums: List[int], x:int = 0) -> int:\n        # if array length == 1 return jumps\n        if(len(nums) == 1):\n            print(nums)\n            if(x==0):\n                return x\n            return x+1\n        elif(len(nums) == 0):\n            return 0\n        # find the distant index from the last value in the array\n        # slice the array from start to the index found\n        # run the function again by adding the jump number\n        indices = \n        return self.jump(nums[:min([i for (y, i) in zip(nums, range(len(nums)-1)) if len(nums) - i -1 <= nums[i]])], x + 1)\n\nWhy [1,2] did not return the expected results? what is wrong?"
                    },
                    {
                        "username": "miha4406",
                        "content": "They just want you to choose an option with longest reach, so if it\\'s [2,3,1,1,4], you have to choose 3, coz it\\'s index+value is larger than in case of 1: (1+3)>(2+1).  That\\'s all.  About [0], you need 0 steps to reach the last element, so it\\'s 0.  "
                    },
                    {
                        "username": "Django_Developer",
                        "content": "can someone explain to me what is \"j\" in that problem? Why people are so obsessed with giving variables such an abnormal names?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "From the instructions: \"if you are at `nums[i]`, you can jump to any `nums[i + j]` where: `0 <= j <= nums[i]` and `i + j < n`\"  \nIn other words: If you are at `nums[i]` you can choose the length of your jump within the range `[0, nums[i]]` (but not jump beyone the end of `nums`.)\n"
                    },
                    {
                        "username": "aelrouby",
                        "content": "[4,1,1,3,1,1,1] this test case does not look correct.\\nit is expecting 2, while the correct answer is 3"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I have found what appear to be incorrect test cases in previous problems and so have just tested for them before starting the function and returning the expected output even if it\\'s wrong "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You start at index `0`. From there you can jump at most `4` positions.  \\nYou jump `3` positions to index `3`. From there you can jum at most `3` positions.  \\nYou jump `3` positions to the index `6`, the goal.  \\nThat\\'s two jumps."
                    },
                    {
                        "username": "aelrouby",
                        "content": "[3,2,1] this test case is giving wrong expectation.\\nthe system expected 1, while the correct is 2.\\n1 means that the first element takes us to the end of the array, while the first element (3) takes us outside of the array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "\"Each element `nums[i]` represents the **maximum** length of a forward jump from index `i`.\""
                    },
                    {
                        "username": "Shrutipandey16",
                        "content": "why num.sum()-1,and when we have to return true or false then only it is num.size()?????"
                    },
                    {
                        "username": "Uttam-Gupta",
                        "content": "EZ ITERATION APPROACH\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        if (nums.size()==1)\\n        return 0;\\n        int jump=1,i=1;\\n        int point1=nums[0],point2=nums[1],check=0;\\n        while(i<nums.size()-1){\\n            point1--;\\n            if((point2-i+check)<=nums[i]){\\n                check=i;\\n                point2=nums[i];\\n            }\\n            if(point1==0){\\n                point1=point2-i+check;\\n                point2=nums[i+1];\\n                jump++;\\n            }\\n            i++;\\n        }\\n        return jump;\\n    }\\n};"
                    },
                    {
                        "username": "yashk_07",
                        "content": "class Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n\\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i] + i, nums[i-1]);\\n      }\\n\\n      int index = 0;\\n      int answer = 0;\\n\\n      while(index < nums.size() - 1)\\n      {\\n        answer++;\\n        index = nums[index];\\n      }\\n\\n      return answer;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1868324,
                "content": [
                    {
                        "username": "Haneet_Arya",
                        "content": "Always remember a concatenated print statement can create TLE"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I have solution in java if you want to see, follow this link: https://leetcode.com/problems/jump-game-ii/submissions/987677306/"
                    },
                    {
                        "username": "YonatanHen",
                        "content": "Using the following solution:\n\nclass Solution:\n    def jump(self, nums: List[int], x:int = 0) -> int:\n        # if array length == 1 return jumps\n        if(len(nums) == 1):\n            print(nums)\n            if(x==0):\n                return x\n            return x+1\n        elif(len(nums) == 0):\n            return 0\n        # find the distant index from the last value in the array\n        # slice the array from start to the index found\n        # run the function again by adding the jump number\n        indices = \n        return self.jump(nums[:min([i for (y, i) in zip(nums, range(len(nums)-1)) if len(nums) - i -1 <= nums[i]])], x + 1)\n\nWhy [1,2] did not return the expected results? what is wrong?"
                    },
                    {
                        "username": "miha4406",
                        "content": "They just want you to choose an option with longest reach, so if it\\'s [2,3,1,1,4], you have to choose 3, coz it\\'s index+value is larger than in case of 1: (1+3)>(2+1).  That\\'s all.  About [0], you need 0 steps to reach the last element, so it\\'s 0.  "
                    },
                    {
                        "username": "Django_Developer",
                        "content": "can someone explain to me what is \"j\" in that problem? Why people are so obsessed with giving variables such an abnormal names?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "From the instructions: \"if you are at `nums[i]`, you can jump to any `nums[i + j]` where: `0 <= j <= nums[i]` and `i + j < n`\"  \nIn other words: If you are at `nums[i]` you can choose the length of your jump within the range `[0, nums[i]]` (but not jump beyone the end of `nums`.)\n"
                    },
                    {
                        "username": "aelrouby",
                        "content": "[4,1,1,3,1,1,1] this test case does not look correct.\\nit is expecting 2, while the correct answer is 3"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I have found what appear to be incorrect test cases in previous problems and so have just tested for them before starting the function and returning the expected output even if it\\'s wrong "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You start at index `0`. From there you can jump at most `4` positions.  \\nYou jump `3` positions to index `3`. From there you can jum at most `3` positions.  \\nYou jump `3` positions to the index `6`, the goal.  \\nThat\\'s two jumps."
                    },
                    {
                        "username": "aelrouby",
                        "content": "[3,2,1] this test case is giving wrong expectation.\\nthe system expected 1, while the correct is 2.\\n1 means that the first element takes us to the end of the array, while the first element (3) takes us outside of the array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "\"Each element `nums[i]` represents the **maximum** length of a forward jump from index `i`.\""
                    },
                    {
                        "username": "Shrutipandey16",
                        "content": "why num.sum()-1,and when we have to return true or false then only it is num.size()?????"
                    },
                    {
                        "username": "Uttam-Gupta",
                        "content": "EZ ITERATION APPROACH\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        if (nums.size()==1)\\n        return 0;\\n        int jump=1,i=1;\\n        int point1=nums[0],point2=nums[1],check=0;\\n        while(i<nums.size()-1){\\n            point1--;\\n            if((point2-i+check)<=nums[i]){\\n                check=i;\\n                point2=nums[i];\\n            }\\n            if(point1==0){\\n                point1=point2-i+check;\\n                point2=nums[i+1];\\n                jump++;\\n            }\\n            i++;\\n        }\\n        return jump;\\n    }\\n};"
                    },
                    {
                        "username": "yashk_07",
                        "content": "class Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n\\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i] + i, nums[i-1]);\\n      }\\n\\n      int index = 0;\\n      int answer = 0;\\n\\n      while(index < nums.size() - 1)\\n      {\\n        answer++;\\n        index = nums[index];\\n      }\\n\\n      return answer;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1854696,
                "content": [
                    {
                        "username": "Haneet_Arya",
                        "content": "Always remember a concatenated print statement can create TLE"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I have solution in java if you want to see, follow this link: https://leetcode.com/problems/jump-game-ii/submissions/987677306/"
                    },
                    {
                        "username": "YonatanHen",
                        "content": "Using the following solution:\n\nclass Solution:\n    def jump(self, nums: List[int], x:int = 0) -> int:\n        # if array length == 1 return jumps\n        if(len(nums) == 1):\n            print(nums)\n            if(x==0):\n                return x\n            return x+1\n        elif(len(nums) == 0):\n            return 0\n        # find the distant index from the last value in the array\n        # slice the array from start to the index found\n        # run the function again by adding the jump number\n        indices = \n        return self.jump(nums[:min([i for (y, i) in zip(nums, range(len(nums)-1)) if len(nums) - i -1 <= nums[i]])], x + 1)\n\nWhy [1,2] did not return the expected results? what is wrong?"
                    },
                    {
                        "username": "miha4406",
                        "content": "They just want you to choose an option with longest reach, so if it\\'s [2,3,1,1,4], you have to choose 3, coz it\\'s index+value is larger than in case of 1: (1+3)>(2+1).  That\\'s all.  About [0], you need 0 steps to reach the last element, so it\\'s 0.  "
                    },
                    {
                        "username": "Django_Developer",
                        "content": "can someone explain to me what is \"j\" in that problem? Why people are so obsessed with giving variables such an abnormal names?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "From the instructions: \"if you are at `nums[i]`, you can jump to any `nums[i + j]` where: `0 <= j <= nums[i]` and `i + j < n`\"  \nIn other words: If you are at `nums[i]` you can choose the length of your jump within the range `[0, nums[i]]` (but not jump beyone the end of `nums`.)\n"
                    },
                    {
                        "username": "aelrouby",
                        "content": "[4,1,1,3,1,1,1] this test case does not look correct.\\nit is expecting 2, while the correct answer is 3"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I have found what appear to be incorrect test cases in previous problems and so have just tested for them before starting the function and returning the expected output even if it\\'s wrong "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You start at index `0`. From there you can jump at most `4` positions.  \\nYou jump `3` positions to index `3`. From there you can jum at most `3` positions.  \\nYou jump `3` positions to the index `6`, the goal.  \\nThat\\'s two jumps."
                    },
                    {
                        "username": "aelrouby",
                        "content": "[3,2,1] this test case is giving wrong expectation.\\nthe system expected 1, while the correct is 2.\\n1 means that the first element takes us to the end of the array, while the first element (3) takes us outside of the array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "\"Each element `nums[i]` represents the **maximum** length of a forward jump from index `i`.\""
                    },
                    {
                        "username": "Shrutipandey16",
                        "content": "why num.sum()-1,and when we have to return true or false then only it is num.size()?????"
                    },
                    {
                        "username": "Uttam-Gupta",
                        "content": "EZ ITERATION APPROACH\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        if (nums.size()==1)\\n        return 0;\\n        int jump=1,i=1;\\n        int point1=nums[0],point2=nums[1],check=0;\\n        while(i<nums.size()-1){\\n            point1--;\\n            if((point2-i+check)<=nums[i]){\\n                check=i;\\n                point2=nums[i];\\n            }\\n            if(point1==0){\\n                point1=point2-i+check;\\n                point2=nums[i+1];\\n                jump++;\\n            }\\n            i++;\\n        }\\n        return jump;\\n    }\\n};"
                    },
                    {
                        "username": "yashk_07",
                        "content": "class Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n\\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i] + i, nums[i-1]);\\n      }\\n\\n      int index = 0;\\n      int answer = 0;\\n\\n      while(index < nums.size() - 1)\\n      {\\n        answer++;\\n        index = nums[index];\\n      }\\n\\n      return answer;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1838890,
                "content": [
                    {
                        "username": "Haneet_Arya",
                        "content": "Always remember a concatenated print statement can create TLE"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I have solution in java if you want to see, follow this link: https://leetcode.com/problems/jump-game-ii/submissions/987677306/"
                    },
                    {
                        "username": "YonatanHen",
                        "content": "Using the following solution:\n\nclass Solution:\n    def jump(self, nums: List[int], x:int = 0) -> int:\n        # if array length == 1 return jumps\n        if(len(nums) == 1):\n            print(nums)\n            if(x==0):\n                return x\n            return x+1\n        elif(len(nums) == 0):\n            return 0\n        # find the distant index from the last value in the array\n        # slice the array from start to the index found\n        # run the function again by adding the jump number\n        indices = \n        return self.jump(nums[:min([i for (y, i) in zip(nums, range(len(nums)-1)) if len(nums) - i -1 <= nums[i]])], x + 1)\n\nWhy [1,2] did not return the expected results? what is wrong?"
                    },
                    {
                        "username": "miha4406",
                        "content": "They just want you to choose an option with longest reach, so if it\\'s [2,3,1,1,4], you have to choose 3, coz it\\'s index+value is larger than in case of 1: (1+3)>(2+1).  That\\'s all.  About [0], you need 0 steps to reach the last element, so it\\'s 0.  "
                    },
                    {
                        "username": "Django_Developer",
                        "content": "can someone explain to me what is \"j\" in that problem? Why people are so obsessed with giving variables such an abnormal names?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "From the instructions: \"if you are at `nums[i]`, you can jump to any `nums[i + j]` where: `0 <= j <= nums[i]` and `i + j < n`\"  \nIn other words: If you are at `nums[i]` you can choose the length of your jump within the range `[0, nums[i]]` (but not jump beyone the end of `nums`.)\n"
                    },
                    {
                        "username": "aelrouby",
                        "content": "[4,1,1,3,1,1,1] this test case does not look correct.\\nit is expecting 2, while the correct answer is 3"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I have found what appear to be incorrect test cases in previous problems and so have just tested for them before starting the function and returning the expected output even if it\\'s wrong "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You start at index `0`. From there you can jump at most `4` positions.  \\nYou jump `3` positions to index `3`. From there you can jum at most `3` positions.  \\nYou jump `3` positions to the index `6`, the goal.  \\nThat\\'s two jumps."
                    },
                    {
                        "username": "aelrouby",
                        "content": "[3,2,1] this test case is giving wrong expectation.\\nthe system expected 1, while the correct is 2.\\n1 means that the first element takes us to the end of the array, while the first element (3) takes us outside of the array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "\"Each element `nums[i]` represents the **maximum** length of a forward jump from index `i`.\""
                    },
                    {
                        "username": "Shrutipandey16",
                        "content": "why num.sum()-1,and when we have to return true or false then only it is num.size()?????"
                    },
                    {
                        "username": "Uttam-Gupta",
                        "content": "EZ ITERATION APPROACH\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        if (nums.size()==1)\\n        return 0;\\n        int jump=1,i=1;\\n        int point1=nums[0],point2=nums[1],check=0;\\n        while(i<nums.size()-1){\\n            point1--;\\n            if((point2-i+check)<=nums[i]){\\n                check=i;\\n                point2=nums[i];\\n            }\\n            if(point1==0){\\n                point1=point2-i+check;\\n                point2=nums[i+1];\\n                jump++;\\n            }\\n            i++;\\n        }\\n        return jump;\\n    }\\n};"
                    },
                    {
                        "username": "yashk_07",
                        "content": "class Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n\\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i] + i, nums[i-1]);\\n      }\\n\\n      int index = 0;\\n      int answer = 0;\\n\\n      while(index < nums.size() - 1)\\n      {\\n        answer++;\\n        index = nums[index];\\n      }\\n\\n      return answer;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1838856,
                "content": [
                    {
                        "username": "Haneet_Arya",
                        "content": "Always remember a concatenated print statement can create TLE"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I have solution in java if you want to see, follow this link: https://leetcode.com/problems/jump-game-ii/submissions/987677306/"
                    },
                    {
                        "username": "YonatanHen",
                        "content": "Using the following solution:\n\nclass Solution:\n    def jump(self, nums: List[int], x:int = 0) -> int:\n        # if array length == 1 return jumps\n        if(len(nums) == 1):\n            print(nums)\n            if(x==0):\n                return x\n            return x+1\n        elif(len(nums) == 0):\n            return 0\n        # find the distant index from the last value in the array\n        # slice the array from start to the index found\n        # run the function again by adding the jump number\n        indices = \n        return self.jump(nums[:min([i for (y, i) in zip(nums, range(len(nums)-1)) if len(nums) - i -1 <= nums[i]])], x + 1)\n\nWhy [1,2] did not return the expected results? what is wrong?"
                    },
                    {
                        "username": "miha4406",
                        "content": "They just want you to choose an option with longest reach, so if it\\'s [2,3,1,1,4], you have to choose 3, coz it\\'s index+value is larger than in case of 1: (1+3)>(2+1).  That\\'s all.  About [0], you need 0 steps to reach the last element, so it\\'s 0.  "
                    },
                    {
                        "username": "Django_Developer",
                        "content": "can someone explain to me what is \"j\" in that problem? Why people are so obsessed with giving variables such an abnormal names?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "From the instructions: \"if you are at `nums[i]`, you can jump to any `nums[i + j]` where: `0 <= j <= nums[i]` and `i + j < n`\"  \nIn other words: If you are at `nums[i]` you can choose the length of your jump within the range `[0, nums[i]]` (but not jump beyone the end of `nums`.)\n"
                    },
                    {
                        "username": "aelrouby",
                        "content": "[4,1,1,3,1,1,1] this test case does not look correct.\\nit is expecting 2, while the correct answer is 3"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I have found what appear to be incorrect test cases in previous problems and so have just tested for them before starting the function and returning the expected output even if it\\'s wrong "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You start at index `0`. From there you can jump at most `4` positions.  \\nYou jump `3` positions to index `3`. From there you can jum at most `3` positions.  \\nYou jump `3` positions to the index `6`, the goal.  \\nThat\\'s two jumps."
                    },
                    {
                        "username": "aelrouby",
                        "content": "[3,2,1] this test case is giving wrong expectation.\\nthe system expected 1, while the correct is 2.\\n1 means that the first element takes us to the end of the array, while the first element (3) takes us outside of the array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "\"Each element `nums[i]` represents the **maximum** length of a forward jump from index `i`.\""
                    },
                    {
                        "username": "Shrutipandey16",
                        "content": "why num.sum()-1,and when we have to return true or false then only it is num.size()?????"
                    },
                    {
                        "username": "Uttam-Gupta",
                        "content": "EZ ITERATION APPROACH\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        if (nums.size()==1)\\n        return 0;\\n        int jump=1,i=1;\\n        int point1=nums[0],point2=nums[1],check=0;\\n        while(i<nums.size()-1){\\n            point1--;\\n            if((point2-i+check)<=nums[i]){\\n                check=i;\\n                point2=nums[i];\\n            }\\n            if(point1==0){\\n                point1=point2-i+check;\\n                point2=nums[i+1];\\n                jump++;\\n            }\\n            i++;\\n        }\\n        return jump;\\n    }\\n};"
                    },
                    {
                        "username": "yashk_07",
                        "content": "class Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n\\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i] + i, nums[i-1]);\\n      }\\n\\n      int index = 0;\\n      int answer = 0;\\n\\n      while(index < nums.size() - 1)\\n      {\\n        answer++;\\n        index = nums[index];\\n      }\\n\\n      return answer;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1806089,
                "content": [
                    {
                        "username": "Haneet_Arya",
                        "content": "Always remember a concatenated print statement can create TLE"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I have solution in java if you want to see, follow this link: https://leetcode.com/problems/jump-game-ii/submissions/987677306/"
                    },
                    {
                        "username": "YonatanHen",
                        "content": "Using the following solution:\n\nclass Solution:\n    def jump(self, nums: List[int], x:int = 0) -> int:\n        # if array length == 1 return jumps\n        if(len(nums) == 1):\n            print(nums)\n            if(x==0):\n                return x\n            return x+1\n        elif(len(nums) == 0):\n            return 0\n        # find the distant index from the last value in the array\n        # slice the array from start to the index found\n        # run the function again by adding the jump number\n        indices = \n        return self.jump(nums[:min([i for (y, i) in zip(nums, range(len(nums)-1)) if len(nums) - i -1 <= nums[i]])], x + 1)\n\nWhy [1,2] did not return the expected results? what is wrong?"
                    },
                    {
                        "username": "miha4406",
                        "content": "They just want you to choose an option with longest reach, so if it\\'s [2,3,1,1,4], you have to choose 3, coz it\\'s index+value is larger than in case of 1: (1+3)>(2+1).  That\\'s all.  About [0], you need 0 steps to reach the last element, so it\\'s 0.  "
                    },
                    {
                        "username": "Django_Developer",
                        "content": "can someone explain to me what is \"j\" in that problem? Why people are so obsessed with giving variables such an abnormal names?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "From the instructions: \"if you are at `nums[i]`, you can jump to any `nums[i + j]` where: `0 <= j <= nums[i]` and `i + j < n`\"  \nIn other words: If you are at `nums[i]` you can choose the length of your jump within the range `[0, nums[i]]` (but not jump beyone the end of `nums`.)\n"
                    },
                    {
                        "username": "aelrouby",
                        "content": "[4,1,1,3,1,1,1] this test case does not look correct.\\nit is expecting 2, while the correct answer is 3"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I have found what appear to be incorrect test cases in previous problems and so have just tested for them before starting the function and returning the expected output even if it\\'s wrong "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You start at index `0`. From there you can jump at most `4` positions.  \\nYou jump `3` positions to index `3`. From there you can jum at most `3` positions.  \\nYou jump `3` positions to the index `6`, the goal.  \\nThat\\'s two jumps."
                    },
                    {
                        "username": "aelrouby",
                        "content": "[3,2,1] this test case is giving wrong expectation.\\nthe system expected 1, while the correct is 2.\\n1 means that the first element takes us to the end of the array, while the first element (3) takes us outside of the array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "\"Each element `nums[i]` represents the **maximum** length of a forward jump from index `i`.\""
                    },
                    {
                        "username": "Shrutipandey16",
                        "content": "why num.sum()-1,and when we have to return true or false then only it is num.size()?????"
                    },
                    {
                        "username": "Uttam-Gupta",
                        "content": "EZ ITERATION APPROACH\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        if (nums.size()==1)\\n        return 0;\\n        int jump=1,i=1;\\n        int point1=nums[0],point2=nums[1],check=0;\\n        while(i<nums.size()-1){\\n            point1--;\\n            if((point2-i+check)<=nums[i]){\\n                check=i;\\n                point2=nums[i];\\n            }\\n            if(point1==0){\\n                point1=point2-i+check;\\n                point2=nums[i+1];\\n                jump++;\\n            }\\n            i++;\\n        }\\n        return jump;\\n    }\\n};"
                    },
                    {
                        "username": "yashk_07",
                        "content": "class Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n\\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i] + i, nums[i-1]);\\n      }\\n\\n      int index = 0;\\n      int answer = 0;\\n\\n      while(index < nums.size() - 1)\\n      {\\n        answer++;\\n        index = nums[index];\\n      }\\n\\n      return answer;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1793545,
                "content": [
                    {
                        "username": "Haneet_Arya",
                        "content": "Always remember a concatenated print statement can create TLE"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I have solution in java if you want to see, follow this link: https://leetcode.com/problems/jump-game-ii/submissions/987677306/"
                    },
                    {
                        "username": "YonatanHen",
                        "content": "Using the following solution:\n\nclass Solution:\n    def jump(self, nums: List[int], x:int = 0) -> int:\n        # if array length == 1 return jumps\n        if(len(nums) == 1):\n            print(nums)\n            if(x==0):\n                return x\n            return x+1\n        elif(len(nums) == 0):\n            return 0\n        # find the distant index from the last value in the array\n        # slice the array from start to the index found\n        # run the function again by adding the jump number\n        indices = \n        return self.jump(nums[:min([i for (y, i) in zip(nums, range(len(nums)-1)) if len(nums) - i -1 <= nums[i]])], x + 1)\n\nWhy [1,2] did not return the expected results? what is wrong?"
                    },
                    {
                        "username": "miha4406",
                        "content": "They just want you to choose an option with longest reach, so if it\\'s [2,3,1,1,4], you have to choose 3, coz it\\'s index+value is larger than in case of 1: (1+3)>(2+1).  That\\'s all.  About [0], you need 0 steps to reach the last element, so it\\'s 0.  "
                    },
                    {
                        "username": "Django_Developer",
                        "content": "can someone explain to me what is \"j\" in that problem? Why people are so obsessed with giving variables such an abnormal names?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "From the instructions: \"if you are at `nums[i]`, you can jump to any `nums[i + j]` where: `0 <= j <= nums[i]` and `i + j < n`\"  \nIn other words: If you are at `nums[i]` you can choose the length of your jump within the range `[0, nums[i]]` (but not jump beyone the end of `nums`.)\n"
                    },
                    {
                        "username": "aelrouby",
                        "content": "[4,1,1,3,1,1,1] this test case does not look correct.\\nit is expecting 2, while the correct answer is 3"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I have found what appear to be incorrect test cases in previous problems and so have just tested for them before starting the function and returning the expected output even if it\\'s wrong "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You start at index `0`. From there you can jump at most `4` positions.  \\nYou jump `3` positions to index `3`. From there you can jum at most `3` positions.  \\nYou jump `3` positions to the index `6`, the goal.  \\nThat\\'s two jumps."
                    },
                    {
                        "username": "aelrouby",
                        "content": "[3,2,1] this test case is giving wrong expectation.\\nthe system expected 1, while the correct is 2.\\n1 means that the first element takes us to the end of the array, while the first element (3) takes us outside of the array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "\"Each element `nums[i]` represents the **maximum** length of a forward jump from index `i`.\""
                    },
                    {
                        "username": "Shrutipandey16",
                        "content": "why num.sum()-1,and when we have to return true or false then only it is num.size()?????"
                    },
                    {
                        "username": "Uttam-Gupta",
                        "content": "EZ ITERATION APPROACH\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        if (nums.size()==1)\\n        return 0;\\n        int jump=1,i=1;\\n        int point1=nums[0],point2=nums[1],check=0;\\n        while(i<nums.size()-1){\\n            point1--;\\n            if((point2-i+check)<=nums[i]){\\n                check=i;\\n                point2=nums[i];\\n            }\\n            if(point1==0){\\n                point1=point2-i+check;\\n                point2=nums[i+1];\\n                jump++;\\n            }\\n            i++;\\n        }\\n        return jump;\\n    }\\n};"
                    },
                    {
                        "username": "yashk_07",
                        "content": "class Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n\\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i] + i, nums[i-1]);\\n      }\\n\\n      int index = 0;\\n      int answer = 0;\\n\\n      while(index < nums.size() - 1)\\n      {\\n        answer++;\\n        index = nums[index];\\n      }\\n\\n      return answer;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1793533,
                "content": [
                    {
                        "username": "Haneet_Arya",
                        "content": "Always remember a concatenated print statement can create TLE"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I have solution in java if you want to see, follow this link: https://leetcode.com/problems/jump-game-ii/submissions/987677306/"
                    },
                    {
                        "username": "YonatanHen",
                        "content": "Using the following solution:\n\nclass Solution:\n    def jump(self, nums: List[int], x:int = 0) -> int:\n        # if array length == 1 return jumps\n        if(len(nums) == 1):\n            print(nums)\n            if(x==0):\n                return x\n            return x+1\n        elif(len(nums) == 0):\n            return 0\n        # find the distant index from the last value in the array\n        # slice the array from start to the index found\n        # run the function again by adding the jump number\n        indices = \n        return self.jump(nums[:min([i for (y, i) in zip(nums, range(len(nums)-1)) if len(nums) - i -1 <= nums[i]])], x + 1)\n\nWhy [1,2] did not return the expected results? what is wrong?"
                    },
                    {
                        "username": "miha4406",
                        "content": "They just want you to choose an option with longest reach, so if it\\'s [2,3,1,1,4], you have to choose 3, coz it\\'s index+value is larger than in case of 1: (1+3)>(2+1).  That\\'s all.  About [0], you need 0 steps to reach the last element, so it\\'s 0.  "
                    },
                    {
                        "username": "Django_Developer",
                        "content": "can someone explain to me what is \"j\" in that problem? Why people are so obsessed with giving variables such an abnormal names?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "From the instructions: \"if you are at `nums[i]`, you can jump to any `nums[i + j]` where: `0 <= j <= nums[i]` and `i + j < n`\"  \nIn other words: If you are at `nums[i]` you can choose the length of your jump within the range `[0, nums[i]]` (but not jump beyone the end of `nums`.)\n"
                    },
                    {
                        "username": "aelrouby",
                        "content": "[4,1,1,3,1,1,1] this test case does not look correct.\\nit is expecting 2, while the correct answer is 3"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I have found what appear to be incorrect test cases in previous problems and so have just tested for them before starting the function and returning the expected output even if it\\'s wrong "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You start at index `0`. From there you can jump at most `4` positions.  \\nYou jump `3` positions to index `3`. From there you can jum at most `3` positions.  \\nYou jump `3` positions to the index `6`, the goal.  \\nThat\\'s two jumps."
                    },
                    {
                        "username": "aelrouby",
                        "content": "[3,2,1] this test case is giving wrong expectation.\\nthe system expected 1, while the correct is 2.\\n1 means that the first element takes us to the end of the array, while the first element (3) takes us outside of the array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "\"Each element `nums[i]` represents the **maximum** length of a forward jump from index `i`.\""
                    },
                    {
                        "username": "Shrutipandey16",
                        "content": "why num.sum()-1,and when we have to return true or false then only it is num.size()?????"
                    },
                    {
                        "username": "Uttam-Gupta",
                        "content": "EZ ITERATION APPROACH\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        if (nums.size()==1)\\n        return 0;\\n        int jump=1,i=1;\\n        int point1=nums[0],point2=nums[1],check=0;\\n        while(i<nums.size()-1){\\n            point1--;\\n            if((point2-i+check)<=nums[i]){\\n                check=i;\\n                point2=nums[i];\\n            }\\n            if(point1==0){\\n                point1=point2-i+check;\\n                point2=nums[i+1];\\n                jump++;\\n            }\\n            i++;\\n        }\\n        return jump;\\n    }\\n};"
                    },
                    {
                        "username": "yashk_07",
                        "content": "class Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n\\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i] + i, nums[i-1]);\\n      }\\n\\n      int index = 0;\\n      int answer = 0;\\n\\n      while(index < nums.size() - 1)\\n      {\\n        answer++;\\n        index = nums[index];\\n      }\\n\\n      return answer;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1793502,
                "content": [
                    {
                        "username": "shivam9935",
                        "content": "I am always able to think of recursion in this way but dynamic programing this is always a challenge for me. Can someone help me add memoization in this way?\\n\\n ```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        m = float(\\'inf\\')\\n        \\n        def j(current, jumps, left):\\n            if current == n-1:\\n                nonlocal m\\n                m = min(m, jumps)\\n                return\\n            if left == 0:\\n                # we have to take this jump\\n                j(current+1, jumps+1, nums[current]-1)\\n            if left > 0:\\n                #either we take it\\n                j(current+1, jumps+1, nums[current]-1)\\n                #or we leave current index\\n                j(current+1, jumps, left-1)\\n        \\n        j(0,0,0)\\n        return m\\n```"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "how  [1,1,1,1] answer is 3"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar)  great\\nyou can see my submission there are 3 diffrenet code in it\\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894277570/)"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "thank u [@harsh_negi_07](/harsh_negi_07) \\ni solved this, here is my  c code (beats 90%) \\nhere js = jumps, m = next index where we jump\\nint jump(int* nums, int n){\\n    int js = 0, m;\\n    if (n == 1) return 0;\\n    for (int i = 0; i < n; ){\\n        if (i + nums[i] >= n-1) return ++js;\\n        m = i+1;\\n        for (int j = i+2, k = nums[i]-1; k > 0; j++, k--)\\n            if ((nums[j] + j) >= (nums[m] + m)) m = j;\\n         i = m;\\n         ++js;\\n    }\\n    return js;\\n}"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar) \\n0 <= j <= nums[i] is the value of jump that you can take\\nit\\'s not a comparison statement ...\\nit\\'s telling you the value of jump you can take from current index and not going out of bound that is n"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "[@harsh_negi_07](/harsh_negi_07) \\nbut the question says \\n\"if you are at nums[i], you can jump to any nums[i + j] where:\\n\\n0 <= j <= nums[i] and\\ni + j < n\"\\nso when we are at index 1 how can we jump to index 2 bcz 2 > nums[1]\\nplz tell if i understand question wrong"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohit](/mohitjakhar) \nInitially number of jump is **zero**\nfrom index 0 you can take max jump 1\n```jump = 1  ( 0 -> 1)```\nfrom index 1 you can take max jump 1\n```jump = 2   (1 -> 2)```\nfrom index 2 you can take max jump 1\n```jump = 3   (2 -> 3)```\nyou reached index 3 with jump = 3\n#  InShort at starting index jump = 0"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Thought too much, could be directly solved via BFS"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I tried normal bfs but it was giving tle.... so i tried to memoize my solution it got accepted.... 5% fast (pretty slow)\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894138084/)"
                    },
                    {
                        "username": "rammanoj",
                        "content": "BFS was also giving me a TLE initially. If my code was able to reach index 5 in 3 steps. 3 is the minimum number of steps I can reach 5. I should never take 5 into account again i.e. don\\'t push 5 into the queue again. Mantain a maxReach variable which specifies about maximum index reached in current iteration. Only push to queue if current index could reach more than maxReach. Hope it helps!"
                    },
                    {
                        "username": "____shubham____",
                        "content": "Can anyone please explain me the question\\n\\nInput: nums = [2,3,1,1,4]\\nOutput: 2\\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\\n\\nIt says \"You are initially positioned at nums[0].\"\\nso my source is nums[0] => 2\\nand dest is nums[n - 1] => 4\\n\\nBut the solution says \"Jump 1 step from index 0 to 1\"\\n\\nMy source is 0 or nums[0]?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "0 bro\\nnums[0] is the maximum jump you can take\\nlike in above tc\\ni = 0 and nums[0] = 2\\nso you can take 1 <= jump <= nums[0] and then you will go to i + jump index "
                    },
                    {
                        "username": "sg3175",
                        "content": "How do we get started in solving this question using C language ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Many problems are pretty hard to solve in C because you have to do everything by hand, allocate memory, write comparators, or use the rather uncomfortable UTHash.  \\nBut this one is quite simple. Imagine you\\'re at index `0`, and `nums[0]` is `6`. You can now \"jump\" to indexes `1`, `2`, `3`, `4`, `5`, or `6`. So which one to choose? How about the one that gets you the farthest on your next jump.  \\nSo all you need for this problem is a single loop and a few variables to keep track of the result, the maximal index of the current jump, and the maximal index of the next jump."
                    },
                    {
                        "username": "babaska",
                        "content": "4 test in submit is failed, bun in testcase he is true. Why???"
                    },
                    {
                        "username": "MichaelTeguhLaksana",
                        "content": "Hi, I tried to use BFS instead to solve this question. However, I found that its too slow. I haven\\'t given it much thought, but shouldn\\'t what BFS (without checking the same index twice) do is the same as the suggested Greedy algorithm? Is it probably how I implemented it that\\'s the issue?"
                    },
                    {
                        "username": "sajjadzh",
                        "content": "for those who wanna implement a easy to understand O(n) approach , they should think about \"snake and ladder\" problem - solved by BFS. "
                    },
                    {
                        "username": "185535",
                        "content": "can someone just help me understand the problem statment? It is very complex and I am quite sure there is a better way to explain this."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Your goal is to reach the last index in the least amount of jumps. Every value that you land on specifies the maximum jumping distance from that index. If you land on a 3, you can jump **up to** 3 places from that index etc. \n\ninput: [2,3,1,1,4]\n\nYou start on nums[0]. nums[0] = 2, therefore you can jump up to 2 places from here --> you land on either 3 or 1. From 3 you can jump up to 3 places --> you land on 1, 1 or 4 (the last index). It took you 2 jumps to get from nums[0] to nums [n - 1], therefore the output is 2. "
                    }
                ]
            },
            {
                "id": 1793436,
                "content": [
                    {
                        "username": "shivam9935",
                        "content": "I am always able to think of recursion in this way but dynamic programing this is always a challenge for me. Can someone help me add memoization in this way?\\n\\n ```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        m = float(\\'inf\\')\\n        \\n        def j(current, jumps, left):\\n            if current == n-1:\\n                nonlocal m\\n                m = min(m, jumps)\\n                return\\n            if left == 0:\\n                # we have to take this jump\\n                j(current+1, jumps+1, nums[current]-1)\\n            if left > 0:\\n                #either we take it\\n                j(current+1, jumps+1, nums[current]-1)\\n                #or we leave current index\\n                j(current+1, jumps, left-1)\\n        \\n        j(0,0,0)\\n        return m\\n```"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "how  [1,1,1,1] answer is 3"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar)  great\\nyou can see my submission there are 3 diffrenet code in it\\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894277570/)"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "thank u [@harsh_negi_07](/harsh_negi_07) \\ni solved this, here is my  c code (beats 90%) \\nhere js = jumps, m = next index where we jump\\nint jump(int* nums, int n){\\n    int js = 0, m;\\n    if (n == 1) return 0;\\n    for (int i = 0; i < n; ){\\n        if (i + nums[i] >= n-1) return ++js;\\n        m = i+1;\\n        for (int j = i+2, k = nums[i]-1; k > 0; j++, k--)\\n            if ((nums[j] + j) >= (nums[m] + m)) m = j;\\n         i = m;\\n         ++js;\\n    }\\n    return js;\\n}"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar) \\n0 <= j <= nums[i] is the value of jump that you can take\\nit\\'s not a comparison statement ...\\nit\\'s telling you the value of jump you can take from current index and not going out of bound that is n"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "[@harsh_negi_07](/harsh_negi_07) \\nbut the question says \\n\"if you are at nums[i], you can jump to any nums[i + j] where:\\n\\n0 <= j <= nums[i] and\\ni + j < n\"\\nso when we are at index 1 how can we jump to index 2 bcz 2 > nums[1]\\nplz tell if i understand question wrong"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohit](/mohitjakhar) \nInitially number of jump is **zero**\nfrom index 0 you can take max jump 1\n```jump = 1  ( 0 -> 1)```\nfrom index 1 you can take max jump 1\n```jump = 2   (1 -> 2)```\nfrom index 2 you can take max jump 1\n```jump = 3   (2 -> 3)```\nyou reached index 3 with jump = 3\n#  InShort at starting index jump = 0"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Thought too much, could be directly solved via BFS"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I tried normal bfs but it was giving tle.... so i tried to memoize my solution it got accepted.... 5% fast (pretty slow)\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894138084/)"
                    },
                    {
                        "username": "rammanoj",
                        "content": "BFS was also giving me a TLE initially. If my code was able to reach index 5 in 3 steps. 3 is the minimum number of steps I can reach 5. I should never take 5 into account again i.e. don\\'t push 5 into the queue again. Mantain a maxReach variable which specifies about maximum index reached in current iteration. Only push to queue if current index could reach more than maxReach. Hope it helps!"
                    },
                    {
                        "username": "____shubham____",
                        "content": "Can anyone please explain me the question\\n\\nInput: nums = [2,3,1,1,4]\\nOutput: 2\\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\\n\\nIt says \"You are initially positioned at nums[0].\"\\nso my source is nums[0] => 2\\nand dest is nums[n - 1] => 4\\n\\nBut the solution says \"Jump 1 step from index 0 to 1\"\\n\\nMy source is 0 or nums[0]?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "0 bro\\nnums[0] is the maximum jump you can take\\nlike in above tc\\ni = 0 and nums[0] = 2\\nso you can take 1 <= jump <= nums[0] and then you will go to i + jump index "
                    },
                    {
                        "username": "sg3175",
                        "content": "How do we get started in solving this question using C language ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Many problems are pretty hard to solve in C because you have to do everything by hand, allocate memory, write comparators, or use the rather uncomfortable UTHash.  \\nBut this one is quite simple. Imagine you\\'re at index `0`, and `nums[0]` is `6`. You can now \"jump\" to indexes `1`, `2`, `3`, `4`, `5`, or `6`. So which one to choose? How about the one that gets you the farthest on your next jump.  \\nSo all you need for this problem is a single loop and a few variables to keep track of the result, the maximal index of the current jump, and the maximal index of the next jump."
                    },
                    {
                        "username": "babaska",
                        "content": "4 test in submit is failed, bun in testcase he is true. Why???"
                    },
                    {
                        "username": "MichaelTeguhLaksana",
                        "content": "Hi, I tried to use BFS instead to solve this question. However, I found that its too slow. I haven\\'t given it much thought, but shouldn\\'t what BFS (without checking the same index twice) do is the same as the suggested Greedy algorithm? Is it probably how I implemented it that\\'s the issue?"
                    },
                    {
                        "username": "sajjadzh",
                        "content": "for those who wanna implement a easy to understand O(n) approach , they should think about \"snake and ladder\" problem - solved by BFS. "
                    },
                    {
                        "username": "185535",
                        "content": "can someone just help me understand the problem statment? It is very complex and I am quite sure there is a better way to explain this."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Your goal is to reach the last index in the least amount of jumps. Every value that you land on specifies the maximum jumping distance from that index. If you land on a 3, you can jump **up to** 3 places from that index etc. \n\ninput: [2,3,1,1,4]\n\nYou start on nums[0]. nums[0] = 2, therefore you can jump up to 2 places from here --> you land on either 3 or 1. From 3 you can jump up to 3 places --> you land on 1, 1 or 4 (the last index). It took you 2 jumps to get from nums[0] to nums [n - 1], therefore the output is 2. "
                    }
                ]
            },
            {
                "id": 1793414,
                "content": [
                    {
                        "username": "shivam9935",
                        "content": "I am always able to think of recursion in this way but dynamic programing this is always a challenge for me. Can someone help me add memoization in this way?\\n\\n ```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        m = float(\\'inf\\')\\n        \\n        def j(current, jumps, left):\\n            if current == n-1:\\n                nonlocal m\\n                m = min(m, jumps)\\n                return\\n            if left == 0:\\n                # we have to take this jump\\n                j(current+1, jumps+1, nums[current]-1)\\n            if left > 0:\\n                #either we take it\\n                j(current+1, jumps+1, nums[current]-1)\\n                #or we leave current index\\n                j(current+1, jumps, left-1)\\n        \\n        j(0,0,0)\\n        return m\\n```"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "how  [1,1,1,1] answer is 3"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar)  great\\nyou can see my submission there are 3 diffrenet code in it\\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894277570/)"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "thank u [@harsh_negi_07](/harsh_negi_07) \\ni solved this, here is my  c code (beats 90%) \\nhere js = jumps, m = next index where we jump\\nint jump(int* nums, int n){\\n    int js = 0, m;\\n    if (n == 1) return 0;\\n    for (int i = 0; i < n; ){\\n        if (i + nums[i] >= n-1) return ++js;\\n        m = i+1;\\n        for (int j = i+2, k = nums[i]-1; k > 0; j++, k--)\\n            if ((nums[j] + j) >= (nums[m] + m)) m = j;\\n         i = m;\\n         ++js;\\n    }\\n    return js;\\n}"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar) \\n0 <= j <= nums[i] is the value of jump that you can take\\nit\\'s not a comparison statement ...\\nit\\'s telling you the value of jump you can take from current index and not going out of bound that is n"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "[@harsh_negi_07](/harsh_negi_07) \\nbut the question says \\n\"if you are at nums[i], you can jump to any nums[i + j] where:\\n\\n0 <= j <= nums[i] and\\ni + j < n\"\\nso when we are at index 1 how can we jump to index 2 bcz 2 > nums[1]\\nplz tell if i understand question wrong"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohit](/mohitjakhar) \nInitially number of jump is **zero**\nfrom index 0 you can take max jump 1\n```jump = 1  ( 0 -> 1)```\nfrom index 1 you can take max jump 1\n```jump = 2   (1 -> 2)```\nfrom index 2 you can take max jump 1\n```jump = 3   (2 -> 3)```\nyou reached index 3 with jump = 3\n#  InShort at starting index jump = 0"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Thought too much, could be directly solved via BFS"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I tried normal bfs but it was giving tle.... so i tried to memoize my solution it got accepted.... 5% fast (pretty slow)\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894138084/)"
                    },
                    {
                        "username": "rammanoj",
                        "content": "BFS was also giving me a TLE initially. If my code was able to reach index 5 in 3 steps. 3 is the minimum number of steps I can reach 5. I should never take 5 into account again i.e. don\\'t push 5 into the queue again. Mantain a maxReach variable which specifies about maximum index reached in current iteration. Only push to queue if current index could reach more than maxReach. Hope it helps!"
                    },
                    {
                        "username": "____shubham____",
                        "content": "Can anyone please explain me the question\\n\\nInput: nums = [2,3,1,1,4]\\nOutput: 2\\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\\n\\nIt says \"You are initially positioned at nums[0].\"\\nso my source is nums[0] => 2\\nand dest is nums[n - 1] => 4\\n\\nBut the solution says \"Jump 1 step from index 0 to 1\"\\n\\nMy source is 0 or nums[0]?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "0 bro\\nnums[0] is the maximum jump you can take\\nlike in above tc\\ni = 0 and nums[0] = 2\\nso you can take 1 <= jump <= nums[0] and then you will go to i + jump index "
                    },
                    {
                        "username": "sg3175",
                        "content": "How do we get started in solving this question using C language ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Many problems are pretty hard to solve in C because you have to do everything by hand, allocate memory, write comparators, or use the rather uncomfortable UTHash.  \\nBut this one is quite simple. Imagine you\\'re at index `0`, and `nums[0]` is `6`. You can now \"jump\" to indexes `1`, `2`, `3`, `4`, `5`, or `6`. So which one to choose? How about the one that gets you the farthest on your next jump.  \\nSo all you need for this problem is a single loop and a few variables to keep track of the result, the maximal index of the current jump, and the maximal index of the next jump."
                    },
                    {
                        "username": "babaska",
                        "content": "4 test in submit is failed, bun in testcase he is true. Why???"
                    },
                    {
                        "username": "MichaelTeguhLaksana",
                        "content": "Hi, I tried to use BFS instead to solve this question. However, I found that its too slow. I haven\\'t given it much thought, but shouldn\\'t what BFS (without checking the same index twice) do is the same as the suggested Greedy algorithm? Is it probably how I implemented it that\\'s the issue?"
                    },
                    {
                        "username": "sajjadzh",
                        "content": "for those who wanna implement a easy to understand O(n) approach , they should think about \"snake and ladder\" problem - solved by BFS. "
                    },
                    {
                        "username": "185535",
                        "content": "can someone just help me understand the problem statment? It is very complex and I am quite sure there is a better way to explain this."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Your goal is to reach the last index in the least amount of jumps. Every value that you land on specifies the maximum jumping distance from that index. If you land on a 3, you can jump **up to** 3 places from that index etc. \n\ninput: [2,3,1,1,4]\n\nYou start on nums[0]. nums[0] = 2, therefore you can jump up to 2 places from here --> you land on either 3 or 1. From 3 you can jump up to 3 places --> you land on 1, 1 or 4 (the last index). It took you 2 jumps to get from nums[0] to nums [n - 1], therefore the output is 2. "
                    }
                ]
            },
            {
                "id": 1793393,
                "content": [
                    {
                        "username": "shivam9935",
                        "content": "I am always able to think of recursion in this way but dynamic programing this is always a challenge for me. Can someone help me add memoization in this way?\\n\\n ```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        m = float(\\'inf\\')\\n        \\n        def j(current, jumps, left):\\n            if current == n-1:\\n                nonlocal m\\n                m = min(m, jumps)\\n                return\\n            if left == 0:\\n                # we have to take this jump\\n                j(current+1, jumps+1, nums[current]-1)\\n            if left > 0:\\n                #either we take it\\n                j(current+1, jumps+1, nums[current]-1)\\n                #or we leave current index\\n                j(current+1, jumps, left-1)\\n        \\n        j(0,0,0)\\n        return m\\n```"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "how  [1,1,1,1] answer is 3"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar)  great\\nyou can see my submission there are 3 diffrenet code in it\\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894277570/)"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "thank u [@harsh_negi_07](/harsh_negi_07) \\ni solved this, here is my  c code (beats 90%) \\nhere js = jumps, m = next index where we jump\\nint jump(int* nums, int n){\\n    int js = 0, m;\\n    if (n == 1) return 0;\\n    for (int i = 0; i < n; ){\\n        if (i + nums[i] >= n-1) return ++js;\\n        m = i+1;\\n        for (int j = i+2, k = nums[i]-1; k > 0; j++, k--)\\n            if ((nums[j] + j) >= (nums[m] + m)) m = j;\\n         i = m;\\n         ++js;\\n    }\\n    return js;\\n}"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar) \\n0 <= j <= nums[i] is the value of jump that you can take\\nit\\'s not a comparison statement ...\\nit\\'s telling you the value of jump you can take from current index and not going out of bound that is n"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "[@harsh_negi_07](/harsh_negi_07) \\nbut the question says \\n\"if you are at nums[i], you can jump to any nums[i + j] where:\\n\\n0 <= j <= nums[i] and\\ni + j < n\"\\nso when we are at index 1 how can we jump to index 2 bcz 2 > nums[1]\\nplz tell if i understand question wrong"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohit](/mohitjakhar) \nInitially number of jump is **zero**\nfrom index 0 you can take max jump 1\n```jump = 1  ( 0 -> 1)```\nfrom index 1 you can take max jump 1\n```jump = 2   (1 -> 2)```\nfrom index 2 you can take max jump 1\n```jump = 3   (2 -> 3)```\nyou reached index 3 with jump = 3\n#  InShort at starting index jump = 0"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Thought too much, could be directly solved via BFS"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I tried normal bfs but it was giving tle.... so i tried to memoize my solution it got accepted.... 5% fast (pretty slow)\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894138084/)"
                    },
                    {
                        "username": "rammanoj",
                        "content": "BFS was also giving me a TLE initially. If my code was able to reach index 5 in 3 steps. 3 is the minimum number of steps I can reach 5. I should never take 5 into account again i.e. don\\'t push 5 into the queue again. Mantain a maxReach variable which specifies about maximum index reached in current iteration. Only push to queue if current index could reach more than maxReach. Hope it helps!"
                    },
                    {
                        "username": "____shubham____",
                        "content": "Can anyone please explain me the question\\n\\nInput: nums = [2,3,1,1,4]\\nOutput: 2\\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\\n\\nIt says \"You are initially positioned at nums[0].\"\\nso my source is nums[0] => 2\\nand dest is nums[n - 1] => 4\\n\\nBut the solution says \"Jump 1 step from index 0 to 1\"\\n\\nMy source is 0 or nums[0]?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "0 bro\\nnums[0] is the maximum jump you can take\\nlike in above tc\\ni = 0 and nums[0] = 2\\nso you can take 1 <= jump <= nums[0] and then you will go to i + jump index "
                    },
                    {
                        "username": "sg3175",
                        "content": "How do we get started in solving this question using C language ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Many problems are pretty hard to solve in C because you have to do everything by hand, allocate memory, write comparators, or use the rather uncomfortable UTHash.  \\nBut this one is quite simple. Imagine you\\'re at index `0`, and `nums[0]` is `6`. You can now \"jump\" to indexes `1`, `2`, `3`, `4`, `5`, or `6`. So which one to choose? How about the one that gets you the farthest on your next jump.  \\nSo all you need for this problem is a single loop and a few variables to keep track of the result, the maximal index of the current jump, and the maximal index of the next jump."
                    },
                    {
                        "username": "babaska",
                        "content": "4 test in submit is failed, bun in testcase he is true. Why???"
                    },
                    {
                        "username": "MichaelTeguhLaksana",
                        "content": "Hi, I tried to use BFS instead to solve this question. However, I found that its too slow. I haven\\'t given it much thought, but shouldn\\'t what BFS (without checking the same index twice) do is the same as the suggested Greedy algorithm? Is it probably how I implemented it that\\'s the issue?"
                    },
                    {
                        "username": "sajjadzh",
                        "content": "for those who wanna implement a easy to understand O(n) approach , they should think about \"snake and ladder\" problem - solved by BFS. "
                    },
                    {
                        "username": "185535",
                        "content": "can someone just help me understand the problem statment? It is very complex and I am quite sure there is a better way to explain this."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Your goal is to reach the last index in the least amount of jumps. Every value that you land on specifies the maximum jumping distance from that index. If you land on a 3, you can jump **up to** 3 places from that index etc. \n\ninput: [2,3,1,1,4]\n\nYou start on nums[0]. nums[0] = 2, therefore you can jump up to 2 places from here --> you land on either 3 or 1. From 3 you can jump up to 3 places --> you land on 1, 1 or 4 (the last index). It took you 2 jumps to get from nums[0] to nums [n - 1], therefore the output is 2. "
                    }
                ]
            },
            {
                "id": 1793386,
                "content": [
                    {
                        "username": "shivam9935",
                        "content": "I am always able to think of recursion in this way but dynamic programing this is always a challenge for me. Can someone help me add memoization in this way?\\n\\n ```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        m = float(\\'inf\\')\\n        \\n        def j(current, jumps, left):\\n            if current == n-1:\\n                nonlocal m\\n                m = min(m, jumps)\\n                return\\n            if left == 0:\\n                # we have to take this jump\\n                j(current+1, jumps+1, nums[current]-1)\\n            if left > 0:\\n                #either we take it\\n                j(current+1, jumps+1, nums[current]-1)\\n                #or we leave current index\\n                j(current+1, jumps, left-1)\\n        \\n        j(0,0,0)\\n        return m\\n```"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "how  [1,1,1,1] answer is 3"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar)  great\\nyou can see my submission there are 3 diffrenet code in it\\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894277570/)"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "thank u [@harsh_negi_07](/harsh_negi_07) \\ni solved this, here is my  c code (beats 90%) \\nhere js = jumps, m = next index where we jump\\nint jump(int* nums, int n){\\n    int js = 0, m;\\n    if (n == 1) return 0;\\n    for (int i = 0; i < n; ){\\n        if (i + nums[i] >= n-1) return ++js;\\n        m = i+1;\\n        for (int j = i+2, k = nums[i]-1; k > 0; j++, k--)\\n            if ((nums[j] + j) >= (nums[m] + m)) m = j;\\n         i = m;\\n         ++js;\\n    }\\n    return js;\\n}"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar) \\n0 <= j <= nums[i] is the value of jump that you can take\\nit\\'s not a comparison statement ...\\nit\\'s telling you the value of jump you can take from current index and not going out of bound that is n"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "[@harsh_negi_07](/harsh_negi_07) \\nbut the question says \\n\"if you are at nums[i], you can jump to any nums[i + j] where:\\n\\n0 <= j <= nums[i] and\\ni + j < n\"\\nso when we are at index 1 how can we jump to index 2 bcz 2 > nums[1]\\nplz tell if i understand question wrong"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohit](/mohitjakhar) \nInitially number of jump is **zero**\nfrom index 0 you can take max jump 1\n```jump = 1  ( 0 -> 1)```\nfrom index 1 you can take max jump 1\n```jump = 2   (1 -> 2)```\nfrom index 2 you can take max jump 1\n```jump = 3   (2 -> 3)```\nyou reached index 3 with jump = 3\n#  InShort at starting index jump = 0"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Thought too much, could be directly solved via BFS"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I tried normal bfs but it was giving tle.... so i tried to memoize my solution it got accepted.... 5% fast (pretty slow)\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894138084/)"
                    },
                    {
                        "username": "rammanoj",
                        "content": "BFS was also giving me a TLE initially. If my code was able to reach index 5 in 3 steps. 3 is the minimum number of steps I can reach 5. I should never take 5 into account again i.e. don\\'t push 5 into the queue again. Mantain a maxReach variable which specifies about maximum index reached in current iteration. Only push to queue if current index could reach more than maxReach. Hope it helps!"
                    },
                    {
                        "username": "____shubham____",
                        "content": "Can anyone please explain me the question\\n\\nInput: nums = [2,3,1,1,4]\\nOutput: 2\\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\\n\\nIt says \"You are initially positioned at nums[0].\"\\nso my source is nums[0] => 2\\nand dest is nums[n - 1] => 4\\n\\nBut the solution says \"Jump 1 step from index 0 to 1\"\\n\\nMy source is 0 or nums[0]?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "0 bro\\nnums[0] is the maximum jump you can take\\nlike in above tc\\ni = 0 and nums[0] = 2\\nso you can take 1 <= jump <= nums[0] and then you will go to i + jump index "
                    },
                    {
                        "username": "sg3175",
                        "content": "How do we get started in solving this question using C language ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Many problems are pretty hard to solve in C because you have to do everything by hand, allocate memory, write comparators, or use the rather uncomfortable UTHash.  \\nBut this one is quite simple. Imagine you\\'re at index `0`, and `nums[0]` is `6`. You can now \"jump\" to indexes `1`, `2`, `3`, `4`, `5`, or `6`. So which one to choose? How about the one that gets you the farthest on your next jump.  \\nSo all you need for this problem is a single loop and a few variables to keep track of the result, the maximal index of the current jump, and the maximal index of the next jump."
                    },
                    {
                        "username": "babaska",
                        "content": "4 test in submit is failed, bun in testcase he is true. Why???"
                    },
                    {
                        "username": "MichaelTeguhLaksana",
                        "content": "Hi, I tried to use BFS instead to solve this question. However, I found that its too slow. I haven\\'t given it much thought, but shouldn\\'t what BFS (without checking the same index twice) do is the same as the suggested Greedy algorithm? Is it probably how I implemented it that\\'s the issue?"
                    },
                    {
                        "username": "sajjadzh",
                        "content": "for those who wanna implement a easy to understand O(n) approach , they should think about \"snake and ladder\" problem - solved by BFS. "
                    },
                    {
                        "username": "185535",
                        "content": "can someone just help me understand the problem statment? It is very complex and I am quite sure there is a better way to explain this."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Your goal is to reach the last index in the least amount of jumps. Every value that you land on specifies the maximum jumping distance from that index. If you land on a 3, you can jump **up to** 3 places from that index etc. \n\ninput: [2,3,1,1,4]\n\nYou start on nums[0]. nums[0] = 2, therefore you can jump up to 2 places from here --> you land on either 3 or 1. From 3 you can jump up to 3 places --> you land on 1, 1 or 4 (the last index). It took you 2 jumps to get from nums[0] to nums [n - 1], therefore the output is 2. "
                    }
                ]
            },
            {
                "id": 1793343,
                "content": [
                    {
                        "username": "shivam9935",
                        "content": "I am always able to think of recursion in this way but dynamic programing this is always a challenge for me. Can someone help me add memoization in this way?\\n\\n ```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        m = float(\\'inf\\')\\n        \\n        def j(current, jumps, left):\\n            if current == n-1:\\n                nonlocal m\\n                m = min(m, jumps)\\n                return\\n            if left == 0:\\n                # we have to take this jump\\n                j(current+1, jumps+1, nums[current]-1)\\n            if left > 0:\\n                #either we take it\\n                j(current+1, jumps+1, nums[current]-1)\\n                #or we leave current index\\n                j(current+1, jumps, left-1)\\n        \\n        j(0,0,0)\\n        return m\\n```"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "how  [1,1,1,1] answer is 3"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar)  great\\nyou can see my submission there are 3 diffrenet code in it\\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894277570/)"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "thank u [@harsh_negi_07](/harsh_negi_07) \\ni solved this, here is my  c code (beats 90%) \\nhere js = jumps, m = next index where we jump\\nint jump(int* nums, int n){\\n    int js = 0, m;\\n    if (n == 1) return 0;\\n    for (int i = 0; i < n; ){\\n        if (i + nums[i] >= n-1) return ++js;\\n        m = i+1;\\n        for (int j = i+2, k = nums[i]-1; k > 0; j++, k--)\\n            if ((nums[j] + j) >= (nums[m] + m)) m = j;\\n         i = m;\\n         ++js;\\n    }\\n    return js;\\n}"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar) \\n0 <= j <= nums[i] is the value of jump that you can take\\nit\\'s not a comparison statement ...\\nit\\'s telling you the value of jump you can take from current index and not going out of bound that is n"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "[@harsh_negi_07](/harsh_negi_07) \\nbut the question says \\n\"if you are at nums[i], you can jump to any nums[i + j] where:\\n\\n0 <= j <= nums[i] and\\ni + j < n\"\\nso when we are at index 1 how can we jump to index 2 bcz 2 > nums[1]\\nplz tell if i understand question wrong"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohit](/mohitjakhar) \nInitially number of jump is **zero**\nfrom index 0 you can take max jump 1\n```jump = 1  ( 0 -> 1)```\nfrom index 1 you can take max jump 1\n```jump = 2   (1 -> 2)```\nfrom index 2 you can take max jump 1\n```jump = 3   (2 -> 3)```\nyou reached index 3 with jump = 3\n#  InShort at starting index jump = 0"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Thought too much, could be directly solved via BFS"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I tried normal bfs but it was giving tle.... so i tried to memoize my solution it got accepted.... 5% fast (pretty slow)\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894138084/)"
                    },
                    {
                        "username": "rammanoj",
                        "content": "BFS was also giving me a TLE initially. If my code was able to reach index 5 in 3 steps. 3 is the minimum number of steps I can reach 5. I should never take 5 into account again i.e. don\\'t push 5 into the queue again. Mantain a maxReach variable which specifies about maximum index reached in current iteration. Only push to queue if current index could reach more than maxReach. Hope it helps!"
                    },
                    {
                        "username": "____shubham____",
                        "content": "Can anyone please explain me the question\\n\\nInput: nums = [2,3,1,1,4]\\nOutput: 2\\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\\n\\nIt says \"You are initially positioned at nums[0].\"\\nso my source is nums[0] => 2\\nand dest is nums[n - 1] => 4\\n\\nBut the solution says \"Jump 1 step from index 0 to 1\"\\n\\nMy source is 0 or nums[0]?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "0 bro\\nnums[0] is the maximum jump you can take\\nlike in above tc\\ni = 0 and nums[0] = 2\\nso you can take 1 <= jump <= nums[0] and then you will go to i + jump index "
                    },
                    {
                        "username": "sg3175",
                        "content": "How do we get started in solving this question using C language ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Many problems are pretty hard to solve in C because you have to do everything by hand, allocate memory, write comparators, or use the rather uncomfortable UTHash.  \\nBut this one is quite simple. Imagine you\\'re at index `0`, and `nums[0]` is `6`. You can now \"jump\" to indexes `1`, `2`, `3`, `4`, `5`, or `6`. So which one to choose? How about the one that gets you the farthest on your next jump.  \\nSo all you need for this problem is a single loop and a few variables to keep track of the result, the maximal index of the current jump, and the maximal index of the next jump."
                    },
                    {
                        "username": "babaska",
                        "content": "4 test in submit is failed, bun in testcase he is true. Why???"
                    },
                    {
                        "username": "MichaelTeguhLaksana",
                        "content": "Hi, I tried to use BFS instead to solve this question. However, I found that its too slow. I haven\\'t given it much thought, but shouldn\\'t what BFS (without checking the same index twice) do is the same as the suggested Greedy algorithm? Is it probably how I implemented it that\\'s the issue?"
                    },
                    {
                        "username": "sajjadzh",
                        "content": "for those who wanna implement a easy to understand O(n) approach , they should think about \"snake and ladder\" problem - solved by BFS. "
                    },
                    {
                        "username": "185535",
                        "content": "can someone just help me understand the problem statment? It is very complex and I am quite sure there is a better way to explain this."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Your goal is to reach the last index in the least amount of jumps. Every value that you land on specifies the maximum jumping distance from that index. If you land on a 3, you can jump **up to** 3 places from that index etc. \n\ninput: [2,3,1,1,4]\n\nYou start on nums[0]. nums[0] = 2, therefore you can jump up to 2 places from here --> you land on either 3 or 1. From 3 you can jump up to 3 places --> you land on 1, 1 or 4 (the last index). It took you 2 jumps to get from nums[0] to nums [n - 1], therefore the output is 2. "
                    }
                ]
            },
            {
                "id": 1793336,
                "content": [
                    {
                        "username": "shivam9935",
                        "content": "I am always able to think of recursion in this way but dynamic programing this is always a challenge for me. Can someone help me add memoization in this way?\\n\\n ```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        m = float(\\'inf\\')\\n        \\n        def j(current, jumps, left):\\n            if current == n-1:\\n                nonlocal m\\n                m = min(m, jumps)\\n                return\\n            if left == 0:\\n                # we have to take this jump\\n                j(current+1, jumps+1, nums[current]-1)\\n            if left > 0:\\n                #either we take it\\n                j(current+1, jumps+1, nums[current]-1)\\n                #or we leave current index\\n                j(current+1, jumps, left-1)\\n        \\n        j(0,0,0)\\n        return m\\n```"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "how  [1,1,1,1] answer is 3"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar)  great\\nyou can see my submission there are 3 diffrenet code in it\\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894277570/)"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "thank u [@harsh_negi_07](/harsh_negi_07) \\ni solved this, here is my  c code (beats 90%) \\nhere js = jumps, m = next index where we jump\\nint jump(int* nums, int n){\\n    int js = 0, m;\\n    if (n == 1) return 0;\\n    for (int i = 0; i < n; ){\\n        if (i + nums[i] >= n-1) return ++js;\\n        m = i+1;\\n        for (int j = i+2, k = nums[i]-1; k > 0; j++, k--)\\n            if ((nums[j] + j) >= (nums[m] + m)) m = j;\\n         i = m;\\n         ++js;\\n    }\\n    return js;\\n}"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar) \\n0 <= j <= nums[i] is the value of jump that you can take\\nit\\'s not a comparison statement ...\\nit\\'s telling you the value of jump you can take from current index and not going out of bound that is n"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "[@harsh_negi_07](/harsh_negi_07) \\nbut the question says \\n\"if you are at nums[i], you can jump to any nums[i + j] where:\\n\\n0 <= j <= nums[i] and\\ni + j < n\"\\nso when we are at index 1 how can we jump to index 2 bcz 2 > nums[1]\\nplz tell if i understand question wrong"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohit](/mohitjakhar) \nInitially number of jump is **zero**\nfrom index 0 you can take max jump 1\n```jump = 1  ( 0 -> 1)```\nfrom index 1 you can take max jump 1\n```jump = 2   (1 -> 2)```\nfrom index 2 you can take max jump 1\n```jump = 3   (2 -> 3)```\nyou reached index 3 with jump = 3\n#  InShort at starting index jump = 0"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Thought too much, could be directly solved via BFS"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I tried normal bfs but it was giving tle.... so i tried to memoize my solution it got accepted.... 5% fast (pretty slow)\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894138084/)"
                    },
                    {
                        "username": "rammanoj",
                        "content": "BFS was also giving me a TLE initially. If my code was able to reach index 5 in 3 steps. 3 is the minimum number of steps I can reach 5. I should never take 5 into account again i.e. don\\'t push 5 into the queue again. Mantain a maxReach variable which specifies about maximum index reached in current iteration. Only push to queue if current index could reach more than maxReach. Hope it helps!"
                    },
                    {
                        "username": "____shubham____",
                        "content": "Can anyone please explain me the question\\n\\nInput: nums = [2,3,1,1,4]\\nOutput: 2\\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\\n\\nIt says \"You are initially positioned at nums[0].\"\\nso my source is nums[0] => 2\\nand dest is nums[n - 1] => 4\\n\\nBut the solution says \"Jump 1 step from index 0 to 1\"\\n\\nMy source is 0 or nums[0]?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "0 bro\\nnums[0] is the maximum jump you can take\\nlike in above tc\\ni = 0 and nums[0] = 2\\nso you can take 1 <= jump <= nums[0] and then you will go to i + jump index "
                    },
                    {
                        "username": "sg3175",
                        "content": "How do we get started in solving this question using C language ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Many problems are pretty hard to solve in C because you have to do everything by hand, allocate memory, write comparators, or use the rather uncomfortable UTHash.  \\nBut this one is quite simple. Imagine you\\'re at index `0`, and `nums[0]` is `6`. You can now \"jump\" to indexes `1`, `2`, `3`, `4`, `5`, or `6`. So which one to choose? How about the one that gets you the farthest on your next jump.  \\nSo all you need for this problem is a single loop and a few variables to keep track of the result, the maximal index of the current jump, and the maximal index of the next jump."
                    },
                    {
                        "username": "babaska",
                        "content": "4 test in submit is failed, bun in testcase he is true. Why???"
                    },
                    {
                        "username": "MichaelTeguhLaksana",
                        "content": "Hi, I tried to use BFS instead to solve this question. However, I found that its too slow. I haven\\'t given it much thought, but shouldn\\'t what BFS (without checking the same index twice) do is the same as the suggested Greedy algorithm? Is it probably how I implemented it that\\'s the issue?"
                    },
                    {
                        "username": "sajjadzh",
                        "content": "for those who wanna implement a easy to understand O(n) approach , they should think about \"snake and ladder\" problem - solved by BFS. "
                    },
                    {
                        "username": "185535",
                        "content": "can someone just help me understand the problem statment? It is very complex and I am quite sure there is a better way to explain this."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Your goal is to reach the last index in the least amount of jumps. Every value that you land on specifies the maximum jumping distance from that index. If you land on a 3, you can jump **up to** 3 places from that index etc. \n\ninput: [2,3,1,1,4]\n\nYou start on nums[0]. nums[0] = 2, therefore you can jump up to 2 places from here --> you land on either 3 or 1. From 3 you can jump up to 3 places --> you land on 1, 1 or 4 (the last index). It took you 2 jumps to get from nums[0] to nums [n - 1], therefore the output is 2. "
                    }
                ]
            },
            {
                "id": 1793322,
                "content": [
                    {
                        "username": "shivam9935",
                        "content": "I am always able to think of recursion in this way but dynamic programing this is always a challenge for me. Can someone help me add memoization in this way?\\n\\n ```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        m = float(\\'inf\\')\\n        \\n        def j(current, jumps, left):\\n            if current == n-1:\\n                nonlocal m\\n                m = min(m, jumps)\\n                return\\n            if left == 0:\\n                # we have to take this jump\\n                j(current+1, jumps+1, nums[current]-1)\\n            if left > 0:\\n                #either we take it\\n                j(current+1, jumps+1, nums[current]-1)\\n                #or we leave current index\\n                j(current+1, jumps, left-1)\\n        \\n        j(0,0,0)\\n        return m\\n```"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "how  [1,1,1,1] answer is 3"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar)  great\\nyou can see my submission there are 3 diffrenet code in it\\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894277570/)"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "thank u [@harsh_negi_07](/harsh_negi_07) \\ni solved this, here is my  c code (beats 90%) \\nhere js = jumps, m = next index where we jump\\nint jump(int* nums, int n){\\n    int js = 0, m;\\n    if (n == 1) return 0;\\n    for (int i = 0; i < n; ){\\n        if (i + nums[i] >= n-1) return ++js;\\n        m = i+1;\\n        for (int j = i+2, k = nums[i]-1; k > 0; j++, k--)\\n            if ((nums[j] + j) >= (nums[m] + m)) m = j;\\n         i = m;\\n         ++js;\\n    }\\n    return js;\\n}"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar) \\n0 <= j <= nums[i] is the value of jump that you can take\\nit\\'s not a comparison statement ...\\nit\\'s telling you the value of jump you can take from current index and not going out of bound that is n"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "[@harsh_negi_07](/harsh_negi_07) \\nbut the question says \\n\"if you are at nums[i], you can jump to any nums[i + j] where:\\n\\n0 <= j <= nums[i] and\\ni + j < n\"\\nso when we are at index 1 how can we jump to index 2 bcz 2 > nums[1]\\nplz tell if i understand question wrong"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohit](/mohitjakhar) \nInitially number of jump is **zero**\nfrom index 0 you can take max jump 1\n```jump = 1  ( 0 -> 1)```\nfrom index 1 you can take max jump 1\n```jump = 2   (1 -> 2)```\nfrom index 2 you can take max jump 1\n```jump = 3   (2 -> 3)```\nyou reached index 3 with jump = 3\n#  InShort at starting index jump = 0"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Thought too much, could be directly solved via BFS"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I tried normal bfs but it was giving tle.... so i tried to memoize my solution it got accepted.... 5% fast (pretty slow)\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894138084/)"
                    },
                    {
                        "username": "rammanoj",
                        "content": "BFS was also giving me a TLE initially. If my code was able to reach index 5 in 3 steps. 3 is the minimum number of steps I can reach 5. I should never take 5 into account again i.e. don\\'t push 5 into the queue again. Mantain a maxReach variable which specifies about maximum index reached in current iteration. Only push to queue if current index could reach more than maxReach. Hope it helps!"
                    },
                    {
                        "username": "____shubham____",
                        "content": "Can anyone please explain me the question\\n\\nInput: nums = [2,3,1,1,4]\\nOutput: 2\\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\\n\\nIt says \"You are initially positioned at nums[0].\"\\nso my source is nums[0] => 2\\nand dest is nums[n - 1] => 4\\n\\nBut the solution says \"Jump 1 step from index 0 to 1\"\\n\\nMy source is 0 or nums[0]?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "0 bro\\nnums[0] is the maximum jump you can take\\nlike in above tc\\ni = 0 and nums[0] = 2\\nso you can take 1 <= jump <= nums[0] and then you will go to i + jump index "
                    },
                    {
                        "username": "sg3175",
                        "content": "How do we get started in solving this question using C language ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Many problems are pretty hard to solve in C because you have to do everything by hand, allocate memory, write comparators, or use the rather uncomfortable UTHash.  \\nBut this one is quite simple. Imagine you\\'re at index `0`, and `nums[0]` is `6`. You can now \"jump\" to indexes `1`, `2`, `3`, `4`, `5`, or `6`. So which one to choose? How about the one that gets you the farthest on your next jump.  \\nSo all you need for this problem is a single loop and a few variables to keep track of the result, the maximal index of the current jump, and the maximal index of the next jump."
                    },
                    {
                        "username": "babaska",
                        "content": "4 test in submit is failed, bun in testcase he is true. Why???"
                    },
                    {
                        "username": "MichaelTeguhLaksana",
                        "content": "Hi, I tried to use BFS instead to solve this question. However, I found that its too slow. I haven\\'t given it much thought, but shouldn\\'t what BFS (without checking the same index twice) do is the same as the suggested Greedy algorithm? Is it probably how I implemented it that\\'s the issue?"
                    },
                    {
                        "username": "sajjadzh",
                        "content": "for those who wanna implement a easy to understand O(n) approach , they should think about \"snake and ladder\" problem - solved by BFS. "
                    },
                    {
                        "username": "185535",
                        "content": "can someone just help me understand the problem statment? It is very complex and I am quite sure there is a better way to explain this."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Your goal is to reach the last index in the least amount of jumps. Every value that you land on specifies the maximum jumping distance from that index. If you land on a 3, you can jump **up to** 3 places from that index etc. \n\ninput: [2,3,1,1,4]\n\nYou start on nums[0]. nums[0] = 2, therefore you can jump up to 2 places from here --> you land on either 3 or 1. From 3 you can jump up to 3 places --> you land on 1, 1 or 4 (the last index). It took you 2 jumps to get from nums[0] to nums [n - 1], therefore the output is 2. "
                    }
                ]
            },
            {
                "id": 1793272,
                "content": [
                    {
                        "username": "shivam9935",
                        "content": "I am always able to think of recursion in this way but dynamic programing this is always a challenge for me. Can someone help me add memoization in this way?\\n\\n ```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        m = float(\\'inf\\')\\n        \\n        def j(current, jumps, left):\\n            if current == n-1:\\n                nonlocal m\\n                m = min(m, jumps)\\n                return\\n            if left == 0:\\n                # we have to take this jump\\n                j(current+1, jumps+1, nums[current]-1)\\n            if left > 0:\\n                #either we take it\\n                j(current+1, jumps+1, nums[current]-1)\\n                #or we leave current index\\n                j(current+1, jumps, left-1)\\n        \\n        j(0,0,0)\\n        return m\\n```"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "how  [1,1,1,1] answer is 3"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar)  great\\nyou can see my submission there are 3 diffrenet code in it\\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894277570/)"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "thank u [@harsh_negi_07](/harsh_negi_07) \\ni solved this, here is my  c code (beats 90%) \\nhere js = jumps, m = next index where we jump\\nint jump(int* nums, int n){\\n    int js = 0, m;\\n    if (n == 1) return 0;\\n    for (int i = 0; i < n; ){\\n        if (i + nums[i] >= n-1) return ++js;\\n        m = i+1;\\n        for (int j = i+2, k = nums[i]-1; k > 0; j++, k--)\\n            if ((nums[j] + j) >= (nums[m] + m)) m = j;\\n         i = m;\\n         ++js;\\n    }\\n    return js;\\n}"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar) \\n0 <= j <= nums[i] is the value of jump that you can take\\nit\\'s not a comparison statement ...\\nit\\'s telling you the value of jump you can take from current index and not going out of bound that is n"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "[@harsh_negi_07](/harsh_negi_07) \\nbut the question says \\n\"if you are at nums[i], you can jump to any nums[i + j] where:\\n\\n0 <= j <= nums[i] and\\ni + j < n\"\\nso when we are at index 1 how can we jump to index 2 bcz 2 > nums[1]\\nplz tell if i understand question wrong"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohit](/mohitjakhar) \nInitially number of jump is **zero**\nfrom index 0 you can take max jump 1\n```jump = 1  ( 0 -> 1)```\nfrom index 1 you can take max jump 1\n```jump = 2   (1 -> 2)```\nfrom index 2 you can take max jump 1\n```jump = 3   (2 -> 3)```\nyou reached index 3 with jump = 3\n#  InShort at starting index jump = 0"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Thought too much, could be directly solved via BFS"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I tried normal bfs but it was giving tle.... so i tried to memoize my solution it got accepted.... 5% fast (pretty slow)\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894138084/)"
                    },
                    {
                        "username": "rammanoj",
                        "content": "BFS was also giving me a TLE initially. If my code was able to reach index 5 in 3 steps. 3 is the minimum number of steps I can reach 5. I should never take 5 into account again i.e. don\\'t push 5 into the queue again. Mantain a maxReach variable which specifies about maximum index reached in current iteration. Only push to queue if current index could reach more than maxReach. Hope it helps!"
                    },
                    {
                        "username": "____shubham____",
                        "content": "Can anyone please explain me the question\\n\\nInput: nums = [2,3,1,1,4]\\nOutput: 2\\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\\n\\nIt says \"You are initially positioned at nums[0].\"\\nso my source is nums[0] => 2\\nand dest is nums[n - 1] => 4\\n\\nBut the solution says \"Jump 1 step from index 0 to 1\"\\n\\nMy source is 0 or nums[0]?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "0 bro\\nnums[0] is the maximum jump you can take\\nlike in above tc\\ni = 0 and nums[0] = 2\\nso you can take 1 <= jump <= nums[0] and then you will go to i + jump index "
                    },
                    {
                        "username": "sg3175",
                        "content": "How do we get started in solving this question using C language ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Many problems are pretty hard to solve in C because you have to do everything by hand, allocate memory, write comparators, or use the rather uncomfortable UTHash.  \\nBut this one is quite simple. Imagine you\\'re at index `0`, and `nums[0]` is `6`. You can now \"jump\" to indexes `1`, `2`, `3`, `4`, `5`, or `6`. So which one to choose? How about the one that gets you the farthest on your next jump.  \\nSo all you need for this problem is a single loop and a few variables to keep track of the result, the maximal index of the current jump, and the maximal index of the next jump."
                    },
                    {
                        "username": "babaska",
                        "content": "4 test in submit is failed, bun in testcase he is true. Why???"
                    },
                    {
                        "username": "MichaelTeguhLaksana",
                        "content": "Hi, I tried to use BFS instead to solve this question. However, I found that its too slow. I haven\\'t given it much thought, but shouldn\\'t what BFS (without checking the same index twice) do is the same as the suggested Greedy algorithm? Is it probably how I implemented it that\\'s the issue?"
                    },
                    {
                        "username": "sajjadzh",
                        "content": "for those who wanna implement a easy to understand O(n) approach , they should think about \"snake and ladder\" problem - solved by BFS. "
                    },
                    {
                        "username": "185535",
                        "content": "can someone just help me understand the problem statment? It is very complex and I am quite sure there is a better way to explain this."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Your goal is to reach the last index in the least amount of jumps. Every value that you land on specifies the maximum jumping distance from that index. If you land on a 3, you can jump **up to** 3 places from that index etc. \n\ninput: [2,3,1,1,4]\n\nYou start on nums[0]. nums[0] = 2, therefore you can jump up to 2 places from here --> you land on either 3 or 1. From 3 you can jump up to 3 places --> you land on 1, 1 or 4 (the last index). It took you 2 jumps to get from nums[0] to nums [n - 1], therefore the output is 2. "
                    }
                ]
            },
            {
                "id": 1793246,
                "content": [
                    {
                        "username": "shivam9935",
                        "content": "I am always able to think of recursion in this way but dynamic programing this is always a challenge for me. Can someone help me add memoization in this way?\\n\\n ```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        m = float(\\'inf\\')\\n        \\n        def j(current, jumps, left):\\n            if current == n-1:\\n                nonlocal m\\n                m = min(m, jumps)\\n                return\\n            if left == 0:\\n                # we have to take this jump\\n                j(current+1, jumps+1, nums[current]-1)\\n            if left > 0:\\n                #either we take it\\n                j(current+1, jumps+1, nums[current]-1)\\n                #or we leave current index\\n                j(current+1, jumps, left-1)\\n        \\n        j(0,0,0)\\n        return m\\n```"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "how  [1,1,1,1] answer is 3"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar)  great\\nyou can see my submission there are 3 diffrenet code in it\\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894277570/)"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "thank u [@harsh_negi_07](/harsh_negi_07) \\ni solved this, here is my  c code (beats 90%) \\nhere js = jumps, m = next index where we jump\\nint jump(int* nums, int n){\\n    int js = 0, m;\\n    if (n == 1) return 0;\\n    for (int i = 0; i < n; ){\\n        if (i + nums[i] >= n-1) return ++js;\\n        m = i+1;\\n        for (int j = i+2, k = nums[i]-1; k > 0; j++, k--)\\n            if ((nums[j] + j) >= (nums[m] + m)) m = j;\\n         i = m;\\n         ++js;\\n    }\\n    return js;\\n}"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar) \\n0 <= j <= nums[i] is the value of jump that you can take\\nit\\'s not a comparison statement ...\\nit\\'s telling you the value of jump you can take from current index and not going out of bound that is n"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "[@harsh_negi_07](/harsh_negi_07) \\nbut the question says \\n\"if you are at nums[i], you can jump to any nums[i + j] where:\\n\\n0 <= j <= nums[i] and\\ni + j < n\"\\nso when we are at index 1 how can we jump to index 2 bcz 2 > nums[1]\\nplz tell if i understand question wrong"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohit](/mohitjakhar) \nInitially number of jump is **zero**\nfrom index 0 you can take max jump 1\n```jump = 1  ( 0 -> 1)```\nfrom index 1 you can take max jump 1\n```jump = 2   (1 -> 2)```\nfrom index 2 you can take max jump 1\n```jump = 3   (2 -> 3)```\nyou reached index 3 with jump = 3\n#  InShort at starting index jump = 0"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Thought too much, could be directly solved via BFS"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I tried normal bfs but it was giving tle.... so i tried to memoize my solution it got accepted.... 5% fast (pretty slow)\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894138084/)"
                    },
                    {
                        "username": "rammanoj",
                        "content": "BFS was also giving me a TLE initially. If my code was able to reach index 5 in 3 steps. 3 is the minimum number of steps I can reach 5. I should never take 5 into account again i.e. don\\'t push 5 into the queue again. Mantain a maxReach variable which specifies about maximum index reached in current iteration. Only push to queue if current index could reach more than maxReach. Hope it helps!"
                    },
                    {
                        "username": "____shubham____",
                        "content": "Can anyone please explain me the question\\n\\nInput: nums = [2,3,1,1,4]\\nOutput: 2\\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\\n\\nIt says \"You are initially positioned at nums[0].\"\\nso my source is nums[0] => 2\\nand dest is nums[n - 1] => 4\\n\\nBut the solution says \"Jump 1 step from index 0 to 1\"\\n\\nMy source is 0 or nums[0]?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "0 bro\\nnums[0] is the maximum jump you can take\\nlike in above tc\\ni = 0 and nums[0] = 2\\nso you can take 1 <= jump <= nums[0] and then you will go to i + jump index "
                    },
                    {
                        "username": "sg3175",
                        "content": "How do we get started in solving this question using C language ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Many problems are pretty hard to solve in C because you have to do everything by hand, allocate memory, write comparators, or use the rather uncomfortable UTHash.  \\nBut this one is quite simple. Imagine you\\'re at index `0`, and `nums[0]` is `6`. You can now \"jump\" to indexes `1`, `2`, `3`, `4`, `5`, or `6`. So which one to choose? How about the one that gets you the farthest on your next jump.  \\nSo all you need for this problem is a single loop and a few variables to keep track of the result, the maximal index of the current jump, and the maximal index of the next jump."
                    },
                    {
                        "username": "babaska",
                        "content": "4 test in submit is failed, bun in testcase he is true. Why???"
                    },
                    {
                        "username": "MichaelTeguhLaksana",
                        "content": "Hi, I tried to use BFS instead to solve this question. However, I found that its too slow. I haven\\'t given it much thought, but shouldn\\'t what BFS (without checking the same index twice) do is the same as the suggested Greedy algorithm? Is it probably how I implemented it that\\'s the issue?"
                    },
                    {
                        "username": "sajjadzh",
                        "content": "for those who wanna implement a easy to understand O(n) approach , they should think about \"snake and ladder\" problem - solved by BFS. "
                    },
                    {
                        "username": "185535",
                        "content": "can someone just help me understand the problem statment? It is very complex and I am quite sure there is a better way to explain this."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Your goal is to reach the last index in the least amount of jumps. Every value that you land on specifies the maximum jumping distance from that index. If you land on a 3, you can jump **up to** 3 places from that index etc. \n\ninput: [2,3,1,1,4]\n\nYou start on nums[0]. nums[0] = 2, therefore you can jump up to 2 places from here --> you land on either 3 or 1. From 3 you can jump up to 3 places --> you land on 1, 1 or 4 (the last index). It took you 2 jumps to get from nums[0] to nums [n - 1], therefore the output is 2. "
                    }
                ]
            },
            {
                "id": 1793151,
                "content": [
                    {
                        "username": "adilkhanovkz",
                        "content": "Do I need to really provide O(n) solution if my O(n^2) solution is accepted. I have not expected that my O(n^2) solution will be accepted but I just tried and it is passed. Or it is opportunity  to write appropriate test case? "
                    },
                    {
                        "username": "KARUPPIAH_AL",
                        "content": "My memoization beats only 5%.\\nCan anyone suggest a DP Course?"
                    },
                    {
                        "username": "hellobhaskarhere",
                        "content": "\\nThis test case [1,2,1,1,1] is failing?\\ncan anyone please help me?\\n\\n \\n\\nclass Solution {\\npublic:\\n    \\n    int jumpUtil(vector<int> &nums,int i,int &n,int steps,int &ans,vector<int>&dp)\\n    {\\n        \\n        if(i>=n-1)\\n        {\\n              return dp[n-1]=min(steps,dp[n-1]);\\n        }\\n\\n        if(nums[i]==0)\\n        return INT_MAX;\\n\\n        if(dp[i]!=INT_MAX)\\n        return dp[i];\\n\\n         for(int j=1;j<=nums[i];j++)\\n         {\\n              \\n             dp[i]=min(dp[i],jumpUtil(nums,i+j,n,steps+1,ans,dp));\\n         }\\n         return dp[i];\\n\\n         \\n    }\\n    int jump(vector<int>& nums) {\\n        int i=0;\\n        int n=nums.size();\\n        int steps=0;\\n        int ans=INT_MAX;\\n       vector<int> dp(n,INT_MAX);\\n       \\n       return  jumpUtil(nums,i,n,steps,ans,dp);\\n       \\n\\n    }\\n};"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "I guess in base case you should return 0. As you are already at end or beyond meaning you don\\'t require any jump."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "Please anyone give idea to optimise bfs..\\ngetting tle 82 testcase\\n.. i also tried priority_queue "
                    },
                    {
                        "username": "UjjwalSharma",
                        "content": "Wrong Answer\\n\\nInput\\nnums =\\n[4,1,1,3,1,1,1]\\n59 / 109 testcases passed\\nOutput\\n3\\nExpected\\n2\\n\\nWhy output is 2..?\\nFrom 0 we reach 4th index i.e. 1 jump and take  1 jump and reach 5th index i.e. 2nd jump and at last we again take a jump of 1 and reach 6th index i.e. 3rd jump. How 2 then..??"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Only two jumps are needed : From index 0 (value=4) jump to index 3. From index 3 jump to the last index. Note that for a given index i, it is not mandatory to make a jump equal to the exact value of nums[i]. For example, if nums[i]=4, you can jump to i+1, i+2,i+3 OR i+4. Here's the solution : https://leetcode.com/problems/jump-game-ii/solutions/3159224/greedy-vs-dynamic-programming-c-both-explained/"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Greedy is not always a bad option !!"
                    },
                    {
                        "username": "Praveen_Kispotta",
                        "content": "How many jumps we can make at once...?"
                    },
                    {
                        "username": "Mariia_89",
                        "content": "Maximum - nums[i], minimum - 1 if nums[i]!=0."
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was a nightmare for me.  struggled with optimization until the forums hinted that greedy O(N) solution works."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "4 days of easy leetcoding:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Make sure you iterate till n-2"
                    }
                ]
            },
            {
                "id": 1793060,
                "content": [
                    {
                        "username": "adilkhanovkz",
                        "content": "Do I need to really provide O(n) solution if my O(n^2) solution is accepted. I have not expected that my O(n^2) solution will be accepted but I just tried and it is passed. Or it is opportunity  to write appropriate test case? "
                    },
                    {
                        "username": "KARUPPIAH_AL",
                        "content": "My memoization beats only 5%.\\nCan anyone suggest a DP Course?"
                    },
                    {
                        "username": "hellobhaskarhere",
                        "content": "\\nThis test case [1,2,1,1,1] is failing?\\ncan anyone please help me?\\n\\n \\n\\nclass Solution {\\npublic:\\n    \\n    int jumpUtil(vector<int> &nums,int i,int &n,int steps,int &ans,vector<int>&dp)\\n    {\\n        \\n        if(i>=n-1)\\n        {\\n              return dp[n-1]=min(steps,dp[n-1]);\\n        }\\n\\n        if(nums[i]==0)\\n        return INT_MAX;\\n\\n        if(dp[i]!=INT_MAX)\\n        return dp[i];\\n\\n         for(int j=1;j<=nums[i];j++)\\n         {\\n              \\n             dp[i]=min(dp[i],jumpUtil(nums,i+j,n,steps+1,ans,dp));\\n         }\\n         return dp[i];\\n\\n         \\n    }\\n    int jump(vector<int>& nums) {\\n        int i=0;\\n        int n=nums.size();\\n        int steps=0;\\n        int ans=INT_MAX;\\n       vector<int> dp(n,INT_MAX);\\n       \\n       return  jumpUtil(nums,i,n,steps,ans,dp);\\n       \\n\\n    }\\n};"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "I guess in base case you should return 0. As you are already at end or beyond meaning you don\\'t require any jump."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "Please anyone give idea to optimise bfs..\\ngetting tle 82 testcase\\n.. i also tried priority_queue "
                    },
                    {
                        "username": "UjjwalSharma",
                        "content": "Wrong Answer\\n\\nInput\\nnums =\\n[4,1,1,3,1,1,1]\\n59 / 109 testcases passed\\nOutput\\n3\\nExpected\\n2\\n\\nWhy output is 2..?\\nFrom 0 we reach 4th index i.e. 1 jump and take  1 jump and reach 5th index i.e. 2nd jump and at last we again take a jump of 1 and reach 6th index i.e. 3rd jump. How 2 then..??"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Only two jumps are needed : From index 0 (value=4) jump to index 3. From index 3 jump to the last index. Note that for a given index i, it is not mandatory to make a jump equal to the exact value of nums[i]. For example, if nums[i]=4, you can jump to i+1, i+2,i+3 OR i+4. Here's the solution : https://leetcode.com/problems/jump-game-ii/solutions/3159224/greedy-vs-dynamic-programming-c-both-explained/"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Greedy is not always a bad option !!"
                    },
                    {
                        "username": "Praveen_Kispotta",
                        "content": "How many jumps we can make at once...?"
                    },
                    {
                        "username": "Mariia_89",
                        "content": "Maximum - nums[i], minimum - 1 if nums[i]!=0."
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was a nightmare for me.  struggled with optimization until the forums hinted that greedy O(N) solution works."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "4 days of easy leetcoding:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Make sure you iterate till n-2"
                    }
                ]
            },
            {
                "id": 1793028,
                "content": [
                    {
                        "username": "adilkhanovkz",
                        "content": "Do I need to really provide O(n) solution if my O(n^2) solution is accepted. I have not expected that my O(n^2) solution will be accepted but I just tried and it is passed. Or it is opportunity  to write appropriate test case? "
                    },
                    {
                        "username": "KARUPPIAH_AL",
                        "content": "My memoization beats only 5%.\\nCan anyone suggest a DP Course?"
                    },
                    {
                        "username": "hellobhaskarhere",
                        "content": "\\nThis test case [1,2,1,1,1] is failing?\\ncan anyone please help me?\\n\\n \\n\\nclass Solution {\\npublic:\\n    \\n    int jumpUtil(vector<int> &nums,int i,int &n,int steps,int &ans,vector<int>&dp)\\n    {\\n        \\n        if(i>=n-1)\\n        {\\n              return dp[n-1]=min(steps,dp[n-1]);\\n        }\\n\\n        if(nums[i]==0)\\n        return INT_MAX;\\n\\n        if(dp[i]!=INT_MAX)\\n        return dp[i];\\n\\n         for(int j=1;j<=nums[i];j++)\\n         {\\n              \\n             dp[i]=min(dp[i],jumpUtil(nums,i+j,n,steps+1,ans,dp));\\n         }\\n         return dp[i];\\n\\n         \\n    }\\n    int jump(vector<int>& nums) {\\n        int i=0;\\n        int n=nums.size();\\n        int steps=0;\\n        int ans=INT_MAX;\\n       vector<int> dp(n,INT_MAX);\\n       \\n       return  jumpUtil(nums,i,n,steps,ans,dp);\\n       \\n\\n    }\\n};"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "I guess in base case you should return 0. As you are already at end or beyond meaning you don\\'t require any jump."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "Please anyone give idea to optimise bfs..\\ngetting tle 82 testcase\\n.. i also tried priority_queue "
                    },
                    {
                        "username": "UjjwalSharma",
                        "content": "Wrong Answer\\n\\nInput\\nnums =\\n[4,1,1,3,1,1,1]\\n59 / 109 testcases passed\\nOutput\\n3\\nExpected\\n2\\n\\nWhy output is 2..?\\nFrom 0 we reach 4th index i.e. 1 jump and take  1 jump and reach 5th index i.e. 2nd jump and at last we again take a jump of 1 and reach 6th index i.e. 3rd jump. How 2 then..??"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Only two jumps are needed : From index 0 (value=4) jump to index 3. From index 3 jump to the last index. Note that for a given index i, it is not mandatory to make a jump equal to the exact value of nums[i]. For example, if nums[i]=4, you can jump to i+1, i+2,i+3 OR i+4. Here's the solution : https://leetcode.com/problems/jump-game-ii/solutions/3159224/greedy-vs-dynamic-programming-c-both-explained/"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Greedy is not always a bad option !!"
                    },
                    {
                        "username": "Praveen_Kispotta",
                        "content": "How many jumps we can make at once...?"
                    },
                    {
                        "username": "Mariia_89",
                        "content": "Maximum - nums[i], minimum - 1 if nums[i]!=0."
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was a nightmare for me.  struggled with optimization until the forums hinted that greedy O(N) solution works."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "4 days of easy leetcoding:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Make sure you iterate till n-2"
                    }
                ]
            },
            {
                "id": 1792979,
                "content": [
                    {
                        "username": "adilkhanovkz",
                        "content": "Do I need to really provide O(n) solution if my O(n^2) solution is accepted. I have not expected that my O(n^2) solution will be accepted but I just tried and it is passed. Or it is opportunity  to write appropriate test case? "
                    },
                    {
                        "username": "KARUPPIAH_AL",
                        "content": "My memoization beats only 5%.\\nCan anyone suggest a DP Course?"
                    },
                    {
                        "username": "hellobhaskarhere",
                        "content": "\\nThis test case [1,2,1,1,1] is failing?\\ncan anyone please help me?\\n\\n \\n\\nclass Solution {\\npublic:\\n    \\n    int jumpUtil(vector<int> &nums,int i,int &n,int steps,int &ans,vector<int>&dp)\\n    {\\n        \\n        if(i>=n-1)\\n        {\\n              return dp[n-1]=min(steps,dp[n-1]);\\n        }\\n\\n        if(nums[i]==0)\\n        return INT_MAX;\\n\\n        if(dp[i]!=INT_MAX)\\n        return dp[i];\\n\\n         for(int j=1;j<=nums[i];j++)\\n         {\\n              \\n             dp[i]=min(dp[i],jumpUtil(nums,i+j,n,steps+1,ans,dp));\\n         }\\n         return dp[i];\\n\\n         \\n    }\\n    int jump(vector<int>& nums) {\\n        int i=0;\\n        int n=nums.size();\\n        int steps=0;\\n        int ans=INT_MAX;\\n       vector<int> dp(n,INT_MAX);\\n       \\n       return  jumpUtil(nums,i,n,steps,ans,dp);\\n       \\n\\n    }\\n};"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "I guess in base case you should return 0. As you are already at end or beyond meaning you don\\'t require any jump."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "Please anyone give idea to optimise bfs..\\ngetting tle 82 testcase\\n.. i also tried priority_queue "
                    },
                    {
                        "username": "UjjwalSharma",
                        "content": "Wrong Answer\\n\\nInput\\nnums =\\n[4,1,1,3,1,1,1]\\n59 / 109 testcases passed\\nOutput\\n3\\nExpected\\n2\\n\\nWhy output is 2..?\\nFrom 0 we reach 4th index i.e. 1 jump and take  1 jump and reach 5th index i.e. 2nd jump and at last we again take a jump of 1 and reach 6th index i.e. 3rd jump. How 2 then..??"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Only two jumps are needed : From index 0 (value=4) jump to index 3. From index 3 jump to the last index. Note that for a given index i, it is not mandatory to make a jump equal to the exact value of nums[i]. For example, if nums[i]=4, you can jump to i+1, i+2,i+3 OR i+4. Here's the solution : https://leetcode.com/problems/jump-game-ii/solutions/3159224/greedy-vs-dynamic-programming-c-both-explained/"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Greedy is not always a bad option !!"
                    },
                    {
                        "username": "Praveen_Kispotta",
                        "content": "How many jumps we can make at once...?"
                    },
                    {
                        "username": "Mariia_89",
                        "content": "Maximum - nums[i], minimum - 1 if nums[i]!=0."
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was a nightmare for me.  struggled with optimization until the forums hinted that greedy O(N) solution works."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "4 days of easy leetcoding:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Make sure you iterate till n-2"
                    }
                ]
            },
            {
                "id": 1792967,
                "content": [
                    {
                        "username": "adilkhanovkz",
                        "content": "Do I need to really provide O(n) solution if my O(n^2) solution is accepted. I have not expected that my O(n^2) solution will be accepted but I just tried and it is passed. Or it is opportunity  to write appropriate test case? "
                    },
                    {
                        "username": "KARUPPIAH_AL",
                        "content": "My memoization beats only 5%.\\nCan anyone suggest a DP Course?"
                    },
                    {
                        "username": "hellobhaskarhere",
                        "content": "\\nThis test case [1,2,1,1,1] is failing?\\ncan anyone please help me?\\n\\n \\n\\nclass Solution {\\npublic:\\n    \\n    int jumpUtil(vector<int> &nums,int i,int &n,int steps,int &ans,vector<int>&dp)\\n    {\\n        \\n        if(i>=n-1)\\n        {\\n              return dp[n-1]=min(steps,dp[n-1]);\\n        }\\n\\n        if(nums[i]==0)\\n        return INT_MAX;\\n\\n        if(dp[i]!=INT_MAX)\\n        return dp[i];\\n\\n         for(int j=1;j<=nums[i];j++)\\n         {\\n              \\n             dp[i]=min(dp[i],jumpUtil(nums,i+j,n,steps+1,ans,dp));\\n         }\\n         return dp[i];\\n\\n         \\n    }\\n    int jump(vector<int>& nums) {\\n        int i=0;\\n        int n=nums.size();\\n        int steps=0;\\n        int ans=INT_MAX;\\n       vector<int> dp(n,INT_MAX);\\n       \\n       return  jumpUtil(nums,i,n,steps,ans,dp);\\n       \\n\\n    }\\n};"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "I guess in base case you should return 0. As you are already at end or beyond meaning you don\\'t require any jump."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "Please anyone give idea to optimise bfs..\\ngetting tle 82 testcase\\n.. i also tried priority_queue "
                    },
                    {
                        "username": "UjjwalSharma",
                        "content": "Wrong Answer\\n\\nInput\\nnums =\\n[4,1,1,3,1,1,1]\\n59 / 109 testcases passed\\nOutput\\n3\\nExpected\\n2\\n\\nWhy output is 2..?\\nFrom 0 we reach 4th index i.e. 1 jump and take  1 jump and reach 5th index i.e. 2nd jump and at last we again take a jump of 1 and reach 6th index i.e. 3rd jump. How 2 then..??"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Only two jumps are needed : From index 0 (value=4) jump to index 3. From index 3 jump to the last index. Note that for a given index i, it is not mandatory to make a jump equal to the exact value of nums[i]. For example, if nums[i]=4, you can jump to i+1, i+2,i+3 OR i+4. Here's the solution : https://leetcode.com/problems/jump-game-ii/solutions/3159224/greedy-vs-dynamic-programming-c-both-explained/"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Greedy is not always a bad option !!"
                    },
                    {
                        "username": "Praveen_Kispotta",
                        "content": "How many jumps we can make at once...?"
                    },
                    {
                        "username": "Mariia_89",
                        "content": "Maximum - nums[i], minimum - 1 if nums[i]!=0."
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was a nightmare for me.  struggled with optimization until the forums hinted that greedy O(N) solution works."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "4 days of easy leetcoding:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Make sure you iterate till n-2"
                    }
                ]
            },
            {
                "id": 1792924,
                "content": [
                    {
                        "username": "adilkhanovkz",
                        "content": "Do I need to really provide O(n) solution if my O(n^2) solution is accepted. I have not expected that my O(n^2) solution will be accepted but I just tried and it is passed. Or it is opportunity  to write appropriate test case? "
                    },
                    {
                        "username": "KARUPPIAH_AL",
                        "content": "My memoization beats only 5%.\\nCan anyone suggest a DP Course?"
                    },
                    {
                        "username": "hellobhaskarhere",
                        "content": "\\nThis test case [1,2,1,1,1] is failing?\\ncan anyone please help me?\\n\\n \\n\\nclass Solution {\\npublic:\\n    \\n    int jumpUtil(vector<int> &nums,int i,int &n,int steps,int &ans,vector<int>&dp)\\n    {\\n        \\n        if(i>=n-1)\\n        {\\n              return dp[n-1]=min(steps,dp[n-1]);\\n        }\\n\\n        if(nums[i]==0)\\n        return INT_MAX;\\n\\n        if(dp[i]!=INT_MAX)\\n        return dp[i];\\n\\n         for(int j=1;j<=nums[i];j++)\\n         {\\n              \\n             dp[i]=min(dp[i],jumpUtil(nums,i+j,n,steps+1,ans,dp));\\n         }\\n         return dp[i];\\n\\n         \\n    }\\n    int jump(vector<int>& nums) {\\n        int i=0;\\n        int n=nums.size();\\n        int steps=0;\\n        int ans=INT_MAX;\\n       vector<int> dp(n,INT_MAX);\\n       \\n       return  jumpUtil(nums,i,n,steps,ans,dp);\\n       \\n\\n    }\\n};"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "I guess in base case you should return 0. As you are already at end or beyond meaning you don\\'t require any jump."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "Please anyone give idea to optimise bfs..\\ngetting tle 82 testcase\\n.. i also tried priority_queue "
                    },
                    {
                        "username": "UjjwalSharma",
                        "content": "Wrong Answer\\n\\nInput\\nnums =\\n[4,1,1,3,1,1,1]\\n59 / 109 testcases passed\\nOutput\\n3\\nExpected\\n2\\n\\nWhy output is 2..?\\nFrom 0 we reach 4th index i.e. 1 jump and take  1 jump and reach 5th index i.e. 2nd jump and at last we again take a jump of 1 and reach 6th index i.e. 3rd jump. How 2 then..??"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Only two jumps are needed : From index 0 (value=4) jump to index 3. From index 3 jump to the last index. Note that for a given index i, it is not mandatory to make a jump equal to the exact value of nums[i]. For example, if nums[i]=4, you can jump to i+1, i+2,i+3 OR i+4. Here's the solution : https://leetcode.com/problems/jump-game-ii/solutions/3159224/greedy-vs-dynamic-programming-c-both-explained/"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Greedy is not always a bad option !!"
                    },
                    {
                        "username": "Praveen_Kispotta",
                        "content": "How many jumps we can make at once...?"
                    },
                    {
                        "username": "Mariia_89",
                        "content": "Maximum - nums[i], minimum - 1 if nums[i]!=0."
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was a nightmare for me.  struggled with optimization until the forums hinted that greedy O(N) solution works."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "4 days of easy leetcoding:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Make sure you iterate till n-2"
                    }
                ]
            },
            {
                "id": 1792910,
                "content": [
                    {
                        "username": "adilkhanovkz",
                        "content": "Do I need to really provide O(n) solution if my O(n^2) solution is accepted. I have not expected that my O(n^2) solution will be accepted but I just tried and it is passed. Or it is opportunity  to write appropriate test case? "
                    },
                    {
                        "username": "KARUPPIAH_AL",
                        "content": "My memoization beats only 5%.\\nCan anyone suggest a DP Course?"
                    },
                    {
                        "username": "hellobhaskarhere",
                        "content": "\\nThis test case [1,2,1,1,1] is failing?\\ncan anyone please help me?\\n\\n \\n\\nclass Solution {\\npublic:\\n    \\n    int jumpUtil(vector<int> &nums,int i,int &n,int steps,int &ans,vector<int>&dp)\\n    {\\n        \\n        if(i>=n-1)\\n        {\\n              return dp[n-1]=min(steps,dp[n-1]);\\n        }\\n\\n        if(nums[i]==0)\\n        return INT_MAX;\\n\\n        if(dp[i]!=INT_MAX)\\n        return dp[i];\\n\\n         for(int j=1;j<=nums[i];j++)\\n         {\\n              \\n             dp[i]=min(dp[i],jumpUtil(nums,i+j,n,steps+1,ans,dp));\\n         }\\n         return dp[i];\\n\\n         \\n    }\\n    int jump(vector<int>& nums) {\\n        int i=0;\\n        int n=nums.size();\\n        int steps=0;\\n        int ans=INT_MAX;\\n       vector<int> dp(n,INT_MAX);\\n       \\n       return  jumpUtil(nums,i,n,steps,ans,dp);\\n       \\n\\n    }\\n};"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "I guess in base case you should return 0. As you are already at end or beyond meaning you don\\'t require any jump."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "Please anyone give idea to optimise bfs..\\ngetting tle 82 testcase\\n.. i also tried priority_queue "
                    },
                    {
                        "username": "UjjwalSharma",
                        "content": "Wrong Answer\\n\\nInput\\nnums =\\n[4,1,1,3,1,1,1]\\n59 / 109 testcases passed\\nOutput\\n3\\nExpected\\n2\\n\\nWhy output is 2..?\\nFrom 0 we reach 4th index i.e. 1 jump and take  1 jump and reach 5th index i.e. 2nd jump and at last we again take a jump of 1 and reach 6th index i.e. 3rd jump. How 2 then..??"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Only two jumps are needed : From index 0 (value=4) jump to index 3. From index 3 jump to the last index. Note that for a given index i, it is not mandatory to make a jump equal to the exact value of nums[i]. For example, if nums[i]=4, you can jump to i+1, i+2,i+3 OR i+4. Here's the solution : https://leetcode.com/problems/jump-game-ii/solutions/3159224/greedy-vs-dynamic-programming-c-both-explained/"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Greedy is not always a bad option !!"
                    },
                    {
                        "username": "Praveen_Kispotta",
                        "content": "How many jumps we can make at once...?"
                    },
                    {
                        "username": "Mariia_89",
                        "content": "Maximum - nums[i], minimum - 1 if nums[i]!=0."
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was a nightmare for me.  struggled with optimization until the forums hinted that greedy O(N) solution works."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "4 days of easy leetcoding:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Make sure you iterate till n-2"
                    }
                ]
            },
            {
                "id": 1792845,
                "content": [
                    {
                        "username": "adilkhanovkz",
                        "content": "Do I need to really provide O(n) solution if my O(n^2) solution is accepted. I have not expected that my O(n^2) solution will be accepted but I just tried and it is passed. Or it is opportunity  to write appropriate test case? "
                    },
                    {
                        "username": "KARUPPIAH_AL",
                        "content": "My memoization beats only 5%.\\nCan anyone suggest a DP Course?"
                    },
                    {
                        "username": "hellobhaskarhere",
                        "content": "\\nThis test case [1,2,1,1,1] is failing?\\ncan anyone please help me?\\n\\n \\n\\nclass Solution {\\npublic:\\n    \\n    int jumpUtil(vector<int> &nums,int i,int &n,int steps,int &ans,vector<int>&dp)\\n    {\\n        \\n        if(i>=n-1)\\n        {\\n              return dp[n-1]=min(steps,dp[n-1]);\\n        }\\n\\n        if(nums[i]==0)\\n        return INT_MAX;\\n\\n        if(dp[i]!=INT_MAX)\\n        return dp[i];\\n\\n         for(int j=1;j<=nums[i];j++)\\n         {\\n              \\n             dp[i]=min(dp[i],jumpUtil(nums,i+j,n,steps+1,ans,dp));\\n         }\\n         return dp[i];\\n\\n         \\n    }\\n    int jump(vector<int>& nums) {\\n        int i=0;\\n        int n=nums.size();\\n        int steps=0;\\n        int ans=INT_MAX;\\n       vector<int> dp(n,INT_MAX);\\n       \\n       return  jumpUtil(nums,i,n,steps,ans,dp);\\n       \\n\\n    }\\n};"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "I guess in base case you should return 0. As you are already at end or beyond meaning you don\\'t require any jump."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "Please anyone give idea to optimise bfs..\\ngetting tle 82 testcase\\n.. i also tried priority_queue "
                    },
                    {
                        "username": "UjjwalSharma",
                        "content": "Wrong Answer\\n\\nInput\\nnums =\\n[4,1,1,3,1,1,1]\\n59 / 109 testcases passed\\nOutput\\n3\\nExpected\\n2\\n\\nWhy output is 2..?\\nFrom 0 we reach 4th index i.e. 1 jump and take  1 jump and reach 5th index i.e. 2nd jump and at last we again take a jump of 1 and reach 6th index i.e. 3rd jump. How 2 then..??"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Only two jumps are needed : From index 0 (value=4) jump to index 3. From index 3 jump to the last index. Note that for a given index i, it is not mandatory to make a jump equal to the exact value of nums[i]. For example, if nums[i]=4, you can jump to i+1, i+2,i+3 OR i+4. Here's the solution : https://leetcode.com/problems/jump-game-ii/solutions/3159224/greedy-vs-dynamic-programming-c-both-explained/"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Greedy is not always a bad option !!"
                    },
                    {
                        "username": "Praveen_Kispotta",
                        "content": "How many jumps we can make at once...?"
                    },
                    {
                        "username": "Mariia_89",
                        "content": "Maximum - nums[i], minimum - 1 if nums[i]!=0."
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was a nightmare for me.  struggled with optimization until the forums hinted that greedy O(N) solution works."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "4 days of easy leetcoding:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Make sure you iterate till n-2"
                    }
                ]
            },
            {
                "id": 1792789,
                "content": [
                    {
                        "username": "adilkhanovkz",
                        "content": "Do I need to really provide O(n) solution if my O(n^2) solution is accepted. I have not expected that my O(n^2) solution will be accepted but I just tried and it is passed. Or it is opportunity  to write appropriate test case? "
                    },
                    {
                        "username": "KARUPPIAH_AL",
                        "content": "My memoization beats only 5%.\\nCan anyone suggest a DP Course?"
                    },
                    {
                        "username": "hellobhaskarhere",
                        "content": "\\nThis test case [1,2,1,1,1] is failing?\\ncan anyone please help me?\\n\\n \\n\\nclass Solution {\\npublic:\\n    \\n    int jumpUtil(vector<int> &nums,int i,int &n,int steps,int &ans,vector<int>&dp)\\n    {\\n        \\n        if(i>=n-1)\\n        {\\n              return dp[n-1]=min(steps,dp[n-1]);\\n        }\\n\\n        if(nums[i]==0)\\n        return INT_MAX;\\n\\n        if(dp[i]!=INT_MAX)\\n        return dp[i];\\n\\n         for(int j=1;j<=nums[i];j++)\\n         {\\n              \\n             dp[i]=min(dp[i],jumpUtil(nums,i+j,n,steps+1,ans,dp));\\n         }\\n         return dp[i];\\n\\n         \\n    }\\n    int jump(vector<int>& nums) {\\n        int i=0;\\n        int n=nums.size();\\n        int steps=0;\\n        int ans=INT_MAX;\\n       vector<int> dp(n,INT_MAX);\\n       \\n       return  jumpUtil(nums,i,n,steps,ans,dp);\\n       \\n\\n    }\\n};"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "I guess in base case you should return 0. As you are already at end or beyond meaning you don\\'t require any jump."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "Please anyone give idea to optimise bfs..\\ngetting tle 82 testcase\\n.. i also tried priority_queue "
                    },
                    {
                        "username": "UjjwalSharma",
                        "content": "Wrong Answer\\n\\nInput\\nnums =\\n[4,1,1,3,1,1,1]\\n59 / 109 testcases passed\\nOutput\\n3\\nExpected\\n2\\n\\nWhy output is 2..?\\nFrom 0 we reach 4th index i.e. 1 jump and take  1 jump and reach 5th index i.e. 2nd jump and at last we again take a jump of 1 and reach 6th index i.e. 3rd jump. How 2 then..??"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Only two jumps are needed : From index 0 (value=4) jump to index 3. From index 3 jump to the last index. Note that for a given index i, it is not mandatory to make a jump equal to the exact value of nums[i]. For example, if nums[i]=4, you can jump to i+1, i+2,i+3 OR i+4. Here's the solution : https://leetcode.com/problems/jump-game-ii/solutions/3159224/greedy-vs-dynamic-programming-c-both-explained/"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Greedy is not always a bad option !!"
                    },
                    {
                        "username": "Praveen_Kispotta",
                        "content": "How many jumps we can make at once...?"
                    },
                    {
                        "username": "Mariia_89",
                        "content": "Maximum - nums[i], minimum - 1 if nums[i]!=0."
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was a nightmare for me.  struggled with optimization until the forums hinted that greedy O(N) solution works."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "4 days of easy leetcoding:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Make sure you iterate till n-2"
                    }
                ]
            },
            {
                "id": 1792787,
                "content": [
                    {
                        "username": "adilkhanovkz",
                        "content": "Do I need to really provide O(n) solution if my O(n^2) solution is accepted. I have not expected that my O(n^2) solution will be accepted but I just tried and it is passed. Or it is opportunity  to write appropriate test case? "
                    },
                    {
                        "username": "KARUPPIAH_AL",
                        "content": "My memoization beats only 5%.\\nCan anyone suggest a DP Course?"
                    },
                    {
                        "username": "hellobhaskarhere",
                        "content": "\\nThis test case [1,2,1,1,1] is failing?\\ncan anyone please help me?\\n\\n \\n\\nclass Solution {\\npublic:\\n    \\n    int jumpUtil(vector<int> &nums,int i,int &n,int steps,int &ans,vector<int>&dp)\\n    {\\n        \\n        if(i>=n-1)\\n        {\\n              return dp[n-1]=min(steps,dp[n-1]);\\n        }\\n\\n        if(nums[i]==0)\\n        return INT_MAX;\\n\\n        if(dp[i]!=INT_MAX)\\n        return dp[i];\\n\\n         for(int j=1;j<=nums[i];j++)\\n         {\\n              \\n             dp[i]=min(dp[i],jumpUtil(nums,i+j,n,steps+1,ans,dp));\\n         }\\n         return dp[i];\\n\\n         \\n    }\\n    int jump(vector<int>& nums) {\\n        int i=0;\\n        int n=nums.size();\\n        int steps=0;\\n        int ans=INT_MAX;\\n       vector<int> dp(n,INT_MAX);\\n       \\n       return  jumpUtil(nums,i,n,steps,ans,dp);\\n       \\n\\n    }\\n};"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "I guess in base case you should return 0. As you are already at end or beyond meaning you don\\'t require any jump."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "Please anyone give idea to optimise bfs..\\ngetting tle 82 testcase\\n.. i also tried priority_queue "
                    },
                    {
                        "username": "UjjwalSharma",
                        "content": "Wrong Answer\\n\\nInput\\nnums =\\n[4,1,1,3,1,1,1]\\n59 / 109 testcases passed\\nOutput\\n3\\nExpected\\n2\\n\\nWhy output is 2..?\\nFrom 0 we reach 4th index i.e. 1 jump and take  1 jump and reach 5th index i.e. 2nd jump and at last we again take a jump of 1 and reach 6th index i.e. 3rd jump. How 2 then..??"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Only two jumps are needed : From index 0 (value=4) jump to index 3. From index 3 jump to the last index. Note that for a given index i, it is not mandatory to make a jump equal to the exact value of nums[i]. For example, if nums[i]=4, you can jump to i+1, i+2,i+3 OR i+4. Here's the solution : https://leetcode.com/problems/jump-game-ii/solutions/3159224/greedy-vs-dynamic-programming-c-both-explained/"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Greedy is not always a bad option !!"
                    },
                    {
                        "username": "Praveen_Kispotta",
                        "content": "How many jumps we can make at once...?"
                    },
                    {
                        "username": "Mariia_89",
                        "content": "Maximum - nums[i], minimum - 1 if nums[i]!=0."
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was a nightmare for me.  struggled with optimization until the forums hinted that greedy O(N) solution works."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "4 days of easy leetcoding:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Make sure you iterate till n-2"
                    }
                ]
            },
            {
                "id": 1792785,
                "content": [
                    {
                        "username": "rushi_4123",
                        "content": "In greedy approach :\\nJust make sure you keep track of how far you can reach by using every index step, and boom! you will reach the last index in min jumps!!\\n:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Should i use DP"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "Ahh. This problem again"
                    },
                    {
                        "username": "trantanloc2111",
                        "content": "The simple idea just is find the max step from current position by compare (distance from current to i + value of i position)"
                    },
                    {
                        "username": "karthikbhandary2",
                        "content": "what is j in nums[i + j], 0 <= j <= nums[i] and i + j < n?"
                    },
                    {
                        "username": "dunglee30",
                        "content": "At every position, keep track of furthest position possibly reaching by comparing the current furthest position to the possibly furthest position that the current position i can reach. if current position have passed the last furthest position being tracked, update the next furthest position, keep doing it until we reach the position where its possibly furthest position reach n-1."
                    },
                    {
                        "username": "colabee992",
                        "content": "In Jump Game 1, thinking DP, you jump backwards trying from the closest number to the end goal. This is to get max coverage of all possible jumps.\\n\\nHere, it is reversed. You also try jumping backwards, but try from the number furthest from the end goal, so you capture the best (earliest) possible jump start point."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Why does Recursion with memiozation , gives a Timeout ? "
                    },
                    {
                        "username": "namanchandak",
                        "content": "why tabulation is showing me wrong ans in [1,3,2]  test case\\n\\n\\n\\n\\n\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int >dp(n+3,0);\\n\\n\\n        for(int ind=n;ind>=0;ind--)\\n        {\\n\\n            int jump=1e9;\\n        for(int i=1;i<=nums[ind];i++)\\n        {\\n            // if(nums[i+ind]>=nums.size()-1)\\n            // return 1;\\n            int path=0;\\n            if(i+ind<=n)\\n            path=1+dp[i+ind];\\n            jump=min(jump,path);\\n        }\\n\\n        dp[ind]= jump;\\n\\n\\n\\n        }\\n\\n        \\n\\n\\n       return dp[0]; \\n    }"
                    }
                ]
            },
            {
                "id": 1792765,
                "content": [
                    {
                        "username": "rushi_4123",
                        "content": "In greedy approach :\\nJust make sure you keep track of how far you can reach by using every index step, and boom! you will reach the last index in min jumps!!\\n:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Should i use DP"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "Ahh. This problem again"
                    },
                    {
                        "username": "trantanloc2111",
                        "content": "The simple idea just is find the max step from current position by compare (distance from current to i + value of i position)"
                    },
                    {
                        "username": "karthikbhandary2",
                        "content": "what is j in nums[i + j], 0 <= j <= nums[i] and i + j < n?"
                    },
                    {
                        "username": "dunglee30",
                        "content": "At every position, keep track of furthest position possibly reaching by comparing the current furthest position to the possibly furthest position that the current position i can reach. if current position have passed the last furthest position being tracked, update the next furthest position, keep doing it until we reach the position where its possibly furthest position reach n-1."
                    },
                    {
                        "username": "colabee992",
                        "content": "In Jump Game 1, thinking DP, you jump backwards trying from the closest number to the end goal. This is to get max coverage of all possible jumps.\\n\\nHere, it is reversed. You also try jumping backwards, but try from the number furthest from the end goal, so you capture the best (earliest) possible jump start point."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Why does Recursion with memiozation , gives a Timeout ? "
                    },
                    {
                        "username": "namanchandak",
                        "content": "why tabulation is showing me wrong ans in [1,3,2]  test case\\n\\n\\n\\n\\n\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int >dp(n+3,0);\\n\\n\\n        for(int ind=n;ind>=0;ind--)\\n        {\\n\\n            int jump=1e9;\\n        for(int i=1;i<=nums[ind];i++)\\n        {\\n            // if(nums[i+ind]>=nums.size()-1)\\n            // return 1;\\n            int path=0;\\n            if(i+ind<=n)\\n            path=1+dp[i+ind];\\n            jump=min(jump,path);\\n        }\\n\\n        dp[ind]= jump;\\n\\n\\n\\n        }\\n\\n        \\n\\n\\n       return dp[0]; \\n    }"
                    }
                ]
            },
            {
                "id": 1792722,
                "content": [
                    {
                        "username": "rushi_4123",
                        "content": "In greedy approach :\\nJust make sure you keep track of how far you can reach by using every index step, and boom! you will reach the last index in min jumps!!\\n:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Should i use DP"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "Ahh. This problem again"
                    },
                    {
                        "username": "trantanloc2111",
                        "content": "The simple idea just is find the max step from current position by compare (distance from current to i + value of i position)"
                    },
                    {
                        "username": "karthikbhandary2",
                        "content": "what is j in nums[i + j], 0 <= j <= nums[i] and i + j < n?"
                    },
                    {
                        "username": "dunglee30",
                        "content": "At every position, keep track of furthest position possibly reaching by comparing the current furthest position to the possibly furthest position that the current position i can reach. if current position have passed the last furthest position being tracked, update the next furthest position, keep doing it until we reach the position where its possibly furthest position reach n-1."
                    },
                    {
                        "username": "colabee992",
                        "content": "In Jump Game 1, thinking DP, you jump backwards trying from the closest number to the end goal. This is to get max coverage of all possible jumps.\\n\\nHere, it is reversed. You also try jumping backwards, but try from the number furthest from the end goal, so you capture the best (earliest) possible jump start point."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Why does Recursion with memiozation , gives a Timeout ? "
                    },
                    {
                        "username": "namanchandak",
                        "content": "why tabulation is showing me wrong ans in [1,3,2]  test case\\n\\n\\n\\n\\n\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int >dp(n+3,0);\\n\\n\\n        for(int ind=n;ind>=0;ind--)\\n        {\\n\\n            int jump=1e9;\\n        for(int i=1;i<=nums[ind];i++)\\n        {\\n            // if(nums[i+ind]>=nums.size()-1)\\n            // return 1;\\n            int path=0;\\n            if(i+ind<=n)\\n            path=1+dp[i+ind];\\n            jump=min(jump,path);\\n        }\\n\\n        dp[ind]= jump;\\n\\n\\n\\n        }\\n\\n        \\n\\n\\n       return dp[0]; \\n    }"
                    }
                ]
            },
            {
                "id": 1792708,
                "content": [
                    {
                        "username": "rushi_4123",
                        "content": "In greedy approach :\\nJust make sure you keep track of how far you can reach by using every index step, and boom! you will reach the last index in min jumps!!\\n:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Should i use DP"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "Ahh. This problem again"
                    },
                    {
                        "username": "trantanloc2111",
                        "content": "The simple idea just is find the max step from current position by compare (distance from current to i + value of i position)"
                    },
                    {
                        "username": "karthikbhandary2",
                        "content": "what is j in nums[i + j], 0 <= j <= nums[i] and i + j < n?"
                    },
                    {
                        "username": "dunglee30",
                        "content": "At every position, keep track of furthest position possibly reaching by comparing the current furthest position to the possibly furthest position that the current position i can reach. if current position have passed the last furthest position being tracked, update the next furthest position, keep doing it until we reach the position where its possibly furthest position reach n-1."
                    },
                    {
                        "username": "colabee992",
                        "content": "In Jump Game 1, thinking DP, you jump backwards trying from the closest number to the end goal. This is to get max coverage of all possible jumps.\\n\\nHere, it is reversed. You also try jumping backwards, but try from the number furthest from the end goal, so you capture the best (earliest) possible jump start point."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Why does Recursion with memiozation , gives a Timeout ? "
                    },
                    {
                        "username": "namanchandak",
                        "content": "why tabulation is showing me wrong ans in [1,3,2]  test case\\n\\n\\n\\n\\n\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int >dp(n+3,0);\\n\\n\\n        for(int ind=n;ind>=0;ind--)\\n        {\\n\\n            int jump=1e9;\\n        for(int i=1;i<=nums[ind];i++)\\n        {\\n            // if(nums[i+ind]>=nums.size()-1)\\n            // return 1;\\n            int path=0;\\n            if(i+ind<=n)\\n            path=1+dp[i+ind];\\n            jump=min(jump,path);\\n        }\\n\\n        dp[ind]= jump;\\n\\n\\n\\n        }\\n\\n        \\n\\n\\n       return dp[0]; \\n    }"
                    }
                ]
            },
            {
                "id": 1792668,
                "content": [
                    {
                        "username": "rushi_4123",
                        "content": "In greedy approach :\\nJust make sure you keep track of how far you can reach by using every index step, and boom! you will reach the last index in min jumps!!\\n:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Should i use DP"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "Ahh. This problem again"
                    },
                    {
                        "username": "trantanloc2111",
                        "content": "The simple idea just is find the max step from current position by compare (distance from current to i + value of i position)"
                    },
                    {
                        "username": "karthikbhandary2",
                        "content": "what is j in nums[i + j], 0 <= j <= nums[i] and i + j < n?"
                    },
                    {
                        "username": "dunglee30",
                        "content": "At every position, keep track of furthest position possibly reaching by comparing the current furthest position to the possibly furthest position that the current position i can reach. if current position have passed the last furthest position being tracked, update the next furthest position, keep doing it until we reach the position where its possibly furthest position reach n-1."
                    },
                    {
                        "username": "colabee992",
                        "content": "In Jump Game 1, thinking DP, you jump backwards trying from the closest number to the end goal. This is to get max coverage of all possible jumps.\\n\\nHere, it is reversed. You also try jumping backwards, but try from the number furthest from the end goal, so you capture the best (earliest) possible jump start point."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Why does Recursion with memiozation , gives a Timeout ? "
                    },
                    {
                        "username": "namanchandak",
                        "content": "why tabulation is showing me wrong ans in [1,3,2]  test case\\n\\n\\n\\n\\n\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int >dp(n+3,0);\\n\\n\\n        for(int ind=n;ind>=0;ind--)\\n        {\\n\\n            int jump=1e9;\\n        for(int i=1;i<=nums[ind];i++)\\n        {\\n            // if(nums[i+ind]>=nums.size()-1)\\n            // return 1;\\n            int path=0;\\n            if(i+ind<=n)\\n            path=1+dp[i+ind];\\n            jump=min(jump,path);\\n        }\\n\\n        dp[ind]= jump;\\n\\n\\n\\n        }\\n\\n        \\n\\n\\n       return dp[0]; \\n    }"
                    }
                ]
            },
            {
                "id": 1792594,
                "content": [
                    {
                        "username": "rushi_4123",
                        "content": "In greedy approach :\\nJust make sure you keep track of how far you can reach by using every index step, and boom! you will reach the last index in min jumps!!\\n:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Should i use DP"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "Ahh. This problem again"
                    },
                    {
                        "username": "trantanloc2111",
                        "content": "The simple idea just is find the max step from current position by compare (distance from current to i + value of i position)"
                    },
                    {
                        "username": "karthikbhandary2",
                        "content": "what is j in nums[i + j], 0 <= j <= nums[i] and i + j < n?"
                    },
                    {
                        "username": "dunglee30",
                        "content": "At every position, keep track of furthest position possibly reaching by comparing the current furthest position to the possibly furthest position that the current position i can reach. if current position have passed the last furthest position being tracked, update the next furthest position, keep doing it until we reach the position where its possibly furthest position reach n-1."
                    },
                    {
                        "username": "colabee992",
                        "content": "In Jump Game 1, thinking DP, you jump backwards trying from the closest number to the end goal. This is to get max coverage of all possible jumps.\\n\\nHere, it is reversed. You also try jumping backwards, but try from the number furthest from the end goal, so you capture the best (earliest) possible jump start point."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Why does Recursion with memiozation , gives a Timeout ? "
                    },
                    {
                        "username": "namanchandak",
                        "content": "why tabulation is showing me wrong ans in [1,3,2]  test case\\n\\n\\n\\n\\n\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int >dp(n+3,0);\\n\\n\\n        for(int ind=n;ind>=0;ind--)\\n        {\\n\\n            int jump=1e9;\\n        for(int i=1;i<=nums[ind];i++)\\n        {\\n            // if(nums[i+ind]>=nums.size()-1)\\n            // return 1;\\n            int path=0;\\n            if(i+ind<=n)\\n            path=1+dp[i+ind];\\n            jump=min(jump,path);\\n        }\\n\\n        dp[ind]= jump;\\n\\n\\n\\n        }\\n\\n        \\n\\n\\n       return dp[0]; \\n    }"
                    }
                ]
            },
            {
                "id": 1760266,
                "content": [
                    {
                        "username": "rushi_4123",
                        "content": "In greedy approach :\\nJust make sure you keep track of how far you can reach by using every index step, and boom! you will reach the last index in min jumps!!\\n:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Should i use DP"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "Ahh. This problem again"
                    },
                    {
                        "username": "trantanloc2111",
                        "content": "The simple idea just is find the max step from current position by compare (distance from current to i + value of i position)"
                    },
                    {
                        "username": "karthikbhandary2",
                        "content": "what is j in nums[i + j], 0 <= j <= nums[i] and i + j < n?"
                    },
                    {
                        "username": "dunglee30",
                        "content": "At every position, keep track of furthest position possibly reaching by comparing the current furthest position to the possibly furthest position that the current position i can reach. if current position have passed the last furthest position being tracked, update the next furthest position, keep doing it until we reach the position where its possibly furthest position reach n-1."
                    },
                    {
                        "username": "colabee992",
                        "content": "In Jump Game 1, thinking DP, you jump backwards trying from the closest number to the end goal. This is to get max coverage of all possible jumps.\\n\\nHere, it is reversed. You also try jumping backwards, but try from the number furthest from the end goal, so you capture the best (earliest) possible jump start point."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Why does Recursion with memiozation , gives a Timeout ? "
                    },
                    {
                        "username": "namanchandak",
                        "content": "why tabulation is showing me wrong ans in [1,3,2]  test case\\n\\n\\n\\n\\n\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int >dp(n+3,0);\\n\\n\\n        for(int ind=n;ind>=0;ind--)\\n        {\\n\\n            int jump=1e9;\\n        for(int i=1;i<=nums[ind];i++)\\n        {\\n            // if(nums[i+ind]>=nums.size()-1)\\n            // return 1;\\n            int path=0;\\n            if(i+ind<=n)\\n            path=1+dp[i+ind];\\n            jump=min(jump,path);\\n        }\\n\\n        dp[ind]= jump;\\n\\n\\n\\n        }\\n\\n        \\n\\n\\n       return dp[0]; \\n    }"
                    }
                ]
            },
            {
                "id": 1752623,
                "content": [
                    {
                        "username": "rushi_4123",
                        "content": "In greedy approach :\\nJust make sure you keep track of how far you can reach by using every index step, and boom! you will reach the last index in min jumps!!\\n:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Should i use DP"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "Ahh. This problem again"
                    },
                    {
                        "username": "trantanloc2111",
                        "content": "The simple idea just is find the max step from current position by compare (distance from current to i + value of i position)"
                    },
                    {
                        "username": "karthikbhandary2",
                        "content": "what is j in nums[i + j], 0 <= j <= nums[i] and i + j < n?"
                    },
                    {
                        "username": "dunglee30",
                        "content": "At every position, keep track of furthest position possibly reaching by comparing the current furthest position to the possibly furthest position that the current position i can reach. if current position have passed the last furthest position being tracked, update the next furthest position, keep doing it until we reach the position where its possibly furthest position reach n-1."
                    },
                    {
                        "username": "colabee992",
                        "content": "In Jump Game 1, thinking DP, you jump backwards trying from the closest number to the end goal. This is to get max coverage of all possible jumps.\\n\\nHere, it is reversed. You also try jumping backwards, but try from the number furthest from the end goal, so you capture the best (earliest) possible jump start point."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Why does Recursion with memiozation , gives a Timeout ? "
                    },
                    {
                        "username": "namanchandak",
                        "content": "why tabulation is showing me wrong ans in [1,3,2]  test case\\n\\n\\n\\n\\n\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int >dp(n+3,0);\\n\\n\\n        for(int ind=n;ind>=0;ind--)\\n        {\\n\\n            int jump=1e9;\\n        for(int i=1;i<=nums[ind];i++)\\n        {\\n            // if(nums[i+ind]>=nums.size()-1)\\n            // return 1;\\n            int path=0;\\n            if(i+ind<=n)\\n            path=1+dp[i+ind];\\n            jump=min(jump,path);\\n        }\\n\\n        dp[ind]= jump;\\n\\n\\n\\n        }\\n\\n        \\n\\n\\n       return dp[0]; \\n    }"
                    }
                ]
            },
            {
                "id": 1728462,
                "content": [
                    {
                        "username": "rushi_4123",
                        "content": "In greedy approach :\\nJust make sure you keep track of how far you can reach by using every index step, and boom! you will reach the last index in min jumps!!\\n:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Should i use DP"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "Ahh. This problem again"
                    },
                    {
                        "username": "trantanloc2111",
                        "content": "The simple idea just is find the max step from current position by compare (distance from current to i + value of i position)"
                    },
                    {
                        "username": "karthikbhandary2",
                        "content": "what is j in nums[i + j], 0 <= j <= nums[i] and i + j < n?"
                    },
                    {
                        "username": "dunglee30",
                        "content": "At every position, keep track of furthest position possibly reaching by comparing the current furthest position to the possibly furthest position that the current position i can reach. if current position have passed the last furthest position being tracked, update the next furthest position, keep doing it until we reach the position where its possibly furthest position reach n-1."
                    },
                    {
                        "username": "colabee992",
                        "content": "In Jump Game 1, thinking DP, you jump backwards trying from the closest number to the end goal. This is to get max coverage of all possible jumps.\\n\\nHere, it is reversed. You also try jumping backwards, but try from the number furthest from the end goal, so you capture the best (earliest) possible jump start point."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Why does Recursion with memiozation , gives a Timeout ? "
                    },
                    {
                        "username": "namanchandak",
                        "content": "why tabulation is showing me wrong ans in [1,3,2]  test case\\n\\n\\n\\n\\n\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int >dp(n+3,0);\\n\\n\\n        for(int ind=n;ind>=0;ind--)\\n        {\\n\\n            int jump=1e9;\\n        for(int i=1;i<=nums[ind];i++)\\n        {\\n            // if(nums[i+ind]>=nums.size()-1)\\n            // return 1;\\n            int path=0;\\n            if(i+ind<=n)\\n            path=1+dp[i+ind];\\n            jump=min(jump,path);\\n        }\\n\\n        dp[ind]= jump;\\n\\n\\n\\n        }\\n\\n        \\n\\n\\n       return dp[0]; \\n    }"
                    }
                ]
            },
            {
                "id": 1725093,
                "content": [
                    {
                        "username": "rushi_4123",
                        "content": "In greedy approach :\\nJust make sure you keep track of how far you can reach by using every index step, and boom! you will reach the last index in min jumps!!\\n:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Should i use DP"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "Ahh. This problem again"
                    },
                    {
                        "username": "trantanloc2111",
                        "content": "The simple idea just is find the max step from current position by compare (distance from current to i + value of i position)"
                    },
                    {
                        "username": "karthikbhandary2",
                        "content": "what is j in nums[i + j], 0 <= j <= nums[i] and i + j < n?"
                    },
                    {
                        "username": "dunglee30",
                        "content": "At every position, keep track of furthest position possibly reaching by comparing the current furthest position to the possibly furthest position that the current position i can reach. if current position have passed the last furthest position being tracked, update the next furthest position, keep doing it until we reach the position where its possibly furthest position reach n-1."
                    },
                    {
                        "username": "colabee992",
                        "content": "In Jump Game 1, thinking DP, you jump backwards trying from the closest number to the end goal. This is to get max coverage of all possible jumps.\\n\\nHere, it is reversed. You also try jumping backwards, but try from the number furthest from the end goal, so you capture the best (earliest) possible jump start point."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Why does Recursion with memiozation , gives a Timeout ? "
                    },
                    {
                        "username": "namanchandak",
                        "content": "why tabulation is showing me wrong ans in [1,3,2]  test case\\n\\n\\n\\n\\n\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int >dp(n+3,0);\\n\\n\\n        for(int ind=n;ind>=0;ind--)\\n        {\\n\\n            int jump=1e9;\\n        for(int i=1;i<=nums[ind];i++)\\n        {\\n            // if(nums[i+ind]>=nums.size()-1)\\n            // return 1;\\n            int path=0;\\n            if(i+ind<=n)\\n            path=1+dp[i+ind];\\n            jump=min(jump,path);\\n        }\\n\\n        dp[ind]= jump;\\n\\n\\n\\n        }\\n\\n        \\n\\n\\n       return dp[0]; \\n    }"
                    }
                ]
            }
        ]
    }
]