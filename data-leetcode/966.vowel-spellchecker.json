[
    {
        "title": "Vowel Spellchecker",
        "question_content": "Given a wordlist, we want to implement a spellchecker that converts a query word into a correct word.\nFor a given query word, the spell checker handles two categories of spelling mistakes:\n\n\tCapitalization: If the query matches a word in the wordlist (case-insensitive), then the query word is returned with the same case as the case in the wordlist.\n\t\n\t\tExample: wordlist = [\"yellow\"], query = \"YellOw\": correct = \"yellow\"\n\t\tExample: wordlist = [\"Yellow\"], query = \"yellow\": correct = \"Yellow\"\n\t\tExample: wordlist = [\"yellow\"], query = \"yellow\": correct = \"yellow\"\n\t\n\t\n\tVowel Errors: If after replacing the vowels ('a', 'e', 'i', 'o', 'u') of the query word with any vowel individually, it matches a word in the wordlist (case-insensitive), then the query word is returned with the same case as the match in the wordlist.\n\t\n\t\tExample: wordlist = [\"YellOw\"], query = \"yollow\": correct = \"YellOw\"\n\t\tExample: wordlist = [\"YellOw\"], query = \"yeellow\": correct = \"\" (no match)\n\t\tExample: wordlist = [\"YellOw\"], query = \"yllw\": correct = \"\" (no match)\n\t\n\t\n\nIn addition, the spell checker operates under the following precedence rules:\n\n\tWhen the query exactly matches a word in the wordlist (case-sensitive), you should return the same word back.\n\tWhen the query matches a word up to capitlization, you should return the first such match in the wordlist.\n\tWhen the query matches a word up to vowel errors, you should return the first such match in the wordlist.\n\tIf the query has no matches in the wordlist, you should return the empty string.\n\nGiven some queries, return a list of words answer, where answer[i] is the correct word for query = queries[i].\n&nbsp;\nExample 1:\nInput: wordlist = [\"KiTe\",\"kite\",\"hare\",\"Hare\"], queries = [\"kite\",\"Kite\",\"KiTe\",\"Hare\",\"HARE\",\"Hear\",\"hear\",\"keti\",\"keet\",\"keto\"]\nOutput: [\"kite\",\"KiTe\",\"KiTe\",\"Hare\",\"hare\",\"\",\"\",\"KiTe\",\"\",\"KiTe\"]\nExample 2:\nInput: wordlist = [\"yellow\"], queries = [\"YellOw\"]\nOutput: [\"yellow\"]\n&nbsp;\nConstraints:\n\n\t1 <= wordlist.length, queries.length <= 5000\n\t1 <= wordlist[i].length, queries[i].length <= 7\n\twordlist[i] and queries[i] consist only of only English letters.",
        "solutions": [
            {
                "id": 211189,
                "title": "java-c-python-two-hashmap",
                "content": "For each word in the wordlist,\\nget its the lower pattern and devowel pattern,\\n\\nFor each lower pattern, record the first such match to hashmap `cap`.\\nFor each vowel pattern, record the first such match to hashmap `vowel`.\\n\\nFor each query,\\ncheck if it\\'s in the `words` set,\\ncheck if there is a match in `cap`,\\ncheck if there is a match in `vowel`,\\notherwise return `\"\"`.\\n\\n\\n**Java:**\\n```\\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        Set<String> words = new HashSet<>(Arrays.asList(wordlist));\\n        HashMap<String, String> cap = new HashMap<>();\\n        HashMap<String, String> vowel = new HashMap<>();\\n        for (String w : wordlist) {\\n            String lower = w.toLowerCase(), devowel = lower.replaceAll(\"[aeiou]\", \"#\");\\n            cap.putIfAbsent(lower, w);\\n            vowel.putIfAbsent(devowel, w);\\n        }\\n        for (int i = 0; i < queries.length; ++i) {\\n            if (words.contains(queries[i])) continue;\\n            String lower = queries[i].toLowerCase(), devowel = lower.replaceAll(\"[aeiou]\", \"#\");\\n            if (cap.containsKey(lower)) {\\n                queries[i] = cap.get(lower);\\n            } else if (vowel.containsKey(devowel)) {\\n                queries[i] = vowel.get(devowel);\\n            } else {\\n                queries[i] = \"\";\\n            }\\n        }\\n        return queries;\\n    }\\n```\\n\\n**C++:**\\n```\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string> queries) {\\n        unordered_set<string> words(wordlist.begin(), wordlist.end());\\n        unordered_map<string, string> cap, vowel;\\n        for (string w : wordlist) {\\n            string lower = tolow(w), devowel = todev(w);\\n            cap.insert({lower, w});\\n            vowel.insert({devowel, w});\\n        }\\n        for (int i = 0; i < queries.size(); ++i) {\\n            if (words.count(queries[i])) continue;\\n            string lower = tolow(queries[i]), devowel = todev(queries[i]);\\n            if (cap.count(lower)) {\\n                queries[i] = cap[lower];\\n            } else if (vowel.count(devowel)) {\\n                queries[i] = vowel[devowel];\\n            } else {\\n                queries[i] = \"\";\\n            }\\n        }\\n        return queries;\\n    }\\n\\n    string tolow(string w) {\\n        for (auto & c: w)\\n            c = tolower(c);\\n        return w;\\n    }\\n\\n    string todev(string w) {\\n        w = tolow(w);\\n        for (auto & c: w)\\n            if (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')\\n                c = \\'#\\';\\n        return w;\\n    }\\n```\\n\\n**Python:**\\n```\\n    def spellchecker(self, wordlist, queries):\\n        words = {w: w for w in wordlist}\\n        cap = {w.lower(): w for w in wordlist[::-1]}\\n        vowel = {re.sub(\"[aeiou]\", \\'#\\', w.lower()): w for w in wordlist[::-1]}\\n        return [words.get(w) or cap.get(w.lower()) or vowel.get(re.sub(\"[aeiou]\", \\'#\\', w.lower()), \"\") for w in queries]\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        Set<String> words = new HashSet<>(Arrays.asList(wordlist));\\n        HashMap<String, String> cap = new HashMap<>();\\n        HashMap<String, String> vowel = new HashMap<>();\\n        for (String w : wordlist) {\\n            String lower = w.toLowerCase(), devowel = lower.replaceAll(\"[aeiou]\", \"#\");\\n            cap.putIfAbsent(lower, w);\\n            vowel.putIfAbsent(devowel, w);\\n        }\\n        for (int i = 0; i < queries.length; ++i) {\\n            if (words.contains(queries[i])) continue;\\n            String lower = queries[i].toLowerCase(), devowel = lower.replaceAll(\"[aeiou]\", \"#\");\\n            if (cap.containsKey(lower)) {\\n                queries[i] = cap.get(lower);\\n            } else if (vowel.containsKey(devowel)) {\\n                queries[i] = vowel.get(devowel);\\n            } else {\\n                queries[i] = \"\";\\n            }\\n        }\\n        return queries;\\n    }\\n```\n```\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string> queries) {\\n        unordered_set<string> words(wordlist.begin(), wordlist.end());\\n        unordered_map<string, string> cap, vowel;\\n        for (string w : wordlist) {\\n            string lower = tolow(w), devowel = todev(w);\\n            cap.insert({lower, w});\\n            vowel.insert({devowel, w});\\n        }\\n        for (int i = 0; i < queries.size(); ++i) {\\n            if (words.count(queries[i])) continue;\\n            string lower = tolow(queries[i]), devowel = todev(queries[i]);\\n            if (cap.count(lower)) {\\n                queries[i] = cap[lower];\\n            } else if (vowel.count(devowel)) {\\n                queries[i] = vowel[devowel];\\n            } else {\\n                queries[i] = \"\";\\n            }\\n        }\\n        return queries;\\n    }\\n\\n    string tolow(string w) {\\n        for (auto & c: w)\\n            c = tolower(c);\\n        return w;\\n    }\\n\\n    string todev(string w) {\\n        w = tolow(w);\\n        for (auto & c: w)\\n            if (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')\\n                c = \\'#\\';\\n        return w;\\n    }\\n```\n```\\n    def spellchecker(self, wordlist, queries):\\n        words = {w: w for w in wordlist}\\n        cap = {w.lower(): w for w in wordlist[::-1]}\\n        vowel = {re.sub(\"[aeiou]\", \\'#\\', w.lower()): w for w in wordlist[::-1]}\\n        return [words.get(w) or cap.get(w.lower()) or vowel.get(re.sub(\"[aeiou]\", \\'#\\', w.lower()), \"\") for w in queries]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1121864,
                "title": "python-use-3-dictionaries-explained",
                "content": "Not very difficult problem, you just need to be careful and use idea of masks here. For example for word `heLLO` I define mask like this `h*ll*`, that is put all letters to lower case and replace all vowels to `*`. Why it is good idea to do it? Because if two words have the same mask, it means, that one of them is correction of another. We need to check `3` cases:\\n\\n1. If `query` word in original `wordlist`, we just return this word.\\n2. If `query.lower()` word in `d1`: dictionary for words without corrections, which is correspondence between word and its lower case, for example `heLlO: hello`. If we found `query` in this dictionary, by problem statement we need to return the first such match in the wordlist: that is why when we define `d1`, we from the end and rewrite matches if we have more than one.\\n3. Finally, if `mask(query)` in dictionary `d2`, we return `d2[mask(query)]`. Note, that we defined `d2` also from the end.\\n\\n**Complexity**: it is `O(M + N)`, where `M` is total length of words in `wordlist` and `M` is total length of words in `queries`, because we process each word from `wordlist` no more than `3` times and each word from query `1` time.\\n\\n```\\nclass Solution:\\n    def spellchecker(self, wordlist, queries):\\n        def mask(w):\\n            return \"\".join(\\'*\\' if c in \\'aeiou\\' else c for c in w.lower())\\n        \\n        d0 = set(wordlist)\\n        d1 = {w.lower(): w for w in wordlist[::-1]}\\n        d2 = {mask(w): w for w in wordlist[::-1]}\\n        \\n        def solve(query):\\n            if query in d0: return query\\n            if query.lower() in d1: return d1[query.lower()]\\n            if mask(query) in d2: return d2[mask(query)]\\n            return \"\"\\n        \\n        return [solve(q) for q in queries]\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def spellchecker(self, wordlist, queries):\\n        def mask(w):\\n            return \"\".join(\\'*\\' if c in \\'aeiou\\' else c for c in w.lower())\\n        \\n        d0 = set(wordlist)\\n        d1 = {w.lower(): w for w in wordlist[::-1]}\\n        d2 = {mask(w): w for w in wordlist[::-1]}\\n        \\n        def solve(query):\\n            if query in d0: return query\\n            if query.lower() in d1: return d1[query.lower()]\\n            if mask(query) in d2: return d2[mask(query)]\\n            return \"\"\\n        \\n        return [solve(q) for q in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1121880,
                "title": "c-simple-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        vector<string> res;\\n        \\n        init_maps(wordlist, queries);\\n        \\n        for (int i = 0; i < queries.size(); i++) {\\n            string lower = to_lower(queries[i]), no_vowels = remove_vowels(queries[i]);\\n            \\n            if (word_set.find(queries[i]) != word_set.end())\\n                res.push_back(queries[i]);\\n            \\n            else if (tolower_map.find(lower) != tolower_map.end())\\n                res.push_back(tolower_map[lower]);\\n            \\n            else if (no_vowel_map.find(no_vowels) != no_vowel_map.end())\\n                res.push_back(no_vowel_map[no_vowels]);\\n            \\n            else res.push_back(\"\");\\n        }\\n        return res;\\n    }\\n    \\nprivate:\\n    unordered_set<string> word_set;\\n    unordered_map<string, string> tolower_map, no_vowel_map;\\n    \\n    // helper function to initialize maps\\n    void init_maps(vector<string>& wordlist, vector<string>& queries) {\\n        for (auto word : wordlist) {\\n            word_set.insert(word);\\n            tolower_map.insert({to_lower(word), word});\\n            no_vowel_map.insert({remove_vowels(word), word});\\n        }\\n    }\\n    \\n    // helper function to make string lower case\\n    string to_lower(string word) {\\n        for (auto& letter : word)\\n            letter = tolower(letter);\\n        return word;\\n    }\\n    \\n    // helper function to remove vowels from string and insert \\'-\\' instead\\n    string remove_vowels(string word) {\\n        unordered_set<char> vowels = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n        transform(word.begin(), word.end(), word.begin(), ::tolower);\\n        for (auto& letter : word) {\\n            if (vowels.find(letter) != vowels.end()) {\\n                letter = \\'-\\';\\n            }\\n        }\\n        return word;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        vector<string> res;\\n        \\n        init_maps(wordlist, queries);\\n        \\n        for (int i = 0; i < queries.size(); i++) {\\n            string lower = to_lower(queries[i]), no_vowels = remove_vowels(queries[i]);\\n            \\n            if (word_set.find(queries[i]) != word_set.end())\\n                res.push_back(queries[i]);\\n            \\n            else if (tolower_map.find(lower) != tolower_map.end())\\n                res.push_back(tolower_map[lower]);\\n            \\n            else if (no_vowel_map.find(no_vowels) != no_vowel_map.end())\\n                res.push_back(no_vowel_map[no_vowels]);\\n            \\n            else res.push_back(\"\");\\n        }\\n        return res;\\n    }\\n    \\nprivate:\\n    unordered_set<string> word_set;\\n    unordered_map<string, string> tolower_map, no_vowel_map;\\n    \\n    // helper function to initialize maps\\n    void init_maps(vector<string>& wordlist, vector<string>& queries) {\\n        for (auto word : wordlist) {\\n            word_set.insert(word);\\n            tolower_map.insert({to_lower(word), word});\\n            no_vowel_map.insert({remove_vowels(word), word});\\n        }\\n    }\\n    \\n    // helper function to make string lower case\\n    string to_lower(string word) {\\n        for (auto& letter : word)\\n            letter = tolower(letter);\\n        return word;\\n    }\\n    \\n    // helper function to remove vowels from string and insert \\'-\\' instead\\n    string remove_vowels(string word) {\\n        unordered_set<char> vowels = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n        transform(word.begin(), word.end(), word.begin(), ::tolower);\\n        for (auto& letter : word) {\\n            if (vowels.find(letter) != vowels.end()) {\\n                letter = \\'-\\';\\n            }\\n        }\\n        return word;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1121849,
                "title": "vowel-spellchecker-js-python-java-c-easy-mask-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThis problem can be broken up into a couple steps of increasing difficulty. The first step is to check whether or not the words in the query list (**Q**) exists in the word list (**W**). For that, we can use the simplest form of value-lookup data structure, which is a **Set**.\\n\\nNext, we need to check if each query has a case-insensitive match in **W**. For case-insensitive matching, the easiest thing to do is to **lowercase** (or **uppercase**) both terms before comparing. In this case, since we want to match one term, but return another, we should use a **Map** data structure, where the **key** is the lowercased term and the **value** is the matching **word**.\\n\\nBut here we encounter an issue, as it is possible for two words to have the same lowercase form. Per the rules we want to favor the one that appears first in **W**, so we can either iterate through **W** forwards and repeatedly check to make sure we\\'re not overwriting an existing entry, or we can simply iterate through **W** backwards and just automatically overwrite entries. This will force the first occurance to be the one that \"sticks\".\\n\\nFor the third check, we need to match the **word** except for the vowels. Whenever you need to selectively match strings by only a portion, the easiest way to do it is with a **mask**. In this case, we can use **regex** to replace all vowel occurrances with a **character mask**, such as **\"#\"**. For example, we can check if **\"tail\"** and **\"tool\"** would match by applying the character masks to both terms and seeing that **\"t##l\" == \"t##l\"**.\\n\\nThis calls for another map structure. We could technically reuse the earlier one, as there will be no overlaps, but navigating two separate, smaller maps is generally more efficient than one large one. Since we\\'ll also want to iterate backwards through **W** for this map, we migtht as well do it at the same time as the other one.\\n\\nThen we can just iterate through **Q** and check for matches in the correct order. As is generally the case with query lists, we can replace the queries in **Q** with their result in order to save on **space complexity**.\\n\\nThen, when we\\'re done, we just **return Q**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nJavascript can use **logical OR** chaining to shorten the assignment of the proper result in **Q**.\\n\\nRegex is much slower in Java and C++, so we can use a helper function to do the same thing for us.\\n\\nC++ will also need a helper to lowercase the words.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **108ms / 49.7MB** (beats 100% / 97%).\\n```javascript\\nconst regex = /[aeiou]/g\\nvar spellchecker = function(W, Q) {\\n    let orig = new Set(W), lower = new Map(), mask = new Map()\\n    for (let i = W.length - 1; ~i; i--) {\\n        let word = W[i], wlow = word.toLowerCase()\\n        lower.set(wlow, word)\\n        mask.set(wlow.replace(regex, \"*\"), word)\\n    }\\n    for (let i in Q) {\\n        let query = Q[i], qlow = query.toLowerCase(),\\n            qmask = qlow.replace(regex, \"*\")\\n        if (orig.has(query)) continue\\n        else Q[i] = lower.get(qlow) || mask.get(qmask) || \"\"\\n    }\\n    return Q\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **160ms / 16.6MB** (beats 98% / 85%).\\n```python\\nclass Solution:\\n    def spellchecker(self, W: List[str], Q: List[str]) -> List[str]:\\n        orig, lcase, mask = set(W), defaultdict(), defaultdict()\\n        regex = r\\'[aeiou]\\'\\n        for i in range(len(W)-1,-1,-1):\\n            word = W[i]\\n            wlow = word.lower()\\n            lcase[wlow] = word\\n            mask[re.sub(regex, \\'*\\', wlow)] = word\\n        for i in range(len(Q)):\\n            query = Q[i]\\n            qlow = query.lower()\\n            qmask = re.sub(regex, \\'*\\', qlow)\\n            if query in orig: continue\\n            elif qlow in lcase: Q[i] = lcase[qlow]\\n            elif qmask in mask: Q[i] = mask[qmask]\\n            else: Q[i] = \"\"\\n        return Q\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **16ms / 41.6MB** (beats 97% / 99%).\\n```java\\nclass Solution {\\n    public String[] spellchecker(String[] W, String[] Q) {\\n        Set<String> orig = new HashSet<>(Arrays.asList(W));\\n        Map<String, String> lower = new HashMap<>(), mask = new HashMap<>();\\n        for (int i = W.length - 1; i >= 0; i--) {\\n            String word = W[i], wlow = word.toLowerCase();\\n            lower.put(wlow, word);\\n            mask.put(vmask(wlow), word);\\n        }\\n        for (int i = 0; i < Q.length; i++) {\\n            String query = Q[i], qlow = query.toLowerCase(),\\n                qmask = vmask(qlow);\\n            if (orig.contains(query)) continue;\\n            else if (lower.containsKey(qlow)) Q[i] = lower.get(qlow);\\n            else if (mask.containsKey(qmask)) Q[i] = mask.get(qmask);\\n            else Q[i] = \"\";\\n        }\\n        return Q;\\n    }\\n    public String vmask(String str) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < str.length(); i++) {\\n            char c = str.charAt(i);\\n            if (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\') c = \\'*\\';\\n            sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **64ms / 32.7MB** (beats 85% / 87%).\\n```c++\\nclass Solution {\\npublic:\\n    vector<string> spellchecker(vector<string>& W, vector<string>& Q) {\\n        set<string> orig (W.begin(), W.end());\\n        unordered_map<string, string> lower, mask;\\n        for (int i = W.size() - 1; ~i; i--) {\\n            string word = W[i], wlow = lcase(word);\\n            lower[wlow] = word, mask[vmask(wlow)] = word;\\n        }\\n        for (string &query : Q) {\\n            string qlow = lcase(query), qmask = vmask(qlow);\\n            if (orig.count(query)) continue;\\n            else if (lower.count(qlow)) query = lower[qlow];\\n            else if (mask.count(qmask)) query = mask[qmask];\\n            else query = \"\";\\n        }\\n        return Q;\\n    }\\n    static string vmask(string str) {\\n        for (char &c : str)\\n            if (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')\\n                c = \\'*\\';\\n        return str;\\n    }\\n    static string lcase(string str) {\\n        for (char &c : str) c = tolower(c);\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nconst regex = /[aeiou]/g\\nvar spellchecker = function(W, Q) {\\n    let orig = new Set(W), lower = new Map(), mask = new Map()\\n    for (let i = W.length - 1; ~i; i--) {\\n        let word = W[i], wlow = word.toLowerCase()\\n        lower.set(wlow, word)\\n        mask.set(wlow.replace(regex, \"*\"), word)\\n    }\\n    for (let i in Q) {\\n        let query = Q[i], qlow = query.toLowerCase(),\\n            qmask = qlow.replace(regex, \"*\")\\n        if (orig.has(query)) continue\\n        else Q[i] = lower.get(qlow) || mask.get(qmask) || \"\"\\n    }\\n    return Q\\n};\\n```\n```python\\nclass Solution:\\n    def spellchecker(self, W: List[str], Q: List[str]) -> List[str]:\\n        orig, lcase, mask = set(W), defaultdict(), defaultdict()\\n        regex = r\\'[aeiou]\\'\\n        for i in range(len(W)-1,-1,-1):\\n            word = W[i]\\n            wlow = word.lower()\\n            lcase[wlow] = word\\n            mask[re.sub(regex, \\'*\\', wlow)] = word\\n        for i in range(len(Q)):\\n            query = Q[i]\\n            qlow = query.lower()\\n            qmask = re.sub(regex, \\'*\\', qlow)\\n            if query in orig: continue\\n            elif qlow in lcase: Q[i] = lcase[qlow]\\n            elif qmask in mask: Q[i] = mask[qmask]\\n            else: Q[i] = \"\"\\n        return Q\\n```\n```java\\nclass Solution {\\n    public String[] spellchecker(String[] W, String[] Q) {\\n        Set<String> orig = new HashSet<>(Arrays.asList(W));\\n        Map<String, String> lower = new HashMap<>(), mask = new HashMap<>();\\n        for (int i = W.length - 1; i >= 0; i--) {\\n            String word = W[i], wlow = word.toLowerCase();\\n            lower.put(wlow, word);\\n            mask.put(vmask(wlow), word);\\n        }\\n        for (int i = 0; i < Q.length; i++) {\\n            String query = Q[i], qlow = query.toLowerCase(),\\n                qmask = vmask(qlow);\\n            if (orig.contains(query)) continue;\\n            else if (lower.containsKey(qlow)) Q[i] = lower.get(qlow);\\n            else if (mask.containsKey(qmask)) Q[i] = mask.get(qmask);\\n            else Q[i] = \"\";\\n        }\\n        return Q;\\n    }\\n    public String vmask(String str) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < str.length(); i++) {\\n            char c = str.charAt(i);\\n            if (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\') c = \\'*\\';\\n            sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<string> spellchecker(vector<string>& W, vector<string>& Q) {\\n        set<string> orig (W.begin(), W.end());\\n        unordered_map<string, string> lower, mask;\\n        for (int i = W.size() - 1; ~i; i--) {\\n            string word = W[i], wlow = lcase(word);\\n            lower[wlow] = word, mask[vmask(wlow)] = word;\\n        }\\n        for (string &query : Q) {\\n            string qlow = lcase(query), qmask = vmask(qlow);\\n            if (orig.count(query)) continue;\\n            else if (lower.count(qlow)) query = lower[qlow];\\n            else if (mask.count(qmask)) query = mask[qmask];\\n            else query = \"\";\\n        }\\n        return Q;\\n    }\\n    static string vmask(string str) {\\n        for (char &c : str)\\n            if (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')\\n                c = \\'*\\';\\n        return str;\\n    }\\n    static string lcase(string str) {\\n        for (char &c : str) c = tolower(c);\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122188,
                "title": "vowel-spellchecker-short-easy-w-explanation-beats-100",
                "content": "***Solution - I (Naive Approach - Rejected)***\\n\\nWe can try to directly implement the solution using brute force as follows - \\n\\n```\\n// Checks for case-insensitive match between two strings\\nbool caseInsensitiveEqual(string &a, string &b){\\n\\treturn equal(begin(a), end(a), begin(b), end(b), [](char &a, char &b){\\n\\t   return tolower(a) == tolower(b); \\n\\t});\\n}\\n// Checks if given character is vowel\\nbool isVowel(char &c){\\n\\tc = tolower(c);\\n\\treturn c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n}\\n// Checks if both string can be made same after vowels replacement\\nbool vowelFreqCheck(string a, string b){\\n\\tif(size(a) != size(b)) return false;\\n\\tint n = size(a);\\n\\tfor(int i = 0; i < n; i++)            \\n\\t\\tif((!isVowel(a[i]) || !isVowel(b[i])) && tolower(a[i]) != tolower(b[i])) return false;\\n\\treturn true;\\n}\\nvector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n\\tint n = size(queries);\\n\\tvector<string> answer(n, \"\");\\n\\tfor(int i = 0; i < n; i++){\\n\\t\\tbool matched = false;\\n\\t\\t// Check if exact match is found\\n\\t\\tfor(string& word : wordlist)\\n\\t\\t\\tif(word == queries[i]){ queries[i] = word; matched = true; break; }\\n\\t\\tif(matched) continue; // move on to next query if match found\\n\\t\\t// Check if case-insensitive match is found\\n\\t\\tfor(string& word : wordlist)\\n\\t\\t\\tif(caseInsensitiveEqual(word, queries[i])){ queries[i] = word; matched = true; break; }\\n\\t\\tif(matched) continue; // move on to next query if match found\\n\\t\\t// Check if after vowel-replacement, the strings match\\n\\t\\tfor(string& word : wordlist)\\n\\t\\t\\tif(vowelFreqCheck(word, queries[i])){ queries[i] = word; matched = true; break; }\\n\\t\\tif(!matched) queries[i] = \"\"; // if no match found in any case return empty string\\n\\t}\\n\\treturn queries;\\n}\\n```\\n\\n**Time Complexity :** **`O(N*Q)`**, where `N` is the sum of lengths of words in `wordlist` and `Q` is the sum of lengths of queries.\\n**Space Complexity :** **`O(1)`**, since we are using the queries array itself. If queries array must not be modified, we would need a space complexity of `O(N)`\\n\\nThis approach is very direct implementation without any optimization and as a results times out on larger test cases.\\n\\n------------\\n------------\\n\\n***Solution - II (Time-Optimised using Hashmaps)***\\n\\nWe can optimise the solution by trading space for time. We don\\'t need to loop through the whole wordlist for every query if we use a hashmaps. The hashmaps used are - \\n1. **`lowered`** : It maps word from wordlist converted to lowercase to the original word.\\n2. **`vowelMasked`** : It maps lowered and masked vowel word from wordlist to the original word. Masking will help finding words that can be formed from one another by replacing a vowel with another vowel.\\n3. **`original_words`**: Its a hashset which stores all the original words of wordlist. Since the word is mapped to itself, we can use hashset instead and save space.\\n\\nUsing these maps, we have eliminated the need the need to loop **`wordlist`** over and over. We can now just check which of the condition the query satisfies in the precedence given in the problem.\\n\\n\\n```\\nstring toLowercase(string &s){\\n\\tfor(char& c : s) c = tolower(c);\\n\\treturn s;\\n}\\nbool isVowel(char &c){\\n\\treturn c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n}\\n// masking will help check if a word satisfies vowel-error condition\\nstring maskVowel(string &s){\\n\\tfor(char& c : s) if(isVowel(c)) c = \\'#\\';\\n\\treturn s;\\n}\\nvector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n\\tunordered_set original_words(begin(wordlist), end(wordlist));\\n\\tunordered_map<string, string> lowered, vowelMasked;\\n\\tstring tmp;\\n\\t// we are reverse-iterating since we need to find the first matching word\\n\\t// so, we need to update maps to hold the first-most word satisfying a condition\\n\\tfor(auto word = rbegin(wordlist); word != rend(wordlist); word++) \\n\\t\\ttmp = *word, lowered[toLowercase(tmp)] = *word, vowelMasked[maskVowel(tmp)] = *word;\\n\\tfor(string& q : queries){\\n\\t\\t// if exact word is found, continue since we already have it stored in queries[i] (Note : we are returing queries itself)\\n\\t\\tif(original_words.count(q)) continue;\\n\\t\\t// if query converted to lowercase matches with lower-cased word, return the corresponding mapped word from lowered hashmap\\n\\t\\telse if(lowered.count(toLowercase(q))) q = lowered[q];\\n\\t\\t// if query converted to lowercase & vowels masked matches with lower-cased vowel-masked word, return the mapped word from vowelMasked hashmap\\n\\t\\telse if(vowelMasked.count(maskVowel(q))) q = vowelMasked[q];\\n\\t\\telse q = \"\"; // if no match found, return empty string\\n\\t}\\n\\treturn queries;\\n}\\n```\\n\\n**Time Complexity :** **`O(N + Q)`**, where `N` is the sum of lengths of words in `wordlist` and `Q` is the sum of lengths of queries.\\n**Space Complexity :** **`O(N)`**, for storing in the hashmaps.\\n\\n![image](https://assets.leetcode.com/users/images/708c9d3e-6c0d-4a25-93a7-82bf463b9bd6_1616422339.8202226.png)\\n\\n\\n------------\\n------------\\n\\n***Solution - III (Further Space-Optimisation using custom hash)***\\n\\nWe don\\'t need to store the entire strings in the hashmaps as we did above. We can convert the string to a hash value and store it as a integer. \\n\\nIn this problem, since the max length of word/query is `7`, we won\\'t see much benefits (in the best case, we are improving space for keys from **`7 bytes`** to **`4 bytes`** for int). But if the words are of larger size, it would be an much optimised approach.\\n\\n```\\nstring toLowercase(string &s){\\n\\tfor(char& c : s) c = tolower(c);\\n\\treturn s;\\n}\\nbool isVowel(char c){\\n\\treturn c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n}\\nstring maskVowel(string &s){\\n\\tfor(char& c : s) if(isVowel(c)) c = \\'#\\';\\n\\treturn s;\\n}\\nint hash(string s){\\n\\tlong h = 0, mod = 1e9 + 7;\\n\\tfor(char& c : s) h = (h * 101 + c) % mod;\\n\\treturn h;\\n}\\nvector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n\\tunordered_set<int> orig;\\n\\tunordered_map<int, string> lowered, vowelMasked;\\n\\tstring tmp;\\n\\tfor(vector<string>::reverse_iterator word = rbegin(wordlist); word != rend(wordlist); word++) \\n\\t\\ttmp = *word,orig.insert(hash(tmp)), lowered[hash(toLowercase(tmp))] = *word, vowelMasked[hash(maskVowel(tmp))] = *word;\\n\\tint h;\\n\\tfor(string& q : queries)\\n\\t\\tif(orig.count(hash(q))) continue;\\n\\t\\telse if(lowered.count(h = hash(toLowercase(q)))) q = lowered[h];\\n\\t\\telse if(vowelMasked.count(h = hash(maskVowel(q)))) q = vowelMasked[h];\\n\\t\\telse q = \"\";\\n\\treturn queries;\\n}\\n```\\n\\n**Time Complexity :** **`O(N + Q)`**, where `N` is the sum of lengths of words in `wordlist` and `Q` is the sum of lengths of queries.\\n**Space Complexity :** **`O(N)`**, for storing in the hashmaps. Although, the space complexity is still the same, we have eliminated a good chunk of constant factor without any addition to time complexity.\\n\\nNote that we would need to choose a good hash function. Luckily, the one I chose didn\\'t give any collisions. For more robust solution, you would need to handle collision cases also.\\n\\n![image](https://assets.leetcode.com/users/images/50e5afb2-f245-477c-8ede-18904754e93b_1616422748.4772894.png)\\n\\n\\n-----------\\n-----------",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// Checks for case-insensitive match between two strings\\nbool caseInsensitiveEqual(string &a, string &b){\\n\\treturn equal(begin(a), end(a), begin(b), end(b), [](char &a, char &b){\\n\\t   return tolower(a) == tolower(b); \\n\\t});\\n}\\n// Checks if given character is vowel\\nbool isVowel(char &c){\\n\\tc = tolower(c);\\n\\treturn c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n}\\n// Checks if both string can be made same after vowels replacement\\nbool vowelFreqCheck(string a, string b){\\n\\tif(size(a) != size(b)) return false;\\n\\tint n = size(a);\\n\\tfor(int i = 0; i < n; i++)            \\n\\t\\tif((!isVowel(a[i]) || !isVowel(b[i])) && tolower(a[i]) != tolower(b[i])) return false;\\n\\treturn true;\\n}\\nvector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n\\tint n = size(queries);\\n\\tvector<string> answer(n, \"\");\\n\\tfor(int i = 0; i < n; i++){\\n\\t\\tbool matched = false;\\n\\t\\t// Check if exact match is found\\n\\t\\tfor(string& word : wordlist)\\n\\t\\t\\tif(word == queries[i]){ queries[i] = word; matched = true; break; }\\n\\t\\tif(matched) continue; // move on to next query if match found\\n\\t\\t// Check if case-insensitive match is found\\n\\t\\tfor(string& word : wordlist)\\n\\t\\t\\tif(caseInsensitiveEqual(word, queries[i])){ queries[i] = word; matched = true; break; }\\n\\t\\tif(matched) continue; // move on to next query if match found\\n\\t\\t// Check if after vowel-replacement, the strings match\\n\\t\\tfor(string& word : wordlist)\\n\\t\\t\\tif(vowelFreqCheck(word, queries[i])){ queries[i] = word; matched = true; break; }\\n\\t\\tif(!matched) queries[i] = \"\"; // if no match found in any case return empty string\\n\\t}\\n\\treturn queries;\\n}\\n```\n```\\nstring toLowercase(string &s){\\n\\tfor(char& c : s) c = tolower(c);\\n\\treturn s;\\n}\\nbool isVowel(char &c){\\n\\treturn c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n}\\n// masking will help check if a word satisfies vowel-error condition\\nstring maskVowel(string &s){\\n\\tfor(char& c : s) if(isVowel(c)) c = \\'#\\';\\n\\treturn s;\\n}\\nvector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n\\tunordered_set original_words(begin(wordlist), end(wordlist));\\n\\tunordered_map<string, string> lowered, vowelMasked;\\n\\tstring tmp;\\n\\t// we are reverse-iterating since we need to find the first matching word\\n\\t// so, we need to update maps to hold the first-most word satisfying a condition\\n\\tfor(auto word = rbegin(wordlist); word != rend(wordlist); word++) \\n\\t\\ttmp = *word, lowered[toLowercase(tmp)] = *word, vowelMasked[maskVowel(tmp)] = *word;\\n\\tfor(string& q : queries){\\n\\t\\t// if exact word is found, continue since we already have it stored in queries[i] (Note : we are returing queries itself)\\n\\t\\tif(original_words.count(q)) continue;\\n\\t\\t// if query converted to lowercase matches with lower-cased word, return the corresponding mapped word from lowered hashmap\\n\\t\\telse if(lowered.count(toLowercase(q))) q = lowered[q];\\n\\t\\t// if query converted to lowercase & vowels masked matches with lower-cased vowel-masked word, return the mapped word from vowelMasked hashmap\\n\\t\\telse if(vowelMasked.count(maskVowel(q))) q = vowelMasked[q];\\n\\t\\telse q = \"\"; // if no match found, return empty string\\n\\t}\\n\\treturn queries;\\n}\\n```\n```\\nstring toLowercase(string &s){\\n\\tfor(char& c : s) c = tolower(c);\\n\\treturn s;\\n}\\nbool isVowel(char c){\\n\\treturn c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n}\\nstring maskVowel(string &s){\\n\\tfor(char& c : s) if(isVowel(c)) c = \\'#\\';\\n\\treturn s;\\n}\\nint hash(string s){\\n\\tlong h = 0, mod = 1e9 + 7;\\n\\tfor(char& c : s) h = (h * 101 + c) % mod;\\n\\treturn h;\\n}\\nvector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n\\tunordered_set<int> orig;\\n\\tunordered_map<int, string> lowered, vowelMasked;\\n\\tstring tmp;\\n\\tfor(vector<string>::reverse_iterator word = rbegin(wordlist); word != rend(wordlist); word++) \\n\\t\\ttmp = *word,orig.insert(hash(tmp)), lowered[hash(toLowercase(tmp))] = *word, vowelMasked[hash(maskVowel(tmp))] = *word;\\n\\tint h;\\n\\tfor(string& q : queries)\\n\\t\\tif(orig.count(hash(q))) continue;\\n\\t\\telse if(lowered.count(h = hash(toLowercase(q)))) q = lowered[h];\\n\\t\\telse if(vowelMasked.count(h = hash(maskVowel(q)))) q = vowelMasked[h];\\n\\t\\telse q = \"\";\\n\\treturn queries;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1121848,
                "title": "js-python-java-c-easy-mask-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThis problem can be broken up into a couple steps of increasing difficulty. The first step is to check whether or not the words in the query list (**Q**) exists in the word list (**W**). For that, we can use the simplest form of value-lookup data structure, which is a **Set**.\\n\\nNext, we need to check if each query has a case-insensitive match in **W**. For case-insensitive matching, the easiest thing to do is to **lowercase** (or **uppercase**) both terms before comparing. In this case, since we want to match one term, but return another, we should use a **Map** data structure, where the **key** is the lowercased term and the **value** is the matching **word**.\\n\\nBut here we encounter an issue, as it is possible for two words to have the same lowercase form. Per the rules we want to favor the one that appears first in **W**, so we can either iterate through **W** forwards and repeatedly check to make sure we\\'re not overwriting an existing entry, or we can simply iterate through **W** backwards and just automatically overwrite entries. This will force the first occurance to be the one that \"sticks\".\\n\\nFor the third check, we need to match the **word** except for the vowels. Whenever you need to selectively match strings by only a portion, the easiest way to do it is with a **mask**. In this case, we can use **regex** to replace all vowel occurrances with a **character mask**, such as **\"#\"**. For example, we can check if **\"tail\"** and **\"tool\"** would match by applying the character masks to both terms and seeing that **\"t##l\" == \"t##l\"**.\\n\\nThis calls for another map structure. We could technically reuse the earlier one, as there will be no overlaps, but navigating two separate, smaller maps is generally more efficient than one large one. Since we\\'ll also want to iterate backwards through **W** for this map, we migtht as well do it at the same time as the other one.\\n\\nThen we can just iterate through **Q** and check for matches in the correct order. As is generally the case with query lists, we can replace the queries in **Q** with their result in order to save on **space complexity**.\\n\\nThen, when we\\'re done, we just **return Q**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nJavascript can use **logical OR** chaining to shorten the assignment of the proper result in **Q**.\\n\\nRegex is much slower in Java and C++, so we can use a helper function to do the same thing for us.\\n\\nC++ will also need a helper to lowercase the words.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **108ms / 49.7MB** (beats 100% / 97%).\\n```javascript\\nconst regex = /[aeiou]/g\\nvar spellchecker = function(W, Q) {\\n    let orig = new Set(W), lower = new Map(), mask = new Map()\\n    for (let i = W.length - 1; ~i; i--) {\\n        let word = W[i], wlow = word.toLowerCase()\\n        lower.set(wlow, word)\\n        mask.set(wlow.replace(regex, \"*\"), word)\\n    }\\n    for (let i in Q) {\\n        let query = Q[i], qlow = query.toLowerCase(),\\n            qmask = qlow.replace(regex, \"*\")\\n        if (orig.has(query)) continue\\n        else Q[i] = lower.get(qlow) || mask.get(qmask) || \"\"\\n    }\\n    return Q\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **160ms / 16.6MB** (beats 98% / 85%).\\n```python\\nclass Solution:\\n    def spellchecker(self, W: List[str], Q: List[str]) -> List[str]:\\n        orig, lcase, mask = set(W), defaultdict(), defaultdict()\\n        regex = r\\'[aeiou]\\'\\n        for i in range(len(W)-1,-1,-1):\\n            word = W[i]\\n            wlow = word.lower()\\n            lcase[wlow] = word\\n            mask[re.sub(regex, \\'*\\', wlow)] = word\\n        for i in range(len(Q)):\\n            query = Q[i]\\n            qlow = query.lower()\\n            qmask = re.sub(regex, \\'*\\', qlow)\\n            if query in orig: continue\\n            elif qlow in lcase: Q[i] = lcase[qlow]\\n            elif qmask in mask: Q[i] = mask[qmask]\\n            else: Q[i] = \"\"\\n        return Q\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **16ms / 41.6MB** (beats 97% / 99%).\\n```java\\nclass Solution {\\n    public String[] spellchecker(String[] W, String[] Q) {\\n        Set<String> orig = new HashSet<>(Arrays.asList(W));\\n        Map<String, String> lower = new HashMap<>(), mask = new HashMap<>();\\n        for (int i = W.length - 1; i >= 0; i--) {\\n            String word = W[i], wlow = word.toLowerCase();\\n            lower.put(wlow, word);\\n            mask.put(vmask(wlow), word);\\n        }\\n        for (int i = 0; i < Q.length; i++) {\\n            String query = Q[i], qlow = query.toLowerCase(),\\n                qmask = vmask(qlow);\\n            if (orig.contains(query)) continue;\\n            else if (lower.containsKey(qlow)) Q[i] = lower.get(qlow);\\n            else if (mask.containsKey(qmask)) Q[i] = mask.get(qmask);\\n            else Q[i] = \"\";\\n        }\\n        return Q;\\n    }\\n    public String vmask(String str) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < str.length(); i++) {\\n            char c = str.charAt(i);\\n            if (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\') c = \\'*\\';\\n            sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **64ms / 32.7MB** (beats 85% / 87%).\\n```c++\\nclass Solution {\\npublic:\\n    vector<string> spellchecker(vector<string>& W, vector<string>& Q) {\\n        set<string> orig (W.begin(), W.end());\\n        unordered_map<string, string> lower, mask;\\n        for (int i = W.size() - 1; ~i; i--) {\\n            string word = W[i], wlow = lcase(word);\\n            lower[wlow] = word, mask[vmask(wlow)] = word;\\n        }\\n        for (string &query : Q) {\\n            string qlow = lcase(query), qmask = vmask(qlow);\\n            if (orig.count(query)) continue;\\n            else if (lower.count(qlow)) query = lower[qlow];\\n            else if (mask.count(qmask)) query = mask[qmask];\\n            else query = \"\";\\n        }\\n        return Q;\\n    }\\n    static string vmask(string str) {\\n        for (char &c : str)\\n            if (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')\\n                c = \\'*\\';\\n        return str;\\n    }\\n    static string lcase(string str) {\\n        for (char &c : str) c = tolower(c);\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nconst regex = /[aeiou]/g\\nvar spellchecker = function(W, Q) {\\n    let orig = new Set(W), lower = new Map(), mask = new Map()\\n    for (let i = W.length - 1; ~i; i--) {\\n        let word = W[i], wlow = word.toLowerCase()\\n        lower.set(wlow, word)\\n        mask.set(wlow.replace(regex, \"*\"), word)\\n    }\\n    for (let i in Q) {\\n        let query = Q[i], qlow = query.toLowerCase(),\\n            qmask = qlow.replace(regex, \"*\")\\n        if (orig.has(query)) continue\\n        else Q[i] = lower.get(qlow) || mask.get(qmask) || \"\"\\n    }\\n    return Q\\n};\\n```\n```python\\nclass Solution:\\n    def spellchecker(self, W: List[str], Q: List[str]) -> List[str]:\\n        orig, lcase, mask = set(W), defaultdict(), defaultdict()\\n        regex = r\\'[aeiou]\\'\\n        for i in range(len(W)-1,-1,-1):\\n            word = W[i]\\n            wlow = word.lower()\\n            lcase[wlow] = word\\n            mask[re.sub(regex, \\'*\\', wlow)] = word\\n        for i in range(len(Q)):\\n            query = Q[i]\\n            qlow = query.lower()\\n            qmask = re.sub(regex, \\'*\\', qlow)\\n            if query in orig: continue\\n            elif qlow in lcase: Q[i] = lcase[qlow]\\n            elif qmask in mask: Q[i] = mask[qmask]\\n            else: Q[i] = \"\"\\n        return Q\\n```\n```java\\nclass Solution {\\n    public String[] spellchecker(String[] W, String[] Q) {\\n        Set<String> orig = new HashSet<>(Arrays.asList(W));\\n        Map<String, String> lower = new HashMap<>(), mask = new HashMap<>();\\n        for (int i = W.length - 1; i >= 0; i--) {\\n            String word = W[i], wlow = word.toLowerCase();\\n            lower.put(wlow, word);\\n            mask.put(vmask(wlow), word);\\n        }\\n        for (int i = 0; i < Q.length; i++) {\\n            String query = Q[i], qlow = query.toLowerCase(),\\n                qmask = vmask(qlow);\\n            if (orig.contains(query)) continue;\\n            else if (lower.containsKey(qlow)) Q[i] = lower.get(qlow);\\n            else if (mask.containsKey(qmask)) Q[i] = mask.get(qmask);\\n            else Q[i] = \"\";\\n        }\\n        return Q;\\n    }\\n    public String vmask(String str) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < str.length(); i++) {\\n            char c = str.charAt(i);\\n            if (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\') c = \\'*\\';\\n            sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<string> spellchecker(vector<string>& W, vector<string>& Q) {\\n        set<string> orig (W.begin(), W.end());\\n        unordered_map<string, string> lower, mask;\\n        for (int i = W.size() - 1; ~i; i--) {\\n            string word = W[i], wlow = lcase(word);\\n            lower[wlow] = word, mask[vmask(wlow)] = word;\\n        }\\n        for (string &query : Q) {\\n            string qlow = lcase(query), qmask = vmask(qlow);\\n            if (orig.count(query)) continue;\\n            else if (lower.count(qlow)) query = lower[qlow];\\n            else if (mask.count(qmask)) query = mask[qmask];\\n            else query = \"\";\\n        }\\n        return Q;\\n    }\\n    static string vmask(string str) {\\n        for (char &c : str)\\n            if (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')\\n                c = \\'*\\';\\n        return str;\\n    }\\n    static string lcase(string str) {\\n        for (char &c : str) c = tolower(c);\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122193,
                "title": "short-easy-w-explanation-hash-map-solutions-beats-100",
                "content": "***Solution - I (Naive Approach - Rejected)***\\n\\nWe can try to directly implement the solution using brute force as follows - \\n\\n```\\n// Checks for case-insensitive match between two strings\\nbool caseInsensitiveEqual(string &a, string &b){\\n\\treturn equal(begin(a), end(a), begin(b), end(b), [](char &a, char &b){\\n\\t   return tolower(a) == tolower(b); \\n\\t});\\n}\\n// Checks if given character is vowel\\nbool isVowel(char &c){\\n\\tc = tolower(c);\\n\\treturn c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n}\\n// Checks if both string can be made same after vowels replacement\\nbool vowelFreqCheck(string a, string b){\\n\\tif(size(a) != size(b)) return false;\\n\\tint n = size(a);\\n\\tfor(int i = 0; i < n; i++)            \\n\\t\\tif((!isVowel(a[i]) || !isVowel(b[i])) && tolower(a[i]) != tolower(b[i])) return false;\\n\\treturn true;\\n}\\nvector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n\\tint n = size(queries);\\n\\tvector<string> answer(n, \"\");\\n\\tfor(int i = 0; i < n; i++){\\n\\t\\tbool matched = false;\\n\\t\\t// Check if exact match is found\\n\\t\\tfor(string& word : wordlist)\\n\\t\\t\\tif(word == queries[i]){ queries[i] = word; matched = true; break; }\\n\\t\\tif(matched) continue; // move on to next query if match found\\n\\t\\t// Check if case-insensitive match is found\\n\\t\\tfor(string& word : wordlist)\\n\\t\\t\\tif(caseInsensitiveEqual(word, queries[i])){ queries[i] = word; matched = true; break; }\\n\\t\\tif(matched) continue; // move on to next query if match found\\n\\t\\t// Check if after vowel-replacement, the strings match\\n\\t\\tfor(string& word : wordlist)\\n\\t\\t\\tif(vowelFreqCheck(word, queries[i])){ queries[i] = word; matched = true; break; }\\n\\t\\tif(!matched) queries[i] = \"\"; // if no match found in any case return empty string\\n\\t}\\n\\treturn queries;\\n}\\n```\\n\\n**Time Complexity :** **`O(N*Q)`**, where `N` is the sum of lengths of words in `wordlist` and `Q` is the sum of lengths of queries.\\n**Space Complexity :** **`O(1)`**, since we are using the queries array itself. If queries array must not be modified, we would need a space complexity of `O(N)`\\n\\nThis approach is very direct implementation without any optimization and as a results times out on larger test cases.\\n\\n------------\\n------------\\n\\n***Solution - II (Time-Optimised using Hashmaps)***\\n\\nWe can optimise the solution by trading space for time. We don\\'t need to loop through the whole wordlist for every query if we use a hashmaps. The hashmaps used are - \\n1. **`lowered`** : It maps word from wordlist converted to lowercase to the original word.\\n2. **`vowelMasked`** : It maps lowered and masked vowel word from wordlist to the original word. Masking will help finding words that can be formed from one another by replacing a vowel with another vowel.\\n3. **`original_words`**: Its a hashset which stores all the original words of wordlist. Since the word is mapped to itself, we can use hashset instead and save space.\\n\\nUsing these maps, we have eliminated the need the need to loop **`wordlist`** over and over. We can now just check which of the condition the query satisfies in the precedence given in the problem.\\n\\n\\n```\\nstring toLowercase(string &s){\\n\\tfor(char& c : s) c = tolower(c);\\n\\treturn s;\\n}\\nbool isVowel(char &c){\\n\\treturn c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n}\\n// masking will help check if a word satisfies vowel-error condition\\nstring maskVowel(string &s){\\n\\tfor(char& c : s) if(isVowel(c)) c = \\'#\\';\\n\\treturn s;\\n}\\nvector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n\\tunordered_set original_words(begin(wordlist), end(wordlist));\\n\\tunordered_map<string, string> lowered, vowelMasked;\\n\\tstring tmp;\\n\\t// we are reverse-iterating since we need to find the first matching word\\n\\t// so, we need to update maps to hold the first-most word satisfying a condition\\n\\tfor(auto word = rbegin(wordlist); word != rend(wordlist); word++) \\n\\t\\ttmp = *word, lowered[toLowercase(tmp)] = *word, vowelMasked[maskVowel(tmp)] = *word;\\n\\tfor(string& q : queries){\\n\\t\\t// if exact word is found, continue since we already have it stored in queries[i] (Note : we are returing queries itself)\\n\\t\\tif(original_words.count(q)) continue;\\n\\t\\t// if query converted to lowercase matches with lower-cased word, return the corresponding mapped word from lowered hashmap\\n\\t\\telse if(lowered.count(toLowercase(q))) q = lowered[q];\\n\\t\\t// if query converted to lowercase & vowels masked matches with lower-cased vowel-masked word, return the mapped word from vowelMasked hashmap\\n\\t\\telse if(vowelMasked.count(maskVowel(q))) q = vowelMasked[q];\\n\\t\\telse q = \"\"; // if no match found, return empty string\\n\\t}\\n\\treturn queries;\\n}\\n```\\n\\n**Time Complexity :** **`O(N + Q)`**, where `N` is the sum of lengths of words in `wordlist` and `Q` is the sum of lengths of queries.\\n**Space Complexity :** **`O(N)`**, for storing in the hashmaps.\\n\\n![image](https://assets.leetcode.com/users/images/708c9d3e-6c0d-4a25-93a7-82bf463b9bd6_1616422339.8202226.png)\\n\\n\\n------------\\n------------\\n\\n***Solution - III (Further Space-Optimisation using custom hash)***\\n\\nWe don\\'t need to store the entire strings in the hashmaps as we did above. We can convert the string to a hash value and store it as a integer. \\n\\nIn this problem, since the max length of word/query is `7`, we won\\'t see much benefits (in the best case, we are improving space for keys from **`7 bytes`** to **`4 bytes`** for int). But if the words are of larger size, it would be an much optimised approach.\\n\\n```\\nstring toLowercase(string &s){\\n\\tfor(char& c : s) c = tolower(c);\\n\\treturn s;\\n}\\nbool isVowel(char c){\\n\\treturn c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n}\\nstring maskVowel(string &s){\\n\\tfor(char& c : s) if(isVowel(c)) c = \\'#\\';\\n\\treturn s;\\n}\\nint hash(string s){\\n\\tlong h = 0, mod = 1e9 + 7;\\n\\tfor(char& c : s) h = (h * 101 + c) % mod;\\n\\treturn h;\\n}\\nvector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n\\tunordered_set<int> orig;\\n\\tunordered_map<int, string> lowered, vowelMasked;\\n\\tstring tmp;\\n\\tfor(vector<string>::reverse_iterator word = rbegin(wordlist); word != rend(wordlist); word++) \\n\\t\\ttmp = *word,orig.insert(hash(tmp)), lowered[hash(toLowercase(tmp))] = *word, vowelMasked[hash(maskVowel(tmp))] = *word;\\n\\tint h;\\n\\tfor(string& q : queries)\\n\\t\\tif(orig.count(hash(q))) continue;\\n\\t\\telse if(lowered.count(h = hash(toLowercase(q)))) q = lowered[h];\\n\\t\\telse if(vowelMasked.count(h = hash(maskVowel(q)))) q = vowelMasked[h];\\n\\t\\telse q = \"\";\\n\\treturn queries;\\n}\\n```\\n\\n**Time Complexity :** **`O(N + Q)`**, where `N` is the sum of lengths of words in `wordlist` and `Q` is the sum of lengths of queries.\\n**Space Complexity :** **`O(N)`**, for storing in the hashmaps. Although, the space complexity is still the same, we have eliminated a good chunk of constant factor without any addition to time complexity.\\n\\nNote that we would need to choose a good hash function. Luckily, the one I chose didn\\'t give any collisions. For more robust solution, you would need to handle collision cases also.\\n\\n![image](https://assets.leetcode.com/users/images/50e5afb2-f245-477c-8ede-18904754e93b_1616422748.4772894.png)\\n\\n\\n-----------\\n-----------",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// Checks for case-insensitive match between two strings\\nbool caseInsensitiveEqual(string &a, string &b){\\n\\treturn equal(begin(a), end(a), begin(b), end(b), [](char &a, char &b){\\n\\t   return tolower(a) == tolower(b); \\n\\t});\\n}\\n// Checks if given character is vowel\\nbool isVowel(char &c){\\n\\tc = tolower(c);\\n\\treturn c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n}\\n// Checks if both string can be made same after vowels replacement\\nbool vowelFreqCheck(string a, string b){\\n\\tif(size(a) != size(b)) return false;\\n\\tint n = size(a);\\n\\tfor(int i = 0; i < n; i++)            \\n\\t\\tif((!isVowel(a[i]) || !isVowel(b[i])) && tolower(a[i]) != tolower(b[i])) return false;\\n\\treturn true;\\n}\\nvector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n\\tint n = size(queries);\\n\\tvector<string> answer(n, \"\");\\n\\tfor(int i = 0; i < n; i++){\\n\\t\\tbool matched = false;\\n\\t\\t// Check if exact match is found\\n\\t\\tfor(string& word : wordlist)\\n\\t\\t\\tif(word == queries[i]){ queries[i] = word; matched = true; break; }\\n\\t\\tif(matched) continue; // move on to next query if match found\\n\\t\\t// Check if case-insensitive match is found\\n\\t\\tfor(string& word : wordlist)\\n\\t\\t\\tif(caseInsensitiveEqual(word, queries[i])){ queries[i] = word; matched = true; break; }\\n\\t\\tif(matched) continue; // move on to next query if match found\\n\\t\\t// Check if after vowel-replacement, the strings match\\n\\t\\tfor(string& word : wordlist)\\n\\t\\t\\tif(vowelFreqCheck(word, queries[i])){ queries[i] = word; matched = true; break; }\\n\\t\\tif(!matched) queries[i] = \"\"; // if no match found in any case return empty string\\n\\t}\\n\\treturn queries;\\n}\\n```\n```\\nstring toLowercase(string &s){\\n\\tfor(char& c : s) c = tolower(c);\\n\\treturn s;\\n}\\nbool isVowel(char &c){\\n\\treturn c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n}\\n// masking will help check if a word satisfies vowel-error condition\\nstring maskVowel(string &s){\\n\\tfor(char& c : s) if(isVowel(c)) c = \\'#\\';\\n\\treturn s;\\n}\\nvector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n\\tunordered_set original_words(begin(wordlist), end(wordlist));\\n\\tunordered_map<string, string> lowered, vowelMasked;\\n\\tstring tmp;\\n\\t// we are reverse-iterating since we need to find the first matching word\\n\\t// so, we need to update maps to hold the first-most word satisfying a condition\\n\\tfor(auto word = rbegin(wordlist); word != rend(wordlist); word++) \\n\\t\\ttmp = *word, lowered[toLowercase(tmp)] = *word, vowelMasked[maskVowel(tmp)] = *word;\\n\\tfor(string& q : queries){\\n\\t\\t// if exact word is found, continue since we already have it stored in queries[i] (Note : we are returing queries itself)\\n\\t\\tif(original_words.count(q)) continue;\\n\\t\\t// if query converted to lowercase matches with lower-cased word, return the corresponding mapped word from lowered hashmap\\n\\t\\telse if(lowered.count(toLowercase(q))) q = lowered[q];\\n\\t\\t// if query converted to lowercase & vowels masked matches with lower-cased vowel-masked word, return the mapped word from vowelMasked hashmap\\n\\t\\telse if(vowelMasked.count(maskVowel(q))) q = vowelMasked[q];\\n\\t\\telse q = \"\"; // if no match found, return empty string\\n\\t}\\n\\treturn queries;\\n}\\n```\n```\\nstring toLowercase(string &s){\\n\\tfor(char& c : s) c = tolower(c);\\n\\treturn s;\\n}\\nbool isVowel(char c){\\n\\treturn c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n}\\nstring maskVowel(string &s){\\n\\tfor(char& c : s) if(isVowel(c)) c = \\'#\\';\\n\\treturn s;\\n}\\nint hash(string s){\\n\\tlong h = 0, mod = 1e9 + 7;\\n\\tfor(char& c : s) h = (h * 101 + c) % mod;\\n\\treturn h;\\n}\\nvector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n\\tunordered_set<int> orig;\\n\\tunordered_map<int, string> lowered, vowelMasked;\\n\\tstring tmp;\\n\\tfor(vector<string>::reverse_iterator word = rbegin(wordlist); word != rend(wordlist); word++) \\n\\t\\ttmp = *word,orig.insert(hash(tmp)), lowered[hash(toLowercase(tmp))] = *word, vowelMasked[hash(maskVowel(tmp))] = *word;\\n\\tint h;\\n\\tfor(string& q : queries)\\n\\t\\tif(orig.count(hash(q))) continue;\\n\\t\\telse if(lowered.count(h = hash(toLowercase(q)))) q = lowered[h];\\n\\t\\telse if(vowelMasked.count(h = hash(maskVowel(q)))) q = vowelMasked[h];\\n\\t\\telse q = \"\";\\n\\treturn queries;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 211238,
                "title": "c-hash-map-yellow-yellow-y-ll-w",
                "content": "Insert into a single hash map:\\n1. The original string capitalization (\"Yellow\").\\n2. The lowered case string with a prefix (e.g. ```\\'_\\'```) for lover-case matching (\"_yellow\").\\n3. The lowered case string with all vowels replaced (e.g. ```\\'*\\'```) for vowel errors matching (\"y*ll*w\").\\nNote that ```unordered_map::insert``` only inserts the key for the first time.\\n\\nFor our queries, transform it the same way as above, and search in our hash map.\\n```\\nstring lowerKey(string &s) {\\n  return accumulate(begin(s), end(s), string(\"_\"), [](string k, char c) { return k + (char)tolower(c); });\\n}\\nstring vowelKey(string &s) {\\n  return accumulate(begin(s), end(s), string(\"\"), [](string k, char c) { return k +\\n    (char)(string(\"aeiou\").find(tolower(c)) != string::npos ? \\'*\\' : tolower(c)); });\\n}\\nvector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n  unordered_map<string, string> words;\\n  for (auto w : wordlist) {\\n    words.insert({ w, w }), words.insert({ lowerKey(w), w }), words.insert({ vowelKey(w), w });\\n  }\\n  vector<string> res;\\n  for (auto q : queries) {\\n    auto it = words.find(q);\\n    if (it == words.end()) it = words.find(lowerKey(q));\\n    if (it == words.end()) it = words.find(vowelKey(q));\\n    if (it != words.end()) res.push_back(it->second);\\n    else res.push_back(\"\");\\n  }\\n  return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\'_\\'```\n```\\'*\\'```\n```unordered_map::insert```\n```\\nstring lowerKey(string &s) {\\n  return accumulate(begin(s), end(s), string(\"_\"), [](string k, char c) { return k + (char)tolower(c); });\\n}\\nstring vowelKey(string &s) {\\n  return accumulate(begin(s), end(s), string(\"\"), [](string k, char c) { return k +\\n    (char)(string(\"aeiou\").find(tolower(c)) != string::npos ? \\'*\\' : tolower(c)); });\\n}\\nvector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n  unordered_map<string, string> words;\\n  for (auto w : wordlist) {\\n    words.insert({ w, w }), words.insert({ lowerKey(w), w }), words.insert({ vowelKey(w), w });\\n  }\\n  vector<string> res;\\n  for (auto q : queries) {\\n    auto it = words.find(q);\\n    if (it == words.end()) it = words.find(lowerKey(q));\\n    if (it == words.end()) it = words.find(vowelKey(q));\\n    if (it != words.end()) res.push_back(it->second);\\n    else res.push_back(\"\");\\n  }\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1122531,
                "title": "java-with-set-and-map-cap-and-vowel",
                "content": "```\\nclass Solution {\\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        Set<String> perfectWord = new HashSet<>();\\n        Map<String, String> wordCap = new HashMap<>();\\n        Map<String, String> wordVowel = new HashMap<>();\\n\\n        for (String word : wordlist) {\\n            perfectWord.add(word);\\n            wordCap.putIfAbsent(word.toLowerCase(), word);\\n            wordVowel.putIfAbsent(encode(word), word);\\n        }\\n\\n        String[] answer = new String[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            if (perfectWord.contains(queries[i])) {\\n                answer[i] = queries[i];\\n            } else if (wordCap.containsKey(queries[i].toLowerCase())) {\\n                answer[i] = wordCap.get(queries[i].toLowerCase());\\n            } else if (wordVowel.containsKey(encode(queries[i]))) {\\n                answer[i] = wordVowel.get(encode(queries[i]));\\n            } else {\\n                answer[i] = \"\";\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n    private String encode(String s) {\\n        char[] ch = s.toCharArray();\\n        for (int i = 0; i < ch.length; i++) {\\n            if (\"aeiouAEIOU\".contains(\"\" + ch[i]))\\n                ch[i] = \\'*\\';\\n            else\\n                ch[i] = Character.toLowerCase(ch[i]);\\n        }\\n\\n        return new String(ch);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        Set<String> perfectWord = new HashSet<>();\\n        Map<String, String> wordCap = new HashMap<>();\\n        Map<String, String> wordVowel = new HashMap<>();\\n\\n        for (String word : wordlist) {\\n            perfectWord.add(word);\\n            wordCap.putIfAbsent(word.toLowerCase(), word);\\n            wordVowel.putIfAbsent(encode(word), word);\\n        }\\n\\n        String[] answer = new String[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            if (perfectWord.contains(queries[i])) {\\n                answer[i] = queries[i];\\n            } else if (wordCap.containsKey(queries[i].toLowerCase())) {\\n                answer[i] = wordCap.get(queries[i].toLowerCase());\\n            } else if (wordVowel.containsKey(encode(queries[i]))) {\\n                answer[i] = wordVowel.get(encode(queries[i]));\\n            } else {\\n                answer[i] = \"\";\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n    private String encode(String s) {\\n        char[] ch = s.toCharArray();\\n        for (int i = 0; i < ch.length; i++) {\\n            if (\"aeiouAEIOU\".contains(\"\" + ch[i]))\\n                ch[i] = \\'*\\';\\n            else\\n                ch[i] = Character.toLowerCase(ch[i]);\\n        }\\n\\n        return new String(ch);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122953,
                "title": "c-40ms-trie-based-solution-explained-100-time-6-space",
                "content": "Ah, I worked on this one for a long while, constanly polishing it since I really wanted to solve it with a trie instead of more brute approaches, still not sure it would have paid off, given the sample size.\\n\\nAnd while I might get worse times with the tests, sometimes even of 60ms, I managed to snatch a pretty good time with it and thus I feel now that my efforts were rewarded :)\\n\\nIn order to proceed, we will declare first of all externally a collection of values for the vowels, all normalised in the `0 - 52` range, as we will do [spoiler!] with our small helper function `convertChar`, that takes a character and turns into  a `0 - 25` value if it is in the `\\'a\\' - \\'z\\'` range or `25 - 51` if it is in the `\\'A\\' - \\'Z\\'` range.\\n\\nWe will also declare a `Trie` structure, with 3 properties:\\n* `eow` is a boolean, defaulted to `false` that marks whether or not the current node is the end of a word;\\n* `children`, an array of `52` `Trie` pointers to the next nodes from the current one (if any), matching alphabetical characters as discussed above while mentioning `convertChar`;\\n* `pos` is a pointer referring to which element of `wordlist` the node points, provided it is an end of word.\\n\\nAt class level, we will declare 3 integer variables, our pointers `perfectMatch`, `match` and `vowelMatch` we will use when searching in our trie.\\n\\nIn the main function, we will create a few more support variables:\\n* `res` is our accumulator variable where we will put all the matches of every query;\\n* `root` and `curr` are `Trie` pointers, with the first initialised to be an empty `Trie`.\\n\\nAnd said empty `Trie` we will go to populate next, running witht pointer `i` through `wordlist` and:\\n* assign the value of the current string to `word`;\\n* set `curr` to point initially to `root`;\\n* loop through each character `c` of `word` and:\\n\\t* convert `c` to be an appropriate index with `convertChar`, as mentioned above;\\n\\t* if `curr->children[c]` does not exist, we create it;\\n\\t* advance `curr` to be `curr->children[c]`.\\n* if it is a word we already saw (ie: `curr->eow == true`), we just `continue`;\\n* otherwise we mark it as finalised (setting `curr->eow`) and set `curr->pos` to be `i`.\\n\\nAnd now time to search through the trie. For each `query` in `queries`, we will:\\n* set `perfectMatc`, `match` and `vowelMatch` all to be `INT_MAX`;\\n* run `checkQuery` passing `root` and `query` down to it (more on it below);\\n* compute a new string `tmp`, checking if we modified any of `perfectMatc`, `match` or `vowelMatch` (in this order);\\n* push `tmp` into `res`.\\n\\nThe last (and more complex) bit of our logic is indeed `checkQuery`, that takes a total of 5 parameters:\\n* `root`, the current starting node in our trie;\\n* `query`, the string to search;\\n* `pos`, an optional pointer to which character of `query` we are currently searching - defaulted to `0`;\\n* `isPerfect` and `originalVowels`, optional booleans defaulted to `true`.\\n\\nIn this function we will:\\n* `return` if `root` is `NULL` (ie: we reached a dead-end);\\n* if we finished parsing `query` (ie: `pos == query.size()`) and the current node is also an end of word (ie: `root->eow`), we will:\\n\\t* set `perfectMatch` if `isPerfect` is still `true`;\\n\\t* update `match` to be the minimum between its current value and `root->pos` if `originalVowels` is still `true`;\\n\\t* update `vowelMatch` to be the minimum between its current value and `root->pos` otherwise;\\n\\t* `return`;\\n* assign the normalised value of `query[pos++]` to `c` (notice we increment `pos` here);\\n* check for exact matches, invoking recursively this function as `checkQuery(root->children[c], query, pos, isPerfect, originalVowels)`;\\n* check if in any case we ever encountered a `perfectMatch` and, in case, `return`;\\n* convert `c` to its lower/uppercase equivalent and assigning it to `luc`;\\n* check for case insensitive matches, invoking recursively this function as `checkQuery(root->children[luc], query, pos, false, originalVowels)` (notice that these calls will happen once we are done checking all the perfect path and that even just one item with `isPerfect` set to `false` will propagate it to the remaining calls);\\n* check if in any case we ever encountered a `match` and, in case, `return`;\\n* check if `c` was referring to a vowel and, in case:\\n\\t* loop through all the vowel codes (`vc`) in `vowels` and:\\n\\t\\t* if it is a vowel we already used as either lower- or uppercase, `continue`;\\n\\t\\t* otherwise, invoke recursively this function as `checkQuery(root->children[vc], query, pos, false, false)`.\\n\\nOnce done, we can finally return the fully populated `res` :)\\n\\nThe code:\\n\\n```cpp\\nstatic constexpr int vowels[10] = {26, 30, 34, 40, 46, 0, 4, 8, 14, 20};\\n\\nstruct Trie {\\n    bool eow = false;\\n    Trie *children[52];\\n    int pos;\\n};\\n\\nclass Solution {\\n    int perfectMatch, match, vowelMatch;\\n    int convertChar(char c) {\\n        // converting c to be in the 0 - 51 range\\n        return c > \\'Z\\' ? c - \\'a\\' : c - \\'\\\\\\'\\';\\n    }\\n    void checkQuery(Trie *root, string query, int pos = 0, bool isPerfect = true, bool originalVowels = true) {\\n        // exit condition: no node in the trie\\n        if (!root) return;\\n        if (pos == query.size() && root->eow) {\\n            if (isPerfect) perfectMatch = root->pos;\\n            else if (originalVowels) match = min(match, root->pos);\\n            else vowelMatch = min(vowelMatch, root->pos);\\n            return;\\n        }\\n        char c = convertChar(query[pos++]);\\n        // checking exact match\\n        checkQuery(root->children[c], query, pos, isPerfect, originalVowels);\\n        // exit condition: found a perfect match\\n        if (perfectMatch != INT_MAX) return;\\n        // checking case insensitive matches\\n        // uppercase => lowercase or lowercase => uppercase\\n        char luc = c > 25 ? c - 26 : c + 26;\\n        checkQuery(root->children[luc], query, pos, false, originalVowels);\\n        // exit condition: found a case insensitive match\\n        if (match != INT_MAX) return;\\n        // vowel-swap matches\\n        if (any_of(vowels, vowels + 10, [c](char e){return e == c;})) {\\n            for (char vc: vowels) {\\n                // ignoring the vowel we already tested in either case\\n                if (vc == c || vc == luc) continue;\\n                checkQuery(root->children[vc], query, pos, false, false);\\n            }\\n        }\\n        \\n    }\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        // support variables\\n        vector<string> res;\\n        Trie *root = new Trie(), *curr;\\n        // populating root\\n        for (int i = 0, lmt = wordlist.size(); i < lmt; i++) {\\n            string word = wordlist[i];\\n            curr = root;\\n            for (char c: word) {\\n                c = convertChar(c);\\n                if (!curr->children[c]) curr->children[c] = new Trie();\\n                curr = curr->children[c];\\n            }\\n            // moving on if we alredy encountered this word\\n            if (curr->eow) continue;\\n            // marking end of word and position of the word\\n            curr->eow = true;\\n            curr->pos = i;\\n        }\\n        for (string query: queries) {\\n            perfectMatch = INT_MAX, match = INT_MAX, vowelMatch = INT_MAX;\\n            checkQuery(root, query);\\n            string tmp = perfectMatch != INT_MAX ? wordlist[perfectMatch]\\n                : match != INT_MAX ? wordlist[match]\\n                : vowelMatch != INT_MAX ? wordlist[vowelMatch] : \"\";\\n            res.push_back(tmp);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nThe brag:\\n![image](https://assets.leetcode.com/users/images/dfb0f7ce-c512-4f6c-b1f1-9b0e0f771f23_1616460187.0792692.png)\\n\\nFurher improved solution removing the `eow` flag (just using `pos` for that, with a default value of `-1` meaning the node is not an end of word) and `res` already set to be of the right size - it seems minor, but that saves 2MB on the whole test run:\\n\\n```cpp\\nstatic constexpr int vowels[10] = {26, 30, 34, 40, 46, 0, 4, 8, 14, 20};\\n\\nstruct Trie {\\n    Trie *children[52];\\n    int pos = -1;\\n};\\n\\nclass Solution {\\n    int perfectMatch, match, vowelMatch;\\n    int convertChar(char c) {\\n        // converting c to be in the 0 - 51 range\\n        return c > \\'Z\\' ? c - \\'a\\' : c - \\'\\\\\\'\\';\\n    }\\n    void checkQuery(Trie *root, string query, int pos = 0, bool isPerfect = true, bool originalVowels = true) {\\n        // exit condition: no node in the trie\\n        if (!root) return;\\n        if (pos == query.size() && root->pos != -1) {\\n            if (isPerfect) perfectMatch = root->pos;\\n            else if (originalVowels) match = min(match, root->pos);\\n            else vowelMatch = min(vowelMatch, root->pos);\\n            return;\\n        }\\n        char c = convertChar(query[pos++]);\\n        // checking exact match\\n        checkQuery(root->children[c], query, pos, isPerfect, originalVowels);\\n        // exit condition: found a perfect match\\n        if (perfectMatch != INT_MAX) return;\\n        // checking case insensitive matches\\n        // uppercase => lowercase or lowercase => uppercase\\n        char luc = c > 25 ? c - 26 : c + 26;\\n        checkQuery(root->children[luc], query, pos, false, originalVowels);\\n        // exit condition: found a case insensitive match\\n        if (match != INT_MAX) return;\\n        // vowel-swap matches\\n        if (any_of(vowels, vowels + 10, [c](char e){return e == c;})) {\\n            for (char vc: vowels) {\\n                // ignoring the vowel we already tested in either case\\n                if (vc == c || vc == luc) continue;\\n                checkQuery(root->children[vc], query, pos, false, false);\\n            }\\n        }\\n        \\n    }\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        // support variables\\n        vector<string> res(queries.size());\\n        Trie *root = new Trie(), *curr;\\n        // populating root\\n        for (int i = 0, lmt = wordlist.size(); i < lmt; i++) {\\n            string word = wordlist[i];\\n            curr = root;\\n            for (char c: word) {\\n                c = convertChar(c);\\n                if (!curr->children[c]) curr->children[c] = new Trie();\\n                curr = curr->children[c];\\n            }\\n            // moving on if we alredy encountered this word\\n            if (curr->pos != -1) continue;\\n            // marking end of word and position of the word\\n            curr->pos = i;\\n        }\\n        for (int i = 0, lmt = queries.size(); i < lmt; i++) {\\n            string query = queries[i];\\n            perfectMatch = INT_MAX, match = INT_MAX, vowelMatch = INT_MAX;\\n            checkQuery(root, query);\\n            string tmp = perfectMatch != INT_MAX ? wordlist[perfectMatch]\\n                : match != INT_MAX ? wordlist[match]\\n                : vowelMatch != INT_MAX ? wordlist[vowelMatch] : \"\";\\n            res[i] = tmp;\\n        }\\n        // creating res already of the right size;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```cpp\\nstatic constexpr int vowels[10] = {26, 30, 34, 40, 46, 0, 4, 8, 14, 20};\\n\\nstruct Trie {\\n    bool eow = false;\\n    Trie *children[52];\\n    int pos;\\n};\\n\\nclass Solution {\\n    int perfectMatch, match, vowelMatch;\\n    int convertChar(char c) {\\n        // converting c to be in the 0 - 51 range\\n        return c > \\'Z\\' ? c - \\'a\\' : c - \\'\\\\\\'\\';\\n    }\\n    void checkQuery(Trie *root, string query, int pos = 0, bool isPerfect = true, bool originalVowels = true) {\\n        // exit condition: no node in the trie\\n        if (!root) return;\\n        if (pos == query.size() && root->eow) {\\n            if (isPerfect) perfectMatch = root->pos;\\n            else if (originalVowels) match = min(match, root->pos);\\n            else vowelMatch = min(vowelMatch, root->pos);\\n            return;\\n        }\\n        char c = convertChar(query[pos++]);\\n        // checking exact match\\n        checkQuery(root->children[c], query, pos, isPerfect, originalVowels);\\n        // exit condition: found a perfect match\\n        if (perfectMatch != INT_MAX) return;\\n        // checking case insensitive matches\\n        // uppercase => lowercase or lowercase => uppercase\\n        char luc = c > 25 ? c - 26 : c + 26;\\n        checkQuery(root->children[luc], query, pos, false, originalVowels);\\n        // exit condition: found a case insensitive match\\n        if (match != INT_MAX) return;\\n        // vowel-swap matches\\n        if (any_of(vowels, vowels + 10, [c](char e){return e == c;})) {\\n            for (char vc: vowels) {\\n                // ignoring the vowel we already tested in either case\\n                if (vc == c || vc == luc) continue;\\n                checkQuery(root->children[vc], query, pos, false, false);\\n            }\\n        }\\n        \\n    }\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        // support variables\\n        vector<string> res;\\n        Trie *root = new Trie(), *curr;\\n        // populating root\\n        for (int i = 0, lmt = wordlist.size(); i < lmt; i++) {\\n            string word = wordlist[i];\\n            curr = root;\\n            for (char c: word) {\\n                c = convertChar(c);\\n                if (!curr->children[c]) curr->children[c] = new Trie();\\n                curr = curr->children[c];\\n            }\\n            // moving on if we alredy encountered this word\\n            if (curr->eow) continue;\\n            // marking end of word and position of the word\\n            curr->eow = true;\\n            curr->pos = i;\\n        }\\n        for (string query: queries) {\\n            perfectMatch = INT_MAX, match = INT_MAX, vowelMatch = INT_MAX;\\n            checkQuery(root, query);\\n            string tmp = perfectMatch != INT_MAX ? wordlist[perfectMatch]\\n                : match != INT_MAX ? wordlist[match]\\n                : vowelMatch != INT_MAX ? wordlist[vowelMatch] : \"\";\\n            res.push_back(tmp);\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nstatic constexpr int vowels[10] = {26, 30, 34, 40, 46, 0, 4, 8, 14, 20};\\n\\nstruct Trie {\\n    Trie *children[52];\\n    int pos = -1;\\n};\\n\\nclass Solution {\\n    int perfectMatch, match, vowelMatch;\\n    int convertChar(char c) {\\n        // converting c to be in the 0 - 51 range\\n        return c > \\'Z\\' ? c - \\'a\\' : c - \\'\\\\\\'\\';\\n    }\\n    void checkQuery(Trie *root, string query, int pos = 0, bool isPerfect = true, bool originalVowels = true) {\\n        // exit condition: no node in the trie\\n        if (!root) return;\\n        if (pos == query.size() && root->pos != -1) {\\n            if (isPerfect) perfectMatch = root->pos;\\n            else if (originalVowels) match = min(match, root->pos);\\n            else vowelMatch = min(vowelMatch, root->pos);\\n            return;\\n        }\\n        char c = convertChar(query[pos++]);\\n        // checking exact match\\n        checkQuery(root->children[c], query, pos, isPerfect, originalVowels);\\n        // exit condition: found a perfect match\\n        if (perfectMatch != INT_MAX) return;\\n        // checking case insensitive matches\\n        // uppercase => lowercase or lowercase => uppercase\\n        char luc = c > 25 ? c - 26 : c + 26;\\n        checkQuery(root->children[luc], query, pos, false, originalVowels);\\n        // exit condition: found a case insensitive match\\n        if (match != INT_MAX) return;\\n        // vowel-swap matches\\n        if (any_of(vowels, vowels + 10, [c](char e){return e == c;})) {\\n            for (char vc: vowels) {\\n                // ignoring the vowel we already tested in either case\\n                if (vc == c || vc == luc) continue;\\n                checkQuery(root->children[vc], query, pos, false, false);\\n            }\\n        }\\n        \\n    }\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        // support variables\\n        vector<string> res(queries.size());\\n        Trie *root = new Trie(), *curr;\\n        // populating root\\n        for (int i = 0, lmt = wordlist.size(); i < lmt; i++) {\\n            string word = wordlist[i];\\n            curr = root;\\n            for (char c: word) {\\n                c = convertChar(c);\\n                if (!curr->children[c]) curr->children[c] = new Trie();\\n                curr = curr->children[c];\\n            }\\n            // moving on if we alredy encountered this word\\n            if (curr->pos != -1) continue;\\n            // marking end of word and position of the word\\n            curr->pos = i;\\n        }\\n        for (int i = 0, lmt = queries.size(); i < lmt; i++) {\\n            string query = queries[i];\\n            perfectMatch = INT_MAX, match = INT_MAX, vowelMatch = INT_MAX;\\n            checkQuery(root, query);\\n            string tmp = perfectMatch != INT_MAX ? wordlist[perfectMatch]\\n                : match != INT_MAX ? wordlist[match]\\n                : vowelMatch != INT_MAX ? wordlist[vowelMatch] : \"\";\\n            res[i] = tmp;\\n        }\\n        // creating res already of the right size;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 211414,
                "title": "java-clean-code-use-map",
                "content": "```java\\nclass Solution {\\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        Map<String, String> wordMap = new HashMap<>();\\n        Map<String, String> wordPatternMap = new HashMap<>();\\n        for (String word : wordlist) {\\n            wordMap.put(word, word);\\n            wordPatternMap.putIfAbsent(word.toLowerCase(), word);\\n            wordPatternMap.putIfAbsent(wordPattern(word), word);\\n        }\\n        for (int i = 0; i < queries.length; i++) {\\n            if (wordMap.containsKey(queries[i])) {\\n                queries[i] = wordMap.get(queries[i]);\\n                continue;\\n            }\\n            String wordPattern = queries[i].toLowerCase();\\n            if (wordPatternMap.containsKey(wordPattern)) {\\n                queries[i] = wordPatternMap.get(wordPattern);\\n                continue;\\n            }\\n            wordPattern = wordPattern(queries[i]);\\n            if (wordPatternMap.containsKey(wordPattern)) {\\n                queries[i] = wordPatternMap.get(wordPattern);\\n                continue;\\n            }\\n            queries[i] = \"\";\\n        }\\n        return queries;\\n    }\\n\\n    private String wordPattern(String word) {\\n\\t    // return word.toLowerCase().replaceAll(\"a|e|i|o|u\", \"*\");\\n        char[] letters = word.toLowerCase().toCharArray();\\n        for (int i = 0; i < letters.length; i++) {\\n            if (letters[i] == \\'a\\'\\n                    || letters[i] == \\'e\\'\\n                    || letters[i] == \\'i\\'\\n                    || letters[i] == \\'o\\'\\n                    || letters[i] == \\'u\\') {\\n                letters[i] = \\'*\\';\\n            }\\n        }\\n        return new String(letters);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        Map<String, String> wordMap = new HashMap<>();\\n        Map<String, String> wordPatternMap = new HashMap<>();\\n        for (String word : wordlist) {\\n            wordMap.put(word, word);\\n            wordPatternMap.putIfAbsent(word.toLowerCase(), word);\\n            wordPatternMap.putIfAbsent(wordPattern(word), word);\\n        }\\n        for (int i = 0; i < queries.length; i++) {\\n            if (wordMap.containsKey(queries[i])) {\\n                queries[i] = wordMap.get(queries[i]);\\n                continue;\\n            }\\n            String wordPattern = queries[i].toLowerCase();\\n            if (wordPatternMap.containsKey(wordPattern)) {\\n                queries[i] = wordPatternMap.get(wordPattern);\\n                continue;\\n            }\\n            wordPattern = wordPattern(queries[i]);\\n            if (wordPatternMap.containsKey(wordPattern)) {\\n                queries[i] = wordPatternMap.get(wordPattern);\\n                continue;\\n            }\\n            queries[i] = \"\";\\n        }\\n        return queries;\\n    }\\n\\n    private String wordPattern(String word) {\\n\\t    // return word.toLowerCase().replaceAll(\"a|e|i|o|u\", \"*\");\\n        char[] letters = word.toLowerCase().toCharArray();\\n        for (int i = 0; i < letters.length; i++) {\\n            if (letters[i] == \\'a\\'\\n                    || letters[i] == \\'e\\'\\n                    || letters[i] == \\'i\\'\\n                    || letters[i] == \\'o\\'\\n                    || letters[i] == \\'u\\') {\\n                letters[i] = \\'*\\';\\n            }\\n        }\\n        return new String(letters);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 211211,
                "title": "my-understandable-python-contest-solution",
                "content": "* Register every word (w) in wordlist in related cap(capitalization) and vow(vowel error) hash table.\\n* For every word (w) in queries, apply the stated precedence rules\\n```\\nclass Solution:\\n    def spellchecker(self, wordlist, queries):\\n        st, cap, vow = set(wordlist), {}, {}\\n        for w in wordlist:\\n            newC = w.lower()\\n            newW = \"\".join(c if c not in \"aeiou\" else \"*\" for c in newC)\\n            if newC not in cap:\\n                cap[newC] = w\\n            if newW not in vow:\\n                vow[newW] = w\\n        for i, w in enumerate(queries):\\n            if w in st:\\n                pass\\n            elif w.lower() in cap:\\n                queries[i] = cap[w.lower()]\\n            else:\\n                new = \"\".join(c if c not in \"aeiou\" else \"*\" for c in w.lower())\\n                if new in vow:\\n                    queries[i] = vow[new]\\n                else:\\n                    queries[i] = \"\"\\n        return queries\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def spellchecker(self, wordlist, queries):\\n        st, cap, vow = set(wordlist), {}, {}\\n        for w in wordlist:\\n            newC = w.lower()\\n            newW = \"\".join(c if c not in \"aeiou\" else \"*\" for c in newC)\\n            if newC not in cap:\\n                cap[newC] = w\\n            if newW not in vow:\\n                vow[newW] = w\\n        for i, w in enumerate(queries):\\n            if w in st:\\n                pass\\n            elif w.lower() in cap:\\n                queries[i] = cap[w.lower()]\\n            else:\\n                new = \"\".join(c if c not in \"aeiou\" else \"*\" for c in w.lower())\\n                if new in vow:\\n                    queries[i] = vow[new]\\n                else:\\n                    queries[i] = \"\"\\n        return queries\\n```",
                "codeTag": "Java"
            },
            {
                "id": 692668,
                "title": "javascript-clean-solution-96ms-faster-than-100",
                "content": "```js\\n/**\\n * @param {string[]} wordlist\\n * @param {string[]} queries\\n * @return {string[]}\\n */\\nvar spellchecker = function(wordlist, queries) {\\n    const asIs = new Set(wordlist);\\n    const lowercased = createLowercasedList(wordlist);\\n    const vowelCorrected = createVowelCorrectedList(wordlist);\\n    \\n    return queries.map(query => {\\n        if (asIs.has(query)) {\\n           return query;\\n        }\\n        \\n        const lowercasedQuery = query.toLowerCase();\\n        if (lowercased.has(lowercasedQuery)) {\\n            return lowercased.get(lowercasedQuery);\\n        }\\n        \\n        const correctedQuery = toVowelCorrected(query);\\n        if (vowelCorrected.has(correctedQuery)) {\\n            return vowelCorrected.get(correctedQuery);\\n        }\\n        \\n        return \\'\\';\\n    });\\n};\\n\\nconst createLowercasedList = (wordlist) => {\\n    const map = new Map();\\n    \\n    for (const word of wordlist) {\\n        const lowercased = word.toLowerCase();\\n        \\n        if (map.has(lowercased)) {\\n            continue;\\n        }\\n        \\n        map.set(lowercased, word);\\n    }\\n    \\n    return map;\\n}\\n\\nconst createVowelCorrectedList = (wordlist) => {\\n    const map = new Map();\\n    \\n    for (const word of wordlist) {\\n        const corrected = toVowelCorrected(word);\\n        \\n        if (map.has(corrected)) {\\n            continue;\\n        }\\n        \\n        map.set(corrected, word);\\n    }\\n    \\n    return map;\\n}\\n\\n// hello => h*ll*\\nconst toVowelCorrected = word => word.toLowerCase().replace(/a|e|i|o|u/g, \\'*\\');\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {string[]} wordlist\\n * @param {string[]} queries\\n * @return {string[]}\\n */\\nvar spellchecker = function(wordlist, queries) {\\n    const asIs = new Set(wordlist);\\n    const lowercased = createLowercasedList(wordlist);\\n    const vowelCorrected = createVowelCorrectedList(wordlist);\\n    \\n    return queries.map(query => {\\n        if (asIs.has(query)) {\\n           return query;\\n        }\\n        \\n        const lowercasedQuery = query.toLowerCase();\\n        if (lowercased.has(lowercasedQuery)) {\\n            return lowercased.get(lowercasedQuery);\\n        }\\n        \\n        const correctedQuery = toVowelCorrected(query);\\n        if (vowelCorrected.has(correctedQuery)) {\\n            return vowelCorrected.get(correctedQuery);\\n        }\\n        \\n        return \\'\\';\\n    });\\n};\\n\\nconst createLowercasedList = (wordlist) => {\\n    const map = new Map();\\n    \\n    for (const word of wordlist) {\\n        const lowercased = word.toLowerCase();\\n        \\n        if (map.has(lowercased)) {\\n            continue;\\n        }\\n        \\n        map.set(lowercased, word);\\n    }\\n    \\n    return map;\\n}\\n\\nconst createVowelCorrectedList = (wordlist) => {\\n    const map = new Map();\\n    \\n    for (const word of wordlist) {\\n        const corrected = toVowelCorrected(word);\\n        \\n        if (map.has(corrected)) {\\n            continue;\\n        }\\n        \\n        map.set(corrected, word);\\n    }\\n    \\n    return map;\\n}\\n\\n// hello => h*ll*\\nconst toVowelCorrected = word => word.toLowerCase().replace(/a|e|i|o|u/g, \\'*\\');\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1121773,
                "title": "python-one-case-at-a-time",
                "content": "**Approach:**\\n\\nThere are 4 possible scenarios for each word, we can try them in order of priority:\\n1. The word matches a word in `wordlist`\\nCreating a set of `wordlist` allows us to check if this is true in O(1) time.\\n\\n2. The word matches a word in `wordlist` up to capitalization.\\nConvert the word to lowercase letters and check if the word is in\\n`case_insensitive`, if so, use the first word that matches with case insensitivity.\\n\\n3. The word matches up to vowel errors.\\nMask the word by converting all characters to lower case and all vowels to `\\'*\\'`.\\nCheck if this mask is in `vowel_insensitive`. If so, use the first word that matches with vowel insensitivity.\\n\\n4. None of the above are true, we add an empty string to res.\\n\\n```python\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        \\n        # Convert words and vowels to sets for O(1) lookup times\\n        words = set(wordlist)\\n        vowels = set(\\'aeiouAEIOU\\')\\n        \\n        # Create two maps.  \\n        # One for case insensitive word to all words that match \"key\" -> [\"Key\", \"kEy\", \"KEY\"]\\n        # The other for vowel insensitive words \"k*t*\" -> [\"Kite\", \"kato\", \"KUTA\"]\\n        case_insensitive = collections.defaultdict(list)            \\n        vowel_insensitive = collections.defaultdict(list)\\n        for word in wordlist:\\n            case_insensitive[word.lower()].append(word)\\n            key = \\'\\'.join(char.lower() if char not in vowels else \\'*\\' for char in word)\\n            vowel_insensitive[key].append(word)\\n\\n        res = []\\n        for word in queries:\\n\\n            # Case 1: When query exactly matches a word\\n            if word in words:\\n                res.append(word)\\n                continue\\n\\n            # Case 2: When query matches a word up to capitalization\\n            low = word.lower()\\n            if low in case_insensitive:\\n                res.append(case_insensitive[low][0])\\n                continue\\n\\n            # Case 3: When query matches a word up to vowel errors\\n            key = \\'\\'.join(char.lower() if char not in vowels else \\'*\\' for char in word)\\n            if key in vowel_insensitive:\\n                res.append(vowel_insensitive[key][0])\\n                continue\\n\\n            res.append(\\'\\')\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        \\n        # Convert words and vowels to sets for O(1) lookup times\\n        words = set(wordlist)\\n        vowels = set(\\'aeiouAEIOU\\')\\n        \\n        # Create two maps.  \\n        # One for case insensitive word to all words that match \"key\" -> [\"Key\", \"kEy\", \"KEY\"]\\n        # The other for vowel insensitive words \"k*t*\" -> [\"Kite\", \"kato\", \"KUTA\"]\\n        case_insensitive = collections.defaultdict(list)            \\n        vowel_insensitive = collections.defaultdict(list)\\n        for word in wordlist:\\n            case_insensitive[word.lower()].append(word)\\n            key = \\'\\'.join(char.lower() if char not in vowels else \\'*\\' for char in word)\\n            vowel_insensitive[key].append(word)\\n\\n        res = []\\n        for word in queries:\\n\\n            # Case 1: When query exactly matches a word\\n            if word in words:\\n                res.append(word)\\n                continue\\n\\n            # Case 2: When query matches a word up to capitalization\\n            low = word.lower()\\n            if low in case_insensitive:\\n                res.append(case_insensitive[low][0])\\n                continue\\n\\n            # Case 3: When query matches a word up to vowel errors\\n            key = \\'\\'.join(char.lower() if char not in vowels else \\'*\\' for char in word)\\n            if key in vowel_insensitive:\\n                res.append(vowel_insensitive[key][0])\\n                continue\\n\\n            res.append(\\'\\')\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 388977,
                "title": "very-easy-python-solution-beats-97-time-100-space",
                "content": "```\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        \\n        if len(queries) == 0:\\n            return []\\n        \\n\\t\\t# Set for Perfect Word\\n        wordPerfect = set(wordlist)\\n\\t\\t# Dictionary to hold Capital Word Form\\n        wordUpper = {}\\n\\t\\t# Dictionary to hold Vowel Chnaged Form\\n        wordVowel = {}\\n        \\n\\t\\t# Setting up the Dictionaries and saving only the first correct occurance of the word in wordList\\n        for word in wordlist:\\n            tempLowerWord = word.lower()\\n            if tempLowerWord not in wordUpper:\\n                wordUpper[tempLowerWord] = word\\n\\t\\t\\t# Converting to Vowel Transformed Word\\n            tempWordVowel = self.changeVowelWord(tempLowerWord)\\n            if tempWordVowel not in wordVowel:\\n                wordVowel[tempWordVowel] = word\\n        \\n        ans = []\\n        for word in queries:\\n            tempWord = word.lower()\\n            tempWordVowel = self.changeVowelWord(tempWord)\\n\\t\\t\\t# If-Else priority wise, Capital before Vowel Transformed\\n            if word in wordPerfect:\\n                ans.append(word)\\n            elif tempWord in wordUpper:\\n                ans.append(wordUpper[tempWord])\\n            elif tempWordVowel in wordVowel:\\n                ans.append(wordVowel[tempWordVowel])\\n            else:\\n                ans.append(\"\")\\n        \\n        return ans\\n        \\n    def changeVowelWord(self, word):\\n        \\n        myWord = \"\"\\n        for ch in word:\\n            if ch in \"aeiou\":\\n                myWord += \\'*\\'\\n            else:\\n                myWord += ch\\n        \\n        return myWord\\n        \\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        \\n        if len(queries) == 0:\\n            return []\\n        \\n\\t\\t# Set for Perfect Word\\n        wordPerfect = set(wordlist)\\n\\t\\t# Dictionary to hold Capital Word Form\\n        wordUpper = {}\\n\\t\\t# Dictionary to hold Vowel Chnaged Form\\n        wordVowel = {}\\n        \\n\\t\\t# Setting up the Dictionaries and saving only the first correct occurance of the word in wordList\\n        for word in wordlist:\\n            tempLowerWord = word.lower()\\n            if tempLowerWord not in wordUpper:\\n                wordUpper[tempLowerWord] = word\\n\\t\\t\\t# Converting to Vowel Transformed Word\\n            tempWordVowel = self.changeVowelWord(tempLowerWord)\\n            if tempWordVowel not in wordVowel:\\n                wordVowel[tempWordVowel] = word\\n        \\n        ans = []\\n        for word in queries:\\n            tempWord = word.lower()\\n            tempWordVowel = self.changeVowelWord(tempWord)\\n\\t\\t\\t# If-Else priority wise, Capital before Vowel Transformed\\n            if word in wordPerfect:\\n                ans.append(word)\\n            elif tempWord in wordUpper:\\n                ans.append(wordUpper[tempWord])\\n            elif tempWordVowel in wordVowel:\\n                ans.append(wordVowel[tempWordVowel])\\n            else:\\n                ans.append(\"\")\\n        \\n        return ans\\n        \\n    def changeVowelWord(self, word):\\n        \\n        myWord = \"\"\\n        for ch in word:\\n            if ch in \"aeiou\":\\n                myWord += \\'*\\'\\n            else:\\n                myWord += ch\\n        \\n        return myWord\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 345171,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeVowels(string s) {\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'o\\' || s[i] == \\'u\\' || s[i] == \\'i\\') s[i] = \\'*\\';\\n        }\\n        return s;\\n    }\\n    string tolow(string s) {\\n        string c;\\n        for(char x: s) c += tolower(x);\\n        return c;\\n    }\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        unordered_map<string, string> c;\\n        unordered_map<string, string> v;\\n        unordered_set<string> s2;\\n        for(string word: wordlist) {\\n            s2.insert(word);\\n            string temp = tolow(word);\\n            if(c.find(temp) == c.end()) c[temp] = word;\\n            if(v.find(removeVowels(temp)) == v.end()) v[removeVowels(temp)] = word;\\n        }\\n        vector<string> ans;\\n        for(string q: queries) {\\n            string lq = tolow(q);\\n            if(s2.find(q) != s2.end()) ans.push_back(q);\\n            else if(c.find(lq) != c.end()) ans.push_back(c[lq]);\\n            else if(v.find(removeVowels(lq)) != v.end()) ans.push_back(v[removeVowels(lq)]);\\n            else ans.push_back(\"\");\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeVowels(string s) {\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'o\\' || s[i] == \\'u\\' || s[i] == \\'i\\') s[i] = \\'*\\';\\n        }\\n        return s;\\n    }\\n    string tolow(string s) {\\n        string c;\\n        for(char x: s) c += tolower(x);\\n        return c;\\n    }\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        unordered_map<string, string> c;\\n        unordered_map<string, string> v;\\n        unordered_set<string> s2;\\n        for(string word: wordlist) {\\n            s2.insert(word);\\n            string temp = tolow(word);\\n            if(c.find(temp) == c.end()) c[temp] = word;\\n            if(v.find(removeVowels(temp)) == v.end()) v[removeVowels(temp)] = word;\\n        }\\n        vector<string> ans;\\n        for(string q: queries) {\\n            string lq = tolow(q);\\n            if(s2.find(q) != s2.end()) ans.push_back(q);\\n            else if(c.find(lq) != c.end()) ans.push_back(c[lq]);\\n            else if(v.find(removeVowels(lq)) != v.end()) ans.push_back(v[removeVowels(lq)]);\\n            else ans.push_back(\"\");\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 240156,
                "title": "java-trietree-beats-100",
                "content": "use TrieTree to improve query efficiency.\\nOne thing to note is that when init the trieTree you need to check every word is built in the tree only once.\\nwhen query word with case sensitivity or vowel sensiticity using dfs is ok, what we need to do is to choose the min result.\\n```\\npublic class Solution {\\n\\tclass Node{\\n\\t\\tNode[] next;\\n\\t\\tchar now;\\n\\t\\tboolean flag;//\\u6807\\u5FD7\\u8FD9\\u91CC\\u662F\\u5426\\u662F\\u4E00\\u4E2A\\u5B8C\\u6574\\u7684\\u5355\\u8BCD\\n\\t\\tint index;//\\u6807\\u5FD7\\u8FD9\\u4E2A\\u5355\\u8BCD\\u5728\\u5B57\\u5178\\u91CC\\u7684\\u987A\\u5E8F\\n\\t\\tpublic Node(char now) {\\n\\t\\t\\tthis.now = now;\\n\\t\\t\\tthis.next = new Node[52];\\n\\t\\t}\\n\\t}\\n\\tpublic String[] spellchecker(String[] wordlist, String[] queries) {\\n        Node root = new Node(\\' \\');\\n        buildTree(wordlist, root);\\n        String[] res = new String[queries.length];\\n        for(int i = 0;i < queries.length;++i) {\\n        \\tint match = matchSearch(queries[i], root);\\n        \\tif(match >= 0) {//\\u7CBE\\u51C6\\u5339\\u914D\\u4E0A\\u4E86\\n        \\t\\tres[i] = wordlist[match];\\n        \\t\\tcontinue;\\n        \\t}\\n        \\tchar[] chars = queries[i].toCharArray();\\n        \\tmatch = likeSearch(chars, root, 0);\\n        \\tif(match != Integer.MAX_VALUE) {//\\u6A21\\u7CCA\\u5339\\u914D\\u4E0A\\u4E86\\n        \\t\\tres[i] = wordlist[match];\\n        \\t\\tcontinue;\\n        \\t}\\n        \\tmatch = vowelSearch(chars, root, 0);\\n        \\tif(match != Integer.MAX_VALUE) {//\\u5143\\u97F3\\u5339\\u914D\\u4E0A\\u4E86\\n        \\t\\tres[i] = wordlist[match];\\n        \\t\\tcontinue;\\n        \\t}\\n        \\tres[i] = \"\";//\\u6CA1\\u6709\\u5339\\u914D\\u4E0A\\n        }\\n        return res;\\n    }\\n\\t\\n\\t//\\u6784\\u9020\\u5B57\\u5178\\u6811\\n\\tprivate void buildTree(String[] wordlist,Node root) {\\n\\t\\tNode now = root;\\n\\t\\tfor(int i=0;i<wordlist.length;++i) {\\n\\t\\t\\tchar[] chars = wordlist[i].toCharArray();\\n\\t\\t\\tfor(int j=0;j<chars.length;++j) {\\n\\t\\t\\t\\tint id = 0;\\n\\t\\t\\t\\tif(chars[j]>=\\'a\\') id = 26+chars[j]-\\'a\\';\\n\\t\\t\\t\\telse id = chars[j]-\\'A\\';\\n\\t\\t\\t\\tNode next = now.next[id];\\n\\t\\t\\t\\tif(next == null) {\\n\\t\\t\\t\\t\\tnow.next[id] = new Node(chars[j]);\\n\\t\\t\\t\\t\\tnext = now.next[id];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnow = next;\\n\\t\\t\\t}\\n\\t\\t\\tif(!now.flag) {//\\u68C0\\u67E5\\u662F\\u5426\\u5DF2\\u7ECF\\u88AB\\u521D\\u59CB\\u5316\\n\\t\\t\\t\\tnow.flag = true;\\n\\t\\t\\t\\tnow.index = i;\\n\\t\\t\\t}\\n\\t\\t\\tnow = root;//\\u91CD\\u65B0\\u7EC4\\u7EC7\\u4E0B\\u4E00\\u4E2A\\u5355\\u8BCD\\n\\t\\t}\\n\\t\\t\\n\\t}\\n\\t//\\u5B8C\\u5168\\u5339\\u914D\\n\\tprivate int matchSearch(String word,Node root) {\\n\\t\\tNode now = root;\\n\\t\\tfor(int i = 0;i < word.length();++i) {\\n\\t\\t\\tchar c = word.charAt(i);\\n\\t\\t\\tint id = c >= \\'a\\'?26+c-\\'a\\':c-\\'A\\';\\n\\t\\t\\tNode next = now.next[id];\\n\\t\\t\\tif(next == null) return -1;//\\u8868\\u793A\\u6CA1\\u6709\\u5339\\u914D\\u4E0A\\n\\t\\t\\tnow = next;\\n\\t\\t}\\n\\t\\treturn now.flag?now.index:-1;//\\u5982\\u679C\\u8FD9\\u4E2A\\u8BCD\\u662F\\u5355\\u8BCD \\u5C31\\u8FD4\\u56DE\\u4E0B\\u6807 \\u5426\\u5219\\u6CA1\\u6709\\u5339\\u914D\\u4E0A\\n\\t}\\n\\t\\n\\t//\\u6A21\\u7CCA\\u66FF\\u6362\\n\\tprivate int likeSearch(char[] word,Node root,int index) {\\n\\t\\tif(index == word.length) return root.flag?root.index:Integer.MAX_VALUE;//\\u5982\\u679C\\u8FD9\\u4E2A\\u8BCD\\u662F\\u5355\\u8BCD \\u5C31\\u8FD4\\u56DE\\u4E0B\\u6807 \\u5426\\u5219\\u6CA1\\u6709\\u5339\\u914D\\u4E0A\\n\\t\\tint may = word[index] >= \\'a\\' ? word[index]-\\'a\\' : word[index]-\\'A\\'+26;\\n\\t\\tint now = word[index] >= \\'a\\' ? word[index]-\\'a\\'+26 : word[index]-\\'A\\';\\n\\t\\tint res = Integer.MAX_VALUE;\\n\\t\\tNode next = root.next[now];\\n\\t\\tif(next != null) {//\\u6709\\u8FD9\\u4E2A\\u8282\\u70B9\\n\\t\\t\\tres = likeSearch(word, next, index+1);\\n\\t\\t}\\n\\t\\tnext = root.next[may];\\n\\t\\tif(next != null) {//\\u6709\\u8FD9\\u4E2A\\u8282\\u70B9\\n\\t\\t\\tres = Math.min(res, likeSearch(word, next, index+1));\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\t//\\u5143\\u97F3\\u66FF\\u6362\\n\\tprivate int vowelSearch(char[] word,Node root,int index) {\\n\\t\\tif(index == word.length) return root.flag?root.index:Integer.MAX_VALUE;//\\u5982\\u679C\\u8FD9\\u4E2A\\u8BCD\\u662F\\u5355\\u8BCD \\u5C31\\u8FD4\\u56DE\\u4E0B\\u6807 \\u5426\\u5219\\u6CA1\\u6709\\u5339\\u914D\\u4E0A\\n\\t\\tint res = Integer.MAX_VALUE;\\n\\t\\tif(word[index] == \\'a\\'||word[index] == \\'e\\'||word[index] == \\'i\\'||word[index] == \\'o\\'|| word[index] == \\'u\\'||\\n\\t\\t\\t\\tword[index] == \\'A\\'||word[index] == \\'E\\'||word[index] == \\'I\\'||word[index] == \\'O\\'||word[index] == \\'U\\') {\\n\\t\\t\\tint[] may = new int[] {26,30,34,40,46,0,4,8,14,20};\\n\\t\\t\\tfor(int i:may) {\\n\\t\\t\\t\\tNode next = root.next[i];\\n\\t\\t\\t\\tif(next != null) res = Math.min(res, vowelSearch(word,next,index+1));\\n\\t\\t\\t}\\n\\t\\t}else{//\\u5426\\u5219\\u4E0D\\u662F\\u5143\\u97F3\\u5B57\\u6BCD \\u4EC5\\u89E6\\u53D1\\u5927\\u5C0F\\u5199\\u654F\\u611F\\u5339\\u914D\\n\\t\\t\\tint may = word[index] >= \\'a\\' ? word[index]-\\'a\\' : word[index]-\\'A\\'+26;\\n\\t\\t\\tint now = word[index] >= \\'a\\' ? word[index]-\\'a\\'+26 : word[index]-\\'A\\';\\n\\t\\t\\tNode next = root.next[now];\\n\\t\\t\\tif(next != null) {\\n\\t\\t\\t\\tres = vowelSearch(word, next, index+1);\\n\\t\\t\\t}\\n\\t\\t\\tnext = root.next[may];\\n\\t\\t\\tif(next != null) {//\\u6709\\u8FD9\\u4E2A\\u8282\\u70B9\\n\\t\\t\\t\\tres = Math.min(res, vowelSearch(word, next, index+1));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\t\\n\\t\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\tclass Node{\\n\\t\\tNode[] next;\\n\\t\\tchar now;\\n\\t\\tboolean flag;//\\u6807\\u5FD7\\u8FD9\\u91CC\\u662F\\u5426\\u662F\\u4E00\\u4E2A\\u5B8C\\u6574\\u7684\\u5355\\u8BCD\\n\\t\\tint index;//\\u6807\\u5FD7\\u8FD9\\u4E2A\\u5355\\u8BCD\\u5728\\u5B57\\u5178\\u91CC\\u7684\\u987A\\u5E8F\\n\\t\\tpublic Node(char now) {\\n\\t\\t\\tthis.now = now;\\n\\t\\t\\tthis.next = new Node[52];\\n\\t\\t}\\n\\t}\\n\\tpublic String[] spellchecker(String[] wordlist, String[] queries) {\\n        Node root = new Node(\\' \\');\\n        buildTree(wordlist, root);\\n        String[] res = new String[queries.length];\\n        for(int i = 0;i < queries.length;++i) {\\n        \\tint match = matchSearch(queries[i], root);\\n        \\tif(match >= 0) {//\\u7CBE\\u51C6\\u5339\\u914D\\u4E0A\\u4E86\\n        \\t\\tres[i] = wordlist[match];\\n        \\t\\tcontinue;\\n        \\t}\\n        \\tchar[] chars = queries[i].toCharArray();\\n        \\tmatch = likeSearch(chars, root, 0);\\n        \\tif(match != Integer.MAX_VALUE) {//\\u6A21\\u7CCA\\u5339\\u914D\\u4E0A\\u4E86\\n        \\t\\tres[i] = wordlist[match];\\n        \\t\\tcontinue;\\n        \\t}\\n        \\tmatch = vowelSearch(chars, root, 0);\\n        \\tif(match != Integer.MAX_VALUE) {//\\u5143\\u97F3\\u5339\\u914D\\u4E0A\\u4E86\\n        \\t\\tres[i] = wordlist[match];\\n        \\t\\tcontinue;\\n        \\t}\\n        \\tres[i] = \"\";//\\u6CA1\\u6709\\u5339\\u914D\\u4E0A\\n        }\\n        return res;\\n    }\\n\\t\\n\\t//\\u6784\\u9020\\u5B57\\u5178\\u6811\\n\\tprivate void buildTree(String[] wordlist,Node root) {\\n\\t\\tNode now = root;\\n\\t\\tfor(int i=0;i<wordlist.length;++i) {\\n\\t\\t\\tchar[] chars = wordlist[i].toCharArray();\\n\\t\\t\\tfor(int j=0;j<chars.length;++j) {\\n\\t\\t\\t\\tint id = 0;\\n\\t\\t\\t\\tif(chars[j]>=\\'a\\') id = 26+chars[j]-\\'a\\';\\n\\t\\t\\t\\telse id = chars[j]-\\'A\\';\\n\\t\\t\\t\\tNode next = now.next[id];\\n\\t\\t\\t\\tif(next == null) {\\n\\t\\t\\t\\t\\tnow.next[id] = new Node(chars[j]);\\n\\t\\t\\t\\t\\tnext = now.next[id];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnow = next;\\n\\t\\t\\t}\\n\\t\\t\\tif(!now.flag) {//\\u68C0\\u67E5\\u662F\\u5426\\u5DF2\\u7ECF\\u88AB\\u521D\\u59CB\\u5316\\n\\t\\t\\t\\tnow.flag = true;\\n\\t\\t\\t\\tnow.index = i;\\n\\t\\t\\t}\\n\\t\\t\\tnow = root;//\\u91CD\\u65B0\\u7EC4\\u7EC7\\u4E0B\\u4E00\\u4E2A\\u5355\\u8BCD\\n\\t\\t}\\n\\t\\t\\n\\t}\\n\\t//\\u5B8C\\u5168\\u5339\\u914D\\n\\tprivate int matchSearch(String word,Node root) {\\n\\t\\tNode now = root;\\n\\t\\tfor(int i = 0;i < word.length();++i) {\\n\\t\\t\\tchar c = word.charAt(i);\\n\\t\\t\\tint id = c >= \\'a\\'?26+c-\\'a\\':c-\\'A\\';\\n\\t\\t\\tNode next = now.next[id];\\n\\t\\t\\tif(next == null) return -1;//\\u8868\\u793A\\u6CA1\\u6709\\u5339\\u914D\\u4E0A\\n\\t\\t\\tnow = next;\\n\\t\\t}\\n\\t\\treturn now.flag?now.index:-1;//\\u5982\\u679C\\u8FD9\\u4E2A\\u8BCD\\u662F\\u5355\\u8BCD \\u5C31\\u8FD4\\u56DE\\u4E0B\\u6807 \\u5426\\u5219\\u6CA1\\u6709\\u5339\\u914D\\u4E0A\\n\\t}\\n\\t\\n\\t//\\u6A21\\u7CCA\\u66FF\\u6362\\n\\tprivate int likeSearch(char[] word,Node root,int index) {\\n\\t\\tif(index == word.length) return root.flag?root.index:Integer.MAX_VALUE;//\\u5982\\u679C\\u8FD9\\u4E2A\\u8BCD\\u662F\\u5355\\u8BCD \\u5C31\\u8FD4\\u56DE\\u4E0B\\u6807 \\u5426\\u5219\\u6CA1\\u6709\\u5339\\u914D\\u4E0A\\n\\t\\tint may = word[index] >= \\'a\\' ? word[index]-\\'a\\' : word[index]-\\'A\\'+26;\\n\\t\\tint now = word[index] >= \\'a\\' ? word[index]-\\'a\\'+26 : word[index]-\\'A\\';\\n\\t\\tint res = Integer.MAX_VALUE;\\n\\t\\tNode next = root.next[now];\\n\\t\\tif(next != null) {//\\u6709\\u8FD9\\u4E2A\\u8282\\u70B9\\n\\t\\t\\tres = likeSearch(word, next, index+1);\\n\\t\\t}\\n\\t\\tnext = root.next[may];\\n\\t\\tif(next != null) {//\\u6709\\u8FD9\\u4E2A\\u8282\\u70B9\\n\\t\\t\\tres = Math.min(res, likeSearch(word, next, index+1));\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\t//\\u5143\\u97F3\\u66FF\\u6362\\n\\tprivate int vowelSearch(char[] word,Node root,int index) {\\n\\t\\tif(index == word.length) return root.flag?root.index:Integer.MAX_VALUE;//\\u5982\\u679C\\u8FD9\\u4E2A\\u8BCD\\u662F\\u5355\\u8BCD \\u5C31\\u8FD4\\u56DE\\u4E0B\\u6807 \\u5426\\u5219\\u6CA1\\u6709\\u5339\\u914D\\u4E0A\\n\\t\\tint res = Integer.MAX_VALUE;\\n\\t\\tif(word[index] == \\'a\\'||word[index] == \\'e\\'||word[index] == \\'i\\'||word[index] == \\'o\\'|| word[index] == \\'u\\'||\\n\\t\\t\\t\\tword[index] == \\'A\\'||word[index] == \\'E\\'||word[index] == \\'I\\'||word[index] == \\'O\\'||word[index] == \\'U\\') {\\n\\t\\t\\tint[] may = new int[] {26,30,34,40,46,0,4,8,14,20};\\n\\t\\t\\tfor(int i:may) {\\n\\t\\t\\t\\tNode next = root.next[i];\\n\\t\\t\\t\\tif(next != null) res = Math.min(res, vowelSearch(word,next,index+1));\\n\\t\\t\\t}\\n\\t\\t}else{//\\u5426\\u5219\\u4E0D\\u662F\\u5143\\u97F3\\u5B57\\u6BCD \\u4EC5\\u89E6\\u53D1\\u5927\\u5C0F\\u5199\\u654F\\u611F\\u5339\\u914D\\n\\t\\t\\tint may = word[index] >= \\'a\\' ? word[index]-\\'a\\' : word[index]-\\'A\\'+26;\\n\\t\\t\\tint now = word[index] >= \\'a\\' ? word[index]-\\'a\\'+26 : word[index]-\\'A\\';\\n\\t\\t\\tNode next = root.next[now];\\n\\t\\t\\tif(next != null) {\\n\\t\\t\\t\\tres = vowelSearch(word, next, index+1);\\n\\t\\t\\t}\\n\\t\\t\\tnext = root.next[may];\\n\\t\\t\\tif(next != null) {//\\u6709\\u8FD9\\u4E2A\\u8282\\u70B9\\n\\t\\t\\t\\tres = Math.min(res, vowelSearch(word, next, index+1));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\t\\n\\t\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1121785,
                "title": "vowel-spellchecker-c-easy-solution-clean-code-using-unordered-maps",
                "content": "**Please Upvote** if you find it helpful\\n```\\nclass Solution {\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        unordered_map<string, string> c;\\n        unordered_map<string, string> v;\\n        unordered_set<string> s1;\\n        for(string word: wordlist) {\\n            s1.insert(word);\\n            string temp = tolowerAlpha(word);\\n            if(c.find(temp) == c.end()) c[temp] = word;\\n            if(v.find(removeVowels(temp)) == v.end()) v[removeVowels(temp)] = word;\\n        }\\n        vector<string> res;\\n        for(string s: queries) {\\n            string temp = tolowerAlpha(s);\\n            if(s1.find(s) != s1.end()) res.push_back(s);\\n            else if(c.find(temp) != c.end()) res.push_back(c[temp]);\\n            else if(v.find(removeVowels(temp)) != v.end()) res.push_back(v[removeVowels(temp)]);\\n            else res.push_back(\"\");\\n        }\\n        return res;\\n    }\\n    string removeVowels(string s) {\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'o\\' || s[i] == \\'u\\' || s[i] == \\'i\\') s[i] = \\'*\\';\\n        }\\n        return s;\\n    }\\n    string tolowerAlpha(string s) {\\n        string str;\\n        for(char c: s) str += tolower(c);\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        unordered_map<string, string> c;\\n        unordered_map<string, string> v;\\n        unordered_set<string> s1;\\n        for(string word: wordlist) {\\n            s1.insert(word);\\n            string temp = tolowerAlpha(word);\\n            if(c.find(temp) == c.end()) c[temp] = word;\\n            if(v.find(removeVowels(temp)) == v.end()) v[removeVowels(temp)] = word;\\n        }\\n        vector<string> res;\\n        for(string s: queries) {\\n            string temp = tolowerAlpha(s);\\n            if(s1.find(s) != s1.end()) res.push_back(s);\\n            else if(c.find(temp) != c.end()) res.push_back(c[temp]);\\n            else if(v.find(removeVowels(temp)) != v.end()) res.push_back(v[removeVowels(temp)]);\\n            else res.push_back(\"\");\\n        }\\n        return res;\\n    }\\n    string removeVowels(string s) {\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'o\\' || s[i] == \\'u\\' || s[i] == \\'i\\') s[i] = \\'*\\';\\n        }\\n        return s;\\n    }\\n    string tolowerAlpha(string s) {\\n        string str;\\n        for(char c: s) str += tolower(c);\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 422504,
                "title": "easy-to-understand-c-solution-72ms-beats-95",
                "content": "Runtime: 72 ms, faster than 95.52% of C++ online submissions for Vowel Spellchecker.\\nMemory Usage: 28.7 MB, less than 100.00% of C++ online submissions for Vowel Spellchecker.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        \\n        vector<string> res(queries.size(), \"\");\\n        int n = queries.size();\\n        unordered_set<string> words;\\n        unordered_map<string, string> ignoreCase;\\n        unordered_map<string, string> vowels;\\n        \\n        for(int i=0; i<wordlist.size(); i++)\\n        {\\n            words.insert(wordlist[i]);\\n            string temp = wordlist[i];\\n            \\n            transform(temp.begin(), temp.end(), temp.begin(), ::tolower);\\n            if(ignoreCase.find(temp) == ignoreCase.end())\\n                ignoreCase[temp] = wordlist[i];\\n            \\n            for(auto& ch : temp)\\n            {\\n                if(isVowel(ch))\\n                    ch = \\'#\\';\\n            }\\n            \\n            if(vowels.find(temp) == vowels.end())\\n                vowels[temp] = wordlist[i];\\n        }\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            string check = queries[i];\\n            transform(check.begin(), check.end(), check.begin(), ::tolower);\\n            if(words.find(queries[i]) != words.end())\\n                res[i] = queries[i];\\n            else if(ignoreCase.find(check) != ignoreCase.end())\\n                res[i] = ignoreCase[check];\\n            else \\n            {\\n                for(auto& ch : check)\\n                {\\n                    if(isVowel(ch))\\n                        ch = \\'#\\';\\n                }\\n                \\n                if(vowels.find(check) != vowels.end())\\n                    res[i] = vowels[check];\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    bool isVowel(char ch)\\n    {\\n        switch(ch)\\n        {\\n            case \\'a\\':\\n            case \\'e\\':\\n            case \\'i\\':\\n            case \\'o\\':\\n            case \\'u\\':\\n                return true;\\n                break;\\n            default:\\n                return false;\\n            \\n            return false;\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        \\n        vector<string> res(queries.size(), \"\");\\n        int n = queries.size();\\n        unordered_set<string> words;\\n        unordered_map<string, string> ignoreCase;\\n        unordered_map<string, string> vowels;\\n        \\n        for(int i=0; i<wordlist.size(); i++)\\n        {\\n            words.insert(wordlist[i]);\\n            string temp = wordlist[i];\\n            \\n            transform(temp.begin(), temp.end(), temp.begin(), ::tolower);\\n            if(ignoreCase.find(temp) == ignoreCase.end())\\n                ignoreCase[temp] = wordlist[i];\\n            \\n            for(auto& ch : temp)\\n            {\\n                if(isVowel(ch))\\n                    ch = \\'#\\';\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 309063,
                "title": "java-hashmap",
                "content": "```java\\nclass Solution {\\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        Set<String> set = new HashSet<>();\\n        Map<String, Integer> map1 = new HashMap<>();\\n        Map<String, Integer> map2 = new HashMap<>();\\n\\n        for (int i = 0; i < wordlist.length; i++) {\\n            String w = wordlist[i];\\n            set.add(w);\\n            map1.putIfAbsent(w.toLowerCase(), i);\\n            map2.putIfAbsent(maskVowels(w.toLowerCase()), i);\\n        }\\n\\n        String[] ans = new String[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            String w = queries[i];\\n            if (set.contains(w)) {\\n                ans[i] = w;\\n                continue;\\n            }\\n\\n            w = w.toLowerCase();\\n            if (map1.containsKey(w)) {\\n                ans[i] = wordlist[map1.get(w)];\\n                continue;\\n            } \\n            \\n            w = maskVowels(w);\\n            if (map2.containsKey(w)) {\\n                ans[i] = wordlist[map2.get(w)];\\n            } else {\\n                ans[i] = \"\";\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private String maskVowels(String s) {\\n        char[] chars = s.toCharArray();\\n        for (int i = 0; i < chars.length; i++) {\\n            if (isVowel(chars[i])) {\\n                chars[i] = \\'*\\';\\n            }\\n        }\\n        return String.valueOf(chars);\\n    }\\n\\n    private boolean isVowel(char c) {\\n        c = Character.toLowerCase(c);\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        Set<String> set = new HashSet<>();\\n        Map<String, Integer> map1 = new HashMap<>();\\n        Map<String, Integer> map2 = new HashMap<>();\\n\\n        for (int i = 0; i < wordlist.length; i++) {\\n            String w = wordlist[i];\\n            set.add(w);\\n            map1.putIfAbsent(w.toLowerCase(), i);\\n            map2.putIfAbsent(maskVowels(w.toLowerCase()), i);\\n        }\\n\\n        String[] ans = new String[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            String w = queries[i];\\n            if (set.contains(w)) {\\n                ans[i] = w;\\n                continue;\\n            }\\n\\n            w = w.toLowerCase();\\n            if (map1.containsKey(w)) {\\n                ans[i] = wordlist[map1.get(w)];\\n                continue;\\n            } \\n            \\n            w = maskVowels(w);\\n            if (map2.containsKey(w)) {\\n                ans[i] = wordlist[map2.get(w)];\\n            } else {\\n                ans[i] = \"\";\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private String maskVowels(String s) {\\n        char[] chars = s.toCharArray();\\n        for (int i = 0; i < chars.length; i++) {\\n            if (isVowel(chars[i])) {\\n                chars[i] = \\'*\\';\\n            }\\n        }\\n        return String.valueOf(chars);\\n    }\\n\\n    private boolean isVowel(char c) {\\n        c = Character.toLowerCase(c);\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2912261,
                "title": "python-3-14-lines-w-comments-t-m-95-74",
                "content": "```\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n\\n        f = lambda x: \\'\\'.join(\\'$\\' if ch in \\'aeiou\\' else ch for ch in x)\\n        cap, vow = defaultdict(str), defaultdict(str)\\n        word_set, ans = set(wordlist), []\\n        \\n        for w in wordlist:                      # Build the dicts\\n\\n            wLow = w.lower()\\n            if not cap[wLow]: cap[wLow] = w     # <\\u2013\\u2013 Case 1: capital-check\\n\\n            wVow = f(wLow)\\n            if not vow[wVow]: vow[wVow] = w     # <\\u2013\\u2013 Case 2: vowel-check\\n\\n        for q in queries:\\n            qLow, qVow, res = q.lower(), f(q.lower()), \\'\\'\\n\\n            if q in word_set: res = q           # <\\u2013\\u2013 word is in wordlist\\n            elif qLow in cap: res = cap[qLow]   # <\\u2013\\u2013 cap-checked word is in wordlist\\n            elif qVow in vow: res = vow[qVow]   # <\\u2013\\u2013 vowel-checked word is in wordlist\\n\\n            ans.append(res)\\n```\\n[https://leetcode.com/problems/vowel-spellchecker/submissions/859821635/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n\\n        f = lambda x: \\'\\'.join(\\'$\\' if ch in \\'aeiou\\' else ch for ch in x)\\n        cap, vow = defaultdict(str), defaultdict(str)\\n        word_set, ans = set(wordlist), []\\n        \\n        for w in wordlist:                      # Build the dicts\\n\\n            wLow = w.lower()\\n            if not cap[wLow]: cap[wLow] = w     # <\\u2013\\u2013 Case 1: capital-check\\n\\n            wVow = f(wLow)\\n            if not vow[wVow]: vow[wVow] = w     # <\\u2013\\u2013 Case 2: vowel-check\\n\\n        for q in queries:\\n            qLow, qVow, res = q.lower(), f(q.lower()), \\'\\'\\n\\n            if q in word_set: res = q           # <\\u2013\\u2013 word is in wordlist\\n            elif qLow in cap: res = cap[qLow]   # <\\u2013\\u2013 cap-checked word is in wordlist\\n            elif qVow in vow: res = vow[qVow]   # <\\u2013\\u2013 vowel-checked word is in wordlist\\n\\n            ans.append(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1719212,
                "title": "simple-java-solution-using-hashmap-and-hashset",
                "content": "class Solution {\\n    \\n\\tSet<Character> vowel = Set.of(\\'a\\' , \\'e\\' , \\'i\\' , \\'o\\' , \\'u\\');\\n    \\n    public String convert(String s){ //convert the string for vowel match\\n        StringBuilder res = new StringBuilder();\\n        \\n        for(char ch : s.toCharArray())\\n            res.append(vowel.contains(ch) ? \\'*\\' : ch);\\n        \\n        return res.toString();\\n    }\\n    \\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        \\n\\t\\tSet<String> compMatch = new HashSet<>();//for complete matching of string\\n        HashMap<String , String> caseMatch = new HashMap<>();//for case match, only first such string is stored\\n        HashMap<String , String> vowelMatch = new HashMap<>();//;//for vowel  match , only first such string is stored\\n        \\n        for(String word : wordlist){\\n\\t\\t\\tcompMatch.add(word);\\n            caseMatch.putIfAbsent(word.toLowerCase() , word);\\n            vowelMatch.putIfAbsent(convert(word.toLowerCase()) , word);\\n        }\\n        \\n        String[] res = new String[queries.length];\\n        \\n        for(int i = 0 ; i < queries.length ; i++){\\n           \\n\\t\\t   if(compMatch.contains(queries[i]))//first precendence\\n                res[i] = queries[i];\\n            \\n\\t\\t\\tqueries[i] = queries[i].toLowerCase(); // next two cases require string to be in lower case\\n\\t\\t\\t\\n\\t\\t\\telse if(caseMatch.containsKey(queries[i])) // second precedence\\n                res[i] = caseMatch.get(queries[i]);\\n           \\n\\t\\t   else\\n                res[i] = vowelMatch.getOrDefault(convert(queries[i]) , \"\"); // third precedence or \"\"\\n        \\n\\t\\t}\\n        \\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n\\tSet<Character> vowel = Set.of(\\'a\\' , \\'e\\' , \\'i\\' , \\'o\\' , \\'u\\');\\n    \\n    public String convert(String s){ //convert the string for vowel match\\n        StringBuilder res = new StringBuilder();\\n        \\n        for(char ch : s.toCharArray())\\n            res.append(vowel.contains(ch) ? \\'*\\' : ch);\\n        \\n        return res.toString();\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1698913,
                "title": "easy-c-solution-using-hashing",
                "content": "**Approach to apply the rules:-**\\n1.  We can maintain an unordered_set of words in wordlist to check wheather the query exactly matches a word in the wordlist (case-sensitive) or not.\\n2.  We can maintain an unordered_map where key would be strings of worldlist after converting to uppercase and value would be corresponding index. Now while processing the queries if we convert query into uppercase and then find in map we can case-insensitively search in O(1) time.\\n3.  We can maintain an unordered_map where key would be strings of worldlist after ignoring the vowels and converting into uppercase. We can ignore the vowels as in rule 3 they have said we can change the vowel to any other vowel and search. So basically vowels do not matter in searching in rule 3.\\n\\n**Code:-**\\n```\\nclass Solution \\n{\\npublic:\\n    // Function to convert a string to uppercase\\n    string upperCaseConvertor(string &s) {\\n        string tmp=\"\";\\n        for(int i=0;i<s.length();i++) {\\n            tmp.push_back((s[i]>=\\'a\\' && s[i]<=\\'z\\')?s[i]-32:s[i]);\\n        }\\n        return tmp;\\n    }\\n    \\n    // This function puts \\'*\\' at the place of vowel and after that converts it to uppercase\\n    string vowelRemover(string &s,unordered_set<char>&vowel) {\\n        string tmp=\"\";\\n        for(int i=0;i<s.length();i++) {\\n            if(vowel.find(s[i])!=vowel.end()) {\\n                tmp.push_back(\\'*\\');\\n            }\\n            else {\\n                tmp.push_back(s[i]);\\n            }\\n        }\\n        return upperCaseConvertor(tmp);\\n    }\\n    \\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) \\n    {\\n        // \\'ans\\' will store the answer\\n        vector<string>ans;\\n        \\n        // \\'captalize\\' is an unordered_map where the key is string of wordlist in uppercase and value is the corresponding index. \\n        // This unordered_map is used to find if the query matches a word in the wordlist (case-insensitive) in O(1) time.\\n        \\n        \\n        // \\'error\\' is an unordered_map where the key is string of wordlist after passing through \\'vowelRemover\\' function and value is the corresponding index\\n        // This unordered_map is used to find wheather after replacing the vowels (\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\') of the query word with any vowel individually, it matches a word in the wordlist (case-insensitive) or not in O(1) time\\n        unordered_map<string,int>capitalize,error;\\n        \\n        // \\'exact\\' is a set of all words in wordlist to search in O(1) time\\n        unordered_set<string>exact(wordlist.begin(),wordlist.end());\\n        \\n        // list of vowels to check wheather a character is vowel or not.\\n        unordered_set<char>vowel={\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\'};\\n        \\n        // populate the maps\\n        for(int i=0;i<wordlist.size();i++) {\\n            string vr=vowelRemover(wordlist[i],vowel);\\n            if(error.find(vr)==error.end()) {\\n                error[vr]=i;\\n            }\\n            vr=upperCaseConvertor(wordlist[i]);\\n            if(capitalize.find(vr)==capitalize.end()) {\\n                capitalize[vr]=i;\\n            }\\n        }\\n        \\n        // Iterate over the queries and apply spell-checking rules\\n        for(auto it:queries) \\n        {\\n            string tmp=upperCaseConvertor(it);\\n            string vr=vowelRemover(it,vowel);\\n            \\n            // When the query exactly matches a word in the wordlist (case-sensitive), you should return the same word back.\\n            if(exact.find(it)!=exact.end()) \\n            {\\n                ans.push_back(it);\\n            }\\n            \\n            // When the query matches a word up to capitlization, you should return the first such match in the wordlist.\\n            else if(capitalize.find(tmp)!=capitalize.end()) \\n            {\\n                ans.push_back(wordlist[capitalize[tmp]]);\\n            }\\n            \\n            // When the query matches a word up to vowel errors, you should return the first such match in the wordlist.\\n            else if(error.find(vr)!=error.end()) \\n            {\\n                ans.push_back(wordlist[error[vr]]);\\n            }\\n            \\n            // If the query has no matches in the wordlist, you should return the empty string.\\n            else \\n            {\\n                ans.push_back(\"\");\\n            }\\n        }\\n        \\n        // finally return the answer\\n        return ans;\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    // Function to convert a string to uppercase\\n    string upperCaseConvertor(string &s) {\\n        string tmp=\"\";\\n        for(int i=0;i<s.length();i++) {\\n            tmp.push_back((s[i]>=\\'a\\' && s[i]<=\\'z\\')?s[i]-32:s[i]);\\n        }\\n        return tmp;\\n    }\\n    \\n    // This function puts \\'*\\' at the place of vowel and after that converts it to uppercase\\n    string vowelRemover(string &s,unordered_set<char>&vowel) {\\n        string tmp=\"\";\\n        for(int i=0;i<s.length();i++) {\\n            if(vowel.find(s[i])!=vowel.end()) {\\n                tmp.push_back(\\'*\\');\\n            }\\n            else {\\n                tmp.push_back(s[i]);\\n            }\\n        }\\n        return upperCaseConvertor(tmp);\\n    }\\n    \\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) \\n    {\\n        // \\'ans\\' will store the answer\\n        vector<string>ans;\\n        \\n        // \\'captalize\\' is an unordered_map where the key is string of wordlist in uppercase and value is the corresponding index. \\n        // This unordered_map is used to find if the query matches a word in the wordlist (case-insensitive) in O(1) time.\\n        \\n        \\n        // \\'error\\' is an unordered_map where the key is string of wordlist after passing through \\'vowelRemover\\' function and value is the corresponding index\\n        // This unordered_map is used to find wheather after replacing the vowels (\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\') of the query word with any vowel individually, it matches a word in the wordlist (case-insensitive) or not in O(1) time\\n        unordered_map<string,int>capitalize,error;\\n        \\n        // \\'exact\\' is a set of all words in wordlist to search in O(1) time\\n        unordered_set<string>exact(wordlist.begin(),wordlist.end());\\n        \\n        // list of vowels to check wheather a character is vowel or not.\\n        unordered_set<char>vowel={\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\'};\\n        \\n        // populate the maps\\n        for(int i=0;i<wordlist.size();i++) {\\n            string vr=vowelRemover(wordlist[i],vowel);\\n            if(error.find(vr)==error.end()) {\\n                error[vr]=i;\\n            }\\n            vr=upperCaseConvertor(wordlist[i]);\\n            if(capitalize.find(vr)==capitalize.end()) {\\n                capitalize[vr]=i;\\n            }\\n        }\\n        \\n        // Iterate over the queries and apply spell-checking rules\\n        for(auto it:queries) \\n        {\\n            string tmp=upperCaseConvertor(it);\\n            string vr=vowelRemover(it,vowel);\\n            \\n            // When the query exactly matches a word in the wordlist (case-sensitive), you should return the same word back.\\n            if(exact.find(it)!=exact.end()) \\n            {\\n                ans.push_back(it);\\n            }\\n            \\n            // When the query matches a word up to capitlization, you should return the first such match in the wordlist.\\n            else if(capitalize.find(tmp)!=capitalize.end()) \\n            {\\n                ans.push_back(wordlist[capitalize[tmp]]);\\n            }\\n            \\n            // When the query matches a word up to vowel errors, you should return the first such match in the wordlist.\\n            else if(error.find(vr)!=error.end()) \\n            {\\n                ans.push_back(wordlist[error[vr]]);\\n            }\\n            \\n            // If the query has no matches in the wordlist, you should return the empty string.\\n            else \\n            {\\n                ans.push_back(\"\");\\n            }\\n        }\\n        \\n        // finally return the answer\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123000,
                "title": "java-simple-and-easy-to-understand-solution-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n```\\nclass Solution {\\n    static Set<Character> VOWELS = new HashSet<>(Arrays.asList(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'));\\n    \\n    Set<String> setActualWord;\\n    Map<String, String> mapCaseInSensitiveWord;\\n    Map<String, String> mapVowelInSensitiveWord;\\n    \\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        setActualWord = new HashSet();\\n        mapCaseInSensitiveWord = new HashMap();\\n        mapVowelInSensitiveWord = new HashMap();\\n        \\n        for(String word : wordlist){\\n            \\n            //store the actual word\\n            setActualWord.add(word);\\n            \\n            //store the lowercase word to first found word, \\n            String wordLowerCase = word.toLowerCase();\\n            mapCaseInSensitiveWord.putIfAbsent(wordLowerCase, word);\\n            \\n            //replace the vowel in lowercase word with *,\\n            //store the first word\\n            String removedVowelWord = removeVowel(wordLowerCase);\\n            mapVowelInSensitiveWord.putIfAbsent(removedVowelWord, word);\\n        }\\n        \\n        \\n        String[] results = new String[queries.length];\\n        \\n        for(int i = 0; i < results.length; i++){\\n            results[i] = search(queries[i]);\\n        }\\n        \\n        return results;\\n    }\\n    \\n    private String search(String str){\\n        \\n        //return actual word, if found\\n        if(setActualWord.contains(str)) return str;\\n        \\n        String strLowerCase = str.toLowerCase();\\n        \\n        //return first word, if it lower case word found\\n        if(mapCaseInSensitiveWord.containsKey(strLowerCase)) \\n            return mapCaseInSensitiveWord.get(strLowerCase);\\n        \\n        //return first word, if it vowel in sensitive  word found of lower case \\n        String removedVowel = removeVowel(strLowerCase);\\n        if(mapVowelInSensitiveWord.containsKey(removedVowel))\\n            return mapVowelInSensitiveWord.get(removedVowel);\\n        \\n        //otherwise return empty string\\n        return \"\";\\n    }\\n    \\n    private String removeVowel(String str){\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(char c : str.toCharArray()){\\n            sb.append(VOWELS.contains(c) ? \\'*\\' : c);\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static Set<Character> VOWELS = new HashSet<>(Arrays.asList(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'));\\n    \\n    Set<String> setActualWord;\\n    Map<String, String> mapCaseInSensitiveWord;\\n    Map<String, String> mapVowelInSensitiveWord;\\n    \\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        setActualWord = new HashSet();\\n        mapCaseInSensitiveWord = new HashMap();\\n        mapVowelInSensitiveWord = new HashMap();\\n        \\n        for(String word : wordlist){\\n            \\n            //store the actual word\\n            setActualWord.add(word);\\n            \\n            //store the lowercase word to first found word, \\n            String wordLowerCase = word.toLowerCase();\\n            mapCaseInSensitiveWord.putIfAbsent(wordLowerCase, word);\\n            \\n            //replace the vowel in lowercase word with *,\\n            //store the first word\\n            String removedVowelWord = removeVowel(wordLowerCase);\\n            mapVowelInSensitiveWord.putIfAbsent(removedVowelWord, word);\\n        }\\n        \\n        \\n        String[] results = new String[queries.length];\\n        \\n        for(int i = 0; i < results.length; i++){\\n            results[i] = search(queries[i]);\\n        }\\n        \\n        return results;\\n    }\\n    \\n    private String search(String str){\\n        \\n        //return actual word, if found\\n        if(setActualWord.contains(str)) return str;\\n        \\n        String strLowerCase = str.toLowerCase();\\n        \\n        //return first word, if it lower case word found\\n        if(mapCaseInSensitiveWord.containsKey(strLowerCase)) \\n            return mapCaseInSensitiveWord.get(strLowerCase);\\n        \\n        //return first word, if it vowel in sensitive  word found of lower case \\n        String removedVowel = removeVowel(strLowerCase);\\n        if(mapVowelInSensitiveWord.containsKey(removedVowel))\\n            return mapVowelInSensitiveWord.get(removedVowel);\\n        \\n        //otherwise return empty string\\n        return \"\";\\n    }\\n    \\n    private String removeVowel(String str){\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(char c : str.toCharArray()){\\n            sb.append(VOWELS.contains(c) ? \\'*\\' : c);\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382748,
                "title": "two-solutions-99-beat-java-amazon",
                "content": "**Using multiple maps**\\n\\n```\\n\\n/**\\n * As we need to match the string to wordlist, we need to find the efficient way to match those string by keeping the precedence of matching in mind\\n * There are three rules\\n * 1. When the query exactly matches a word in the wordlist (case-sensitive), you should return the same word back. : Means we need to search query in wordlist with exact match\\n * 2. When the query matches a word up to capitalization, you should return the first such match in the wordlist.: Means we need to search query in wordlist with canalization match\\n * 3. When the query matches a word up to vowel errors, you should return the first such match in the wordlist. : means we need to replace vowel if possible and then match\\n * 4. One way would be finding all three kind of string and then match. To keep and search efficiently, we an use hashmaps.\\n * <p>\\n * Algo:\\n * 1. Build all three kind of hashmaps\\n * 2. for every query, search in all three maps by above precedence rules and return.\\n * <p>\\n * To match for vowels error, we need to change the vowel to matched vowel, but keep changing at everytime cost lot of computation. So we hash those string which has vowels.\\n * <p>\\n * Time complexity: Assuming hashmap search is O(1), w is length of wordList, wl is length of longest word in word list,  q is length of query, ql is length of longest query\\n * Step 1:  O(wl*w) ;\\n * Step 2: O(ql * q)\\n * Overall : O(wl*w) + O(ql*q)\\n * <p>\\n * Space: O(3*w) => O(w)\\n * Runtime: 52 ms, faster than 42.40% of Java online submissions for Vowel Spellchecker.\\n * Memory Usage: 45.7 MB, less than 100.00% of Java online submissions for Vowel Spellchecker.\\n */\\nclass VowelSpellcheckerUsingMap {\\n\\n    public String[] spellchecker(String[] wordList, String[] queries) {\\n\\n        if (wordList == null || wordList.length == 0 || queries == null || queries.length == 0)\\n            return null;\\n\\n        //Build hashmaps\\n        final Map<String, String> exactMatch = new HashMap<>();\\n        final Map<String, String> capMatch = new HashMap<>();\\n        final Map<String, String> vowelMatch = new HashMap<>();\\n\\n        for (String word : wordList) {\\n            //1. When the query exactly matches a word in the wordlist (case-sensitive), you should return the same word back. : Means we need to search query in wordlist with exact match\\n            // O(1)\\n            exactMatch.putIfAbsent(word, word);\\n\\n            //2. When the query matches a word up to capitalization, you should return the first such match in the wordlist.: Means we need to search query in wordlist with canalization match\\n            //O(wl); since to lowercase take O(wl) time\\n            capMatch.putIfAbsent(word.toLowerCase(), word);\\n\\n            // 3. When the query matches a word up to vowel errors, you should return the first such match in the wordlist. : means we need to replace vowel if possible and then match\\n            // O(wl); since to hash take O(wl) time\\n            vowelMatch.putIfAbsent(hash(word.toLowerCase()), word);\\n\\n        }\\n\\n        //Search through query\\n        final String[] result = new String[queries.length];\\n        int index = 0;\\n        for (String query : queries)\\n            result[index++] = search(query, exactMatch, capMatch, vowelMatch);\\n\\n        return result;\\n\\n\\n    }\\n\\n    //O(ql)\\n    private String search(String query, Map<String, String> exactMatch, Map<String, String> capMatch, Map<String, String> vowelMatch) {\\n        //1. When the query exactly matches a word in the wordlist (case-sensitive), you should return the same word back.\\n        //O(1)\\n        if (exactMatch.containsKey(query))\\n            return query;\\n\\n        //2. When the query matches a word up to capitalization, you should return the first such match in the wordlist.\\n        //O(ql); since to lowercase take O(ql) time\\n        String temp = query.toLowerCase();\\n        if (capMatch.containsKey(temp))\\n            return capMatch.get(temp);\\n\\n        // 3. When the query matches a word up to vowel errors, you should return the first such match in the wordlist.\\n        //O(ql); since to hash take O(ql) time\\n        if ((temp = vowelMatch.get(hash(temp))) != null)\\n            return temp;\\n\\n\\n        return \"\";\\n\\n    }\\n\\n    private String hash(String word) {\\n        return word.replaceAll(\"[aeiou]\", \"a\");\\n    }\\n\\n}\\n\\n\\n```\\n\\n**Using single map and list**\\n\\n```\\n\\n\\n/**\\n * Same as above, but collect the words in list instead different map\\n * <p>\\n * Runtime: 15 ms, faster than 99.16% of Java online submissions for Vowel Spellchecker.\\n * Memory Usage: 40.7 MB, less than 100.00% of Java online submissions for Vowel Spellchecker.\\n */\\nclass VowelSpellcheckerUsingMap2 {\\n\\n    final char[] vowels = new char[]{\\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n\\n    public String[] spellchecker(String[] wordList, String[] queries) {\\n\\n        if (wordList == null || wordList.length == 0 || queries == null || queries.length == 0)\\n            return null;\\n\\n        //Build hashmaps\\n        final Map<String, List<String>> map = new HashMap<>();\\n\\n        for (String word : wordList) {\\n            String hash = hash(word);\\n            if (!map.containsKey(hash))\\n                map.put(hash, new ArrayList<>());\\n            map.get(hash).add(word);\\n\\n        }\\n\\n        //Search through query\\n        final String[] result = new String[queries.length];\\n        int index = 0;\\n        for (String query : queries)\\n            result[index++] = search(query, map);\\n\\n        return result;\\n\\n\\n    }\\n\\n    private String search(String query, Map<String, List<String>> map) {\\n        if (query == null || query.isEmpty())\\n            return query;\\n\\n        String tempQuery = hash(query);\\n\\n        //If the query has no matches in the wordlist, you should return the empty string.\\n        if (!map.containsKey(tempQuery))\\n            return \"\";\\n\\n        final List<String> words = map.get(tempQuery);\\n\\n        //1. When the query exactly matches a word in the wordlist (case-sensitive), you should return the same word back.\\n        for (String word : words) {\\n            if (word.equals(query))\\n                return word;\\n        }\\n\\n        ////2. When the query matches a word up to capitalization, you should return the first such match in the wordlist.\\n        for (String word : words) {\\n            if (word.toLowerCase().equals(query.toLowerCase()))\\n                return word;\\n\\n        }\\n\\n        // 3. When the query matches a word up to vowel errors, you should return the first such match in the wordlist.\\n        return words.get(0);\\n    }\\n\\n//This is slow\\n//    private String hash(String word) {\\n//        word = word.toLowerCase();\\n//        return word.replaceAll(\"[aeiou]\", \"a\");\\n//    }\\n\\n\\n   String hash(String word) {\\n        char[] hash = word.toLowerCase().toCharArray();\\n        for (int i = 0; i < hash.length; i++) {\\n            for (char vowel : vowels) {\\n                if (hash[i] == vowel) {\\n                    hash[i] = \\'a\\';\\n                    break;\\n                }\\n            }\\n        }\\n        return new String(hash);\\n    }\\n\\n}\\n\\n```\\n\\n`Never imagined that simple looping is faster than regex. `",
                "solutionTags": [],
                "code": "```\\n\\n/**\\n * As we need to match the string to wordlist, we need to find the efficient way to match those string by keeping the precedence of matching in mind\\n * There are three rules\\n * 1. When the query exactly matches a word in the wordlist (case-sensitive), you should return the same word back. : Means we need to search query in wordlist with exact match\\n * 2. When the query matches a word up to capitalization, you should return the first such match in the wordlist.: Means we need to search query in wordlist with canalization match\\n * 3. When the query matches a word up to vowel errors, you should return the first such match in the wordlist. : means we need to replace vowel if possible and then match\\n * 4. One way would be finding all three kind of string and then match. To keep and search efficiently, we an use hashmaps.\\n * <p>\\n * Algo:\\n * 1. Build all three kind of hashmaps\\n * 2. for every query, search in all three maps by above precedence rules and return.\\n * <p>\\n * To match for vowels error, we need to change the vowel to matched vowel, but keep changing at everytime cost lot of computation. So we hash those string which has vowels.\\n * <p>\\n * Time complexity: Assuming hashmap search is O(1), w is length of wordList, wl is length of longest word in word list,  q is length of query, ql is length of longest query\\n * Step 1:  O(wl*w) ;\\n * Step 2: O(ql * q)\\n * Overall : O(wl*w) + O(ql*q)\\n * <p>\\n * Space: O(3*w) => O(w)\\n * Runtime: 52 ms, faster than 42.40% of Java online submissions for Vowel Spellchecker.\\n * Memory Usage: 45.7 MB, less than 100.00% of Java online submissions for Vowel Spellchecker.\\n */\\nclass VowelSpellcheckerUsingMap {\\n\\n    public String[] spellchecker(String[] wordList, String[] queries) {\\n\\n        if (wordList == null || wordList.length == 0 || queries == null || queries.length == 0)\\n            return null;\\n\\n        //Build hashmaps\\n        final Map<String, String> exactMatch = new HashMap<>();\\n        final Map<String, String> capMatch = new HashMap<>();\\n        final Map<String, String> vowelMatch = new HashMap<>();\\n\\n        for (String word : wordList) {\\n            //1. When the query exactly matches a word in the wordlist (case-sensitive), you should return the same word back. : Means we need to search query in wordlist with exact match\\n            // O(1)\\n            exactMatch.putIfAbsent(word, word);\\n\\n            //2. When the query matches a word up to capitalization, you should return the first such match in the wordlist.: Means we need to search query in wordlist with canalization match\\n            //O(wl); since to lowercase take O(wl) time\\n            capMatch.putIfAbsent(word.toLowerCase(), word);\\n\\n            // 3. When the query matches a word up to vowel errors, you should return the first such match in the wordlist. : means we need to replace vowel if possible and then match\\n            // O(wl); since to hash take O(wl) time\\n            vowelMatch.putIfAbsent(hash(word.toLowerCase()), word);\\n\\n        }\\n\\n        //Search through query\\n        final String[] result = new String[queries.length];\\n        int index = 0;\\n        for (String query : queries)\\n            result[index++] = search(query, exactMatch, capMatch, vowelMatch);\\n\\n        return result;\\n\\n\\n    }\\n\\n    //O(ql)\\n    private String search(String query, Map<String, String> exactMatch, Map<String, String> capMatch, Map<String, String> vowelMatch) {\\n        //1. When the query exactly matches a word in the wordlist (case-sensitive), you should return the same word back.\\n        //O(1)\\n        if (exactMatch.containsKey(query))\\n            return query;\\n\\n        //2. When the query matches a word up to capitalization, you should return the first such match in the wordlist.\\n        //O(ql); since to lowercase take O(ql) time\\n        String temp = query.toLowerCase();\\n        if (capMatch.containsKey(temp))\\n            return capMatch.get(temp);\\n\\n        // 3. When the query matches a word up to vowel errors, you should return the first such match in the wordlist.\\n        //O(ql); since to hash take O(ql) time\\n        if ((temp = vowelMatch.get(hash(temp))) != null)\\n            return temp;\\n\\n\\n        return \"\";\\n\\n    }\\n\\n    private String hash(String word) {\\n        return word.replaceAll(\"[aeiou]\", \"a\");\\n    }\\n\\n}\\n\\n\\n```\n```\\n\\n\\n/**\\n * Same as above, but collect the words in list instead different map\\n * <p>\\n * Runtime: 15 ms, faster than 99.16% of Java online submissions for Vowel Spellchecker.\\n * Memory Usage: 40.7 MB, less than 100.00% of Java online submissions for Vowel Spellchecker.\\n */\\nclass VowelSpellcheckerUsingMap2 {\\n\\n    final char[] vowels = new char[]{\\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n\\n    public String[] spellchecker(String[] wordList, String[] queries) {\\n\\n        if (wordList == null || wordList.length == 0 || queries == null || queries.length == 0)\\n            return null;\\n\\n        //Build hashmaps\\n        final Map<String, List<String>> map = new HashMap<>();\\n\\n        for (String word : wordList) {\\n            String hash = hash(word);\\n            if (!map.containsKey(hash))\\n                map.put(hash, new ArrayList<>());\\n            map.get(hash).add(word);\\n\\n        }\\n\\n        //Search through query\\n        final String[] result = new String[queries.length];\\n        int index = 0;\\n        for (String query : queries)\\n            result[index++] = search(query, map);\\n\\n        return result;\\n\\n\\n    }\\n\\n    private String search(String query, Map<String, List<String>> map) {\\n        if (query == null || query.isEmpty())\\n            return query;\\n\\n        String tempQuery = hash(query);\\n\\n        //If the query has no matches in the wordlist, you should return the empty string.\\n        if (!map.containsKey(tempQuery))\\n            return \"\";\\n\\n        final List<String> words = map.get(tempQuery);\\n\\n        //1. When the query exactly matches a word in the wordlist (case-sensitive), you should return the same word back.\\n        for (String word : words) {\\n            if (word.equals(query))\\n                return word;\\n        }\\n\\n        ////2. When the query matches a word up to capitalization, you should return the first such match in the wordlist.\\n        for (String word : words) {\\n            if (word.toLowerCase().equals(query.toLowerCase()))\\n                return word;\\n\\n        }\\n\\n        // 3. When the query matches a word up to vowel errors, you should return the first such match in the wordlist.\\n        return words.get(0);\\n    }\\n\\n//This is slow\\n//    private String hash(String word) {\\n//        word = word.toLowerCase();\\n//        return word.replaceAll(\"[aeiou]\", \"a\");\\n//    }\\n\\n\\n   String hash(String word) {\\n        char[] hash = word.toLowerCase().toCharArray();\\n        for (int i = 0; i < hash.length; i++) {\\n            for (char vowel : vowels) {\\n                if (hash[i] == vowel) {\\n                    hash[i] = \\'a\\';\\n                    break;\\n                }\\n            }\\n        }\\n        return new String(hash);\\n    }\\n\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 221239,
                "title": "python-trie-bfs-solution",
                "content": "Not the best solution, but hope it can give you some inspire.\\n\\n```\\nclass Solution(object):\\n    def spellchecker(self, wordlist, queries):\\n        \"\"\"\\n        :type wordlist: List[str]\\n        :type queries: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        s = set(wordlist)\\n        trie = dict()\\n        res = []\\n        \\n        # build trie\\n        for i in range(len(wordlist))[::-1]:\\n            w = wordlist[i]\\n            cur = trie\\n            for c in w:\\n                if c not in cur:\\n                    cur[c] = dict()\\n                cur = cur[c]\\n            cur[\\'#\\'] = [i, w]\\n        \\n        for q in queries:\\n            # bfs\\n            que = [[0, trie]]\\n            for c in q:\\n                nex = []\\n                for order, node in que:\\n                    if c in node:\\n                        nex.append([max(0, order), node[c]])\\n                    if \\'a\\' <= c <= \\'z\\' and c.upper() in node:\\n                        nex.append([max(1, order), node[c.upper()]])\\n                    if \\'A\\' <= c <= \\'Z\\' and c.lower() in node:\\n                        nex.append([max(1, order), node[c.lower()]])\\n                    if c in \\'aeiouAEIOU\\':\\n                        for vowel in \\'aeiouAEIOU\\':\\n                            if vowel != c and vowel in node:\\n                                nex.append([max(2, order), node[vowel]])\\n                que = nex\\n            \\n            if que:\\n                order, index, w = sorted([[order, dic[\\'#\\'][0], dic[\\'#\\'][1]] for order, dic in que])[0]\\n                res.append(w)\\n            else:\\n                res.append(\"\")\\n        \\n        return res\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def spellchecker(self, wordlist, queries):\\n        \"\"\"\\n        :type wordlist: List[str]\\n        :type queries: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        s = set(wordlist)\\n        trie = dict()\\n        res = []\\n        \\n        # build trie\\n        for i in range(len(wordlist))[::-1]:\\n            w = wordlist[i]\\n            cur = trie\\n            for c in w:\\n                if c not in cur:\\n                    cur[c] = dict()\\n                cur = cur[c]\\n            cur[\\'#\\'] = [i, w]\\n        \\n        for q in queries:\\n            # bfs\\n            que = [[0, trie]]\\n            for c in q:\\n                nex = []\\n                for order, node in que:\\n                    if c in node:\\n                        nex.append([max(0, order), node[c]])\\n                    if \\'a\\' <= c <= \\'z\\' and c.upper() in node:\\n                        nex.append([max(1, order), node[c.upper()]])\\n                    if \\'A\\' <= c <= \\'Z\\' and c.lower() in node:\\n                        nex.append([max(1, order), node[c.lower()]])\\n                    if c in \\'aeiouAEIOU\\':\\n                        for vowel in \\'aeiouAEIOU\\':\\n                            if vowel != c and vowel in node:\\n                                nex.append([max(2, order), node[vowel]])\\n                que = nex\\n            \\n            if que:\\n                order, index, w = sorted([[order, dic[\\'#\\'][0], dic[\\'#\\'][1]] for order, dic in que])[0]\\n                res.append(w)\\n            else:\\n                res.append(\"\")\\n        \\n        return res\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 211516,
                "title": "share-my-trie-solution",
                "content": "Somehow I got WA by using hashset in the contest so I turned to use trie instead. I stored all characters in the word as nodes in trie, which means the trie needs to handle both lowercase and uppercase letters. So I assigned the ```nodes``` vector in trie with a length of 128 in order to contain all of those letters and got MLE at the end... In fact, just assign 52 elements in ```nodes``` is fine and should pass all test cases.\\n\\nIn ```find```, the rule of choosing query result is as below:\\n\\n1. If the query word exists in the wordlist, directly return the word.\\n2. If the candidate and query word are equal to each other (both converted into lowercase), return one candidate which has the smallest index.\\n3. If all candidate cannot match the query up to capialize, return one which has the smallest index.\\n4. If no candidate exist, return empty string. \\n\\n```C++\\nclass Solution {\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        Trie trie;\\n        for(int i = 0; i < wordlist.size(); ++i) {\\n            trie.add(wordlist[i], i);\\n        }\\n        vector<string> res;\\n        for(auto query : queries) {\\n            res.push_back(trie.find(query));\\n        }\\n        return res;\\n    }\\nprivate:\\n    class Trie {\\n    public:\\n        Trie() {\\n            for(int i = 0; i <= 54; ++i) nodes.push_back(NULL);\\n            word = \"\";\\n            index = INT_MAX;\\n        }\\n        void add(const string& word, int index) {\\n            auto current = this;\\n            for(int i = 0; i < word.size(); ++i) {\\n                if(current->nodes[getIndex(word[i])] == NULL) {\\n                    Trie* tmp = new Trie();\\n                    current->nodes[getIndex(word[i])] = tmp;\\n                }\\n                current = current->nodes[getIndex(word[i])];\\n            }\\n            current->word = word;\\n            current->index = min(index, current->index);\\n            return;\\n        }\\n        string find(const string& word) {\\n            auto current = this;\\n            queue<pair<Trie*, int>> que;\\n            que.push({current, 0});\\n            int pos = INT_MAX;\\n            string res = \"\";\\n            while(que.size() != 0) {\\n                auto tmp = que.front();\\n                que.pop();\\n                if(tmp.second == word.size()) {\\n                    if(tmp.first->word != \"\") {\\n                        if(tmp.first->word == word) {\\n                            return word;\\n                        }\\n                        else if(small(word) == small(tmp.first->word) && (small(word) != small(res) || tmp.first->index < pos)) {\\n                            res = tmp.first->word;\\n                            pos = tmp.first->index;\\n                        } \\n                        else if(small(res) != small(word) && tmp.first->index < pos) {\\n                            res = tmp.first->word;\\n                            pos = tmp.first->index;\\n                        }\\n                    }\\n                    else continue;\\n                }\\n                if(tmp.first->nodes[getIndex(word[tmp.second])] != NULL) {\\n                    que.push({tmp.first->nodes[getIndex(word[tmp.second])], tmp.second + 1});\\n                }\\n                if(\\'a\\' <= word[tmp.second] && word[tmp.second] <= \\'z\\' && tmp.first->nodes[getIndex(word[tmp.second] - \\'a\\' + \\'A\\')] != NULL) {\\n                    que.push({tmp.first->nodes[getIndex(word[tmp.second] - \\'a\\' + \\'A\\')], tmp.second + 1});\\n                }\\n                if(\\'A\\' <= word[tmp.second] && word[tmp.second] <= \\'Z\\' && tmp.first->nodes[getIndex(word[tmp.second] - \\'A\\' + \\'a\\')] != NULL) {\\n                    que.push({tmp.first->nodes[getIndex(word[tmp.second] - \\'A\\' + \\'a\\')], tmp.second + 1});\\n                }\\n                if(isVow(word[tmp.second])) {\\n                    for(auto vow : vows) {\\n                        if(tmp.first->nodes[getIndex(vow)] != NULL) {\\n                            que.push({tmp.first->nodes[getIndex(vow)], tmp.second + 1});\\n                        }\\n                    }\\n                }\\n            }\\n            return res;\\n        }\\n    private:\\n        vector<Trie*> nodes;\\n        string word;\\n        int index;\\n        bool isVow(char ch) {\\n            return vows.count(ch) != 0;\\n        }\\n        string small(string word) {\\n            for(auto &item : word) if(\\'A\\' <= item && item <= \\'Z\\') item = item - \\'A\\' + \\'a\\';\\n            return word;\\n        }\\n        int getIndex(char ch) {\\n            if(ch == 0) return 52;\\n            if(\\'a\\' <= ch && ch <= \\'z\\') return ch - \\'a\\';\\n            else return ch - \\'A\\' + 26;\\n        }\\n        unordered_set<char> vows = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\'};\\n    };\\n};\\n```",
                "solutionTags": [],
                "code": "```nodes```\n```nodes```\n```find```\n```C++\\nclass Solution {\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        Trie trie;\\n        for(int i = 0; i < wordlist.size(); ++i) {\\n            trie.add(wordlist[i], i);\\n        }\\n        vector<string> res;\\n        for(auto query : queries) {\\n            res.push_back(trie.find(query));\\n        }\\n        return res;\\n    }\\nprivate:\\n    class Trie {\\n    public:\\n        Trie() {\\n            for(int i = 0; i <= 54; ++i) nodes.push_back(NULL);\\n            word = \"\";\\n            index = INT_MAX;\\n        }\\n        void add(const string& word, int index) {\\n            auto current = this;\\n            for(int i = 0; i < word.size(); ++i) {\\n                if(current->nodes[getIndex(word[i])] == NULL) {\\n                    Trie* tmp = new Trie();\\n                    current->nodes[getIndex(word[i])] = tmp;\\n                }\\n                current = current->nodes[getIndex(word[i])];\\n            }\\n            current->word = word;\\n            current->index = min(index, current->index);\\n            return;\\n        }\\n        string find(const string& word) {\\n            auto current = this;\\n            queue<pair<Trie*, int>> que;\\n            que.push({current, 0});\\n            int pos = INT_MAX;\\n            string res = \"\";\\n            while(que.size() != 0) {\\n                auto tmp = que.front();\\n                que.pop();\\n                if(tmp.second == word.size()) {\\n                    if(tmp.first->word != \"\") {\\n                        if(tmp.first->word == word) {\\n                            return word;\\n                        }\\n                        else if(small(word) == small(tmp.first->word) && (small(word) != small(res) || tmp.first->index < pos)) {\\n                            res = tmp.first->word;\\n                            pos = tmp.first->index;\\n                        } \\n                        else if(small(res) != small(word) && tmp.first->index < pos) {\\n                            res = tmp.first->word;\\n                            pos = tmp.first->index;\\n                        }\\n                    }\\n                    else continue;\\n                }\\n                if(tmp.first->nodes[getIndex(word[tmp.second])] != NULL) {\\n                    que.push({tmp.first->nodes[getIndex(word[tmp.second])], tmp.second + 1});\\n                }\\n                if(\\'a\\' <= word[tmp.second] && word[tmp.second] <= \\'z\\' && tmp.first->nodes[getIndex(word[tmp.second] - \\'a\\' + \\'A\\')] != NULL) {\\n                    que.push({tmp.first->nodes[getIndex(word[tmp.second] - \\'a\\' + \\'A\\')], tmp.second + 1});\\n                }\\n                if(\\'A\\' <= word[tmp.second] && word[tmp.second] <= \\'Z\\' && tmp.first->nodes[getIndex(word[tmp.second] - \\'A\\' + \\'a\\')] != NULL) {\\n                    que.push({tmp.first->nodes[getIndex(word[tmp.second] - \\'A\\' + \\'a\\')], tmp.second + 1});\\n                }\\n                if(isVow(word[tmp.second])) {\\n                    for(auto vow : vows) {\\n                        if(tmp.first->nodes[getIndex(vow)] != NULL) {\\n                            que.push({tmp.first->nodes[getIndex(vow)], tmp.second + 1});\\n                        }\\n                    }\\n                }\\n            }\\n            return res;\\n        }\\n    private:\\n        vector<Trie*> nodes;\\n        string word;\\n        int index;\\n        bool isVow(char ch) {\\n            return vows.count(ch) != 0;\\n        }\\n        string small(string word) {\\n            for(auto &item : word) if(\\'A\\' <= item && item <= \\'Z\\') item = item - \\'A\\' + \\'a\\';\\n            return word;\\n        }\\n        int getIndex(char ch) {\\n            if(ch == 0) return 52;\\n            if(\\'a\\' <= ch && ch <= \\'z\\') return ch - \\'a\\';\\n            else return ch - \\'A\\' + 26;\\n        }\\n        unordered_set<char> vows = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\'};\\n    };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123447,
                "title": "javascript-easy-to-understand-from-4132ms-to-116ms",
                "content": "The key point for this problem is \"precedence rules\" in the description. I got 2 fail submissions since I haven\\'t noticed that.\\nWhen we realized that, the only thing we need to do is handling the two categories in the description and traversal for the answers.\\n\\n## SOLUTION 1\\n\\nHere, it\\'s pretty straightforward. We traversal the `queries`, and for each `query`, we check all the `wordlist` for the different matching rules.\\nFinally, we get the answers.\\n\\nSince we need to loop `wordlist` for all `queries`, so it\\'s really slow. I got 4132ms in a submission.\\n\\n```js\\nconst VOWEL = new Set([\"a\", \"e\", \"i\", \"o\", \"u\"]);\\n\\nconst isVower = (query, word) => {\\n  for (let i = 0; i < query.length; ++i) {\\n    if ((VOWEL.has(query[i]) && VOWEL.has(word[i])) || query[i] === word[i]) continue;\\n    return false;\\n  }\\n  return true;\\n};\\n\\nconst checker = (query, wordlist) => {\\n  let capital = \"\";\\n  let vowel = \"\";\\n\\n  for (let i = 0; i < wordlist.length; ++i) {\\n    const word = wordlist[i];\\n    if (query.length !== word.length) continue;\\n    if (word === query) return word;\\n    const lowerQuery = query.toLowerCase();\\n    const lowerWord = word.toLowerCase();\\n    if (!capital && lowerQuery === lowerWord) capital = word;\\n    if (!capital && !vowel && isVower(lowerQuery, lowerWord)) vowel = word;\\n  }\\n\\n  return capital || vowel;\\n};\\n\\nconst spellchecker = (wordlist, queries) => queries.map((query) => checker(query, wordlist));\\n```\\n\\n## SOLUTION 2\\n\\nTo make it efficient, we could use a map instead array which will make look-up operation much faster.\\nHere, we initialize the maps before we deal with the `queries`. And after that, we just need to traversal the `queries` and for each `query` just O(1) time to find the answer.\\nI got 116ms in a submission.\\n\\n```js\\nconst spellchecker = (wordlist, queries) => {\\n  const REG = /[aeiou]/g;\\n  const originSet = new Set();\\n  const spellMap = new Map();\\n\\n  wordlist.forEach((word) => {\\n    const lowerWord = word.toLowerCase();\\n    const vowelWord = lowerWord.replace(REG, \"_\");\\n    originSet.add(word);\\n    if (!spellMap.has(lowerWord)) spellMap.set(lowerWord, word);\\n    if (!spellMap.has(vowelWord)) spellMap.set(vowelWord, word);\\n  });\\n\\n  return queries.map((query) => {\\n    if (originSet.has(query)) return query;\\n    const lowerQuery = query.toLowerCase();\\n    if (spellMap.has(lowerQuery)) return spellMap.get(lowerQuery);\\n    const vowelQuery = lowerQuery.replace(REG, \"_\");\\n    if (spellMap.has(vowelQuery)) return spellMap.get(vowelQuery);\\n    return \"\";\\n  });\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst VOWEL = new Set([\"a\", \"e\", \"i\", \"o\", \"u\"]);\\n\\nconst isVower = (query, word) => {\\n  for (let i = 0; i < query.length; ++i) {\\n    if ((VOWEL.has(query[i]) && VOWEL.has(word[i])) || query[i] === word[i]) continue;\\n    return false;\\n  }\\n  return true;\\n};\\n\\nconst checker = (query, wordlist) => {\\n  let capital = \"\";\\n  let vowel = \"\";\\n\\n  for (let i = 0; i < wordlist.length; ++i) {\\n    const word = wordlist[i];\\n    if (query.length !== word.length) continue;\\n    if (word === query) return word;\\n    const lowerQuery = query.toLowerCase();\\n    const lowerWord = word.toLowerCase();\\n    if (!capital && lowerQuery === lowerWord) capital = word;\\n    if (!capital && !vowel && isVower(lowerQuery, lowerWord)) vowel = word;\\n  }\\n\\n  return capital || vowel;\\n};\\n\\nconst spellchecker = (wordlist, queries) => queries.map((query) => checker(query, wordlist));\\n```\n```js\\nconst spellchecker = (wordlist, queries) => {\\n  const REG = /[aeiou]/g;\\n  const originSet = new Set();\\n  const spellMap = new Map();\\n\\n  wordlist.forEach((word) => {\\n    const lowerWord = word.toLowerCase();\\n    const vowelWord = lowerWord.replace(REG, \"_\");\\n    originSet.add(word);\\n    if (!spellMap.has(lowerWord)) spellMap.set(lowerWord, word);\\n    if (!spellMap.has(vowelWord)) spellMap.set(vowelWord, word);\\n  });\\n\\n  return queries.map((query) => {\\n    if (originSet.has(query)) return query;\\n    const lowerQuery = query.toLowerCase();\\n    if (spellMap.has(lowerQuery)) return spellMap.get(lowerQuery);\\n    const vowelQuery = lowerQuery.replace(REG, \"_\");\\n    if (spellMap.has(vowelQuery)) return spellMap.get(vowelQuery);\\n    return \"\";\\n  });\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1123196,
                "title": "python-three-cases",
                "content": "```\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        def devo(word):\\n            return \\'\\'.join([\\'*\\' if ch.lower() in \\'aeiou\\' else ch.lower() for ch in word])\\n        \\n        # three hash map to handle three cases\\n        map_perfect = set(wordlist)\\n        map_case = defaultdict(list)\\n        \\n        for word in wordlist:\\n            map_case[word.lower()].append(word)\\n        \\n        map_vowel = defaultdict(list)\\n        for word in wordlist:\\n            map_vowel[devo(word)].append(word)\\n        \\n        res = []\\n        \\n        # driver\\n        def findWord(query):\\n            if query in map_perfect: return query\\n            if query.lower() in map_case: return map_case[query.lower()][0]\\n            wild_query = devo(query)\\n            if wild_query in map_vowel:\\n                return map_vowel.get(wild_query)[0]\\n            \\n            return \"\"\\n        \\n        for query in queries:\\n            res.append(findWord(query))\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        def devo(word):\\n            return \\'\\'.join([\\'*\\' if ch.lower() in \\'aeiou\\' else ch.lower() for ch in word])\\n        \\n        # three hash map to handle three cases\\n        map_perfect = set(wordlist)\\n        map_case = defaultdict(list)\\n        \\n        for word in wordlist:\\n            map_case[word.lower()].append(word)\\n        \\n        map_vowel = defaultdict(list)\\n        for word in wordlist:\\n            map_vowel[devo(word)].append(word)\\n        \\n        res = []\\n        \\n        # driver\\n        def findWord(query):\\n            if query in map_perfect: return query\\n            if query.lower() in map_case: return map_case[query.lower()][0]\\n            wild_query = devo(query)\\n            if wild_query in map_vowel:\\n                return map_vowel.get(wild_query)[0]\\n            \\n            return \"\"\\n        \\n        for query in queries:\\n            res.append(findWord(query))\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122542,
                "title": "python-3-dictionaries-translate-5-lines-144ms",
                "content": "# Set, 2 dictionaries, translate, 152ms\\n- To check if the query exactly matches a word in the wordlist we can use a set of words. Search is faster via set `O(1)` than via list `O(n)`.\\n- To check if the query matches a word up to capitlization we can use a dictionary of words indexed by normalized words. To normalize words we can just translate it into lower case, e.g `KakA->kaka`.\\n- To check if the query matches a word up to vowel errors we can use a dictionary of words indexed by normalized words. In this case to normalize words we can translate lowercased words into hidden-vowel words, e.g `KokA->k*k*`.\\n- To return the first match in the wordlist we can just generate dictionaries in reverse order.\\n- Time complexity is `O(W+Q)`. Space complexity is `O(W+Q)`. W - total number of chars in `wordlist`, Q - total number of chars in `queries`.\\n```\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        exactly = {*wordlist}\\n        cap = {w.lower():w for w in reversed(wordlist)}\\n        tr = str.maketrans(\\'aeiou\\', \\'*****\\')\\n        vowel = {w.lower().translate(tr):w for w in reversed(wordlist)}\\n        \\n        return [q if q in exactly else cap[p] if (p := q.lower()) in cap else vowel[p] if (p := p.translate(tr)) in vowel else \\'\\' for q in queries]\\n```\\n# 3 dictionaries, 144ms\\n- We can use `dict.get()` method to make the code more readable and faster. To do it we should use `dict` (with equal keys and values) instead of `set`.\\n- Time complexity is `O(W+Q)`. Space complexity is `O(W+Q)`. W - total number of chars in `wordlist`, Q - total number of chars in `queries`.\\n```\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        exactly = dict(zip(wordlist, wordlist))\\n        cap = {w.lower():w for w in reversed(wordlist)}\\n        tr = str.maketrans(\\'aeiou\\', \\'*****\\')\\n        vowel = {w.lower().translate(tr):w for w in reversed(wordlist)}\\n        \\n        return [exactly.get(q) or cap.get(p := q.lower()) or vowel.get(p.translate(tr)) or \\'\\' for q in queries]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        exactly = {*wordlist}\\n        cap = {w.lower():w for w in reversed(wordlist)}\\n        tr = str.maketrans(\\'aeiou\\', \\'*****\\')\\n        vowel = {w.lower().translate(tr):w for w in reversed(wordlist)}\\n        \\n        return [q if q in exactly else cap[p] if (p := q.lower()) in cap else vowel[p] if (p := p.translate(tr)) in vowel else \\'\\' for q in queries]\\n```\n```\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        exactly = dict(zip(wordlist, wordlist))\\n        cap = {w.lower():w for w in reversed(wordlist)}\\n        tr = str.maketrans(\\'aeiou\\', \\'*****\\')\\n        vowel = {w.lower().translate(tr):w for w in reversed(wordlist)}\\n        \\n        return [exactly.get(q) or cap.get(p := q.lower()) or vowel.get(p.translate(tr)) or \\'\\' for q in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 726105,
                "title": "java-solution",
                "content": "```Java\\npublic String[] spellchecker(String[] wordlist, String[] queries) {\\n\\n\\tSet<String> original = new HashSet<>();\\n\\tMap<String, String> map = new HashMap<>();\\n\\tMap<String, String> masked = new HashMap<>();\\n\\n\\tfor(String w: wordlist){\\n\\t\\toriginal.add(w);\\n\\t\\tmap.putIfAbsent(w.toLowerCase(), w);\\n\\t\\tmasked.putIfAbsent(mask(w.toLowerCase()), w);\\n\\t} \\n\\n\\tString[] res = new String[queries.length];\\n\\n\\tfor(int i=0; i < queries.length; i++){\\n\\t\\tif(original.contains(queries[i])){\\n\\t\\t\\tres[i] = queries[i];\\n\\t\\t}else if(map.get(queries[i].toLowerCase()) != null){\\n\\t\\t\\tres[i] = map.get(queries[i].toLowerCase());\\n\\t\\t}else{\\n\\t\\t\\tString maskStr = mask(queries[i].toLowerCase());\\n\\t\\t\\tres[i] = masked.get(maskStr) == null ? \"\" : masked.get(maskStr);\\n\\t\\t}\\n\\t}\\n\\n\\treturn res;\\n}\\n\\nprivate String mask(String s){\\n\\treturn s.replaceAll(\"[aeiou]\", \"*\");\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```Java\\npublic String[] spellchecker(String[] wordlist, String[] queries) {\\n\\n\\tSet<String> original = new HashSet<>();\\n\\tMap<String, String> map = new HashMap<>();\\n\\tMap<String, String> masked = new HashMap<>();\\n\\n\\tfor(String w: wordlist){\\n\\t\\toriginal.add(w);\\n\\t\\tmap.putIfAbsent(w.toLowerCase(), w);\\n\\t\\tmasked.putIfAbsent(mask(w.toLowerCase()), w);\\n\\t} \\n\\n\\tString[] res = new String[queries.length];\\n\\n\\tfor(int i=0; i < queries.length; i++){\\n\\t\\tif(original.contains(queries[i])){\\n\\t\\t\\tres[i] = queries[i];\\n\\t\\t}else if(map.get(queries[i].toLowerCase()) != null){\\n\\t\\t\\tres[i] = map.get(queries[i].toLowerCase());\\n\\t\\t}else{\\n\\t\\t\\tString maskStr = mask(queries[i].toLowerCase());\\n\\t\\t\\tres[i] = masked.get(maskStr) == null ? \"\" : masked.get(maskStr);\\n\\t\\t}\\n\\t}\\n\\n\\treturn res;\\n}\\n\\nprivate String mask(String s){\\n\\treturn s.replaceAll(\"[aeiou]\", \"*\");\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 310485,
                "title": "java-one-set-one-map-17ms-short-clean-code",
                "content": "```\\npublic String[] spellchecker(String[] wordlist, String[] queries) {\\n        Map<String, String> dic = new HashMap<String, String>();\\n        Set<String> set = new HashSet<>(Arrays.asList(wordlist));\\n        String[] res = new String[queries.length];\\n        for (int k = wordlist.length - 1; k >= 0; k--) {\\n            String word =  wordlist[k];\\n            dic.put(word.toLowerCase(), word);\\n            dic.put(devowel(word), word);\\n        }\\n\\n        for (int i = 0; i < queries.length; i++) {\\n            String query = queries[i];\\n            res[i] = query;\\n            boolean b = !(set.contains(query)) && \\n                ((res[i] = dic.getOrDefault(query.toLowerCase(), \"\")) != \"\"\\n                || (res[i] = dic.getOrDefault(devowel(query), \"\")) != \"\");\\n        }\\n        return res;\\n    }\\n\\n    private String devowel(String word) {\\n        char[] chars = word.toLowerCase().toCharArray();\\n        for (int j = 0; j < chars.length; j++) {\\n            char c = chars[j];\\n            if (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\') chars[j] = \\'!\\';\\n        }\\n        return new String(chars);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String[] spellchecker(String[] wordlist, String[] queries) {\\n        Map<String, String> dic = new HashMap<String, String>();\\n        Set<String> set = new HashSet<>(Arrays.asList(wordlist));\\n        String[] res = new String[queries.length];\\n        for (int k = wordlist.length - 1; k >= 0; k--) {\\n            String word =  wordlist[k];\\n            dic.put(word.toLowerCase(), word);\\n            dic.put(devowel(word), word);\\n        }\\n\\n        for (int i = 0; i < queries.length; i++) {\\n            String query = queries[i];\\n            res[i] = query;\\n            boolean b = !(set.contains(query)) && \\n                ((res[i] = dic.getOrDefault(query.toLowerCase(), \"\")) != \"\"\\n                || (res[i] = dic.getOrDefault(devowel(query), \"\")) != \"\");\\n        }\\n        return res;\\n    }\\n\\n    private String devowel(String word) {\\n        char[] chars = word.toLowerCase().toCharArray();\\n        for (int j = 0; j < chars.length; j++) {\\n            char c = chars[j];\\n            if (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\') chars[j] = \\'!\\';\\n        }\\n        return new String(chars);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 245085,
                "title": "java-one-map-100",
                "content": "```\\nclass Solution {    \\n\\n    // lower case and replace all \\'aeiou\\' to \\'a\\'    \\n    final char[] eiou = new char[] { \\'e\\', \\'i\\', \\'o\\', \\'u\\' };\\n    String toKey(String origin) {\\n        char[] key = origin.toLowerCase().toCharArray();\\n        for (int i = 0; i < key.length; i++) {\\n            for (int j = 0; j < eiou.length; j++) {\\n                if (key[i] == eiou[j]) {\\n                    key[i] = \\'a\\';\\n                    break;\\n                }\\n            }\\n        }\\n        return new String(key);\\n    }\\n    \\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        String[] result = new String[queries.length];\\n        // build dictionary\\n        HashMap<String, ArrayList> map = new HashMap<>();\\n        for (int i = 0; i < wordlist.length; i++) {\\n            String key = toKey(wordlist[i]);\\n            if (map.containsKey(key)) {\\n                map.get(key).add(wordlist[i]);\\n            } else {\\n                ArrayList<String> newList = new ArrayList<>();\\n                newList.add(wordlist[i]);\\n                map.put(key, newList);\\n            }\\n        }\\n        //query\\n        for (int i = 0; i < queries.length; i++) {\\n            //  no matches \\n            String key = toKey(queries[i]);\\n            if (!map.containsKey(key)) {\\n                result[i] = \"\";\\n                continue;\\n            }\\n            ArrayList<String> list = map.get(key);\\n            boolean found = false;\\n            // find exactly matches\\n            for (int j = 0, s = list.size(); j < s; j++) {\\n                if (list.get(j).equals(queries[i])) {\\n                    result[i] = list.get(j);\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            if (!found) {\\n                //find case-insensitive\\n                for (int j = 0, s = list.size(); j < s; j++) {\\n                    if (list.get(j).toLowerCase().equals(queries[i].toLowerCase())) {\\n                        result[i] = list.get(j);\\n                        found = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (!found) {\\n                //find vowel errors\\n                result[i] = list.get(0);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {    \\n\\n    // lower case and replace all \\'aeiou\\' to \\'a\\'    \\n    final char[] eiou = new char[] { \\'e\\', \\'i\\', \\'o\\', \\'u\\' };\\n    String toKey(String origin) {\\n        char[] key = origin.toLowerCase().toCharArray();\\n        for (int i = 0; i < key.length; i++) {\\n            for (int j = 0; j < eiou.length; j++) {\\n                if (key[i] == eiou[j]) {\\n                    key[i] = \\'a\\';\\n                    break;\\n                }\\n            }\\n        }\\n        return new String(key);\\n    }\\n    \\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        String[] result = new String[queries.length];\\n        // build dictionary\\n        HashMap<String, ArrayList> map = new HashMap<>();\\n        for (int i = 0; i < wordlist.length; i++) {\\n            String key = toKey(wordlist[i]);\\n            if (map.containsKey(key)) {\\n                map.get(key).add(wordlist[i]);\\n            } else {\\n                ArrayList<String> newList = new ArrayList<>();\\n                newList.add(wordlist[i]);\\n                map.put(key, newList);\\n            }\\n        }\\n        //query\\n        for (int i = 0; i < queries.length; i++) {\\n            //  no matches \\n            String key = toKey(queries[i]);\\n            if (!map.containsKey(key)) {\\n                result[i] = \"\";\\n                continue;\\n            }\\n            ArrayList<String> list = map.get(key);\\n            boolean found = false;\\n            // find exactly matches\\n            for (int j = 0, s = list.size(); j < s; j++) {\\n                if (list.get(j).equals(queries[i])) {\\n                    result[i] = list.get(j);\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            if (!found) {\\n                //find case-insensitive\\n                for (int j = 0, s = list.size(); j < s; j++) {\\n                    if (list.get(j).toLowerCase().equals(queries[i].toLowerCase())) {\\n                        result[i] = list.get(j);\\n                        found = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (!found) {\\n                //find vowel errors\\n                result[i] = list.get(0);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 211457,
                "title": "javascript-hashmap-beats-100",
                "content": "```\\nvar spellchecker = function(wordlist, queries) {\\n    let ans=[],caplist={},vowlist={}, samelist={};\\n\\n    for(let i=0;i<wordlist.length;i++) {\\n        let key = wordlist[i].toUpperCase();\\n        if(caplist[key]==undefined){\\n            caplist[key]=wordlist[i];     \\n        }\\n        samelist[wordlist[i]] = wordlist[i];\\n        \\n        key = wordlist[i].toLowerCase().replace(/[aeiou]/gi,\\'@\\');\\n        if(vowlist[key]==undefined){\\n            vowlist[key]=wordlist[i];     \\n        }\\n    }\\n    \\n    for(let i=0;i<queries.length;i++) {\\n        \\n        if(samelist[queries[i]]) {\\n            ans[i] = queries[i];\\n        }\\n        else if(caplist[queries[i].toUpperCase()]) {\\n            ans[i] = caplist[queries[i].toUpperCase()];\\n        }\\n        else if(vowlist[queries[i].toLowerCase().replace(/[aeiou]/gi,\\'@\\')]) {\\n            ans[i] = vowlist[queries[i].toLowerCase().replace(/[aeiou]/gi,\\'@\\')];\\n        }\\n        else {\\n            ans[i] = \\'\\';\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar spellchecker = function(wordlist, queries) {\\n    let ans=[],caplist={},vowlist={}, samelist={};\\n\\n    for(let i=0;i<wordlist.length;i++) {\\n        let key = wordlist[i].toUpperCase();\\n        if(caplist[key]==undefined){\\n            caplist[key]=wordlist[i];     \\n        }\\n        samelist[wordlist[i]] = wordlist[i];\\n        \\n        key = wordlist[i].toLowerCase().replace(/[aeiou]/gi,\\'@\\');\\n        if(vowlist[key]==undefined){\\n            vowlist[key]=wordlist[i];     \\n        }\\n    }\\n    \\n    for(let i=0;i<queries.length;i++) {\\n        \\n        if(samelist[queries[i]]) {\\n            ans[i] = queries[i];\\n        }\\n        else if(caplist[queries[i].toUpperCase()]) {\\n            ans[i] = caplist[queries[i].toUpperCase()];\\n        }\\n        else if(vowlist[queries[i].toLowerCase().replace(/[aeiou]/gi,\\'@\\')]) {\\n            ans[i] = vowlist[queries[i].toLowerCase().replace(/[aeiou]/gi,\\'@\\')];\\n        }\\n        else {\\n            ans[i] = \\'\\';\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530814,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        unordered_set<string> exact;\\n        unordered_map<string, string> cap, vow;\\n        \\n        for(string &s : wordlist){\\n            exact.insert(s);\\n            string s2 = s;\\n            transform(s2.begin(), s2.end(), s2.begin(), ::tolower);\\n            if(!cap.count(s2)) cap[s2] = s;\\n            for(char &ch : s2){\\n                if(ch == \\'a\\' || ch ==\\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') ch = \\'*\\';\\n            }\\n            if(!vow.count(s2)) vow[s2] = s;\\n        }\\n        vector<string> res(queries.size(), \"\");\\n        for(int i = 0; i < queries.size(); i++){\\n            if(exact.count(queries[i])) {\\n                res[i] = queries[i];\\n                continue;\\n            }\\n            string s = queries[i];\\n            transform(s.begin(), s.end(), s.begin(), ::tolower);\\n            if(cap.count(s)) {\\n                res[i] = cap[s];\\n                continue;\\n            }\\n            for(char &ch : s){\\n                if(ch == \\'a\\' || ch ==\\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') ch = \\'*\\';\\n            }\\n            if(vow.count(s)) res[i] = vow[s];\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        capital={i.lower():i for i in wordlist[::-1]}\\n        vovel={\\'\\'.join([j if j not in \"aeiou\" else \\'.\\' for j in i.lower()]):i for i in wordlist[::-1]}\\n        wordlist=set(wordlist)\\n        res=[]\\n        for i in queries:\\n            if i in wordlist:\\n                res.append(i)\\n            elif i.lower() in capital:\\n                res.append(capital[i.lower()])\\n            elif \\'\\'.join([j if j not in \"aeiou\" else \\'.\\' for j in i.lower()]) in vovel:\\n                res.append(vovel[\\'\\'.join([j if j not in \"aeiou\" else \\'.\\' for j in i.lower()])])\\n            else:\\n                res.append(\"\")\\n        return res\\n```\\n\\n```Java []\\nclass Solution {\\n\\t\\tstatic final int GAP = \\'a\\' - \\'A\\';\\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        Map<Long, String> wordMap = new HashMap<>(wordlist.length << 1), capMap = new HashMap<>(wordlist.length << 1), vowelMap = new HashMap<>(wordlist.length << 1);\\n\\t\\t\\t\\tfor (String word : wordlist) {\\n\\t\\t\\t\\t\\tlong hash = 0, capHash = 0, vowelHash = 0;\\n\\t\\t\\t\\t\\tfor (int i = 0, length = word.length(), c; i < length; ) {\\n\\t\\t\\t\\t\\t\\thash = (hash << 7) | (c = word.charAt(i++));\\n\\t\\t\\t\\t\\t\\tcapHash = (capHash << 7) | (c < \\'a\\' ? c += GAP : c);\\n\\t\\t\\t\\t\\t\\tvowelHash = c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' ? (vowelHash << 7) : (vowelHash << 7) | c;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\twordMap.put(hash, word);\\n\\t\\t\\t\\t\\tcapMap.putIfAbsent(capHash, word);\\n\\t\\t\\t\\t\\tvowelMap.putIfAbsent(vowelHash, word);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor (int i = 0; i < queries.length; i++) {\\n\\t\\t\\t\\t\\tlong hash = 0, capHash = 0, vowelHash = 0;\\n\\t\\t\\t\\t\\tfor (int j = 0, length = queries[i].length(), c; j < length; ) {\\n\\t\\t\\t\\t\\t\\thash = (hash << 7) | (c = queries[i].charAt(j++));\\n\\t\\t\\t\\t\\t\\tcapHash = (capHash << 7) | (c < \\'a\\' ? c += GAP : c);\\n\\t\\t\\t\\t\\t\\tvowelHash = c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' ? (vowelHash << 7) : (vowelHash << 7) | c;\\n\\t\\t\\t\\t\\t}\\n                    if (wordMap.containsKey(hash)) continue;\\n\\t\\t\\t\\t\\tString word = capMap.get(capHash);\\n\\t\\t\\t        queries[i] = word != null ? word : vowelMap.getOrDefault(vowelHash, \"\");\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn queries;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        unordered_set<string> exact;\\n        unordered_map<string, string> cap, vow;\\n        \\n        for(string &s : wordlist){\\n            exact.insert(s);\\n            string s2 = s;\\n            transform(s2.begin(), s2.end(), s2.begin(), ::tolower);\\n            if(!cap.count(s2)) cap[s2] = s;\\n            for(char &ch : s2){\\n                if(ch == \\'a\\' || ch ==\\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') ch = \\'*\\';\\n            }\\n            if(!vow.count(s2)) vow[s2] = s;\\n        }\\n        vector<string> res(queries.size(), \"\");\\n        for(int i = 0; i < queries.size(); i++){\\n            if(exact.count(queries[i])) {\\n                res[i] = queries[i];\\n                continue;\\n            }\\n            string s = queries[i];\\n            transform(s.begin(), s.end(), s.begin(), ::tolower);\\n            if(cap.count(s)) {\\n                res[i] = cap[s];\\n                continue;\\n            }\\n            for(char &ch : s){\\n                if(ch == \\'a\\' || ch ==\\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') ch = \\'*\\';\\n            }\\n            if(vow.count(s)) res[i] = vow[s];\\n        }\\n        return res;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        capital={i.lower():i for i in wordlist[::-1]}\\n        vovel={\\'\\'.join([j if j not in \"aeiou\" else \\'.\\' for j in i.lower()]):i for i in wordlist[::-1]}\\n        wordlist=set(wordlist)\\n        res=[]\\n        for i in queries:\\n            if i in wordlist:\\n                res.append(i)\\n            elif i.lower() in capital:\\n                res.append(capital[i.lower()])\\n            elif \\'\\'.join([j if j not in \"aeiou\" else \\'.\\' for j in i.lower()]) in vovel:\\n                res.append(vovel[\\'\\'.join([j if j not in \"aeiou\" else \\'.\\' for j in i.lower()])])\\n            else:\\n                res.append(\"\")\\n        return res\\n```\n```Java []\\nclass Solution {\\n\\t\\tstatic final int GAP = \\'a\\' - \\'A\\';\\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        Map<Long, String> wordMap = new HashMap<>(wordlist.length << 1), capMap = new HashMap<>(wordlist.length << 1), vowelMap = new HashMap<>(wordlist.length << 1);\\n\\t\\t\\t\\tfor (String word : wordlist) {\\n\\t\\t\\t\\t\\tlong hash = 0, capHash = 0, vowelHash = 0;\\n\\t\\t\\t\\t\\tfor (int i = 0, length = word.length(), c; i < length; ) {\\n\\t\\t\\t\\t\\t\\thash = (hash << 7) | (c = word.charAt(i++));\\n\\t\\t\\t\\t\\t\\tcapHash = (capHash << 7) | (c < \\'a\\' ? c += GAP : c);\\n\\t\\t\\t\\t\\t\\tvowelHash = c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' ? (vowelHash << 7) : (vowelHash << 7) | c;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\twordMap.put(hash, word);\\n\\t\\t\\t\\t\\tcapMap.putIfAbsent(capHash, word);\\n\\t\\t\\t\\t\\tvowelMap.putIfAbsent(vowelHash, word);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor (int i = 0; i < queries.length; i++) {\\n\\t\\t\\t\\t\\tlong hash = 0, capHash = 0, vowelHash = 0;\\n\\t\\t\\t\\t\\tfor (int j = 0, length = queries[i].length(), c; j < length; ) {\\n\\t\\t\\t\\t\\t\\thash = (hash << 7) | (c = queries[i].charAt(j++));\\n\\t\\t\\t\\t\\t\\tcapHash = (capHash << 7) | (c < \\'a\\' ? c += GAP : c);\\n\\t\\t\\t\\t\\t\\tvowelHash = c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' ? (vowelHash << 7) : (vowelHash << 7) | c;\\n\\t\\t\\t\\t\\t}\\n                    if (wordMap.containsKey(hash)) continue;\\n\\t\\t\\t\\t\\tString word = capMap.get(capHash);\\n\\t\\t\\t        queries[i] = word != null ? word : vowelMap.getOrDefault(vowelHash, \"\");\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn queries;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362155,
                "title": "easy-c-beats-93-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nit seems to check if query is present as exact of in lower or in vowel so there is neet to use Hash Map\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe create three hashmaps exact, capitalised, vowel. Here we enter exact word in exact map and map its lower value to it in Capitalised and to make sure first word lower is stored we use if statement to see if lower of that exist already or not.\\nthen for vowel we use the methode\\nVishal is converted to v*sh*l in which vowels converted to * and all other are converted to lower and map them to Original.\\n\\nthen for each query chech in order in which they found\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*m)$$\\nwhere n is number of words and m is length of word\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string toLower(string s){\\n        for(int i=0;i<s.length();i++){\\n            if(!(s[i]>=\\'a\\' and s[i]<=\\'z\\')){\\n                s[i]=s[i]+32;\\n            }\\n        }\\n        return s;\\n    }\\n    string toVowel(string s){\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\' || s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\' || s[i]==\\'A\\' || s[i]==\\'E\\' || s[i]==\\'I\\' || s[i]==\\'O\\' || s[i]==\\'U\\'){\\n                s[i]=\\'*\\';\\n            }\\n        }\\n        return s;\\n    }\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        unordered_map<string,int>Exact;\\n        unordered_map<string,string>Capitalised;\\n        unordered_map<string,string>Vowel;\\n        for(auto word:wordlist){\\n            Exact[word]=1;\\n            string cap=toLower(word);\\n            if(Capitalised.count(cap)==0)\\n            Capitalised[cap]=word;\\n            string cap1=toVowel(cap);\\n            if(Vowel.count(cap1)==0)\\n            Vowel[cap1]=word;\\n        }\\n        vector<string>ans;\\n        for(auto q:queries){\\n            if(Exact.count(q)){\\n                ans.push_back(q);\\n                continue;\\n            }else if(Capitalised.count(toLower(q))){\\n                ans.push_back(Capitalised[toLower(q)]);\\n                continue;\\n            }else if(Vowel.count(toVowel(toLower(q)))){\\n                ans.push_back(Vowel[toVowel(toLower(q))]);\\n                continue;\\n            }else{\\n                ans.push_back(\"\");\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string toLower(string s){\\n        for(int i=0;i<s.length();i++){\\n            if(!(s[i]>=\\'a\\' and s[i]<=\\'z\\')){\\n                s[i]=s[i]+32;\\n            }\\n        }\\n        return s;\\n    }\\n    string toVowel(string s){\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\' || s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\' || s[i]==\\'A\\' || s[i]==\\'E\\' || s[i]==\\'I\\' || s[i]==\\'O\\' || s[i]==\\'U\\'){\\n                s[i]=\\'*\\';\\n            }\\n        }\\n        return s;\\n    }\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        unordered_map<string,int>Exact;\\n        unordered_map<string,string>Capitalised;\\n        unordered_map<string,string>Vowel;\\n        for(auto word:wordlist){\\n            Exact[word]=1;\\n            string cap=toLower(word);\\n            if(Capitalised.count(cap)==0)\\n            Capitalised[cap]=word;\\n            string cap1=toVowel(cap);\\n            if(Vowel.count(cap1)==0)\\n            Vowel[cap1]=word;\\n        }\\n        vector<string>ans;\\n        for(auto q:queries){\\n            if(Exact.count(q)){\\n                ans.push_back(q);\\n                continue;\\n            }else if(Capitalised.count(toLower(q))){\\n                ans.push_back(Capitalised[toLower(q)]);\\n                continue;\\n            }else if(Vowel.count(toVowel(toLower(q)))){\\n                ans.push_back(Vowel[toVowel(toLower(q))]);\\n                continue;\\n            }else{\\n                ans.push_back(\"\");\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612546,
                "title": "c-85-faster-than-all-detailed",
                "content": "```\\nclass Solution {\\n    bool isVowel(char ch)\\n    {\\n        if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch ==\\'u\\' || ch == \\'A\\' || ch == \\'E\\' || ch == \\'I\\' || ch == \\'O\\' || ch == \\'U\\')\\n            return true;\\n        return false;\\n    }\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries)\\n    {\\n        unordered_map<string, int> list;\\n        unordered_map<string, int> cases;\\n        set<string> sfst;\\n        int idx = 0;\\n        for(string &word : wordlist)\\n        {\\n            sfst.insert(word);\\n            string str = \"\";\\n            string w = \"\";\\n            int slen = word.size();\\n            for(int i = 0; i < slen; i++)\\n            {\\n                \\n                if(isVowel(word[i]))\\n                    str += \\'*\\';\\n                else\\n                {\\n                    str += tolower(word[i]);\\n                }\\n                w += tolower(word[i]);\\n            }\\n            if(!list.count(str))\\n                list[str] = idx;\\n            if(!cases.count(w))\\n                cases[w] = idx;\\n            idx++;\\n        }\\n        int n = queries.size();\\n        for(int i = 0; i < n; i++)\\n        {\\n            string str = \"\", w = \"\";\\n            int slen = queries[i].size();\\n            if(sfst.find(queries[i]) != sfst.end())\\n            {\\n                continue;\\n            }\\n            for(int j = 0; j < slen; j++)\\n            {\\n\\n                if(isVowel(queries[i][j]))\\n                    str += \\'*\\';\\n                else\\n                {\\n                    str += tolower(queries[i][j]);\\n                }\\n                w += tolower(queries[i][j]);\\n            }\\n            if(cases.count(w))\\n            {\\n                queries[i] = wordlist[cases[w]];\\n                continue;\\n            }\\n            if(list.count(str))\\n            {\\n                queries[i] = wordlist[list[str]];\\n                continue;\\n            }\\n            queries[i] = \"\";\\n        }\\n        return queries;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    bool isVowel(char ch)\\n    {\\n        if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch ==\\'u\\' || ch == \\'A\\' || ch == \\'E\\' || ch == \\'I\\' || ch == \\'O\\' || ch == \\'U\\')\\n            return true;\\n        return false;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2500979,
                "title": "c-simple-c-code",
                "content": "\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    bool isVowel(char ch)\\n    {\\n        if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch ==\\'u\\' || ch == \\'A\\' || ch == \\'E\\' || ch == \\'I\\' || ch == \\'O\\' || ch == \\'U\\')\\n            return true;\\n        return false;\\n    }\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries)\\n    {\\n        unordered_map<string, int> list;\\n        unordered_map<string, int> cases;\\n        set<string> sfst;\\n        int idx = 0;\\n        for(string &word : wordlist)\\n        {\\n            sfst.insert(word);\\n            string str = \"\";\\n            string w = \"\";\\n            int slen = word.size();\\n            for(int i = 0; i < slen; i++)\\n            {\\n                \\n                if(isVowel(word[i]))\\n                    str += \\'*\\';\\n                else\\n                {\\n                    str += tolower(word[i]);\\n                }\\n                w += tolower(word[i]);\\n            }\\n            if(!list.count(str))\\n                list[str] = idx;\\n            if(!cases.count(w))\\n                cases[w] = idx;\\n            idx++;\\n        }\\n        int n = queries.size();\\n        for(int i = 0; i < n; i++)\\n        {\\n            string str = \"\", w = \"\";\\n            int slen = queries[i].size();\\n            if(sfst.find(queries[i]) != sfst.end())\\n            {\\n                continue;\\n            }\\n            for(int j = 0; j < slen; j++)\\n            {\\n\\n                if(isVowel(queries[i][j]))\\n                    str += \\'*\\';\\n                else\\n                {\\n                    str += tolower(queries[i][j]);\\n                }\\n                w += tolower(queries[i][j]);\\n            }\\n            if(cases.count(w))\\n            {\\n                queries[i] = wordlist[cases[w]];\\n                continue;\\n            }\\n            if(list.count(str))\\n            {\\n                queries[i] = wordlist[list[str]];\\n                continue;\\n            }\\n            queries[i] = \"\";\\n        }\\n        return queries;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    bool isVowel(char ch)\\n    {\\n        if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch ==\\'u\\' || ch == \\'A\\' || ch == \\'E\\' || ch == \\'I\\' || ch == \\'O\\' || ch == \\'U\\')\\n            return true;\\n        return false;\\n    }\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries)\\n    {\\n        unordered_map<string, int> list;\\n        unordered_map<string, int> cases;\\n        set<string> sfst;\\n        int idx = 0;\\n        for(string &word : wordlist)\\n        {\\n            sfst.insert(word);\\n            string str = \"\";\\n            string w = \"\";\\n            int slen = word.size();\\n            for(int i = 0; i < slen; i++)\\n            {\\n                \\n                if(isVowel(word[i]))\\n                    str += \\'*\\';\\n                else\\n                {\\n                    str += tolower(word[i]);\\n                }\\n                w += tolower(word[i]);\\n            }\\n            if(!list.count(str))\\n                list[str] = idx;\\n            if(!cases.count(w))\\n                cases[w] = idx;\\n            idx++;\\n        }\\n        int n = queries.size();\\n        for(int i = 0; i < n; i++)\\n        {\\n            string str = \"\", w = \"\";\\n            int slen = queries[i].size();\\n            if(sfst.find(queries[i]) != sfst.end())\\n            {\\n                continue;\\n            }\\n            for(int j = 0; j < slen; j++)\\n            {\\n\\n                if(isVowel(queries[i][j]))\\n                    str += \\'*\\';\\n                else\\n                {\\n                    str += tolower(queries[i][j]);\\n                }\\n                w += tolower(queries[i][j]);\\n            }\\n            if(cases.count(w))\\n            {\\n                queries[i] = wordlist[cases[w]];\\n                continue;\\n            }\\n            if(list.count(str))\\n            {\\n                queries[i] = wordlist[list[str]];\\n                continue;\\n            }\\n            queries[i] = \"\";\\n        }\\n        return queries;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1862616,
                "title": "java-share-my-solution-array-of-maps",
                "content": "Understanding what the question is really asking is 90% of the task in my opionion. Poorly worded. \\n\\nPrecedence is separated by index.\\n0 - perfect match\\n1 - capitalization mismatch\\n2 - vowel mismatch\\n\\nThere is one catch that I didn\\'t see the question mentioning - If the string was replaced via the weakest precedence (i.e. index 3 - vowel), then we need to check whether after the replacement, we can find it in index 2 level. I deal with this when putting them into hashmap.\\n```Java\\nclass Solution {\\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        String[] ans = new String[queries.length];\\n        Map<String, String>[] map = new HashMap[3];\\n        Arrays.setAll(map, o -> new HashMap<>());\\n        String pattern = \"[aeiou]\";\\n\\n        for (String w : wordlist){\\n            String lo = w.toLowerCase();\\n            map[0].put(w, \"\");\\n            map[1].putIfAbsent(lo, w);\\n            map[2].putIfAbsent(lo.replaceAll(pattern, \".\"), map[1].getOrDefault(w, w));\\n        }\\n\\n        int i = 0;\\n        for (String q : queries){\\n            String lo = q.toLowerCase();\\n            String re = lo.replaceAll(pattern, \".\");\\n            if (map[0].containsKey(q)){\\n                ans[i] = q;\\n            }else if (map[1].containsKey(lo)){\\n                ans[i] = map[1].get(lo);\\n            }else if (map[2].containsKey(re)){\\n                ans[i] = map[2].get(re);\\n            }else{\\n                ans[i] = \"\";\\n            }\\n            i++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        String[] ans = new String[queries.length];\\n        Map<String, String>[] map = new HashMap[3];\\n        Arrays.setAll(map, o -> new HashMap<>());\\n        String pattern = \"[aeiou]\";\\n\\n        for (String w : wordlist){\\n            String lo = w.toLowerCase();\\n            map[0].put(w, \"\");\\n            map[1].putIfAbsent(lo, w);\\n            map[2].putIfAbsent(lo.replaceAll(pattern, \".\"), map[1].getOrDefault(w, w));\\n        }\\n\\n        int i = 0;\\n        for (String q : queries){\\n            String lo = q.toLowerCase();\\n            String re = lo.replaceAll(pattern, \".\");\\n            if (map[0].containsKey(q)){\\n                ans[i] = q;\\n            }else if (map[1].containsKey(lo)){\\n                ans[i] = map[1].get(lo);\\n            }else if (map[2].containsKey(re)){\\n                ans[i] = map[2].get(re);\\n            }else{\\n                ans[i] = \"\";\\n            }\\n            i++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131193,
                "title": "java-hashmap-a-poorly-worded-problem",
                "content": "class Solution {\\n    \\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        HashSet<String> set=new HashSet<>();\\n        HashMap<String,String> forCaps=new HashMap<>();\\n        HashMap<String ,String> forVow=new HashMap<>();\\n        for(String word:wordlist)\\n        {\\n            set.add(word);\\n            forCaps.computeIfAbsent(word.toLowerCase(),v->word);\\n            String key=getKey(word);\\n            forVow.computeIfAbsent(key,v->word);\\n        }\\n        \\n        String[] ans=new String[queries.length];\\n        int index=0;\\n        for(String word:queries)\\n        {\\n            if(set.contains(word))\\n                ans[index]=word;\\n            else if(forCaps.containsKey(word.toLowerCase()))\\n                ans[index]=forCaps.get(word.toLowerCase());\\n            \\n            else if(forVow.containsKey(getKey(word)))\\n                ans[index]=forVow.get(getKey(word));\\n            else\\n                ans[index]=\"\";\\n            index++;\\n\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public String getKey(String word)\\n    {\\n        StringBuilder key=new StringBuilder();\\n        for(int i=0;i<word.length();i++)\\n        {\\n            char temp=word.charAt(i);\\n            temp=Character.toLowerCase(temp);\\n            if(temp==\\'a\\'||temp==\\'e\\'||temp==\\'i\\'||temp==\\'o\\'||temp==\\'u\\')\\n                key.append(\"*\");\\n            else\\n                key.append(temp);\\n        }\\n        return key.toString();\\n    }\\n    \\n    \\n    \\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        HashSet<String> set=new HashSet<>();\\n        HashMap<String,String> forCaps=new HashMap<>();\\n        HashMap<String ,String> forVow=new HashMap<>();\\n        for(String word:wordlist)\\n        {\\n            set.add(word);\\n            forCaps.computeIfAbsent(word.toLowerCase(),v->word);\\n            String key=getKey(word);\\n            forVow.computeIfAbsent(key,v->word);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1123364,
                "title": "scala-trie-solution",
                "content": "```scala\\nobject Solution {\\n  case class Trie(idx: Option[Int], child: Map[Char, Trie])\\n  def insert(string: List[Char], index: Int, trie: Trie): Trie = string match {\\n    case Nil =>\\n      trie.idx match {\\n        case None => Trie(Some(index), trie.child)\\n        case s @ Some(j) =>\\n          if (j < index) Trie(s, trie.child) else Trie(Some(index), trie.child)\\n      }\\n    case x :: xs => {\\n      val sub = trie.child.get(x).getOrElse(Trie(None, Map()))\\n      Trie(trie.idx, trie.child + (x -> insert(xs, index, sub)))\\n    }\\n  }\\n\\n  sealed abstract class SearchState\\n  final case object PerfectMatch extends SearchState\\n  final case object Capitalization extends SearchState\\n  final case object VowelError extends SearchState\\n\\n  implicit object SearchStateOrdering extends Ordering[SearchState] {\\n    def compare(a: SearchState, b: SearchState): Int = (a, b) match {\\n      case (PerfectMatch, PerfectMatch)     => 0\\n      case (PerfectMatch, _)                => -1\\n      case (Capitalization, PerfectMatch)   => 1\\n      case (Capitalization, Capitalization) => 0\\n      case (Capitalization, _)              => -1\\n      case (VowelError, VowelError)         => 0\\n      case (VowelError, _)                  => 1\\n    }\\n  }\\n\\n  sealed abstract class SearchResult\\n  final case class Found(state: SearchState, idx: Int) extends SearchResult\\n  final case object NotFound extends SearchResult\\n\\n  implicit def searchResultOrdering(implicit\\n      ss: Ordering[SearchState]\\n  ): Ordering[SearchResult] = new Ordering[SearchResult] {\\n    def compare(a: SearchResult, b: SearchResult): Int = (a, b) match {\\n      case (NotFound, NotFound) => 0\\n      case (Found(s1, i1), Found(s2, i2)) =>\\n        ss.compare(s1, s2) match {\\n          case x if x != 0 => x\\n          case _           => i1 - i2\\n        }\\n      case (NotFound, _)    => -1\\n      case (Found(_, _), _) => 1\\n    }\\n  }\\n\\n  val vowelSet = Set(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\')\\n  val vowelList = List(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\')\\n\\n  def candidate(ch: Char): List[(Char, SearchState)] =\\n    capitalize(ch) ++ vowelError(ch) ++ List((ch, PerfectMatch))\\n  def capitalize(ch: Char): List[(Char, SearchState)] = if (ch.isLower)\\n    List((ch.toUpper, Capitalization))\\n  else List((ch.toLower, Capitalization))\\n  def vowelError(ch: Char): List[(Char, SearchState)] = if (\\n    vowelSet(ch.toLower)\\n  ) {\\n    for {\\n      v <- vowelList\\n      pair = (v, VowelError) if v != ch\\n    } yield pair\\n  } else {\\n    Nil\\n  }\\n\\n  def search(\\n      string: List[Char],\\n      s: SearchState,\\n      trie: Trie,\\n      currentSolution: List[SearchResult]\\n  )(implicit o: Ordering[SearchState]): List[SearchResult] = string match {\\n    case Nil =>\\n      trie.idx match {\\n        case None    => currentSolution\\n        case Some(i) => Found(s, i) :: currentSolution\\n      }\\n    case x :: xs => {\\n      val candidates = candidate(x)\\n      candidates.foldLeft(currentSolution) {\\n        case (acc, (ch, st)) => {\\n          trie.child.get(ch) match {\\n            case None => acc\\n            case Some(t) =>\\n              search(xs, if (o.compare(st, s) > 0) st else s, t, acc)\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  def spellchecker(\\n      wordlist: Array[String],\\n      queries: Array[String]\\n  ): Array[String] = {\\n    val words = wordlist.zipWithIndex\\n    val trie = words.foldLeft(Trie(None, Map())) {\\n      case (acc, (s, i)) => {\\n        insert(s.toList, i, acc)\\n      }\\n    }\\n\\n    queries.map { query =>\\n      {\\n        val answers = search(query.toList, PerfectMatch, trie, List()).sorted\\n        answers.headOption.getOrElse(NotFound) match {\\n          case NotFound    => \"\"\\n          case Found(s, i) => wordlist(i)\\n        }\\n      }\\n    }\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```scala\\nobject Solution {\\n  case class Trie(idx: Option[Int], child: Map[Char, Trie])\\n  def insert(string: List[Char], index: Int, trie: Trie): Trie = string match {\\n    case Nil =>\\n      trie.idx match {\\n        case None => Trie(Some(index), trie.child)\\n        case s @ Some(j) =>\\n          if (j < index) Trie(s, trie.child) else Trie(Some(index), trie.child)\\n      }\\n    case x :: xs => {\\n      val sub = trie.child.get(x).getOrElse(Trie(None, Map()))\\n      Trie(trie.idx, trie.child + (x -> insert(xs, index, sub)))\\n    }\\n  }\\n\\n  sealed abstract class SearchState\\n  final case object PerfectMatch extends SearchState\\n  final case object Capitalization extends SearchState\\n  final case object VowelError extends SearchState\\n\\n  implicit object SearchStateOrdering extends Ordering[SearchState] {\\n    def compare(a: SearchState, b: SearchState): Int = (a, b) match {\\n      case (PerfectMatch, PerfectMatch)     => 0\\n      case (PerfectMatch, _)                => -1\\n      case (Capitalization, PerfectMatch)   => 1\\n      case (Capitalization, Capitalization) => 0\\n      case (Capitalization, _)              => -1\\n      case (VowelError, VowelError)         => 0\\n      case (VowelError, _)                  => 1\\n    }\\n  }\\n\\n  sealed abstract class SearchResult\\n  final case class Found(state: SearchState, idx: Int) extends SearchResult\\n  final case object NotFound extends SearchResult\\n\\n  implicit def searchResultOrdering(implicit\\n      ss: Ordering[SearchState]\\n  ): Ordering[SearchResult] = new Ordering[SearchResult] {\\n    def compare(a: SearchResult, b: SearchResult): Int = (a, b) match {\\n      case (NotFound, NotFound) => 0\\n      case (Found(s1, i1), Found(s2, i2)) =>\\n        ss.compare(s1, s2) match {\\n          case x if x != 0 => x\\n          case _           => i1 - i2\\n        }\\n      case (NotFound, _)    => -1\\n      case (Found(_, _), _) => 1\\n    }\\n  }\\n\\n  val vowelSet = Set(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\')\\n  val vowelList = List(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\')\\n\\n  def candidate(ch: Char): List[(Char, SearchState)] =\\n    capitalize(ch) ++ vowelError(ch) ++ List((ch, PerfectMatch))\\n  def capitalize(ch: Char): List[(Char, SearchState)] = if (ch.isLower)\\n    List((ch.toUpper, Capitalization))\\n  else List((ch.toLower, Capitalization))\\n  def vowelError(ch: Char): List[(Char, SearchState)] = if (\\n    vowelSet(ch.toLower)\\n  ) {\\n    for {\\n      v <- vowelList\\n      pair = (v, VowelError) if v != ch\\n    } yield pair\\n  } else {\\n    Nil\\n  }\\n\\n  def search(\\n      string: List[Char],\\n      s: SearchState,\\n      trie: Trie,\\n      currentSolution: List[SearchResult]\\n  )(implicit o: Ordering[SearchState]): List[SearchResult] = string match {\\n    case Nil =>\\n      trie.idx match {\\n        case None    => currentSolution\\n        case Some(i) => Found(s, i) :: currentSolution\\n      }\\n    case x :: xs => {\\n      val candidates = candidate(x)\\n      candidates.foldLeft(currentSolution) {\\n        case (acc, (ch, st)) => {\\n          trie.child.get(ch) match {\\n            case None => acc\\n            case Some(t) =>\\n              search(xs, if (o.compare(st, s) > 0) st else s, t, acc)\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  def spellchecker(\\n      wordlist: Array[String],\\n      queries: Array[String]\\n  ): Array[String] = {\\n    val words = wordlist.zipWithIndex\\n    val trie = words.foldLeft(Trie(None, Map())) {\\n      case (acc, (s, i)) => {\\n        insert(s.toList, i, acc)\\n      }\\n    }\\n\\n    queries.map { query =>\\n      {\\n        val answers = search(query.toList, PerfectMatch, trie, List()).sorted\\n        answers.headOption.getOrElse(NotFound) match {\\n          case NotFound    => \"\"\\n          case Found(s, i) => wordlist(i)\\n        }\\n      }\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123264,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        map<string,string> cap;\\n        map<string,string> vol;\\n        vector<string> ans;\\n        for(string s:wordlist){\\n            string temp=\"\";\\n            for(char k:s){\\n                temp.push_back(toupper(k));\\n            }\\n            if(cap.count(temp)==0){\\n                cap[temp]=s;\\n            }\\n            cap[s]=s;\\n            for(int i=0;i<s.size();i++){\\n                if(tolower(s[i])==\\'a\\' || tolower(s[i])==\\'e\\' || tolower(s[i])==\\'i\\' || tolower(s[i])==\\'o\\' || tolower(s[i])==\\'u\\'){\\n                    temp[i]=\\'#\\';\\n                }\\n            }\\n            if(vol.count(temp)==0){\\n                vol[temp]=s;\\n            }\\n        }\\n        for(auto s:queries){\\n            if(cap.count(s)){\\n                ans.push_back(cap[s]);\\n                continue;\\n            }\\n            string temp=\"\";\\n            for(char k:s){\\n                temp.push_back(toupper(k));\\n            }\\n            if(cap.count(temp)){\\n                ans.push_back(cap[temp]);\\n                continue;\\n            }\\n            for(int i=0;i<s.size();i++){\\n                if(tolower(s[i])==\\'a\\' || tolower(s[i])==\\'e\\' || tolower(s[i])==\\'i\\' || tolower(s[i])==\\'o\\' || tolower(s[i])==\\'u\\'){\\n                    temp[i]=\\'#\\';\\n                }\\n            }\\n            if(vol.count(temp)){\\n                ans.push_back(vol[temp]);\\n                continue;\\n            }\\n            ans.push_back(\"\");\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        map<string,string> cap;\\n        map<string,string> vol;\\n        vector<string> ans;\\n        for(string s:wordlist){\\n            string temp=\"\";\\n            for(char k:s){\\n                temp.push_back(toupper(k));\\n            }\\n            if(cap.count(temp)==0){\\n                cap[temp]=s;\\n            }\\n            cap[s]=s;\\n            for(int i=0;i<s.size();i++){\\n                if(tolower(s[i])==\\'a\\' || tolower(s[i])==\\'e\\' || tolower(s[i])==\\'i\\' || tolower(s[i])==\\'o\\' || tolower(s[i])==\\'u\\'){\\n                    temp[i]=\\'#\\';\\n                }\\n            }\\n            if(vol.count(temp)==0){\\n                vol[temp]=s;\\n            }\\n        }\\n        for(auto s:queries){\\n            if(cap.count(s)){\\n                ans.push_back(cap[s]);\\n                continue;\\n            }\\n            string temp=\"\";\\n            for(char k:s){\\n                temp.push_back(toupper(k));\\n            }\\n            if(cap.count(temp)){\\n                ans.push_back(cap[temp]);\\n                continue;\\n            }\\n            for(int i=0;i<s.size();i++){\\n                if(tolower(s[i])==\\'a\\' || tolower(s[i])==\\'e\\' || tolower(s[i])==\\'i\\' || tolower(s[i])==\\'o\\' || tolower(s[i])==\\'u\\'){\\n                    temp[i]=\\'#\\';\\n                }\\n            }\\n            if(vol.count(temp)){\\n                ans.push_back(vol[temp]);\\n                continue;\\n            }\\n            ans.push_back(\"\");\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123256,
                "title": "javascript-preprocess-the-wordlist-o-m-n-k",
                "content": "```\\n/**\\n * @param {string[]} wordlist\\n * @param {string[]} queries\\n * @return {string[]}\\n */\\n//. n words of k length\\n// m queries of k length\\nvar spellchecker = function(wordlist, queries) {\\n    // m(O(n) + O(nk) + O(nk)) => O(mnk)\\n    \\n    \\n    // case-sensitvie: O(n) =>  use a set  O(1)\\n    // case-insensitive: O(n * k) => normalize first => use a Set O(k)\\n    // vowel-insensitive: O(n * k) => normalize, replace vowel to _ => use Set O(k)\\n    \\n    // O(n) + O(nk) + O(k)*m\\n    // O(nk) + O(mk)\\n    // O((m + n)k)\\n    \\n    const originSet = new Set(wordlist)\\n    const lowercaseMap = new Map()\\n    const novowelMap = new Map()\\n    \\n    for (const word of wordlist ) {\\n        const lowered = word.toLowerCase()\\n        if (!lowercaseMap.has(lowered)) {\\n            lowercaseMap.set(lowered, word)\\n        }\\n        \\n        const novoweled = lowered.replace(/[aiueo]/g, \\'_\\')\\n        if (!novowelMap.has(novoweled)) {\\n            novowelMap.set(novoweled, word)\\n        }\\n    }\\n    \\n    return queries.map((query) => {\\n        if (originSet.has(query)) return query\\n        const lowered = query.toLowerCase()\\n        if (lowercaseMap.has(lowered)) {\\n            return lowercaseMap.get(lowered)\\n        }\\n        \\n        const novoweled = lowered.replace(/[aiueo]/g, \\'_\\')\\n        if (novowelMap.has(novoweled)) {\\n            return novowelMap.get(novoweled)\\n        }\\n        return \\'\\'\\n    })\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string[]} wordlist\\n * @param {string[]} queries\\n * @return {string[]}\\n */\\n//. n words of k length\\n// m queries of k length\\nvar spellchecker = function(wordlist, queries) {\\n    // m(O(n) + O(nk) + O(nk)) => O(mnk)\\n    \\n    \\n    // case-sensitvie: O(n) =>  use a set  O(1)\\n    // case-insensitive: O(n * k) => normalize first => use a Set O(k)\\n    // vowel-insensitive: O(n * k) => normalize, replace vowel to _ => use Set O(k)\\n    \\n    // O(n) + O(nk) + O(k)*m\\n    // O(nk) + O(mk)\\n    // O((m + n)k)\\n    \\n    const originSet = new Set(wordlist)\\n    const lowercaseMap = new Map()\\n    const novowelMap = new Map()\\n    \\n    for (const word of wordlist ) {\\n        const lowered = word.toLowerCase()\\n        if (!lowercaseMap.has(lowered)) {\\n            lowercaseMap.set(lowered, word)\\n        }\\n        \\n        const novoweled = lowered.replace(/[aiueo]/g, \\'_\\')\\n        if (!novowelMap.has(novoweled)) {\\n            novowelMap.set(novoweled, word)\\n        }\\n    }\\n    \\n    return queries.map((query) => {\\n        if (originSet.has(query)) return query\\n        const lowered = query.toLowerCase()\\n        if (lowercaseMap.has(lowered)) {\\n            return lowercaseMap.get(lowered)\\n        }\\n        \\n        const novoweled = lowered.replace(/[aiueo]/g, \\'_\\')\\n        if (novowelMap.has(novoweled)) {\\n            return novowelMap.get(novoweled)\\n        }\\n        return \\'\\'\\n    })\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1123148,
                "title": "c-simple-solution-using-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char c){\\n        return (c==\\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\');\\n    }\\n    string key(string str){\\n        string retStr;\\n        for(int i=0;i<str.length();i++){\\n            if(isVowel(str[i]))\\n                retStr.push_back(\\'*\\');\\n            else\\n                retStr.push_back(str[i]);\\n        }\\n        return retStr;\\n    }\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        \\n        unordered_map<string,string> um; \\n        unordered_map<string,bool> isPresent;\\n        for(int i=0;i<wordlist.size();i++){\\n            isPresent[wordlist[i]]=true;\\n            string s=wordlist[i];\\n            transform(s.begin(),s.end(),s.begin(),\\n                                       [](unsigned char c){ return std::tolower(c); } );\\n            string lower_str=s;\\n            if(um.find(lower_str)==um.end())\\n                um[lower_str]=wordlist[i];\\n            \\n            string strKey=key(lower_str);\\n            if(um.find(strKey)==um.end())\\n                um[strKey]=wordlist[i];\\n        }\\n        vector<string> ans;\\n        for(int i=0;i<queries.size();i++){\\n            if(isPresent[queries[i]]){\\n                ans.push_back(queries[i]);\\n                continue;\\n            }\\n            string s=queries[i];\\n            transform(s.begin(),s.end(),s.begin(),\\n                                       [](unsigned char c){ return std::tolower(c); }\\n                  );\\n            string lower_str=s;\\n            if(um.find(lower_str)!=um.end()){\\n                ans.push_back(um[lower_str]);\\n                continue;\\n            }\\n            \\n            string strKey=key(lower_str);\\n            if(um.find(strKey)!=um.end()){\\n                ans.push_back(um[strKey]);\\n                continue;\\n            }\\n            ans.push_back(\"\");\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char c){\\n        return (c==\\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\');\\n    }\\n    string key(string str){\\n        string retStr;\\n        for(int i=0;i<str.length();i++){\\n            if(isVowel(str[i]))\\n                retStr.push_back(\\'*\\');\\n            else\\n                retStr.push_back(str[i]);\\n        }\\n        return retStr;\\n    }\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        \\n        unordered_map<string,string> um; \\n        unordered_map<string,bool> isPresent;\\n        for(int i=0;i<wordlist.size();i++){\\n            isPresent[wordlist[i]]=true;\\n            string s=wordlist[i];\\n            transform(s.begin(),s.end(),s.begin(),\\n                                       [](unsigned char c){ return std::tolower(c); } );\\n            string lower_str=s;\\n            if(um.find(lower_str)==um.end())\\n                um[lower_str]=wordlist[i];\\n            \\n            string strKey=key(lower_str);\\n            if(um.find(strKey)==um.end())\\n                um[strKey]=wordlist[i];\\n        }\\n        vector<string> ans;\\n        for(int i=0;i<queries.size();i++){\\n            if(isPresent[queries[i]]){\\n                ans.push_back(queries[i]);\\n                continue;\\n            }\\n            string s=queries[i];\\n            transform(s.begin(),s.end(),s.begin(),\\n                                       [](unsigned char c){ return std::tolower(c); }\\n                  );\\n            string lower_str=s;\\n            if(um.find(lower_str)!=um.end()){\\n                ans.push_back(um[lower_str]);\\n                continue;\\n            }\\n            \\n            string strKey=key(lower_str);\\n            if(um.find(strKey)!=um.end()){\\n                ans.push_back(um[strKey]);\\n                continue;\\n            }\\n            ans.push_back(\"\");\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122465,
                "title": "c-runtime-and-memory-beats-100-with-precomputed-mapping",
                "content": "```\\npublic class Solution {\\n    static readonly char[] mapping = new char[256];\\n    \\n    static Solution() {\\n        for (char i=\\'a\\'; i <= \\'z\\'; i++) {\\n            mapping[i] = i; \\n        }\\n        mapping[\\'a\\'] = \\'?\\';\\n        mapping[\\'e\\'] = \\'?\\';\\n        mapping[\\'i\\'] = \\'?\\';\\n        mapping[\\'o\\'] = \\'?\\';\\n        mapping[\\'u\\'] = \\'?\\';\\n    }\\n    \\n        \\n    public string[] Spellchecker(string[] wordlist, string[] queries) {\\n        char[] temp = new char[7];\\n        var origSet = new HashSet<string>(wordlist.Length);\\n        var caseDict = new Dictionary<string, string>(wordlist.Length);\\n        var vowelDict = new Dictionary<string, string>(wordlist.Length);\\n        \\n        for (int i = wordlist.Length - 1; i >=0; i--) {\\n            string word = wordlist[i];\\n            string s = word.ToLower();          \\n            \\n            origSet.Add(word);\\n            caseDict[s] = word;\\n            \\n            for (int j=0; j < s.Length; j++) {\\n                temp[j] = mapping[s[j]];\\n            }\\n            vowelDict[new String(temp, 0, s.Length)] = word;\\n        }\\n        \\n        for (int i=0; i < queries.Length; i++) {\\n            if (!origSet.Contains(queries[i])) {\\n                string s = queries[i].ToLower();\\n                if (caseDict.TryGetValue(s, out string origWord)) {\\n                    queries[i] = origWord;\\n                } else {\\n                     for (int j=0; j < s.Length; j++) {\\n                        temp[j] = mapping[s[j]];\\n                    }\\n                    if (vowelDict.TryGetValue(new String(temp, 0, s.Length), out origWord)) {\\n                         queries[i] = origWord;\\n                    } else {\\n                         queries[i] = string.Empty;\\n                    }\\n                }\\n            }\\n        }        \\n        return queries;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    static readonly char[] mapping = new char[256];\\n    \\n    static Solution() {\\n        for (char i=\\'a\\'; i <= \\'z\\'; i++) {\\n            mapping[i] = i; \\n        }\\n        mapping[\\'a\\'] = \\'?\\';\\n        mapping[\\'e\\'] = \\'?\\';\\n        mapping[\\'i\\'] = \\'?\\';\\n        mapping[\\'o\\'] = \\'?\\';\\n        mapping[\\'u\\'] = \\'?\\';\\n    }\\n    \\n        \\n    public string[] Spellchecker(string[] wordlist, string[] queries) {\\n        char[] temp = new char[7];\\n        var origSet = new HashSet<string>(wordlist.Length);\\n        var caseDict = new Dictionary<string, string>(wordlist.Length);\\n        var vowelDict = new Dictionary<string, string>(wordlist.Length);\\n        \\n        for (int i = wordlist.Length - 1; i >=0; i--) {\\n            string word = wordlist[i];\\n            string s = word.ToLower();          \\n            \\n            origSet.Add(word);\\n            caseDict[s] = word;\\n            \\n            for (int j=0; j < s.Length; j++) {\\n                temp[j] = mapping[s[j]];\\n            }\\n            vowelDict[new String(temp, 0, s.Length)] = word;\\n        }\\n        \\n        for (int i=0; i < queries.Length; i++) {\\n            if (!origSet.Contains(queries[i])) {\\n                string s = queries[i].ToLower();\\n                if (caseDict.TryGetValue(s, out string origWord)) {\\n                    queries[i] = origWord;\\n                } else {\\n                     for (int j=0; j < s.Length; j++) {\\n                        temp[j] = mapping[s[j]];\\n                    }\\n                    if (vowelDict.TryGetValue(new String(temp, 0, s.Length), out origWord)) {\\n                         queries[i] = origWord;\\n                    } else {\\n                         queries[i] = string.Empty;\\n                    }\\n                }\\n            }\\n        }        \\n        return queries;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122264,
                "title": "cpp-easy-solution-fast",
                "content": "```\\nclass Solution {\\npublic:\\n     map<string,vector<string>>s1;//for vowel error\\n        vector<string>v1;\\n        map<string,int>m1;\\n         map<string,vector<string>>s21;//for capitalization\\n    int isVowel(char ch)\\n{\\n    int check = 0;\\n    switch (ch) {\\n    case \\'a\\':\\n    case \\'e\\':\\n    case \\'i\\':\\n    case \\'o\\':\\n    case \\'u\\':\\n    case \\'A\\':\\n    case \\'E\\':\\n    case \\'I\\':\\n    case \\'O\\':\\n    case \\'U\\':\\n        check = 1;\\n    }\\n    return check;\\n}\\n    string e;\\n     \\n    string toconvert(string s)\\n    {\\n        string w;\\n        e.clear();\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            e+=tolower(s[i]);\\n            if(isVowel(s[i]))\\n                w+=\\'*\\';\\n            else\\n                w+=tolower(s[i]);\\n        }\\n        return w;\\n    }\\n     vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n       for(int  i=0;i<wordlist.size();i++)\\n       {\\n           string s=toconvert(wordlist[i]);\\n           s1[s].push_back(wordlist[i]);\\n           s21[e].push_back(wordlist[i]);\\n           m1[wordlist[i]]++;\\n           \\n       }\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            string s=toconvert(queries[i]);\\n             if(s1.find(s)!=s1.end())\\n            {\\n                \\n                if(m1[queries[i]]!=0)\\n                    v1.push_back(queries[i]);\\n                else if(s21.find(e)!=s21.end())\\n                {\\n                    v1.push_back(s21[e][0]);\\n                }\\n                else\\n                    v1.push_back(s1[s][0]);\\n                \\n            }\\n            else\\n            {\\n              v1.push_back(\"\");\\n            }\\n        }\\n    return v1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     map<string,vector<string>>s1;//for vowel error\\n        vector<string>v1;\\n        map<string,int>m1;\\n         map<string,vector<string>>s21;//for capitalization\\n    int isVowel(char ch)\\n{\\n    int check = 0;\\n    switch (ch) {\\n    case \\'a\\':\\n    case \\'e\\':\\n    case \\'i\\':\\n    case \\'o\\':\\n    case \\'u\\':\\n    case \\'A\\':\\n    case \\'E\\':\\n    case \\'I\\':\\n    case \\'O\\':\\n    case \\'U\\':\\n        check = 1;\\n    }\\n    return check;\\n}\\n    string e;\\n     \\n    string toconvert(string s)\\n    {\\n        string w;\\n        e.clear();\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            e+=tolower(s[i]);\\n            if(isVowel(s[i]))\\n                w+=\\'*\\';\\n            else\\n                w+=tolower(s[i]);\\n        }\\n        return w;\\n    }\\n     vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n       for(int  i=0;i<wordlist.size();i++)\\n       {\\n           string s=toconvert(wordlist[i]);\\n           s1[s].push_back(wordlist[i]);\\n           s21[e].push_back(wordlist[i]);\\n           m1[wordlist[i]]++;\\n           \\n       }\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            string s=toconvert(queries[i]);\\n             if(s1.find(s)!=s1.end())\\n            {\\n                \\n                if(m1[queries[i]]!=0)\\n                    v1.push_back(queries[i]);\\n                else if(s21.find(e)!=s21.end())\\n                {\\n                    v1.push_back(s21[e][0]);\\n                }\\n                else\\n                    v1.push_back(s1[s][0]);\\n                \\n            }\\n            else\\n            {\\n              v1.push_back(\"\");\\n            }\\n        }\\n    return v1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122137,
                "title": "vowel-spellchecker-c-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        unordered_set<string> s(wordlist.begin(), wordlist.end());\\n        unordered_map<string, string> m, mm;    \\n        vector<string> w(wordlist);\\n        for(int i=wordlist.size()-1;i>=0;i--){\\n            for(auto& j:w[i]) j=tolower(j);\\n            m[w[i]]=wordlist[i];\\n            for(auto& j:w[i]) if(j==\\'a\\' || j==\\'e\\' || j==\\'i\\' || j==\\'o\\' || j==\\'u\\') j=\\'.\\';\\n            mm[w[i]]=wordlist[i];\\n        }\\n        for(auto& i:queries){\\n            if(s.count(i)) continue;\\n            for(auto& j:i) j=tolower(j);\\n            if(m.count(i)){\\n                i=m[i];\\n                continue;\\n            }\\n            for(auto& j:i) if(j==\\'a\\' || j==\\'e\\' || j==\\'i\\' || j==\\'o\\' || j==\\'u\\') j=\\'.\\';\\n            if(mm.count(i)){\\n                i=mm[i];\\n                continue;\\n            }\\n            i=\"\";\\n        }\\n        return queries;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        unordered_set<string> s(wordlist.begin(), wordlist.end());\\n        unordered_map<string, string> m, mm;    \\n        vector<string> w(wordlist);\\n        for(int i=wordlist.size()-1;i>=0;i--){\\n            for(auto& j:w[i]) j=tolower(j);\\n            m[w[i]]=wordlist[i];\\n            for(auto& j:w[i]) if(j==\\'a\\' || j==\\'e\\' || j==\\'i\\' || j==\\'o\\' || j==\\'u\\') j=\\'.\\';\\n            mm[w[i]]=wordlist[i];\\n        }\\n        for(auto& i:queries){\\n            if(s.count(i)) continue;\\n            for(auto& j:i) j=tolower(j);\\n            if(m.count(i)){\\n                i=m[i];\\n                continue;\\n            }\\n            for(auto& j:i) if(j==\\'a\\' || j==\\'e\\' || j==\\'i\\' || j==\\'o\\' || j==\\'u\\') j=\\'.\\';\\n            if(mm.count(i)){\\n                i=mm[i];\\n                continue;\\n            }\\n            i=\"\";\\n        }\\n        return queries;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122136,
                "title": "typescript-hash-solution",
                "content": "```\\nconst spellchecker = (wordList: string[], queries: string[]): string[] => {\\n  const originalWords = new Set<string>();\\n  const lowerWords = new Map<string, string>();\\n  const devowelWords = new Map<string, string>();\\n\\n  for (const word of wordList) {\\n    originalWords.add(word);\\n    const lowerWord = word.toLowerCase();\\n    const devowelWord = devowel(lowerWord);\\n    if (!lowerWords.has(lowerWord)) {\\n      lowerWords.set(lowerWord, word);\\n    }\\n    if (!devowelWords.has(devowelWord)) {\\n      devowelWords.set(devowelWord, word);\\n    }\\n  }\\n  const res = [] as string[];\\n\\n  for (const query of queries) {\\n    if (originalWords.has(query)) {\\n      res.push(query);\\n      continue;\\n    }\\n    const lowerQuery = query.toLowerCase();\\n    if (lowerWords.has(lowerQuery)) {\\n      res.push(lowerWords.get(lowerQuery));\\n      continue;\\n    }\\n    const devowelQuery = devowel(lowerQuery);\\n    if (devowelWords.has(devowelQuery)) {\\n      res.push(devowelWords.get(devowelQuery));\\n      continue;\\n    }\\n    res.push(\\'\\');\\n  }\\n  return res;\\n};\\n\\nconst devowel = (word: string): string => {\\n  const newWordArr = [] as string[];\\n  for (const c of word) {\\n    if (\\'aeiou\\'.indexOf(c) !== -1) {\\n      newWordArr.push(\\'_\\');\\n    } else {\\n      newWordArr.push(c.toLowerCase());\\n    }\\n  }\\n  return newWordArr.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nconst spellchecker = (wordList: string[], queries: string[]): string[] => {\\n  const originalWords = new Set<string>();\\n  const lowerWords = new Map<string, string>();\\n  const devowelWords = new Map<string, string>();\\n\\n  for (const word of wordList) {\\n    originalWords.add(word);\\n    const lowerWord = word.toLowerCase();\\n    const devowelWord = devowel(lowerWord);\\n    if (!lowerWords.has(lowerWord)) {\\n      lowerWords.set(lowerWord, word);\\n    }\\n    if (!devowelWords.has(devowelWord)) {\\n      devowelWords.set(devowelWord, word);\\n    }\\n  }\\n  const res = [] as string[];\\n\\n  for (const query of queries) {\\n    if (originalWords.has(query)) {\\n      res.push(query);\\n      continue;\\n    }\\n    const lowerQuery = query.toLowerCase();\\n    if (lowerWords.has(lowerQuery)) {\\n      res.push(lowerWords.get(lowerQuery));\\n      continue;\\n    }\\n    const devowelQuery = devowel(lowerQuery);\\n    if (devowelWords.has(devowelQuery)) {\\n      res.push(devowelWords.get(devowelQuery));\\n      continue;\\n    }\\n    res.push(\\'\\');\\n  }\\n  return res;\\n};\\n\\nconst devowel = (word: string): string => {\\n  const newWordArr = [] as string[];\\n  for (const c of word) {\\n    if (\\'aeiou\\'.indexOf(c) !== -1) {\\n      newWordArr.push(\\'_\\');\\n    } else {\\n      newWordArr.push(c.toLowerCase());\\n    }\\n  }\\n  return newWordArr.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1122127,
                "title": "python-set-dict-dict",
                "content": "# Idea\\nThe problem statement is a bit convoluted, but essentially what is required is to find the best match according to specified priority.\\nFirst, we just check if there\\'s an exact match for the word by looking up in the set of all words in `wordList`.\\nThen, we see if by normalizing the capitalization of a query (converting to lowercase) we could find a match.\\nFinally, we normalize both the capitalization and the vowels, and see if we can find any match that way.\\n```\\ndef spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n\\tword_set = set(wordlist)\\n\\tword_capn = defaultdict(list)\\n\\tword_vwn = defaultdict(list)\\n\\tvwls = set([\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'])\\n\\tresult = []\\n\\n\\tdef vowel_norm(word):\\n\\t\\tchrs = []\\n\\t\\tfor ch in word:\\n\\t\\t\\tch = ch.lower()\\n\\t\\t\\tif ch in vwls: chrs.append(\\'*\\')\\n\\t\\t\\telse: chrs.append(ch)\\n\\t\\treturn \\'\\'.join(chrs)\\n\\n\\tfor word in wordlist:\\n\\t\\tword_capn[word.lower()].append(word)\\n\\t\\tword_vwn[vowel_norm(word)].append(word)\\n\\n\\tfor query in queries:\\n\\t\\tif query in word_set:\\n\\t\\t\\tresult.append(query)\\n\\t\\telif (lq := query.lower()) in word_capn:\\n\\t\\t\\tresult.append(word_capn[lq][0])\\n\\t\\telif (vn := vowel_norm(query)) in word_vwn:\\n\\t\\t\\tresult.append(word_vwn[vn][0])\\n\\t\\telse:\\n\\t\\t\\tresult.append(\\'\\')\\n\\n\\treturn result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\ndef spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n\\tword_set = set(wordlist)\\n\\tword_capn = defaultdict(list)\\n\\tword_vwn = defaultdict(list)\\n\\tvwls = set([\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'])\\n\\tresult = []\\n\\n\\tdef vowel_norm(word):\\n\\t\\tchrs = []\\n\\t\\tfor ch in word:\\n\\t\\t\\tch = ch.lower()\\n\\t\\t\\tif ch in vwls: chrs.append(\\'*\\')\\n\\t\\t\\telse: chrs.append(ch)\\n\\t\\treturn \\'\\'.join(chrs)\\n\\n\\tfor word in wordlist:\\n\\t\\tword_capn[word.lower()].append(word)\\n\\t\\tword_vwn[vowel_norm(word)].append(word)\\n\\n\\tfor query in queries:\\n\\t\\tif query in word_set:\\n\\t\\t\\tresult.append(query)\\n\\t\\telif (lq := query.lower()) in word_capn:\\n\\t\\t\\tresult.append(word_capn[lq][0])\\n\\t\\telif (vn := vowel_norm(query)) in word_vwn:\\n\\t\\t\\tresult.append(word_vwn[vn][0])\\n\\t\\telse:\\n\\t\\t\\tresult.append(\\'\\')\\n\\n\\treturn result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1121980,
                "title": "c-solution-easy-to-understand-using-maps",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\nunordered_set<string> us;\\n        unordered_map<string, string> um;\\n        vector<string> result;\\n        \\n        for (auto word : wordlist) {\\n            us.insert(word);\\n            \\n            string lowerCaseWord = toLowerCaseWord(word);\\n            string wordWithoutVowels = toWordWithoutVowels(lowerCaseWord);\\n            \\n            um.insert({lowerCaseWord, word});\\n            um.insert({wordWithoutVowels, word});            \\n        }\\n        \\n        for (auto query : queries) {\\n            if (us.count(query)) {\\n                result.push_back(query); continue;\\n            }\\n            \\n            query = toLowerCaseWord(query);\\n            if (um.count(query)) {\\n                result.push_back(um[query]); continue;\\n            }\\n            \\n            query = toWordWithoutVowels(query);\\n            if (um.count(query)) {\\n                result.push_back(um[query]); continue;\\n            }\\n            \\n            result.push_back(\"\");\\n        }\\n        \\n        return result;\\n    }\\n    \\n    string toLowerCaseWord(string str) {\\n        for (auto &ch : str)\\n            ch = tolower(ch);\\n        \\n        return str;\\n    }\\n    \\n    string toWordWithoutVowels(string str) {\\n        for (auto &ch : str)\\n            if (isVowel(ch))\\n                ch = \\'-\\';\\n        \\n        return str;\\n    }\\n    \\n    bool isVowel(char ch) {\\n        return ch == \\'a\\' or ch == \\'e\\' or ch == \\'i\\' or ch == \\'o\\' or ch == \\'u\\';\\n\\t\\t}\\n};\\n\\t\\t",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\nunordered_set<string> us;\\n        unordered_map<string, string> um;\\n        vector<string> result;\\n        \\n        for (auto word : wordlist) {\\n            us.insert(word);\\n            \\n            string lowerCaseWord = toLowerCaseWord(word);\\n            string wordWithoutVowels = toWordWithoutVowels(lowerCaseWord);\\n            \\n            um.insert({lowerCaseWord, word}",
                "codeTag": "Java"
            },
            {
                "id": 1121953,
                "title": "vowelspellchecker-java-soln-w-expln",
                "content": "The problem asks us to check whether the words in our query array matches the dictionary code. We need to do so keeping in mind the following rules:\\n* When the query exactly matches a word in the wordlist (case-sensitive), you should return the same word back.\\n* When the query matches a word up to capitlization, you should return the first such match in the wordlist.\\n* When the query matches a word up to vowel errors, you should return the first such match in the wordlist.\\n* If the query has no matches in the wordlist, you should return the empty string.\\n\\nLogic:\\nLet\\'s consider brute force appraoch. \\nWe can take each word in \\'queries\\' array and check against each word in \\'wordList\\' array. (case-insensitive check)\\nEven though we might get the right match for few of them, we still need to face the difficulty of handling words that might have vowel errors. In this case running a regex for every word will be very time consuming.\\n\\nSo the alternate solution is to use [Trie](https://en.wikipedia.org/wiki/Trie). \\nFor every word in the \\'wordList\\' array we will maintain a Trie structure. \\nFor example, let\\'s say our wordList = [\"kite\"]. Then our Trie structure will look something like below image.\\n\\'*\\' represents end of a word\\n![image](https://assets.leetcode.com/users/images/618ab525-dfd4-4c1f-a9c2-6119144d4e71_1616408455.8267794.png)\\n\\nThis still does not incorporate the vowels error problem. To address that, we will duplicate all the sub-tries of our vowels node to incorporate other vowels. So in the above example, for node \\'i\\' we will have four more nodes for other vowels with same sub-trie as \\'i\\'. Same for node \\'e\\'\\nOur Trie will now look something like this\\n![image](https://assets.leetcode.com/users/images/e0bafd75-70df-4a76-8265-1bfb72a7eccf_1616408694.9425037.png)\\n\\n\\nOn the above structure we can have a number of queries running for words with vowel errors and we will always end up with our dictionary word saved in the last node (one represented by \\'*\\')\\n\\nCode:\\n```\\nclass Trie {\\n    //stores a character and its subtrie\\n    Map<Character, Trie> characters;\\n    //denotes if there exists a word till here\\n    boolean isWord;\\n    //stores all the list of words in the order\\n    List<String> words;\\n\\n    Trie() {\\n        characters = new HashMap<>();\\n    }\\n}\\n\\npublic String[] spellchecker(String[] wordlist, String[] queries) {\\n    Set<String> uniqueWords = new HashSet<>();\\n    //our root of trie structure\\n    Map<Character, Trie> root = new HashMap<>();\\n\\n    Set<Character> vowels = new HashSet<>();\\n    vowels.add(\\'a\\');\\n    vowels.add(\\'e\\');\\n    vowels.add(\\'i\\');\\n    vowels.add(\\'o\\');\\n    vowels.add(\\'u\\');\\n\\n    String[] answer = new String[queries.length];\\n\\n    for(String word: wordlist) {\\n        uniqueWords.add(word);\\n        String lowerCase = word.toLowerCase();\\n        Map<Character, Trie> temp = root;\\n        //for every letter in word, create the trie structure\\n        for(int i = 0; i < word.length() - 1; i++) {\\n            char c = lowerCase.charAt(i);\\n            Trie newSubTrie = temp.getOrDefault(c, new Trie());\\n\\n            //if we encounter a vowel, duplicate the trie structure for all vowels\\n            if(vowels.contains(c)) {\\n                for(char v: vowels) {\\n                    temp.put(v, newSubTrie);\\n                }\\n            } else {\\n                temp.put(c, newSubTrie);\\n            }\\n\\n            temp = newSubTrie.characters;\\n        }\\n\\n        //for last character, mark the node as \\'hasWord\\' and add that word to the list\\n        char c = lowerCase.charAt(word.length() - 1);\\n        Trie newSubTrie = temp.getOrDefault(c, new Trie());\\n        newSubTrie.isWord = true;\\n        if(newSubTrie.words == null) {\\n            newSubTrie.words = new ArrayList<>();\\n        }\\n        newSubTrie.words.add(word);\\n        if(vowels.contains(c)) {\\n            for(char v: vowels) {\\n                temp.put(v, newSubTrie);\\n            }\\n        } else {\\n            temp.put(c, newSubTrie);\\n        }\\n    }\\n\\n    int index = 0;\\n    for(String query: queries) {\\n        //if there exists a word in our dictionary then refer that directly\\n        if(uniqueWords.contains(query)) {\\n            answer[index++] = query;\\n        } else {\\n            //else traverse the trie structure for every character in query word\\n            String word = query.toLowerCase();\\n            Map<Character, Trie> temp = root;\\n            Trie lastNode = null;\\n            for(char c: word.toCharArray()) {\\n                if(!temp.containsKey(c)) {\\n                    lastNode = null;\\n                    break;\\n                } else {\\n                    lastNode = temp.get(c);\\n                    temp =  temp.get(c).characters;\\n                }\\n            }\\n\\n            //if no such node exists then word is not present in dictionary\\n            if(lastNode == null || !lastNode.isWord) {\\n                answer[index++] = \"\";\\n            } else {\\n                //if there is a word present, check if the query word is different only in terms of capitalization\\n                boolean flag = true;\\n                for(String dictWord: lastNode.words) {\\n                    if(dictWord.equalsIgnoreCase(word)) {\\n                        answer[index++] = dictWord;\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                //if no such word with capitalization found, just take the first occurrence of word\\n                if(flag) {\\n                    answer[index++] = lastNode.words.get(0);\\n                }\\n            }\\n\\n        }\\n    }\\n\\n    return answer;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Trie {\\n    //stores a character and its subtrie\\n    Map<Character, Trie> characters;\\n    //denotes if there exists a word till here\\n    boolean isWord;\\n    //stores all the list of words in the order\\n    List<String> words;\\n\\n    Trie() {\\n        characters = new HashMap<>();\\n    }\\n}\\n\\npublic String[] spellchecker(String[] wordlist, String[] queries) {\\n    Set<String> uniqueWords = new HashSet<>();\\n    //our root of trie structure\\n    Map<Character, Trie> root = new HashMap<>();\\n\\n    Set<Character> vowels = new HashSet<>();\\n    vowels.add(\\'a\\');\\n    vowels.add(\\'e\\');\\n    vowels.add(\\'i\\');\\n    vowels.add(\\'o\\');\\n    vowels.add(\\'u\\');\\n\\n    String[] answer = new String[queries.length];\\n\\n    for(String word: wordlist) {\\n        uniqueWords.add(word);\\n        String lowerCase = word.toLowerCase();\\n        Map<Character, Trie> temp = root;\\n        //for every letter in word, create the trie structure\\n        for(int i = 0; i < word.length() - 1; i++) {\\n            char c = lowerCase.charAt(i);\\n            Trie newSubTrie = temp.getOrDefault(c, new Trie());\\n\\n            //if we encounter a vowel, duplicate the trie structure for all vowels\\n            if(vowels.contains(c)) {\\n                for(char v: vowels) {\\n                    temp.put(v, newSubTrie);\\n                }\\n            } else {\\n                temp.put(c, newSubTrie);\\n            }\\n\\n            temp = newSubTrie.characters;\\n        }\\n\\n        //for last character, mark the node as \\'hasWord\\' and add that word to the list\\n        char c = lowerCase.charAt(word.length() - 1);\\n        Trie newSubTrie = temp.getOrDefault(c, new Trie());\\n        newSubTrie.isWord = true;\\n        if(newSubTrie.words == null) {\\n            newSubTrie.words = new ArrayList<>();\\n        }\\n        newSubTrie.words.add(word);\\n        if(vowels.contains(c)) {\\n            for(char v: vowels) {\\n                temp.put(v, newSubTrie);\\n            }\\n        } else {\\n            temp.put(c, newSubTrie);\\n        }\\n    }\\n\\n    int index = 0;\\n    for(String query: queries) {\\n        //if there exists a word in our dictionary then refer that directly\\n        if(uniqueWords.contains(query)) {\\n            answer[index++] = query;\\n        } else {\\n            //else traverse the trie structure for every character in query word\\n            String word = query.toLowerCase();\\n            Map<Character, Trie> temp = root;\\n            Trie lastNode = null;\\n            for(char c: word.toCharArray()) {\\n                if(!temp.containsKey(c)) {\\n                    lastNode = null;\\n                    break;\\n                } else {\\n                    lastNode = temp.get(c);\\n                    temp =  temp.get(c).characters;\\n                }\\n            }\\n\\n            //if no such node exists then word is not present in dictionary\\n            if(lastNode == null || !lastNode.isWord) {\\n                answer[index++] = \"\";\\n            } else {\\n                //if there is a word present, check if the query word is different only in terms of capitalization\\n                boolean flag = true;\\n                for(String dictWord: lastNode.words) {\\n                    if(dictWord.equalsIgnoreCase(word)) {\\n                        answer[index++] = dictWord;\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                //if no such word with capitalization found, just take the first occurrence of word\\n                if(flag) {\\n                    answer[index++] = lastNode.words.get(0);\\n                }\\n            }\\n\\n        }\\n    }\\n\\n    return answer;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1121891,
                "title": "javascript-solution-100-concise",
                "content": "```\\nvar spellchecker = function(wordlist, queries) {\\n  const baseList = new Set(wordlist.reverse());\\n  const loweredList = wordlist.reduce((map, word) => (map[normalize(word)] = word, map), {});\\n  const replacedList = wordlist.reduce((map, word) => (map[repVowels(word)] = word, map), {});\\n  return queries.map(word => (\\n    baseList.has(word) && word    ||\\n\\tloweredList[normalize(word)]  ||\\n\\treplacedList[repVowels(word)] ||\\n\\t\\'\\'\\n  ));\\n};\\nvar normalize = function(word) { return word.toLowerCase() };\\nvar repVowels = function(word) { return normalize(word).replace(/[eiou]/g, \\'a\\') };\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar spellchecker = function(wordlist, queries) {\\n  const baseList = new Set(wordlist.reverse());\\n  const loweredList = wordlist.reduce((map, word) => (map[normalize(word)] = word, map), {});\\n  const replacedList = wordlist.reduce((map, word) => (map[repVowels(word)] = word, map), {});\\n  return queries.map(word => (\\n    baseList.has(word) && word    ||\\n\\tloweredList[normalize(word)]  ||\\n\\treplacedList[repVowels(word)] ||\\n\\t\\'\\'\\n  ));\\n};\\nvar normalize = function(word) { return word.toLowerCase() };\\nvar repVowels = function(word) { return normalize(word).replace(/[eiou]/g, \\'a\\') };\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1121878,
                "title": "java-vowel-spellchecker-2-hashmap-1-hashset-explained",
                "content": "Three types of query words:\\n1. The query is same as the word in the wordlist.\\n2. The query has the same letters and the same order, but has subtle different with the capitalization.\\n3. The query has similar letters. Only the vowels part are different with the word in the wordlist.\\n\\nIterate wordlist:\\n1. Add the word into `HashSet`.\\n2. Capitalize the word and add to the first `HashMap`.\\n3. Replace the vowels to `*` then add to the second `HashMap`. \\n\\nSince the question also noted that only return the first match, so only put the word into map when first meet.\\n\\nQueries:\\n\\n- For type 1 : Return the same word in the wordlist.\\n- For type 2 : Capitalize the query and return the word (all capitalize) from the first map.\\n- For type 3 : Replace the vowel part of the query (after capitalize), and return the word from the second map.\\n- For others: Return the empty string.\\n\\n```\\nclass Solution {\\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        HashSet<String> same = new HashSet<String>();\\n        HashMap<String, String> caseInsensitive = new HashMap<String, String>();\\n        HashMap<String, String> vowelMap = new HashMap<String, String>();\\n        \\n        for (String word: wordlist) {\\n\\t\\t\\tsame.add(word);\\n            String capital = word.toUpperCase();\\n            caseInsensitive.putIfAbsent(capital, word);\\n            vowelMap.putIfAbsent(replaceVowel(capital), word);\\n        }\\n        \\n        String[] res = new String[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            if (same.contains(queries[i])) {\\n                res[i] = queries[i];\\n                continue;\\n            }\\n            \\n            String cap = queries[i].toUpperCase(), vow = replaceVowel(cap);\\n            if (caseInsensitive.containsKey(cap)) {\\n                res[i] = caseInsensitive.get(cap);\\n            } else if (vowelMap.containsKey(vow)) {\\n                res[i] = vowelMap.get(vow);\\n            } else {\\n                res[i] = \"\";\\n            }\\n        }\\n        return res;\\n\\n    }\\n    \\n    private String replaceVowel(String s) {\\n        char[] ch = s.toCharArray();\\n        for (int i = 0; i < ch.length; i++) {\\n            if (ch[i] == \\'A\\' || ch[i] == \\'E\\' || ch[i] == \\'I\\' || ch[i] == \\'O\\' || ch[i] == \\'U\\')\\n                ch[i] = \\'*\\';\\n        }\\n        return new String(ch);\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        HashSet<String> same = new HashSet<String>();\\n        HashMap<String, String> caseInsensitive = new HashMap<String, String>();\\n        HashMap<String, String> vowelMap = new HashMap<String, String>();\\n        \\n        for (String word: wordlist) {\\n\\t\\t\\tsame.add(word);\\n            String capital = word.toUpperCase();\\n            caseInsensitive.putIfAbsent(capital, word);\\n            vowelMap.putIfAbsent(replaceVowel(capital), word);\\n        }\\n        \\n        String[] res = new String[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            if (same.contains(queries[i])) {\\n                res[i] = queries[i];\\n                continue;\\n            }\\n            \\n            String cap = queries[i].toUpperCase(), vow = replaceVowel(cap);\\n            if (caseInsensitive.containsKey(cap)) {\\n                res[i] = caseInsensitive.get(cap);\\n            } else if (vowelMap.containsKey(vow)) {\\n                res[i] = vowelMap.get(vow);\\n            } else {\\n                res[i] = \"\";\\n            }\\n        }\\n        return res;\\n\\n    }\\n    \\n    private String replaceVowel(String s) {\\n        char[] ch = s.toCharArray();\\n        for (int i = 0; i < ch.length; i++) {\\n            if (ch[i] == \\'A\\' || ch[i] == \\'E\\' || ch[i] == \\'I\\' || ch[i] == \\'O\\' || ch[i] == \\'U\\')\\n                ch[i] = \\'*\\';\\n        }\\n        return new String(ch);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1121851,
                "title": "vowel-spellchecker-python-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        table1=set()\\n        table2={}\\n        table3={}\\n        for i in wordlist:\\n            table1.add(i)\\n            key1=i.lower()\\n            if key1 not in table2:\\n                table2[key1]=i\\n            key2=\"\".join(j if j not in \"aeiou\" else \"*\" for j in key1)\\n            if key2 not in table3:\\n                table3[key2]=i\\n        res=[]\\n        for i in queries:\\n            if i in table1:\\n                res.append(i)\\n                continue\\n            word1=i.lower()\\n            if word1 in table2:\\n                res.append(table2[word1])\\n                continue\\n            word2=\"\".join(j if j not in \"aeiou\" else \"*\" for j in word1)\\n            if word2 in table3:\\n                res.append(table3[word2])\\n            else:\\n                res.append(\"\")\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        table1=set()\\n        table2={}\\n        table3={}\\n        for i in wordlist:\\n            table1.add(i)\\n            key1=i.lower()\\n            if key1 not in table2:\\n                table2[key1]=i\\n            key2=\"\".join(j if j not in \"aeiou\" else \"*\" for j in key1)\\n            if key2 not in table3:\\n                table3[key2]=i\\n        res=[]\\n        for i in queries:\\n            if i in table1:\\n                res.append(i)\\n                continue\\n            word1=i.lower()\\n            if word1 in table2:\\n                res.append(table2[word1])\\n                continue\\n            word2=\"\".join(j if j not in \"aeiou\" else \"*\" for j in word1)\\n            if word2 in table3:\\n                res.append(table3[word2])\\n            else:\\n                res.append(\"\")\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1121803,
                "title": "rust-solution",
                "content": "```rust\\nuse std::collections::{HashMap, HashSet};\\n\\nimpl Solution {\\n    pub fn spellchecker(wordlist: Vec<String>, queries: Vec<String>) -> Vec<String> {\\n        let mut exactly_matches = HashSet::new();\\n        let mut capitalization = HashMap::new();\\n        let mut vowel = HashMap::new();\\n        let to_any_vowels = |s: &String| -> String {\\n            s.to_ascii_lowercase().replace(\\n                |c| match c {\\n                    \\'a\\' | \\'e\\' | \\'i\\' | \\'o\\' | \\'u\\' => true,\\n                    _ => false,\\n                },\\n                \"*\",\\n            )\\n        };\\n        for word in wordlist.iter() {\\n            exactly_matches.insert(word);\\n            capitalization\\n                .entry(word.to_ascii_lowercase())\\n                .or_insert(word);\\n            vowel.entry(to_any_vowels(word)).or_insert(word);\\n        }\\n        let convert = |s: &String| -> String {\\n            if exactly_matches.contains(s) {\\n                return s.clone();\\n            }\\n            if let Some(&collect) = capitalization.get(&s.to_ascii_lowercase()) {\\n                return collect.clone();\\n            }\\n            if let Some(&collect) = vowel.get(&to_any_vowels(s)) {\\n                return collect.clone();\\n            }\\n            String::new()\\n        };\\n        queries.iter().map(convert).collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::{HashMap, HashSet};\\n\\nimpl Solution {\\n    pub fn spellchecker(wordlist: Vec<String>, queries: Vec<String>) -> Vec<String> {\\n        let mut exactly_matches = HashSet::new();\\n        let mut capitalization = HashMap::new();\\n        let mut vowel = HashMap::new();\\n        let to_any_vowels = |s: &String| -> String {\\n            s.to_ascii_lowercase().replace(\\n                |c| match c {\\n                    \\'a\\' | \\'e\\' | \\'i\\' | \\'o\\' | \\'u\\' => true,\\n                    _ => false,\\n                },\\n                \"*\",\\n            )\\n        };\\n        for word in wordlist.iter() {\\n            exactly_matches.insert(word);\\n            capitalization\\n                .entry(word.to_ascii_lowercase())\\n                .or_insert(word);\\n            vowel.entry(to_any_vowels(word)).or_insert(word);\\n        }\\n        let convert = |s: &String| -> String {\\n            if exactly_matches.contains(s) {\\n                return s.clone();\\n            }\\n            if let Some(&collect) = capitalization.get(&s.to_ascii_lowercase()) {\\n                return collect.clone();\\n            }\\n            if let Some(&collect) = vowel.get(&to_any_vowels(s)) {\\n                return collect.clone();\\n            }\\n            String::new()\\n        };\\n        queries.iter().map(convert).collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1121776,
                "title": "python",
                "content": "```python\\nclass Solution:\\n    def spellchecker(self, wordlist, queries):\\n        #bOreD -> b*r*d\\n\\t\\tdef get_template(word):\\n            template = \\'\\'\\n            for c in word:\\n                if c.lower() in {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'}:\\n                    template += \\'*\\'\\n                else:\\n                    template += c.lower()\\n            return template\\n        \\n        \\n        htc = collections.defaultdict(list)\\n        for word in wordlist:\\n            key = word.lower()\\n            htc[key].append(word)\\n        \\n        htv = collections.defaultdict(list)\\n        for word in wordlist:\\n            key = get_template(word)\\n            htv[key].append(word)\\n        \\n        ans = []\\n        for word in queries:\\n            key1 = word.lower() #bOreD -> bored\\n            key2 = get_template(word) #bOreD -> b*r*d\\n            if word in htc[key1]: #is bOreD seen?\\n                ans.append(word)\\n            elif htc[key1]: #is (any word) -> bored seen?\\n                ans.append(htc[key1][0])\\n            elif htv[key2]: #is (any word) -> b*r*d seen?\\n                ans.append(htv[key2][0])\\n            else: #nothing is seen!\\n                ans.append(\\'\\')\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def spellchecker(self, wordlist, queries):\\n        #bOreD -> b*r*d\\n\\t\\tdef get_template(word):\\n            template = \\'\\'\\n            for c in word:\\n                if c.lower() in {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'}:\\n                    template += \\'*\\'\\n                else:\\n                    template += c.lower()\\n            return template\\n        \\n        \\n        htc = collections.defaultdict(list)\\n        for word in wordlist:\\n            key = word.lower()\\n            htc[key].append(word)\\n        \\n        htv = collections.defaultdict(list)\\n        for word in wordlist:\\n            key = get_template(word)\\n            htv[key].append(word)\\n        \\n        ans = []\\n        for word in queries:\\n            key1 = word.lower() #bOreD -> bored\\n            key2 = get_template(word) #bOreD -> b*r*d\\n            if word in htc[key1]: #is bOreD seen?\\n                ans.append(word)\\n            elif htc[key1]: #is (any word) -> bored seen?\\n                ans.append(htc[key1][0])\\n            elif htv[key2]: #is (any word) -> b*r*d seen?\\n                ans.append(htv[key2][0])\\n            else: #nothing is seen!\\n                ans.append(\\'\\')\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 981316,
                "title": "python3-3-hash-tables",
                "content": "**Algo**\\nSince the criterion of word matching is hierarchical in nature, we define 3 hash tables here to look a word. \\n`orig` is a hash set of original word;\\n`case` is mapping from lower case version to original one;\\n`vowel` is a special mapping where vowels are replaced by a character (here `*` is chosen)\\n\\n**Implementation**\\n(168ms, 88.58%)\\n```\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        orig = set(wordlist) # original words O(1) lookup \\n        case = {} # diff in case\\n        vowel = {} # diff in vowel\\n        \\n        for word in wordlist: \\n            key = word.lower()\\n            case.setdefault(key, []).append(word)\\n            for c in \"aeiou\": key = key.replace(c, \"*\")\\n            vowel.setdefault(key, []).append(word)\\n        \\n        ans = []\\n        for word in queries: \\n            if word in orig: ans.append(word)\\n            else: \\n                key = word.lower()\\n                if key in case: ans.append(case[key][0])\\n                else: \\n                    for c in \"aeiou\": key = key.replace(c, \"*\")\\n                    if key in vowel: ans.append(vowel[key][0])\\n                    else: ans.append(\"\")\\n        return ans \\n```\\n\\n**Analysis**\\nTime complexity `O(MN)` (where `N` is number of words and `M` is average size of words)\\nSpace complexity `O(MN)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        orig = set(wordlist) # original words O(1) lookup \\n        case = {} # diff in case\\n        vowel = {} # diff in vowel\\n        \\n        for word in wordlist: \\n            key = word.lower()\\n            case.setdefault(key, []).append(word)\\n            for c in \"aeiou\": key = key.replace(c, \"*\")\\n            vowel.setdefault(key, []).append(word)\\n        \\n        ans = []\\n        for word in queries: \\n            if word in orig: ans.append(word)\\n            else: \\n                key = word.lower()\\n                if key in case: ans.append(case[key][0])\\n                else: \\n                    for c in \"aeiou\": key = key.replace(c, \"*\")\\n                    if key in vowel: ans.append(vowel[key][0])\\n                    else: ans.append(\"\")\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 971548,
                "title": "21ms-faster-java",
                "content": "```\\nimport java.util.ArrayList;\\nimport java.util.HashMap;\\nimport java.util.List;\\nimport java.util.Map;\\n\\nclass Solution {\\n\\tpublic String[] spellchecker(String[] wordlist, String[] queries) {\\n\\n\\t\\tMap<String, List<String>> map = new HashMap<>();\\n\\n\\t\\tfor (String word : wordlist) {\\n\\n\\t\\t\\tString w = word.toLowerCase();\\n\\t\\t\\tmap.putIfAbsent(w, new ArrayList<>());\\n\\t\\t\\tmap.get(w).add(word);\\n\\n\\t\\t\\tString gen = getGeneric(w);\\n\\t\\t\\tmap.putIfAbsent(gen, new ArrayList<>());\\n\\t\\t\\tmap.get(gen).add(word);\\n\\n\\t\\t}\\n\\n\\t\\tString[] out = new String[queries.length];\\n\\t\\tint i = 0;\\n\\t\\tfor (String q : queries) {\\n\\n\\t\\t\\tString s = q.toLowerCase();\\n\\n\\t\\t\\tif (map.containsKey(s)) {\\n\\n\\t\\t\\t\\tList<String> possible = map.get(s);\\n\\t\\t\\t\\tfor (String temp : possible) {\\n\\t\\t\\t\\t\\tif (temp.equals(q)) {\\n\\t\\t\\t\\t\\t\\tout[i] = temp;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (out[i] == null) {\\n\\t\\t\\t\\t\\tout[i] = possible.get(0);\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (out[i] == null) {\\n\\n\\t\\t\\t\\tString gen = getGeneric(s);\\n\\n\\t\\t\\t\\tif (map.containsKey(gen)) {\\n\\n\\t\\t\\t\\t\\tList<String> possible = map.get(gen);\\n\\n\\t\\t\\t\\t\\tout[i] = possible.get(0);\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\tif (out[i] == null) {\\n\\t\\t\\t\\tout[i] = \"\";\\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\treturn out;\\n\\t}\\n\\n\\tString getGeneric(String w) {\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tfor (char c : w.toCharArray()) {\\n\\t\\t\\tif (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\') {\\n\\t\\t\\t\\tsb.append(\"_\");\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsb.append(c);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn sb.toString();\\n\\t}\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.ArrayList;\\nimport java.util.HashMap;\\nimport java.util.List;\\nimport java.util.Map;\\n\\nclass Solution {\\n\\tpublic String[] spellchecker(String[] wordlist, String[] queries) {\\n\\n\\t\\tMap<String, List<String>> map = new HashMap<>();\\n\\n\\t\\tfor (String word : wordlist) {\\n\\n\\t\\t\\tString w = word.toLowerCase();\\n\\t\\t\\tmap.putIfAbsent(w, new ArrayList<>());\\n\\t\\t\\tmap.get(w).add(word);\\n\\n\\t\\t\\tString gen = getGeneric(w);\\n\\t\\t\\tmap.putIfAbsent(gen, new ArrayList<>());\\n\\t\\t\\tmap.get(gen).add(word);\\n\\n\\t\\t}\\n\\n\\t\\tString[] out = new String[queries.length];\\n\\t\\tint i = 0;\\n\\t\\tfor (String q : queries) {\\n\\n\\t\\t\\tString s = q.toLowerCase();\\n\\n\\t\\t\\tif (map.containsKey(s)) {\\n\\n\\t\\t\\t\\tList<String> possible = map.get(s);\\n\\t\\t\\t\\tfor (String temp : possible) {\\n\\t\\t\\t\\t\\tif (temp.equals(q)) {\\n\\t\\t\\t\\t\\t\\tout[i] = temp;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (out[i] == null) {\\n\\t\\t\\t\\t\\tout[i] = possible.get(0);\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (out[i] == null) {\\n\\n\\t\\t\\t\\tString gen = getGeneric(s);\\n\\n\\t\\t\\t\\tif (map.containsKey(gen)) {\\n\\n\\t\\t\\t\\t\\tList<String> possible = map.get(gen);\\n\\n\\t\\t\\t\\t\\tout[i] = possible.get(0);\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\tif (out[i] == null) {\\n\\t\\t\\t\\tout[i] = \"\";\\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\treturn out;\\n\\t}\\n\\n\\tString getGeneric(String w) {\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tfor (char c : w.toCharArray()) {\\n\\t\\t\\tif (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\') {\\n\\t\\t\\t\\tsb.append(\"_\");\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsb.append(c);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn sb.toString();\\n\\t}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 950931,
                "title": "python-3-dict-easy-to-understand-solution",
                "content": "```\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        ans=[]\\n        vows={}\\n        low={}\\n        normal={}\\n        for word in wordlist:\\n            normal[word]=0\\n            low[word.lower()]=low.get(word.lower(),[])+[word]\\n            t=\"\"\\n            for i in word.lower():\\n                if i in \"aeiou\":\\n                    t+=\"*\"\\n                else:\\n                    t+=i \\n            vows[t]=vows.get(t,[])+[word]\\n        for query in queries:\\n            if query in normal:\\n                ans.append(query)\\n            elif query.lower() in low:\\n                ans.append(low[query.lower()][0])\\n            else:\\n                t=\"\"\\n                for i in query.lower():\\n                    if i in \"aeiou\":\\n                        t+=\"*\"\\n                    else:\\n                        t+=i \\n                if t in vows:\\n                    ans.append(vows[t][0])\\n                else:\\n                    ans.append(\"\")\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        ans=[]\\n        vows={}\\n        low={}\\n        normal={}\\n        for word in wordlist:\\n            normal[word]=0\\n            low[word.lower()]=low.get(word.lower(),[])+[word]\\n            t=\"\"\\n            for i in word.lower():\\n                if i in \"aeiou\":\\n                    t+=\"*\"\\n                else:\\n                    t+=i \\n            vows[t]=vows.get(t,[])+[word]\\n        for query in queries:\\n            if query in normal:\\n                ans.append(query)\\n            elif query.lower() in low:\\n                ans.append(low[query.lower()][0])\\n            else:\\n                t=\"\"\\n                for i in query.lower():\\n                    if i in \"aeiou\":\\n                        t+=\"*\"\\n                    else:\\n                        t+=i \\n                if t in vows:\\n                    ans.append(vows[t][0])\\n                else:\\n                    ans.append(\"\")\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 886347,
                "title": "rust-translated-28ms-100",
                "content": "```rust\\nimpl Solution {\\n    pub fn spellchecker(wordlist: Vec<String>, mut queries: Vec<String>) -> Vec<String> {\\n        use std::collections::{HashMap, HashSet};\\n        use std::iter::FromIterator;\\n\\n        let mut cap = HashMap::<String, String>::new();\\n        let mut vowel = HashMap::<String, String>::new();\\n        for w in &wordlist {\\n            let lower = w.to_lowercase();\\n            let v = lower\\n                .chars()\\n                .map(|ch| if \"aeiou\".contains(ch) { \\'#\\' } else { ch })\\n                .collect::<String>();\\n            cap.entry(lower).or_insert_with(|| w.to_owned());\\n            vowel.entry(v).or_insert_with(|| w.to_owned());\\n        }\\n        let words: HashSet<String> = HashSet::from_iter(wordlist.into_iter());\\n        for (_, q) in queries.iter_mut().enumerate() {\\n            if words.contains(q) {\\n                continue;\\n            }\\n            let lower = q.to_lowercase();\\n            let v = lower\\n                .chars()\\n                .map(|ch| if \"aeiou\".contains(ch) { \\'#\\' } else { ch })\\n                .collect::<String>();\\n            if cap.contains_key(&lower) {\\n                *q = cap[&lower].to_owned();\\n            } else if vowel.contains_key(&v) {\\n                *q = vowel[&v].to_owned();\\n            } else {\\n                (*q).clear();\\n            }\\n        }\\n        queries\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_spellchecker() {\\n        assert_eq!(\\n            Solution::spellchecker(\\n                vec![\\n                    \"KiTe\".to_owned(),\\n                    \"kite\".to_owned(),\\n                    \"hare\".to_owned(),\\n                    \"Hare\".to_owned()\\n                ],\\n                vec![\\n                    \"kite\".to_owned(),\\n                    \"Kite\".to_owned(),\\n                    \"KiTe\".to_owned(),\\n                    \"Hare\".to_owned(),\\n                    \"HARE\".to_owned(),\\n                    \"Hear\".to_owned(),\\n                    \"hear\".to_owned(),\\n                    \"keti\".to_owned(),\\n                    \"keet\".to_owned(),\\n                    \"keto\".to_owned()\\n                ]\\n            ),\\n            vec![\\n                \"kite\".to_owned(),\\n                \"KiTe\".to_owned(),\\n                \"KiTe\".to_owned(),\\n                \"Hare\".to_owned(),\\n                \"hare\".to_owned(),\\n                \"\".to_owned(),\\n                \"\".to_owned(),\\n                \"KiTe\".to_owned(),\\n                \"\".to_owned(),\\n                \"KiTe\".to_owned()\\n            ]\\n        );\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn spellchecker(wordlist: Vec<String>, mut queries: Vec<String>) -> Vec<String> {\\n        use std::collections::{HashMap, HashSet};\\n        use std::iter::FromIterator;\\n\\n        let mut cap = HashMap::<String, String>::new();\\n        let mut vowel = HashMap::<String, String>::new();\\n        for w in &wordlist {\\n            let lower = w.to_lowercase();\\n            let v = lower\\n                .chars()\\n                .map(|ch| if \"aeiou\".contains(ch) { \\'#\\' } else { ch })\\n                .collect::<String>();\\n            cap.entry(lower).or_insert_with(|| w.to_owned());\\n            vowel.entry(v).or_insert_with(|| w.to_owned());\\n        }\\n        let words: HashSet<String> = HashSet::from_iter(wordlist.into_iter());\\n        for (_, q) in queries.iter_mut().enumerate() {\\n            if words.contains(q) {\\n                continue;\\n            }\\n            let lower = q.to_lowercase();\\n            let v = lower\\n                .chars()\\n                .map(|ch| if \"aeiou\".contains(ch) { \\'#\\' } else { ch })\\n                .collect::<String>();\\n            if cap.contains_key(&lower) {\\n                *q = cap[&lower].to_owned();\\n            } else if vowel.contains_key(&v) {\\n                *q = vowel[&v].to_owned();\\n            } else {\\n                (*q).clear();\\n            }\\n        }\\n        queries\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_spellchecker() {\\n        assert_eq!(\\n            Solution::spellchecker(\\n                vec![\\n                    \"KiTe\".to_owned(),\\n                    \"kite\".to_owned(),\\n                    \"hare\".to_owned(),\\n                    \"Hare\".to_owned()\\n                ],\\n                vec![\\n                    \"kite\".to_owned(),\\n                    \"Kite\".to_owned(),\\n                    \"KiTe\".to_owned(),\\n                    \"Hare\".to_owned(),\\n                    \"HARE\".to_owned(),\\n                    \"Hear\".to_owned(),\\n                    \"hear\".to_owned(),\\n                    \"keti\".to_owned(),\\n                    \"keet\".to_owned(),\\n                    \"keto\".to_owned()\\n                ]\\n            ),\\n            vec![\\n                \"kite\".to_owned(),\\n                \"KiTe\".to_owned(),\\n                \"KiTe\".to_owned(),\\n                \"Hare\".to_owned(),\\n                \"hare\".to_owned(),\\n                \"\".to_owned(),\\n                \"\".to_owned(),\\n                \"KiTe\".to_owned(),\\n                \"\".to_owned(),\\n                \"KiTe\".to_owned()\\n            ]\\n        );\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 838793,
                "title": "python-3-hash-table-wild-card-explanations",
                "content": "### Explanation\\n- For each `query` in `queries`\\n\\t- If `query` itself is a word in `wordlist`, add itself (original)\\n\\t- If `query` change to lower case is in `low_origin`, add `low_origin[query]` \\n\\t- If any vowel combinations of `query` is in `wild_origin`, add `wild_origin[query]`\\n\\t- else, add empty string `\\'\\'`\\n- You don\\'t need to find all combination of vowels of query, simply mark vowels in query as `*`\\n### Implementation\\n```\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        low_origin, wild_origin = collections.defaultdict(str), collections.defaultdict(str)\\n        s = set(wordlist)            \\n        def to_wild(word): return \\'\\'.join([\\'*\\' if c in \\'aeiou\\' else c for c in word])\\n        \\n        for word in wordlist:\\n            low = word.lower()\\n            if low not in low_origin: low_origin[low] = word\\n            wild = to_wild(low)\\n            if wild not in wild_origin: wild_origin[wild] = word\\n            \\n        ans = []\\n        for query in queries:\\n            low = query.lower()\\n            wild = to_wild(low)\\n            if query in s: ans.append(query)\\n            elif low in low_origin: ans.append(low_origin[low])    \\n            elif wild in wild_origin: ans.append(wild_origin[wild]) \\n            else: ans.append(\\'\\')\\n        return ans        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        low_origin, wild_origin = collections.defaultdict(str), collections.defaultdict(str)\\n        s = set(wordlist)            \\n        def to_wild(word): return \\'\\'.join([\\'*\\' if c in \\'aeiou\\' else c for c in word])\\n        \\n        for word in wordlist:\\n            low = word.lower()\\n            if low not in low_origin: low_origin[low] = word\\n            wild = to_wild(low)\\n            if wild not in wild_origin: wild_origin[wild] = word\\n            \\n        ans = []\\n        for query in queries:\\n            low = query.lower()\\n            wild = to_wild(low)\\n            if query in s: ans.append(query)\\n            elif low in low_origin: ans.append(low_origin[low])    \\n            elif wild in wild_origin: ans.append(wild_origin[wild]) \\n            else: ans.append(\\'\\')\\n        return ans        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 799522,
                "title": "three-trie-trees-or-one-hashtable-python-code-with-comments",
                "content": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.nxt = defaultdict(TrieNode)\\n        self.word = None \\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    def insert(self, word, origword=None):\\n        node = self.root\\n        for char in word:\\n            if char not in node.nxt:\\n                node.nxt[char] = TrieNode()\\n            node = node.nxt[char]\\n        if not node.word or len(node.word) == 0:\\n            node.word = origword if origword else word # only keep one oldest is fine\\n        \\n    def find(self, word):\\n        node = self.root\\n        for char in word:\\n            if not char in node.nxt:\\n                return \\'\\'\\n            node = node.nxt[char]\\n        return \\'\\' if not node.word else node.word\\n\\nclass Solution(object):\\n    def spellchecker(self, wordlist, queries): # Trie tree method\\n        trieprefect = Trie()\\n        trielow = Trie()\\n        trievowdel = Trie()\\n        import re\\n        \\n        for word in wordlist:\\n            trieprefect.insert(word)\\n            trielow.insert(word.lower(), word)\\n            trievowdel.insert(re.sub(\\'[a|e|i|o|u]\\', \\' \\', word.lower()), word)\\n        \\n        outq = []\\n        for query in queries:\\n            qprefect = trieprefect.find(query) # prefect match first\\n            if qprefect != \\'\\':\\n                outq.append(qprefect)\\n            else:\\n                qlow = trielow.find(query.lower()) # lower match second\\n                if qlow != \\'\\':\\n                    outq.append(qlow)\\n                else:\\n                    qvowdel = trievowdel.find(re.sub(\\'[a|e|i|o|u]\\', \\' \\', query.lower())) \\n                    # lower and rm aeiou third\\n                    if qvowdel != \\'\\':\\n                        outq.append(qvowdel)\\n                    else:\\n                        outq.append(\\'\\')\\n        return outq\\n        \\n    def spellchecker1(self, wordlist , queries ) : # hashtable method\\n        # 1. the same\\n        # 2. case diff, all in lowercase then compare, hash of wordlist(low:orig.list)\\n        # 3. vowel diff, same length, compare after replacing relative position info all aeiou with \\' \\' (compare all in lowercase)\\n        \\n        def rmvowel(word):\\n            return re.sub(\\'(a|e|i|o|u)\\', \\' \\', word.lower())\\n        \\n        wordhash = defaultdict(str)\\n        for word in wordlist:\\n            wordhash[(word, 1)] = \\'\\'\\n            wordlow = word.lower()\\n            if not (wordlow, 2) in wordhash:\\n                wordhash[(wordlow, 2)] = (word) # keep the oldest one\\n            wordlowvow = rmvowel(word)\\n            if not (wordlowvow, 3) in wordhash:\\n                wordhash[(wordlowvow, 3)] = (word) # keep the oldest one\\n        \\n        outq = []\\n        for query in queries:\\n            if (query, 1) in wordhash:\\n                outq.append(query) # original format\\n            else:\\n                qlow = query.lower()\\n                if (qlow, 2) in wordhash:\\n                    outq.append(wordhash[(qlow, 2)])\\n                else:\\n                    qlowvow = rmvowel(query)\\n                    if (qlowvow, 3) in wordhash:\\n                        outq.append(wordhash[(qlowvow, 3)])\\n                    else:\\n                        outq.append(\\'\\')\\n        return outq\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.nxt = defaultdict(TrieNode)\\n        self.word = None \\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    def insert(self, word, origword=None):\\n        node = self.root\\n        for char in word:\\n            if char not in node.nxt:\\n                node.nxt[char] = TrieNode()\\n            node = node.nxt[char]\\n        if not node.word or len(node.word) == 0:\\n            node.word = origword if origword else word # only keep one oldest is fine\\n        \\n    def find(self, word):\\n        node = self.root\\n        for char in word:\\n            if not char in node.nxt:\\n                return \\'\\'\\n            node = node.nxt[char]\\n        return \\'\\' if not node.word else node.word\\n\\nclass Solution(object):\\n    def spellchecker(self, wordlist, queries): # Trie tree method\\n        trieprefect = Trie()\\n        trielow = Trie()\\n        trievowdel = Trie()\\n        import re\\n        \\n        for word in wordlist:\\n            trieprefect.insert(word)\\n            trielow.insert(word.lower(), word)\\n            trievowdel.insert(re.sub(\\'[a|e|i|o|u]\\', \\' \\', word.lower()), word)\\n        \\n        outq = []\\n        for query in queries:\\n            qprefect = trieprefect.find(query) # prefect match first\\n            if qprefect != \\'\\':\\n                outq.append(qprefect)\\n            else:\\n                qlow = trielow.find(query.lower()) # lower match second\\n                if qlow != \\'\\':\\n                    outq.append(qlow)\\n                else:\\n                    qvowdel = trievowdel.find(re.sub(\\'[a|e|i|o|u]\\', \\' \\', query.lower())) \\n                    # lower and rm aeiou third\\n                    if qvowdel != \\'\\':\\n                        outq.append(qvowdel)\\n                    else:\\n                        outq.append(\\'\\')\\n        return outq\\n        \\n    def spellchecker1(self, wordlist , queries ) : # hashtable method\\n        # 1. the same\\n        # 2. case diff, all in lowercase then compare, hash of wordlist(low:orig.list)\\n        # 3. vowel diff, same length, compare after replacing relative position info all aeiou with \\' \\' (compare all in lowercase)\\n        \\n        def rmvowel(word):\\n            return re.sub(\\'(a|e|i|o|u)\\', \\' \\', word.lower())\\n        \\n        wordhash = defaultdict(str)\\n        for word in wordlist:\\n            wordhash[(word, 1)] = \\'\\'\\n            wordlow = word.lower()\\n            if not (wordlow, 2) in wordhash:\\n                wordhash[(wordlow, 2)] = (word) # keep the oldest one\\n            wordlowvow = rmvowel(word)\\n            if not (wordlowvow, 3) in wordhash:\\n                wordhash[(wordlowvow, 3)] = (word) # keep the oldest one\\n        \\n        outq = []\\n        for query in queries:\\n            if (query, 1) in wordhash:\\n                outq.append(query) # original format\\n            else:\\n                qlow = query.lower()\\n                if (qlow, 2) in wordhash:\\n                    outq.append(wordhash[(qlow, 2)])\\n                else:\\n                    qlowvow = rmvowel(query)\\n                    if (qlowvow, 3) in wordhash:\\n                        outq.append(wordhash[(qlowvow, 3)])\\n                    else:\\n                        outq.append(\\'\\')\\n        return outq\\n```",
                "codeTag": "Java"
            },
            {
                "id": 534496,
                "title": "java-two-map-and-set",
                "content": "```\\nclass Solution {\\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        String[] res = new String[queries.length];\\n        Set<String> dict = new HashSet<>();\\n        HashMap<String, String> cap = new HashMap<>();\\n        HashMap<String, String> vowel = new HashMap<>();\\n        for(String w : wordlist) {\\n            dict.add(w);\\n            String lower = w.toLowerCase();\\n            if(!cap.containsKey(lower)) {\\n                cap.put(lower, w);\\n            }\\n            String v = removeVowel(lower);\\n            if(!vowel.containsKey(v)) {\\n                vowel.put(v, w);\\n            }\\n        }\\n        for(int i = 0; i < queries.length; i++) {\\n            String q = queries[i];\\n            String lowerq = q.toLowerCase();\\n            String devowelq = removeVowel(lowerq);\\n            if(dict.contains(q)) {\\n                res[i] = q;\\n            } else if(cap.containsKey(lowerq)) {\\n                res[i] = cap.get(lowerq);\\n            } else if(vowel.containsKey(devowelq)) {\\n                res[i] = vowel.get(devowelq);\\n            } else {\\n                res[i] = \"\";\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private String removeVowel(String w) {\\n        StringBuilder sb = new StringBuilder();\\n        for(char c : w.toCharArray()) {\\n            if(isVowel(c)) {\\n                sb.append(\\'*\\');\\n            } else {\\n                sb.append(c);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private boolean isVowel(char c) {\\n        if(c == \\'a\\' || c ==\\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\') {\\n            return true;\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        String[] res = new String[queries.length];\\n        Set<String> dict = new HashSet<>();\\n        HashMap<String, String> cap = new HashMap<>();\\n        HashMap<String, String> vowel = new HashMap<>();\\n        for(String w : wordlist) {\\n            dict.add(w);\\n            String lower = w.toLowerCase();\\n            if(!cap.containsKey(lower)) {\\n                cap.put(lower, w);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 211265,
                "title": "my-solution-using-trie",
                "content": "Don\\'t think this is the optimal solution, but this is my first reponse during contest. \\nBasically treat all vowels char as the same node in Trie, and store all words at the end node. \\nAlso pay attention to \"xxx under the following precedence rules\", so capitalization has priority over changing vowels, thus need one more step to search capitalized match when querying. \\n\\n```\\nclass Solution {\\n    \\n    TrieNode root = new TrieNode();\\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        String[] res = new String[queries.length];\\n        for (String word : wordlist) {\\n            insert(word);\\n        }\\n        for (int i = 0; i < queries.length; i++) {\\n            res[i] = query(queries[i]);\\n        }\\n        return res;\\n    }\\n    \\n    private void insert(String word) {\\n        TrieNode node = root;\\n        for (char c : word.toCharArray()) {\\n            if (\"aeiouAEIOU\".indexOf(c) != -1) {\\n                if (node.children[0] == null) {\\n                    node.children[0] = new TrieNode();\\n                }\\n                node = node.children[0];\\n            } else {\\n                c = Character.toLowerCase(c);\\n                if (node.children[c - \\'a\\'] == null) {\\n                   node.children[c - \\'a\\'] = new TrieNode();\\n                }\\n                node = node.children[c - \\'a\\'];\\n            }\\n        }\\n        node.isEnd = true;\\n        node.list.add(word); // Store all words at the end node.\\n    }\\n    \\n    private String query(String word) {\\n        TrieNode node = root;\\n        for (char c : word.toCharArray()) {\\n            if (\"aeiouAEIOU\".indexOf(c) != -1) {\\n                if (node.children[0] == null) return \"\";\\n                node = node.children[0];\\n            } else {\\n                c = Character.toLowerCase(c);\\n                if (node.children[c - \\'a\\'] == null) return \"\";\\n                node = node.children[c - \\'a\\'];\\n            }\\n        }\\n        if (node.isEnd == false) return \"\";   // If not end, return empty\\n        if (node.list.contains(word)) return word; // If list contains exactly the same word, return the word.\\n        \\n        String res = findCap(node.list, word); // Search for the first capitalized match\\n        if (res != \"\") return res;\\n      \\n        return node.list.get(0); // Return the first one that change vowels\\n    }\\n    \\n    private String findCap(List<String> list, String word) {\\n        for (String str : list) {\\n            if (str.toLowerCase().equals(word.toLowerCase())) return str;\\n        }\\n        return \"\";\\n    }\\n    \\n}\\n\\nclass TrieNode {\\n    TrieNode[] children = new TrieNode[26];\\n    boolean isEnd = false;\\n    List<String> list = new ArrayList<>();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    TrieNode root = new TrieNode();\\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        String[] res = new String[queries.length];\\n        for (String word : wordlist) {\\n            insert(word);\\n        }\\n        for (int i = 0; i < queries.length; i++) {\\n            res[i] = query(queries[i]);\\n        }\\n        return res;\\n    }\\n    \\n    private void insert(String word) {\\n        TrieNode node = root;\\n        for (char c : word.toCharArray()) {\\n            if (\"aeiouAEIOU\".indexOf(c) != -1) {\\n                if (node.children[0] == null) {\\n                    node.children[0] = new TrieNode();\\n                }\\n                node = node.children[0];\\n            } else {\\n                c = Character.toLowerCase(c);\\n                if (node.children[c - \\'a\\'] == null) {\\n                   node.children[c - \\'a\\'] = new TrieNode();\\n                }\\n                node = node.children[c - \\'a\\'];\\n            }\\n        }\\n        node.isEnd = true;\\n        node.list.add(word); // Store all words at the end node.\\n    }\\n    \\n    private String query(String word) {\\n        TrieNode node = root;\\n        for (char c : word.toCharArray()) {\\n            if (\"aeiouAEIOU\".indexOf(c) != -1) {\\n                if (node.children[0] == null) return \"\";\\n                node = node.children[0];\\n            } else {\\n                c = Character.toLowerCase(c);\\n                if (node.children[c - \\'a\\'] == null) return \"\";\\n                node = node.children[c - \\'a\\'];\\n            }\\n        }\\n        if (node.isEnd == false) return \"\";   // If not end, return empty\\n        if (node.list.contains(word)) return word; // If list contains exactly the same word, return the word.\\n        \\n        String res = findCap(node.list, word); // Search for the first capitalized match\\n        if (res != \"\") return res;\\n      \\n        return node.list.get(0); // Return the first one that change vowels\\n    }\\n    \\n    private String findCap(List<String> list, String word) {\\n        for (String str : list) {\\n            if (str.toLowerCase().equals(word.toLowerCase())) return str;\\n        }\\n        return \"\";\\n    }\\n    \\n}\\n\\nclass TrieNode {\\n    TrieNode[] children = new TrieNode[26];\\n    boolean isEnd = false;\\n    List<String> list = new ArrayList<>();\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046140,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        seen = set()\\n        lower = {}\\n        mapping = {}\\n        final = []\\n\\n        def convert(word: str) -> Tuple[str]:\\n            word = list(word.lower())\\n\\n            for i in range(len(word)):\\n                if word[i] in \\'aeiou\\':\\n                    word[i] = \\'\\'\\n            \\n            return tuple(word)\\n\\n        for x in wordlist:\\n            seen.add(x)\\n            if x.lower() not in lower:\\n                lower[x.lower()] = x\\n            converted = convert(x)\\n            mapping[converted] = mapping.get(converted, [])\\n            mapping[converted].append(x)\\n        \\n        for x in queries:\\n            if x in seen:\\n                final.append(x)\\n            elif x.lower() in lower:\\n                final.append(lower[x.lower()])\\n            elif convert(x) in mapping:\\n                final.append(mapping[convert(x)][0])\\n            else:\\n                final.append(\\'\\')\\n        \\n        return final\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        seen = set()\\n        lower = {}\\n        mapping = {}\\n        final = []\\n\\n        def convert(word: str) -> Tuple[str]:\\n            word = list(word.lower())\\n\\n            for i in range(len(word)):\\n                if word[i] in \\'aeiou\\':\\n                    word[i] = \\'\\'\\n            \\n            return tuple(word)\\n\\n        for x in wordlist:\\n            seen.add(x)\\n            if x.lower() not in lower:\\n                lower[x.lower()] = x\\n            converted = convert(x)\\n            mapping[converted] = mapping.get(converted, [])\\n            mapping[converted].append(x)\\n        \\n        for x in queries:\\n            if x in seen:\\n                final.append(x)\\n            elif x.lower() in lower:\\n                final.append(lower[x.lower()])\\n            elif convert(x) in mapping:\\n                final.append(mapping[convert(x)][0])\\n            else:\\n                final.append(\\'\\')\\n        \\n        return final\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915775,
                "title": "java-13ms-100-using-set-and-trie-not-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private class trie{\\n        String v;\\n        trie[] next;\\n\\n        trie(){\\n            v=\"\"; next=new trie[27];\\n        }\\n        void put(String s){\\n            String t = s.toLowerCase();\\n\\n            int n1, n2;\\n            trie t1=this, t2=this;\\n\\n            for(int i=0; i<t.length(); i++){\\n                n1 = n2 = (t.charAt(i)-\\'a\\');\\n                if(n2==0 || n2==4 || n2==8 || n2==14 || n2==20)n2=26;\\n                if(t1.next[n1]==null)t1.next[n1]=new trie();\\n                if(t2.next[n2]==null)t2.next[n2]=new trie();\\n\\n                t1=t1.next[n1];\\n                t2=t2.next[n2];\\n            }\\n\\n            if(t1.v.equals(\"\"))t1.v=s;\\n            if(t2.v.equals(\"\"))t2.v=s;\\n        }\\n        String get(String s){\\n            String t = s.toLowerCase();\\n\\n            String r = find(t, true);\\n            if(r.equals(\"\"))r=find(t, false);\\n            return r;\\n        }\\n        String find(String t, boolean cap){\\n            trie tr = this;\\n            int n=0;\\n\\n            for(int i=0; i<t.length(); i++){\\n                n = t.charAt(i)-\\'a\\';\\n                if(!cap && (n==0 || n==4 || n==8 || n==14 || n==20))n=26;\\n                if(tr.next[n]==null)return \"\";\\n                tr=tr.next[n];\\n            }\\n            return tr.v;\\n        }\\n    }\\n    public String[] spellchecker(String[] w, String[] q) {\\n        Set<String> set = new HashSet<>();\\n        trie head = new trie();\\n        for(String s:w){\\n            head.put(s); set.add(s);\\n        }\\n\\n        for(int i=0; i<q.length; i++){\\n            if(!set.contains(q[i]))q[i]=head.get(q[i]);\\n        }\\n\\n        return q;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private class trie{\\n        String v;\\n        trie[] next;\\n\\n        trie(){\\n            v=\"\"; next=new trie[27];\\n        }\\n        void put(String s){\\n            String t = s.toLowerCase();\\n\\n            int n1, n2;\\n            trie t1=this, t2=this;\\n\\n            for(int i=0; i<t.length(); i++){\\n                n1 = n2 = (t.charAt(i)-\\'a\\');\\n                if(n2==0 || n2==4 || n2==8 || n2==14 || n2==20)n2=26;\\n                if(t1.next[n1]==null)t1.next[n1]=new trie();\\n                if(t2.next[n2]==null)t2.next[n2]=new trie();\\n\\n                t1=t1.next[n1];\\n                t2=t2.next[n2];\\n            }\\n\\n            if(t1.v.equals(\"\"))t1.v=s;\\n            if(t2.v.equals(\"\"))t2.v=s;\\n        }\\n        String get(String s){\\n            String t = s.toLowerCase();\\n\\n            String r = find(t, true);\\n            if(r.equals(\"\"))r=find(t, false);\\n            return r;\\n        }\\n        String find(String t, boolean cap){\\n            trie tr = this;\\n            int n=0;\\n\\n            for(int i=0; i<t.length(); i++){\\n                n = t.charAt(i)-\\'a\\';\\n                if(!cap && (n==0 || n==4 || n==8 || n==14 || n==20))n=26;\\n                if(tr.next[n]==null)return \"\";\\n                tr=tr.next[n];\\n            }\\n            return tr.v;\\n        }\\n    }\\n    public String[] spellchecker(String[] w, String[] q) {\\n        Set<String> set = new HashSet<>();\\n        trie head = new trie();\\n        for(String s:w){\\n            head.put(s); set.add(s);\\n        }\\n\\n        for(int i=0; i<q.length; i++){\\n            if(!set.contains(q[i]))q[i]=head.get(q[i]);\\n        }\\n\\n        return q;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819173,
                "title": "java-solution-easy-approach-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        int n = queries.length;\\n\\n        HashSet<String> set = new HashSet<>();\\n        HashMap<String,Integer> map = new HashMap<>();\\n        HashMap<String,Integer> mapO = new HashMap<>();\\n        String arr[] = new String[n];\\n        for(String str : wordlist) set.add(str);\\n        for(int i=0; i<wordlist.length; i++) {\\n            if(!mapO.containsKey(wordlist[i].toLowerCase())) {\\n                mapO.put(wordlist[i].toLowerCase(),i);\\n            }\\n        }\\n        \\n        \\n        for(int i=0; i<wordlist.length; i++) {\\n            String str = change(wordlist[i]);\\n\\n            if(!map.containsKey(str)) {\\n                map.put(str,i);\\n            }\\n        }\\n\\n\\n        for(int i=0; i<n; i++) {\\n            String str = queries[i];\\n            if(set.contains(str)) {\\n                arr[i] = str;\\n\\n            } else if(mapO.containsKey(str.toLowerCase())) {\\n                 arr[i] = wordlist[mapO.get(str.toLowerCase())];\\n\\n            } else if(map.containsKey(change(str))) {\\n                arr[i] = wordlist[map.get(change(str))];\\n\\n            } else {\\n                arr[i] = \"\";\\n            }\\n        }\\n\\n       return arr;\\n    }\\n\\n\\n\\n\\n\\n   // Function to change the form of a String to compare \\n    public static String change(String str) {\\n        str = str.toLowerCase();\\n        StringBuilder sb = new StringBuilder();\\n\\n        for(int i=0; i<str.length(); i++) {\\n            char ch = str.charAt(i);\\n            if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') {\\n                sb.append(\\'0\\');\\n            } else {\\n                sb.append(ch);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        int n = queries.length;\\n\\n        HashSet<String> set = new HashSet<>();\\n        HashMap<String,Integer> map = new HashMap<>();\\n        HashMap<String,Integer> mapO = new HashMap<>();\\n        String arr[] = new String[n];\\n        for(String str : wordlist) set.add(str);\\n        for(int i=0; i<wordlist.length; i++) {\\n            if(!mapO.containsKey(wordlist[i].toLowerCase())) {\\n                mapO.put(wordlist[i].toLowerCase(),i);\\n            }\\n        }\\n        \\n        \\n        for(int i=0; i<wordlist.length; i++) {\\n            String str = change(wordlist[i]);\\n\\n            if(!map.containsKey(str)) {\\n                map.put(str,i);\\n            }\\n        }\\n\\n\\n        for(int i=0; i<n; i++) {\\n            String str = queries[i];\\n            if(set.contains(str)) {\\n                arr[i] = str;\\n\\n            } else if(mapO.containsKey(str.toLowerCase())) {\\n                 arr[i] = wordlist[mapO.get(str.toLowerCase())];\\n\\n            } else if(map.containsKey(change(str))) {\\n                arr[i] = wordlist[map.get(change(str))];\\n\\n            } else {\\n                arr[i] = \"\";\\n            }\\n        }\\n\\n       return arr;\\n    }\\n\\n\\n\\n\\n\\n   // Function to change the form of a String to compare \\n    public static String change(String str) {\\n        str = str.toLowerCase();\\n        StringBuilder sb = new StringBuilder();\\n\\n        for(int i=0; i<str.length(); i++) {\\n            char ch = str.charAt(i);\\n            if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') {\\n                sb.append(\\'0\\');\\n            } else {\\n                sb.append(ch);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818331,
                "title": "vowel-spellchecker",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- brute&optimal - use set to store wordlist which are distinct and use 2 map to store lower case words with normal worldlist value , and 2nd map to store that lower case words whose vowoels replace by * with wordlist words . then traverse the queries list and check the exact match of queries words with set words , else check query words transformed to lower form with map 1 containing lower case as key , else check vowel map by converting query word to same * form of vowels in it and check vowel map key for it  \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- brute&optimal - use set to store wordlist which are distinct and use 2 map to store lower case words with normal worldlist value , and 2nd map to store that lower case words whose vowoels replace by * with wordlist words . then traverse the queries list and check the exact match of queries words with set words , else check query words transformed to lower form with map 1 containing lower case as key , else check vowel map by converting query word to same * form of vowels in it and check vowel map key for it  \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- O((N + Q) * M)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- O(N + Q)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        unordered_set<string> exact;\\n        unordered_map<string, string> cap, vow;\\n        \\n        for(string &s : wordlist){\\n            exact.insert(s);\\n            string s2 = s;\\n            transform(s2.begin(), s2.end(), s2.begin(), ::tolower);\\n            if(!cap.count(s2)) cap[s2] = s;\\n            for(char &ch : s2){\\n                if(ch == \\'a\\' || ch ==\\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') ch = \\'*\\';\\n            }\\n            if(!vow.count(s2)) vow[s2] = s;\\n        }\\n        vector<string> res(queries.size(), \"\");\\n        for(int i = 0; i < queries.size(); i++){\\n            if(exact.count(queries[i])) {\\n                res[i] = queries[i];\\n                continue;\\n            }\\n            string s = queries[i];\\n            transform(s.begin(), s.end(), s.begin(), ::tolower);\\n            if(cap.count(s)) {\\n                res[i] = cap[s];\\n                continue;\\n            }\\n            for(char &ch : s){\\n                if(ch == \\'a\\' || ch ==\\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') ch = \\'*\\';\\n            }\\n            if(vow.count(s)) res[i] = vow[s];\\n        }\\n        return res;\\n    }\\n};\\n// class Solution {\\n// public:\\n//     vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n//         unordered_set<string> exact;\\n//         unordered_map<string , string >c,v;\\n\\n//         vector<string> res ;\\n\\n//         for( auto s : wordlist)\\n//         {\\n//             exact.insert(s);\\n//             string s2=s;\\n//             transform(s2.begin(),s2.end(),s2.begin(), ::tolower );\\n//             if(!c.count(s2)) \\n//             {\\n//                 c[s2]=s;\\n//             }\\n\\n           \\n//             for(auto ch : s2)  { if(ch == \\'a\\' || ch ==\\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') ch = \\'*\\'; }\\n//             if(!v.count(s2)) \\n//             {\\n//             v[s2]=s;\\n//             }\\n//         }\\n\\n//             for(int i=0 ; i<queries.size();i++)\\n//             {\\n//                 if(exact.count(queries[i]))\\n//                 {\\n//                     res.push_back(queries[i]);\\n//                     continue;\\n//                 }\\n                \\n//                 string s1=queries[i];\\n//                 transform(s1.begin(),s1.end(),s1.begin(), ::tolower);\\n//                 if(c.count(s1))\\n//                 {\\n//                     res.push_back(v[s1]);\\n//                     continue;\\n//                 }\\n                \\n//                 for(auto ch : s1)  { if(ch == \\'a\\' || ch ==\\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') ch = \\'*\\'; }\\n//                 if(v.count(s1))\\n//                 {\\n//                     res.push_back(v[s1]);\\n//                     continue;\\n//                 } \\n//                 else {\\n\\n//                 res.push_back(\"\");\\n\\n//             }\\n//             return res;\\n\\n        \\n//     }\\n// };\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        unordered_set<string> exact;\\n        unordered_map<string, string> cap, vow;\\n        \\n        for(string &s : wordlist){\\n            exact.insert(s);\\n            string s2 = s;\\n            transform(s2.begin(), s2.end(), s2.begin(), ::tolower);\\n            if(!cap.count(s2)) cap[s2] = s;\\n            for(char &ch : s2){\\n                if(ch == \\'a\\' || ch ==\\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') ch = \\'*\\';\\n            }\\n            if(!vow.count(s2)) vow[s2] = s;\\n        }\\n        vector<string> res(queries.size(), \"\");\\n        for(int i = 0; i < queries.size(); i++){\\n            if(exact.count(queries[i])) {\\n                res[i] = queries[i];\\n                continue;\\n            }\\n            string s = queries[i];\\n            transform(s.begin(), s.end(), s.begin(), ::tolower);\\n            if(cap.count(s)) {\\n                res[i] = cap[s];\\n                continue;\\n            }\\n            for(char &ch : s){\\n                if(ch == \\'a\\' || ch ==\\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') ch = \\'*\\';\\n            }\\n            if(vow.count(s)) res[i] = vow[s];\\n        }\\n        return res;\\n    }\\n};\\n// class Solution {\\n// public:\\n//     vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n//         unordered_set<string> exact;\\n//         unordered_map<string , string >c,v;\\n\\n//         vector<string> res ;\\n\\n//         for( auto s : wordlist)\\n//         {\\n//             exact.insert(s);\\n//             string s2=s;\\n//             transform(s2.begin(),s2.end(),s2.begin(), ::tolower );\\n//             if(!c.count(s2)) \\n//             {\\n//                 c[s2]=s;\\n//             }\\n\\n           \\n//             for(auto ch : s2)  { if(ch == \\'a\\' || ch ==\\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') ch = \\'*\\'; }\\n//             if(!v.count(s2)) \\n//             {\\n//             v[s2]=s;\\n//             }\\n//         }\\n\\n//             for(int i=0 ; i<queries.size();i++)\\n//             {\\n//                 if(exact.count(queries[i]))\\n//                 {\\n//                     res.push_back(queries[i]);\\n//                     continue;\\n//                 }\\n                \\n//                 string s1=queries[i];\\n//                 transform(s1.begin(),s1.end(),s1.begin(), ::tolower);\\n//                 if(c.count(s1))\\n//                 {\\n//                     res.push_back(v[s1]);\\n//                     continue;\\n//                 }\\n                \\n//                 for(auto ch : s1)  { if(ch == \\'a\\' || ch ==\\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') ch = \\'*\\'; }\\n//                 if(v.count(s1))\\n//                 {\\n//                     res.push_back(v[s1]);\\n//                     continue;\\n//                 } \\n//                 else {\\n\\n//                 res.push_back(\"\");\\n\\n//             }\\n//             return res;\\n\\n        \\n//     }\\n// };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769266,
                "title": "logical-elimination-for-speed-up-commented-and-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe set of all unique words in wordlist is a subset of all words in wordlist\\nThe set of all lower unique words in wordlist is a subset of all unique words in word list \\nThe set of all decapitalized and devoweled lower unique words in wordlist is a subset of all lower unique words in word list, BUT these words may be encountered before those in their superset \\n\\nBy thinking in terms of sets and presence in groupings, we can utilize this to advance our progression through the wordlist. Any word we have encountered before, we can skip. This also can apply to whether or not to update our words lower and words decapitalized \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMake generics for devoweling and in grouping as needed \\nMake a collection (faster then set) of Counter for the wordlist \\nMake a map of words visited of word -> 0 for word in word list collection\\nMake a words lower and words decap devowel listing \\n\\n- For word in wordlist \\n    - if you\\'ve visited, skip it \\n    - Otherwise, get the word lower \\n    - If words visited at word lower is 0\\n        - mark words lower mapping at word lower to word \\n    - do similar for decap devowel \\n    - and update visited \\n\\nSet result as a list of strings of size queries \\n- enumerate index and query in queries \\n- if in grouping words perfect \\n    - result at index is query \\n- otherwise \\n    - get lower \\n    - if lower in grouping words lower \\n        - result at index is words lower at lower \\n    - otherwise \\n        - result at index is either words decap devowl at decap devowel of lower or \"\" (use get function and default) \\n\\nreturn result          \\n\\n# Complexity\\n- Time complexity : O(W) to build word list \\n\\n- Space complexity : O(3W) \\n    - word list, word lower, word decap devowel  \\n\\n# Code\\n```\\nclass Solution :\\n    def spellchecker(self, wordlist : List[ str ], queries : List[ str ]) -> List[ str ] :\\n        # devowel method as a join of characters \\n        devowel = lambda word : \"\".join(\"_\" if c in \"aeiou\" else c for c in word)\\n        # in grouping method for various types of containers \\n        in_grouping = lambda item, grouping : item in grouping \\n        # get all the words and their frequencies \\n        words_perfect = collections.Counter(wordlist)\\n        words_visited = {word_key : 0 for word_key in words_perfect}\\n        # get lower and lower with no vowels \\n        words_lower   = {}\\n        words_decap_devowel = {} \\n        # by looping over words\\n        for word in wordlist : \\n            # if we\\'ve visited, skip it \\n            if words_visited[word] > 0 : \\n                continue \\n            else : \\n                # otherwise, do lower first \\n                wL = word.lower()\\n                if words_visited.get(wL, 0) == 0 : \\n                    words_lower[wL] = word \\n                    words_visited[wL] = 1 \\n                # then devowel it \\n                wLV = devowel(wL) \\n                if words_visited.get(wLV, 0) == 0 : \\n                    words_decap_devowel[wLV] = word \\n                    words_visited[wLV] = 1 \\n                # then mark visited \\n                words_visited[word] = 1 \\n\\n        # build result \\n        result = [\"\"]*len(queries) \\n        # by looping over queries \\n        for index, query in enumerate(queries) : \\n            # if we have this word exactly, add it \\n            if in_grouping(query, words_perfect) : \\n                result[index] = query\\n            else : \\n                # if we have the lower form of it, add it\\'s lower form \\n                qL = query.lower()\\n                if in_grouping(qL, words_lower) : \\n                    result[index] = words_lower[qL]\\n                else : \\n                    # if we have the devoweld lower form add that \\n                    # otherwise, add \"\" \\n                    result[index] = words_decap_devowel.get(devowel(qL), \"\")\\n        # return result \\n        return result \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution :\\n    def spellchecker(self, wordlist : List[ str ], queries : List[ str ]) -> List[ str ] :\\n        # devowel method as a join of characters \\n        devowel = lambda word : \"\".join(\"_\" if c in \"aeiou\" else c for c in word)\\n        # in grouping method for various types of containers \\n        in_grouping = lambda item, grouping : item in grouping \\n        # get all the words and their frequencies \\n        words_perfect = collections.Counter(wordlist)\\n        words_visited = {word_key : 0 for word_key in words_perfect}\\n        # get lower and lower with no vowels \\n        words_lower   = {}\\n        words_decap_devowel = {} \\n        # by looping over words\\n        for word in wordlist : \\n            # if we\\'ve visited, skip it \\n            if words_visited[word] > 0 : \\n                continue \\n            else : \\n                # otherwise, do lower first \\n                wL = word.lower()\\n                if words_visited.get(wL, 0) == 0 : \\n                    words_lower[wL] = word \\n                    words_visited[wL] = 1 \\n                # then devowel it \\n                wLV = devowel(wL) \\n                if words_visited.get(wLV, 0) == 0 : \\n                    words_decap_devowel[wLV] = word \\n                    words_visited[wLV] = 1 \\n                # then mark visited \\n                words_visited[word] = 1 \\n\\n        # build result \\n        result = [\"\"]*len(queries) \\n        # by looping over queries \\n        for index, query in enumerate(queries) : \\n            # if we have this word exactly, add it \\n            if in_grouping(query, words_perfect) : \\n                result[index] = query\\n            else : \\n                # if we have the lower form of it, add it\\'s lower form \\n                qL = query.lower()\\n                if in_grouping(qL, words_lower) : \\n                    result[index] = words_lower[qL]\\n                else : \\n                    # if we have the devoweld lower form add that \\n                    # otherwise, add \"\" \\n                    result[index] = words_decap_devowel.get(devowel(qL), \"\")\\n        # return result \\n        return result \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723563,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        Map<String, List<String>> map1 = buildCaseInsensitiveHashMap(wordlist);\\n        Map<String, List<String>> map2 = buildConstonantsMap(wordlist);\\n        String[] ans = new String[queries.length];\\n\\n        for(int i=0; i<queries.length; i++) {\\n            String word = caseChecker(map1, queries[i]);\\n            if(!word.equals(\"\"))\\n                ans[i] = word;\\n            else {\\n                word = vowelChecker(map2, queries[i]);\\n            }\\n            ans[i] = word;\\n        }\\n        // for(int i=0; i<ans.length; i++) {\\n        //     System.out.print(\"(\"+queries[i]+\", \"+ans[i]+\") \");\\n        // }\\n         return ans;\\n    }\\n\\n    public String vowelChecker(Map<String, List<String>> map, String query){\\n        String q_cons = extractConstonants(query);\\n        if(map.containsKey(q_cons)) {\\n            List<String> words = map.get(q_cons);\\n            if(words.contains(query))\\n                return query;\\n            else\\n                return words.get(0);\\n        }else \\n            return \"\";\\n    }\\n\\n    public String caseChecker(Map<String, List<String>> map, String query) {\\n        String lower = query.toLowerCase();\\n        if(map.containsKey(lower)) {\\n            List<String> strs = map.get(lower);\\n            if(strs.contains(query))\\n                return query;\\n            else\\n                return strs.get(0);\\n        }\\n        else{\\n            return \"\";\\n        }\\n    }\\n\\n    public Map<String, List<String>> buildCaseInsensitiveHashMap(String[] wordlist) {\\n        Map<String, List<String>> map =new HashMap<String, List<String>>();\\n        for(String word: wordlist) {\\n            String lower = word.toLowerCase();\\n            if(!map.containsKey(lower)) \\n                map.put(lower, new ArrayList<String>());\\n            map.get(lower).add(word);\\n        }\\n\\n        return map;\\n    }\\n\\n    public Map<String, List<String>> buildConstonantsMap(String[] wordlist) {\\n        Map<String, List<String>> map =new HashMap<String, List<String>>();\\n        for(String word: wordlist) {\\n            String cons = extractConstonants(word);\\n            if(!map.containsKey(cons))\\n                map.put(cons, new ArrayList<String>());\\n            map.get(cons).add(word);\\n        }\\n        return map;\\n    }\\n\\n    public String extractConstonants(String str) {\\n        String ans=\"\";\\n        str = str.toLowerCase();\\n        for(char c: str.toCharArray()) {\\n            if(c!=\\'a\\' && c!=\\'e\\' && c!=\\'i\\' && c!=\\'o\\' && c!=\\'u\\') {\\n                ans += c;\\n            }else{\\n                ans+=\"*\";\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        Map<String, List<String>> map1 = buildCaseInsensitiveHashMap(wordlist);\\n        Map<String, List<String>> map2 = buildConstonantsMap(wordlist);\\n        String[] ans = new String[queries.length];\\n\\n        for(int i=0; i<queries.length; i++) {\\n            String word = caseChecker(map1, queries[i]);\\n            if(!word.equals(\"\"))\\n                ans[i] = word;\\n            else {\\n                word = vowelChecker(map2, queries[i]);\\n            }\\n            ans[i] = word;\\n        }\\n        // for(int i=0; i<ans.length; i++) {\\n        //     System.out.print(\"(\"+queries[i]+\", \"+ans[i]+\") \");\\n        // }\\n         return ans;\\n    }\\n\\n    public String vowelChecker(Map<String, List<String>> map, String query){\\n        String q_cons = extractConstonants(query);\\n        if(map.containsKey(q_cons)) {\\n            List<String> words = map.get(q_cons);\\n            if(words.contains(query))\\n                return query;\\n            else\\n                return words.get(0);\\n        }else \\n            return \"\";\\n    }\\n\\n    public String caseChecker(Map<String, List<String>> map, String query) {\\n        String lower = query.toLowerCase();\\n        if(map.containsKey(lower)) {\\n            List<String> strs = map.get(lower);\\n            if(strs.contains(query))\\n                return query;\\n            else\\n                return strs.get(0);\\n        }\\n        else{\\n            return \"\";\\n        }\\n    }\\n\\n    public Map<String, List<String>> buildCaseInsensitiveHashMap(String[] wordlist) {\\n        Map<String, List<String>> map =new HashMap<String, List<String>>();\\n        for(String word: wordlist) {\\n            String lower = word.toLowerCase();\\n            if(!map.containsKey(lower)) \\n                map.put(lower, new ArrayList<String>());\\n            map.get(lower).add(word);\\n        }\\n\\n        return map;\\n    }\\n\\n    public Map<String, List<String>> buildConstonantsMap(String[] wordlist) {\\n        Map<String, List<String>> map =new HashMap<String, List<String>>();\\n        for(String word: wordlist) {\\n            String cons = extractConstonants(word);\\n            if(!map.containsKey(cons))\\n                map.put(cons, new ArrayList<String>());\\n            map.get(cons).add(word);\\n        }\\n        return map;\\n    }\\n\\n    public String extractConstonants(String str) {\\n        String ans=\"\";\\n        str = str.toLowerCase();\\n        for(char c: str.toCharArray()) {\\n            if(c!=\\'a\\' && c!=\\'e\\' && c!=\\'i\\' && c!=\\'o\\' && c!=\\'u\\') {\\n                ans += c;\\n            }else{\\n                ans+=\"*\";\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540580,
                "title": "java-solution-96-fast",
                "content": "# Intuition\\n4 levels of comparisons, go through them one by one.\\n\\n1) Exact match --> Do nothing\\n2) Case insensitive match -> return first such match in wordlist\\n3) Case insensitive and Vowel ignore match -> return first such match in wordlist\\n4) None of the above(No Match) -> return empty string  \\n\\n# Approach\\n3 Data structures for 3 comparisons:\\n1) 1 set to hold all the words in wordlist for comparison no. 1\\n2) 1 map to hold the lowercase versions of all the words in wordlist, and then the value of that key would be first appearing word whose lowercase matches that key, for comparison no. 2\\n3) 1 map to hold the vowelcase of every word in wordlist \\n(here, vowelcase means a string which has all the non-vowel characters present with vowels replaced by a placeholder (**```\\'.\\'```** here))\\nvalue of that key would be the first string in wordlist which matches that vowelcase key\\n\\n\\n# Complexity\\nLets assume ```queries``` will have many more entries than ```wordlist```, let that number be **```n```**\\nand let the length og longest string including both arrays be **```k```**\\n- Time complexity:\\nParsing the queries array : $$O(n)$$\\nlowercase and vowelcase conversion for every string: 2*k = $$O(k)$$\\n**Total : O(n * k)**\\n\\n\\n\\n- Space complexity:\\ninput : $$O(n*k)$$\\nset : $$O(n*k)$$\\nmap1 and map2 : 2*(n*k) = $$O(n*k)$$\\n**Total : O(n * k)**\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        Set<String> words = new HashSet<>();\\n        Map<String,String> lowercaseMap = new HashMap<>();\\n        Map<String,String> vowelcaseMap = new HashMap<>();\\n        for(String word:wordlist){\\n            words.add(word);\\n            String lower = word.toLowerCase();\\n            lowercaseMap.putIfAbsent(lower,word);\\n            vowelcaseMap.putIfAbsent(getVowelCase(lower),word);\\n        }\\n\\n        for(int i=0;i<queries.length;i++){\\n            String word = queries[i];\\n            if(words.contains(word)) continue;\\n            String lower = word.toLowerCase();\\n            if(lowercaseMap.containsKey(lower)){\\n                queries[i] = lowercaseMap.get(lower);\\n                continue;\\n            }\\n            String vowelcase = getVowelCase(lower);\\n            if(vowelcaseMap.containsKey(vowelcase))\\n                queries[i] = vowelcaseMap.get(vowelcase);\\n            else queries[i] = \"\";\\n        }\\n\\n        return queries;\\n    }\\n\\n    public String getVowelCase(String str){\\n        char[] arr = str.toCharArray();\\n        for(int i=0;i<arr.length;i++)\\n            if(isVowel(arr[i]))\\n                arr[i] = \\'.\\';\\n        return String.valueOf(arr);\\n    }\\n\\n    public boolean isVowel(char ch){\\n        return ch==\\'a\\' || ch==\\'e\\' ||\\n        ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\';\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\'.\\'```\n```queries```\n```wordlist```\n```n```\n```k```\n```\\nclass Solution {\\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        Set<String> words = new HashSet<>();\\n        Map<String,String> lowercaseMap = new HashMap<>();\\n        Map<String,String> vowelcaseMap = new HashMap<>();\\n        for(String word:wordlist){\\n            words.add(word);\\n            String lower = word.toLowerCase();\\n            lowercaseMap.putIfAbsent(lower,word);\\n            vowelcaseMap.putIfAbsent(getVowelCase(lower),word);\\n        }\\n\\n        for(int i=0;i<queries.length;i++){\\n            String word = queries[i];\\n            if(words.contains(word)) continue;\\n            String lower = word.toLowerCase();\\n            if(lowercaseMap.containsKey(lower)){\\n                queries[i] = lowercaseMap.get(lower);\\n                continue;\\n            }\\n            String vowelcase = getVowelCase(lower);\\n            if(vowelcaseMap.containsKey(vowelcase))\\n                queries[i] = vowelcaseMap.get(vowelcase);\\n            else queries[i] = \"\";\\n        }\\n\\n        return queries;\\n    }\\n\\n    public String getVowelCase(String str){\\n        char[] arr = str.toCharArray();\\n        for(int i=0;i<arr.length;i++)\\n            if(isVowel(arr[i]))\\n                arr[i] = \\'.\\';\\n        return String.valueOf(arr);\\n    }\\n\\n    public boolean isVowel(char ch){\\n        return ch==\\'a\\' || ch==\\'e\\' ||\\n        ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\';\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372732,
                "title": "hashing-simple-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    bool isVowel(char ch)\\n    {\\n        return (ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\' || ch==\\'o\\' || ch==\\'u\\');\\n    }\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) \\n    {\\n        set<string> exact;\\n        map<string,int> capital;\\n        map<string,int> vowel;\\n        for(auto word: wordlist) exact.insert(word);\\n        for(int i=wordlist.size()-1; i>=0; i--)\\n        {\\n            string str=wordlist[i];\\n            transform(str.begin(), str.end(), str.begin(), ::tolower);\\n            capital[str]=i;\\n            for(int x=0; x<str.size(); x++)\\n            {\\n                if(isVowel(str[x]))\\n                {\\n                    str[x]=\\'*\\';\\n                }\\n            }\\n            vowel[str]=i;\\n        }\\n        vector<string> ans;\\n        for(auto q: queries)\\n        {\\n            string s=q;\\n            transform(s.begin(), s.end(), s.begin(), ::tolower);\\n            string t=s;\\n            for(int x=0; x<s.size(); x++)\\n            {\\n                if(isVowel(s[x])) s[x]=\\'*\\';\\n            }\\n            if(exact.find(q)!=exact.end())\\n            {\\n                ans.push_back(q);\\n            }\\n            else if(capital.find(t)!=capital.end())\\n            {\\n                ans.push_back(wordlist[capital[t]]);\\n            }\\n            else if(vowel.find(s)!=vowel.end())\\n            {\\n                ans.push_back(wordlist[vowel[s]]);\\n            }\\n            else \\n            {\\n                ans.push_back(\"\");\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool isVowel(char ch)\\n    {\\n        return (ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\' || ch==\\'o\\' || ch==\\'u\\');\\n    }\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) \\n    {\\n        set<string> exact;\\n        map<string,int> capital;\\n        map<string,int> vowel;\\n        for(auto word: wordlist) exact.insert(word);\\n        for(int i=wordlist.size()-1; i>=0; i--)\\n        {\\n            string str=wordlist[i];\\n            transform(str.begin(), str.end(), str.begin(), ::tolower);\\n            capital[str]=i;\\n            for(int x=0; x<str.size(); x++)\\n            {\\n                if(isVowel(str[x]))\\n                {\\n                    str[x]=\\'*\\';\\n                }\\n            }\\n            vowel[str]=i;\\n        }\\n        vector<string> ans;\\n        for(auto q: queries)\\n        {\\n            string s=q;\\n            transform(s.begin(), s.end(), s.begin(), ::tolower);\\n            string t=s;\\n            for(int x=0; x<s.size(); x++)\\n            {\\n                if(isVowel(s[x])) s[x]=\\'*\\';\\n            }\\n            if(exact.find(q)!=exact.end())\\n            {\\n                ans.push_back(q);\\n            }\\n            else if(capital.find(t)!=capital.end())\\n            {\\n                ans.push_back(wordlist[capital[t]]);\\n            }\\n            else if(vowel.find(s)!=vowel.end())\\n            {\\n                ans.push_back(wordlist[vowel[s]]);\\n            }\\n            else \\n            {\\n                ans.push_back(\"\");\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325995,
                "title": "easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo understand the problem I had to read it several times. After that, I had to think a little and break it into elementary blocks, which are described point by point right in the task\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe task consists of three blocks:\\n- Complete match - using for that set with case sensitive words, if we has word in set, just add him to result\\n- Insensitive match - using for that set with case insensitive words, if we has word in set, just find first insensitive case match in wordlist\\n- Vowels error - and last one case, just go through the wordlist and process every word. It is vowel word if: \\n1) word.length === query.length\\n2) every not vowel letters are on the same index\\n3) every vowels letters are on the same index \\nall of this easy to check in simple for cycle\\n\\n\\n# Code\\n```\\n\\nconst vowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'];\\n\\nconst checkVowelWithQuery = (word: string, query: string): boolean => {\\n  if (word.length !== query.length) {\\n    return false;\\n  }\\n\\n\\n  for (let i = 0; i < word.length; i++) {\\n    const wordLetter = word[i].toLowerCase();\\n    const queryLetter = query[i].toLowerCase();\\n\\n    if (vowels.includes(wordLetter) && vowels.includes(queryLetter)) {\\n      continue;\\n    }\\n    if (wordLetter === queryLetter) {\\n      continue;\\n    }\\n    return false;\\n  }\\n  return true;\\n}\\n\\nconst findVowel = (wordlist: string[], query: string): string => {\\n  for (let i = 0; i < wordlist.length; i++) {\\n    const word = wordlist[i];\\n    if (checkVowelWithQuery(word, query)) {\\n      return word;\\n    }\\n  }\\n  return \\'\\';\\n}\\n\\nfunction spellchecker(wordlist: string[], queries: string[]): string[] {\\n  const wordlistSet = new Set<string>(wordlist);\\n  const wordlistInsensitiveSet = new Set<string>(wordlist.map((word) => word.toLowerCase()));\\n  const result: string[] = [];\\n  for (let i = 0; i < queries.length; i++) {\\n    const currentQuery = queries[i];\\n    // check full match\\n    if (wordlistSet.has(currentQuery)) {\\n      result.push(currentQuery);\\n      continue;\\n    }\\n\\n    // check case insensitive\\n    if (wordlistInsensitiveSet.has(currentQuery.toLowerCase())) {\\n      const insensitive = wordlist.find((word) => word.toLowerCase() === currentQuery.toLowerCase());\\n      insensitive && result.push(insensitive);\\n      continue;\\n    }\\n\\n    // check vowels\\n    result.push(findVowel(wordlist, currentQuery));\\n  }\\n  return result;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\n\\nconst vowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'];\\n\\nconst checkVowelWithQuery = (word: string, query: string): boolean => {\\n  if (word.length !== query.length) {\\n    return false;\\n  }\\n\\n\\n  for (let i = 0; i < word.length; i++) {\\n    const wordLetter = word[i].toLowerCase();\\n    const queryLetter = query[i].toLowerCase();\\n\\n    if (vowels.includes(wordLetter) && vowels.includes(queryLetter)) {\\n      continue;\\n    }\\n    if (wordLetter === queryLetter) {\\n      continue;\\n    }\\n    return false;\\n  }\\n  return true;\\n}\\n\\nconst findVowel = (wordlist: string[], query: string): string => {\\n  for (let i = 0; i < wordlist.length; i++) {\\n    const word = wordlist[i];\\n    if (checkVowelWithQuery(word, query)) {\\n      return word;\\n    }\\n  }\\n  return \\'\\';\\n}\\n\\nfunction spellchecker(wordlist: string[], queries: string[]): string[] {\\n  const wordlistSet = new Set<string>(wordlist);\\n  const wordlistInsensitiveSet = new Set<string>(wordlist.map((word) => word.toLowerCase()));\\n  const result: string[] = [];\\n  for (let i = 0; i < queries.length; i++) {\\n    const currentQuery = queries[i];\\n    // check full match\\n    if (wordlistSet.has(currentQuery)) {\\n      result.push(currentQuery);\\n      continue;\\n    }\\n\\n    // check case insensitive\\n    if (wordlistInsensitiveSet.has(currentQuery.toLowerCase())) {\\n      const insensitive = wordlist.find((word) => word.toLowerCase() === currentQuery.toLowerCase());\\n      insensitive && result.push(insensitive);\\n      continue;\\n    }\\n\\n    // check vowels\\n    result.push(findVowel(wordlist, currentQuery));\\n  }\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3325252,
                "title": "c-simple-explanation",
                "content": "1. Regarding the \\'Vowel Errors\\', please pay close attention to the example:\\nwordlist = [\"YellOw\"], query = \"yollow\": correct = \"YellOw\"\\nY**e**llOw <=> Y**o**llow\\n2. That means we can replace a vowel with another vowel.\\n3. We can express all possible combinations by replacing the vowels in the word (case-insensitive). For example, \"Yollow\", \"Yellow\", and \"YalloW\" can be expressed as \"y.ll.w\".\\n\\n# Code\\n```\\npublic class Solution {\\n    public string[] Spellchecker(string[] wordlist, string[] queries) {\\n        Dictionary<string, string> exactTable = new Dictionary<string, string>();\\n        Dictionary<string, string> caseInsensitiveTable = new Dictionary<string, string>();\\n        Dictionary<string, string> vowelTable = new Dictionary<string, string>();\\n\\n        for(int whichWord = 0; whichWord < wordlist.Length; ++whichWord)\\n        {\\n            string word = wordlist[whichWord];\\n            if(!exactTable.ContainsKey(word))\\n            {\\n                exactTable[word] = word;\\n            }\\n\\n            string lowerWord = word.ToLower();\\n            if(!caseInsensitiveTable.ContainsKey(lowerWord))\\n            {\\n                caseInsensitiveTable[lowerWord] = word;\\n            }\\n\\n            string vowelExpressionWord = ToVowelExpression(word);\\n            if(!vowelTable.ContainsKey(vowelExpressionWord))\\n            {\\n                vowelTable[vowelExpressionWord] = word;\\n            }\\n        }\\n\\n        string[] answer = new string[queries.Length];\\n        for(int whichQuery = 0; whichQuery < queries.Length; ++whichQuery)\\n        {\\n            string query = queries[whichQuery];\\n            if(exactTable.ContainsKey(query))\\n            {\\n                answer[whichQuery] = exactTable[query];\\n                continue;\\n            }\\n            \\n            string lowerWord = query.ToLower();\\n            if(caseInsensitiveTable.ContainsKey(lowerWord))\\n            {\\n                answer[whichQuery] = caseInsensitiveTable[lowerWord];\\n                continue;\\n            }\\n\\n            string vowelExpressionWord = ToVowelExpression(query);\\n            if(vowelTable.ContainsKey(vowelExpressionWord))\\n            {\\n                answer[whichQuery] = vowelTable[vowelExpressionWord];\\n                continue;\\n            }\\n\\n            answer[whichQuery] = \"\";\\n        }\\n\\n        return answer;\\n    }\\n\\n    HashSet<char> _vowels = new HashSet<char>(){\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n    private string ToVowelExpression(string s)\\n    {\\n        s = s.ToLower();\\n        StringBuilder vowelWordBuilder = new StringBuilder();\\n        for(int i = 0; i < s.Length; ++i)\\n        {\\n            char charNow = s[i];\\n            if(_vowels.Contains(charNow))\\n            {\\n                vowelWordBuilder.Append(\\'.\\');\\n            }\\n            else\\n            {\\n                vowelWordBuilder.Append(charNow);\\n            }\\n        }\\n        \\n        return vowelWordBuilder.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string[] Spellchecker(string[] wordlist, string[] queries) {\\n        Dictionary<string, string> exactTable = new Dictionary<string, string>();\\n        Dictionary<string, string> caseInsensitiveTable = new Dictionary<string, string>();\\n        Dictionary<string, string> vowelTable = new Dictionary<string, string>();\\n\\n        for(int whichWord = 0; whichWord < wordlist.Length; ++whichWord)\\n        {\\n            string word = wordlist[whichWord];\\n            if(!exactTable.ContainsKey(word))\\n            {\\n                exactTable[word] = word;\\n            }\\n\\n            string lowerWord = word.ToLower();\\n            if(!caseInsensitiveTable.ContainsKey(lowerWord))\\n            {\\n                caseInsensitiveTable[lowerWord] = word;\\n            }\\n\\n            string vowelExpressionWord = ToVowelExpression(word);\\n            if(!vowelTable.ContainsKey(vowelExpressionWord))\\n            {\\n                vowelTable[vowelExpressionWord] = word;\\n            }\\n        }\\n\\n        string[] answer = new string[queries.Length];\\n        for(int whichQuery = 0; whichQuery < queries.Length; ++whichQuery)\\n        {\\n            string query = queries[whichQuery];\\n            if(exactTable.ContainsKey(query))\\n            {\\n                answer[whichQuery] = exactTable[query];\\n                continue;\\n            }\\n            \\n            string lowerWord = query.ToLower();\\n            if(caseInsensitiveTable.ContainsKey(lowerWord))\\n            {\\n                answer[whichQuery] = caseInsensitiveTable[lowerWord];\\n                continue;\\n            }\\n\\n            string vowelExpressionWord = ToVowelExpression(query);\\n            if(vowelTable.ContainsKey(vowelExpressionWord))\\n            {\\n                answer[whichQuery] = vowelTable[vowelExpressionWord];\\n                continue;\\n            }\\n\\n            answer[whichQuery] = \"\";\\n        }\\n\\n        return answer;\\n    }\\n\\n    HashSet<char> _vowels = new HashSet<char>(){\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n    private string ToVowelExpression(string s)\\n    {\\n        s = s.ToLower();\\n        StringBuilder vowelWordBuilder = new StringBuilder();\\n        for(int i = 0; i < s.Length; ++i)\\n        {\\n            char charNow = s[i];\\n            if(_vowels.Contains(charNow))\\n            {\\n                vowelWordBuilder.Append(\\'.\\');\\n            }\\n            else\\n            {\\n                vowelWordBuilder.Append(charNow);\\n            }\\n        }\\n        \\n        return vowelWordBuilder.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297898,
                "title": "python-three-dictionary-to-match-the-word-explained",
                "content": "Dictionary 1 record the original form of word in the list, It is used for exactly matching;\\n\\nDictionary 2 record the lower case form of words in the list, only the location of the first word with the same lower cases form is recorded. It is for lower case matching;\\n\\nDictionary 3 record the word with vowel replaced form in the list. It is for lower case replacing matching.\\n\\n```\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        # build three dictionary for word matching\\n        dict1 = set(wordlist)\\n        dict2 = dict()\\n        dict3 = dict()\\n        \\n        for index, wd in enumerate(wordlist):\\n            lower_wd = wd.lower()\\n            if lower_wd not in dict2:\\n                # only track the first word\\n                dict2[lower_wd] = index\\n                \\n            ignore_vowel_wd = \"\"\\n            for c in lower_wd:\\n                if c in {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'}:\\n                    ignore_vowel_wd += \"*\"\\n                else:\\n                    ignore_vowel_wd += c\\n            if ignore_vowel_wd not in dict3:\\n                # only track the first word\\n                dict3[ignore_vowel_wd] = index\\n        \\n        \\n        ans = []\\n        for q in queries:\\n            if q in dict1:\\n                ans.append(q)\\n                continue\\n            \\n            q_lower = q.lower()\\n            if q_lower in dict2:\\n                ans.append(wordlist[dict2[q_lower]])\\n                continue\\n            \\n            ignore_vowel_wd = \"\"\\n            for c in q_lower:\\n                if c in {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'}:\\n                    ignore_vowel_wd += \"*\"\\n                else:\\n                    ignore_vowel_wd += c\\n            if ignore_vowel_wd in dict3:\\n                ans.append(wordlist[dict3[ignore_vowel_wd]])\\n                continue\\n                \\n            ans.append(\"\")\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        # build three dictionary for word matching\\n        dict1 = set(wordlist)\\n        dict2 = dict()\\n        dict3 = dict()\\n        \\n        for index, wd in enumerate(wordlist):\\n            lower_wd = wd.lower()\\n            if lower_wd not in dict2:\\n                # only track the first word\\n                dict2[lower_wd] = index\\n                \\n            ignore_vowel_wd = \"\"\\n            for c in lower_wd:\\n                if c in {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'}:\\n                    ignore_vowel_wd += \"*\"\\n                else:\\n                    ignore_vowel_wd += c\\n            if ignore_vowel_wd not in dict3:\\n                # only track the first word\\n                dict3[ignore_vowel_wd] = index\\n        \\n        \\n        ans = []\\n        for q in queries:\\n            if q in dict1:\\n                ans.append(q)\\n                continue\\n            \\n            q_lower = q.lower()\\n            if q_lower in dict2:\\n                ans.append(wordlist[dict2[q_lower]])\\n                continue\\n            \\n            ignore_vowel_wd = \"\"\\n            for c in q_lower:\\n                if c in {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'}:\\n                    ignore_vowel_wd += \"*\"\\n                else:\\n                    ignore_vowel_wd += c\\n            if ignore_vowel_wd in dict3:\\n                ans.append(wordlist[dict3[ignore_vowel_wd]])\\n                continue\\n                \\n            ans.append(\"\")\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289414,
                "title": "290-ms",
                "content": "```ruby\\ndef spellchecker a, q\\n    e, c, v = a.to_set, {}, {}\\n    a.each do\\n        c[d = _1.downcase] ||= _1\\n        v[d.gsub /[aeiou]/, ?*] ||= _1\\n    end\\n    q.map! do | s |\\n        e === s && s ||\\n            c[s = s.downcase] ||\\n            v[s.gsub /[aeiou]/, ?*] ||\\n            \\'\\'\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef spellchecker a, q\\n    e, c, v = a.to_set, {}, {}\\n    a.each do\\n        c[d = _1.downcase] ||= _1\\n        v[d.gsub /[aeiou]/, ?*] ||= _1\\n    end\\n    q.map! do | s |\\n        e === s && s ||\\n            c[s = s.downcase] ||\\n            v[s.gsub /[aeiou]/, ?*] ||\\n            \\'\\'\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3284122,
                "title": "trie-dfs-hashmap-faster-than-100",
                "content": "```\\nclass Solution {\\n\\n    private fun String.lowercase(): String {\\n        return this.toCharArray().map { if(it >= \\'A\\' && it <= \\'Z\\') (\\'a\\' - \\'A\\' + it.toInt()).toChar() else it }.joinToString(\"\")\\n    }\\n\\n    class Trie {\\n        class Node(\\n            var isEnd: Boolean, \\n            var index: Int, \\n            val children : Array<Node?>\\n        )\\n        \\n        private var root: Node = Node(false, -1, Array<Node?>(26) { null })\\n        \\n        fun insert(s: String, index: Int) {\\n            var temp: Node? = root\\n            for(c in s) {\\n                val index = c-\\'a\\'\\n                if(temp?.children?.get(index) == null) {\\n                    temp?.children?.set(index, Node(false, -1, Array<Node?>(26) { null }))\\n                }\\n                temp = temp?.children?.get(index)\\n            }\\n            temp?.isEnd = true\\n            temp?.index = index\\n        }\\n        \\n        private fun searchFrom(s: String, index: Int, triePoint: Node?): Int {\\n            if(triePoint == null) {\\n                return -1\\n            }\\n            if(index >= s.length) {\\n                return triePoint.index ?: -1\\n            }\\n            \\n            if(s[index] == \\'a\\' || s[index] == \\'e\\' || s[index] == \\'i\\' || s[index] == \\'o\\' || s[index] == \\'u\\') {\\n                var minIndex = Int.MAX_VALUE\\n                val updateMin = { x: Int -> \\n                    if(x < minIndex && x != -1) {\\n                        minIndex = x\\n                    }\\n                }\\n                updateMin(searchFrom(s, index+1, triePoint?.children?.get(0)))\\n                updateMin(searchFrom(s, index+1, triePoint?.children?.get(\\'e\\'-\\'a\\')))\\n                updateMin(searchFrom(s, index+1, triePoint?.children?.get(\\'i\\'-\\'a\\')))\\n                updateMin(searchFrom(s, index+1, triePoint?.children?.get(\\'o\\'-\\'a\\')))\\n                updateMin(searchFrom(s, index+1, triePoint?.children?.get(\\'u\\'-\\'a\\')))\\n                return if(minIndex == Int.MAX_VALUE) -1 else minIndex\\n            } else {\\n                return searchFrom(s, index+1, triePoint?.children?.get(s[index]-\\'a\\'))\\n            }\\n        }\\n        \\n        fun vowelErrorSearch(s: String): Int {\\n            return searchFrom(s, 0, root)\\n        }\\n    }\\n\\n    fun spellchecker(wordlist: Array<String>, queries: Array<String>): Array<String> {\\n        val trie = Trie()\\n        val exactWordSet = mutableSetOf<String>()\\n        val firstIndex = mutableMapOf<String, Int>()\\n        for((i, word) in wordlist.withIndex()) {\\n            exactWordSet.add(word)\\n            firstIndex[word.lowercase()] ?: run {\\n                firstIndex[word.lowercase()] = i\\n                trie.insert(word.lowercase(), i)\\n            }\\n        }\\n        val result = mutableListOf<String>()\\n        for(query in queries) {\\n            if(exactWordSet.contains(query)) {\\n                result.add(query)\\n            } else if(firstIndex[query.lowercase()] != null) {\\n                result.add(wordlist[firstIndex[query.lowercase()]!!])\\n            } else {\\n                val index = trie.vowelErrorSearch(query.lowercase())\\n                if(index == -1) {\\n                    result.add(\"\")\\n                } else {\\n                    result.add(wordlist[index]!!)\\n                }\\n            }\\n            \\n        }\\n        return result.toTypedArray()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    private fun String.lowercase(): String {\\n        return this.toCharArray().map { if(it >= \\'A\\' && it <= \\'Z\\') (\\'a\\' - \\'A\\' + it.toInt()).toChar() else it }.joinToString(\"\")\\n    }\\n\\n    class Trie {\\n        class Node(\\n            var isEnd: Boolean, \\n            var index: Int, \\n            val children : Array<Node?>\\n        )\\n        \\n        private var root: Node = Node(false, -1, Array<Node?>(26) { null })\\n        \\n        fun insert(s: String, index: Int) {\\n            var temp: Node? = root\\n            for(c in s) {\\n                val index = c-\\'a\\'\\n                if(temp?.children?.get(index) == null) {\\n                    temp?.children?.set(index, Node(false, -1, Array<Node?>(26) { null }))\\n                }\\n                temp = temp?.children?.get(index)\\n            }\\n            temp?.isEnd = true\\n            temp?.index = index\\n        }\\n        \\n        private fun searchFrom(s: String, index: Int, triePoint: Node?): Int {\\n            if(triePoint == null) {\\n                return -1\\n            }\\n            if(index >= s.length) {\\n                return triePoint.index ?: -1\\n            }\\n            \\n            if(s[index] == \\'a\\' || s[index] == \\'e\\' || s[index] == \\'i\\' || s[index] == \\'o\\' || s[index] == \\'u\\') {\\n                var minIndex = Int.MAX_VALUE\\n                val updateMin = { x: Int -> \\n                    if(x < minIndex && x != -1) {\\n                        minIndex = x\\n                    }\\n                }\\n                updateMin(searchFrom(s, index+1, triePoint?.children?.get(0)))\\n                updateMin(searchFrom(s, index+1, triePoint?.children?.get(\\'e\\'-\\'a\\')))\\n                updateMin(searchFrom(s, index+1, triePoint?.children?.get(\\'i\\'-\\'a\\')))\\n                updateMin(searchFrom(s, index+1, triePoint?.children?.get(\\'o\\'-\\'a\\')))\\n                updateMin(searchFrom(s, index+1, triePoint?.children?.get(\\'u\\'-\\'a\\')))\\n                return if(minIndex == Int.MAX_VALUE) -1 else minIndex\\n            } else {\\n                return searchFrom(s, index+1, triePoint?.children?.get(s[index]-\\'a\\'))\\n            }\\n        }\\n        \\n        fun vowelErrorSearch(s: String): Int {\\n            return searchFrom(s, 0, root)\\n        }\\n    }\\n\\n    fun spellchecker(wordlist: Array<String>, queries: Array<String>): Array<String> {\\n        val trie = Trie()\\n        val exactWordSet = mutableSetOf<String>()\\n        val firstIndex = mutableMapOf<String, Int>()\\n        for((i, word) in wordlist.withIndex()) {\\n            exactWordSet.add(word)\\n            firstIndex[word.lowercase()] ?: run {\\n                firstIndex[word.lowercase()] = i\\n                trie.insert(word.lowercase(), i)\\n            }\\n        }\\n        val result = mutableListOf<String>()\\n        for(query in queries) {\\n            if(exactWordSet.contains(query)) {\\n                result.add(query)\\n            } else if(firstIndex[query.lowercase()] != null) {\\n                result.add(wordlist[firstIndex[query.lowercase()]!!])\\n            } else {\\n                val index = trie.vowelErrorSearch(query.lowercase())\\n                if(index == -1) {\\n                    result.add(\"\")\\n                } else {\\n                    result.add(wordlist[index]!!)\\n                }\\n            }\\n            \\n        }\\n        return result.toTypedArray()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207572,
                "title": "c",
                "content": "```\\nclass Solution {\\n public:\\n  vector<char> vowels = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n  vector<string> spellchecker(vector<string>& wordlist,\\n                              vector<string>& queries) {\\n    unordered_set<string> perfect(wordlist.begin(), wordlist.end());\\n    unordered_map<string, string> c;\\n    for (auto s : wordlist) {\\n      string old = s;\\n      for (int i = 0; i < s.size(); ++i) s[i] = tolower(s[i]);\\n      if (c.find(s) == c.end()) c[s] = old;\\n    }\\n    unordered_map<string, string> v;\\n    for (auto s : wordlist) {\\n      string old = s;\\n      for (int i = 0; i < s.size(); ++i) {\\n        s[i] = tolower(s[i]);\\n        for (auto& cr : vowels)\\n          if (s[i] == cr) s[i] = \\' \\';\\n      }\\n      if (v.find(s) == v.end()) v[s] = old;\\n    }\\n    vector<string> ans;\\n    for (auto& s : queries) {\\n      if (perfect.find(s) != perfect.end())\\n        ans.push_back(s);\\n      else {\\n        for (int i = 0; i < s.size(); ++i) s[i] = tolower(s[i]);\\n        if (c.find(s) != c.end())\\n          ans.push_back(c[s]);\\n        else {\\n          for (int i = 0; i < s.size(); ++i) {\\n            for (auto& cr : vowels)\\n              if (s[i] == cr) s[i] = \\' \\';\\n          }\\n          if (v.find(s) != v.end())\\n            ans.push_back(v[s]);\\n          else\\n            ans.push_back(\"\");\\n        }\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n public:\\n  vector<char> vowels = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n  vector<string> spellchecker(vector<string>& wordlist,\\n                              vector<string>& queries) {\\n    unordered_set<string> perfect(wordlist.begin(), wordlist.end());\\n    unordered_map<string, string> c;\\n    for (auto s : wordlist) {\\n      string old = s;\\n      for (int i = 0; i < s.size(); ++i) s[i] = tolower(s[i]);\\n      if (c.find(s) == c.end()) c[s] = old;\\n    }\\n    unordered_map<string, string> v;\\n    for (auto s : wordlist) {\\n      string old = s;\\n      for (int i = 0; i < s.size(); ++i) {\\n        s[i] = tolower(s[i]);\\n        for (auto& cr : vowels)\\n          if (s[i] == cr) s[i] = \\' \\';\\n      }\\n      if (v.find(s) == v.end()) v[s] = old;\\n    }\\n    vector<string> ans;\\n    for (auto& s : queries) {\\n      if (perfect.find(s) != perfect.end())\\n        ans.push_back(s);\\n      else {\\n        for (int i = 0; i < s.size(); ++i) s[i] = tolower(s[i]);\\n        if (c.find(s) != c.end())\\n          ans.push_back(c[s]);\\n        else {\\n          for (int i = 0; i < s.size(); ++i) {\\n            for (auto& cr : vowels)\\n              if (s[i] == cr) s[i] = \\' \\';\\n          }\\n          if (v.find(s) != v.end())\\n            ans.push_back(v[s]);\\n          else\\n            ans.push_back(\"\");\\n        }\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117114,
                "title": "java-use-a-trie",
                "content": "```\\nclass Solution {\\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n\\t\\t// dedup and keep the order\\n        LinkedHashSet<String> set = new LinkedHashSet<>();\\n        for (int i = 0; i < wordlist.length; i++) {\\n            set.add(wordlist[i]);\\n        }\\n\\t\\t// build a trie\\n        Trie t = new Trie();\\n        int j = 0;\\n        for (String s : set) {\\n            t.insert(s, j);\\n            j++;\\n        }\\n        String[] ans = new String[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            if (set.contains(queries[i])) {\\n                ans[i] = queries[i];\\n            } else {\\n\\t\\t\\t    // try capitalization first, if it is empty then we try vowel\\n                String cap = dfs(queries[i], 0, t, true).word;\\n                ans[i] = cap.isEmpty() ? dfs(queries[i], 0, t, false).word : cap;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    Node dfs(String s, int i, Trie t, boolean cap) {\\n        if (t == null) {\\n            return new Node(\"\", 6000);\\n        }\\n        if (i == s.length()) {\\n            return new Node(t.word, t.index);\\n        }\\n        char c = s.charAt(i);\\n        int index = Character.isUpperCase(c) ? (c - \\'A\\') + 26 : c - \\'a\\';\\n        // normal\\n        Node ans = dfs(s, i + 1, t.trie[index], cap);\\n        // capitalization\\n        Node candidate = dfs(s, i + 1, t.trie[Character.isUpperCase(c) ? index - 26 : index + 26], cap);\\n        if (candidate.index < ans.index) {\\n            ans = candidate;\\n        }\\n        if (!cap) {\\n            // vowel\\n            if (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' || c == \\'A\\' || c == \\'E\\' || c == \\'I\\' || c == \\'O\\' || c == \\'U\\') {\\n                candidate = dfs(s, i + 1, t.trie[\\'a\\' - \\'a\\'], cap);\\n                if (candidate.index < ans.index) {\\n                    ans = candidate;\\n                }\\n                candidate = dfs(s, i + 1, t.trie[\\'e\\' - \\'a\\'], cap);\\n                if (candidate.index < ans.index) {\\n                    ans = candidate;\\n                }\\n                candidate = dfs(s, i + 1, t.trie[\\'i\\' - \\'a\\'], cap);\\n                if (candidate.index < ans.index) {\\n                    ans = candidate;\\n                }\\n                candidate = dfs(s, i + 1, t.trie[\\'o\\' - \\'a\\'], cap);\\n                if (candidate.index < ans.index) {\\n                    ans = candidate;\\n                }\\n                candidate = dfs(s, i + 1, t.trie[\\'u\\' - \\'a\\'], cap);\\n                if (candidate.index < ans.index) {\\n                    ans = candidate;\\n                }\\n                candidate = dfs(s, i + 1, t.trie[(\\'A\\' - \\'A\\') + 26], cap);\\n                if (candidate.index < ans.index) {\\n                    ans = candidate;\\n                }\\n                candidate = dfs(s, i + 1, t.trie[(\\'E\\' - \\'A\\') + 26], cap);\\n                if (candidate.index < ans.index) {\\n                    ans = candidate;\\n                }\\n                candidate = dfs(s, i + 1, t.trie[(\\'I\\' - \\'A\\') + 26], cap);\\n                if (candidate.index < ans.index) {\\n                    ans = candidate;\\n                }\\n                candidate = dfs(s, i + 1, t.trie[(\\'O\\' - \\'A\\') + 26], cap);\\n                if (candidate.index < ans.index) {\\n                    ans = candidate;\\n                }\\n                candidate = dfs(s, i + 1, t.trie[(\\'U\\' - \\'A\\') + 26], cap);\\n                if (candidate.index < ans.index) {\\n                    ans = candidate;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    class Node {\\n        String word;\\n        int index;\\n\\n        Node(String word, int index) {\\n            this.word = word;\\n            this.index = index;\\n        }\\n    }\\n\\n    class Trie {\\n        Trie[] trie = new Trie[52];\\n        String word = \"\";\\n        int index = 6000;\\n\\n        void insert(String s, int index) {\\n            Trie t = this;\\n            for (int i = 0; i < s.length(); i++) {\\n                char c = s.charAt(i);\\n                int d = Character.isUpperCase(c) ? (c - \\'A\\') + 26 : c - \\'a\\';\\n                if (t.trie[d] == null) {\\n                    t.trie[d] = new Trie();\\n                }\\n                t = t.trie[d];\\n            }\\n            t.word = s;\\n            t.index = index;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n\\t\\t// dedup and keep the order\\n        LinkedHashSet<String> set = new LinkedHashSet<>();\\n        for (int i = 0; i < wordlist.length; i++) {\\n            set.add(wordlist[i]);\\n        }\\n\\t\\t// build a trie\\n        Trie t = new Trie();\\n        int j = 0;\\n        for (String s : set) {\\n            t.insert(s, j);\\n            j++;\\n        }\\n        String[] ans = new String[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            if (set.contains(queries[i])) {\\n                ans[i] = queries[i];\\n            } else {\\n\\t\\t\\t    // try capitalization first, if it is empty then we try vowel\\n                String cap = dfs(queries[i], 0, t, true).word;\\n                ans[i] = cap.isEmpty() ? dfs(queries[i], 0, t, false).word : cap;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    Node dfs(String s, int i, Trie t, boolean cap) {\\n        if (t == null) {\\n            return new Node(\"\", 6000);\\n        }\\n        if (i == s.length()) {\\n            return new Node(t.word, t.index);\\n        }\\n        char c = s.charAt(i);\\n        int index = Character.isUpperCase(c) ? (c - \\'A\\') + 26 : c - \\'a\\';\\n        // normal\\n        Node ans = dfs(s, i + 1, t.trie[index], cap);\\n        // capitalization\\n        Node candidate = dfs(s, i + 1, t.trie[Character.isUpperCase(c) ? index - 26 : index + 26], cap);\\n        if (candidate.index < ans.index) {\\n            ans = candidate;\\n        }\\n        if (!cap) {\\n            // vowel\\n            if (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' || c == \\'A\\' || c == \\'E\\' || c == \\'I\\' || c == \\'O\\' || c == \\'U\\') {\\n                candidate = dfs(s, i + 1, t.trie[\\'a\\' - \\'a\\'], cap);\\n                if (candidate.index < ans.index) {\\n                    ans = candidate;\\n                }\\n                candidate = dfs(s, i + 1, t.trie[\\'e\\' - \\'a\\'], cap);\\n                if (candidate.index < ans.index) {\\n                    ans = candidate;\\n                }\\n                candidate = dfs(s, i + 1, t.trie[\\'i\\' - \\'a\\'], cap);\\n                if (candidate.index < ans.index) {\\n                    ans = candidate;\\n                }\\n                candidate = dfs(s, i + 1, t.trie[\\'o\\' - \\'a\\'], cap);\\n                if (candidate.index < ans.index) {\\n                    ans = candidate;\\n                }\\n                candidate = dfs(s, i + 1, t.trie[\\'u\\' - \\'a\\'], cap);\\n                if (candidate.index < ans.index) {\\n                    ans = candidate;\\n                }\\n                candidate = dfs(s, i + 1, t.trie[(\\'A\\' - \\'A\\') + 26], cap);\\n                if (candidate.index < ans.index) {\\n                    ans = candidate;\\n                }\\n                candidate = dfs(s, i + 1, t.trie[(\\'E\\' - \\'A\\') + 26], cap);\\n                if (candidate.index < ans.index) {\\n                    ans = candidate;\\n                }\\n                candidate = dfs(s, i + 1, t.trie[(\\'I\\' - \\'A\\') + 26], cap);\\n                if (candidate.index < ans.index) {\\n                    ans = candidate;\\n                }\\n                candidate = dfs(s, i + 1, t.trie[(\\'O\\' - \\'A\\') + 26], cap);\\n                if (candidate.index < ans.index) {\\n                    ans = candidate;\\n                }\\n                candidate = dfs(s, i + 1, t.trie[(\\'U\\' - \\'A\\') + 26], cap);\\n                if (candidate.index < ans.index) {\\n                    ans = candidate;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    class Node {\\n        String word;\\n        int index;\\n\\n        Node(String word, int index) {\\n            this.word = word;\\n            this.index = index;\\n        }\\n    }\\n\\n    class Trie {\\n        Trie[] trie = new Trie[52];\\n        String word = \"\";\\n        int index = 6000;\\n\\n        void insert(String s, int index) {\\n            Trie t = this;\\n            for (int i = 0; i < s.length(); i++) {\\n                char c = s.charAt(i);\\n                int d = Character.isUpperCase(c) ? (c - \\'A\\') + 26 : c - \\'a\\';\\n                if (t.trie[d] == null) {\\n                    t.trie[d] = new Trie();\\n                }\\n                t = t.trie[d];\\n            }\\n            t.word = s;\\n            t.index = index;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103725,
                "title": "python3-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n + m)$$\\n- $$n$$ is wordlist length\\n- $$m$$ is queries length\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvowels = set([\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'])\\n\\ndef get_word_pattern(word):\\n    ret = \"\"\\n    for ch in word.lower():\\n        if  ch in vowels:\\n            ret += \\'*\\'\\n        else:\\n            ret += ch\\n    return ret\\n\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        d1 = set(wordlist)\\n        d2 = {}\\n        d3 = {}\\n        for word in wordlist:\\n            word_lower = word.lower()\\n            if not (word_lower in d2):\\n                d2[word_lower] = word\\n\\n            word_pattern = get_word_pattern(word)\\n            if not (word_pattern in d3):\\n                d3[word_pattern] = word\\n\\n        ret = []\\n        for query in queries:\\n            if query in d1:\\n                ret.append(query)\\n                continue\\n            \\n            query_lower = query.lower()\\n            if query_lower in d2:\\n                ret.append(d2[query_lower])\\n                continue\\n\\n            query_pattern = get_word_pattern(query)                \\n            if query_pattern in d3:\\n                ret.append(d3[query_pattern])\\n                continue\\n\\n            ret.append(\"\")                \\n\\n        return ret            \\n            \\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nvowels = set([\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'])\\n\\ndef get_word_pattern(word):\\n    ret = \"\"\\n    for ch in word.lower():\\n        if  ch in vowels:\\n            ret += \\'*\\'\\n        else:\\n            ret += ch\\n    return ret\\n\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        d1 = set(wordlist)\\n        d2 = {}\\n        d3 = {}\\n        for word in wordlist:\\n            word_lower = word.lower()\\n            if not (word_lower in d2):\\n                d2[word_lower] = word\\n\\n            word_pattern = get_word_pattern(word)\\n            if not (word_pattern in d3):\\n                d3[word_pattern] = word\\n\\n        ret = []\\n        for query in queries:\\n            if query in d1:\\n                ret.append(query)\\n                continue\\n            \\n            query_lower = query.lower()\\n            if query_lower in d2:\\n                ret.append(d2[query_lower])\\n                continue\\n\\n            query_pattern = get_word_pattern(query)                \\n            if query_pattern in d3:\\n                ret.append(d3[query_pattern])\\n                continue\\n\\n            ret.append(\"\")                \\n\\n        return ret            \\n            \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012644,
                "title": "easy-to-understand-javascript-solution-hash-table",
                "content": "```\\nvar spellchecker = function(wordlist, queries) {\\n    const wordSet = new Set(wordlist);\\n    const lowerMap = new Map();\\n    const vowelMap = new Map();\\n    const regex = /[aeiou]/g;\\n\\n    wordlist.forEach(word => {\\n        const lower = word.toLowerCase();\\n        const vowel = lower.replace(regex, \\'_\\');\\n\\n        !lowerMap.has(lower) && lowerMap.set(lower, word);\\n        !vowelMap.has(vowel) && vowelMap.set(vowel, word);\\n    });\\n\\n    return queries.map(word => {\\n        if (wordSet.has(word)) return word;\\n\\n        const lower = word.toLowerCase();\\n        if (lowerMap.has(lower)) return lowerMap.get(lower);\\n\\n        const vowel = lower.replace(regex, \\'_\\');\\n        if (vowelMap.has(vowel)) return vowelMap.get(vowel);\\n\\n        return \\'\\';\\n    });\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar spellchecker = function(wordlist, queries) {\\n    const wordSet = new Set(wordlist);\\n    const lowerMap = new Map();\\n    const vowelMap = new Map();\\n    const regex = /[aeiou]/g;\\n\\n    wordlist.forEach(word => {\\n        const lower = word.toLowerCase();\\n        const vowel = lower.replace(regex, \\'_\\');\\n\\n        !lowerMap.has(lower) && lowerMap.set(lower, word);\\n        !vowelMap.has(vowel) && vowelMap.set(vowel, word);\\n    });\\n\\n    return queries.map(word => {\\n        if (wordSet.has(word)) return word;\\n\\n        const lower = word.toLowerCase();\\n        if (lowerMap.has(lower)) return lowerMap.get(lower);\\n\\n        const vowel = lower.replace(regex, \\'_\\');\\n        if (vowelMap.has(vowel)) return vowelMap.get(vowel);\\n\\n        return \\'\\';\\n    });\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2973295,
                "title": "c",
                "content": "```\\n\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\n\\n// RS Hash Function\\nunsigned int RSHash1(char *str)\\n{\\n    unsigned int b = 378551;\\n    unsigned int a = 63689;\\n    unsigned int hash = 0;\\n\\n    while (*str)\\n    {\\n        hash = hash * a + (*str++);\\n        a *= b;\\n    }\\n\\n    return (hash & 0x7FFFFFFF);\\n}\\n\\n// RS Hash Function\\nunsigned int RSHash2(char *str)\\n{\\n    unsigned int b = 378551;\\n    unsigned int a = 63689;\\n    unsigned int hash = 0;\\n\\n    while (*str)\\n    {\\n        char c = *str;\\n        if(c >= \\'A\\' && c <= \\'Z\\'){\\n            c = c- \\'A\\' + \\'a\\';\\n        }\\n        hash = hash * a + c;\\n        *str++;\\n        a *= b;\\n    }\\n\\n    return (hash & 0x7FFFFFFF);\\n}\\n\\n// RS Hash Function\\nunsigned int RSHash3(char *str)\\n{\\n    unsigned int b = 378551;\\n    unsigned int a = 63689;\\n    unsigned int hash = 0;\\n\\n    while (*str)\\n    {\\n        char c = *str;\\n        if( c == \\'a\\'|| c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')\\n            c = \\'A\\' ;\\n        else if( c == \\'A\\'|| c == \\'E\\' || c == \\'I\\' || c == \\'O\\' || c == \\'U\\')\\n            c = \\'A\\';\\n        else if(c >= \\'A\\' && c <=\\'Z\\')\\n            c = c -\\'A\\' + \\'a\\';\\n        \\n        hash = hash * a + c;\\n        *str++;\\n        a *= b;\\n    }\\n\\n    return (hash & 0x7FFFFFFF);    \\n}\\n\\nchar ** spellchecker(char ** wordlist, int wordlistSize, char ** queries, int queriesSize, int* returnSize){\\n    int N = 10 * wordlistSize;\\n    unsigned int** hash1 = calloc(N , sizeof(unsigned int*)) ;  \\n    unsigned int** hash2 = calloc(N , sizeof(unsigned int*)) ;\\n    unsigned int** hash3 = calloc(N , sizeof(unsigned int*)) ;\\n    for(int i = 0; i < wordlistSize; i++){\\n        //hash1\\n        unsigned val = RSHash1(wordlist[i]);\\n        unsigned d = val;\\n        while(1){\\n            if(hash1[d % N] == NULL){\\n                hash1[d % N] = malloc(2 * sizeof(unsigned int));\\n                hash1[d % N][0] = val; \\n                hash1[d % N][1] = i;\\n                break;\\n            } \\n            else\\n                d++;\\n        }\\n        //hash2 \\n        val = RSHash2(wordlist[i]);\\n        d = val;\\n        while(1){\\n            if(hash2[d % N] == NULL){\\n                hash2[d % N] = malloc(2 * sizeof(unsigned int));\\n                hash2[d % N][0] = val; \\n                hash2[d % N][1] = i;\\n                break;\\n            } \\n            else\\n                d++;\\n        }\\n        //hash3 \\n        val = RSHash3(wordlist[i]);\\n        d = val;\\n        while(1){\\n            if(hash3[d % N] == NULL){\\n                hash3[d % N] = malloc(2* sizeof(unsigned int));\\n                hash3[d % N][0] = val; \\n                hash3[d % N][1] = i;\\n                break;\\n            } \\n            else\\n                d++;\\n        }\\n    }\\n    \\n    char** ans = malloc(queriesSize * sizeof(char*));\\n    unsigned int val, d;\\n    for(int i = 0; i < queriesSize; i++){\\n        ans[i] = malloc(8 * sizeof(char));  \\n        //check hash2    \\n        val = RSHash1(queries[i]);\\n        d = val ;\\n        while(1){\\n            if(hash1[d % N] == NULL)\\n                break;\\n            else if(hash1[d % N][0] == val ){\\n                int pos = hash1[d % N][1];\\n                strcpy(ans[i], wordlist[pos]);\\n                goto next;\\n            }\\n            else\\n                d++;\\n        }\\n        //check hash2    \\n         val = RSHash2(queries[i]);\\n         d = val ;\\n         while(1){\\n            if(hash2[d % N] == NULL)\\n                break;\\n            else if(hash2[d % N][0] == val ){\\n                int pos = hash2[d % N][1];\\n                strcpy(ans[i], wordlist[pos]);\\n                goto next;\\n            }\\n            else\\n                d++;\\n        }\\n        //check hash3 \\n        val = RSHash3(queries[i]);\\n        d = val ;\\n        while(1){\\n            if(hash3[d % N] == NULL)\\n                break;\\n            else if(hash3[d % N][0] == val ){\\n                int pos = hash3[d % N][1];\\n                //printf(\"pos = %d,\", pos);\\n                strcpy(ans[i], wordlist[pos]);\\n                goto next;\\n            }\\n            else\\n                d++;\\n        }\\n        \\n        ans[i] = \"\";\\n        next:\\n            continue;\\n    }\\n    *returnSize = queriesSize;\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\n\\n// RS Hash Function\\nunsigned int RSHash1(char *str)\\n{\\n    unsigned int b = 378551;\\n    unsigned int a = 63689;\\n    unsigned int hash = 0;\\n\\n    while (*str)\\n    {\\n        hash = hash * a + (*str++);\\n        a *= b;\\n    }\\n\\n    return (hash & 0x7FFFFFFF);\\n}\\n\\n// RS Hash Function\\nunsigned int RSHash2(char *str)\\n{\\n    unsigned int b = 378551;\\n    unsigned int a = 63689;\\n    unsigned int hash = 0;\\n\\n    while (*str)\\n    {\\n        char c = *str;\\n        if(c >= \\'A\\' && c <= \\'Z\\'){\\n            c = c- \\'A\\' + \\'a\\';\\n        }\\n        hash = hash * a + c;\\n        *str++;\\n        a *= b;\\n    }\\n\\n    return (hash & 0x7FFFFFFF);\\n}\\n\\n// RS Hash Function\\nunsigned int RSHash3(char *str)\\n{\\n    unsigned int b = 378551;\\n    unsigned int a = 63689;\\n    unsigned int hash = 0;\\n\\n    while (*str)\\n    {\\n        char c = *str;\\n        if( c == \\'a\\'|| c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')\\n            c = \\'A\\' ;\\n        else if( c == \\'A\\'|| c == \\'E\\' || c == \\'I\\' || c == \\'O\\' || c == \\'U\\')\\n            c = \\'A\\';\\n        else if(c >= \\'A\\' && c <=\\'Z\\')\\n            c = c -\\'A\\' + \\'a\\';\\n        \\n        hash = hash * a + c;\\n        *str++;\\n        a *= b;\\n    }\\n\\n    return (hash & 0x7FFFFFFF);    \\n}\\n\\nchar ** spellchecker(char ** wordlist, int wordlistSize, char ** queries, int queriesSize, int* returnSize){\\n    int N = 10 * wordlistSize;\\n    unsigned int** hash1 = calloc(N , sizeof(unsigned int*)) ;  \\n    unsigned int** hash2 = calloc(N , sizeof(unsigned int*)) ;\\n    unsigned int** hash3 = calloc(N , sizeof(unsigned int*)) ;\\n    for(int i = 0; i < wordlistSize; i++){\\n        //hash1\\n        unsigned val = RSHash1(wordlist[i]);\\n        unsigned d = val;\\n        while(1){\\n            if(hash1[d % N] == NULL){\\n                hash1[d % N] = malloc(2 * sizeof(unsigned int));\\n                hash1[d % N][0] = val; \\n                hash1[d % N][1] = i;\\n                break;\\n            } \\n            else\\n                d++;\\n        }\\n        //hash2 \\n        val = RSHash2(wordlist[i]);\\n        d = val;\\n        while(1){\\n            if(hash2[d % N] == NULL){\\n                hash2[d % N] = malloc(2 * sizeof(unsigned int));\\n                hash2[d % N][0] = val; \\n                hash2[d % N][1] = i;\\n                break;\\n            } \\n            else\\n                d++;\\n        }\\n        //hash3 \\n        val = RSHash3(wordlist[i]);\\n        d = val;\\n        while(1){\\n            if(hash3[d % N] == NULL){\\n                hash3[d % N] = malloc(2* sizeof(unsigned int));\\n                hash3[d % N][0] = val; \\n                hash3[d % N][1] = i;\\n                break;\\n            } \\n            else\\n                d++;\\n        }\\n    }\\n    \\n    char** ans = malloc(queriesSize * sizeof(char*));\\n    unsigned int val, d;\\n    for(int i = 0; i < queriesSize; i++){\\n        ans[i] = malloc(8 * sizeof(char));  \\n        //check hash2    \\n        val = RSHash1(queries[i]);\\n        d = val ;\\n        while(1){\\n            if(hash1[d % N] == NULL)\\n                break;\\n            else if(hash1[d % N][0] == val ){\\n                int pos = hash1[d % N][1];\\n                strcpy(ans[i], wordlist[pos]);\\n                goto next;\\n            }\\n            else\\n                d++;\\n        }\\n        //check hash2    \\n         val = RSHash2(queries[i]);\\n         d = val ;\\n         while(1){\\n            if(hash2[d % N] == NULL)\\n                break;\\n            else if(hash2[d % N][0] == val ){\\n                int pos = hash2[d % N][1];\\n                strcpy(ans[i], wordlist[pos]);\\n                goto next;\\n            }\\n            else\\n                d++;\\n        }\\n        //check hash3 \\n        val = RSHash3(queries[i]);\\n        d = val ;\\n        while(1){\\n            if(hash3[d % N] == NULL)\\n                break;\\n            else if(hash3[d % N][0] == val ){\\n                int pos = hash3[d % N][1];\\n                //printf(\"pos = %d,\", pos);\\n                strcpy(ans[i], wordlist[pos]);\\n                goto next;\\n            }\\n            else\\n                d++;\\n        }\\n        \\n        ans[i] = \"\";\\n        next:\\n            continue;\\n    }\\n    *returnSize = queriesSize;\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2814626,
                "title": "python3-readable-and-commented-hashmap-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to identify the priority of the rules and also how to quickly check them.\\n\\nFor me the most complicated one was: check whether vowel replacement has a match in our wordlist.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe initialize a set for the original words in the wordlist (for fast lookup).\\n\\nThen we lower all of the characters and keep the first occurence of the lowered words.\\n\\nThen we replace all vowels with a placeholder and keep the first occurence.\\n\\nOne needs to consider:\\n1) We need to replace the vowels with a placeholder and not delete them entirely. Otherwise oho will be the same as eh\\n2) We need to replace the vowels in the lowered version of the word, as this vowel replacement is case insensitive\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N + M), where N is the length of all characters in the wordlist and M is the amount of characters in the queries.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) as we need to save a set and two dicts.\\n\\n# Code\\n```\\nclass Solution:\\n\\n    # a static vowel set so we don\\'t initialize it with every quer\\n    vowel_set = set((\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'))\\n    \\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n\\n        # keep a set of all variations in their original form for fast lookup\\n        wordset = set(wordlist)\\n\\n        # put all the words into the wordlist (lowercase) and lowercase without vowels\\n        # we will use these dicts to check for the capitalization errors and vowel errors\\n        # which are both cas insensitive (so lower both)\\n        #\\n        # also we only keep the first occurencce to match the precedence rules\\n        worddict = dict()\\n        wrddct = dict()\\n        for idx, word in enumerate(wordlist):\\n            lowered = word.lower()\\n            devoweled = self.devowel(lowered)\\n            if lowered not in worddict:\\n                worddict[lowered] = word\\n            if devoweled not in wrddct:\\n                wrddct[devoweled] = word\\n        \\n        # go through each of the queries and check the rules\\n        result = []\\n        for query in queries:\\n\\n            # check if it is in the original wordlist\\n            # append the word and continue with the next query\\n            if query in wordset:\\n                result.append(query)\\n                continue\\n            \\n            # check if the word only has capitalization error\\n            # append the corrected one and continue with the next query\\n            lowered = query.lower()\\n            if lowered in worddict:\\n                result.append(worddict[lowered])\\n                continue\\n            \\n            # check if the word has vowel errors, append it to the result\\n            # and go to the next query\\n            devoweled = self.devowel(lowered)\\n            if devoweled in wrddct:\\n                result.append(wrddct[devoweled])\\n                continue\\n            \\n            # no case matched (all quard clauses have been passed)\\n            result.append(\"\")\\n            \\n        return result\\n    \\n    def devowel(self, word):\\n        # replace vowels with unused placeholder\\n        return \"\".join(char if char not in self.vowel_set else \"_\" for char in word)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    # a static vowel set so we don\\'t initialize it with every quer\\n    vowel_set = set((\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'))\\n    \\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n\\n        # keep a set of all variations in their original form for fast lookup\\n        wordset = set(wordlist)\\n\\n        # put all the words into the wordlist (lowercase) and lowercase without vowels\\n        # we will use these dicts to check for the capitalization errors and vowel errors\\n        # which are both cas insensitive (so lower both)\\n        #\\n        # also we only keep the first occurencce to match the precedence rules\\n        worddict = dict()\\n        wrddct = dict()\\n        for idx, word in enumerate(wordlist):\\n            lowered = word.lower()\\n            devoweled = self.devowel(lowered)\\n            if lowered not in worddict:\\n                worddict[lowered] = word\\n            if devoweled not in wrddct:\\n                wrddct[devoweled] = word\\n        \\n        # go through each of the queries and check the rules\\n        result = []\\n        for query in queries:\\n\\n            # check if it is in the original wordlist\\n            # append the word and continue with the next query\\n            if query in wordset:\\n                result.append(query)\\n                continue\\n            \\n            # check if the word only has capitalization error\\n            # append the corrected one and continue with the next query\\n            lowered = query.lower()\\n            if lowered in worddict:\\n                result.append(worddict[lowered])\\n                continue\\n            \\n            # check if the word has vowel errors, append it to the result\\n            # and go to the next query\\n            devoweled = self.devowel(lowered)\\n            if devoweled in wrddct:\\n                result.append(wrddct[devoweled])\\n                continue\\n            \\n            # no case matched (all quard clauses have been passed)\\n            result.append(\"\")\\n            \\n        return result\\n    \\n    def devowel(self, word):\\n        # replace vowels with unused placeholder\\n        return \"\".join(char if char not in self.vowel_set else \"_\" for char in word)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2714241,
                "title": "python-easy-solution",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        wordset = set(wordlist)\\n        d1 = defaultdict(list)\\n        d2 = defaultdict(list)\\n        def normalize(v):\\n            v = list(v.lower())\\n            for i, c in enumerate(v):\\n                if c in \\'aeiou\\':\\n                    v[i] = \\'?\\'\\n            return \"\".join(v)\\n        for w in wordlist:\\n            v = w.lower()\\n            d1[v].append(w)\\n            v = normalize(v)\\n            d2[v].append(w)\\n        res = []\\n        for q in queries:\\n            if q in wordset:\\n                res.append(q)\\n            elif q.lower() in d1:\\n                res.append(d1[q.lower()][0])\\n            elif normalize(q) in d2:\\n                res.append(d2[normalize(q)][0])\\n            else:\\n                res.append(\"\")\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        wordset = set(wordlist)\\n        d1 = defaultdict(list)\\n        d2 = defaultdict(list)\\n        def normalize(v):\\n            v = list(v.lower())\\n            for i, c in enumerate(v):\\n                if c in \\'aeiou\\':\\n                    v[i] = \\'?\\'\\n            return \"\".join(v)\\n        for w in wordlist:\\n            v = w.lower()\\n            d1[v].append(w)\\n            v = normalize(v)\\n            d2[v].append(w)\\n        res = []\\n        for q in queries:\\n            if q in wordset:\\n                res.append(q)\\n            elif q.lower() in d1:\\n                res.append(d1[q.lower()][0])\\n            elif normalize(q) in d2:\\n                res.append(d2[normalize(q)][0])\\n            else:\\n                res.append(\"\")\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2587295,
                "title": "o-n-m-time-o-n-space-clear-explanation-three-dicts",
                "content": "\\tdef spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n\\t\\t\\t\"\"\" O(N+M)TS \"\"\"\\n\\t\\t\\ta, b, c = {w: w for w in wordlist}, collections.defaultdict(str), collections.defaultdict(str)\\n\\t\\t\\tfn = lambda w: w.lower().translate(str.maketrans(\\'aeiou\\', \\'_____\\'))\\n\\n\\t\\t\\tfor w in wordlist:\\n\\t\\t\\t\\tb.setdefault(w.lower(), w), c.setdefault(fn(w), w)\\n\\n\\t\\t\\tfor q in queries:\\n\\t\\t\\t\\tyield a.get(q) or b.get(q.lower()) or c.get(fn(q), \\'\\')",
                "solutionTags": [],
                "code": "\\tdef spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n\\t\\t\\t\"\"\" O(N+M)TS \"\"\"\\n\\t\\t\\ta, b, c = {w: w for w in wordlist}, collections.defaultdict(str), collections.defaultdict(str)\\n\\t\\t\\tfn = lambda w: w.lower().translate(str.maketrans(\\'aeiou\\', \\'_____\\'))\\n\\n\\t\\t\\tfor w in wordlist:\\n\\t\\t\\t\\tb.setdefault(w.lower(), w), c.setdefault(fn(w), w)\\n\\n\\t\\t\\tfor q in queries:\\n\\t\\t\\t\\tyield a.get(q) or b.get(q.lower()) or c.get(fn(q), \\'\\')",
                "codeTag": "Python3"
            },
            {
                "id": 2562843,
                "title": "c-solution-guessed-the-question-setter-s-intention-correctly",
                "content": "This questions has more downvotes than upvotes for a reason. Those statements are confusing:\\n\\n* When the query exactly matches a word in the wordlist (case-sensitive), you should return the same word back.\\n* When the query matches a word up to capitlization, you should return the first such match in the wordlist.\\n* When the query matches a word up to vowel errors, you should return the first such match in the wordlist.\\n* If the query has no matches in the wordlist, you should return the empty string.\\n\\nbut here\\'s the thing, you can just rephrase them as:  \\n1. Exact match --> return it\\n2. If convert to lowercase --> match a word, return the **first** occurance in list, **literally**.\\n3. If convert to lowercase + pattern of vowel and non-vowel characters in a string --> match that in the wordlist, return the **first** occurance in list, **literally**.\\n\\nFor rule #3, you don\\'t have to check for all combinations of vowels. \\n\\ne.g. here --> just convert it into --> h$r$.\\nif the wordlist is like : [HaRe, hare, hAre], the patterns (in lowercase) for those words = h$r$ \\nyou shall return HaRe as the result.\\n\\n\\\\\\\\(-_-)/  \\n\\nWeird question tho.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    set<string> S;\\n    map<string, string> M;  \\n    map<string, string> VM;\\n    \\n    string toL(string in_s) {\\n        for (int i = 0; i < in_s.length(); i++) {\\n            if (\\'A\\' <= in_s[i] && in_s[i] <= \\'Z\\') {\\n                in_s[i] = in_s[i] - \\'A\\' + \\'a\\';\\n            }\\n        }\\n        return in_s;\\n    }\\n    vector<char> V = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n    bool VS[26];\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        memset(VS, false, sizeof(VS));\\n        for (char v : V) {\\n            VS[(int)(v - \\'a\\')] = true;\\n        }\\n        for (string s : wordlist) {\\n            S.insert(s);\\n            string sk = toL(s);\\n            if (M.find(sk) == M.end()) {\\n                M[sk] = s;\\n            }\\n            string vmk = sk;\\n            for (int i = 0; i < s.length(); i++) {\\n                if (VS[(int)(sk[i] - \\'a\\')]) {\\n                    vmk[i] = \\'$\\';\\n                }\\n            }\\n            if (VM.find(vmk) == VM.end()) {\\n                VM[vmk] = sk;\\n            }\\n        }\\n        vector<string> res = {};\\n        for (string q : queries) {\\n            if (S.find(q) != S.end()) {\\n                res.push_back(q);\\n            }\\n            else {\\n                string qk = toL(q);\\n                if (M.find(qk) != M.end()) {\\n                    res.push_back(M[qk]);\\n                }\\n                else {\\n                    string qvmk = qk;\\n                    for (int i = 0; i < qvmk.length(); i++) {\\n                        if (VS[(int)(qk[i] - \\'a\\')]) {\\n                            qvmk[i] = \\'$\\';\\n                        }\\n                    }\\n                    if (VM.find(qvmk) != VM.end()) {\\n                        res.push_back(M[VM[qvmk]]);\\n                    }\\n                    else {\\n                        res.push_back(\"\");\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    set<string> S;\\n    map<string, string> M;  \\n    map<string, string> VM;\\n    \\n    string toL(string in_s) {\\n        for (int i = 0; i < in_s.length(); i++) {\\n            if (\\'A\\' <= in_s[i] && in_s[i] <= \\'Z\\') {\\n                in_s[i] = in_s[i] - \\'A\\' + \\'a\\';\\n            }\\n        }\\n        return in_s;\\n    }\\n    vector<char> V = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n    bool VS[26];\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        memset(VS, false, sizeof(VS));\\n        for (char v : V) {\\n            VS[(int)(v - \\'a\\')] = true;\\n        }\\n        for (string s : wordlist) {\\n            S.insert(s);\\n            string sk = toL(s);\\n            if (M.find(sk) == M.end()) {\\n                M[sk] = s;\\n            }\\n            string vmk = sk;\\n            for (int i = 0; i < s.length(); i++) {\\n                if (VS[(int)(sk[i] - \\'a\\')]) {\\n                    vmk[i] = \\'$\\';\\n                }\\n            }\\n            if (VM.find(vmk) == VM.end()) {\\n                VM[vmk] = sk;\\n            }\\n        }\\n        vector<string> res = {};\\n        for (string q : queries) {\\n            if (S.find(q) != S.end()) {\\n                res.push_back(q);\\n            }\\n            else {\\n                string qk = toL(q);\\n                if (M.find(qk) != M.end()) {\\n                    res.push_back(M[qk]);\\n                }\\n                else {\\n                    string qvmk = qk;\\n                    for (int i = 0; i < qvmk.length(); i++) {\\n                        if (VS[(int)(qk[i] - \\'a\\')]) {\\n                            qvmk[i] = \\'$\\';\\n                        }\\n                    }\\n                    if (VM.find(qvmk) != VM.end()) {\\n                        res.push_back(M[VM[qvmk]]);\\n                    }\\n                    else {\\n                        res.push_back(\"\");\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2490522,
                "title": "c-easy-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isvowel(char a){\\n        if(a==\\'a\\'||a==\\'e\\'||a==\\'i\\'||a==\\'o\\'||a==\\'u\\') return 0;\\n        return 1;\\n    }\\n    \\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        map<string,int> hash;\\n        map<string,int> hash2;\\n        map<string,int> hash3;\\n        for(int i=0;i<wordlist.size();i++){\\n            string  p = wordlist[i];\\n            hash[p]++;\\n        }\\n        for(int i=0;i<wordlist.size();i++){\\n            string s1;\\n            string s2;\\n            for(int j=0;j<wordlist[i].length();j++){\\n                \\n                s1+=tolower(wordlist[i][j]);\\n                if((isvowel(tolower(wordlist[i][j])))) {\\n                   s2+=tolower(wordlist[i][j]);\\n                }\\n                else s2+=\\'*\\';\\n                if(j==wordlist[i].length()-1){\\n                    if(hash2[s1]==0) hash2[s1]=i+1;\\n                    if(hash3[s2]==0) hash3[s2]=i+1;\\n                    // // cout<<s1<<hash2[s1]<<endl;\\n                }\\n            }\\n                       \\n        }\\n        vector<string> ans;\\n        for(int i=0;i<queries.size();i++){\\n            \\n            string n1;\\n            string n2;\\n            string n3;\\n            for(int j=0;j<queries[i].length();j++){\\n                 n1+=tolower(queries[i][j]);\\n                if((isvowel(tolower(queries[i][j])))) {\\n                   n2+=tolower(queries[i][j]);\\n                }\\n                else n2+=\\'*\\';\\n            }\\n            // cout<<queries[i]<<\" \"<<n1<<\" \"<<n2<<hash2[n1]<<\" \"<<hash3[n2]<<endl;\\n//             \\n            if(hash[queries[i]]>0) ans.push_back(queries[i]);\\n            else if(hash2[n1]>0){\\n                ans.push_back(wordlist[hash2[n1]-1]);\\n            }\\n            else if(hash3[n2]>0){\\n                ans.push_back(wordlist[hash3[n2]-1]);\\n            }\\n            else ans.push_back(n3);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvowel(char a){\\n        if(a==\\'a\\'||a==\\'e\\'||a==\\'i\\'||a==\\'o\\'||a==\\'u\\') return 0;\\n        return 1;\\n    }\\n    \\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        map<string,int> hash;\\n        map<string,int> hash2;\\n        map<string,int> hash3;\\n        for(int i=0;i<wordlist.size();i++){\\n            string  p = wordlist[i];\\n            hash[p]++;\\n        }\\n        for(int i=0;i<wordlist.size();i++){\\n            string s1;\\n            string s2;\\n            for(int j=0;j<wordlist[i].length();j++){\\n                \\n                s1+=tolower(wordlist[i][j]);\\n                if((isvowel(tolower(wordlist[i][j])))) {\\n                   s2+=tolower(wordlist[i][j]);\\n                }\\n                else s2+=\\'*\\';\\n                if(j==wordlist[i].length()-1){\\n                    if(hash2[s1]==0) hash2[s1]=i+1;\\n                    if(hash3[s2]==0) hash3[s2]=i+1;\\n                    // // cout<<s1<<hash2[s1]<<endl;\\n                }\\n            }\\n                       \\n        }\\n        vector<string> ans;\\n        for(int i=0;i<queries.size();i++){\\n            \\n            string n1;\\n            string n2;\\n            string n3;\\n            for(int j=0;j<queries[i].length();j++){\\n                 n1+=tolower(queries[i][j]);\\n                if((isvowel(tolower(queries[i][j])))) {\\n                   n2+=tolower(queries[i][j]);\\n                }\\n                else n2+=\\'*\\';\\n            }\\n            // cout<<queries[i]<<\" \"<<n1<<\" \"<<n2<<hash2[n1]<<\" \"<<hash3[n2]<<endl;\\n//             \\n            if(hash[queries[i]]>0) ans.push_back(queries[i]);\\n            else if(hash2[n1]>0){\\n                ans.push_back(wordlist[hash2[n1]-1]);\\n            }\\n            else if(hash3[n2]>0){\\n                ans.push_back(wordlist[hash3[n2]-1]);\\n            }\\n            else ans.push_back(n3);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2475115,
                "title": "python-solution",
                "content": "```\\ndef spellchecker(self, wordlist: List[str], qs: List[str]) -> List[str]:\\n\\tword_set = set(wordlist)\\n\\tmp1, mp2 = {}, {}\\n\\tfor w in wordlist:\\n\\t\\tw1 = w.lower()\\n\\t\\tif w1 not in mp1:\\n\\t\\t\\tmp1[w1] = w\\n\\t\\tw2 = \\'\\'.join(\\'*\\' if c in \\'aeiou\\' else c for c in w1)\\n\\t\\tif w2 not in mp2:\\n\\t\\t\\tmp2[w2] = w\\n\\n\\tans = []\\n\\tfor q in qs:\\n\\t\\tw1 = q.lower()\\n\\t\\tw2 = \\'\\'.join(\\'*\\' if c in \\'aeiou\\' else c for c in w1)\\n\\t\\tcur = \\'\\'\\n\\t\\tif q in word_set:\\n\\t\\t\\tcur = q\\n\\t\\telif w1 in mp1:\\n\\t\\t\\tcur = mp1[w1]\\n\\t\\telif w2 in mp2:\\n\\t\\t\\tcur = mp2[w2]\\n\\t\\tans.append(cur)\\n\\treturn ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef spellchecker(self, wordlist: List[str], qs: List[str]) -> List[str]:\\n\\tword_set = set(wordlist)\\n\\tmp1, mp2 = {}, {}\\n\\tfor w in wordlist:\\n\\t\\tw1 = w.lower()\\n\\t\\tif w1 not in mp1:\\n\\t\\t\\tmp1[w1] = w\\n\\t\\tw2 = \\'\\'.join(\\'*\\' if c in \\'aeiou\\' else c for c in w1)\\n\\t\\tif w2 not in mp2:\\n\\t\\t\\tmp2[w2] = w\\n\\n\\tans = []\\n\\tfor q in qs:\\n\\t\\tw1 = q.lower()\\n\\t\\tw2 = \\'\\'.join(\\'*\\' if c in \\'aeiou\\' else c for c in w1)\\n\\t\\tcur = \\'\\'\\n\\t\\tif q in word_set:\\n\\t\\t\\tcur = q\\n\\t\\telif w1 in mp1:\\n\\t\\t\\tcur = mp1[w1]\\n\\t\\telif w2 in mp2:\\n\\t\\t\\tcur = mp2[w2]\\n\\t\\tans.append(cur)\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2398935,
                "title": "python-solution-hierachy-should-be-stated-more-clearly",
                "content": "I think the hierachy of finding matches should be stated more clearly:\\n**Exact match** > **Capitalized** > **Vowel switch**\\n```\\nclass Solution:\\n    # First I will save the words in set, so that whenever I see the search word match exactly, I will return the same word\\n    \\n    # If I build all possible keys\\n    # 1 <= wordlist.length, queries.length <= 5000\\n    # 1 <= wordlist[i].length, queries[i].length <= 7\\n    # So if I build every possible variations the worst will be aaaaaaa = 10^7 keys\\n    # a little too much\\n    \\n    # Second option is whenever I do not see a perfect match, I preconvert the word list into lowercase letters. For example, if wordlist = [\"KiTe\",\"kite\",\"hare\",\"Hare\"], effectively I am only searching [\"KiTe\", \"hare\"] in this stage\\n    # To allow for all the vowels, we can use something like \"k#t#\" to represent kite or karo etc. This should do the job \\n    \\n    def preprocess(self, word):\\n        # preprocess:\\n        word_search = \"\"\\n        for c in word:\\n            if c in \"aeiouAEIOU\":\\n                word_search += \"#\"\\n            else:\\n                word_search += c.lower()\\n        return word_search\\n    \\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        word_set = set(wordlist)\\n        lowered_hash_table, hash_table, result = {}, {}, []\\n        for word in wordlist:\\n            if word.lower() not in lowered_hash_table:\\n                lowered_hash_table[word.lower()] = word\\n            word_search = self.preprocess(word)\\n            if word_search not in hash_table:\\n                hash_table[word_search] = word        \\n        \\n        for query in queries:\\n            if query in word_set:\\n                result.append(query)\\n            elif query.lower() in lowered_hash_table:\\n                result.append(lowered_hash_table[query.lower()])\\n            else:\\n                query_search = self.preprocess(query)\\n                if query_search in hash_table:\\n                    result.append(hash_table[query_search])\\n                else:\\n                    result.append(\"\")\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # First I will save the words in set, so that whenever I see the search word match exactly, I will return the same word\\n    \\n    # If I build all possible keys\\n    # 1 <= wordlist.length, queries.length <= 5000\\n    # 1 <= wordlist[i].length, queries[i].length <= 7\\n    # So if I build every possible variations the worst will be aaaaaaa = 10^7 keys\\n    # a little too much\\n    \\n    # Second option is whenever I do not see a perfect match, I preconvert the word list into lowercase letters. For example, if wordlist = [\"KiTe\",\"kite\",\"hare\",\"Hare\"], effectively I am only searching [\"KiTe\", \"hare\"] in this stage\\n    # To allow for all the vowels, we can use something like \"k#t#\" to represent kite or karo etc. This should do the job \\n    \\n    def preprocess(self, word):\\n        # preprocess:\\n        word_search = \"\"\\n        for c in word:\\n            if c in \"aeiouAEIOU\":\\n                word_search += \"#\"\\n            else:\\n                word_search += c.lower()\\n        return word_search\\n    \\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        word_set = set(wordlist)\\n        lowered_hash_table, hash_table, result = {}, {}, []\\n        for word in wordlist:\\n            if word.lower() not in lowered_hash_table:\\n                lowered_hash_table[word.lower()] = word\\n            word_search = self.preprocess(word)\\n            if word_search not in hash_table:\\n                hash_table[word_search] = word        \\n        \\n        for query in queries:\\n            if query in word_set:\\n                result.append(query)\\n            elif query.lower() in lowered_hash_table:\\n                result.append(lowered_hash_table[query.lower()])\\n            else:\\n                query_search = self.preprocess(query)\\n                if query_search in hash_table:\\n                    result.append(hash_table[query_search])\\n                else:\\n                    result.append(\"\")\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340822,
                "title": "c-using-maps-and-set",
                "content": "Could be made faster by passing references and using those modifying str in valid places.\\n\\n```\\nbool isVowel(char ch){\\n        return ch == \\'a\\' or ch == \\'e\\' or ch == \\'i\\' or ch == \\'o\\' or ch == \\'u\\';\\n    }\\n    \\n    string encode(string str){\\n        \\n        for(int j=0; j<str.size(); j++){\\n            if(isVowel(str[j])) str[j] = \\'*\\';\\n        } \\n        return str; \\n    }\\n    \\n    string to_lower(string str){\\n        \\n        for(int i=0; i<str.size(); i++)\\n            str[i] = tolower(str[i]);\\n        \\n        return str;\\n    }\\n    \\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        \\n        unordered_set<string> s(begin(wordlist), end(wordlist));\\n        \\n        unordered_map<string, string> capital, consonant;\\n        \\n        for(int i=0; i<wordlist.size(); i++){\\n            \\n            string str = wordlist[i];\\n            \\n            if(capital.find(to_lower(str)) == capital.end())\\n                capital[to_lower(str)] = str;\\n            \\n            if(consonant.find(encode(to_lower(str))) == consonant.end())\\n                consonant[encode(to_lower(str))] = wordlist[i];\\n        }\\n        \\n        vector<string> res;\\n        \\n        for(int i=0; i<queries.size(); i++){\\n            \\n            string str = queries[i];\\n            \\n            if(s.find(str) != s.end()) res.push_back(str);\\n            \\n            else if(capital.find(to_lower(str)) != capital.end())\\n                res.push_back(capital[to_lower(str)]);\\n            \\n            else if (consonant.find(encode(to_lower(str))) != consonant.end())\\n                res.push_back(consonant[encode(to_lower(str))]);\\n            \\n            else\\n                res.push_back(\"\");\\n            \\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool isVowel(char ch){\\n        return ch == \\'a\\' or ch == \\'e\\' or ch == \\'i\\' or ch == \\'o\\' or ch == \\'u\\';\\n    }\\n    \\n    string encode(string str){\\n        \\n        for(int j=0; j<str.size(); j++){\\n            if(isVowel(str[j])) str[j] = \\'*\\';\\n        } \\n        return str; \\n    }\\n    \\n    string to_lower(string str){\\n        \\n        for(int i=0; i<str.size(); i++)\\n            str[i] = tolower(str[i]);\\n        \\n        return str;\\n    }\\n    \\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        \\n        unordered_set<string> s(begin(wordlist), end(wordlist));\\n        \\n        unordered_map<string, string> capital, consonant;\\n        \\n        for(int i=0; i<wordlist.size(); i++){\\n            \\n            string str = wordlist[i];\\n            \\n            if(capital.find(to_lower(str)) == capital.end())\\n                capital[to_lower(str)] = str;\\n            \\n            if(consonant.find(encode(to_lower(str))) == consonant.end())\\n                consonant[encode(to_lower(str))] = wordlist[i];\\n        }\\n        \\n        vector<string> res;\\n        \\n        for(int i=0; i<queries.size(); i++){\\n            \\n            string str = queries[i];\\n            \\n            if(s.find(str) != s.end()) res.push_back(str);\\n            \\n            else if(capital.find(to_lower(str)) != capital.end())\\n                res.push_back(capital[to_lower(str)]);\\n            \\n            else if (consonant.find(encode(to_lower(str))) != consonant.end())\\n                res.push_back(consonant[encode(to_lower(str))]);\\n            \\n            else\\n                res.push_back(\"\");\\n            \\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2304479,
                "title": "python-code-easy-understand-use-one-set-and-tow-hash-map",
                "content": "according to spellingchecker rules we can check query by 3 types of errors:\\n1. no error:if query exists in wordlist,so we need a dictionary with valid words.\\n2. capitalization error: we can convert word in wordlist to lowercases as key then map to the first word with same key,eg Kite,kIte,KItE to d[kite]=Kite (arrording to rule and priority).\\n3. vowel error: we can mask vowel in word and lowercae it as key and map to the first word with same key, eg \"HEAR\",\"Hear\",\"hear\", all with same key as h??r, d[h??r]=HEAR.\\ntime complex: O(N * C), N=len(wordList), C=average word length\\nspace require:O(N), one set and two hashmaps\\n\\n```\\nclass Solution(object):\\n    def spellchecker(self, wordlist, queries):\\n        \"\"\"\\n        :type wordlist: List[str]\\n        :type queries: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        self._validWds,self._lowerWdD,self._vowelWdD=set(wordlist),{},{}\\n        def _maskVowel(w):\\n            return \\'\\'.join([\\'*\\' if c in \\'aeiou\\' else c for c in w.lower()])\\n        \\n        for w in wordlist:\\n            k,vk=w.lower(),_maskVowel(w)\\n            if k not in self._lowerWdD:self._lowerWdD[k]=w\\n            if vk not in self._vowelWdD:self._vowelWdD[vk]=w\\n                \\n        def _mapQueryToWord(q):\\n            if q in self._validWds:return q\\n            lk=q.lower()\\n            if lk in self._lowerWdD:\\n                return self._lowerWdD[lk]\\n            else:\\n                vk=_maskVowel(q)\\n                return self._vowelWdD[vk] if vk in self._vowelWdD else \\'\\'\\n            \\n        return map(_mapQueryToWord,queries)\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution(object):\\n    def spellchecker(self, wordlist, queries):\\n        \"\"\"\\n        :type wordlist: List[str]\\n        :type queries: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        self._validWds,self._lowerWdD,self._vowelWdD=set(wordlist),{},{}\\n        def _maskVowel(w):\\n            return \\'\\'.join([\\'*\\' if c in \\'aeiou\\' else c for c in w.lower()])\\n        \\n        for w in wordlist:\\n            k,vk=w.lower(),_maskVowel(w)\\n            if k not in self._lowerWdD:self._lowerWdD[k]=w\\n            if vk not in self._vowelWdD:self._vowelWdD[vk]=w\\n                \\n        def _mapQueryToWord(q):\\n            if q in self._validWds:return q\\n            lk=q.lower()\\n            if lk in self._lowerWdD:\\n                return self._lowerWdD[lk]\\n            else:\\n                vk=_maskVowel(q)\\n                return self._vowelWdD[vk] if vk in self._vowelWdD else \\'\\'\\n            \\n        return map(_mapQueryToWord,queries)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298025,
                "title": "description-of-problem-is-terrible",
                "content": "The last match rule says the the following: \\n   (1) form all words W from the query word by changing any of the vowels \"a\", \"e\", \"i\", \"o\", and \"u\" to any other vowel;\\n   (2) return the first word in the wordlist argument which is a case-insenstive match for one of the words in W, or the empty string if there is no such word.\\n\\nThis rule DOES NOT SAY that you are allowed to substitute an \"A\", \"E\", \"I\", \"O\",or \"U\" in the query word. AND NO, I ABSOLUTELY SHOULD NOT HAVE HAD TO INFER THAT THESE SUBSTITUTIONS WERE ALLOWED BY EXPERIMENTING.\\n\\nWith the rule that I have described and input wordlist = [\"a\"] and query = [\"E\"], the return reply list should be a list whose only element is the empty string.\\n        \\nIf you really mean to allow that upper-case ias well as lower-case vowels be substituted in query words, please say so explicitly. Listing only the lower-case vowels as substitutable and expecting us to guess that upper-case vowels are also  substitutable is misdirection and gaslighting!",
                "solutionTags": [],
                "code": "The last match rule says the the following: \\n   (1) form all words W from the query word by changing any of the vowels \"a\", \"e\", \"i\", \"o\", and \"u\" to any other vowel;\\n   (2) return the first word in the wordlist argument which is a case-insenstive match for one of the words in W, or the empty string if there is no such word.\\n\\nThis rule DOES NOT SAY that you are allowed to substitute an \"A\", \"E\", \"I\", \"O\",or \"U\" in the query word. AND NO, I ABSOLUTELY SHOULD NOT HAVE HAD TO INFER THAT THESE SUBSTITUTIONS WERE ALLOWED BY EXPERIMENTING.\\n\\nWith the rule that I have described and input wordlist = [\"a\"] and query = [\"E\"], the return reply list should be a list whose only element is the empty string.\\n        \\nIf you really mean to allow that upper-case ias well as lower-case vowels be substituted in query words, please say so explicitly. Listing only the lower-case vowels as substitutable and expecting us to guess that upper-case vowels are also  substitutable is misdirection and gaslighting!",
                "codeTag": "Unknown"
            },
            {
                "id": 2162471,
                "title": "c-solution-using-hashmap-super-fast-space-efficient",
                "content": "### C++ Solution using HashMap. Super fast && space efficient.\\nRuntime: 68 ms, faster than 100.00% of C++ online submissions for Vowel Spellchecker.\\nMemory Usage: 32.7 MB, less than 96.90% of C++ online submissions for Vowel Spellchecker.\\n```\\nclass Solution {\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        unordered_map<string, vector<int>> umap;\\n        \\n        // step 1: add info in umap;\\n        for(int curr = 0; curr < wordlist.size(); curr++){\\n            // case 1: add same;\\n            umap[wordlist[curr]].push_back({curr});\\n            // notice that the lowercase may appear;\\n            \\n            // case 2: add lowercase;\\n            string tmp = wordlist[curr];\\n            transform(tmp.begin(), tmp.end(), tmp.begin(), ::tolower);\\n            \\n            if(umap.find(tmp) == umap.end() && tmp != wordlist[curr]) umap[tmp].push_back({curr});      \\n            \\n            // case 3: add vowel errors;\\n            // convert aeiou to _;\\n            for(int c_index = 0; c_index < tmp.size(); c_index++){\\n                char c = tmp[c_index];\\n                if(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\') tmp[c_index] = \\'_\\';\\n            }\\n            \\n            if(umap.find(tmp) == umap.end()) umap[tmp].push_back({curr});\\n        }\\n        \\n        // step 2: convert queries;\\n        for(int curr = 0; curr < queries.size(); curr++){\\n            string tmp = queries[curr];\\n            transform(tmp.begin(), tmp.end(), tmp.begin(), ::tolower);\\n            \\n            // case 1: check same;\\n            if(umap.find(queries[curr]) != umap.end()){\\n                queries[curr] = (umap[queries[curr]].size() == 1) ? wordlist[umap[queries[curr]][0]] : wordlist[umap[queries[curr]][1]];\\n                continue;\\n            }\\n            \\n            // case 2: check lowercase;\\n            if(umap.find(tmp) != umap.end() && tmp != queries[curr]){\\n                queries[curr] = wordlist[umap[tmp][0]];\\n                continue;\\n            }\\n            \\n            // case 3: check vowel errors;\\n            // convert aeiou to _;\\n            for(int c_index = 0; c_index < tmp.size(); c_index++){\\n                char c = tmp[c_index];\\n                if(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\') tmp[c_index] = \\'_\\';\\n            }\\n                  \\n            if(umap.find(tmp) != umap.end()){\\n                queries[curr] = wordlist[umap[tmp][0]];\\n                continue;\\n            }\\n            \\n            // case 4: not found;\\n            queries[curr] = \"\";\\n        }\\n        \\n        return queries;\\n    }\\n};\\n\\n// 1. When the query exactly matches a word in the wordlist (case-sensitive), you should return the same word back.\\n// 2. When the query matches a word up to capitlization, you should return the first such match in the wordlist.\\n// 3. When the query matches a word up to vowel errors, you should return the first such match in the wordlist.\\n// 4. If the query has no matches in the wordlist, you should return the empty string.\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        unordered_map<string, vector<int>> umap;\\n        \\n        // step 1: add info in umap;\\n        for(int curr = 0; curr < wordlist.size(); curr++){\\n            // case 1: add same;\\n            umap[wordlist[curr]].push_back({curr});\\n            // notice that the lowercase may appear;\\n            \\n            // case 2: add lowercase;\\n            string tmp = wordlist[curr];\\n            transform(tmp.begin(), tmp.end(), tmp.begin(), ::tolower);\\n            \\n            if(umap.find(tmp) == umap.end() && tmp != wordlist[curr]) umap[tmp].push_back({curr});      \\n            \\n            // case 3: add vowel errors;\\n            // convert aeiou to _;\\n            for(int c_index = 0; c_index < tmp.size(); c_index++){\\n                char c = tmp[c_index];\\n                if(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\') tmp[c_index] = \\'_\\';\\n            }\\n            \\n            if(umap.find(tmp) == umap.end()) umap[tmp].push_back({curr});\\n        }\\n        \\n        // step 2: convert queries;\\n        for(int curr = 0; curr < queries.size(); curr++){\\n            string tmp = queries[curr];\\n            transform(tmp.begin(), tmp.end(), tmp.begin(), ::tolower);\\n            \\n            // case 1: check same;\\n            if(umap.find(queries[curr]) != umap.end()){\\n                queries[curr] = (umap[queries[curr]].size() == 1) ? wordlist[umap[queries[curr]][0]] : wordlist[umap[queries[curr]][1]];\\n                continue;\\n            }\\n            \\n            // case 2: check lowercase;\\n            if(umap.find(tmp) != umap.end() && tmp != queries[curr]){\\n                queries[curr] = wordlist[umap[tmp][0]];\\n                continue;\\n            }\\n            \\n            // case 3: check vowel errors;\\n            // convert aeiou to _;\\n            for(int c_index = 0; c_index < tmp.size(); c_index++){\\n                char c = tmp[c_index];\\n                if(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\') tmp[c_index] = \\'_\\';\\n            }\\n                  \\n            if(umap.find(tmp) != umap.end()){\\n                queries[curr] = wordlist[umap[tmp][0]];\\n                continue;\\n            }\\n            \\n            // case 4: not found;\\n            queries[curr] = \"\";\\n        }\\n        \\n        return queries;\\n    }\\n};\\n\\n// 1. When the query exactly matches a word in the wordlist (case-sensitive), you should return the same word back.\\n// 2. When the query matches a word up to capitlization, you should return the first such match in the wordlist.\\n// 3. When the query matches a word up to vowel errors, you should return the first such match in the wordlist.\\n// 4. If the query has no matches in the wordlist, you should return the empty string.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2156640,
                "title": "c-w-trie-makes-o-c-more-stable",
                "content": "The means of using hash is fair enough. But the only problem on hash is the worse case. The worse case will meet O(nl) if key gets collision. (n = numbers of word, l = length of word)\\n\\nUsing Trie may be more complicated on coding but it ensure the worse case will still remind O(l).\\n\\n```cpp\\nstruct TrieNode {\\n    vector<string> str;\\n    unordered_map<char,TrieNode*> next;\\n};\\n\\nclass Solution {\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        unordered_set<char> vowels = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n        TrieNode * origHead = new TrieNode;\\n        TrieNode * caseHead = new TrieNode;\\n        TrieNode * voweHead = new TrieNode;\\n        for (auto & word: wordlist) {\\n            TrieNode * origCurr = origHead;\\n            TrieNode * caseCurr = caseHead;\\n            TrieNode * voweCurr = voweHead;\\n            for (auto ch: word) {\\n                if (origCurr->next.find(ch) == origCurr->next.end())\\n                    origCurr->next.insert({ch, new TrieNode});\\n                origCurr = origCurr->next[ch];\\n                \\n                if (ch <= \\'Z\\')\\n                    ch += 32;\\n                if (caseCurr->next.find(ch) == caseCurr->next.end())\\n                    caseCurr->next.insert({ch, new TrieNode});\\n                caseCurr = caseCurr->next[ch];\\n                \\n                if (vowels.find(ch) != vowels.end())\\n                    ch = \\'*\\';\\n                if (voweCurr->next.find(ch) == voweCurr->next.end())\\n                    voweCurr->next.insert({ch, new TrieNode});\\n                voweCurr = voweCurr->next[ch];\\n            }\\n            origCurr->str.push_back(word);\\n            caseCurr->str.push_back(word);\\n            voweCurr->str.push_back(word);\\n        }\\n        vector<string> ans;\\n        for (auto & q: queries) {\\n            TrieNode * origCurr = origHead;\\n            TrieNode * caseCurr = caseHead;\\n            TrieNode * voweCurr = voweHead;\\n            for (auto ch: q) {\\n                if (origCurr && origCurr->next.find(ch) != origCurr->next.end()) {\\n                    origCurr = origCurr->next[ch];\\n                } else {\\n                    origCurr = NULL;\\n                    // break;\\n                }\\n                \\n                if (ch <= \\'Z\\')\\n                    ch += 32;\\n                if (caseCurr && caseCurr->next.find(ch) != caseCurr->next.end()) {\\n                    caseCurr = caseCurr->next[ch];\\n                } else {\\n                    caseCurr = NULL;\\n                    // break;\\n                }\\n                \\n                if (vowels.find(ch) != vowels.end())\\n                    ch = \\'*\\';\\n                if (voweCurr && voweCurr->next.find(ch) != voweCurr->next.end()) {\\n                    voweCurr = voweCurr->next[ch];\\n                } else {\\n                    voweCurr = NULL;\\n                    // break;\\n                }\\n            }\\n            if (origCurr && origCurr->str.size() != 0)\\n                ans.push_back(origCurr->str[0]);\\n            else if (caseCurr && caseCurr->str.size() != 0)\\n                ans.push_back(caseCurr->str[0]);\\n            else if (voweCurr && voweCurr->str.size() != 0)\\n                ans.push_back(voweCurr->str[0]);\\n            else\\n                ans.push_back(\"\");\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```cpp\\nstruct TrieNode {\\n    vector<string> str;\\n    unordered_map<char,TrieNode*> next;\\n};\\n\\nclass Solution {\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        unordered_set<char> vowels = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n        TrieNode * origHead = new TrieNode;\\n        TrieNode * caseHead = new TrieNode;\\n        TrieNode * voweHead = new TrieNode;\\n        for (auto & word: wordlist) {\\n            TrieNode * origCurr = origHead;\\n            TrieNode * caseCurr = caseHead;\\n            TrieNode * voweCurr = voweHead;\\n            for (auto ch: word) {\\n                if (origCurr->next.find(ch) == origCurr->next.end())\\n                    origCurr->next.insert({ch, new TrieNode});\\n                origCurr = origCurr->next[ch];\\n                \\n                if (ch <= \\'Z\\')\\n                    ch += 32;\\n                if (caseCurr->next.find(ch) == caseCurr->next.end())\\n                    caseCurr->next.insert({ch, new TrieNode});\\n                caseCurr = caseCurr->next[ch];\\n                \\n                if (vowels.find(ch) != vowels.end())\\n                    ch = \\'*\\';\\n                if (voweCurr->next.find(ch) == voweCurr->next.end())\\n                    voweCurr->next.insert({ch, new TrieNode});\\n                voweCurr = voweCurr->next[ch];\\n            }\\n            origCurr->str.push_back(word);\\n            caseCurr->str.push_back(word);\\n            voweCurr->str.push_back(word);\\n        }\\n        vector<string> ans;\\n        for (auto & q: queries) {\\n            TrieNode * origCurr = origHead;\\n            TrieNode * caseCurr = caseHead;\\n            TrieNode * voweCurr = voweHead;\\n            for (auto ch: q) {\\n                if (origCurr && origCurr->next.find(ch) != origCurr->next.end()) {\\n                    origCurr = origCurr->next[ch];\\n                } else {\\n                    origCurr = NULL;\\n                    // break;\\n                }\\n                \\n                if (ch <= \\'Z\\')\\n                    ch += 32;\\n                if (caseCurr && caseCurr->next.find(ch) != caseCurr->next.end()) {\\n                    caseCurr = caseCurr->next[ch];\\n                } else {\\n                    caseCurr = NULL;\\n                    // break;\\n                }\\n                \\n                if (vowels.find(ch) != vowels.end())\\n                    ch = \\'*\\';\\n                if (voweCurr && voweCurr->next.find(ch) != voweCurr->next.end()) {\\n                    voweCurr = voweCurr->next[ch];\\n                } else {\\n                    voweCurr = NULL;\\n                    // break;\\n                }\\n            }\\n            if (origCurr && origCurr->str.size() != 0)\\n                ans.push_back(origCurr->str[0]);\\n            else if (caseCurr && caseCurr->str.size() != 0)\\n                ans.push_back(caseCurr->str[0]);\\n            else if (voweCurr && voweCurr->str.size() != 0)\\n                ans.push_back(voweCurr->str[0]);\\n            else\\n                ans.push_back(\"\");\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2072718,
                "title": "issue",
                "content": "![image](https://assets.leetcode.com/users/images/c1ecaa20-2a4f-42a2-9075-32276ad6b8be_1653482183.1435874.png)\\n\\nSomething happened when I submitted my code. local tests that are equal to the evaluation ones work as tests but fail when sent.",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/c1ecaa20-2a4f-42a2-9075-32276ad6b8be_1653482183.1435874.png)\\n\\nSomething happened when I submitted my code. local tests that are equal to the evaluation ones work as tests but fail when sent.",
                "codeTag": "Unknown"
            },
            {
                "id": 1943178,
                "title": "kotlin-set-map-map-solution",
                "content": "Please, let me know if you have any questions.\\n\\n```\\n/**\\n * We use putIfAbsent for lowercase and devoweled dictionaries because we are only interested in the first occurrence of\\n * transformed word. \\n * Let\\'s say we have wordlist = (WoRd, WOrd, WoRD) and queries = (wOrd)\\n * originalDict will be     (WoRd, WOrd, WoRD)\\n * lowerCaseDict will be    (word -> WoRd)\\n * devoweledDict will be    (w*rd -> WoRd)\\n * That\\'s because WOrd and WoRD will have the same lowerCAse and devoweled forms\\n */\\nclass Solution {\\n    fun spellchecker(wordlist: Array<String>, queries: Array<String>): Array<String> {\\n        val result = Array(queries.size) { \"\" }\\n\\n        val originalDict = mutableSetOf<String>() // just words from the original dictionary\\n        val lowerCasedDict = mutableMapOf<String, String>() // lowercase words from the original dictionary (WoRd -> word)\\n        val devoweledDict = mutableMapOf<String, String>() // lowercase words from the original dictionary with vowels replaced (WooOooORd -> w******rd)\\n        \\n        // Initialize dictionaries\\n        for (word in wordlist) {\\n            originalDict.add(word)\\n            val lowerCaseWord = word.lowercase()\\n            lowerCasedDict.putIfAbsent(lowerCaseWord, word)  \\n            devoweledDict.putIfAbsent(devowel(lowerCaseWord), word)\\n        }\\n\\n        // Try to find in dictionaries in accordance with precedence \\n        for ((index, query) in queries.withIndex()) {\\n            if (originalDict.contains(query)) {\\n                result[index] = query\\n            } else {\\n                val lowerCaseQuery = query.lowercase()\\n                result[index] = lowerCasedDict[lowerCaseQuery] ?: devoweledDict[devowel(lowerCaseQuery)] ?: \"\"\\n            }\\n        }\\n        return result\\n    }\\n\\n    private fun devowel(word: String): String {\\n        return word.replace(\"[aeiou]\".toRegex(), \"*\")\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n/**\\n * We use putIfAbsent for lowercase and devoweled dictionaries because we are only interested in the first occurrence of\\n * transformed word. \\n * Let\\'s say we have wordlist = (WoRd, WOrd, WoRD) and queries = (wOrd)\\n * originalDict will be     (WoRd, WOrd, WoRD)\\n * lowerCaseDict will be    (word -> WoRd)\\n * devoweledDict will be    (w*rd -> WoRd)\\n * That\\'s because WOrd and WoRD will have the same lowerCAse and devoweled forms\\n */\\nclass Solution {\\n    fun spellchecker(wordlist: Array<String>, queries: Array<String>): Array<String> {\\n        val result = Array(queries.size) { \"\" }\\n\\n        val originalDict = mutableSetOf<String>() // just words from the original dictionary\\n        val lowerCasedDict = mutableMapOf<String, String>() // lowercase words from the original dictionary (WoRd -> word)\\n        val devoweledDict = mutableMapOf<String, String>() // lowercase words from the original dictionary with vowels replaced (WooOooORd -> w******rd)\\n        \\n        // Initialize dictionaries\\n        for (word in wordlist) {\\n            originalDict.add(word)\\n            val lowerCaseWord = word.lowercase()\\n            lowerCasedDict.putIfAbsent(lowerCaseWord, word)  \\n            devoweledDict.putIfAbsent(devowel(lowerCaseWord), word)\\n        }\\n\\n        // Try to find in dictionaries in accordance with precedence \\n        for ((index, query) in queries.withIndex()) {\\n            if (originalDict.contains(query)) {\\n                result[index] = query\\n            } else {\\n                val lowerCaseQuery = query.lowercase()\\n                result[index] = lowerCasedDict[lowerCaseQuery] ?: devoweledDict[devowel(lowerCaseQuery)] ?: \"\"\\n            }\\n        }\\n        return result\\n    }\\n\\n    private fun devowel(word: String): String {\\n        return word.replace(\"[aeiou]\".toRegex(), \"*\")\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1925880,
                "title": "python-sol-simple-easy-code-hashtable",
                "content": "# CODE\\n```\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        n = len(wordlist)\\n        d = {}\\n        sd = {}\\n        vd = {}\\n        cd = {}\\n        for i in range(n):\\n            d[wordlist[i]] = i\\n            s = wordlist[i].lower()\\n            if s not in sd:sd[s] = i \\n            m = len(wordlist[i])\\n            tmp = []\\n            emp = \"\"\\n            for j in range(m):\\n                if wordlist[i][j] in \\'aeiouAEIOU\\': tmp.append(j)\\n                else:emp+=wordlist[i][j].lower()\\n            cd[i] = emp\\n            vd[i] = tmp\\n            \\n        ans = []\\n        for word in queries:\\n            word_lower = word.lower()\\n            if word in d: \\n                ans.append(word)\\n                continue            \\n            elif word_lower in sd:\\n                ans.append(wordlist[sd[word_lower]])\\n                continue\\n            else:\\n                vow_word = []\\n                con_word = \"\" \\n                m = len(word)\\n                for i in range(m):\\n                    if word[i] in \\'aeiouAEIOU\\' : vow_word.append(i)\\n                    else: con_word += word[i].lower()\\n                if vow_word == []:\\n                    ans.append(\"\")\\n                    continue\\n                    \\n                flag = False\\n                for i in range(n):\\n                    vow_tmp = vd[i]\\n                    con_tmp = cd[i]\\n                    if vow_tmp == vow_word and con_tmp == con_word:\\n                        ans.append(wordlist[i])\\n                        flag = True\\n                        break\\n                if flag == True:continue\\n                ans.append(\"\")\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        n = len(wordlist)\\n        d = {}\\n        sd = {}\\n        vd = {}\\n        cd = {}\\n        for i in range(n):\\n            d[wordlist[i]] = i\\n            s = wordlist[i].lower()\\n            if s not in sd:sd[s] = i \\n            m = len(wordlist[i])\\n            tmp = []\\n            emp = \"\"\\n            for j in range(m):\\n                if wordlist[i][j] in \\'aeiouAEIOU\\': tmp.append(j)\\n                else:emp+=wordlist[i][j].lower()\\n            cd[i] = emp\\n            vd[i] = tmp\\n            \\n        ans = []\\n        for word in queries:\\n            word_lower = word.lower()\\n            if word in d: \\n                ans.append(word)\\n                continue            \\n            elif word_lower in sd:\\n                ans.append(wordlist[sd[word_lower]])\\n                continue\\n            else:\\n                vow_word = []\\n                con_word = \"\" \\n                m = len(word)\\n                for i in range(m):\\n                    if word[i] in \\'aeiouAEIOU\\' : vow_word.append(i)\\n                    else: con_word += word[i].lower()\\n                if vow_word == []:\\n                    ans.append(\"\")\\n                    continue\\n                    \\n                flag = False\\n                for i in range(n):\\n                    vow_tmp = vd[i]\\n                    con_tmp = cd[i]\\n                    if vow_tmp == vow_word and con_tmp == con_word:\\n                        ans.append(wordlist[i])\\n                        flag = True\\n                        break\\n                if flag == True:continue\\n                ans.append(\"\")\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1799638,
                "title": "python3-hashing-consonants-and-their-index",
                "content": "```\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        vowels=set(\\'aeiou\\')\\n        dct,consonants={},{}\\n        for el in wordlist:\\n            dct.setdefault(el.lower(),el)\\n            s=\\'\\'.join(f\"{x}{str(i)}\" for i,x in enumerate(el.lower()) if x not in vowels)\\n            consonants.setdefault(s,el)\\n        s=set(wordlist)\\n        res=[]\\n        for word in queries:\\n            if word in s:\\n                res.append(word)\\n            elif word.lower() in dct:\\n                res.append(dct[word.lower()])\\n            else:\\n                s=\\'\\'.join(f\"{x}{str(i)}\" for i,x in enumerate(word.lower()) if x not in vowels)\\n                res.append(consonants[s] if s in consonants else \\'\\')\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        vowels=set(\\'aeiou\\')\\n        dct,consonants={},{}\\n        for el in wordlist:\\n            dct.setdefault(el.lower(),el)\\n            s=\\'\\'.join(f\"{x}{str(i)}\" for i,x in enumerate(el.lower()) if x not in vowels)\\n            consonants.setdefault(s,el)\\n        s=set(wordlist)\\n        res=[]\\n        for word in queries:\\n            if word in s:\\n                res.append(word)\\n            elif word.lower() in dct:\\n                res.append(dct[word.lower()])\\n            else:\\n                s=\\'\\'.join(f\"{x}{str(i)}\" for i,x in enumerate(word.lower()) if x not in vowels)\\n                res.append(consonants[s] if s in consonants else \\'\\')\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1796084,
                "title": "c-using-3-level-dictionary-hashmap-easy-to-understand",
                "content": "\\t\\t\\tpublic string[] Spellchecker(string[] wordlist, string[] queries)\\n        {\\n            var ans=new List<string>();\\n            Dictionary<char, int> map = new Dictionary<char, int>()\\n            {\\n                {\\'a\\', 0},{\\'e\\', 0},{\\'i\\', 0},{\\'o\\', 0},{\\'u\\', 0},\\n                {\\'A\\', 0}, {\\'E\\', 0}, {\\'I\\', 0}, {\\'O\\', 0}, {\\'U\\', 0},\\n            };\\n            //Capitalization hashmap\\n            Dictionary<string, string> dict = new Dictionary<string, string>();\\n            //Vowel Errors hashmap\\n            Dictionary<int, Dictionary<string, Dictionary<string, string>>> vowelDict\\n                = new Dictionary<int, Dictionary<string, Dictionary<string, string>>>();\\n            foreach (var word in wordlist)\\n            {\\n                //store to Capitalization hashmap\\n                if (!dict.ContainsKey(word))\\n                    dict.Add(word, word);\\n                var capWord = word.ToUpper();\\n                if(!dict.ContainsKey(capWord))\\n                    dict.Add(capWord, word);\\n                //two parts, Vowel idnexes and other letters\\n                List<int> list = new List<int>();\\n                List<char> others = new List<char>();\\n                for(int i=0;i< word.Length;i++)\\n                {\\n                    if (map.ContainsKey(word[i]))\\n                        list.Add(i);\\n                    else\\n                        others.Add(word[i]);\\n                }\\n                if (list.Count > 0)\\n                {\\n                    //using Length as 1st level key\\n                    if (!vowelDict.ContainsKey(word.Length))\\n                        vowelDict.Add(word.Length,new Dictionary<string, Dictionary<string, string>>());\\n                    var indexStr = string.Join(\"_\", list);\\n                    //using indexStr string join \"_\" as 2nd level key\\n                    if (!vowelDict[word.Length].ContainsKey(indexStr))\\n                        vowelDict[word.Length].Add(indexStr, new Dictionary<string, string>());\\n                    //using otherStr as 3rd level key\\n                    var otherStr = new string(others.ToArray()).ToUpper();\\n                    if(!vowelDict[word.Length][indexStr].ContainsKey(otherStr))\\n                        vowelDict[word.Length][indexStr].Add(otherStr,word);\\n                }\\n            }\\n            foreach(var query in queries)\\n            {\\n                if (dict.ContainsKey(query))\\n                {\\n                    ans.Add(dict[query]);\\n                }\\n                else if (dict.ContainsKey(query.ToUpper()))\\n                {\\n                    ans.Add(dict[query.ToUpper()]);\\n                }\\n                else\\n                {\\n                    List<int> list = new List<int>();\\n                    List<char> others = new List<char>();\\n                    for (int i = 0; i < query.Length; i++)\\n                    {\\n                        if (map.ContainsKey(query[i]))\\n                            list.Add(i);\\n                        else\\n                            others.Add(query[i]);\\n                    }\\n                    if (list.Count >0 && vowelDict.ContainsKey(query.Length))\\n                    {\\n                        var indexStr = string.Join(\"_\", list);\\n                        var otherStr = new string(others.ToArray()).ToUpper();\\n                        if (vowelDict[query.Length].ContainsKey(indexStr)\\n                            && vowelDict[query.Length][indexStr].ContainsKey(otherStr))\\n                        {\\n                            ans.Add(vowelDict[query.Length][indexStr][otherStr]);\\n                        }\\n                        else\\n                        {\\n                            ans.Add(string.Empty);\\n                        }\\n                    }\\n                    else\\n                    {\\n                        ans.Add(string.Empty);\\n                    }\\n                }\\n            }\\n            return ans.ToArray();\\n        }\\n",
                "solutionTags": [],
                "code": "\\t\\t\\tpublic string[] Spellchecker(string[] wordlist, string[] queries)\\n        {\\n            var ans=new List<string>();\\n            Dictionary<char, int> map = new Dictionary<char, int>()\\n            {\\n                {\\'a\\', 0},{\\'e\\', 0},{\\'i\\', 0},{\\'o\\', 0},{\\'u\\', 0},\\n                {\\'A\\', 0}, {\\'E\\', 0}, {\\'I\\', 0}, {\\'O\\', 0}, {\\'U\\', 0},\\n            };\\n            //Capitalization hashmap\\n            Dictionary<string, string> dict = new Dictionary<string, string>();\\n            //Vowel Errors hashmap\\n            Dictionary<int, Dictionary<string, Dictionary<string, string>>> vowelDict\\n                = new Dictionary<int, Dictionary<string, Dictionary<string, string>>>();\\n            foreach (var word in wordlist)\\n            {\\n                //store to Capitalization hashmap\\n                if (!dict.ContainsKey(word))\\n                    dict.Add(word, word);\\n                var capWord = word.ToUpper();\\n                if(!dict.ContainsKey(capWord))\\n                    dict.Add(capWord, word);\\n                //two parts, Vowel idnexes and other letters\\n                List<int> list = new List<int>();\\n                List<char> others = new List<char>();\\n                for(int i=0;i< word.Length;i++)\\n                {\\n                    if (map.ContainsKey(word[i]))\\n                        list.Add(i);\\n                    else\\n                        others.Add(word[i]);\\n                }\\n                if (list.Count > 0)\\n                {\\n                    //using Length as 1st level key\\n                    if (!vowelDict.ContainsKey(word.Length))\\n                        vowelDict.Add(word.Length,new Dictionary<string, Dictionary<string, string>>());\\n                    var indexStr = string.Join(\"_\", list);\\n                    //using indexStr string join \"_\" as 2nd level key\\n                    if (!vowelDict[word.Length].ContainsKey(indexStr))\\n                        vowelDict[word.Length].Add(indexStr, new Dictionary<string, string>());\\n                    //using otherStr as 3rd level key\\n                    var otherStr = new string(others.ToArray()).ToUpper();\\n                    if(!vowelDict[word.Length][indexStr].ContainsKey(otherStr))\\n                        vowelDict[word.Length][indexStr].Add(otherStr,word);\\n                }\\n            }\\n            foreach(var query in queries)\\n            {\\n                if (dict.ContainsKey(query))\\n                {\\n                    ans.Add(dict[query]);\\n                }\\n                else if (dict.ContainsKey(query.ToUpper()))\\n                {\\n                    ans.Add(dict[query.ToUpper()]);\\n                }\\n                else\\n                {\\n                    List<int> list = new List<int>();\\n                    List<char> others = new List<char>();\\n                    for (int i = 0; i < query.Length; i++)\\n                    {\\n                        if (map.ContainsKey(query[i]))\\n                            list.Add(i);\\n                        else\\n                            others.Add(query[i]);\\n                    }\\n                    if (list.Count >0 && vowelDict.ContainsKey(query.Length))\\n                    {\\n                        var indexStr = string.Join(\"_\", list);\\n                        var otherStr = new string(others.ToArray()).ToUpper();\\n                        if (vowelDict[query.Length].ContainsKey(indexStr)\\n                            && vowelDict[query.Length][indexStr].ContainsKey(otherStr))\\n                        {\\n                            ans.Add(vowelDict[query.Length][indexStr][otherStr]);\\n                        }\\n                        else\\n                        {\\n                            ans.Add(string.Empty);\\n                        }\\n                    }\\n                    else\\n                    {\\n                        ans.Add(string.Empty);\\n                    }\\n                }\\n            }\\n            return ans.ToArray();\\n        }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1782208,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    //O(w + q) time | O(w + q) space\\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        Set<String> set = new HashSet<>();\\n        Map<String, String> caseMap = new HashMap<>();\\n        Map<String, String> vowMap = new HashMap<>();\\n        \\n        for(String word : wordlist) {\\n            set.add(word);\\n            caseMap.putIfAbsent(word.toLowerCase(), word);\\n            vowMap.putIfAbsent(vowel(word.toLowerCase()), word);\\n        }\\n    \\n        String[] result = new String[queries.length];\\n        int index=0;\\n        for(String query : queries) {\\n              String lowerCase = query.toLowerCase();\\n              String vowel = vowel(query.toLowerCase());\\n              if(set.contains(query)) {\\n                  result[index] = query;\\n              } else if(caseMap.containsKey(lowerCase)) {\\n                  result[index] = caseMap.get(lowerCase);\\n              } else if(vowMap.containsKey(vowel)) {\\n                  result[index] = vowMap.get(vowel);\\n              } else{\\n                  result[index] = \"\";\\n              }\\n              index++;\\n        }\\n        return result;     \\n    }\\n    \\n    \\n    private String vowel(String word) {\\n        StringBuilder sb = new StringBuilder();\\n        for(char ch : word.toCharArray()) {\\n            if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') {\\n                sb.append(\\'*\\');\\n            } else {\\n                sb.append(ch);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //O(w + q) time | O(w + q) space\\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        Set<String> set = new HashSet<>();\\n        Map<String, String> caseMap = new HashMap<>();\\n        Map<String, String> vowMap = new HashMap<>();\\n        \\n        for(String word : wordlist) {\\n            set.add(word);\\n            caseMap.putIfAbsent(word.toLowerCase(), word);\\n            vowMap.putIfAbsent(vowel(word.toLowerCase()), word);\\n        }\\n    \\n        String[] result = new String[queries.length];\\n        int index=0;\\n        for(String query : queries) {\\n              String lowerCase = query.toLowerCase();\\n              String vowel = vowel(query.toLowerCase());\\n              if(set.contains(query)) {\\n                  result[index] = query;\\n              } else if(caseMap.containsKey(lowerCase)) {\\n                  result[index] = caseMap.get(lowerCase);\\n              } else if(vowMap.containsKey(vowel)) {\\n                  result[index] = vowMap.get(vowel);\\n              } else{\\n                  result[index] = \"\";\\n              }\\n              index++;\\n        }\\n        return result;     \\n    }\\n    \\n    \\n    private String vowel(String word) {\\n        StringBuilder sb = new StringBuilder();\\n        for(char ch : word.toCharArray()) {\\n            if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') {\\n                sb.append(\\'*\\');\\n            } else {\\n                sb.append(ch);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594442,
                "title": "simple-python-solution-dictionaries-95-faster",
                "content": "```\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        main_list = set(wordlist)\\n        cap_dic = {}\\n        wild_card_dic = {}\\n        \\n        vowels = (\"a\", \"e\", \"i\", \"o\", \"u\")\\n        \\n        for i in wordlist:\\n            if i.upper() not in cap_dic:\\n                cap_dic[i.upper()] = i\\n                \\n        \\n        for i in wordlist:\\n            tmp = i.lower()\\n            for v in vowels:\\n                tmp = tmp.replace(v, \"*\")\\n                \\n            if tmp.upper() not in wild_card_dic:\\n                wild_card_dic[tmp.upper()] = i\\n                \\n                \\n        def replace_v(s):\\n            tmp = s.lower()\\n            for v in vowels:\\n                tmp = tmp.replace(v, \"*\")\\n            return tmp.upper()\\n                \\n        ans = []\\n        \\n        for q in queries:\\n            if q in main_list:\\n                ans.append(q)\\n            elif q.upper() in cap_dic:\\n                ans.append(cap_dic[q.upper()])\\n            elif replace_v(q) in wild_card_dic:\\n                ans.append(wild_card_dic[replace_v(q)])\\n            else:\\n                ans.append(\"\")\\n                \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        main_list = set(wordlist)\\n        cap_dic = {}\\n        wild_card_dic = {}\\n        \\n        vowels = (\"a\", \"e\", \"i\", \"o\", \"u\")\\n        \\n        for i in wordlist:\\n            if i.upper() not in cap_dic:\\n                cap_dic[i.upper()] = i\\n                \\n        \\n        for i in wordlist:\\n            tmp = i.lower()\\n            for v in vowels:\\n                tmp = tmp.replace(v, \"*\")\\n                \\n            if tmp.upper() not in wild_card_dic:\\n                wild_card_dic[tmp.upper()] = i\\n                \\n                \\n        def replace_v(s):\\n            tmp = s.lower()\\n            for v in vowels:\\n                tmp = tmp.replace(v, \"*\")\\n            return tmp.upper()\\n                \\n        ans = []\\n        \\n        for q in queries:\\n            if q in main_list:\\n                ans.append(q)\\n            elif q.upper() in cap_dic:\\n                ans.append(cap_dic[q.upper()])\\n            elif replace_v(q) in wild_card_dic:\\n                ans.append(wild_card_dic[replace_v(q)])\\n            else:\\n                ans.append(\"\")\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1572785,
                "title": "simple-python3-solution-using-two-dictionaries",
                "content": "```\\nimport re\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        d = {re.sub(\\'[aeiou]\\', \\'#\\', w.lower()): w for w in wordlist[::-1]}\\n        a = {w:w for w in wordlist}\\n        d.update({w.lower(): w for w in wordlist[::-1]})     \\n        out = []\\n        for q in queries:\\n            if q in a:\\n                out.append(q)\\n            elif q.lower() in d:\\n                out.append(d[q.lower()])\\n            else:\\n                out.append(d.get(re.sub(\\'[aeiou]\\', \\'#\\', q.lower()), \"\"))\\n        return out\\n    \\n      \\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nimport re\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        d = {re.sub(\\'[aeiou]\\', \\'#\\', w.lower()): w for w in wordlist[::-1]}\\n        a = {w:w for w in wordlist}\\n        d.update({w.lower(): w for w in wordlist[::-1]})     \\n        out = []\\n        for q in queries:\\n            if q in a:\\n                out.append(q)\\n            elif q.lower() in d:\\n                out.append(d[q.lower()])\\n            else:\\n                out.append(d.get(re.sub(\\'[aeiou]\\', \\'#\\', q.lower()), \"\"))\\n        return out\\n    \\n      \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1554207,
                "title": "golang-90-faster",
                "content": "```\\nvar v = map[byte]struct{}{\\n\\t97:  {},\\n\\t101: {},\\n\\t105: {},\\n\\t111: {},\\n\\t117: {},\\n}\\n\\nfunc spellchecker(w []string, q []string) []string {\\n\\two := make(map[string]int)\\n\\twl := make(map[string]int)\\n\\twd := make(map[string]int)\\n\\tvar cl = func(s string) string {\\n\\t\\tb := make([]byte, len(s))\\n\\t\\tfor i := range s {\\n\\t\\t\\tif _, ok := v[s[i]]; ok {\\n\\t\\t\\t\\tb[i] = 42\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tb[i] = s[i]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn *(*string)(unsafe.Pointer(&b))\\n\\t}\\n\\tfor i := range w {\\n\\t\\tif _, ok := wo[w[i]]; !ok {\\n\\t\\t\\two[w[i]] = i\\n\\t\\t}\\n\\t\\tl := strings.ToLower(w[i])\\n\\t\\tif _, ok := wl[l]; !ok {\\n\\t\\t\\twl[l] = i\\n\\t\\t}\\n\\t\\td := cl(strings.ToLower(w[i]))\\n\\t\\tif _, ok := wd[d]; !ok {\\n\\t\\t\\twd[d] = i\\n\\t\\t}\\n\\t}\\n\\tr := make([]string, len(q))\\n\\tfor i := range q {\\n\\t\\tif _, ok := wo[q[i]]; ok {\\n\\t\\t\\tr[i] = q[i]\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tl := strings.ToLower(q[i])\\n\\t\\tif j, ok := wl[l]; ok {\\n\\t\\t\\tr[i] = w[j]\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\td := cl(strings.ToLower(q[i]))\\n\\t\\tif j, ok := wd[d]; ok {\\n\\t\\t\\tr[i] = w[j]\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tr[i] = \"\"\\n\\t}\\n\\treturn r\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar v = map[byte]struct{}{\\n\\t97:  {},\\n\\t101: {},\\n\\t105: {},\\n\\t111: {},\\n\\t117: {},\\n}\\n\\nfunc spellchecker(w []string, q []string) []string {\\n\\two := make(map[string]int)\\n\\twl := make(map[string]int)\\n\\twd := make(map[string]int)\\n\\tvar cl = func(s string) string {\\n\\t\\tb := make([]byte, len(s))\\n\\t\\tfor i := range s {\\n\\t\\t\\tif _, ok := v[s[i]]; ok {\\n\\t\\t\\t\\tb[i] = 42\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tb[i] = s[i]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn *(*string)(unsafe.Pointer(&b))\\n\\t}\\n\\tfor i := range w {\\n\\t\\tif _, ok := wo[w[i]]; !ok {\\n\\t\\t\\two[w[i]] = i\\n\\t\\t}\\n\\t\\tl := strings.ToLower(w[i])\\n\\t\\tif _, ok := wl[l]; !ok {\\n\\t\\t\\twl[l] = i\\n\\t\\t}\\n\\t\\td := cl(strings.ToLower(w[i]))\\n\\t\\tif _, ok := wd[d]; !ok {\\n\\t\\t\\twd[d] = i\\n\\t\\t}\\n\\t}\\n\\tr := make([]string, len(q))\\n\\tfor i := range q {\\n\\t\\tif _, ok := wo[q[i]]; ok {\\n\\t\\t\\tr[i] = q[i]\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tl := strings.ToLower(q[i])\\n\\t\\tif j, ok := wl[l]; ok {\\n\\t\\t\\tr[i] = w[j]\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\td := cl(strings.ToLower(q[i]))\\n\\t\\tif j, ok := wd[d]; ok {\\n\\t\\t\\tr[i] = w[j]\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tr[i] = \"\"\\n\\t}\\n\\treturn r\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1444516,
                "title": "java-solution",
                "content": "\\tclass Solution {\\n    Set<Character> set = null;\\n    \\n    Solution()\\n    {\\n        set = new HashSet<>();\\n        set.add(\\'a\\');\\n        set.add(\\'e\\');\\n        set.add(\\'i\\');\\n        set.add(\\'o\\');\\n        set.add(\\'u\\');\\n    }\\n    \\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        Map<String,String> exactMatch = new HashMap<>();\\n        Map<String,List<String>> ciMatch = new HashMap<>();\\n        Map<String,List<String>> woVowelsMatch = new HashMap<>();\\n        \\n        for(String word : wordlist)\\n        {\\n            exactMatch.put(word,word);\\n            String lword = word.toLowerCase();\\n            ciMatch.putIfAbsent(lword, new LinkedList<>());\\n            ciMatch.get(lword).add(word);\\n            \\n            String wovWord = convert(word.toLowerCase());\\n            woVowelsMatch.putIfAbsent(wovWord, new LinkedList<>());\\n            woVowelsMatch.get(wovWord).add(word);\\n        }\\n        \\n        String[] result = new String[queries.length];\\n        for(int i = 0; i < queries.length; i++)\\n        {\\n            String correct = \"\";\\n            if(exactMatch.containsKey(queries[i]))\\n            {\\n                correct = exactMatch.get(queries[i]);\\n            }\\n            else if(ciMatch.containsKey(queries[i].toLowerCase()))\\n            {\\n                correct = ciMatch.get(queries[i].toLowerCase()).get(0);\\n            }\\n            else if(woVowelsMatch.containsKey(convert(queries[i].toLowerCase())))\\n            {\\n                correct = woVowelsMatch.get(convert(queries[i].toLowerCase())).get(0);\\n            }\\n            \\n            result[i] = correct;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    String convert(String word)\\n    {\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(char c : word.toCharArray())\\n        {\\n            if(set.contains(c))\\n            {\\n                sb.append(\\'*\\');\\n            }\\n            else\\n            {\\n                sb.append(c);\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n    Set<Character> set = null;\\n    \\n    Solution()\\n    {\\n        set = new HashSet<>();\\n        set.add(\\'a\\');\\n        set.add(\\'e\\');\\n        set.add(\\'i\\');\\n        set.add(\\'o\\');\\n        set.add(\\'u\\');\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1420676,
                "title": "dictionary-of-words-100-speed",
                "content": "![image](https://assets.leetcode.com/users/images/e3d4fd85-a9a4-438a-8546-9d3b4ac9388c_1629700688.4104102.png)\\n\\nMake original words lower, substitute a special character (e.g. `\"_\"` for vowels). This will be a key for the dictionary. For each key make a list of tuples `(word_lower, first_orinal_word)`. Search queries in the dictionary.\\n```\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        set_words = set(wordlist)\\n        dict_words = dict()\\n        for w in wordlist:\\n            w_lower = w.lower()\\n            w_key = (w_lower.replace(\"a\", \"_\").replace(\"e\", \"_\")\\n                     .replace(\"i\", \"_\").replace(\"o\", \"_\").replace(\"u\", \"_\"))\\n            if w_key in dict_words:\\n                for w_lower_, _ in dict_words[w_key]:\\n                    if w_lower == w_lower_:\\n                        break\\n                else:\\n                    dict_words[w_key].append((w_lower, w))\\n            else:\\n                dict_words[w_key] = [(w_lower, w)]\\n\\n        ans = [\"\"] * len(queries)\\n        for i, q in enumerate(queries):\\n            if q in set_words:\\n                ans[i] = q\\n                continue\\n            q_lower = q.lower()\\n            q_key = (q_lower.replace(\"a\", \"_\").replace(\"e\", \"_\")\\n                     .replace(\"i\", \"_\").replace(\"o\", \"_\").replace(\"u\", \"_\"))\\n            if q_key in dict_words:\\n                for w_lower_, first_word in dict_words[q_key]:\\n                    if q_lower == w_lower_:\\n                        ans[i] = first_word\\n                        break\\n                else:\\n                    ans[i] = dict_words[q_key][0][1]\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        set_words = set(wordlist)\\n        dict_words = dict()\\n        for w in wordlist:\\n            w_lower = w.lower()\\n            w_key = (w_lower.replace(\"a\", \"_\").replace(\"e\", \"_\")\\n                     .replace(\"i\", \"_\").replace(\"o\", \"_\").replace(\"u\", \"_\"))\\n            if w_key in dict_words:\\n                for w_lower_, _ in dict_words[w_key]:\\n                    if w_lower == w_lower_:\\n                        break\\n                else:\\n                    dict_words[w_key].append((w_lower, w))\\n            else:\\n                dict_words[w_key] = [(w_lower, w)]\\n\\n        ans = [\"\"] * len(queries)\\n        for i, q in enumerate(queries):\\n            if q in set_words:\\n                ans[i] = q\\n                continue\\n            q_lower = q.lower()\\n            q_key = (q_lower.replace(\"a\", \"_\").replace(\"e\", \"_\")\\n                     .replace(\"i\", \"_\").replace(\"o\", \"_\").replace(\"u\", \"_\"))\\n            if q_key in dict_words:\\n                for w_lower_, first_word in dict_words[q_key]:\\n                    if q_lower == w_lower_:\\n                        ans[i] = first_word\\n                        break\\n                else:\\n                    ans[i] = dict_words[q_key][0][1]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1408630,
                "title": "c-two-hash-map",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<string> spellchecker(vector<string>& wordlist, \\n                                vector<string>& queries) {\\n        \\n        vector<string> res;\\n       \\n        unordered_set<string> actualWords;\\n        unordered_map<string,map<int,string>> translatedWords;\\n        unordered_map<string,map<int,string>> vowelWords;\\n        \\n        int i=0;\\n        for (string& s : wordlist) {\\n            \\n            actualWords.insert(s);\\n            string cur = s;\\n            transform(cur.begin(), cur.end(), cur.begin(), [](unsigned char c) {\\n               return tolower(c); \\n            });\\n            \\n            translatedWords[cur][i] = s;\\n            \\n            \\n            string vCur = cur;\\n            transform(vCur.begin(), vCur.end(), vCur.begin(), [](char c) {\\n                \\n                if (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\') {\\n                    return \\'#\\';\\n                }\\n                \\n                return c;\\n            });\\n     \\n            vowelWords[vCur][i] = s;\\n            i++;\\n            \\n        }\\n    \\n        for (string& q : queries) {\\n                        \\n            string curQ = q;\\n            transform(curQ.begin(), curQ.end(), curQ.begin(), \\n                      [](unsigned char c) {\\n                return tolower(c); \\n            });\\n            \\n            string vCurQ = curQ;\\n            transform(vCurQ.begin(), vCurQ.end(), vCurQ.begin(), [](char c) {\\n                if (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\') {\\n                    return \\'#\\';\\n                }\\n                \\n                return c;\\n            });\\n            \\n            \\n            if (actualWords.find(q) != actualWords.end()) {\\n                res.push_back(q);\\n                continue;\\n            }\\n            \\n            if (translatedWords.find(curQ) != translatedWords.end()) {\\n                res.push_back(translatedWords[curQ].begin()->second);\\n                continue;\\n            }\\n            \\n            if (vowelWords.find(vCurQ) != vowelWords.end()) {\\n                res.push_back(vowelWords[vCurQ].begin()->second);\\n                continue;\\n            }\\n            \\n            res.push_back(\"\");\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<string> spellchecker(vector<string>& wordlist, \\n                                vector<string>& queries) {\\n        \\n        vector<string> res;\\n       \\n        unordered_set<string> actualWords;\\n        unordered_map<string,map<int,string>> translatedWords;\\n        unordered_map<string,map<int,string>> vowelWords;\\n        \\n        int i=0;\\n        for (string& s : wordlist) {\\n            \\n            actualWords.insert(s);\\n            string cur = s;\\n            transform(cur.begin(), cur.end(), cur.begin(), [](unsigned char c) {\\n               return tolower(c); \\n            });\\n            \\n            translatedWords[cur][i] = s;\\n            \\n            \\n            string vCur = cur;\\n            transform(vCur.begin(), vCur.end(), vCur.begin(), [](char c) {\\n                \\n                if (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\') {\\n                    return \\'#\\';\\n                }\\n                \\n                return c;\\n            });\\n     \\n            vowelWords[vCur][i] = s;\\n            i++;\\n            \\n        }\\n    \\n        for (string& q : queries) {\\n                        \\n            string curQ = q;\\n            transform(curQ.begin(), curQ.end(), curQ.begin(), \\n                      [](unsigned char c) {\\n                return tolower(c); \\n            });\\n            \\n            string vCurQ = curQ;\\n            transform(vCurQ.begin(), vCurQ.end(), vCurQ.begin(), [](char c) {\\n                if (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\') {\\n                    return \\'#\\';\\n                }\\n                \\n                return c;\\n            });\\n            \\n            \\n            if (actualWords.find(q) != actualWords.end()) {\\n                res.push_back(q);\\n                continue;\\n            }\\n            \\n            if (translatedWords.find(curQ) != translatedWords.end()) {\\n                res.push_back(translatedWords[curQ].begin()->second);\\n                continue;\\n            }\\n            \\n            if (vowelWords.find(vCurQ) != vowelWords.end()) {\\n                res.push_back(vowelWords[vCurQ].begin()->second);\\n                continue;\\n            }\\n            \\n            res.push_back(\"\");\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1377596,
                "title": "966-return-matched-word-same-ignore-cased-one-vowels-replaced-one-or-empty-string",
                "content": "---\\n\\nA bit confusing in the intial read again, similar to below:\\n- Q - https://leetcode.com/problems/determine-if-two-strings-are-close/\\n- A - https://leetcode.com/problems/determine-if-two-strings-are-close/discuss/1376841/1657-same-chars-must-exist-then-just-the-counts-must-be-same\\n\\n---\\n\\n**Algo**\\n- if query word already exists in the given word list, return it\\n- if query word (ignore case) exists in the given word list, return 1st (ignore case) word from word list\\n- if query word (vowels replaced with others) exists in the given word list, return 1st (vowels replaced with others) word from word list\\n  - Replaced with other vowels is done by replacing all vowels with *\\n- else return empty string\\n\\nHope it is simple to understand.\\n\\n---\\n\\n```\\nconst getStaredWord = (w) => w.replace(/[aeiou]/gi, \"*\").toLowerCase();\\n\\nvar spellchecker = function (wordlist, queries) {\\n    let w, w2, w3;\\n    const iToOriMap = new Map(); // ignoreCase To Original Map\\n    const sToOriMap = new Map(); // stared To Original Map\\n    for (w of wordlist) {\\n        w2 = w.toLowerCase();\\n        !iToOriMap.has(w2) && iToOriMap.set(w2, w); // add if not exist\\n        w3 = getStaredWord(w);\\n        !sToOriMap.has(w3) && sToOriMap.set(w3, w);\\n    }\\n\\n    const oriSet = new Set(wordlist); // original Set\\n    return queries.map((q) => {\\n        return oriSet.has(q)\\n            ? q\\n            : iToOriMap.get(q.toLowerCase()) || //\\n                  sToOriMap.get(getStaredWord(q)) ||\\n                  \"\";\\n    });\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/fc7f1530-6f08-4221-8bec-8c96263ff73b_1627867045.3442776.png)\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst getStaredWord = (w) => w.replace(/[aeiou]/gi, \"*\").toLowerCase();\\n\\nvar spellchecker = function (wordlist, queries) {\\n    let w, w2, w3;\\n    const iToOriMap = new Map(); // ignoreCase To Original Map\\n    const sToOriMap = new Map(); // stared To Original Map\\n    for (w of wordlist) {\\n        w2 = w.toLowerCase();\\n        !iToOriMap.has(w2) && iToOriMap.set(w2, w); // add if not exist\\n        w3 = getStaredWord(w);\\n        !sToOriMap.has(w3) && sToOriMap.set(w3, w);\\n    }\\n\\n    const oriSet = new Set(wordlist); // original Set\\n    return queries.map((q) => {\\n        return oriSet.has(q)\\n            ? q\\n            : iToOriMap.get(q.toLowerCase()) || //\\n                  sToOriMap.get(getStaredWord(q)) ||\\n                  \"\";\\n    });\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1374590,
                "title": "cpp-easiest-solution",
                "content": "class Solution {\\npublic:\\n    bool isVowel(char ch)\\n    {\\n        \\n        if(ch==\\'a\\'||ch==\\'e\\'||ch==\\'i\\'||ch==\\'o\\'||ch==\\'u\\'||ch==\\'A\\'||ch==\\'E\\'||ch==\\'I\\'||ch==\\'O\\'||ch==\\'U\\'){\\n            return true;\\n        }\\n        \\n        else{\\n            return false;\\n        }\\n    }\\n    \\n    \\n    string result(string s){\\n        \\n        string res=\"\";\\n        for(int i=0;i<s.length();i++){\\n            if(isVowel(s[i])){\\n                res+=\"*\";\\n            }\\n            else{\\n                res+=s[i];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    \\n    string tolower(string s){\\n        string res=\"\";\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]>=\\'A\\' && s[i]<=\\'Z\\'){\\n                res+=(s[i]+32);\\n            }\\n            \\n            else{\\n                res+=s[i];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        \\n        set<string>exact;\\n        \\n        map<string,string>capitalization;\\n        \\n        map<string,string>consonant;\\n        \\n        for(int i=0;i<wordlist.size();i++){\\n            \\n            string str=wordlist[i];\\n            \\n            \\n            exact.insert(str);\\n            \\n            string cap=tolower(str);\\n            \\n            capitalization.insert({cap,str});\\n            \\n            string cons=result(cap);\\n            \\n            consonant.insert({cons,str});\\n            \\n        }\\n        \\n        vector<string>ans;\\n        \\n        for(int i=0;i<queries.size();i++){\\n             string str=queries[i];\\n             string cap=tolower(str);\\n             string cons=result(cap);\\n\\n            if(exact.find(str)!=exact.end()){\\n                ans.push_back(str);\\n            }\\n            \\n            //string cap=tolower(str);\\n            \\n            else if(capitalization.find(cap)!=capitalization.end()){\\n                ans.push_back(capitalization[cap]);\\n            }\\n            \\n            //string cons=result(cap);\\n            \\n            else if(consonant.find(cons)!=consonant.end()){\\n                ans.push_back(consonant[cons]);\\n            }\\n            \\n            else{\\n                ans.push_back(\"\");\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isVowel(char ch)\\n    {\\n        \\n        if(ch==\\'a\\'||ch==\\'e\\'||ch==\\'i\\'||ch==\\'o\\'||ch==\\'u\\'||ch==\\'A\\'||ch==\\'E\\'||ch==\\'I\\'||ch==\\'O\\'||ch==\\'U\\'){\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1361710,
                "title": "java-hashmaps",
                "content": "\\n```\\nclass Solution {\\n\\n    public String[] spellchecker(String[] words, String[] queries) {\\n        Map<String, Integer> strictMap = new HashMap<>();\\n        Map<String, Integer> capMap = new HashMap<>();\\n        Map<String, Integer> vowelMap = new HashMap<>();\\n        for (int i = 0; i < words.length; i++) {\\n            final String word = words[i];\\n            if (!strictMap.containsKey(word)) strictMap.put(word, i);\\n            if (!capMap.containsKey(getCap(word))) capMap.put(getCap(word), i);\\n            if (!vowelMap.containsKey(deVowel(word))) vowelMap.put(deVowel(word), i);\\n        }\\n        String[] res = new String[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            final String query = queries[i];\\n            int index = -1;\\n            if(strictMap.containsKey(query)) index = strictMap.get(query);\\n            else if(capMap.containsKey(getCap(query))) index = capMap.get(getCap(query));\\n            else if(vowelMap.containsKey(deVowel(query))) index = vowelMap.get(deVowel(query));\\n            res[i]  = index >= 0 ? words[index]: \"\";\\n        }\\n        return res;\\n    }\\n\\n    private String deVowel(String word) {\\n        return word.toLowerCase().replaceAll(\"[aeiou]\", \"a\");\\n    }\\n\\n    private String getCap(String word) {\\n        return Character.toUpperCase(word.charAt(0)) + word.substring(1).toLowerCase();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public String[] spellchecker(String[] words, String[] queries) {\\n        Map<String, Integer> strictMap = new HashMap<>();\\n        Map<String, Integer> capMap = new HashMap<>();\\n        Map<String, Integer> vowelMap = new HashMap<>();\\n        for (int i = 0; i < words.length; i++) {\\n            final String word = words[i];\\n            if (!strictMap.containsKey(word)) strictMap.put(word, i);\\n            if (!capMap.containsKey(getCap(word))) capMap.put(getCap(word), i);\\n            if (!vowelMap.containsKey(deVowel(word))) vowelMap.put(deVowel(word), i);\\n        }\\n        String[] res = new String[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            final String query = queries[i];\\n            int index = -1;\\n            if(strictMap.containsKey(query)) index = strictMap.get(query);\\n            else if(capMap.containsKey(getCap(query))) index = capMap.get(getCap(query));\\n            else if(vowelMap.containsKey(deVowel(query))) index = vowelMap.get(deVowel(query));\\n            res[i]  = index >= 0 ? words[index]: \"\";\\n        }\\n        return res;\\n    }\\n\\n    private String deVowel(String word) {\\n        return word.toLowerCase().replaceAll(\"[aeiou]\", \"a\");\\n    }\\n\\n    private String getCap(String word) {\\n        return Character.toUpperCase(word.charAt(0)) + word.substring(1).toLowerCase();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1310810,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) \\n     {\\n          unordered_map<string,bool>mached;\\n          unordered_map<string,string>first;\\n          unordered_map<string,string>vowel;\\n          for(int i=0;i<wordlist.size();i++)\\n          {\\n              mached[wordlist[i]]=true;\\n              string serial=\"\",lower=\"\";\\n              string put=wordlist[i];\\n              for(int j=0;j<wordlist[i].size();j++)\\n              {\\n                  if(wordlist[i][j]>=\\'A\\'&&wordlist[i][j]<=\\'Z\\')wordlist[i][j]=char(int(wordlist[i][j])-65+97);\\n                  lower+=wordlist[i][j];\\n                  if(wordlist[i][j]==\\'a\\'||wordlist[i][j]==\\'e\\'||wordlist[i][j]==\\'i\\'||wordlist[i][j]==\\'o\\'||wordlist[i][j]==\\'u\\')wordlist[i][j]=\\'*\\';\\n                  serial+=wordlist[i][j];\\n              }\\n             if(vowel.find(serial)==vowel.end())vowel[serial]=put;\\n             if(first.find(lower)==first.end())first[lower]=put;\\n          }\\n          vector<string>Ans;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            string temp=\"\";\\n            if(mached.find(queries[i])!=mached.end()){Ans.push_back(queries[i]);continue;}\\n              string serial=\"\",lower=\"\";\\n              for(int j=0;j<queries[i].size();j++)\\n              {\\n                  if(queries[i][j]>=\\'A\\'&&queries[i][j]<=\\'Z\\')queries[i][j]=char(int(queries[i][j])-65+97);\\n                  lower+=queries[i][j];\\n                  if(queries[i][j]==\\'a\\'||queries[i][j]==\\'e\\'||queries[i][j]==\\'i\\'||queries[i][j]==\\'o\\'||queries[i][j]==\\'u\\')queries[i][j]=\\'*\\';\\n                  serial+=queries[i][j];\\n              }\\n            if(first.find(lower)!=first.end()){Ans.push_back(first[lower]);continue;}\\n            if(vowel.find(serial)!=vowel.end()){Ans.push_back(vowel[serial]);continue;}\\n            Ans.push_back(\"\");\\n            \\n            \\n            \\n        }\\n        return Ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) \\n     {\\n          unordered_map<string,bool>mached;\\n          unordered_map<string,string>first;\\n          unordered_map<string,string>vowel;\\n          for(int i=0;i<wordlist.size();i++)\\n          {\\n              mached[wordlist[i]]=true;\\n              string serial=\"\",lower=\"\";\\n              string put=wordlist[i];\\n              for(int j=0;j<wordlist[i].size();j++)\\n              {\\n                  if(wordlist[i][j]>=\\'A\\'&&wordlist[i][j]<=\\'Z\\')wordlist[i][j]=char(int(wordlist[i][j])-65+97);\\n                  lower+=wordlist[i][j];\\n                  if(wordlist[i][j]==\\'a\\'||wordlist[i][j]==\\'e\\'||wordlist[i][j]==\\'i\\'||wordlist[i][j]==\\'o\\'||wordlist[i][j]==\\'u\\')wordlist[i][j]=\\'*\\';\\n                  serial+=wordlist[i][j];\\n              }\\n             if(vowel.find(serial)==vowel.end())vowel[serial]=put;\\n             if(first.find(lower)==first.end())first[lower]=put;\\n          }\\n          vector<string>Ans;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            string temp=\"\";\\n            if(mached.find(queries[i])!=mached.end()){Ans.push_back(queries[i]);continue;}\\n              string serial=\"\",lower=\"\";\\n              for(int j=0;j<queries[i].size();j++)\\n              {\\n                  if(queries[i][j]>=\\'A\\'&&queries[i][j]<=\\'Z\\')queries[i][j]=char(int(queries[i][j])-65+97);\\n                  lower+=queries[i][j];\\n                  if(queries[i][j]==\\'a\\'||queries[i][j]==\\'e\\'||queries[i][j]==\\'i\\'||queries[i][j]==\\'o\\'||queries[i][j]==\\'u\\')queries[i][j]=\\'*\\';\\n                  serial+=queries[i][j];\\n              }\\n            if(first.find(lower)!=first.end()){Ans.push_back(first[lower]);continue;}\\n            if(vowel.find(serial)!=vowel.end()){Ans.push_back(vowel[serial]);continue;}\\n            Ans.push_back(\"\");\\n            \\n            \\n            \\n        }\\n        return Ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1169079,
                "title": "straightforward-java-solution",
                "content": "class Solution {\\n\\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n       \\n        HashMap<String, String> map1 = new HashMap<>();\\n\\t\\tHashMap<String, String> map2 = new HashMap<>();\\n        HashSet<String> set = new HashSet<>();\\n\\n\\t\\tfor (String str : wordlist) {\\n\\t\\t\\tString temp2 = str;\\n\\t\\t\\tString temp = str;\\n\\t\\t\\tstr = str.toLowerCase();\\n            str = str.replaceAll(\"[aeiou]\", \"?\");\\n\\t\\t\\ttemp = temp.toLowerCase();\\n\\t\\t\\t\\n\\t\\t\\tif (!map1.containsKey(str))\\n\\t\\t\\t\\tmap1.put(str, temp2);\\n\\t\\t\\tif (!map2.containsKey(temp))\\n\\t\\t\\t\\tmap2.put(temp, temp2);\\n            set.add(temp2);\\n\\t\\t}\\n\\n\\t\\tint n = queries.length;\\n\\t\\tString[] ans = new String[n];\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tString q1 = queries[i];\\n\\t\\t\\tString q2 = new String(queries[i]);\\n            q1 = q1.toLowerCase();\\n\\t\\t\\tq1 = q1.replaceAll(\"[aeiou]\", \"?\");\\n\\t\\t\\tq2 = q2.toLowerCase();\\n\\t\\t\\t\\n            if(set.contains(queries[i])) ans[i] = queries[i];\\n            else if (map2.containsKey(q2))\\n\\t\\t\\t\\tans[i] = map2.get(q2);\\n\\t\\t\\telse if (map1.containsKey(q1))\\n\\t\\t\\t\\tans[i] = map1.get(q1);\\n\\t\\t\\telse\\n\\t\\t\\t\\tans[i] = \"\";\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n       \\n        HashMap<String, String> map1 = new HashMap<>();\\n\\t\\tHashMap<String, String> map2 = new HashMap<>();\\n        HashSet<String> set = new HashSet<>();\\n\\n\\t\\tfor (String str : wordlist) {\\n\\t\\t\\tString temp2 = str;\\n\\t\\t\\tString temp = str;\\n\\t\\t\\tstr = str.toLowerCase();\\n            str = str.replaceAll(\"[aeiou]\", \"?\");\\n\\t\\t\\ttemp = temp.toLowerCase();\\n\\t\\t\\t\\n\\t\\t\\tif (!map1.containsKey(str))\\n\\t\\t\\t\\tmap1.put(str, temp2);\\n\\t\\t\\tif (!map2.containsKey(temp))\\n\\t\\t\\t\\tmap2.put(temp, temp2);\\n            set.add(temp2);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1133748,
                "title": "js-solution",
                "content": "```\\n/**\\n * @param {string[]} wordlist\\n * @param {string[]} queries\\n * @return {string[]}\\n */\\nvar spellchecker = function(wordList, queries) {\\n    // lower case => first word\\n    const caseMap = new Map()\\n    // formatted by removing vowels  => first word\\n    const consonantMap = new Map()\\n    const wordSet = new Set(wordList)\\n    \\n    function consonantFormat(word) {\\n        const reg = /[aeiou]+/gi\\n        word = word.replace(reg, function(text) {\\n            const textLen = text.length\\n            return textLen\\n        })\\n        \\n        return word\\n    }\\n    \\n    \\n    // build both maps\\n    for (const word of wordList.values())  {\\n        const caseWord = word.toLowerCase()\\n        if (!caseMap.has(caseWord)) {\\n            caseMap.set(caseWord, word)\\n        }\\n        \\n        const consonantWord = consonantFormat(caseWord)\\n        if (!consonantMap.has(consonantWord)) {\\n            consonantMap.set(consonantWord, word)\\n        }\\n    }\\n    \\n    \\n    let result = queries.map(word => {\\n        if (wordSet.has(word))\\n            return word\\n    \\n        const caseWord = word.toLowerCase()\\n        if (caseMap.has(caseWord))  return caseMap.get(caseWord)\\n        \\n        const consonantWord = consonantFormat(caseWord)\\n        if (consonantMap.has(consonantWord)) \\n            return consonantMap.get(consonantWord)\\n            \\n        return \\'\\'\\n    })\\n    \\n    \\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string[]} wordlist\\n * @param {string[]} queries\\n * @return {string[]}\\n */\\nvar spellchecker = function(wordList, queries) {\\n    // lower case => first word\\n    const caseMap = new Map()\\n    // formatted by removing vowels  => first word\\n    const consonantMap = new Map()\\n    const wordSet = new Set(wordList)\\n    \\n    function consonantFormat(word) {\\n        const reg = /[aeiou]+/gi\\n        word = word.replace(reg, function(text) {\\n            const textLen = text.length\\n            return textLen\\n        })\\n        \\n        return word\\n    }\\n    \\n    \\n    // build both maps\\n    for (const word of wordList.values())  {\\n        const caseWord = word.toLowerCase()\\n        if (!caseMap.has(caseWord)) {\\n            caseMap.set(caseWord, word)\\n        }\\n        \\n        const consonantWord = consonantFormat(caseWord)\\n        if (!consonantMap.has(consonantWord)) {\\n            consonantMap.set(consonantWord, word)\\n        }\\n    }\\n    \\n    \\n    let result = queries.map(word => {\\n        if (wordSet.has(word))\\n            return word\\n    \\n        const caseWord = word.toLowerCase()\\n        if (caseMap.has(caseWord))  return caseMap.get(caseWord)\\n        \\n        const consonantWord = consonantFormat(caseWord)\\n        if (consonantMap.has(consonantWord)) \\n            return consonantMap.get(consonantWord)\\n            \\n        return \\'\\'\\n    })\\n    \\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1133483,
                "title": "swift-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    let vowels: [Character] = [\"a\", \"e\", \"i\", \"o\", \"u\"]\\n    \\n    func spellchecker(_ wordlist: [String], _ queries: [String]) -> [String] {\\n        let exact = Set(wordlist)\\n        var cap = [String: String]() // key for lowercase, value for orginal value\\n        var mistake = [String: String]() // key for lowercase with *, value for original\\n        \\n        for word in wordlist {\\n            let lower = word.lowercased()\\n            if cap[lower] == nil { // trick is avoid override\\n                cap[lower] = word\\n            }\\n            \\n            let k = replace(word)\\n            if mistake[k] == nil {\\n                mistake[k] = word\\n            }\\n        }\\n        \\n        let ans = queries.map { (q) -> String in\\n            if exact.contains(q) {\\n                return q\\n            } else if let capital = cap[q.lowercased()] {\\n                return capital\\n            } else if let m = mistake[replace(q)] {\\n                return m\\n            } else {\\n                return \"\"\\n            }\\n        }\\n        return ans\\n    }\\n    \\n    private func replace(_ word: String) -> String {\\n        let w = word.lowercased()\\n        \\n        let arr: [Character] = Array(w).map { (c) -> Character in\\n            if vowels.contains(c) {\\n                return \"*\"\\n            } else {\\n                return c\\n            }\\n        }\\n        return String(arr)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    let vowels: [Character] = [\"a\", \"e\", \"i\", \"o\", \"u\"]\\n    \\n    func spellchecker(_ wordlist: [String], _ queries: [String]) -> [String] {\\n        let exact = Set(wordlist)\\n        var cap = [String: String]() // key for lowercase, value for orginal value\\n        var mistake = [String: String]() // key for lowercase with *, value for original\\n        \\n        for word in wordlist {\\n            let lower = word.lowercased()\\n            if cap[lower] == nil { // trick is avoid override\\n                cap[lower] = word\\n            }\\n            \\n            let k = replace(word)\\n            if mistake[k] == nil {\\n                mistake[k] = word\\n            }\\n        }\\n        \\n        let ans = queries.map { (q) -> String in\\n            if exact.contains(q) {\\n                return q\\n            } else if let capital = cap[q.lowercased()] {\\n                return capital\\n            } else if let m = mistake[replace(q)] {\\n                return m\\n            } else {\\n                return \"\"\\n            }\\n        }\\n        return ans\\n    }\\n    \\n    private func replace(_ word: String) -> String {\\n        let w = word.lowercased()\\n        \\n        let arr: [Character] = Array(w).map { (c) -> Character in\\n            if vowels.contains(c) {\\n                return \"*\"\\n            } else {\\n                return c\\n            }\\n        }\\n        return String(arr)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1132749,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        l=len(queries)\\n        lk=len(wordlist)\\n        l1=[]\\n        lw=[]\\n        l3=[\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\']\\n        l4=[]\\n        for e in range(lk):\\n            l6=len(wordlist[e])\\n            s9=\"\"\\n            for c in range(l6):\\n                if(wordlist[e][c].lower() not in l3):\\n                    s9=s9+wordlist[e][c].lower()\\n                else:\\n                    s9=s9+\\'@\\'\\n            l4.append(s9)   \\n        for k in wordlist:\\n            lw.append(k.lower())\\n        for i in range(l):\\n            if(queries[i] in wordlist):\\n                l1.append(queries[i])\\n            elif(queries[i].lower() in lw):\\n                for t in range(lk):\\n                    if(queries[i].lower()==lw[t]):\\n                        l1.append(wordlist[t])\\n                        break\\n            else:\\n                s19=\"\"\\n                l2=len(queries[i])\\n                for g in range(l2):\\n                    if(queries[i][g].lower() not in l3):\\n                        s19=s19+queries[i][g].lower()\\n                    else:\\n                        s19=s19+\\'@\\'\\n                for t1 in range(lk):\\n                    if(s19==l4[t1]):\\n                        l1.append(wordlist[t1])\\n                        break\\n                else:\\n                    l1.append(\"\")\\n        return l1\\n                    \\n                    \\n                    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        l=len(queries)\\n        lk=len(wordlist)\\n        l1=[]\\n        lw=[]\\n        l3=[\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\']\\n        l4=[]\\n        for e in range(lk):\\n            l6=len(wordlist[e])\\n            s9=\"\"\\n            for c in range(l6):\\n                if(wordlist[e][c].lower() not in l3):\\n                    s9=s9+wordlist[e][c].lower()\\n                else:\\n                    s9=s9+\\'@\\'\\n            l4.append(s9)   \\n        for k in wordlist:\\n            lw.append(k.lower())\\n        for i in range(l):\\n            if(queries[i] in wordlist):\\n                l1.append(queries[i])\\n            elif(queries[i].lower() in lw):\\n                for t in range(lk):\\n                    if(queries[i].lower()==lw[t]):\\n                        l1.append(wordlist[t])\\n                        break\\n            else:\\n                s19=\"\"\\n                l2=len(queries[i])\\n                for g in range(l2):\\n                    if(queries[i][g].lower() not in l3):\\n                        s19=s19+queries[i][g].lower()\\n                    else:\\n                        s19=s19+\\'@\\'\\n                for t1 in range(lk):\\n                    if(s19==l4[t1]):\\n                        l1.append(wordlist[t1])\\n                        break\\n                else:\\n                    l1.append(\"\")\\n        return l1\\n                    \\n                    \\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1124459,
                "title": "go",
                "content": "```\\nvar vows = []byte{\\'a\\', \\'i\\', \\'u\\', \\'e\\', \\'o\\'}\\nfunc spellchecker(wordlist []string, queries []string) []string {\\n    set := make(map[string]struct{})\\n    capital := make(map[string]string)\\n    vowel := make(map[string]string)\\n    \\n    for _, w := range wordlist {\\n        set[w] = struct{}{}\\n        if _, ok := capital[strings.ToLower(w)]; !ok {\\n            capital[strings.ToLower(w)] = w\\n        }\\n        if _, ok := vowel[wild(w)]; !ok {\\n            vowel[wild(w)] = w\\n        }\\n    }\\n    \\n    var res []string\\n    for _, q := range queries {\\n        if _, ok := set[q]; ok {\\n            res = append(res, q)\\n            continue\\n        }\\n        if _, ok := capital[strings.ToLower(q)]; ok {\\n            res = append(res, capital[strings.ToLower(q)])\\n            continue\\n        }\\n        if _, ok := vowel[wild(q)]; ok {\\n            res = append(res, vowel[wild(q)])\\n            continue\\n        }\\n        res = append(res, \"\")\\n    }\\n    return res\\n}\\n\\nfunc wild(w string) string {\\n    temp := []byte(strings.ToLower(w))  \\n    var res []byte\\n    for _, v := range temp {\\n        if isVow(v) {\\n            res = append(res, \\'*\\')\\n        } else {\\n            res = append(res, v)\\n        }\\n    }\\n    return string(res)\\n}\\n\\nfunc isVow(b byte) bool {\\n    if b == \\'a\\' || b == \\'i\\' || b == \\'u\\' || b == \\'e\\' || b == \\'o\\' {\\n        return true\\n    }\\n    return false\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar vows = []byte{\\'a\\', \\'i\\', \\'u\\', \\'e\\', \\'o\\'}\\nfunc spellchecker(wordlist []string, queries []string) []string {\\n    set := make(map[string]struct{})\\n    capital := make(map[string]string)\\n    vowel := make(map[string]string)\\n    \\n    for _, w := range wordlist {\\n        set[w] = struct{}{}\\n        if _, ok := capital[strings.ToLower(w)]; !ok {\\n            capital[strings.ToLower(w)] = w\\n        }\\n        if _, ok := vowel[wild(w)]; !ok {\\n            vowel[wild(w)] = w\\n        }\\n    }\\n    \\n    var res []string\\n    for _, q := range queries {\\n        if _, ok := set[q]; ok {\\n            res = append(res, q)\\n            continue\\n        }\\n        if _, ok := capital[strings.ToLower(q)]; ok {\\n            res = append(res, capital[strings.ToLower(q)])\\n            continue\\n        }\\n        if _, ok := vowel[wild(q)]; ok {\\n            res = append(res, vowel[wild(q)])\\n            continue\\n        }\\n        res = append(res, \"\")\\n    }\\n    return res\\n}\\n\\nfunc wild(w string) string {\\n    temp := []byte(strings.ToLower(w))  \\n    var res []byte\\n    for _, v := range temp {\\n        if isVow(v) {\\n            res = append(res, \\'*\\')\\n        } else {\\n            res = append(res, v)\\n        }\\n    }\\n    return string(res)\\n}\\n\\nfunc isVow(b byte) bool {\\n    if b == \\'a\\' || b == \\'i\\' || b == \\'u\\' || b == \\'e\\' || b == \\'o\\' {\\n        return true\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1124378,
                "title": "java-clean-concise-code-easy-to-understand-100-beats-faster-solution",
                "content": "```\\nclass Solution {\\n    \\n    Set<String> matched;\\n    Map<String, String> capitalizations;\\n    Map<String, String> vowelErrors;\\n    \\n    private boolean isVowel (char w) {\\n        \\n        return w == \\'a\\' || w == \\'e\\' || w == \\'i\\' || w == \\'o\\' || w == \\'u\\';\\n    }\\n    \\n    private String removeVowels (String word) {\\n        \\n        StringBuilder s = new StringBuilder ();\\n        \\n        for (char w : word.toCharArray ()) {\\n            s.append (isVowel (w) ? \\'*\\' : w);\\n        }\\n        \\n        return s.toString ();\\n    }\\n    \\n    private String solveQuery (String query) {\\n        \\n        if (matched.contains (query)) {\\n            return query;\\n        }\\n        \\n        String word = query.toLowerCase ();\\n        if (capitalizations.containsKey (word)) {\\n            return capitalizations.get (word);\\n        }\\n        \\n        word = removeVowels (word);\\n        if (vowelErrors.containsKey (word)) {\\n            return vowelErrors.get (word);\\n        }\\n        \\n        return \"\";\\n    }\\n    \\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        \\n        String[] answer = new String[queries.length];\\n        matched = new HashSet <>();\\n        capitalizations = new HashMap <>();\\n        vowelErrors = new HashMap <>();\\n        \\n        for (String word : wordlist) {\\n            matched.add (word);\\n            \\n            String s = word.toLowerCase ();\\n            if (!capitalizations.containsKey (s)) {\\n                capitalizations.put (s, word);\\n            }\\n            \\n            s = removeVowels (s);\\n            if (!vowelErrors.containsKey (s)) {\\n                vowelErrors.put (s, word);\\n            }\\n        }\\n        \\n        for (int i = 0; i < queries.length; i++) {\\n            answer[i] = solveQuery (queries[i]);\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    Set<String> matched;\\n    Map<String, String> capitalizations;\\n    Map<String, String> vowelErrors;\\n    \\n    private boolean isVowel (char w) {\\n        \\n        return w == \\'a\\' || w == \\'e\\' || w == \\'i\\' || w == \\'o\\' || w == \\'u\\';\\n    }\\n    \\n    private String removeVowels (String word) {\\n        \\n        StringBuilder s = new StringBuilder ();\\n        \\n        for (char w : word.toCharArray ()) {\\n            s.append (isVowel (w) ? \\'*\\' : w);\\n        }\\n        \\n        return s.toString ();\\n    }\\n    \\n    private String solveQuery (String query) {\\n        \\n        if (matched.contains (query)) {\\n            return query;\\n        }\\n        \\n        String word = query.toLowerCase ();\\n        if (capitalizations.containsKey (word)) {\\n            return capitalizations.get (word);\\n        }\\n        \\n        word = removeVowels (word);\\n        if (vowelErrors.containsKey (word)) {\\n            return vowelErrors.get (word);\\n        }\\n        \\n        return \"\";\\n    }\\n    \\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        \\n        String[] answer = new String[queries.length];\\n        matched = new HashSet <>();\\n        capitalizations = new HashMap <>();\\n        vowelErrors = new HashMap <>();\\n        \\n        for (String word : wordlist) {\\n            matched.add (word);\\n            \\n            String s = word.toLowerCase ();\\n            if (!capitalizations.containsKey (s)) {\\n                capitalizations.put (s, word);\\n            }\\n            \\n            s = removeVowels (s);\\n            if (!vowelErrors.containsKey (s)) {\\n                vowelErrors.put (s, word);\\n            }\\n        }\\n        \\n        for (int i = 0; i < queries.length; i++) {\\n            answer[i] = solveQuery (queries[i]);\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1124333,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    unordered_set<string> perfectWords;\\n    unordered_map<string, string> wordsCap;\\n    unordered_map<string, string> wordsVow;\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        for(string &word: wordlist){\\n            perfectWords.insert(word);\\n            \\n            string lowerCasedWord   = lowercase(word);\\n            wordsCap.insert({lowerCasedWord, word});\\n            \\n            string lowerCasedWordDV = devowel(lowerCasedWord);\\n            wordsVow.insert({lowerCasedWordDV, word});\\n        }\\n        \\n        vector<string> result;\\n        for(string &query : queries)\\n            result.push_back(solve(query));\\n        \\n        return result;\\n    }\\n    \\n    string solve(string query){\\n        if(perfectWords.find(query) != perfectWords.end())\\n            return query;\\n        \\n        string queryLower = lowercase(query);\\n        if(wordsCap.find(queryLower) != wordsCap.end())\\n            return wordsCap.at(queryLower);\\n        \\n        string queryLowerDV = devowel(queryLower);\\n        if(wordsVow.find(queryLowerDV) != wordsVow.end())\\n            return wordsVow.at(queryLowerDV);\\n        \\n        return \"\";\\n    }\\n    \\n    string lowercase(string word){\\n        string lowercased = word;\\n        for(char &val : lowercased)\\n            val = tolower(val);\\n        \\n        return lowercased;\\n    }\\n    \\n    string devowel(string word){\\n        string devoweled;\\n        for(char &val : word)\\n            devoweled.push_back(isVowel(val) ? \\'*\\' : val);\\n        \\n        return devoweled;\\n    }\\n    \\n    bool isVowel(char val){\\n        return (val == \\'a\\' || val == \\'e\\' || val == \\'i\\' || val == \\'o\\' || val == \\'u\\');\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    unordered_set<string> perfectWords;\\n    unordered_map<string, string> wordsCap;\\n    unordered_map<string, string> wordsVow;\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        for(string &word: wordlist){\\n            perfectWords.insert(word);\\n            \\n            string lowerCasedWord   = lowercase(word);\\n            wordsCap.insert({lowerCasedWord, word});\\n            \\n            string lowerCasedWordDV = devowel(lowerCasedWord);\\n            wordsVow.insert({lowerCasedWordDV, word});\\n        }\\n        \\n        vector<string> result;\\n        for(string &query : queries)\\n            result.push_back(solve(query));\\n        \\n        return result;\\n    }\\n    \\n    string solve(string query){\\n        if(perfectWords.find(query) != perfectWords.end())\\n            return query;\\n        \\n        string queryLower = lowercase(query);\\n        if(wordsCap.find(queryLower) != wordsCap.end())\\n            return wordsCap.at(queryLower);\\n        \\n        string queryLowerDV = devowel(queryLower);\\n        if(wordsVow.find(queryLowerDV) != wordsVow.end())\\n            return wordsVow.at(queryLowerDV);\\n        \\n        return \"\";\\n    }\\n    \\n    string lowercase(string word){\\n        string lowercased = word;\\n        for(char &val : lowercased)\\n            val = tolower(val);\\n        \\n        return lowercased;\\n    }\\n    \\n    string devowel(string word){\\n        string devoweled;\\n        for(char &val : word)\\n            devoweled.push_back(isVowel(val) ? \\'*\\' : val);\\n        \\n        return devoweled;\\n    }\\n    \\n    bool isVowel(char val){\\n        return (val == \\'a\\' || val == \\'e\\' || val == \\'i\\' || val == \\'o\\' || val == \\'u\\');\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123467,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n            \\n            Set<String> orig = new HashSet<>(Arrays.asList(wordlist));\\n            Map<String, String> lower = new HashMap<>();\\n            Map<String, String> mask = new HashMap<>();\\n            \\n            for( String word : wordlist ){\\n                    String low = word.toLowerCase();\\n                    lower.putIfAbsent(low,word);\\n                    mask.putIfAbsent(vmask(low),word);\\n            }\\n            \\n            \\n             for(int i=0; i<queries.length; i++){\\n                     String temp = queries[i];\\n                     String templower = temp.toLowerCase();\\n                     String tempmask = vmask(templower);\\n                     \\n                     if(orig.contains(temp)) continue;\\n                     else if (lower.containsKey(templower)) queries[i]= lower.get(templower);\\n                     else if (mask.containsKey(tempmask)) queries[i]= mask.get(tempmask);\\n                     else queries[i]=\"\";\\n             }\\n            \\n        return queries;   \\n    }\\n        \\n        public static String vmask(String str){\\n               StringBuilder sb = new StringBuilder();\\n               \\n                for (int i=0; i<str.length(); i++){\\n                       char c = str.charAt(i);\\n                       if(c==\\'a\\'|| c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\') \\n                        c=\\'*\\';\\n                       sb.append(c);\\n                       \\n               }\\n                return sb.toString();\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n            \\n            Set<String> orig = new HashSet<>(Arrays.asList(wordlist));\\n            Map<String, String> lower = new HashMap<>();\\n            Map<String, String> mask = new HashMap<>();\\n            \\n            for( String word : wordlist ){\\n                    String low = word.toLowerCase();\\n                    lower.putIfAbsent(low,word);\\n                    mask.putIfAbsent(vmask(low),word);\\n            }\\n            \\n            \\n             for(int i=0; i<queries.length; i++){\\n                     String temp = queries[i];\\n                     String templower = temp.toLowerCase();\\n                     String tempmask = vmask(templower);\\n                     \\n                     if(orig.contains(temp)) continue;\\n                     else if (lower.containsKey(templower)) queries[i]= lower.get(templower);\\n                     else if (mask.containsKey(tempmask)) queries[i]= mask.get(tempmask);\\n                     else queries[i]=\"\";\\n             }\\n            \\n        return queries;   \\n    }\\n        \\n        public static String vmask(String str){\\n               StringBuilder sb = new StringBuilder();\\n               \\n                for (int i=0; i<str.length(); i++){\\n                       char c = str.charAt(i);\\n                       if(c==\\'a\\'|| c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\') \\n                        c=\\'*\\';\\n                       sb.append(c);\\n                       \\n               }\\n                return sb.toString();\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123429,
                "title": "simple-java-solution-using-hashset-hashmap",
                "content": "```\\nclass Solution {\\n    Set<String> setActualWord;\\n    Map<String, String> mapCaseInSensitiveWord;\\n    Map<String, String> mapVowelInSensitiveWord;\\n    \\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        setActualWord = new HashSet();\\n        mapCaseInSensitiveWord = new HashMap();\\n        mapVowelInSensitiveWord = new HashMap();\\n        \\n        for (String word : wordlist) {\\n            setActualWord.add(word);\\n            \\n            String lowerCase = word.toLowerCase();\\n            \\n            mapCaseInSensitiveWord.putIfAbsent(lowerCase, word);\\n            mapVowelInSensitiveWord.putIfAbsent(removeVowels(lowerCase), word);\\n        }\\n        \\n        String[] result = new String[queries.length];\\n        \\n        for (int i = 0; i < queries.length; i++) {\\n            result[i] = search(queries[i]);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private String search(String str) {\\n        if (setActualWord.contains(str)) return str;\\n        \\n        String lowerCase = str.toLowerCase();\\n        \\n        if (mapCaseInSensitiveWord.containsKey(lowerCase)) return mapCaseInSensitiveWord.get(lowerCase);\\n        \\n        String removeViwels = removeVowels(lowerCase);\\n        \\n        if (mapVowelInSensitiveWord.containsKey(removeViwels)) return mapVowelInSensitiveWord.get(removeViwels);\\n        \\n        return \"\";\\n    }\\n    \\n    private String removeVowels(String str) {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for (int i = 0; i < str.length(); i++) {\\n            if (!isVowel(str.charAt(i))) sb.append(str.charAt(i));\\n            else sb.append(\\'*\\');\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    private boolean isVowel(char c) {\\n        return (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\');\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    Set<String> setActualWord;\\n    Map<String, String> mapCaseInSensitiveWord;\\n    Map<String, String> mapVowelInSensitiveWord;\\n    \\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        setActualWord = new HashSet();\\n        mapCaseInSensitiveWord = new HashMap();\\n        mapVowelInSensitiveWord = new HashMap();\\n        \\n        for (String word : wordlist) {\\n            setActualWord.add(word);\\n            \\n            String lowerCase = word.toLowerCase();\\n            \\n            mapCaseInSensitiveWord.putIfAbsent(lowerCase, word);\\n            mapVowelInSensitiveWord.putIfAbsent(removeVowels(lowerCase), word);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1123325,
                "title": "vowel-spellchecker-java-solution",
                "content": "class Solution {\\n  public String[] spellchecker(String[] wordlist, String[] queries) {\\n    Map<String, String> capsMap = new HashMap<>();\\n    Map<String, String> vowMap = new HashMap<>();\\n    Set<String> perfect = new HashSet<>();\\n    for (String word : wordlist) {\\n      perfect.add(word);\\n      capsMap.putIfAbsent(word.toLowerCase(), word);\\n      vowMap.putIfAbsent(getVowelKey(word.toLowerCase()), word);\\n    }\\n    String[] ans = new String[queries.length];\\n    for (int i = 0; i < queries.length; i++) {\\n      if (perfect.contains(queries[i])) {\\n        ans[i] = queries[i];\\n      }\\n      else if (capsMap.containsKey(queries[i].toLowerCase())) {\\n        ans[i] = capsMap.get(queries[i].toLowerCase());\\n      }\\n      else {\\n        ans[i] = vowMap.getOrDefault(getVowelKey(queries[i].toLowerCase()), \"\");\\n      }\\n    }\\n    return ans;\\n  }\\n  \\n  private String getVowelKey(String word) {\\n    StringBuilder sb = new StringBuilder();\\n    for (char c : word.toCharArray()) {\\n      if (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\') {\\n        sb.append(\\'*\\');\\n      }\\n      else {\\n        sb.append(c);\\n      }\\n    }\\n    return sb.toString();\\n  }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n  public String[] spellchecker(String[] wordlist, String[] queries) {\\n    Map<String, String> capsMap = new HashMap<>();\\n    Map<String, String> vowMap = new HashMap<>();\\n    Set<String> perfect = new HashSet<>();\\n    for (String word : wordlist) {\\n      perfect.add(word);\\n      capsMap.putIfAbsent(word.toLowerCase(), word);\\n      vowMap.putIfAbsent(getVowelKey(word.toLowerCase()), word);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1123198,
                "title": "linkedhashmap-for-maintaining-the-order-and-a-set",
                "content": "```\\nclass Solution {\\n    HashSet<Character> vowels;\\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        LinkedHashMap<String, List<String>> map = new LinkedHashMap<>();\\n        vowels = new HashSet<>(Arrays.asList(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'));\\n\\n        for(String word : wordlist){\\n            \\n            String key = word.toLowerCase();\\n            \\n            if(map.containsKey(key)){\\n                List<String> list = map.get(key);\\n                list.add(word);\\n                map.put(key,list);\\n            }else{\\n                List<String> list = new ArrayList<>();\\n                list.add(word);\\n                map.put(key,list);\\n            }\\n      \\n        }\\n\\n        String[] result = new String[queries.length];\\n        \\n        for(int i = 0; i < queries.length; i++){\\n            \\n            String key = queries[i].toLowerCase();\\n            \\n            if(map.containsKey(key)){\\n                \\n                if(map.get(key).contains(queries[i])){\\n                    result[i] = queries[i];\\n                }else{\\n                    result[i] = map.get(key).get(0);\\n                }\\n     \\n            }else{\\n                \\n                boolean found = false;\\n                for(String keyset : map.keySet()){\\n                    \\n                    if(checkVowels(key, keyset)){\\n                        result[i] =map.get(keyset).get(0);\\n                        found = true;\\n                        break;\\n                    }        \\n                }\\n                if(!found){\\n                    result[i] = \"\";\\n                }\\n                \\n            }   \\n        }\\n\\t\\t\\n        return result;\\n    }\\n\\n    public boolean checkVowels(String a , String b){\\n        \\n        if(a.length()!= b.length()){\\n            return false;\\n        }\\n        \\n        for(int i = 0 ; i < a.length(); i++){\\n            \\n            if(a.charAt(i) != b.charAt(i)){\\n                if(!vowels.contains(a.charAt(i)) || !vowels.contains(b.charAt(i))){\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;          \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    HashSet<Character> vowels;\\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        LinkedHashMap<String, List<String>> map = new LinkedHashMap<>();\\n        vowels = new HashSet<>(Arrays.asList(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'));\\n\\n        for(String word : wordlist){\\n            \\n            String key = word.toLowerCase();\\n            \\n            if(map.containsKey(key)){\\n                List<String> list = map.get(key);\\n                list.add(word);\\n                map.put(key,list);\\n            }else{\\n                List<String> list = new ArrayList<>();\\n                list.add(word);\\n                map.put(key,list);\\n            }\\n      \\n        }\\n\\n        String[] result = new String[queries.length];\\n        \\n        for(int i = 0; i < queries.length; i++){\\n            \\n            String key = queries[i].toLowerCase();\\n            \\n            if(map.containsKey(key)){\\n                \\n                if(map.get(key).contains(queries[i])){\\n                    result[i] = queries[i];\\n                }else{\\n                    result[i] = map.get(key).get(0);\\n                }\\n     \\n            }else{\\n                \\n                boolean found = false;\\n                for(String keyset : map.keySet()){\\n                    \\n                    if(checkVowels(key, keyset)){\\n                        result[i] =map.get(keyset).get(0);\\n                        found = true;\\n                        break;\\n                    }        \\n                }\\n                if(!found){\\n                    result[i] = \"\";\\n                }\\n                \\n            }   \\n        }\\n\\t\\t\\n        return result;\\n    }\\n\\n    public boolean checkVowels(String a , String b){\\n        \\n        if(a.length()!= b.length()){\\n            return false;\\n        }\\n        \\n        for(int i = 0 ; i < a.length(); i++){\\n            \\n            if(a.charAt(i) != b.charAt(i)){\\n                if(!vowels.contains(a.charAt(i)) || !vowels.contains(b.charAt(i))){\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;          \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123184,
                "title": "vowel-spellchecker",
                "content": "class Solution(object):\\n    def spellchecker(self, wordlist, queries):\\n        def devowel(word):\\n            return \"\".join(\\'*\\' if c in \\'aeiou\\' else c\\n                           for c in word)\\n\\n        words_perfect = set(wordlist)\\n        words_cap = {}\\n        words_vow = {}\\n\\n        for word in wordlist:\\n            wordlow = word.lower()\\n            words_cap.setdefault(wordlow, word)\\n            words_vow.setdefault(devowel(wordlow), word)\\n\\n        def solve(query):\\n            if query in words_perfect:\\n                return query\\n\\n            queryL = query.lower()\\n            if queryL in words_cap:\\n                return words_cap[queryL]\\n\\n            queryLV = devowel(queryL)\\n            if queryLV in words_vow:\\n                return words_vow[queryLV]\\n            return \"\"\\n\\n        return map(solve, queries)[](http://)",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def spellchecker(self, wordlist, queries):\\n        def devowel(word):\\n            return \"\".join(\\'*\\' if c in \\'aeiou\\' else c\\n                           for c in word)\\n\\n        words_perfect = set(wordlist)\\n        words_cap = {}",
                "codeTag": "Java"
            },
            {
                "id": 1123155,
                "title": "vowel-spellchecker",
                "content": "class Solution(object):\\n    def spellchecker(self, wordlist, queries):\\n        def devowel(word):\\n            return \"\".join(\\'*\\' if c in \\'aeiou\\' else c\\n                           for c in word)\\n\\n        words_perfect = set(wordlist)\\n        words_cap = {}\\n        words_vow = {}\\n\\n        for word in wordlist:\\n            wordlow = word.lower()\\n            words_cap.setdefault(wordlow, word)\\n            words_vow.setdefault(devowel(wordlow), word)\\n\\n        def solve(query):\\n            if query in words_perfect:\\n                return query\\n\\n            queryL = query.lower()\\n            if queryL in words_cap:\\n                return words_cap[queryL]\\n\\n            queryLV = devowel(queryL)\\n            if queryLV in words_vow:\\n                return words_vow[queryLV]\\n            return \"\"\\n\\n        return map(solve, queries)",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def spellchecker(self, wordlist, queries):\\n        def devowel(word):\\n            return \"\".join(\\'*\\' if c in \\'aeiou\\' else c\\n                           for c in word)\\n\\n        words_perfect = set(wordlist)\\n        words_cap = {}",
                "codeTag": "Java"
            },
            {
                "id": 1123147,
                "title": "c-set-map-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_set<char> vhs{\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        vector<string> queryRes;\\n        unordered_set<string> hs;\\n        unordered_map<string,string> hm1, hm2;\\n        for(string word : wordlist) {\\n            hs.insert(word);\\n            string lowerStr = toLower(word);\\n            if(hm1.find(lowerStr) == hm1.end()) hm1[lowerStr] = word;\\n            string convertStr = convertStrUtil(word);\\n            if(hm2.find(convertStr) == hm2.end()) hm2[convertStr] = word;\\n        }\\n        for(string query : queries) {\\n            if(hs.count(query)) queryRes.push_back(query);\\n            else if(hm1.find(toLower(query)) != hm1.end()) queryRes.push_back(hm1[toLower(query)]);\\n            else if(hm2.find(convertStrUtil(query)) != hm2.end()) queryRes.push_back(hm2[convertStrUtil(query)]);\\n            else queryRes.push_back(\"\");\\n        }\\n        return queryRes;\\n    }\\n    \\n    string convertStrUtil(string &str) {\\n        string res;\\n        for(char ch : str) {\\n            if(vhs.count(tolower(ch))) res.push_back(\\'*\\');\\n            else res.push_back(tolower(ch));\\n        }\\n        return res;\\n    }\\n    \\n    string toLower(string &str) {\\n        string res;\\n        for(char ch : str) res.push_back(tolower(ch));\\n        return res;\\n    }\\n   \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_set<char> vhs{\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        vector<string> queryRes;\\n        unordered_set<string> hs;\\n        unordered_map<string,string> hm1, hm2;\\n        for(string word : wordlist) {\\n            hs.insert(word);\\n            string lowerStr = toLower(word);\\n            if(hm1.find(lowerStr) == hm1.end()) hm1[lowerStr] = word;\\n            string convertStr = convertStrUtil(word);\\n            if(hm2.find(convertStr) == hm2.end()) hm2[convertStr] = word;\\n        }\\n        for(string query : queries) {\\n            if(hs.count(query)) queryRes.push_back(query);\\n            else if(hm1.find(toLower(query)) != hm1.end()) queryRes.push_back(hm1[toLower(query)]);\\n            else if(hm2.find(convertStrUtil(query)) != hm2.end()) queryRes.push_back(hm2[convertStrUtil(query)]);\\n            else queryRes.push_back(\"\");\\n        }\\n        return queryRes;\\n    }\\n    \\n    string convertStrUtil(string &str) {\\n        string res;\\n        for(char ch : str) {\\n            if(vhs.count(tolower(ch))) res.push_back(\\'*\\');\\n            else res.push_back(tolower(ch));\\n        }\\n        return res;\\n    }\\n    \\n    string toLower(string &str) {\\n        string res;\\n        for(char ch : str) res.push_back(tolower(ch));\\n        return res;\\n    }\\n   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123133,
                "title": "python-easy-to-read",
                "content": "```\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        def devowel(word):\\n            return \"\".join(\\'*\\' if c in \\'aeiouAEIOU\\' else c\\n                           for c in word)\\n        \\n        upper_ls = [w.upper() for w in wordlist]\\n        dev_ls = [devowel(w) for w in wordlist]\\n        upper_dev_ls = [w.upper() for w in dev_ls]\\n        ans_ls = []\\n        \\n        for query in queries:\\n            if query in wordlist:\\n                ans_ls.append(query)\\n            elif query.upper() in upper_ls:\\n                ans_ls.append(wordlist[upper_ls.index(query.upper())])\\n            elif devowel(query).upper() in upper_dev_ls:\\n                ans_ls.append(wordlist[upper_dev_ls.index(devowel(query).upper())])\\n            else:\\n                ans_ls.append(\"\")\\n\\n        return ans_ls\\n     \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        def devowel(word):\\n            return \"\".join(\\'*\\' if c in \\'aeiouAEIOU\\' else c\\n                           for c in word)\\n        \\n        upper_ls = [w.upper() for w in wordlist]\\n        dev_ls = [devowel(w) for w in wordlist]\\n        upper_dev_ls = [w.upper() for w in dev_ls]\\n        ans_ls = []\\n        \\n        for query in queries:\\n            if query in wordlist:\\n                ans_ls.append(query)\\n            elif query.upper() in upper_ls:\\n                ans_ls.append(wordlist[upper_ls.index(query.upper())])\\n            elif devowel(query).upper() in upper_dev_ls:\\n                ans_ls.append(wordlist[upper_dev_ls.index(devowel(query).upper())])\\n            else:\\n                ans_ls.append(\"\")\\n\\n        return ans_ls\\n     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123124,
                "title": "c-beats-100-c-solutions-in-time-and-space",
                "content": "Create a dictionary with \"normalized\" words from the word list mapped to the list of word prior to normalization, so that [\"KiTe\",\"kite\",\"hare\",\"Hare\"] becomes\\n\"kete\" -> [\"KiTe\",\"kite\"]\\n\"here\" -> [\"hare\",\"Hare\"]\\nI used  \\'e\\' as a replacement for {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'} since \\'e\\' is the most common vowel in English.\\nThen normalize each query to find list of candidates in the dictionary and search the candidates within the order of precedence for the spellcheker.\\n```\\npublic class Solution {\\n    public string[] Spellchecker(string[] wordlist, string[] queries) {\\n        var count = wordlist.Length;\\n        var dictionary = new Dictionary<string, List<string>>();\\n        foreach(var word in wordlist)\\n        {\\n            var normalized = Normalize(word);\\n            if(dictionary.TryGetValue(normalized, out var words)) words.Add(word);\\n            else dictionary[normalized] = new List<string>{word};\\n        }\\n        var queryCount = queries.Length;\\n        var result = new string[queryCount];\\n        for(var i = 0; i < queryCount; i++)\\n        {\\n            var query = queries[i];\\n            var queryNormalized = Normalize(query);\\n            if(dictionary.TryGetValue(queryNormalized, out var candidates))\\n            {\\n                if(candidates.Contains(query)) result[i] = query;\\n                else\\n                {\\n                    var ignoreCase = candidates.FirstOrDefault(x => x.Equals(query, StringComparison.OrdinalIgnoreCase));\\n                    if(ignoreCase != null) result[i] = ignoreCase;\\n                    else result[i] = candidates[0]; \\n                }\\n            }\\n            else result[i] = string.Empty;\\n        }\\n        return result;\\n    } \\n    \\n    private static readonly HashSet<char> Vowels = new HashSet<char>(new []{\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'});\\n    static string Normalize(string s)\\n    {\\n        var builder = new StringBuilder(s.Length);\\n        foreach(var ch in s)\\n        {\\n            var lower = char.ToLower(ch);\\n            if(Vowels.Contains(lower)) lower = \\'e\\';\\n            builder.Append(lower);\\n        }\\n        return builder.ToString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string[] Spellchecker(string[] wordlist, string[] queries) {\\n        var count = wordlist.Length;\\n        var dictionary = new Dictionary<string, List<string>>();\\n        foreach(var word in wordlist)\\n        {\\n            var normalized = Normalize(word);\\n            if(dictionary.TryGetValue(normalized, out var words)) words.Add(word);\\n            else dictionary[normalized] = new List<string>{word};\\n        }\\n        var queryCount = queries.Length;\\n        var result = new string[queryCount];\\n        for(var i = 0; i < queryCount; i++)\\n        {\\n            var query = queries[i];\\n            var queryNormalized = Normalize(query);\\n            if(dictionary.TryGetValue(queryNormalized, out var candidates))\\n            {\\n                if(candidates.Contains(query)) result[i] = query;\\n                else\\n                {\\n                    var ignoreCase = candidates.FirstOrDefault(x => x.Equals(query, StringComparison.OrdinalIgnoreCase));\\n                    if(ignoreCase != null) result[i] = ignoreCase;\\n                    else result[i] = candidates[0]; \\n                }\\n            }\\n            else result[i] = string.Empty;\\n        }\\n        return result;\\n    } \\n    \\n    private static readonly HashSet<char> Vowels = new HashSet<char>(new []{\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'});\\n    static string Normalize(string s)\\n    {\\n        var builder = new StringBuilder(s.Length);\\n        foreach(var ch in s)\\n        {\\n            var lower = char.ToLower(ch);\\n            if(Vowels.Contains(lower)) lower = \\'e\\';\\n            builder.Append(lower);\\n        }\\n        return builder.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123114,
                "title": "c-with-explanation",
                "content": "```\\n    /*\\n     * Solution is to find the set of words that are queried should be present\\n     * in wordlist. For doing this, there are set of rules\\n     * Rules:\\n     * 1. If the word matches the wordlist, return the same word\\n     *    Eg: wordList- [kite], query - [kite] => o/p = [kite]\\n     *\\n     * 2. If the word matches the wordlists by doing a lowercase check, then\\n     *    word should be returned as same case in the wordlist\\n     *    Eg: wordList - [kite], query - [KITE, KiTE, KItE] => [kite, kite,kite]\\n     *\\n     * 3. If the wordList has same case-sensitive words and if the query word\\n     *    matches the word in wordlist by converting it to a lower-case, then\\n     *    word returned is the first such match in wordlist\\n     *    Eg: wordList - [KiTe, kite], query - [Kite] => [KiTe]\\n     *\\n     * 4. If the query word by replacing the vowels matches a word in wordlist,\\n     *    then word returned with same case as the first such match in wordlist\\n     *    Eg: wordList - [KiTe, kite], query - [keti] => [KiTe]\\n     *\\n     * 5. If query word is not found in wordlist, then word returned is an empty\\n     *    word\\n     *    Eg: wordList - [KiTe, kite], query - [keet] => []\\n    */\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        // Set to store the unique words from the wordlist\\n        std::unordered_set<string> uniqueWords;\\n        // Map to store the lowercase wordlist and original word\\n        std::unordered_map<string, string> mp;\\n        // Map to store the words after changing the vowels with \\'*\\'\\n        std::unordered_map<string, string> devowels;\\n        \\n        // Fill all the maps and sets\\n        for (string word : wordlist) {\\n            // push it in set\\n            uniqueWords.insert(word);\\n            \\n            // LowerCase Rule\\n            string lowercaseword = lower(word);\\n            if (mp.count(lowercaseword) == 0)\\n                mp[lowercaseword] = word;\\n            \\n            // Vowel Replacing rule\\n            string vowelreplacedword = vowelRemovedString(lowercaseword);\\n            if (devowels.count(vowelreplacedword) == 0)\\n                devowels[vowelreplacedword] = word;\\n        }\\n        \\n        // Loop over queries, returing results in queries\\n        for (int i = 0; i < queries.size(); i++) {\\n            string word = \"\";\\n            if (uniqueWords.count(queries[i]) == 1) {\\n                // Same word found in wordList\\n                // nothing to update \\n            }\\n            else if (mp.count(word = lower(queries[i])) == 1) {\\n                // Lower Case word is found, replace with the\\n                // first occurence of the word in wordlist\\n                queries[i] = mp[word];\\n            }\\n            else if (devowels.count(word = vowelRemovedString(word)) == 1) {\\n                // After replacing the vowels, the string is\\n                // present in the wordlist, return the first\\n                // matched word\\n                queries[i] = devowels[word];               \\n            }\\n            else {\\n                // Nothing found, push empty string\\n                queries[i] = \"\";\\n            }\\n        }\\n        return queries;\\n    }\\n    \\n    string lower(string word) {\\n        for (int i = 0; i < word.size(); i++) {\\n            word[i] = tolower(word[i]);\\n        }\\n        return word;\\n    }\\n    \\n    string vowelRemovedString(string word) {\\n        for (int i = 0; i < word.length(); i++) {\\n            char c = word[i];\\n            if (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\') {\\n                word[i] = \\'*\\';\\n            }\\n        }\\n        return word;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    /*\\n     * Solution is to find the set of words that are queried should be present\\n     * in wordlist. For doing this, there are set of rules\\n     * Rules:\\n     * 1. If the word matches the wordlist, return the same word\\n     *    Eg: wordList- [kite], query - [kite] => o/p = [kite]\\n     *\\n     * 2. If the word matches the wordlists by doing a lowercase check, then\\n     *    word should be returned as same case in the wordlist\\n     *    Eg: wordList - [kite], query - [KITE, KiTE, KItE] => [kite, kite,kite]\\n     *\\n     * 3. If the wordList has same case-sensitive words and if the query word\\n     *    matches the word in wordlist by converting it to a lower-case, then\\n     *    word returned is the first such match in wordlist\\n     *    Eg: wordList - [KiTe, kite], query - [Kite] => [KiTe]\\n     *\\n     * 4. If the query word by replacing the vowels matches a word in wordlist,\\n     *    then word returned with same case as the first such match in wordlist\\n     *    Eg: wordList - [KiTe, kite], query - [keti] => [KiTe]\\n     *\\n     * 5. If query word is not found in wordlist, then word returned is an empty\\n     *    word\\n     *    Eg: wordList - [KiTe, kite], query - [keet] => []\\n    */\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        // Set to store the unique words from the wordlist\\n        std::unordered_set<string> uniqueWords;\\n        // Map to store the lowercase wordlist and original word\\n        std::unordered_map<string, string> mp;\\n        // Map to store the words after changing the vowels with \\'*\\'\\n        std::unordered_map<string, string> devowels;\\n        \\n        // Fill all the maps and sets\\n        for (string word : wordlist) {\\n            // push it in set\\n            uniqueWords.insert(word);\\n            \\n            // LowerCase Rule\\n            string lowercaseword = lower(word);\\n            if (mp.count(lowercaseword) == 0)\\n                mp[lowercaseword] = word;\\n            \\n            // Vowel Replacing rule\\n            string vowelreplacedword = vowelRemovedString(lowercaseword);\\n            if (devowels.count(vowelreplacedword) == 0)\\n                devowels[vowelreplacedword] = word;\\n        }\\n        \\n        // Loop over queries, returing results in queries\\n        for (int i = 0; i < queries.size(); i++) {\\n            string word = \"\";\\n            if (uniqueWords.count(queries[i]) == 1) {\\n                // Same word found in wordList\\n                // nothing to update \\n            }\\n            else if (mp.count(word = lower(queries[i])) == 1) {\\n                // Lower Case word is found, replace with the\\n                // first occurence of the word in wordlist\\n                queries[i] = mp[word];\\n            }\\n            else if (devowels.count(word = vowelRemovedString(word)) == 1) {\\n                // After replacing the vowels, the string is\\n                // present in the wordlist, return the first\\n                // matched word\\n                queries[i] = devowels[word];               \\n            }\\n            else {\\n                // Nothing found, push empty string\\n                queries[i] = \"\";\\n            }\\n        }\\n        return queries;\\n    }\\n    \\n    string lower(string word) {\\n        for (int i = 0; i < word.size(); i++) {\\n            word[i] = tolower(word[i]);\\n        }\\n        return word;\\n    }\\n    \\n    string vowelRemovedString(string word) {\\n        for (int i = 0; i < word.length(); i++) {\\n            char c = word[i];\\n            if (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\') {\\n                word[i] = \\'*\\';\\n            }\\n        }\\n        return word;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1123058,
                "title": "python-3",
                "content": "```class Solution(object):\\n    def spellchecker(self, wordlist, queries):\\n        def devowel(word):\\n            return \"\".join(\\'*\\' if c in \\'aeiou\\' else c\\n                           for c in word)\\n\\n        words_perfect = set(wordlist)\\n        words_cap = {}\\n        words_vow = {}\\n\\n        for word in wordlist:\\n            wordlow = word.lower()\\n            words_cap.setdefault(wordlow, word)\\n            words_vow.setdefault(devowel(wordlow), word)\\n\\n        def solve(query):\\n            if query in words_perfect:\\n                return query\\n\\n            queryL = query.lower()\\n            if queryL in words_cap:\\n                return words_cap[queryL]\\n\\n            queryLV = devowel(queryL)\\n            if queryLV in words_vow:\\n                return words_vow[queryLV]\\n            return \"\"\\n\\n        return map(solve, queries)\\n",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def spellchecker(self, wordlist, queries):\\n        def devowel(word):\\n            return \"\".join(\\'*\\' if c in \\'aeiou\\' else c\\n                           for c in word)\\n\\n        words_perfect = set(wordlist)\\n        words_cap = {}",
                "codeTag": "Java"
            },
            {
                "id": 1122985,
                "title": "python-dict",
                "content": "```\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        \\n        replace_vowel = lambda w: w.replace(\\'a\\', \\'*\\').replace(\\'e\\', \\'*\\').replace(\\'i\\', \\'*\\').replace(\\'o\\', \\'*\\').replace(\\'u\\', \\'*\\')\\n        capitalization_dict = vowel_errors_dict = {}\\n        for w in wordlist:\\n            if w.lower() not in capitalization_dict:\\n                capitalization_dict[w.lower()] = w\\n            if replace_vowel(w.lower()) not in vowel_errors_dict:\\n                vowel_errors_dict[replace_vowel(w.lower())] = w\\n        word_set = set(wordlist)\\n        \\n        def convert(word: str) -> str:\\n            if word in word_set:\\n                return word\\n            elif word.lower() in capitalization_dict:\\n                return capitalization_dict[word.lower()]\\n            elif replace_vowel(word.lower()) in vowel_errors_dict:\\n                return vowel_errors_dict[replace_vowel(word.lower())]\\n            return \\'\\'\\n        \\n        return [convert(w) for w in queries]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        \\n        replace_vowel = lambda w: w.replace(\\'a\\', \\'*\\').replace(\\'e\\', \\'*\\').replace(\\'i\\', \\'*\\').replace(\\'o\\', \\'*\\').replace(\\'u\\', \\'*\\')\\n        capitalization_dict = vowel_errors_dict = {}\\n        for w in wordlist:\\n            if w.lower() not in capitalization_dict:\\n                capitalization_dict[w.lower()] = w\\n            if replace_vowel(w.lower()) not in vowel_errors_dict:\\n                vowel_errors_dict[replace_vowel(w.lower())] = w\\n        word_set = set(wordlist)\\n        \\n        def convert(word: str) -> str:\\n            if word in word_set:\\n                return word\\n            elif word.lower() in capitalization_dict:\\n                return capitalization_dict[word.lower()]\\n            elif replace_vowel(word.lower()) in vowel_errors_dict:\\n                return vowel_errors_dict[replace_vowel(word.lower())]\\n            return \\'\\'\\n        \\n        return [convert(w) for w in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122954,
                "title": "php-solution-separate-mappings-for-each-type-of-match-with-quick-overview",
                "content": "56 ms 20.4 MB\\n\\n**After spending some unhappy time attempting a Trie solution, I came up with this ...**\\n\\nSince queries and words can get up to 5000 each, a brute force O(n^2) solution is infeasible.\\n\\nInstead, map the words to their indices in the wordlist, with the following:\\n\\n1. Map of each word to it\\'s index.\\n1. Map of each lower-cased word to it\\'s first index in the wordlist.\\n1. Map of each lower-cased word with the vowels replaced by a non-letters to it\\'s index in the wordlist.\\n\\nFor each query, try the query against the first map.  If not found, LC the query and try it against the second map.  If not found, substitute the vowels and try it against the 3rd map.\\nIf one of these matches, add the wordlist entry at the index found.  Otherwise, add 0.\\n\\n```\\nclass Solution \\n{\\n\\n        /**\\n        * @param String[] $wordlist\\n        * @param String[] $queries\\n        * @return String[]\\n        */\\n        function spellchecker($wordlist, $queries) \\n        {\\n                /* Make maps for exact, case-insensitive, and vowels-substitute matches. */\\n                $wl1 = [];\\n                $wl2 = [];\\n                $wl2 = [];\\n                for($i=0; $i<count($wordlist); $i++)\\n                {\\n                        $key = $wordlist[$i];\\n                        $wl1[$key] = $i;\\n                        $key = strtolower($key);\\n                        if(!array_key_exists($key, $wl2))\\n                                $wl2[$key] = $i;\\n                        $key = preg_replace(\\'/[aeiou]/\\',\\'#\\',$key);\\n                        if(!array_key_exists($key, $wl3))\\n                                $wl3[$key] = $i;\\n                }\\n                \\n                $result = [];\\n\\n                /* Run each key against the diffeent maps, transofrming as necessary. */\\n                foreach($queries as $q)\\n                {\\n                        if(array_key_exists($q, $wl1))\\n                        {\\n                                $result[] = $wordlist[$wl1[$q]];\\n                                continue;\\n                        }\\n                        $q = strtolower($q);\\n                        if(array_key_exists($q, $wl2))\\n                        {\\n                                $result[] = $wordlist[$wl2[$q]];\\n                                continue;\\n                        }\\n                        $q = preg_replace(\\'/[aeiou]/\\',\\'#\\',$q);\\n                        if(array_key_exists($q, $wl3))\\n                        {\\n                                $result[] = $wordlist[$wl3[$q]];\\n                                continue;\\n                        }\\n                        $result[] = \\'\\';\\n                }\\n                \\n                return $result;\\n        }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n\\n        /**\\n        * @param String[] $wordlist\\n        * @param String[] $queries\\n        * @return String[]\\n        */\\n        function spellchecker($wordlist, $queries) \\n        {\\n                /* Make maps for exact, case-insensitive, and vowels-substitute matches. */\\n                $wl1 = [];\\n                $wl2 = [];\\n                $wl2 = [];\\n                for($i=0; $i<count($wordlist); $i++)\\n                {\\n                        $key = $wordlist[$i];\\n                        $wl1[$key] = $i;\\n                        $key = strtolower($key);\\n                        if(!array_key_exists($key, $wl2))\\n                                $wl2[$key] = $i;\\n                        $key = preg_replace(\\'/[aeiou]/\\',\\'#\\',$key);\\n                        if(!array_key_exists($key, $wl3))\\n                                $wl3[$key] = $i;\\n                }\\n                \\n                $result = [];\\n\\n                /* Run each key against the diffeent maps, transofrming as necessary. */\\n                foreach($queries as $q)\\n                {\\n                        if(array_key_exists($q, $wl1))\\n                        {\\n                                $result[] = $wordlist[$wl1[$q]];\\n                                continue;\\n                        }\\n                        $q = strtolower($q);\\n                        if(array_key_exists($q, $wl2))\\n                        {\\n                                $result[] = $wordlist[$wl2[$q]];\\n                                continue;\\n                        }\\n                        $q = preg_replace(\\'/[aeiou]/\\',\\'#\\',$q);\\n                        if(array_key_exists($q, $wl3))\\n                        {\\n                                $result[] = $wordlist[$wl3[$q]];\\n                                continue;\\n                        }\\n                        $result[] = \\'\\';\\n                }\\n                \\n                return $result;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122864,
                "title": "python-dictionary-solution",
                "content": "```\\nclass Solution:\\n    def get_replaced_word(self, word):\\n            replaced_char_list = []\\n            for c in word:\\n                if c in set([\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']):\\n                    replaced_char_list.append(\\'_\\')\\n                else:\\n                    replaced_char_list.append(c)\\n            replaced_word = \\'\\'.join(replaced_char_list)\\n            return replaced_word\\n\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        case_sensitive_set = set(wordlist)\\n        case_insensitive_dict = {}\\n        vowel_dict = {}\\n\\n        for word in wordlist:\\n            small_case_word = word.lower()\\n            if small_case_word not in case_insensitive_dict:\\n                case_insensitive_dict[small_case_word] = word\\n\\n            replaced_word = self.get_replaced_word(small_case_word)\\n            if replaced_word not in vowel_dict:\\n                vowel_dict[replaced_word] = word\\n\\n        res = []\\n        for qw in queries:\\n            if qw in case_sensitive_set:\\n                res.append(qw)\\n            elif qw.lower() in case_insensitive_dict:\\n                res.append(case_insensitive_dict[qw.lower()])\\n            else:\\n                replaced_word = self.get_replaced_word(qw.lower())\\n                if replaced_word in vowel_dict:\\n                    res.append(vowel_dict[replaced_word])\\n                else:\\n                    res.append(\\'\\')\\n\\n        return res\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def get_replaced_word(self, word):\\n            replaced_char_list = []\\n            for c in word:\\n                if c in set([\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']):\\n                    replaced_char_list.append(\\'_\\')\\n                else:\\n                    replaced_char_list.append(c)\\n            replaced_word = \\'\\'.join(replaced_char_list)\\n            return replaced_word\\n\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        case_sensitive_set = set(wordlist)\\n        case_insensitive_dict = {}\\n        vowel_dict = {}\\n\\n        for word in wordlist:\\n            small_case_word = word.lower()\\n            if small_case_word not in case_insensitive_dict:\\n                case_insensitive_dict[small_case_word] = word\\n\\n            replaced_word = self.get_replaced_word(small_case_word)\\n            if replaced_word not in vowel_dict:\\n                vowel_dict[replaced_word] = word\\n\\n        res = []\\n        for qw in queries:\\n            if qw in case_sensitive_set:\\n                res.append(qw)\\n            elif qw.lower() in case_insensitive_dict:\\n                res.append(case_insensitive_dict[qw.lower()])\\n            else:\\n                replaced_word = self.get_replaced_word(qw.lower())\\n                if replaced_word in vowel_dict:\\n                    res.append(vowel_dict[replaced_word])\\n                else:\\n                    res.append(\\'\\')\\n\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122855,
                "title": "c-index-by-removing-cap-and-vowels",
                "content": "```cpp   \\nstring to_lower(const string& w) {\\n\\tstring s(w);\\n\\ttransform(s.begin(), s.end(), s.begin(), ::tolower);\\n\\treturn s;\\n}\\n\\nstring remove_vowels(const string& w) {\\n\\tstring s;\\n\\ts.reserve(w.size());\\n\\ttransform(w.begin(), w.end(), back_inserter(s), [](auto c) {\\n\\t\\tswitch(c) {\\n\\t\\t\\tcase \\'a\\': case \\'e\\': case \\'i\\': case \\'o\\': case \\'u\\':\\n\\t\\t\\t\\treturn \\'*\\';\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\treturn c;\\n\\t\\t}\\n\\t});\\n\\treturn s;\\n};\\n\\nvector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n\\tunordered_map<string, vector<string>> dict_cap;\\n\\tunordered_map<string, vector<string>> dict_vowels;\\n\\tfor(const auto& w: wordlist){\\n\\t\\tauto lc = to_lower(w);\\n\\t\\tdict_cap[lc].push_back(w);\\n\\t\\tdict_vowels[remove_vowels(lc)].push_back(w);\\n\\t}\\n\\tvector<string> corr;\\n\\tcorr.reserve(queries.size());\\n\\tfor(const auto& q: queries) {\\n\\t\\tstring lc = to_lower(q);\\n\\t\\tstring s = q;\\n\\t\\tif(auto it1 = dict_cap.find(lc); it1 != dict_cap.end()) {\\n\\t\\t\\tif(find(it1->second.begin(), it1->second.end(), q) == it1->second.end())\\n\\t\\t\\t\\ts = it1->second.front();\\n\\t\\t} else if(auto it2 = dict_vowels.find(remove_vowels(lc)); it2 != dict_vowels.end()) {\\n\\t\\t\\tif(find(it2->second.begin(), it2->second.end(), q) == it2->second.end())\\n\\t\\t\\t\\ts = it2->second.front();\\n\\t\\t} else\\n\\t\\t\\ts = \"\";\\n\\t\\tcorr.push_back(s);\\n\\t}\\n\\treturn corr;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp   \\nstring to_lower(const string& w) {\\n\\tstring s(w);\\n\\ttransform(s.begin(), s.end(), s.begin(), ::tolower);\\n\\treturn s;\\n}\\n\\nstring remove_vowels(const string& w) {\\n\\tstring s;\\n\\ts.reserve(w.size());\\n\\ttransform(w.begin(), w.end(), back_inserter(s), [](auto c) {\\n\\t\\tswitch(c) {\\n\\t\\t\\tcase \\'a\\': case \\'e\\': case \\'i\\': case \\'o\\': case \\'u\\':\\n\\t\\t\\t\\treturn \\'*\\';\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\treturn c;\\n\\t\\t}\\n\\t});\\n\\treturn s;\\n};\\n\\nvector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n\\tunordered_map<string, vector<string>> dict_cap;\\n\\tunordered_map<string, vector<string>> dict_vowels;\\n\\tfor(const auto& w: wordlist){\\n\\t\\tauto lc = to_lower(w);\\n\\t\\tdict_cap[lc].push_back(w);\\n\\t\\tdict_vowels[remove_vowels(lc)].push_back(w);\\n\\t}\\n\\tvector<string> corr;\\n\\tcorr.reserve(queries.size());\\n\\tfor(const auto& q: queries) {\\n\\t\\tstring lc = to_lower(q);\\n\\t\\tstring s = q;\\n\\t\\tif(auto it1 = dict_cap.find(lc); it1 != dict_cap.end()) {\\n\\t\\t\\tif(find(it1->second.begin(), it1->second.end(), q) == it1->second.end())\\n\\t\\t\\t\\ts = it1->second.front();\\n\\t\\t} else if(auto it2 = dict_vowels.find(remove_vowels(lc)); it2 != dict_vowels.end()) {\\n\\t\\t\\tif(find(it2->second.begin(), it2->second.end(), q) == it2->second.end())\\n\\t\\t\\t\\ts = it2->second.front();\\n\\t\\t} else\\n\\t\\t\\ts = \"\";\\n\\t\\tcorr.push_back(s);\\n\\t}\\n\\treturn corr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1122835,
                "title": "ruby-two-hash-map",
                "content": "```\\n# @param {String[]} wordlist\\n# @param {String[]} queries\\n# @return {String[]}\\ndef spellchecker(wordlist, queries)\\n  words = Hash[wordlist.map{|w| [w, w]}]\\n  cap = Hash[wordlist.reverse.map{|w| [w.downcase, w]}]\\n  vowel = Hash[wordlist.reverse.map{|w| [w.downcase.gsub(/[aeiou]/, \\'#\\'), w]}]\\n  queries.map{|w| words[w] || cap[w.downcase] || vowel[w.downcase.gsub(/[aeiou]/, \\'#\\')] || \"\"}\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {String[]} wordlist\\n# @param {String[]} queries\\n# @return {String[]}\\ndef spellchecker(wordlist, queries)\\n  words = Hash[wordlist.map{|w| [w, w]}]\\n  cap = Hash[wordlist.reverse.map{|w| [w.downcase, w]}]\\n  vowel = Hash[wordlist.reverse.map{|w| [w.downcase.gsub(/[aeiou]/, \\'#\\'), w]}]\\n  queries.map{|w| words[w] || cap[w.downcase] || vowel[w.downcase.gsub(/[aeiou]/, \\'#\\')] || \"\"}\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1122786,
                "title": "is-it-someting-wrong-with-rule-2-when-the-query-matches-a-word-up-to-capitlization",
                "content": "Hello,\\n\\nBesides the spelling \"capitlization\", I think there is something else wrong in the reference implementation.\\nIn the description/example, with the wordlist = [\"KiTe\",\"kite\",\"hare\",\"Hare\"], \"HARE\\' is matched to \"hare\".\\nRule 1 is not applicable: there is no case-sensitive match\\nRule 2 would be applicable, since we have a \"hare\" starting with upper (\\'h\\'), so I think it sould return \"Hare\"...\\n.. not \"hare\", as it seems rule 3 is applied\\nI had to ignore that rule 2 to make my soluton acceptable...\\n\\nWhat do you think?\\n\\nThank you,\\nE.I",
                "solutionTags": [],
                "code": "Hello,\\n\\nBesides the spelling \"capitlization\", I think there is something else wrong in the reference implementation.\\nIn the description/example, with the wordlist = [\"KiTe\",\"kite\",\"hare\",\"Hare\"], \"HARE\\' is matched to \"hare\".\\nRule 1 is not applicable: there is no case-sensitive match\\nRule 2 would be applicable, since we have a \"hare\" starting with upper (\\'h\\'), so I think it sould return \"Hare\"...\\n.. not \"hare\", as it seems rule 3 is applied\\nI had to ignore that rule 2 to make my soluton acceptable...\\n\\nWhat do you think?\\n\\nThank you,\\nE.I",
                "codeTag": "Unknown"
            },
            {
                "id": 1122704,
                "title": "vowel-spellchecker-faster-than-100-golang",
                "content": "```\\nfunc lowerAndRemoveVowels(word string) string {\\n\\tword = strings.ToLower(word)\\n\\tword = strings.ReplaceAll(word, \"a\", \"*\")\\n\\tword = strings.ReplaceAll(word, \"e\", \"*\")\\n\\tword = strings.ReplaceAll(word, \"i\", \"*\")\\n\\tword = strings.ReplaceAll(word, \"o\", \"*\")\\n\\tword = strings.ReplaceAll(word, \"u\", \"*\")\\n\\treturn word\\n}\\n\\nfunc spellchecker(wordlist []string, queries []string) []string {\\n\\twordsMap := make(map[string]bool)\\n\\twordsLowerMap := make(map[string]string)\\n\\twordsLARVMap := make(map[string]string)\\n\\tfor _, word := range wordlist {\\n\\t\\twordsMap[word] = true\\n\\t\\tlowerStr := strings.ToLower(word)\\n\\t\\twordsLARVStr := lowerAndRemoveVowels(word)\\n\\t\\tif _, ok := wordsLowerMap[lowerStr]; !ok {\\n\\t\\t\\twordsLowerMap[strings.ToLower(word)] = word\\n\\t\\t}\\n\\t\\tif _, ok := wordsLARVMap[wordsLARVStr]; !ok {\\n\\t\\t\\twordsLARVMap[wordsLARVStr] = word\\n\\t\\t}\\n\\t}\\n\\tret := make([]string, 0)\\n\\tfor _, query := range queries {\\n\\t\\tvar answer string\\n\\t\\tfound := false\\n\\t\\tif wordsMap[query] {\\n\\t\\t\\tfound = true\\n\\t\\t\\tanswer = query\\n\\t\\t}\\n\\t\\tif !found {\\n\\t\\t\\tlowerCaseQuery := strings.ToLower(query)\\n\\t\\t\\tanswer, found = wordsLowerMap[lowerCaseQuery]\\n\\t\\t}\\n\\t\\tif !found {\\n\\t\\t\\tnoVowelsQuery := lowerAndRemoveVowels(query)\\n\\t\\t\\tanswer, found = wordsLARVMap[noVowelsQuery]\\n\\t\\t}\\n\\t\\tif !found {\\n\\t\\t\\tanswer = \"\"\\n\\t\\t}\\n\\t\\tret = append(ret, answer)\\n\\t}\\n\\treturn ret\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc lowerAndRemoveVowels(word string) string {\\n\\tword = strings.ToLower(word)\\n\\tword = strings.ReplaceAll(word, \"a\", \"*\")\\n\\tword = strings.ReplaceAll(word, \"e\", \"*\")\\n\\tword = strings.ReplaceAll(word, \"i\", \"*\")\\n\\tword = strings.ReplaceAll(word, \"o\", \"*\")\\n\\tword = strings.ReplaceAll(word, \"u\", \"*\")\\n\\treturn word\\n}\\n\\nfunc spellchecker(wordlist []string, queries []string) []string {\\n\\twordsMap := make(map[string]bool)\\n\\twordsLowerMap := make(map[string]string)\\n\\twordsLARVMap := make(map[string]string)\\n\\tfor _, word := range wordlist {\\n\\t\\twordsMap[word] = true\\n\\t\\tlowerStr := strings.ToLower(word)\\n\\t\\twordsLARVStr := lowerAndRemoveVowels(word)\\n\\t\\tif _, ok := wordsLowerMap[lowerStr]; !ok {\\n\\t\\t\\twordsLowerMap[strings.ToLower(word)] = word\\n\\t\\t}\\n\\t\\tif _, ok := wordsLARVMap[wordsLARVStr]; !ok {\\n\\t\\t\\twordsLARVMap[wordsLARVStr] = word\\n\\t\\t}\\n\\t}\\n\\tret := make([]string, 0)\\n\\tfor _, query := range queries {\\n\\t\\tvar answer string\\n\\t\\tfound := false\\n\\t\\tif wordsMap[query] {\\n\\t\\t\\tfound = true\\n\\t\\t\\tanswer = query\\n\\t\\t}\\n\\t\\tif !found {\\n\\t\\t\\tlowerCaseQuery := strings.ToLower(query)\\n\\t\\t\\tanswer, found = wordsLowerMap[lowerCaseQuery]\\n\\t\\t}\\n\\t\\tif !found {\\n\\t\\t\\tnoVowelsQuery := lowerAndRemoveVowels(query)\\n\\t\\t\\tanswer, found = wordsLARVMap[noVowelsQuery]\\n\\t\\t}\\n\\t\\tif !found {\\n\\t\\t\\tanswer = \"\"\\n\\t\\t}\\n\\t\\tret = append(ret, answer)\\n\\t}\\n\\treturn ret\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1122680,
                "title": "92-faster-time-o-n-m-space-o-n-soln-using-hashtables",
                "content": "```\\npublic class Solution {\\n    HashSet<String> words_perfect;\\n    Dictionary<String, String> words_cap;\\n    Dictionary<String, String> words_vow;\\n    StringBuilder sb;\\n    \\n    // Time = O(n+m) || Space = O(n), n = no of words in \\'wordlist\\' & m = no of words in \\'queries\\'\\n    public string[] Spellchecker(string[] wordlist, string[] queries) {\\n        words_perfect = new HashSet<String>();\\n        words_cap = new Dictionary<String, String>();\\n        words_vow = new Dictionary<String, String>();\\n        sb = new StringBuilder();\\n        string lower, vowelLess;\\n\\n        // Fill respective Dictionary\\n        for (int i = 0; i < wordlist.Length; i++)\\n        {\\n            words_perfect.Add(wordlist[i]);\\n\\n            lower = wordlist[i].ToLower();\\n            if (!words_cap.ContainsKey(lower))\\n                words_cap.Add(lower, wordlist[i]);\\n\\n            vowelLess = DeVowel(lower);\\n            if (!words_vow.ContainsKey(vowelLess))\\n                words_vow.Add(vowelLess, wordlist[i]);\\n        }\\n\\n        string[] ans = new string[queries.Length];\\n        // Find Matching word for each query\\n        for (int i = 0; i < queries.Length; i++)\\n            ans[i] = GetMatch(queries[i]);\\n\\n        return ans;\\n\\n        // Local Func\\n        // Time O(l), l = len of \\'str\\'\\n        string DeVowel(string str)\\n        {\\n            sb.Clear();\\n            foreach (var ch in str)\\n                sb.Append(IsVowel(ch) ? \\'*\\' : ch);\\n            return sb.ToString();\\n        }\\n\\n        // Time O(1)\\n        bool IsVowel(char ch) => ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\';\\n\\n        // Time O(1)\\n        string GetMatch(string toSearch)\\n        {\\n            // Case 1: excat match\\n            if (words_perfect.Contains(toSearch))\\n                return toSearch;\\n\\n            // Case 2: Cap mis-match\\n            lower = toSearch.ToLower();\\n            if (words_cap.ContainsKey(lower))\\n                return words_cap[lower];\\n\\n            // Case 3: Vowel mis-match\\n            vowelLess = DeVowel(lower);\\n            if (words_vow.ContainsKey(vowelLess))\\n                return words_vow[vowelLess];\\n\\n            // Deafult case: Return empty string\\n            return \"\";\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\npublic class Solution {\\n    HashSet<String> words_perfect;\\n    Dictionary<String, String> words_cap;\\n    Dictionary<String, String> words_vow;\\n    StringBuilder sb;\\n    \\n    // Time = O(n+m) || Space = O(n), n = no of words in \\'wordlist\\' & m = no of words in \\'queries\\'\\n    public string[] Spellchecker(string[] wordlist, string[] queries) {\\n        words_perfect = new HashSet<String>();\\n        words_cap = new Dictionary<String, String>();\\n        words_vow = new Dictionary<String, String>();\\n        sb = new StringBuilder();\\n        string lower, vowelLess;\\n\\n        // Fill respective Dictionary\\n        for (int i = 0; i < wordlist.Length; i++)\\n        {\\n            words_perfect.Add(wordlist[i]);\\n\\n            lower = wordlist[i].ToLower();\\n            if (!words_cap.ContainsKey(lower))\\n                words_cap.Add(lower, wordlist[i]);\\n\\n            vowelLess = DeVowel(lower);\\n            if (!words_vow.ContainsKey(vowelLess))\\n                words_vow.Add(vowelLess, wordlist[i]);\\n        }\\n\\n        string[] ans = new string[queries.Length];\\n        // Find Matching word for each query\\n        for (int i = 0; i < queries.Length; i++)\\n            ans[i] = GetMatch(queries[i]);\\n\\n        return ans;\\n\\n        // Local Func\\n        // Time O(l), l = len of \\'str\\'\\n        string DeVowel(string str)\\n        {\\n            sb.Clear();\\n            foreach (var ch in str)\\n                sb.Append(IsVowel(ch) ? \\'*\\' : ch);\\n            return sb.ToString();\\n        }\\n\\n        // Time O(1)\\n        bool IsVowel(char ch) => ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\';\\n\\n        // Time O(1)\\n        string GetMatch(string toSearch)\\n        {\\n            // Case 1: excat match\\n            if (words_perfect.Contains(toSearch))\\n                return toSearch;\\n\\n            // Case 2: Cap mis-match\\n            lower = toSearch.ToLower();\\n            if (words_cap.ContainsKey(lower))\\n                return words_cap[lower];\\n\\n            // Case 3: Vowel mis-match\\n            vowelLess = DeVowel(lower);\\n            if (words_vow.ContainsKey(vowelLess))\\n                return words_vow[vowelLess];\\n\\n            // Deafult case: Return empty string\\n            return \"\";\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122640,
                "title": "rust-intuitive-solution-with-hashmap-and-hashset-36ms",
                "content": "```rust\\nuse std::collections::{HashMap, HashSet};\\n\\nimpl Solution {\\n    pub fn spellchecker(wordlist: Vec<String>, queries: Vec<String>) -> Vec<String> {\\n        // first rule : case-sensitive match\\n        let wordset: HashSet<String> = wordlist.iter().cloned().collect();\\n        // second rule : case-insensitive match\\n        let mut dict_case: HashMap<String, String> = HashMap::new();\\n        for s in wordlist.iter() {\\n            dict_case.entry(s.to_lowercase()).or_insert(s.clone());\\n        }\\n        // third rule : vowel-ignoring match\\n        fn to_key(s: &String) -> String {\\n            let mut key = String::new();\\n            let lower_s = s.to_lowercase();\\n            let vowels = [\\'a\\', \\'e\\', \\'o\\', \\'i\\', \\'u\\'];\\n            for c in lower_s.chars() {\\n                if vowels.contains(&c) {\\n                    key.push(\\'-\\');\\n                } else {\\n                    key.push(c);\\n                }\\n            }\\n            key\\n        }\\n        let mut dict_vowel: HashMap<String, String> = HashMap::new();\\n        for s in wordlist.iter() {\\n            dict_vowel.entry(to_key(s)).or_insert(s.clone());\\n        }\\n\\n        // start matching\\n        let mut ans: Vec<String> = vec![];\\n        for s in queries.iter() {\\n            if wordset.contains(s) {\\n                ans.push(s.clone());\\n            } else if dict_case.contains_key(&s.to_lowercase()) {\\n                ans.push(dict_case.get(&s.to_lowercase()).unwrap().clone());\\n            } else if dict_vowel.contains_key(&to_key(s)) {\\n                ans.push(dict_vowel.get(&to_key(s)).unwrap().clone());\\n            } else {\\n                ans.push(String::new());\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::{HashMap, HashSet};\\n\\nimpl Solution {\\n    pub fn spellchecker(wordlist: Vec<String>, queries: Vec<String>) -> Vec<String> {\\n        // first rule : case-sensitive match\\n        let wordset: HashSet<String> = wordlist.iter().cloned().collect();\\n        // second rule : case-insensitive match\\n        let mut dict_case: HashMap<String, String> = HashMap::new();\\n        for s in wordlist.iter() {\\n            dict_case.entry(s.to_lowercase()).or_insert(s.clone());\\n        }\\n        // third rule : vowel-ignoring match\\n        fn to_key(s: &String) -> String {\\n            let mut key = String::new();\\n            let lower_s = s.to_lowercase();\\n            let vowels = [\\'a\\', \\'e\\', \\'o\\', \\'i\\', \\'u\\'];\\n            for c in lower_s.chars() {\\n                if vowels.contains(&c) {\\n                    key.push(\\'-\\');\\n                } else {\\n                    key.push(c);\\n                }\\n            }\\n            key\\n        }\\n        let mut dict_vowel: HashMap<String, String> = HashMap::new();\\n        for s in wordlist.iter() {\\n            dict_vowel.entry(to_key(s)).or_insert(s.clone());\\n        }\\n\\n        // start matching\\n        let mut ans: Vec<String> = vec![];\\n        for s in queries.iter() {\\n            if wordset.contains(s) {\\n                ans.push(s.clone());\\n            } else if dict_case.contains_key(&s.to_lowercase()) {\\n                ans.push(dict_case.get(&s.to_lowercase()).unwrap().clone());\\n            } else if dict_vowel.contains_key(&to_key(s)) {\\n                ans.push(dict_vowel.get(&to_key(s)).unwrap().clone());\\n            } else {\\n                ans.push(String::new());\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1122634,
                "title": "c-solution-beats-100-using-hashmap",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int getdiff(string& word, string& query)\\n    {\\n        int diff = 0;\\n        for(int i=0; i<word.length(); i++)\\n        {\\n            if(word[i]!=query[i])\\n            {\\n                if(tolower(word[i])==tolower(query[i]))\\n                {\\n                    diff+=1;\\n                }\\n                else\\n                    diff+=100;\\n            }\\n        }\\n        return diff;\\n        \\n    }\\n    string getcode(string& word)\\n    {\\n        string s = word;\\n            for(int j=0; j<s.length(); j++)\\n            {\\n                s[j] = tolower(s[j]);\\n                switch(s[j])\\n                {\\n                    case \\'a\\':\\n                    case \\'e\\':\\n                    case \\'i\\':\\n                    case \\'o\\':\\n                    case \\'u\\': s[j] = \\'*\\';\\n                }\\n                \\n            }\\n        return s;\\n    }\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        unordered_map<string, vector<int>> m;\\n        for(int i=0; i<wordlist.size(); i++)\\n        {\\n            string s = getcode(wordlist[i]);\\n            if(m.find(s)==m.end())\\n                m[s] = vector<int> (0);\\n            m[s].push_back(i);\\n        }\\n        vector<string> ans(queries.size(), \"\");\\n        for(int i=0; i<queries.size(); i++)\\n        {\\n            string s = getcode(queries[i]);\\n            \\n\\t\\t\\tif(m.find(s)!=m.end())\\n            {\\n               \\n\\t\\t\\t   int one=-1, two = -1, three = -1;\\n\\t\\t\\t   \\n\\t\\t\\t   //case one: exact match\\n\\t\\t\\t   //case two: capitlization\\n\\t\\t\\t   //case three: vowel errors\\n                for(int j=0; j<m[s].size(); j++)\\n                {\\n                    int diff = getdiff(wordlist[m[s][j]], queries[i]);\\n                    if(diff==0)\\n                    {\\n                        one = j;\\n                        break;\\n                    }\\n                    else if(two==-1&&diff<100)\\n                    {\\n                        two = j;\\n                    }\\n                    else if(three==-1&&diff>=100)\\n                    {\\n                        three = j;\\n                    }\\n\\t\\t\\t\\t\\t\\n                }\\n                \\n                if(one!=-1)\\n                    ans[i] = wordlist[m[s][one]];\\n                else if(two!=-1)\\n                    ans[i]= wordlist[m[s][two]];\\n                else\\n                    ans[i]= wordlist[m[s][three]];\\n               \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int getdiff(string& word, string& query)\\n    {\\n        int diff = 0;\\n        for(int i=0; i<word.length(); i++)\\n        {\\n            if(word[i]!=query[i])\\n            {\\n                if(tolower(word[i])==tolower(query[i]))\\n                {\\n                    diff+=1;\\n                }\\n                else\\n                    diff+=100;\\n            }\\n        }\\n        return diff;\\n        \\n    }\\n    string getcode(string& word)\\n    {\\n        string s = word;\\n            for(int j=0; j<s.length(); j++)\\n            {\\n                s[j] = tolower(s[j]);\\n                switch(s[j])\\n                {\\n                    case \\'a\\':\\n                    case \\'e\\':\\n                    case \\'i\\':\\n                    case \\'o\\':\\n                    case \\'u\\': s[j] = \\'*\\';\\n                }\\n                \\n            }\\n        return s;\\n    }\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        unordered_map<string, vector<int>> m;\\n        for(int i=0; i<wordlist.size(); i++)\\n        {\\n            string s = getcode(wordlist[i]);\\n            if(m.find(s)==m.end())\\n                m[s] = vector<int> (0);\\n            m[s].push_back(i);\\n        }\\n        vector<string> ans(queries.size(), \"\");\\n        for(int i=0; i<queries.size(); i++)\\n        {\\n            string s = getcode(queries[i]);\\n            \\n\\t\\t\\tif(m.find(s)!=m.end())\\n            {\\n               \\n\\t\\t\\t   int one=-1, two = -1, three = -1;\\n\\t\\t\\t   \\n\\t\\t\\t   //case one: exact match\\n\\t\\t\\t   //case two: capitlization\\n\\t\\t\\t   //case three: vowel errors\\n                for(int j=0; j<m[s].size(); j++)\\n                {\\n                    int diff = getdiff(wordlist[m[s][j]], queries[i]);\\n                    if(diff==0)\\n                    {\\n                        one = j;\\n                        break;\\n                    }\\n                    else if(two==-1&&diff<100)\\n                    {\\n                        two = j;\\n                    }\\n                    else if(three==-1&&diff>=100)\\n                    {\\n                        three = j;\\n                    }\\n\\t\\t\\t\\t\\t\\n                }\\n                \\n                if(one!=-1)\\n                    ans[i] = wordlist[m[s][one]];\\n                else if(two!=-1)\\n                    ans[i]= wordlist[m[s][two]];\\n                else\\n                    ans[i]= wordlist[m[s][three]];\\n               \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122594,
                "title": "cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> spellchecker(vector<string>& W, vector<string>& Q) {\\n        set<string> orig (W.begin(), W.end());\\n        unordered_map<string, string> lower, mask;\\n        for (int i = W.size() - 1; ~i; i--) {\\n            string word = W[i], wlow = lcase(word);\\n            lower[wlow] = word, mask[vmask(wlow)] = word;\\n        }\\n        for (string &query : Q) {\\n            string qlow = lcase(query), qmask = vmask(qlow);\\n            if (orig.count(query)) continue;\\n            else if (lower.count(qlow)) query = lower[qlow];\\n            else if (mask.count(qmask)) query = mask[qmask];\\n            else query = \"\";\\n        }\\n        return Q;\\n    }\\n    static string vmask(string str) {\\n        for (char &c : str)\\n            if (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')\\n                c = \\'*\\';\\n        return str;\\n    }\\n    static string lcase(string str) {\\n        for (char &c : str) c = tolower(c);\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> spellchecker(vector<string>& W, vector<string>& Q) {\\n        set<string> orig (W.begin(), W.end());\\n        unordered_map<string, string> lower, mask;\\n        for (int i = W.size() - 1; ~i; i--) {\\n            string word = W[i], wlow = lcase(word);\\n            lower[wlow] = word, mask[vmask(wlow)] = word;\\n        }\\n        for (string &query : Q) {\\n            string qlow = lcase(query), qmask = vmask(qlow);\\n            if (orig.count(query)) continue;\\n            else if (lower.count(qlow)) query = lower[qlow];\\n            else if (mask.count(qmask)) query = mask[qmask];\\n            else query = \"\";\\n        }\\n        return Q;\\n    }\\n    static string vmask(string str) {\\n        for (char &c : str)\\n            if (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')\\n                c = \\'*\\';\\n        return str;\\n    }\\n    static string lcase(string str) {\\n        for (char &c : str) c = tolower(c);\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122584,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    unordered_set<string> perfectWords;\\n    unordered_map<string, string> wordsCap;\\n    unordered_map<string, string> wordsVow;\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        for(string &word: wordlist){\\n            perfectWords.insert(word);\\n            \\n            string lowerCasedWord   = lowercase(word);\\n            wordsCap.insert({lowerCasedWord, word});\\n            \\n            string lowerCasedWordDV = devowel(lowerCasedWord);\\n            wordsVow.insert({lowerCasedWordDV, word});\\n        }\\n        \\n        vector<string> result(queries.size());\\n        int index = 0;\\n        for(string &query : queries)\\n            result.at(index++) = solve(query);\\n        \\n        return result;\\n    }\\n    \\n    string solve(string query){\\n        if(perfectWords.find(query) != perfectWords.end())\\n            return query;\\n        \\n        string queryLower = lowercase(query);\\n        if(wordsCap.find(queryLower) != wordsCap.end())\\n            return wordsCap.at(queryLower);\\n        \\n        string queryLowerDV = devowel(queryLower);\\n        if(wordsVow.find(queryLowerDV) != wordsVow.end())\\n            return wordsVow.at(queryLowerDV);\\n        \\n        return \"\";\\n    }\\n    \\n    string lowercase(string word){\\n        string lowercased = word;\\n        for(char &val : lowercased)\\n            val = tolower(val);\\n        \\n        return lowercased;\\n    }\\n    \\n    string devowel(string word){\\n        string devoweled;\\n        for(char &val : word)\\n            devoweled.push_back(isVowel(val) ? \\'*\\' : val);\\n        \\n        return devoweled;\\n    }\\n    \\n    bool isVowel(char val){\\n        return (val == \\'a\\' || val == \\'e\\' || val == \\'i\\' || val == \\'o\\' || val == \\'u\\');\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    unordered_set<string> perfectWords;\\n    unordered_map<string, string> wordsCap;\\n    unordered_map<string, string> wordsVow;\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        for(string &word: wordlist){\\n            perfectWords.insert(word);\\n            \\n            string lowerCasedWord   = lowercase(word);\\n            wordsCap.insert({lowerCasedWord, word});\\n            \\n            string lowerCasedWordDV = devowel(lowerCasedWord);\\n            wordsVow.insert({lowerCasedWordDV, word});\\n        }\\n        \\n        vector<string> result(queries.size());\\n        int index = 0;\\n        for(string &query : queries)\\n            result.at(index++) = solve(query);\\n        \\n        return result;\\n    }\\n    \\n    string solve(string query){\\n        if(perfectWords.find(query) != perfectWords.end())\\n            return query;\\n        \\n        string queryLower = lowercase(query);\\n        if(wordsCap.find(queryLower) != wordsCap.end())\\n            return wordsCap.at(queryLower);\\n        \\n        string queryLowerDV = devowel(queryLower);\\n        if(wordsVow.find(queryLowerDV) != wordsVow.end())\\n            return wordsVow.at(queryLowerDV);\\n        \\n        return \"\";\\n    }\\n    \\n    string lowercase(string word){\\n        string lowercased = word;\\n        for(char &val : lowercased)\\n            val = tolower(val);\\n        \\n        return lowercased;\\n    }\\n    \\n    string devowel(string word){\\n        string devoweled;\\n        for(char &val : word)\\n            devoweled.push_back(isVowel(val) ? \\'*\\' : val);\\n        \\n        return devoweled;\\n    }\\n    \\n    bool isVowel(char val){\\n        return (val == \\'a\\' || val == \\'e\\' || val == \\'i\\' || val == \\'o\\' || val == \\'u\\');\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122574,
                "title": "c-three-hash-map-solution-with-explanations",
                "content": "**Key points:**\\n* I was trying to do pair wise compare but got a humiliating Time Limit Exceeded.\\n* This hurts my feelings. Don\\'t care about saving memory any more. Just want to see how fast we can go.\\n* Build 3 lookup map from three flavors of strings, one original, one in lower case and one replace all vowels with space so that I can do \"vowel insensitive\" compare.\\n* Look up in three maps in the order required. It gets pretty boring quickly.\\n* Result was ok, run a few times and the best was 48 ms\\t32.9 MB. Surprisingly memory situation wasn\\'t that bad.\\n* Don\\'t do string to string mapping, map to index in array should save some memory.\\n* Saw another post\\'s title, yes indeed the original doesn\\'t need to be a map. A hashset will do the job fine since we are just sending the same string back anyway. This improved memory situation to 31.7MB.\\n```\\n  vector<string> spellchecker(const vector<string> & wordlist,\\n                              const vector<string> & queries) {\\n    unordered_set<string> original;\\n    unordered_map<string, int> lower;\\n    unordered_map<string, int> vowel;\\n    string tmp1;\\n    string tmp2;\\n    string vowels(\"aeiou\");\\n    for (int i=0; i<wordlist.size(); ++i) {\\n      original.insert(wordlist[i]);\\n      tmp1 = wordlist[i];\\n      tmp2 = wordlist[i];\\n      for (int i = 0; i<tmp1.size(); ++i) {\\n        tmp1[i] = std::tolower(tmp1[i]);\\n        if (vowels.find(tmp1[i]) == std::string::npos)\\n          tmp2[i] = tmp1[i];\\n        else\\n          tmp2[i] = \\' \\';\\n      }\\n      lower.insert({tmp1, i});\\n      vowel.insert({tmp2, i});\\n    }\\n    \\n    vector<string> ret(queries.size());\\n    for (int i=0; i<queries.size(); ++i) {\\n      if (original.find(queries[i]) != original.end())\\n        ret[i] = queries[i];\\n      else {\\n        tmp1 = queries[i];\\n        for (int i = 0; i<tmp1.size(); ++i)\\n          tmp1[i] = std::tolower(tmp1[i]);\\n        auto itor = lower.find(tmp1);\\n        if (itor != lower.end())\\n          ret[i] = wordlist[itor->second];\\n        else {\\n          for (int i = 0; i<tmp1.size(); ++i)\\n            if (vowels.find(tmp1[i]) != std::string::npos)\\n              tmp1[i] = \\' \\';\\n          itor = vowel.find(tmp1);\\n          if (itor != vowel.end())\\n            ret[i] = wordlist[itor->second];\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  vector<string> spellchecker(const vector<string> & wordlist,\\n                              const vector<string> & queries) {\\n    unordered_set<string> original;\\n    unordered_map<string, int> lower;\\n    unordered_map<string, int> vowel;\\n    string tmp1;\\n    string tmp2;\\n    string vowels(\"aeiou\");\\n    for (int i=0; i<wordlist.size(); ++i) {\\n      original.insert(wordlist[i]);\\n      tmp1 = wordlist[i];\\n      tmp2 = wordlist[i];\\n      for (int i = 0; i<tmp1.size(); ++i) {\\n        tmp1[i] = std::tolower(tmp1[i]);\\n        if (vowels.find(tmp1[i]) == std::string::npos)\\n          tmp2[i] = tmp1[i];\\n        else\\n          tmp2[i] = \\' \\';\\n      }\\n      lower.insert({tmp1, i});\\n      vowel.insert({tmp2, i});\\n    }\\n    \\n    vector<string> ret(queries.size());\\n    for (int i=0; i<queries.size(); ++i) {\\n      if (original.find(queries[i]) != original.end())\\n        ret[i] = queries[i];\\n      else {\\n        tmp1 = queries[i];\\n        for (int i = 0; i<tmp1.size(); ++i)\\n          tmp1[i] = std::tolower(tmp1[i]);\\n        auto itor = lower.find(tmp1);\\n        if (itor != lower.end())\\n          ret[i] = wordlist[itor->second];\\n        else {\\n          for (int i = 0; i<tmp1.size(); ++i)\\n            if (vowels.find(tmp1[i]) != std::string::npos)\\n              tmp1[i] = \\' \\';\\n          itor = vowel.find(tmp1);\\n          if (itor != vowel.end())\\n            ret[i] = wordlist[itor->second];\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1122503,
                "title": "ruby-solution",
                "content": "```\\ndef spellchecker(wordlist, queries)\\n  words_exact = {}\\n  words_nocase = {}\\n  words_novowel = {}\\n  \\n  wordlist.each do |word|\\n    words_exact[word] = word\\n    words_nocase[word.downcase] ||= word\\n    words_novowel[word.downcase.gsub(/[aeiou]/, \\'_\\')] ||= word\\n  end\\n  \\n  queries.collect do |query|\\n    if words_exact[query]\\n      words_exact[query]\\n      \\n    elsif words_nocase[query.downcase]\\n      words_nocase[query.downcase]\\n      \\n    elsif words_novowel[query.downcase.gsub(/[aeiou]/, \\'_\\')]\\n      words_novowel[query.downcase.gsub(/[aeiou]/, \\'_\\')]\\n      \\n    else\\n      \\'\\'\\n    end\\n  end\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef spellchecker(wordlist, queries)\\n  words_exact = {}\\n  words_nocase = {}\\n  words_novowel = {}\\n  \\n  wordlist.each do |word|\\n    words_exact[word] = word\\n    words_nocase[word.downcase] ||= word\\n    words_novowel[word.downcase.gsub(/[aeiou]/, \\'_\\')] ||= word\\n  end\\n  \\n  queries.collect do |query|\\n    if words_exact[query]\\n      words_exact[query]\\n      \\n    elsif words_nocase[query.downcase]\\n      words_nocase[query.downcase]\\n      \\n    elsif words_novowel[query.downcase.gsub(/[aeiou]/, \\'_\\')]\\n      words_novowel[query.downcase.gsub(/[aeiou]/, \\'_\\')]\\n      \\n    else\\n      \\'\\'\\n    end\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1122502,
                "title": "c-1-set-2-maps-yellow-yellow-y-ll-w",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        unordered_set<string> wordset(wordlist.begin(), wordlist.end());\\n        unordered_map<string, vector<string>> case_insensitives;\\n        unordered_map<string, vector<string>> vowel_errors;\\n        \\n        for (const auto& word: wordlist) {\\n            case_insensitives[to_case_insensitive(word)].push_back(word);\\n            vowel_errors[to_vowel_error(word)].push_back(word);\\n        }\\n        \\n        vector<string> answer;\\n        for (const auto& query: queries) {\\n            if (wordset.find(query) != wordset.end()) {\\n                answer.push_back(query);\\n                continue;\\n            }\\n            auto case_insensitive = to_case_insensitive(query);\\n            if (case_insensitives.find(case_insensitive) != case_insensitives.end()) {\\n                answer.push_back(case_insensitives[case_insensitive][0]);\\n                continue;\\n            }\\n            auto vowel_error = to_vowel_error(query);\\n            if (vowel_errors.find(vowel_error) != vowel_errors.end()) {\\n                answer.push_back(vowel_errors[vowel_error][0]);\\n                continue;\\n            }\\n            answer.push_back(\"\");\\n        }\\n        return answer;\\n    }\\n    \\nprivate:\\n    string to_case_insensitive(string s) {\\n        for (auto& c: s) {\\n            c = tolower(c);\\n        }\\n        return s;\\n    }\\n    \\n    string to_vowel_error(string s) {\\n        for (auto& c: s) {\\n            c = tolower(c);\\n            if (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\') {\\n                c = \\'*\\';\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        unordered_set<string> wordset(wordlist.begin(), wordlist.end());\\n        unordered_map<string, vector<string>> case_insensitives;\\n        unordered_map<string, vector<string>> vowel_errors;\\n        \\n        for (const auto& word: wordlist) {\\n            case_insensitives[to_case_insensitive(word)].push_back(word);\\n            vowel_errors[to_vowel_error(word)].push_back(word);\\n        }\\n        \\n        vector<string> answer;\\n        for (const auto& query: queries) {\\n            if (wordset.find(query) != wordset.end()) {\\n                answer.push_back(query);\\n                continue;\\n            }\\n            auto case_insensitive = to_case_insensitive(query);\\n            if (case_insensitives.find(case_insensitive) != case_insensitives.end()) {\\n                answer.push_back(case_insensitives[case_insensitive][0]);\\n                continue;\\n            }\\n            auto vowel_error = to_vowel_error(query);\\n            if (vowel_errors.find(vowel_error) != vowel_errors.end()) {\\n                answer.push_back(vowel_errors[vowel_error][0]);\\n                continue;\\n            }\\n            answer.push_back(\"\");\\n        }\\n        return answer;\\n    }\\n    \\nprivate:\\n    string to_case_insensitive(string s) {\\n        for (auto& c: s) {\\n            c = tolower(c);\\n        }\\n        return s;\\n    }\\n    \\n    string to_vowel_error(string s) {\\n        for (auto& c: s) {\\n            c = tolower(c);\\n            if (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\') {\\n                c = \\'*\\';\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122498,
                "title": "python-easy-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n\\t\\t\\tcheck = set()\\n\\t\\t\\tlowerCase = {}\\n\\t\\t\\tvowerErrors = {}\\n\\t\\t\\tvowel = \"aeiou\"\\n\\t\\t\\tres = [\"\"] * len(queries)\\n\\t\\t\\tfor word in wordlist:\\n\\t\\t\\t\\tcheck.add(word)\\n\\t\\t\\t\\tif word.lower() not in lowerCase:\\n\\t\\t\\t\\t\\tlowerCase[word.lower()] = word\\n\\t\\t\\t\\ts = \"\"\\n\\t\\t\\t\\tfor c in word.lower():\\n\\t\\t\\t\\t\\tif c not in vowel:\\n\\t\\t\\t\\t\\t\\ts += c\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\ts += \"?\"\\n\\t\\t\\t\\tif s not in vowerErrors:\\n\\t\\t\\t\\t\\tvowerErrors[s] = word\\n\\t\\t\\tfor i, query in enumerate(queries):   \\n\\t\\t\\t\\tif query in check:\\n\\t\\t\\t\\t\\tres[i] = query\\n\\t\\t\\t\\telif query.lower() in lowerCase:\\n\\t\\t\\t\\t\\tres[i] = lowerCase[query.lower()]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ts = \"\"\\n\\t\\t\\t\\t\\tfor c in query.lower():\\n\\t\\t\\t\\t\\t\\tif c not in vowel:\\n\\t\\t\\t\\t\\t\\t\\ts += c\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\ts += \"?\"\\n\\t\\t\\t\\t\\tif s in vowerErrors:\\n\\t\\t\\t\\t\\t\\tres[i] = vowerErrors[s]\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n\\t\\t\\tcheck = set()\\n\\t\\t\\tlowerCase = {}",
                "codeTag": "Java"
            },
            {
                "id": 1122497,
                "title": "c-multiple-hashmap-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, string> ordered;\\n    unordered_map<string, unordered_set<string>> existed;\\n    unordered_map<string, int> pos;\\n    \\n    string toLower(string s){\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i] >= \\'A\\' && s[i] <= \\'Z\\'){\\n                s[i] = s[i] - \\'A\\' + \\'a\\';\\n            }\\n        }\\n        return s;\\n    }\\n    void func(string& ans, int& pos2, string input, int ptr){\\n        if(ptr == input.size()){\\n            if(ordered.count(input)){\\n                if(pos[ordered[input]] < pos2){\\n                    pos2 = pos[ordered[input]];\\n                    ans = ordered[input];\\n                }\\n            }\\n        }\\n        else{\\n            if(input[ptr] == \\'a\\' || input[ptr] == \\'e\\' || input[ptr] == \\'i\\' || input[ptr] == \\'o\\' || input[ptr] == \\'u\\'){\\n                input[ptr] = \\'a\\';\\n                func(ans, pos2, input, ptr+1);\\n                input[ptr] = \\'e\\';\\n                func(ans, pos2, input, ptr+1);\\n                input[ptr] = \\'i\\';\\n                func(ans, pos2, input, ptr+1);\\n                input[ptr] = \\'o\\';\\n                func(ans, pos2, input, ptr+1);\\n                input[ptr] = \\'u\\';\\n                func(ans, pos2, input, ptr+1);\\n            }\\n            else func(ans, pos2, input, ptr+1);\\n        }\\n    }\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        \\n        \\n        for(int i=0; i<wordlist.size(); i++){\\n            if(pos.count(wordlist[i]) == 0)pos[wordlist[i]] = i;\\n            string toL = toLower(wordlist[i]);\\n            if(existed.count(toL) == 0){\\n\\n                existed[toL].insert(wordlist[i]);\\n                ordered[toL] = wordlist[i];\\n            }\\n            else{\\n                existed[toL].insert(wordlist[i]);\\n            }\\n        }\\n        vector<string> ret;\\n        for(int i=0; i<queries.size(); i++){\\n            string toL = toLower(queries[i]);\\n            if(existed.count(toL)){\\n                if(existed[toL].count(queries[i]))ret.push_back(queries[i]);\\n                else ret.push_back(ordered[toL]);\\n            }\\n            else{\\n                string ans = \"\";\\n                int pos2 = INT_MAX;\\n                func(ans, pos2, toL, 0);\\n                ret.push_back(ans);\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, string> ordered;\\n    unordered_map<string, unordered_set<string>> existed;\\n    unordered_map<string, int> pos;\\n    \\n    string toLower(string s){\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i] >= \\'A\\' && s[i] <= \\'Z\\'){\\n                s[i] = s[i] - \\'A\\' + \\'a\\';\\n            }\\n        }\\n        return s;\\n    }\\n    void func(string& ans, int& pos2, string input, int ptr){\\n        if(ptr == input.size()){\\n            if(ordered.count(input)){\\n                if(pos[ordered[input]] < pos2){\\n                    pos2 = pos[ordered[input]];\\n                    ans = ordered[input];\\n                }\\n            }\\n        }\\n        else{\\n            if(input[ptr] == \\'a\\' || input[ptr] == \\'e\\' || input[ptr] == \\'i\\' || input[ptr] == \\'o\\' || input[ptr] == \\'u\\'){\\n                input[ptr] = \\'a\\';\\n                func(ans, pos2, input, ptr+1);\\n                input[ptr] = \\'e\\';\\n                func(ans, pos2, input, ptr+1);\\n                input[ptr] = \\'i\\';\\n                func(ans, pos2, input, ptr+1);\\n                input[ptr] = \\'o\\';\\n                func(ans, pos2, input, ptr+1);\\n                input[ptr] = \\'u\\';\\n                func(ans, pos2, input, ptr+1);\\n            }\\n            else func(ans, pos2, input, ptr+1);\\n        }\\n    }\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        \\n        \\n        for(int i=0; i<wordlist.size(); i++){\\n            if(pos.count(wordlist[i]) == 0)pos[wordlist[i]] = i;\\n            string toL = toLower(wordlist[i]);\\n            if(existed.count(toL) == 0){\\n\\n                existed[toL].insert(wordlist[i]);\\n                ordered[toL] = wordlist[i];\\n            }\\n            else{\\n                existed[toL].insert(wordlist[i]);\\n            }\\n        }\\n        vector<string> ret;\\n        for(int i=0; i<queries.size(); i++){\\n            string toL = toLower(queries[i]);\\n            if(existed.count(toL)){\\n                if(existed[toL].count(queries[i]))ret.push_back(queries[i]);\\n                else ret.push_back(ordered[toL]);\\n            }\\n            else{\\n                string ans = \"\";\\n                int pos2 = INT_MAX;\\n                func(ans, pos2, toL, 0);\\n                ret.push_back(ans);\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122461,
                "title": "go-three-hashmap-beat-100",
                "content": "```go\\nfunc spellchecker(wordlist []string, queries []string) []string {\\n    word_match := make(map[string]string)\\n    word_cap := make(map[string]string)\\n    word_vowel := make(map[string]string)\\n    \\n    for _, word := range wordlist {\\n        word_match[word] = word\\n        \\n        wordL := strings.ToLower(word)\\n        if _, ok := word_cap[wordL]; !ok {\\n            word_cap[wordL] = word\\n        }\\n        if _, ok := word_vowel[devowel(wordL)]; !ok {\\n            word_vowel[devowel(wordL)] = word\\n        }\\n    }\\n    \\n    ans := make([]string, len(queries))\\n    for idx, query := range queries {\\n        ans[idx] = solve(query, word_match, word_cap, word_vowel)\\n    }\\n    \\n    return ans\\n}\\n\\nfunc devowel(word string) string {\\n    res := make([]byte, len(word))\\n    for i:=0; i < len(word); i++ {\\n        ch := word[i]\\n        if ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\' {\\n            res[i] = \\'*\\'\\n        } else {\\n            res[i] = ch           \\n        }\\n    }\\n    return string(res)\\n}\\n\\nfunc solve(query string, word_match, word_cap, word_vowel map[string]string) string {\\n    \\n    if m, ok := word_match[query]; ok {\\n        return m\\n    }\\n    \\n    queryL := strings.ToLower(query)\\n    if m, ok := word_cap[queryL]; ok {\\n        return m\\n    }\\n    \\n    queryV := devowel(queryL)\\n    if m, ok := word_vowel[queryV]; ok {\\n        return m\\n    }\\n    \\n    return \"\"\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc spellchecker(wordlist []string, queries []string) []string {\\n    word_match := make(map[string]string)\\n    word_cap := make(map[string]string)\\n    word_vowel := make(map[string]string)\\n    \\n    for _, word := range wordlist {\\n        word_match[word] = word\\n        \\n        wordL := strings.ToLower(word)\\n        if _, ok := word_cap[wordL]; !ok {\\n            word_cap[wordL] = word\\n        }\\n        if _, ok := word_vowel[devowel(wordL)]; !ok {\\n            word_vowel[devowel(wordL)] = word\\n        }\\n    }\\n    \\n    ans := make([]string, len(queries))\\n    for idx, query := range queries {\\n        ans[idx] = solve(query, word_match, word_cap, word_vowel)\\n    }\\n    \\n    return ans\\n}\\n\\nfunc devowel(word string) string {\\n    res := make([]byte, len(word))\\n    for i:=0; i < len(word); i++ {\\n        ch := word[i]\\n        if ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\' {\\n            res[i] = \\'*\\'\\n        } else {\\n            res[i] = ch           \\n        }\\n    }\\n    return string(res)\\n}\\n\\nfunc solve(query string, word_match, word_cap, word_vowel map[string]string) string {\\n    \\n    if m, ok := word_match[query]; ok {\\n        return m\\n    }\\n    \\n    queryL := strings.ToLower(query)\\n    if m, ok := word_cap[queryL]; ok {\\n        return m\\n    }\\n    \\n    queryV := devowel(queryL)\\n    if m, ok := word_vowel[queryV]; ok {\\n        return m\\n    }\\n    \\n    return \"\"\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1122452,
                "title": "vowel-spellchecker",
                "content": "class Solution(object):\\n    def spellchecker(self, wordlist, queries):\\n        def devowel(word):\\n            return \"\".join(\\'*\\' if c in \\'aeiou\\' else c\\n                           for c in word)\\n\\n        words_perfect = set(wordlist)\\n        words_cap = {}\\n        words_vow = {}\\n\\n        for word in wordlist:\\n            wordlow = word.lower()\\n            words_cap.setdefault(wordlow, word)\\n            words_vow.setdefault(devowel(wordlow), word)\\n\\n        def solve(query):\\n            if query in words_perfect:\\n                return query\\n\\n            queryL = query.lower()\\n            if queryL in words_cap:\\n                return words_cap[queryL]\\n\\n            queryLV = devowel(queryL)\\n            if queryLV in words_vow:\\n                return words_vow[queryLV]\\n            return \"\"\\n\\n        return map(solve, queries)",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def spellchecker(self, wordlist, queries):\\n        def devowel(word):\\n            return \"\".join(\\'*\\' if c in \\'aeiou\\' else c\\n                           for c in word)\\n\\n        words_perfect = set(wordlist)\\n        words_cap = {}",
                "codeTag": "Java"
            },
            {
                "id": 1122428,
                "title": "simple-c-solution-with-2-hashmaps",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        map<string, vector<string>> m1;\\n        map<string, vector<string>> m2;\\n        vector<string> ans;\\n        for (const auto & i : wordlist)\\n        {\\n            string t = to_lower(i.c_str());\\n            //cout<<t<<\" \"<<i<<endl;\\n            m1[t].push_back(i);\\n        }\\n        for (const auto & i : wordlist)\\n        {\\n            string t = to_lower_add_underscore(i.c_str());\\n            //cout<<t<<\" \"<<i<<endl;\\n            m2[t].push_back(i);\\n        }\\n        for (const auto & i : queries)\\n        {\\n            string t = to_lower_add_underscore(i);\\n            //cout<<t<<endl;\\n            if (m2.find(t) == m2.end())\\n            {\\n                ans.push_back(\"\"); \\n            }\\n            else if (m1.find(to_lower(i)) != m1.end())\\n            {\\n                bool found = false;\\n                string t1 = to_lower(i);\\n                for (const auto & j : m1[t1])\\n                {\\n                    if (j == i)\\n                    {\\n                        ans.push_back(i);\\n                        found = true;\\n                        break;\\n                    }\\n                }\\n                if (!found)\\n                {\\n                    ans.push_back(m1[t1][0]);\\n                }\\n            }\\n            else\\n            {\\n                ans.push_back(m2[t][0]);\\n            }\\n        }\\n        return ans;\\n    }\\nprivate:\\n    string to_lower_add_underscore(string s)\\n    {\\n        std::transform(s.begin(), s.end(), s.begin(),\\n            [](unsigned char c){ \\n                c = tolower(c);\\n                if (c == \\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c ==\\'u\\')\\n                {\\n                    return (char)\\'_\\';\\n                }\\n                return (char)std::tolower(c); \\n            }\\n        );\\n        return s;\\n    }\\n    string to_lower(string s)\\n    {\\n        std::transform(s.begin(), s.end(), s.begin(),\\n            [](unsigned char c){ \\n                return (char)std::tolower(c); \\n            }\\n        );\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        map<string, vector<string>> m1;\\n        map<string, vector<string>> m2;\\n        vector<string> ans;\\n        for (const auto & i : wordlist)\\n        {\\n            string t = to_lower(i.c_str());\\n            //cout<<t<<\" \"<<i<<endl;\\n            m1[t].push_back(i);\\n        }\\n        for (const auto & i : wordlist)\\n        {\\n            string t = to_lower_add_underscore(i.c_str());\\n            //cout<<t<<\" \"<<i<<endl;\\n            m2[t].push_back(i);\\n        }\\n        for (const auto & i : queries)\\n        {\\n            string t = to_lower_add_underscore(i);\\n            //cout<<t<<endl;\\n            if (m2.find(t) == m2.end())\\n            {\\n                ans.push_back(\"\"); \\n            }\\n            else if (m1.find(to_lower(i)) != m1.end())\\n            {\\n                bool found = false;\\n                string t1 = to_lower(i);\\n                for (const auto & j : m1[t1])\\n                {\\n                    if (j == i)\\n                    {\\n                        ans.push_back(i);\\n                        found = true;\\n                        break;\\n                    }\\n                }\\n                if (!found)\\n                {\\n                    ans.push_back(m1[t1][0]);\\n                }\\n            }\\n            else\\n            {\\n                ans.push_back(m2[t][0]);\\n            }\\n        }\\n        return ans;\\n    }\\nprivate:\\n    string to_lower_add_underscore(string s)\\n    {\\n        std::transform(s.begin(), s.end(), s.begin(),\\n            [](unsigned char c){ \\n                c = tolower(c);\\n                if (c == \\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c ==\\'u\\')\\n                {\\n                    return (char)\\'_\\';\\n                }\\n                return (char)std::tolower(c); \\n            }\\n        );\\n        return s;\\n    }\\n    string to_lower(string s)\\n    {\\n        std::transform(s.begin(), s.end(), s.begin(),\\n            [](unsigned char c){ \\n                return (char)std::tolower(c); \\n            }\\n        );\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1122398,
                "title": "three-hashmaps",
                "content": "Approach 1: three hashmaps[1]\\n```\\n#Using 3 hashtables: original words, lower cases, lower cases with vowels replaced to \\u201C*\\u201D\\nclass Solution:\\n  def spellchecker(self, wordlist, queries):\\n    org = dict() \\n    #org=set(wordlist) # also ok\\n    low = dict()\\n    vow = dict()\\n    for w in wordlist:\\n      org[w] = w\\n      l = w.lower()\\n      if l not in low: low[l] = w # only keep 1st occurence\\n      v = re.sub(r\\'[aeiou]\\', \\'*\\', l)\\n      if v not in vow: vow[v] = w # only keep 1st occurence\\n    ans = []\\n    for q in queries:\\n      if q in org: \\n        ans.append(q)\\n        continue\\n      l = q.lower()\\n      if l in low:\\n        ans.append(low[l])\\n        continue\\n      v = re.sub(r\\'[aeiou]\\', \\'*\\', l)\\n      if v in vow:\\n        ans.append(vow[v])\\n        continue\\n      ans.append(\"\")\\n    return ans\\n```\\n[1] https://zxi.mytechroad.com/blog/hashtable/leetcode-966-vowel-spellchecker/",
                "solutionTags": [],
                "code": "```\\n#Using 3 hashtables: original words, lower cases, lower cases with vowels replaced to \\u201C*\\u201D\\nclass Solution:\\n  def spellchecker(self, wordlist, queries):\\n    org = dict() \\n    #org=set(wordlist) # also ok\\n    low = dict()\\n    vow = dict()\\n    for w in wordlist:\\n      org[w] = w\\n      l = w.lower()\\n      if l not in low: low[l] = w # only keep 1st occurence\\n      v = re.sub(r\\'[aeiou]\\', \\'*\\', l)\\n      if v not in vow: vow[v] = w # only keep 1st occurence\\n    ans = []\\n    for q in queries:\\n      if q in org: \\n        ans.append(q)\\n        continue\\n      l = q.lower()\\n      if l in low:\\n        ans.append(low[l])\\n        continue\\n      v = re.sub(r\\'[aeiou]\\', \\'*\\', l)\\n      if v in vow:\\n        ans.append(vow[v])\\n        continue\\n      ans.append(\"\")\\n    return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122393,
                "title": "ruby-solution-with-hashes-and-gsub",
                "content": "```\\ndef spellchecker(wordlist, queries)\\n  output = []\\n  wordlist_hash = {}\\n  wordlist_case_insensitive = {}\\n  wordlist_no_vowels = {}\\n\\n  # Need to reverse the array so that if a match is found, it will be the first match.\\n  wordlist.reverse.each_with_index do |word, idx|\\n    wordlist_hash[word] = wordlist.length - idx - 1\\n    wordlist_case_insensitive[word.downcase] = wordlist.length - idx - 1\\n    wordlist_no_vowels[swap_vowels(word)] = wordlist.length - idx - 1\\n  end\\n\\n  # If a match is found, use the index to find the original value in the wordlist. If not\\n  # return an empty string,\\n  queries.each do |word|\\n    index = wordlist_hash[word] || wordlist_case_insensitive[word.downcase] || wordlist_no_vowels[swap_vowels(word)]\\n\\n    output << if index\\n                wordlist[index]\\n              else\\n                \\'\\'\\n              end\\n  end\\n  output\\nend\\n\\ndef swap_vowels(word)\\n  word.downcase.gsub(/[aeiou]/, \\'-\\')\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef spellchecker(wordlist, queries)\\n  output = []\\n  wordlist_hash = {}\\n  wordlist_case_insensitive = {}\\n  wordlist_no_vowels = {}\\n\\n  # Need to reverse the array so that if a match is found, it will be the first match.\\n  wordlist.reverse.each_with_index do |word, idx|\\n    wordlist_hash[word] = wordlist.length - idx - 1\\n    wordlist_case_insensitive[word.downcase] = wordlist.length - idx - 1\\n    wordlist_no_vowels[swap_vowels(word)] = wordlist.length - idx - 1\\n  end\\n\\n  # If a match is found, use the index to find the original value in the wordlist. If not\\n  # return an empty string,\\n  queries.each do |word|\\n    index = wordlist_hash[word] || wordlist_case_insensitive[word.downcase] || wordlist_no_vowels[swap_vowels(word)]\\n\\n    output << if index\\n                wordlist[index]\\n              else\\n                \\'\\'\\n              end\\n  end\\n  output\\nend\\n\\ndef swap_vowels(word)\\n  word.downcase.gsub(/[aeiou]/, \\'-\\')\\nend\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1567352,
                "content": [
                    {
                        "username": "ashishjain87",
                        "content": "Consier being given words = [\"paa\",\"poe\"], and query = [\"pue\"].\\n\\nAlthough both \"poe\" and \"paa\" match \"pue\". However, from a hamming distance perspective \"pue\" is closer to \"poe\" (only \\'u\\' and \\'o\\' are different), and therefore, it should be considered a better match compared to \"paa\" (\\'aa\\' is different from \\'ue\\'). The fact that \"paa\" and \"poe\" are equivalent from the problem\\'s perspective was not made very clear in the problem statement."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[\"ae\",\"aa\"]\\nqueries =\\n[\"UU\"]\\nOutput\\n[\"aa\"]\\nExpected\\n[\"ae\"]\\n\\nwhy this is wrong output somebody please tell me"
                    },
                    {
                        "username": "user5376Zt",
                        "content": "\"When the query matches a word up to vowel errors, you should return the first such match in the wordlist.\"\\n*first*\\n\"ae\" is first, \"aa\" is second"
                    }
                ]
            },
            {
                "id": 1798652,
                "content": [
                    {
                        "username": "ashishjain87",
                        "content": "Consier being given words = [\"paa\",\"poe\"], and query = [\"pue\"].\\n\\nAlthough both \"poe\" and \"paa\" match \"pue\". However, from a hamming distance perspective \"pue\" is closer to \"poe\" (only \\'u\\' and \\'o\\' are different), and therefore, it should be considered a better match compared to \"paa\" (\\'aa\\' is different from \\'ue\\'). The fact that \"paa\" and \"poe\" are equivalent from the problem\\'s perspective was not made very clear in the problem statement."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[\"ae\",\"aa\"]\\nqueries =\\n[\"UU\"]\\nOutput\\n[\"aa\"]\\nExpected\\n[\"ae\"]\\n\\nwhy this is wrong output somebody please tell me"
                    },
                    {
                        "username": "user5376Zt",
                        "content": "\"When the query matches a word up to vowel errors, you should return the first such match in the wordlist.\"\\n*first*\\n\"ae\" is first, \"aa\" is second"
                    }
                ]
            }
        ]
    }
]