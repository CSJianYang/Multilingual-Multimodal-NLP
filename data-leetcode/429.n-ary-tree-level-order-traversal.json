[
    {
        "title": "Divide Two Integers",
        "question_content": "Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.\nThe integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.\nReturn the quotient after dividing dividend by divisor.\nNote: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [&minus;231, 231 &minus; 1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\n&nbsp;\nExample 1:\n\nInput: dividend = 10, divisor = 3\nOutput: 3\nExplanation: 10/3 = 3.33333.. which is truncated to 3.\n\nExample 2:\n\nInput: dividend = 7, divisor = -3\nOutput: -2\nExplanation: 7/-3 = -2.33333.. which is truncated to -2.\n\n&nbsp;\nConstraints:\n\n\t-231 <= dividend, divisor <= 231 - 1\n\tdivisor != 0",
        "solutions": [
            {
                "id": 13407,
                "title": "c-bit-manipulations",
                "content": "The key observation is that the quotient of a division is just the number of times that we can subtract the `divisor` from the `dividend` without making it negative.\\n\\nSuppose `dividend = 15` and `divisor = 3`, `15 - 3 > 0`. We now try to subtract more by *shifting* `3` to the left by `1` bit (`6`). Since `15 - 6 > 0`, shift `6` again to `12`. Now `15 - 12 > 0`, shift `12` again to `24`, which is larger than `15`. So we can at most subtract `12` from `15`. Since `12` is obtained by shifting `3` to left twice, it is `1 << 2 = 4` times of `3`. We add `4` to an answer variable (initialized to be `0`). The above process is like `15 = 3 * 4 + 3`. We now get part of the quotient (`4`), with a remaining dividend `3`.\\n\\nThen we repeat the above process by subtracting `divisor = 3` from the remaining `dividend = 3` and obtain `0`. We are done. In this case, no shift happens. We simply add `1 << 0 = 1` to the answer variable.\\n\\nThis is the full algorithm to perform division using bit manipulations. The sign also needs to be taken into consideration. And we still need to handle one overflow case: `dividend = INT_MIN` and `divisor = -1`.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        if (dividend == INT_MIN && divisor == -1) {\\n            return INT_MAX;\\n        }\\n        long dvd = labs(dividend), dvs = labs(divisor), ans = 0;\\n        int sign = dividend > 0 ^ divisor > 0 ? -1 : 1;\\n        while (dvd >= dvs) {\\n            long temp = dvs, m = 1;\\n            while (temp << 1 <= dvd) {\\n                temp <<= 1;\\n                m <<= 1;\\n            }\\n            dvd -= temp;\\n            ans += m;\\n        }\\n        return sign * ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        if (dividend == INT_MIN && divisor == -1) {\\n            return INT_MAX;\\n        }\\n        long dvd = labs(dividend), dvs = labs(divisor), ans = 0;\\n        int sign = dividend > 0 ^ divisor > 0 ? -1 : 1;\\n        while (dvd >= dvs) {\\n            long temp = dvs, m = 1;\\n            while (temp << 1 <= dvd) {\\n                temp <<= 1;\\n                m <<= 1;\\n            }\\n            dvd -= temp;\\n            ans += m;\\n        }\\n        return sign * ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1516367,
                "title": "complete-thinking-process-intuitive-explanation-all-rules-followed-c-code",
                "content": "# **Explanation:**\\n```\\n\\tdividend = (quotient) * divisor + remainder\\n```\\nWe have to find the quotient in this equation and we are given divisor and dividend.\\nAny number can be represented in binary form. Same goes for `quotient` :\\n\\nLet us have an example: `58/5`:\\n`58 = (11) * 5 + 3`\\nRepresenting the quotient in binary form:  (11)<sub>10</sub> = (1011)<sub>2</sub>:\\n```\\n\\t58 = (2^3 + 2^1 + 2^0) * 5 + 3                // --- (I)\\n\\t58 = [(2^3 * 5) + (2^1 * 5) + (2^0 * 5)] + 3  // --- (II)\\n```\\n\\nSince we dont know the quotient and remainder the equation we know is:\\n`58 = (q) * 5 + rem`\\n\\nWe get a hint at what we would like to do here. We will first multiply 5 with maximum power of 2 such that the resulting number is still smaller than the dividend (read further if you don\\'t understand why). Since multiplication operator is not allowed, we would use bitwise left shift to achieve this multiplication: each time we shift 5 by 1, we multiply it by 2:\\n```\\n\\t5 << 0 = 5               // less than dividend\\n\\t5 << 1 = 5*2 = 10        // less than dividend\\n\\t5 << 2 = 5*2*2 = 20      // less than dividend\\n\\t5 << 3 = 5*2*2*2 = 40    // less than dividend\\n\\t5 << 4 = 5*2*2*2*2 = 80  // (stop and consider the previous value as the result is greater than dividend\\n```\\n\\nWe observe that:\\n`58 = (2^3 * 5) + (something * 5) + rem      // --- (III)`\\nYou can see we are getting close to the equation we initialy wanted (eqa II). \\n\\nSince 5 is multiplied with 2<sup>3</sup>, ***we add 2<sup>3</sup> to our answer***.\\nFurther operating on equation III:\\n```\\n\\t58 - (2^3 * 5)  =  (something * 5) + rem\\n\\t58 - (8 * 5) = something * 5 + rem\\n\\t58 - 40 = something * 5 + rem\\n\\t18 = something * 5 + rem\\n```\\n\\nWhat we effectively have done is, subtracted the result we got from our first step from dividend `(58 - 40)`.\\nWe arived at the same question again but with a smaller dividend this time. \\n`dividend = 18, divisor = 5`\\n\\nTherefore let us repeat the process:\\n```\\n\\t5 << 0 = 5           // less than dividend\\n\\t5 << 1 = 5*2 = 10    // less than dividend\\n\\t5 << 2 = 5*2*2 = 20  // (stop and consider the previous value as the result is greater than dividend\\n```\\n***We add  2<sup>1</sup> to our answer***.\\nLooking back: \\n```\\n\\t18  =  (2^1 * 5) + (something * 5) + rem\\n\\t58 - (2^3 * 5) = (2^1 * 5) + (something * 5) + rem\\n\\t58 =  (2^3 * 5) + (2^1 * 5) + (something * 5) + rem\\n```\\nYou can notice we are gradually advancing towards equ II:\\nOur new dividend is now:\\n```\\n\\t18 - (2^1 * 5)  =  (something * 5) + rem\\n\\t18 - (2 * 5) = something * 5 + rem\\n\\t18 - 10 = something * 5 + rem\\n\\t8 = something * 5 + rem\\n```\\n`dividend = 8, divisor = 5`\\nRepeating the process:\\n```\\n\\t5 << 0 = 5           // less than dividend\\n\\t5 << 1 = 5*2 = 10    // (stop and consider the previous value as the result is greater than dividend\\n```\\n***We add  2<sup>0</sup> to our answer.***\\nNew dividend: \\n```\\n\\t8 = (2^0 * 5) + (something * 5) + rem\\n\\t8 - 5 = something * 5 + rem\\n\\t3 = something * 5 + rem\\n```\\n`dividend = 3, divisor = 5`\\nAt this step, we stop iterating as our dividend is less than the divisor (we have also found our remainder = 3, as 5 should be multiplied with 0 and what remains is the remainder).\\n\\nLooking back again for the last time:\\n```\\n\\t3 = 0*5 + rem\\n\\t8 = (2^0 * 5) + 3\\n\\t18  =  (2^0 * 5) + (2^1 * 5) + 3\\n\\t58 = (2^3 * 5) + (2^1 * 5) + (2^0 * 5) + 3\\n```\\nIn the process, we have finally reached the equation we wanted to, and have got the answer as:\\n`quotient = (2^3 + 2^1 + 2^0)`\\n\\n# **Code:**\\nSince we are not allowed to have any numerical data type bigger than 32 bit integer, we will use the last bit reserved for sign to avoid overflow by using the unsinged int in c++:\\n```\\n\\tint divide(int dividend, int divisor) {\\n        if(dividend == divisor)\\n            return 1;\\n        bool isPositive = (dividend<0 == divisor<0);    // if both are of same sign, answer is positive\\n        unsigned int a = abs(dividend);\\n        unsigned int b = abs(divisor);\\n        unsigned int ans = 0;\\n        while(a >= b){  // while dividend is greater than or equal to divisor\\n            short q = 0;\\n            while(a > (b<<(q+1)))\\n                q++;\\n            ans += (1<<q);  // add the power of 2 found to the answer\\n            a = a - (b<<q);  // reduce the dividend by divisor * power of 2 found\\n        }\\n        if(ans == (1<<31) and isPositive)   // if ans cannot be stored in signed int\\n            return INT_MAX;\\n        return isPositive ? ans : -ans;\\n    }\\n```\\n***Please upvote if you find this helpful, or if you think someone else might find it useful :)***\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tdividend = (quotient) * divisor + remainder\\n```\n```\\n\\t58 = (2^3 + 2^1 + 2^0) * 5 + 3                // --- (I)\\n\\t58 = [(2^3 * 5) + (2^1 * 5) + (2^0 * 5)] + 3  // --- (II)\\n```\n```\\n\\t5 << 0 = 5               // less than dividend\\n\\t5 << 1 = 5*2 = 10        // less than dividend\\n\\t5 << 2 = 5*2*2 = 20      // less than dividend\\n\\t5 << 3 = 5*2*2*2 = 40    // less than dividend\\n\\t5 << 4 = 5*2*2*2*2 = 80  // (stop and consider the previous value as the result is greater than dividend\\n```\n```\\n\\t58 - (2^3 * 5)  =  (something * 5) + rem\\n\\t58 - (8 * 5) = something * 5 + rem\\n\\t58 - 40 = something * 5 + rem\\n\\t18 = something * 5 + rem\\n```\n```\\n\\t5 << 0 = 5           // less than dividend\\n\\t5 << 1 = 5*2 = 10    // less than dividend\\n\\t5 << 2 = 5*2*2 = 20  // (stop and consider the previous value as the result is greater than dividend\\n```\n```\\n\\t18  =  (2^1 * 5) + (something * 5) + rem\\n\\t58 - (2^3 * 5) = (2^1 * 5) + (something * 5) + rem\\n\\t58 =  (2^3 * 5) + (2^1 * 5) + (something * 5) + rem\\n```\n```\\n\\t18 - (2^1 * 5)  =  (something * 5) + rem\\n\\t18 - (2 * 5) = something * 5 + rem\\n\\t18 - 10 = something * 5 + rem\\n\\t8 = something * 5 + rem\\n```\n```\\n\\t5 << 0 = 5           // less than dividend\\n\\t5 << 1 = 5*2 = 10    // (stop and consider the previous value as the result is greater than dividend\\n```\n```\\n\\t8 = (2^0 * 5) + (something * 5) + rem\\n\\t8 - 5 = something * 5 + rem\\n\\t3 = something * 5 + rem\\n```\n```\\n\\t3 = 0*5 + rem\\n\\t8 = (2^0 * 5) + 3\\n\\t18  =  (2^0 * 5) + (2^1 * 5) + 3\\n\\t58 = (2^3 * 5) + (2^1 * 5) + (2^0 * 5) + 3\\n```\n```\\n\\tint divide(int dividend, int divisor) {\\n        if(dividend == divisor)\\n            return 1;\\n        bool isPositive = (dividend<0 == divisor<0);    // if both are of same sign, answer is positive\\n        unsigned int a = abs(dividend);\\n        unsigned int b = abs(divisor);\\n        unsigned int ans = 0;\\n        while(a >= b){  // while dividend is greater than or equal to divisor\\n            short q = 0;\\n            while(a > (b<<(q+1)))\\n                q++;\\n            ans += (1<<q);  // add the power of 2 found to the answer\\n            a = a - (b<<q);  // reduce the dividend by divisor * power of 2 found\\n        }\\n        if(ans == (1<<31) and isPositive)   // if ans cannot be stored in signed int\\n            return INT_MAX;\\n        return isPositive ? ans : -ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 142849,
                "title": "c-java-python-should-not-use-long-int",
                "content": "## **Update 2019/02**\\nUsed to work on Leetcode when I wrote this solution, before 2019/02.\\nNow it\\'s broken. The C++ compiler on the Leetcode is changed.\\nI have locally clang-1000 and the solutions work very well.\\n\\n## **Preword**\\nThe description note that:\\n\"Assume we are dealing with an environment,\\nwhich could **only store integers within the 32-bit** signed integer range: `[\\u22122^31,  2^31 \\u2212 1]`.\"\\n\\nBut most of solution use \"long\" integer.\\nSo I share my solution here.\\n\\n## **Solution 1**\\n\\nOnly one corner case is `-2^31 / 1` and I deal with it at the first line.\\n\\nThis solution has `O(logN^2)` time complexity.\\n\\n**C++:**\\n```cpp\\n    int divide(int A, int B) {\\n        if (A == INT_MIN && B == -1) return INT_MAX;\\n        int a = abs(A), b = abs(B), res = 0, x = 0;\\n        while (a - b >= 0) {\\n            for (x = 0; a - (b << x << 1) >= 0; x++);\\n            res += 1 << x;\\n            a -= b << x;\\n        }\\n        return (A > 0) == (B > 0) ? res : -res;\\n    }\\n```\\n\\n**Java:**\\n```java\\n    public int divide(int A, int B) {\\n        if (A == 1 << 31 && B == -1) return (1 << 31) - 1;\\n        int a = Math.abs(A), b = Math.abs(B), res = 0, x = 0;\\n        while (a - b >= 0) {\\n            for (x = 0; a - (b << x << 1) >= 0; x++);\\n            res += 1 << x;\\n            a -= b << x;\\n        }\\n        return (A > 0) == (B > 0) ? res : -res;\\n    }\\n```\\n\\n## **Solution 2**\\nAnother solution is also `O(32)`\\n\\n**C++:**\\n```cpp\\n    int divide(int A, int B) {\\n        if (A == INT_MIN && B == -1) return INT_MAX;\\n        int a = abs(A), b = abs(B), res = 0;\\n        for (int x = 31; x >= 0; x--)\\n            if ((signed)((unsigned)a >> x) - b >= 0)\\n                res += 1 << x, a -= b << x;\\n        return (A > 0) == (B > 0) ? res : -res;\\n    }\\n```\\n\\n**Java:**\\n```java\\n    public int divide(int A, int B) {\\n        if (A == 1 << 31 && B == -1) return (1 << 31) - 1;\\n        int a = Math.abs(A), b = Math.abs(B), res = 0;\\n        for (int x = 31; x >= 0; x--)\\n            if ((a >>> x) - b >= 0) {\\n                res += 1 << x;\\n                a -= b << x;\\n            }\\n        return (A > 0) == (B > 0) ? res : -res;\\n    }\\n```\\n**Python:**\\n```python\\n    def divide(self, A, B):\\n        if (A == -2147483648 and B == -1): return 2147483647\\n        a, b, res = abs(A), abs(B), 0\\n        for x in range(32)[::-1]:\\n            if (a >> x) - b >= 0:\\n                res += 1 << x\\n                a -= b << x\\n        return res if (A > 0) == (B > 0) else -res\\n```",
                "solutionTags": [],
                "code": "```cpp\\n    int divide(int A, int B) {\\n        if (A == INT_MIN && B == -1) return INT_MAX;\\n        int a = abs(A), b = abs(B), res = 0, x = 0;\\n        while (a - b >= 0) {\\n            for (x = 0; a - (b << x << 1) >= 0; x++);\\n            res += 1 << x;\\n            a -= b << x;\\n        }\\n        return (A > 0) == (B > 0) ? res : -res;\\n    }\\n```\n```java\\n    public int divide(int A, int B) {\\n        if (A == 1 << 31 && B == -1) return (1 << 31) - 1;\\n        int a = Math.abs(A), b = Math.abs(B), res = 0, x = 0;\\n        while (a - b >= 0) {\\n            for (x = 0; a - (b << x << 1) >= 0; x++);\\n            res += 1 << x;\\n            a -= b << x;\\n        }\\n        return (A > 0) == (B > 0) ? res : -res;\\n    }\\n```\n```cpp\\n    int divide(int A, int B) {\\n        if (A == INT_MIN && B == -1) return INT_MAX;\\n        int a = abs(A), b = abs(B), res = 0;\\n        for (int x = 31; x >= 0; x--)\\n            if ((signed)((unsigned)a >> x) - b >= 0)\\n                res += 1 << x, a -= b << x;\\n        return (A > 0) == (B > 0) ? res : -res;\\n    }\\n```\n```java\\n    public int divide(int A, int B) {\\n        if (A == 1 << 31 && B == -1) return (1 << 31) - 1;\\n        int a = Math.abs(A), b = Math.abs(B), res = 0;\\n        for (int x = 31; x >= 0; x--)\\n            if ((a >>> x) - b >= 0) {\\n                res += 1 << x;\\n                a -= b << x;\\n            }\\n        return (A > 0) == (B > 0) ? res : -res;\\n    }\\n```\n```python\\n    def divide(self, A, B):\\n        if (A == -2147483648 and B == -1): return 2147483647\\n        a, b, res = abs(A), abs(B), 0\\n        for x in range(32)[::-1]:\\n            if (a >> x) - b >= 0:\\n                res += 1 << x\\n                a -= b << x\\n        return res if (A > 0) == (B > 0) else -res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 13403,
                "title": "clear-python-code",
                "content": "    class Solution:\\n    # @return an integer\\n    def divide(self, dividend, divisor):\\n        positive = (dividend < 0) is (divisor < 0)\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        res = 0\\n        while dividend >= divisor:\\n            temp, i = divisor, 1\\n            while dividend >= temp:\\n                dividend -= temp\\n                res += i\\n                i <<= 1\\n                temp <<= 1\\n        if not positive:\\n            res = -res\\n        return min(max(-2147483648, res), 2147483647)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n    # @return an integer\\n    def divide(self, dividend, divisor):\\n        positive = (dividend < 0) is (divisor < 0)\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        res = 0\\n        while dividend >= divisor:\\n            temp, i = divisor, 1\\n            while dividend >= temp:\\n                dividend -= temp\\n                res += i\\n                i <<= 1\\n                temp <<= 1\\n        if not positive:\\n            res = -res\\n        return min(max(-2147483648, res), 2147483647)",
                "codeTag": "Java"
            },
            {
                "id": 13397,
                "title": "clean-java-solution-with-some-comment",
                "content": "  \\tpublic int divide(int dividend, int divisor) {\\n\\t\\t//Reduce the problem to positive long integer to make it easier.\\n\\t\\t//Use long to avoid integer overflow cases.\\n\\t\\tint sign = 1;\\n\\t\\tif ((dividend > 0 && divisor < 0) || (dividend < 0 && divisor > 0))\\n\\t\\t\\tsign = -1;\\n\\t\\tlong ldividend = Math.abs((long) dividend);\\n\\t\\tlong ldivisor = Math.abs((long) divisor);\\n\\t\\t\\n\\t\\t//Take care the edge cases.\\n\\t\\tif (ldivisor == 0) return Integer.MAX_VALUE;\\n\\t\\tif ((ldividend == 0) || (ldividend < ldivisor))\\treturn 0;\\n\\t\\t\\n\\t\\tlong lans = ldivide(ldividend, ldivisor);\\n\\t\\t\\n\\t\\tint ans;\\n\\t\\tif (lans > Integer.MAX_VALUE){ //Handle overflow.\\n\\t\\t\\tans = (sign == 1)? Integer.MAX_VALUE : Integer.MIN_VALUE;\\n\\t\\t} else {\\n\\t\\t\\tans = (int) (sign * lans);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tprivate long ldivide(long ldividend, long ldivisor) {\\n\\t\\t// Recursion exit condition\\n\\t\\tif (ldividend < ldivisor) return 0;\\n\\t\\t\\n\\t\\t//  Find the largest multiple so that (divisor * multiple <= dividend), \\n\\t\\t//  whereas we are moving with stride 1, 2, 4, 8, 16...2^n for performance reason.\\n\\t\\t//  Think this as a binary search.\\n\\t\\tlong sum = ldivisor;\\n\\t\\tlong multiple = 1;\\n\\t\\twhile ((sum+sum) <= ldividend) {\\n\\t\\t\\tsum += sum;\\n\\t\\t\\tmultiple += multiple;\\n\\t\\t}\\n\\t\\t//Look for additional value for the multiple from the reminder (dividend - sum) recursively.\\n\\t\\treturn multiple + ldivide(ldividend - sum, ldivisor);\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "  \\tpublic int divide(int dividend, int divisor) {\\n\\t\\t//Reduce the problem to positive long integer to make it easier.\\n\\t\\t//Use long to avoid integer overflow cases.\\n\\t\\tint sign = 1;\\n\\t\\tif ((dividend > 0 && divisor < 0) || (dividend < 0 && divisor > 0))\\n\\t\\t\\tsign = -1;\\n\\t\\tlong ldividend = Math.abs((long) dividend);\\n\\t\\tlong ldivisor = Math.abs((long) divisor);\\n\\t\\t\\n\\t\\t//Take care the edge cases.\\n\\t\\tif (ldivisor == 0) return Integer.MAX_VALUE;\\n\\t\\tif ((ldividend == 0) || (ldividend < ldivisor))\\treturn 0;\\n\\t\\t\\n\\t\\tlong lans = ldivide(ldividend, ldivisor);\\n\\t\\t\\n\\t\\tint ans;\\n\\t\\tif (lans > Integer.MAX_VALUE){ //Handle overflow.\\n\\t\\t\\tans = (sign == 1)? Integer.MAX_VALUE : Integer.MIN_VALUE;\\n\\t\\t} else {\\n\\t\\t\\tans = (int) (sign * lans);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tprivate long ldivide(long ldividend, long ldivisor) {\\n\\t\\t// Recursion exit condition\\n\\t\\tif (ldividend < ldivisor) return 0;\\n\\t\\t\\n\\t\\t//  Find the largest multiple so that (divisor * multiple <= dividend), \\n\\t\\t//  whereas we are moving with stride 1, 2, 4, 8, 16...2^n for performance reason.\\n\\t\\t//  Think this as a binary search.\\n\\t\\tlong sum = ldivisor;\\n\\t\\tlong multiple = 1;\\n\\t\\twhile ((sum+sum) <= ldividend) {\\n\\t\\t\\tsum += sum;\\n\\t\\t\\tmultiple += multiple;\\n\\t\\t}\\n\\t\\t//Look for additional value for the multiple from the reminder (dividend - sum) recursively.\\n\\t\\treturn multiple + ldivide(ldividend - sum, ldivisor);\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 13467,
                "title": "very-detailed-step-by-step-explanation-java-solution",
                "content": "This seems to be a very difficult question with whole lot of restriction, but if you break down the question and tackle every sub-problem individually, it might not seem as hard as it is.\\n\\nFirst, we need to check whether the end result is positive or negative. Two cases will lead to negative case which is when dividend and divisor has different signs. Alright, first part is done.\\n\\nSecond part is to deal with overflow. You know, there are so many corner cases which will lead to overflow. So it is better to convert them to long first, and convert it back to integer when returning the value.\\n\\nAlright, now we get to the main part. We know that division is actually the backward of multiplication, for example , `20 / 5  = 4` can be seen as `4 * 5 = 20`. Here what we are going to do is to find the multiplication. We set tmp as divisor `(5)` and set count to `1`.  As long as the tmp is less than or equal to dividend `(20)`, we left shift `<<` **which is same as multiply 2 but without using multiplication**. \\n\\n    1st loop --- tmp = 10 , count = 2 \\n    2nd loop --- tmp = 20, count = 4\\n    3rd loop --- tmp = 40, count = 8 (exit the loop)\\n\\nNow we right shift both tmp and count by 1, which gives us result of `4` . After subtraction of `20` from dividend, which gives us dividend = `0` and that we break out the outer loop and get to the last part.\\n\\nFinally, we gotta check if the sign is positive or negative. If it is negative, then we apply negation `~result` + `1` (two's complement) to get the negative result (why not just `result * -1` ? Well, critics might say you use multiplication -_-!!! (lol jk). Also make sure to check if result is overflow, because you know, leetcode is pretty strict to corner cases as well.\\n\\n----------\\n\\nAnother example : `10 / 3 = 3`\\n\\n    1st outer loop\\n    --------------\\n\\n    1st inner loop --- tmp = 6 , count = 2\\n    2nd inner loop --- tmp = 12, count = 4 (exit the inner loop, result = 0 + (4 >> 1) = 2)\\n\\n    dividend = 10 - (12 >> 1) = 10 - 6 = 4 (4 >  divisor, so here we go second outer loop)\\n\\n    2nd outer loop\\n    --------------\\n\\n    1st inner loop --- tmp = 6, count = 2 (exit the inner loop, result = 2 + (2 >> 1) = 3)\\n\\n    dividend = 4 - (6 >> 1) = 4 - 3 = 1( divisor > 1, exit outer loop, return result)\\n\\n----------\\n\\nCredits to @HelloWorld123456. Here is the simplified code: \\n\\n\\n    public int divide(int dividend, int divisor) {\\n        boolean isNegative = (dividend < 0 && divisor > 0) || (dividend > 0 && divisor < 0) ? true : false;\\n        long absDividend = Math.abs((long) dividend);\\n        long absDivisor = Math.abs((long) divisor);\\n        long result = 0;\\n        while(absDividend >= absDivisor){\\n            long tmp = absDivisor, count = 1;\\n            while(tmp <= absDividend){\\n                tmp <<= 1;\\n                count <<= 1;\\n            }\\n            result += count >> 1;\\n            absDividend -= tmp >> 1;\\n        }\\n        return  isNegative ? (int) ~result + 1 : result > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) result;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "This seems to be a very difficult question with whole lot of restriction, but if you break down the question and tackle every sub-problem individually, it might not seem as hard as it is.\\n\\nFirst, we need to check whether the end result is positive or negative. Two cases will lead to negative case which is when dividend and divisor has different signs. Alright, first part is done.\\n\\nSecond part is to deal with overflow. You know, there are so many corner cases which will lead to overflow. So it is better to convert them to long first, and convert it back to integer when returning the value.\\n\\nAlright, now we get to the main part. We know that division is actually the backward of multiplication, for example , `20 / 5  = 4` can be seen as `4 * 5 = 20`. Here what we are going to do is to find the multiplication. We set tmp as divisor `(5)` and set count to `1`.  As long as the tmp is less than or equal to dividend `(20)`, we left shift `<<` **which is same as multiply 2 but without using multiplication**. \\n\\n    1st loop --- tmp = 10 , count = 2 \\n    2nd loop --- tmp = 20, count = 4\\n    3rd loop --- tmp = 40, count = 8 (exit the loop)\\n\\nNow we right shift both tmp and count by 1, which gives us result of `4` . After subtraction of `20` from dividend, which gives us dividend = `0` and that we break out the outer loop and get to the last part.\\n\\nFinally, we gotta check if the sign is positive or negative. If it is negative, then we apply negation `~result` + `1` (two's complement) to get the negative result (why not just `result * -1` ? Well, critics might say you use multiplication -_-!!! (lol jk). Also make sure to check if result is overflow, because you know, leetcode is pretty strict to corner cases as well.\\n\\n----------\\n\\nAnother example : `10 / 3 = 3`\\n\\n    1st outer loop\\n    --------------\\n\\n    1st inner loop --- tmp = 6 , count = 2\\n    2nd inner loop --- tmp = 12, count = 4 (exit the inner loop, result = 0 + (4 >> 1) = 2)\\n\\n    dividend = 10 - (12 >> 1) = 10 - 6 = 4 (4 >  divisor, so here we go second outer loop)\\n\\n    2nd outer loop\\n    --------------\\n\\n    1st inner loop --- tmp = 6, count = 2 (exit the inner loop, result = 2 + (2 >> 1) = 3)\\n\\n    dividend = 4 - (6 >> 1) = 4 - 3 = 1( divisor > 1, exit outer loop, return result)\\n\\n----------\\n\\nCredits to @HelloWorld123456. Here is the simplified code: \\n\\n\\n    public int divide(int dividend, int divisor) {\\n        boolean isNegative = (dividend < 0 && divisor > 0) || (dividend > 0 && divisor < 0) ? true : false;\\n        long absDividend = Math.abs((long) dividend);\\n        long absDivisor = Math.abs((long) divisor);\\n        long result = 0;\\n        while(absDividend >= absDivisor){\\n            long tmp = absDivisor, count = 1;\\n            while(tmp <= absDividend){\\n                tmp <<= 1;\\n                count <<= 1;\\n            }\\n            result += count >> 1;\\n            absDividend -= tmp >> 1;\\n        }\\n        return  isNegative ? (int) ~result + 1 : result > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2089533,
                "title": "easy-solution-in-c",
                "content": "The idea here is to use addition efficiently to compute the final result...\\nwe know that division can be done using addition or subtraction...\\nfor example 20/3 = 3+3+3+3+3+3+(2, ignored) (result is 6 times 3 hence 6)\\n\\nHence the loop is run, n times where n is our result...\\nTo more efficiently compute this, we can reduce the loops to log n time by adding divisor everytime it is added on...\\n\\nSo 20/3 = 3 + 6 + 12 + (24, ignore) (curr result is 2^(3-1)=4, 3 here is number of iterations...) \\nleft over sum, 20-12 = 8, and we repeat the process...\\nSo 8/3 = 3 + 6 + (12, ignore) (this time result is 2^(2-1)=2, 2 here is number of iterations...)\\nleft over sum, 8-6 = 2, since 2 is less than 3, we terminate the process...\\n\\nHence final result is 4+2 = 6\\n\\n**Pls upvote the  thread if you found it helpful.**\\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        \\n        //Handling corner cases\\n        if(dividend==INT_MIN && divisor==-1) return INT_MAX;\\n        if(dividend==INT_MIN && divisor==1) return INT_MIN;\\n\\n        \\n        //Converting divisors and dividend to their positive values\\n        long int dd = abs(dividend), dv = abs(divisor);\\n        \\n        //Result Variables\\n        int res=0;\\n        while(dv<=dd) {\\n            long int mul=dv, tmp=1;\\n            while(mul<=dd-mul) {\\n                mul+=mul;\\n                tmp+=tmp;\\n            }\\n            res+=tmp;\\n            dd-=mul;\\n        }\\n        \\n        //If either of dividend or divisor is negative our result will be negative\\n        if((dividend<0&&divisor>0) || (dividend>0&&divisor<0)) return -res;\\n        \\n        return res;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        \\n        //Handling corner cases\\n        if(dividend==INT_MIN && divisor==-1) return INT_MAX;\\n        if(dividend==INT_MIN && divisor==1) return INT_MIN;\\n\\n        \\n        //Converting divisors and dividend to their positive values\\n        long int dd = abs(dividend), dv = abs(divisor);\\n        \\n        //Result Variables\\n        int res=0;\\n        while(dv<=dd) {\\n            long int mul=dv, tmp=1;\\n            while(mul<=dd-mul) {\\n                mul+=mul;\\n                tmp+=tmp;\\n            }\\n            res+=tmp;\\n            dd-=mul;\\n        }\\n        \\n        //If either of dividend or divisor is negative our result will be negative\\n        if((dividend<0&&divisor>0) || (dividend>0&&divisor<0)) return -res;\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13417,
                "title": "no-use-of-long-java-solution",
                "content": "Integer.MIN_VALUE as dividend is really troublesome. Thus, I turn everything to negative value and keep finding closest 1,2,4,8... multiples and recursive on rest. The only case that will cause overflow is Integer.MIN_VALUE / -1, so I list it alone as an edge case. \\n\\n\\n    public class Solution {\\n        public int divide(int dividend, int divisor) {\\n    \\t\\tif(dividend==Integer.MIN_VALUE && divisor==-1) return Integer.MAX_VALUE;\\n            if(dividend > 0 && divisor > 0) return divideHelper(-dividend, -divisor);\\n            else if(dividend > 0) return -divideHelper(-dividend,divisor);\\n            else if(divisor > 0) return -divideHelper(dividend,-divisor);\\n            else return divideHelper(dividend, divisor);\\n        }\\n        \\n        private int divideHelper(int dividend, int divisor){\\n            // base case\\n            if(divisor < dividend) return 0;\\n            // get highest digit of divisor\\n            int cur = 0, res = 0;\\n            while((divisor << cur) >= dividend && divisor << cur < 0 && cur < 31) cur++;\\n            res = dividend - (divisor << cur-1);\\n            if(res > divisor) return 1 << cur-1;\\n            return (1 << cur-1)+divide(res, divisor);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int divide(int dividend, int divisor) {\\n    \\t\\tif(dividend==Integer.MIN_VALUE && divisor==-1) return Integer.MAX_VALUE;\\n            if(dividend > 0 && divisor > 0) return divideHelper(-dividend, -divisor);\\n            else if(dividend > 0) return -divideHelper(-dividend,divisor);\\n            else if(divisor > 0) return -divideHelper(dividend,-divisor);\\n            else return divideHelper(dividend, divisor);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 427345,
                "title": "python-24ms-beats-99-with-and-w-o-bitwise-operators",
                "content": "**With [bitwise operators](https://wiki.python.org/moin/BitwiseOperators):**\\n```\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        is_negative = (dividend < 0) != (divisor < 0)\\n        divisor, dividend = abs(divisor), abs(dividend)\\n\\n        quotient = 0\\n        the_sum = divisor\\n\\n        while the_sum <= dividend:\\n            current_quotient = 1\\n            while (the_sum << 1) <= dividend:\\n                the_sum <<= 1\\n                current_quotient <<= 1            \\n            dividend -= the_sum\\n            the_sum = divisor\\n            quotient += current_quotient\\n\\n        return min(2147483647, max(-quotient if is_negative else quotient, -2147483648))\\n```\\nRuntime: 24 ms, faster than 99.56% of Python3 online submissions for Divide Two Integers.\\nMemory Usage: 12.8 MB, less than 100.00% of Python3 online submissions for Divide Two Integers.\\n\\n**Without bitwise operators:**\\n```\\n    def divide(self, dividend: int, divisor: int) -> int:\\n\\t\\tis_negative = (dividend < 0) != (divisor < 0)\\n\\t\\tdivisor, dividend = abs(divisor), abs(dividend)\\n\\n\\t\\tquotient = 0\\n\\t\\tthe_sum = divisor\\n\\n\\t\\twhile the_sum <= dividend:\\n\\t\\t\\tcurrent_quotient = 1\\n\\t\\t\\twhile (the_sum + the_sum) <= dividend:\\n\\t\\t\\t\\tthe_sum += the_sum\\n\\t\\t\\t\\tcurrent_quotient += current_quotient\\n\\t\\t\\tdividend -= the_sum\\n\\t\\t\\tthe_sum = divisor\\n\\t\\t\\tquotient += current_quotient\\n\\n\\t\\treturn min(2147483647, max(-quotient if is_negative else quotient, -2147483648))\\n```\\n**How it works**\\nFor example, we `divide(5000, 14)`:\\n1) After the first inner loop: `the_sum = 3584` which is `14` multiplied `256` times. \\nWe can\\'t multiply any more \\u2014 because after `256` is coming `256 + 256 = 512` and `14 * 512 = 7168` which is larger than our `dividend`, so we exit the inner loop,\\nReducing dividend: `dividend = 5000 - 3584 = 1416` \\nAnd moving to another cycle of outer loop\\n2) After the second inner loop: `the_sum = 896` which is `14` multiplied `64` times.  \\n3) Third: `the_sum = 448` which is `14` multiplied `32` times.  \\n4) And so on\\n5) Finally we have: `quotient = 256 + 64 + 32 + 4 + 1 = 357`",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        is_negative = (dividend < 0) != (divisor < 0)\\n        divisor, dividend = abs(divisor), abs(dividend)\\n\\n        quotient = 0\\n        the_sum = divisor\\n\\n        while the_sum <= dividend:\\n            current_quotient = 1\\n            while (the_sum << 1) <= dividend:\\n                the_sum <<= 1\\n                current_quotient <<= 1            \\n            dividend -= the_sum\\n            the_sum = divisor\\n            quotient += current_quotient\\n\\n        return min(2147483647, max(-quotient if is_negative else quotient, -2147483648))\\n```\n```\\n    def divide(self, dividend: int, divisor: int) -> int:\\n\\t\\tis_negative = (dividend < 0) != (divisor < 0)\\n\\t\\tdivisor, dividend = abs(divisor), abs(dividend)\\n\\n\\t\\tquotient = 0\\n\\t\\tthe_sum = divisor\\n\\n\\t\\twhile the_sum <= dividend:\\n\\t\\t\\tcurrent_quotient = 1\\n\\t\\t\\twhile (the_sum + the_sum) <= dividend:\\n\\t\\t\\t\\tthe_sum += the_sum\\n\\t\\t\\t\\tcurrent_quotient += current_quotient\\n\\t\\t\\tdividend -= the_sum\\n\\t\\t\\tthe_sum = divisor\\n\\t\\t\\tquotient += current_quotient\\n\\n\\t\\treturn min(2147483647, max(-quotient if is_negative else quotient, -2147483648))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 13428,
                "title": "15-line-easy-understand-solution-129ms",
                "content": "for example, if we want to calc (17/2)\\n\\nret = 0;\\n\\n17-2  ,ret+=1; left=15\\n\\n15-4  ,ret+=2; left=11\\n\\n11-8  ,ret+=4; left=3\\n\\n3-2    ,ret+=1; left=1\\n\\n\\nret=8;\\n\\n\\n\\n\\n\\n\\n    class Solution:\\n    # @return an integer\\n    def divide(self, dividend, divisor):\\n        isMinus= ((dividend<0 and divisor >0) or (dividend>0 and divisor <0));\\n        ret=0;        \\n        dividend,divisor=abs(dividend),abs(divisor);\\n        c,sub=1,divisor;\\n\\n        while(dividend >= divisor):\\n            if(dividend>=sub):\\n                dividend-=sub;\\n                ret+=c;\\n                sub=(sub<<1);\\n                c=(c<<1);\\n            else:\\n                sub=(sub>>1);\\n                c=(c>>1);\\n        \\n        if(isMinus):\\n            ret=-ret;\\n        return min(max(-2147483648,ret),2147483647);",
                "solutionTags": [
                    "Python"
                ],
                "code": "for example, if we want to calc (17/2)\\n\\nret = 0;\\n\\n17-2  ,ret+=1; left=15\\n\\n15-4  ,ret+=2; left=11\\n\\n11-8  ,ret+=4; left=3\\n\\n3-2    ,ret+=1; left=1\\n\\n\\nret=8;\\n\\n\\n\\n\\n\\n\\n    class Solution:\\n    # @return an integer\\n    def divide(self, dividend, divisor):\\n        isMinus= ((dividend<0 and divisor >0) or (dividend>0 and divisor <0));\\n        ret=0;        \\n        dividend,divisor=abs(dividend),abs(divisor);\\n        c,sub=1,divisor;\\n\\n        while(dividend >= divisor):\\n            if(dividend>=sub):\\n                dividend-=sub;\\n                ret+=c;\\n                sub=(sub<<1);\\n                c=(c<<1);\\n            else:\\n                sub=(sub>>1);\\n                c=(c>>1);\\n        \\n        if(isMinus):\\n            ret=-ret;\\n        return min(max(-2147483648,ret),2147483647);",
                "codeTag": "Java"
            },
            {
                "id": 13460,
                "title": "6-line-solution-c",
                "content": "Basic idea: a/b = e^(ln(a))/e^(ln(b)) = e^(ln(a)-ln(b))\\n\\n    class Solution {\\n    public:\\n        int divide(int dividend, int divisor) {\\n            if (dividend==0) return 0;\\n            if (divisor==0) return INT_MAX;\\n            long long res=double(exp(log(fabs(dividend))-log(fabs(divisor))));\\n            if ((dividend<0)^(divisor<0)) res=-res;\\n            if (res>INT_MAX) res=INT_MAX;\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int divide(int dividend, int divisor) {\\n            if (dividend==0) return 0;\\n            if (divisor==0) return INT_MAX;\\n            long long res=double(exp(log(fabs(dividend))-log(fabs(divisor))));\\n            if ((dividend<0)^(divisor<0)) res=-res;\\n            if (res>INT_MAX) res=INT_MAX;\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1327339,
                "title": "java-0ms-100-faster-obeys-all-conditions",
                "content": "If you are furiously looking for answers as i was, let me shed some light. I had to spend a lots of time to understand the secret behind the solutions to this problem. \\n\\nFirst of all, As we all know already the basic idea for solving the problem with out the mod operator is simply **identifying the number of times the divisor can fully SUBSTRACT the dividend as a whole** but iterations are so costly and it will not work for large numbers. The obvious secret is to identify **effective way to reduce the number of substractions**\\n\\nThe following is simply my idea but there can be many as well, \\n\\n**1. Exponensly increase the divisor until before it surpass the dividend then substract with it.\\n2. Add up the divisor and find the remainder.\\n3. Repeat the same until it brings to 0**\\n\\nFor an example, 116 divided by 3, Following is the way to gradually reduce the possibilities and idendify the final quotient\\n\\n![image](https://assets.leetcode.com/users/images/31c9c3ac-8bd5-437a-a976-ad74d369e0f0_1624215160.6451015.png)\\n\\nLets start with 3, then double it which is 6 then 12, 24,..until we stop at 96 because 192 can be substracted. So here 96 == 3 * 2^5 ==  3 << 5 and quotient = 32, remainder = 20\\n\\nLet start the same process again with 20, it can go upto which gets to 12 == 3 * 2^2 == 3 << 2 then the quotient is now 32 + 4 = 36, reminder = 8\\n\\nLets start over again, i can go upto 6 which is again 6 == 3 * 2^1 == 3 << 1 the quotient is not 36+2 = 38, remainder = 2 which is less than divisor so we can not continue with the cycle and all ends here.\\n\\nHowever multiplication is not allowed to use let see what else we can do for replacing it. \\n\\n**Programmatic Rule:**\\nLeft Shift (<<) shall be considered as multiplication by 2^N\\nSimilarly, Right Shift (>>) shall be considered as division by 2^N \\n\\nSince the environment only allows to accomodate `integer`  data type, overflow cases are the corner cases.\\n\\nLets dive into the code,\\n\\n```java\\nclass Solution {\\n     public int divide(int dividend, int divisor) {\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE; //Cornor case when -2^31 is divided by -1 will give 2^31 which doesnt exist so overflow \\n         \\n        boolean negative = dividend < 0 ^ divisor < 0; //Logical XOR will help in deciding if the results is negative only if any one of them is negative\\n        \\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n        int quotient = 0, subQuot = 0;\\n        \\n        while (dividend - divisor >= 0) {\\n            for (subQuot = 0; dividend - (divisor << subQuot << 1) >= 0; subQuot++);\\n            quotient += 1 << subQuot; //Add to the quotient\\n            dividend -= divisor << subQuot; //Substract from dividend to start over with the remaining\\n        }\\n        return negative ? -quotient : quotient;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n     public int divide(int dividend, int divisor) {\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE; //Cornor case when -2^31 is divided by -1 will give 2^31 which doesnt exist so overflow \\n         \\n        boolean negative = dividend < 0 ^ divisor < 0; //Logical XOR will help in deciding if the results is negative only if any one of them is negative\\n        \\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n        int quotient = 0, subQuot = 0;\\n        \\n        while (dividend - divisor >= 0) {\\n            for (subQuot = 0; dividend - (divisor << subQuot << 1) >= 0; subQuot++);\\n            quotient += 1 << subQuot; //Add to the quotient\\n            dividend -= divisor << subQuot; //Substract from dividend to start over with the remaining\\n        }\\n        return negative ? -quotient : quotient;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13420,
                "title": "32-times-bit-shift-operation-in-c-with-o-1-solution",
                "content": "we assure the factor `ret`'s binary fomula is\\n\\n`ret = a0 + a1*2 + a2*2^2 + ...... + a29*2^29 + a30*2^30 + a31*2^31;  ai = 0 or 1, i = 0......31`\\n\\nthe dividend `B` and divisor `A` is non-negative, then\\n\\n`A(a0 + a1*2 + a2*2^2 + ...... + a29*2^29 + a30*2^30 + a31*2^31) = B;    Eq1`\\n\\n(1) when `Eq1` divided by `2^31`, we can get  `A*a31 = B>>31`;  then `a31 = (B>>31)/A`;\\n\\nif `(B>>31) > A`, then `a31 = 1`; else `a31 = 0`;\\n\\n(2) when `Eq1` divided by `2^30`, we can get  `A*a30 + A*a31*2 = B>>30`;  then `a30 = ((B>>30) - a31*A*2)/A`;  and `(B>>30) - a31*A*2` can be rewritten by `(B-a31*A<<31)>>30`, so we make `B' = B-a31*A<<31`, the formula simplified to `a30 = (B'>>30)/A`\\n\\nif `(B'>>30) > A`, then `a30 = 1`; else `a30 = 0`;\\n\\n(3) in the same reason, we can get  `a29 = ((B-a31*A<<31-a30*A<<30)>>29)/A`, we make `B'' = B' - a30*A<<30`, the formula simplified to `a29 = (B''>>29)/A`;\\n\\ndo the same bit operation `32` times, we can get `a31 ..... a0`, so we get the `ret` finally.\\n\\nthe C solution with constant time complexity\\n\\n    int divide(int dividend, int divisor) {\\n        //special cases\\n        if(divisor == 0 || (dividend == INT_MIN && divisor == -1))\\n            return INT_MAX;\\n        \\n        // transform to unsigned int\\n        bool sign = (dividend > 0)^(divisor > 0);\\n        unsigned int A = (divisor < 0) ? -divisor : divisor;\\n        unsigned int B = (dividend < 0) ? -dividend : dividend;\\n        int ret = 0;\\n        \\n        // shift 32 times\\n        for(int i = 31; i >= 0; i--)\\n        {\\n            if((B>>i) >= A)\\n            {\\n                ret = (ret<<1)|0x01;\\n                B -= (A<<i);   // update B\\n            }\\n            else\\n                ret = ret<<1;\\n        }\\n        \\n        if(sign)\\n            ret = -ret;\\n        \\n        return ret;\\n    }",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "we assure the factor `ret`'s binary fomula is\\n\\n`ret = a0 + a1*2 + a2*2^2 + ...... + a29*2^29 + a30*2^30 + a31*2^31;  ai = 0 or 1, i = 0......31`\\n\\nthe dividend `B` and divisor `A` is non-negative, then\\n\\n`A(a0 + a1*2 + a2*2^2 + ...... + a29*2^29 + a30*2^30 + a31*2^31) = B;    Eq1`\\n\\n(1) when `Eq1` divided by `2^31`, we can get  `A*a31 = B>>31`;  then `a31 = (B>>31)/A`;\\n\\nif `(B>>31) > A`, then `a31 = 1`; else `a31 = 0`;\\n\\n(2) when `Eq1` divided by `2^30`, we can get  `A*a30 + A*a31*2 = B>>30`;  then `a30 = ((B>>30) - a31*A*2)/A`;  and `(B>>30) - a31*A*2` can be rewritten by `(B-a31*A<<31)>>30`, so we make `B' = B-a31*A<<31`, the formula simplified to `a30 = (B'>>30)/A`\\n\\nif `(B'>>30) > A`, then `a30 = 1`; else `a30 = 0`;\\n\\n(3) in the same reason, we can get  `a29 = ((B-a31*A<<31-a30*A<<30)>>29)/A`, we make `B'' = B' - a30*A<<30`, the formula simplified to `a29 = (B''>>29)/A`;\\n\\ndo the same bit operation `32` times, we can get `a31 ..... a0`, so we get the `ret` finally.\\n\\nthe C solution with constant time complexity\\n\\n    int divide(int dividend, int divisor) {\\n        //special cases\\n        if(divisor == 0 || (dividend == INT_MIN && divisor == -1))\\n            return INT_MAX;\\n        \\n        // transform to unsigned int\\n        bool sign = (dividend > 0)^(divisor > 0);\\n        unsigned int A = (divisor < 0) ? -divisor : divisor;\\n        unsigned int B = (dividend < 0) ? -dividend : dividend;\\n        int ret = 0;\\n        \\n        // shift 32 times\\n        for(int i = 31; i >= 0; i--)\\n        {\\n            if((B>>i) >= A)\\n            {\\n                ret = (ret<<1)|0x01;\\n                B -= (A<<i);   // update B\\n            }\\n            else\\n                ret = ret<<1;\\n        }\\n        \\n        if(sign)\\n            ret = -ret;\\n        \\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3233898,
                "title": "best-c-2-solution-easy-solution-math-bit-manipulation-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Multiple Approaches. (Here I have explained all the possible solutions of this problem).\\n\\n1. Solved using Math + Bit Manipulation.\\n2. Solved using Math.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(log(N)*log(N)), The time complexity of the code is O(log(N)*log(N)) since the outer loop\\n    and the inner loop both runs log(N) times, where N is the dividend.\\n\\n    Space Complexity : O(1), The space complexity of the above code is O(1) since we\\u2019re using constant extra\\n    space.\\n\\n    Solved using Math + Bit Manipulation.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n        long long dvd = labs(dividend), dvs = labs(divisor), result = 0;\\n        int sign = (dividend > 0) ^ (divisor > 0) == 0 ? 1 : -1;\\n        while(dvd >= dvs){\\n            long long temp = dvs, mul = 1;\\n            while(temp << 1 <= dvd){\\n                temp <<= 1;\\n                mul <<= 1;\\n            }\\n            dvd -= temp;\\n            result += mul;\\n        } \\n        return sign*result;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(1), Constant Operation.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Math.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n        return dividend/divisor;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(log(N)*log(N)), The time complexity of the code is O(log(N)*log(N)) since the outer loop\\n    and the inner loop both runs log(N) times, where N is the dividend.\\n\\n    Space Complexity : O(1), The space complexity of the above code is O(1) since we\\u2019re using constant extra\\n    space.\\n\\n    Solved using Math + Bit Manipulation.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n        long long dvd = labs(dividend), dvs = labs(divisor), result = 0;\\n        int sign = (dividend > 0) ^ (divisor > 0) == 0 ? 1 : -1;\\n        while(dvd >= dvs){\\n            long long temp = dvs, mul = 1;\\n            while(temp << 1 <= dvd){\\n                temp <<= 1;\\n                mul <<= 1;\\n            }\\n            dvd -= temp;\\n            result += mul;\\n        } \\n        return sign*result;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(1), Constant Operation.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Math.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n        return dividend/divisor;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13402,
                "title": "fast-and-simple-python-solutions-56ms-64ms-no-bitwise-operators",
                "content": "idea: \\nkeep subtracting the new divisor `div` from the remaining `left` and then doubling `div` (by `div += div`). if `left < div`, start from the original divisor. Do these until `left < divisor.`<p>\\n\\n\\n----------\\n\\n\\n    def divide(self, dividend, divisor):     \\n        neg=( (dividend < 0) != (divisor < 0) )\\n        dividend = left = abs(dividend)\\n        divisor  = div  = abs(divisor)\\n        Q = 1\\n        ans = 0\\n        while left >= divisor:\\n            left -= div\\n            ans  += Q \\n            Q    += Q\\n            div  += div\\n            if left < div:\\n                div = divisor\\n                Q = 1\\n        if neg:\\n            return max(-ans, -2147483648)\\n        else:\\n            return min(ans, 2147483647)\\n\\n\\n----------\\n\\n\\nRecursive version: \\n\\n    def divide(self, dividend, divisor):  \\n        neg=( (dividend < 0) != (divisor < 0) )\\n        dividend = left = abs(dividend)\\n        divisor  = div  = abs(divisor)       \\n        if dividend < divisor:\\n            return 0\\n        Q = 1\\n        ans = 0\\n        while left >= div:\\n            left -= div\\n            ans  += Q\\n            Q    += Q\\n            div  += div\\n        if neg:\\n            return max(-(ans + self.divide(left, divisor)), -2147483648)\\n        else:\\n            return min(ans + self.divide(left, divisor), 2147483647)",
                "solutionTags": [
                    "Python"
                ],
                "code": "idea: \\nkeep subtracting the new divisor `div` from the remaining `left` and then doubling `div` (by `div += div`). if `left < div`, start from the original divisor. Do these until `left < divisor.`<p>\\n\\n\\n----------\\n\\n\\n    def divide(self, dividend, divisor):     \\n        neg=( (dividend < 0) != (divisor < 0) )\\n        dividend = left = abs(dividend)\\n        divisor  = div  = abs(divisor)\\n        Q = 1\\n        ans = 0\\n        while left >= divisor:\\n            left -= div\\n            ans  += Q \\n            Q    += Q\\n            div  += div\\n            if left < div:\\n                div = divisor\\n                Q = 1\\n        if neg:\\n            return max(-ans, -2147483648)\\n        else:\\n            return min(ans, 2147483647)\\n\\n\\n----------\\n\\n\\nRecursive version: \\n\\n    def divide(self, dividend, divisor):  \\n        neg=( (dividend < 0) != (divisor < 0) )\\n        dividend = left = abs(dividend)\\n        divisor  = div  = abs(divisor)       \\n        if dividend < divisor:\\n            return 0\\n        Q = 1\\n        ans = 0\\n        while left >= div:\\n            left -= div\\n            ans  += Q\\n            Q    += Q\\n            div  += div\\n        if neg:\\n            return max(-(ans + self.divide(left, divisor)), -2147483648)\\n        else:\\n            return min(ans + self.divide(left, divisor), 2147483647)",
                "codeTag": "Python3"
            },
            {
                "id": 13528,
                "title": "ac-javascript-code",
                "content": "The algorithm is just the same as many other posts, double the divisor by shifting left 1 bit.\\n\\nBut I still got TLE 3 times, the trick is: JavaScript bitwise op is for signed 32-bit, so \\n\\n    while ((base << 1) <= dividend) {\\n\\ndoesn't work. Because \"base\" overflows.\\n\\n    while (base <= (dividend >> 1)) {\\n\\nworks.\\n\\n    /**\\n     * @param {number} dividend\\n     * @param {number} divisor\\n     * @return {number}\\n     */\\n    var divide = function(dividend, divisor) {\\n      if (divisor === 0) return 0;\\n      if (dividend === 0) return 0;\\n      if (dividend === -2147483648 && divisor === -1) return 2147483647;\\n    \\n      var isPositive = true;\\n      if (dividend > 0 !== divisor > 0) isPositive = false;\\n    \\n      divisor = Math.abs(divisor);\\n      dividend = Math.abs(dividend);\\n    \\n      var count = 1,\\n        result = 0,\\n        base = divisor;\\n    \\n      while (dividend >= divisor) {\\n        count = 1;\\n        base = divisor;\\n        while (base <= (dividend >> 1)) {\\n          base = base << 1;\\n          count = count << 1;\\n        }\\n        result += count;\\n        dividend -= base;\\n      }\\n    \\n      if (!isPositive) result = -result;\\n      return result;\\n    };",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation",
                    "Binary Tree"
                ],
                "code": "The algorithm is just the same as many other posts, double the divisor by shifting left 1 bit.\\n\\nBut I still got TLE 3 times, the trick is: JavaScript bitwise op is for signed 32-bit, so \\n\\n    while ((base << 1) <= dividend) {\\n\\ndoesn't work. Because \"base\" overflows.\\n\\n    while (base <= (dividend >> 1)) {\\n\\nworks.\\n\\n    /**\\n     * @param {number} dividend\\n     * @param {number} divisor\\n     * @return {number}\\n     */\\n    var divide = function(dividend, divisor) {\\n      if (divisor === 0) return 0;\\n      if (dividend === 0) return 0;\\n      if (dividend === -2147483648 && divisor === -1) return 2147483647;\\n    \\n      var isPositive = true;\\n      if (dividend > 0 !== divisor > 0) isPositive = false;\\n    \\n      divisor = Math.abs(divisor);\\n      dividend = Math.abs(dividend);\\n    \\n      var count = 1,\\n        result = 0,\\n        base = divisor;\\n    \\n      while (dividend >= divisor) {\\n        count = 1;\\n        base = divisor;\\n        while (base <= (dividend >> 1)) {\\n          base = base << 1;\\n          count = count << 1;\\n        }\\n        result += count;\\n        dividend -= base;\\n      }\\n    \\n      if (!isPositive) result = -result;\\n      return result;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 13426,
                "title": "simple-o-log-n-2-c-solution",
                "content": "Long division in binary:\\nThe outer loop reduces n by at least half each iteration. So It has O(log N) iterations.\\nThe inner loop has at most log N iterations. \\n So  the overall complexity is O(( log N)^2) \\n\\n    typedef long long ll;\\n\\n    int divide(int n_, int d_) {\\n        ll ans=0;\\n        ll n=abs((ll)n_);\\n        ll d=abs((ll)d_);\\n        while(n>=d){\\n            ll a=d;\\n            ll m=1;\\n            while((a<<1) < n){a<<=1;m<<=1;}\\n            ans+=m;\\n            n-=a;\\n        }\\n        if((n_<0&&d_>=0)||(n_>=0&&d_<0))\\n            return -ans;\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "Long division in binary:\\nThe outer loop reduces n by at least half each iteration. So It has O(log N) iterations.\\nThe inner loop has at most log N iterations. \\n So  the overall complexity is O(( log N)^2) \\n\\n    typedef long long ll;\\n\\n    int divide(int n_, int d_) {\\n        ll ans=0;\\n        ll n=abs((ll)n_);\\n        ll d=abs((ll)d_);\\n        while(n>=d){\\n            ll a=d;\\n            ll m=1;\\n            while((a<<1) < n){a<<=1;m<<=1;}\\n            ans+=m;\\n            n-=a;\\n        }\\n        if((n_<0&&d_>=0)||(n_>=0&&d_<0))\\n            return -ans;\\n        return ans;\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 1163652,
                "title": "accepted-solution-for-swift",
                "content": "```swift\\nclass Solution {\\n    func divide(_ dd: Int, _ dr: Int) -> Int {\\n        let dd64 = Int64(abs(dd)), dr64 = Int64(abs(dr))\\n        var val: Int64 = 0, lhs: Int64 = 1, rhs = dd64\\n        while lhs <= rhs {\\n            let mid = (lhs + rhs) / 2\\n            if mid * dr64 <= dd64 {\\n                val = mid\\n                lhs = mid + 1\\n            } else {\\n                rhs = mid - 1\\n            }\\n        }\\n        return max(min(Int((dd * dr) < 0 ? -val : val), Int(Int32.max)), Int(Int32.min))\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<p><details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<p><pre>\\nResult: Executed 4 tests, with 0 failures (0 unexpected) in 0.006 (0.008) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // 10/3 = 3.33333.. which is truncated to 3.\\n    func test0() {\\n        let value = solution.divide(10, 3)\\n        XCTAssertEqual(value, 3)\\n    }\\n    \\n    // 7/-3 = -2.33333.. which is truncated to -2.\\n    func test1() {\\n        let value = solution.divide(7, -3)\\n        XCTAssertEqual(value, -2)\\n    }\\n    \\n    func test2() {\\n        let value = solution.divide(0, -1)\\n        XCTAssertEqual(value, 0)\\n    }\\n    \\n    func test3() {\\n        let value = solution.divide(1, 1)\\n        XCTAssertEqual(value, 1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details></p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func divide(_ dd: Int, _ dr: Int) -> Int {\\n        let dd64 = Int64(abs(dd)), dr64 = Int64(abs(dr))\\n        var val: Int64 = 0, lhs: Int64 = 1, rhs = dd64\\n        while lhs <= rhs {\\n            let mid = (lhs + rhs) / 2\\n            if mid * dr64 <= dd64 {\\n                val = mid\\n                lhs = mid + 1\\n            } else {\\n                rhs = mid - 1\\n            }\\n        }\\n        return max(min(Int((dd * dr) < 0 ? -val : val), Int(Int32.max)), Int(Int32.min))\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // 10/3 = 3.33333.. which is truncated to 3.\\n    func test0() {\\n        let value = solution.divide(10, 3)\\n        XCTAssertEqual(value, 3)\\n    }\\n    \\n    // 7/-3 = -2.33333.. which is truncated to -2.\\n    func test1() {\\n        let value = solution.divide(7, -3)\\n        XCTAssertEqual(value, -2)\\n    }\\n    \\n    func test2() {\\n        let value = solution.divide(0, -1)\\n        XCTAssertEqual(value, 0)\\n    }\\n    \\n    func test3() {\\n        let value = solution.divide(1, 1)\\n        XCTAssertEqual(value, 1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1084819,
                "title": "python-o-log-n-honest-solution-explained",
                "content": "I do not really like these type of problems, where you restricted in using operations. What we can use if we can not use multiplications and divisions: we can use only addition and subtraction. Let consider an example:\\n`100 // 7`\\n\\nWe can try just to subtract `7` while it is possible.  However potentially it can be quite long, if `dividend` is big and `divisor` is small. Let us multiply `7` by `2` (in fact it is not multiplication, but addition with itself), until we are smaller than `100`.  `7 -> 14 -> 28 -> 56`. Ans subtract `56` now, so we have `8` as result and we need to divide `44` by `7` now. Repeat procedure, so we subtract `28`, and we have `8 + 4` as result and `44 - 28 = 16 = 2`. Finally, we subtract `14` and we have `8 + 4 + 2 = 14` as result.\\n\\nLet us precalculate pairs `(7, 1), (14, 2), (28, 4), (56, 8)`. Then we iterate through these pairs in opposite direction and if we can subtract corresponding number, we subtract, if not - we go to the next one. Also we need to deal with signs and overflows here.\\n\\n**Complexity**: time complexity is `O(log n)`, where `n = divident/divisor`: there will be `O(log n)` terms in our `cand` list as well as this is limit for number of steps. Space complexity is `O(log n)` as well. What I mean by **honest** here, that a lot of people here in discussion either use some tricks which are not allowed, or complexity is wrong.\\n\\n```\\nclass Solution:\\n    def divide(self, dividend, divisor):\\n        if dividend == -1<<31 and divisor == -1: return (1<<31)-1\\n\\n        a, b = abs(dividend), abs(divisor)\\n        sign = (dividend < 0) == (divisor < 0)\\n        res, cand = 0, [(1, b)]\\n        \\n        while b << 1 <= a:\\n            cand += [(cand[-1][0]<<1, b<<1)]\\n            b <<= 1\\n            \\n        for pw, num in cand[::-1]:\\n            if a >= num:\\n                a, res = a - num, res + pw\\n                \\n        return res if sign else -res\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend, divisor):\\n        if dividend == -1<<31 and divisor == -1: return (1<<31)-1\\n\\n        a, b = abs(dividend), abs(divisor)\\n        sign = (dividend < 0) == (divisor < 0)\\n        res, cand = 0, [(1, b)]\\n        \\n        while b << 1 <= a:\\n            cand += [(cand[-1][0]<<1, b<<1)]\\n            b <<= 1\\n            \\n        for pw, num in cand[::-1]:\\n            if a >= num:\\n                a, res = a - num, res + pw\\n                \\n        return res if sign else -res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 715094,
                "title": "python-fast-code-with-detailed-explanation",
                "content": "I took the code of  [@tusizi](https://leetcode.com/problems/divide-two-integers/discuss/13403/Clear-python-code) and made it easier to understand by changing variable names, and adding a detailed explanation for each line. I\\'m also not experienced myself and whatever I right here comes from discussion forums and googling. The high level idea is that you substract `dividend` by `divisor` until `dividend` is less than `divisor`.  Also, the solution has two `while` loops. The inner `while` loop tries to substract `divisor`, `2*divisor`, `4*divisor` and so on, until `dividend` is less than `divisor` where it starts over the outer `while` loop. \\n\\n```\\nclass Solution:\\n# @return an integer\\ndef divide(self, dividend, divisor):\\n    positive = (dividend < 0) is (divisor < 0) # 1\\n    dividend, divisor = abs(dividend), abs(divisor) # 2\\n    res = 0 # 3\\n    while dividend >= divisor: # 4\\n            curr_divisor, num_divisors = divisor, 1 # 5\\n            while dividend >= curr_divisor: # 6\\n                dividend -= curr_divisor # 7\\n                res += num_divisors # 8\\n                \\n                curr_divisor = curr_divisor << 1 # 9\\n                num_divisors = num_divisors << 1 # 10\\n\\t\\t\\t\\t\\n    if not positive: # 11\\n        res = -res # 12\\n\\t\\t\\n    return min(max(-2147483648, res), 2147483647) # 13\\n```\\n\\n`#1`: `is` operator is similar to `==` operator except that it compares that whether both the operands refer to the same object or not. check [this](https://www.***.org/difference-operator-python/).\\nSo here, if both of `dividend` and `divisor` have similar sign, it returns `True`. Otherwise, `False`. This will be used in line `#11` when we check if the `positive` variable is `True` or `False`. And, if it\\'s not `True` (meaning if they don\\'t have similar signs, we add a `-` to the output (`#12`). Note that in this example `==` works just fine as `is`. \\n\\n`#2`: No that we decided on the sign in line `#1`, we can use absolute values of `dividend` and `divisor`. That\\'s what\\'s being done here. \\n\\n`#3`: Initiating the output by setting it to zero. \\n\\n`#4`: So the high level idea is that we substract `divisor` from `dividend` until we can\\'t substract anymore. Imagine you want to divide 7 by 2. 7-2 =5, 5-2=3, 3-2 = 1 ! You can\\'t substract anymore. Them the `while` loope stops. \\n\\n`#5`: Now, we enter the main (tricky, challenging, confusing) part of the code. This line is not complicated. It simply initilize some values, meaning `curr_divisor` and `num_divisors\\' with `divisor` and `1`, recpectively. This means we assume `curr_divisor = divisor` and `num_divisor = 1`, initially. \\n\\n`#7` and `#8`: These two lines are updating `dividend` and `res`. When you substract `dividend` by `curr_divisor`, you\\'re basically saying if I was going to calculating the quotient of division, I could still cut another piece with the size of `divisor` from `dividend`, and that\\'s why you update the `res` variable by num_divisor (`res += num_divisors` means `res = res + num_divisors`). \\n\\n`#9` and `#10`: `currdivisor = currdivisor << 1` is the same as `currdivisor = currdivisor  2`, and `numdivisors = numdivisors << 1`, is the same as`numdivisors = numdivisors2`. This is called bitwise operation. Check [this](https://wiki.python.org/moin/BitwiseOperators). `<<` sign is left-shifting bitwise operator which shift bits in binary of a number by one to the left. Imaging you have number 4, (`bin(4) = 0b100`)! doing `4 >> 1` make the new binary `1000` (shifted to the left by 1 and added a zero to the rightmost bit) which is the binary for 8. The reason it tries to do the multiplicaion is to fasten the process. From [here](https://leetcode.com/problems/divide-two-integers/discuss/13403/Clear-python-code/329694), A naive method here is to repeatedly subtract divisor from dividend, until there is none enough left. Then the count of subtractions will be the answer. Yet this takes linear time and is thus slow. A better method is to subtract divisor in a more efficient way. We can subtract divisor, 2divisor, 4divisor, 8*divisor... as is implemented above. .It will go to the outer loop once it cannot substract anymore of `curr_divisor` from `dividend`, and set the `curr_divisor = divisor` and tries the actual divisor (no 2  multiplications). \\n\\n`#13`: We are told by problem statement to limit the output to 32-bit integers, meaning the `res` parameter fall in the [-2^31, 2*^31-1] range. Here, the line has two components. First, it compares output (`res`) with -2^31 value and return the max of the two since we don\\'t want values less than -2^31. Next, it compares the value from `max(-2147483648, res)` with the maximum allowable value (meaning 2^31). So, if we put `a = max(-2147483648, res)`, then it does `min(a, 2147483647)` and return the min of two since we\\'re not allowed to go above 2^31 = 2147483647 number. \\n\\n=========================================\\n\\nFinal note: In order to fully understand the code, I suggest to grab a piece of paper and pen (or write on a notepad or something similar in out laptop/pc) and write a simple example and try to pass through the algorithm by hand. Here is an example from [this](https://leetcode.com/problems/divide-two-integers/discuss/13403/Clear-python-code/144026). \\n\\nLet\\'s take an example: `50 / 4`\\nAt the start,\\n`curr_divisor, num_divisors = divisor, 1` # dividend = 50, curr_divisor = 4, num_divisors = 1\\n`dividend -= curr_divisor` # dividend = 46, curr_divisor = 4 ,num_divisors = 1\\n`res += num_divisors` # res = 1\\n`num_divisors <<= 1 ` # dividend = 46, curr_divisor = 4 , num_divisors = 2\\n`curr_divisor <<= 1` # dividend = 46, curr_divisor = 8 , num_divisors = 2\\n\\nSecond iteration:\\n`dividend -= curr_divisor` # dividend = 38, curr_divisor = 8 , num_divisors= 2\\n`res += num_divisors` # res = 3\\n`num_divisors <<= 1` # dividend = 38, curr_divisor = 8 , num_divisors = 3\\n`curr_divisor <<= 1` # dividend = 38, curr_divisor = 12 ,  num_divisors = 3\\n\\nand so on, when `dividend > curr_divisor`, we start over again with `curr_divisor = 4`, and `num_divisors = 1`\\n\\n\\n===========================================================================\\nFinal note 2: Since I believe if I could explain something to others in a simple manner, it would be helpful to me, I try to add more posts like this as I move forward through my leetcode journey. \\n\\nFinal note 3: There might be some typos in the writing above!!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n# @return an integer\\ndef divide(self, dividend, divisor):\\n    positive = (dividend < 0) is (divisor < 0) # 1\\n    dividend, divisor = abs(dividend), abs(divisor) # 2\\n    res = 0 # 3\\n    while dividend >= divisor: # 4\\n            curr_divisor, num_divisors = divisor, 1 # 5\\n            while dividend >= curr_divisor: # 6\\n                dividend -= curr_divisor # 7\\n                res += num_divisors # 8\\n                \\n                curr_divisor = curr_divisor << 1 # 9\\n                num_divisors = num_divisors << 1 # 10\\n\\t\\t\\t\\t\\n    if not positive: # 11\\n        res = -res # 12\\n\\t\\t\\n    return min(max(-2147483648, res), 2147483647) # 13\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1076061,
                "title": "broken-calculator-js-python-java-c-simple-solution-w-detailed-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations ([**index**](https://dev.to/seanpgallivan/leetcode-solutions-index-57fl)). If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe first thing we should be able to understand is that one of the operations increases **X** while the other one decreases it. So the natural tendency is to think about the solution in terms of applying these operations in order. That is, multiply as many times as you need to before subtracting as many times as you need to.\\n\\nWe see that that\\'s not a viable solution, however, once we recognize that one of the operations is quite obviously multiplicative rather than additive, meaning that a subtraction done *before* a multiplication has twice the impact, for example.\\n\\nSo the trick here is to think of the problem backwards: moving from **Y** to **X** instead of from **X** to **Y**. If **Y** is odd, we\\'re forced to do the additive operation (reversed from the subtractive operation) as we can\\'t divide an odd number by **2** and be able to reach **X**. If **Y** is even, we can prioritize the division operation instead. At each step we can increment our **ans**.\\n\\nOnce **Y** drops below **X**, the remaining difference must be made via the additive operation, so we can just **return** that difference plus **ans**.\\n\\n**To illustrate why the backwards order leads to the correct solution**, let\\'s take a look at an example: **X = 3, Y = 13**. Under the naive approach discussed at the very beginning of this section, we could apply the multiplication operation **3** times to achieve **24**, then apply the subtraction operation **11** times to bring **Y** back down to **13**.\\n\\nAs we observed before, that **11** is not very efficient, considering that some/all of those subtraction operations could have been done before some/all of the multiplication operations with greater impact.\\n\\nSo what if we had applied as many of those operations as necessary just *before* the last of the three multiplications? Then we would only have needed **5** operations to effect **10** subtraction, plus the leftover **1** to get to **11** at the end.\\n\\nIf we go back one more step before the second of three multiplications, we could have instead done **2** operations then which would have the effect of **8** substraction, plus an extra operation after the second multiplication (adding another **2** subtraction), plus the final operation after all multiplications to reach **11**.\\n\\nThis quickly begins to represent a binary representation of our target difference of **11**:\\n```js\\n     Total multiplications:                                 In binary: (11 = 1011)\\n        3    2    1    0\\n                      11   =   11 in 11 operations                   1011   =   11\\n                  5    1   =   11 in 6 operations                 101 + 1   =   6\\n             2    1    1   =   11 in 4 operations              10 + 1 + 1   =   4\\n        1    0    1    1   =   11 in 3 operations           1 + 0 + 1 + 1   =   3\\n```\\nWe can already see that this is starting to look like our backwards approach. At each additional multiplication operation available, we\\'re forced to perform a subtraction operation if the difference is still odd, otherwise, we can divide the remainder by **2** and push it back one multiplication earlier.\\n\\nBasically, for each multiplication we need to take **X** over **Y**, we take the remaining difference, count the first bit, then shift the difference to the right. And that should sound *exactly* like our backwards approach, because the first bit is a **0** if even and **1** if odd, and shifting to the right is the same as dividing by **2**.\\n\\n**So why can\\'t we go forwards with X instead of backwards with Y?** As mentioned before, the multiplication operation is, quite obviously, multiplicative, and will have an enhancing effect on any subtraction operations performed before it. Therefore, *we cannot possibly know* how much impact any given subtraction operation will have on the difference between **X** and **Y** until we find out how many multiplication operations we will need after it.\\n\\nSo any solution involving moving **X** to **Y** would at least require \"peeking\" ahead at part of the solution before progressing with the subtraction operations.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThis solution is almost identical in all four languages.\\n\\nPython will convert our integer into a float if we simply divide by 2, so we can use the floor division operator instead to maintain the integer.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **68ms / 38.2MB** (beats 100% / 90%).\\n```javascript\\nvar brokenCalc = function(X, Y) {\\n    let ans = 0\\n    while (X < Y) {\\n        ans++\\n        if (Y % 2) Y++\\n        else Y /= 2\\n    }\\n    return X - Y + ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **20ms / 14.1MB** (beats 99% / 90%).\\n```python\\nclass Solution:\\n    def brokenCalc(self, X: int, Y: int) -> int:\\n        ans = 0\\n        while X < Y:\\n            ans += 1\\n            if Y % 2: Y += 1\\n            else: Y //= 2\\n        return X - Y + ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 35.4MB** (beats 100% / 98%).\\n```java\\nclass Solution {\\n    public int brokenCalc(int X, int Y) {\\n        int ans = 0;\\n        while (X < Y) {\\n            ans++;\\n            if (Y % 2 > 0) Y++;\\n            else Y /= 2;\\n        }\\n        return X - Y + ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 5.8MB** (beats 100% / 81%).\\n```c++\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        int ans = 0;\\n        while (X < Y) {\\n            ans++;\\n            if (Y % 2) Y++;\\n            else Y /= 2;\\n        }\\n        return X - Y + ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\n     Total multiplications:                                 In binary: (11 = 1011)\\n        3    2    1    0\\n                      11   =   11 in 11 operations                   1011   =   11\\n                  5    1   =   11 in 6 operations                 101 + 1   =   6\\n             2    1    1   =   11 in 4 operations              10 + 1 + 1   =   4\\n        1    0    1    1   =   11 in 3 operations           1 + 0 + 1 + 1   =   3\\n```\n```javascript\\nvar brokenCalc = function(X, Y) {\\n    let ans = 0\\n    while (X < Y) {\\n        ans++\\n        if (Y % 2) Y++\\n        else Y /= 2\\n    }\\n    return X - Y + ans\\n};\\n```\n```python\\nclass Solution:\\n    def brokenCalc(self, X: int, Y: int) -> int:\\n        ans = 0\\n        while X < Y:\\n            ans += 1\\n            if Y % 2: Y += 1\\n            else: Y //= 2\\n        return X - Y + ans\\n```\n```java\\nclass Solution {\\n    public int brokenCalc(int X, int Y) {\\n        int ans = 0;\\n        while (X < Y) {\\n            ans++;\\n            if (Y % 2 > 0) Y++;\\n            else Y /= 2;\\n        }\\n        return X - Y + ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        int ans = 0;\\n        while (X < Y) {\\n            ans++;\\n            if (Y % 2) Y++;\\n            else Y /= 2;\\n        }\\n        return X - Y + ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2871168,
                "title": "python3-easiest-solution",
                "content": "1) Define the result\\'s sign and operate with positive dividend and divisor.\\n2) Calculate the result using the length of range.\\n3) Apply the sign.\\n4) Apply the 32-bit integer limitations.\\n\\nNo multiplication, division, or mod used.\\n\\n\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        sign = -1 if (dividend >= 0 and divisor < 0) or (dividend < 0 and divisor >= 0) else 1\\n        dividend = abs(dividend)\\n        divisor = abs(divisor)\\n        result = len(range(0, dividend-divisor+1, divisor))\\n        if sign == -1:\\n            result = -result\\n        minus_limit = -(2**31)\\n        plus_limit = (2**31 - 1)\\n        result = min(max(result, minus_limit), plus_limit)\\n        return result\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "1) Define the result\\'s sign and operate with positive dividend and divisor.\\n2) Calculate the result using the length of range.\\n3) Apply the sign.\\n4) Apply the 32-bit integer limitations.\\n\\nNo multiplication, division, or mod used.\\n\\n\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        sign = -1 if (dividend >= 0 and divisor < 0) or (dividend < 0 and divisor >= 0) else 1\\n        dividend = abs(dividend)\\n        divisor = abs(divisor)\\n        result = len(range(0, dividend-divisor+1, divisor))\\n        if sign == -1:\\n            result = -result\\n        minus_limit = -(2**31)\\n        plus_limit = (2**31 - 1)\\n        result = min(max(result, minus_limit), plus_limit)\\n        return result\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 778597,
                "title": "javascript-with-explanation-80ms-21-lines",
                "content": "Think of multiplication as just a * b = c. This can be rewritten as a + a + a + ... + a + a = c where a is repeated b times. Using this fact, we could naively keep subtracting a from c until c is too small, but this takes too long for large numbers. In order to speed this up, we keep doubling the total number of a\\'s we can subtract, there by making large calculations logarithmic instead of linear. I.e. we check if we can subtract one a, then 2 a\\'s, then 4 a\\'s, then 8 a\\'s, all the way until we cannot subtract anymore. \\n\\nI\\'ll also note that I\\'ve seen a lot of bit manipulation answers here as well. While that is cool, and very useful for lower level coding, if your goal is to understand algorithms I wouldn\\'t worry about these implementations. Just my two cents.\\n\\nStay coding!\\n\\n```\\nvar divide = function(dividend, divisor) {\\n    const retIsNegative = Math.sign(divisor) !== Math.sign(dividend);\\n    dividend = Math.abs(dividend)\\n    divisor = Math.abs(divisor)\\n    \\n    let ret = 0\\n    while (divisor <= dividend) {\\n        let value = divisor\\n        let multiple = 1\\n        while (value + value <= dividend) {\\n            value += value\\n            multiple += multiple\\n        }\\n        dividend = dividend - value\\n        ret += multiple\\n    }\\n    \\n    if (ret > ((2**31) - 1)) {\\n        return retIsNegative ? -(2**31) : 2**31 - 1\\n    }\\n    return retIsNegative ? -ret : ret\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\nvar divide = function(dividend, divisor) {\\n    const retIsNegative = Math.sign(divisor) !== Math.sign(dividend);\\n    dividend = Math.abs(dividend)\\n    divisor = Math.abs(divisor)\\n    \\n    let ret = 0\\n    while (divisor <= dividend) {\\n        let value = divisor\\n        let multiple = 1\\n        while (value + value <= dividend) {\\n            value += value\\n            multiple += multiple\\n        }\\n        dividend = dividend - value\\n        ret += multiple\\n    }\\n    \\n    if (ret > ((2**31) - 1)) {\\n        return retIsNegative ? -(2**31) : 2**31 - 1\\n    }\\n    return retIsNegative ? -ret : ret\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 13422,
                "title": "accepted-java-solution-with-comments",
                "content": "    public int divide(int dividend, int divisor) {\\n\\t\\tlong result = divideLong(dividend, divisor);\\n\\t\\treturn result > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int)result;\\n    }\\n\\t\\n\\t// It's easy to handle edge cases when\\n\\t// operate with long numbers rather than int\\n\\tpublic long divideLong(long dividend, long divisor) {\\n\\t\\t\\n\\t\\t// Remember the sign\\n\\t\\tboolean negative = dividend < 0 != divisor < 0;\\n\\t\\t\\n\\t\\t// Make dividend and divisor unsign\\n\\t\\tif (dividend < 0) dividend = -dividend;\\n\\t\\tif (divisor < 0) divisor = -divisor;\\n\\t\\t\\n\\t\\t// Return if nothing to divide\\n\\t\\tif (dividend < divisor) return 0;\\n\\t\\t\\n\\t\\t// Sum divisor 2, 4, 8, 16, 32 .... times\\n        long sum = divisor;\\n        long divide = 1;\\n        while ((sum+sum) <= dividend) {\\n        \\tsum += sum;\\n        \\tdivide += divide;\\n        }\\n        \\n        // Make a recursive call for (devided-sum) and add it to the result\\n        return negative ? -(divide + divideLong((dividend-sum), divisor)) :\\n        \\t(divide + divideLong((dividend-sum), divisor));\\n    }",
                "solutionTags": [],
                "code": "    public int divide(int dividend, int divisor) {\\n\\t\\tlong result = divideLong(dividend, divisor);\\n\\t\\treturn result > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int)result;\\n    }\\n\\t\\n\\t// It's easy to handle edge cases when\\n\\t// operate with long numbers rather than int\\n\\tpublic long divideLong(long dividend, long divisor) {\\n\\t\\t\\n\\t\\t// Remember the sign\\n\\t\\tboolean negative = dividend < 0 != divisor < 0;\\n\\t\\t\\n\\t\\t// Make dividend and divisor unsign\\n\\t\\tif (dividend < 0) dividend = -dividend;\\n\\t\\tif (divisor < 0) divisor = -divisor;\\n\\t\\t\\n\\t\\t// Return if nothing to divide\\n\\t\\tif (dividend < divisor) return 0;\\n\\t\\t\\n\\t\\t// Sum divisor 2, 4, 8, 16, 32 .... times\\n        long sum = divisor;\\n        long divide = 1;\\n        while ((sum+sum) <= dividend) {\\n        \\tsum += sum;\\n        \\tdivide += divide;\\n        }\\n        \\n        // Make a recursive call for (devided-sum) and add it to the result\\n        return negative ? -(divide + divideLong((dividend-sum), divisor)) :\\n        \\t(divide + divideLong((dividend-sum), divisor));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1085017,
                "title": "js-python-java-c-updated-logarithmic-bit-manipulation-solutions-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\n*(Note: Some have questioned whether or not bitwise shifts should count as multiplication/division, so I\\'ve added an alternate solution explanation taking advantage of the algebraic qualities of logarithms below in the **Alaternate Idea** section.)*\\n\\nThe naive approach here would be to use a loop to just work down the difference between the dividend (**A**) and the divisor (**B**) through subtraction, but that\\'s obviously not a very efficient solution.\\n\\nInstead, we can use **bit manipulation** to simulate multiplication/division. Since a **bitwise shift** to the left is the equivalent of a multiplication by **2**, if we count how many times we can bitwise shift **B** to the left while still staying under **A**, then we can quickly work out a chunk of the solution. All that\\'s left is to start over with the remaining amount of **A** and repeat this process, adding the results to our answer (**ans**) as we go.\\n\\nOf course, negative numbers will play havoc with our bitwise shifting, so we should first extract the **sign** difference and then use only positive numbers for **A** and **B**.\\n\\nThere\\'s also the stated edge case, which only occurs at one permutation of **A** and **B**, so we can handle that at the outset.\\n\\n---\\n\\n#### ***Alternate Idea:***\\n\\nFor those who consider bitwise shifts to be too close to multiplication/division, we can instead use the rules of **logarithms** to our advantage:\\n```c++\\n  if:  exp(log(c) = c                   // Logarithmic rule #1\\n  if:  log(a / b) = log(a) - log(b)     // Logarithmic rule #2\\n\\nthen:  a / b = exp(log(a / b))          // From rule #1\\n       a / b = exp(log(a) - log(b))     // From rule #2\\n\\n       (if m and n are > 0)\\n```\\nSince we\\'ll have to use the absolute values of **A** and **B**, we\\'ll have to define the same edge cases as in the earlier solutions. Finally, we\\'ll also have to apply a **floor()** to the result to truncate the decimal before we **return ans**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nJavascript and Python both handle numbers larger than **32-bit** internally, and Java requires only a small change to the conditions on its loops to avoid an issue.\\n\\nC++, on the other hand, adheres strictly to the **32-bit** limit, so we have to define a few more edge cases to avoid exceeding these boundaries. That does allow us to simplify the code for both loops, however.\\n\\n---\\n\\n#### ***Javascript Code w/ Bit Manipulation:***\\n\\nThe best result for the code below is **84ms / 39.8MB** (beats 99% / 96%).\\n```javascript\\nvar divide = function(A, B) {\\n    if (A === -2147483648 && B === -1) return 2147483647\\n    let ans = 0, sign = 1\\n    if (A < 0) A = -A, sign = -sign\\n    if (B < 0) B = -B, sign = -sign\\n    if (A === B) return sign\\n    for (let i = 0, val = B; A >= B; i = 0, val = B) {\\n        while (val > 0 && val <= A) val = B << ++i\\n        A -= B << i - 1, ans += 1 << i - 1\\n    }\\n    return sign < 0 ? -ans : ans\\n};\\n```\\n\\n---\\n\\n#### ***Javascript Code w/ Logarithms:***\\n\\nThe best result for the code below is **84ms / 40.1MB** (beats 99% / 63%).\\n```javascript\\nvar divide = function(A, B) {\\n    let ans = 0\\n    if (B === -2147483648) return A === B\\n    if (A === -2147483648)\\n        if (B === 1) return -2147483648\\n        else if (B === -1) return 2147483647\\n        else A += Math.abs(B), ans++\\n    ans += Math.floor(Math.exp(Math.log(Math.abs(A)) - Math.log(Math.abs(B))))\\n    return A > 0 === B > 0 ? ans : -ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code w/ Bit Manipulation:***\\n\\nThe best result for the code below is **20ms / 14.0MB** (beats 100% / 95%).\\n```python\\nclass Solution:\\n    def divide(self, A: int, B: int) -> int:\\n        if A == -2147483648 and B == -1: return 2147483647\\n        ans, sign = 0, 1\\n        if A < 0: A, sign = -A, -sign\\n        if B < 0: B, sign = -B, -sign\\n        if A == B: return sign\\n        while A >= B:\\n            b = 0\\n            while B << b <= A: b += 1\\n            A -= B << b - 1\\n            ans += 1 << b - 1\\n        return -ans if sign < 0 else ans\\n```\\n\\n---\\n\\n#### ***Python Code w/ Logarithms:***\\n\\nThe best result for the code below is **28ms / 14.1MB** (beats 92% / 95%).\\n```python\\nclass Solution:\\n    def divide(self, A: int, B: int) -> int:\\n        if A == 0: return 0\\n        if A == -2147483648 and B == -1: return 2147483647\\n        ans = math.floor(math.exp(math.log(abs(A)) - math.log(abs(B))))\\n        return ans if (A > 0) == (B > 0) else -ans\\n```\\n\\n---\\n\\n#### ***Java Code w/ Bit Manipulation:***\\n\\nThe best result for the code below is **1ms / 35.8MB** (beats 100% / 97%).\\n```java\\nclass Solution {\\n    public int divide(int A, int B) {\\n        if (A == -2147483648 && B == -1) return 2147483647;\\n        int ans = 0, sign = A > 0 == B > 0 ? 1 : -1;\\n        if (A < 0) A = -A;\\n        if (B < 0) B = -B;\\n        if (A == B) return sign;\\n        for (int i = 0, val = B; A - B >= 0; i = 0, val = B) {\\n            while (val > 0 && A - val >= 0) val = B << ++i;\\n            A -= B << i - 1;\\n            ans += 1 << i - 1;\\n        }\\n        return sign < 0 ? -ans : ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***Java Code w/ Logarithms:***\\n\\nThe best result for the code below is **1ms / 35.9MB** (beats 100% / 84%).\\n```java\\nclass Solution {\\n    public int divide(int A, int B) {\\n        int ans = 0;\\n        if (B == -2147483648) return A == B ? 1 : 0;\\n        if (A == -2147483648) {\\n            if (B == 1) return -2147483648;\\n            if (B == -1) return 2147483647;\\n            A += Math.abs(B);\\n            ans++;\\n        }\\n        ans += Math.floor(Math.exp(Math.log(Math.abs(A)) - Math.log(Math.abs(B))));\\n        return A > 0 == B > 0 ? ans : -ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code w/ Bit Manipulation:***\\n\\nThe best result for the code below is **0ms / 5.8MB** (beats 100% / 97%).\\n```c++\\nclass Solution {\\npublic:\\n    int divide(int A, int B) {\\n        int ans = 0, sign = A > 0 == B > 0 ? 1 : -1;\\n        if (B == -2147483648) return A == B;\\n        if (A == -2147483648)\\n            if (B == 1) return -2147483648;\\n            else if (B == -1) return 2147483647;\\n            else A += abs(B), ans++;\\n        A = abs(A), B = abs(B);\\n        for (int i = 0; A >= B; i = 0) {\\n            while (A >> i >= B) i++;\\n            A -= B << i - 1, ans += 1 << i - 1;\\n        }\\n        return sign < 0 ? -ans : ans;\\n    }\\n};\\n```\\n\\n---\\n\\n#### ***C++ Code w/ Logarithms:***\\n\\nThe best result for the code below is **0ms / 6.1MB** (beats 100% / 48%).\\n```c++\\nclass Solution {\\npublic:\\n    int divide(int A, int B) {\\n        int ans = 0;\\n        if (B == -2147483648) return A == B;\\n        if (A == -2147483648)\\n            if (B == 1) return -2147483648;\\n            else if (B == -1) return 2147483647;\\n            else A += abs(B), ans++;\\n        ans += floor(exp(log(abs(A)) - log(abs(B))));\\n        return A > 0 == B > 0 ? ans : -ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```c++\\n  if:  exp(log(c) = c                   // Logarithmic rule #1\\n  if:  log(a / b) = log(a) - log(b)     // Logarithmic rule #2\\n\\nthen:  a / b = exp(log(a / b))          // From rule #1\\n       a / b = exp(log(a) - log(b))     // From rule #2\\n\\n       (if m and n are > 0)\\n```\n```javascript\\nvar divide = function(A, B) {\\n    if (A === -2147483648 && B === -1) return 2147483647\\n    let ans = 0, sign = 1\\n    if (A < 0) A = -A, sign = -sign\\n    if (B < 0) B = -B, sign = -sign\\n    if (A === B) return sign\\n    for (let i = 0, val = B; A >= B; i = 0, val = B) {\\n        while (val > 0 && val <= A) val = B << ++i\\n        A -= B << i - 1, ans += 1 << i - 1\\n    }\\n    return sign < 0 ? -ans : ans\\n};\\n```\n```javascript\\nvar divide = function(A, B) {\\n    let ans = 0\\n    if (B === -2147483648) return A === B\\n    if (A === -2147483648)\\n        if (B === 1) return -2147483648\\n        else if (B === -1) return 2147483647\\n        else A += Math.abs(B), ans++\\n    ans += Math.floor(Math.exp(Math.log(Math.abs(A)) - Math.log(Math.abs(B))))\\n    return A > 0 === B > 0 ? ans : -ans\\n};\\n```\n```python\\nclass Solution:\\n    def divide(self, A: int, B: int) -> int:\\n        if A == -2147483648 and B == -1: return 2147483647\\n        ans, sign = 0, 1\\n        if A < 0: A, sign = -A, -sign\\n        if B < 0: B, sign = -B, -sign\\n        if A == B: return sign\\n        while A >= B:\\n            b = 0\\n            while B << b <= A: b += 1\\n            A -= B << b - 1\\n            ans += 1 << b - 1\\n        return -ans if sign < 0 else ans\\n```\n```python\\nclass Solution:\\n    def divide(self, A: int, B: int) -> int:\\n        if A == 0: return 0\\n        if A == -2147483648 and B == -1: return 2147483647\\n        ans = math.floor(math.exp(math.log(abs(A)) - math.log(abs(B))))\\n        return ans if (A > 0) == (B > 0) else -ans\\n```\n```java\\nclass Solution {\\n    public int divide(int A, int B) {\\n        if (A == -2147483648 && B == -1) return 2147483647;\\n        int ans = 0, sign = A > 0 == B > 0 ? 1 : -1;\\n        if (A < 0) A = -A;\\n        if (B < 0) B = -B;\\n        if (A == B) return sign;\\n        for (int i = 0, val = B; A - B >= 0; i = 0, val = B) {\\n            while (val > 0 && A - val >= 0) val = B << ++i;\\n            A -= B << i - 1;\\n            ans += 1 << i - 1;\\n        }\\n        return sign < 0 ? -ans : ans;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int divide(int A, int B) {\\n        int ans = 0;\\n        if (B == -2147483648) return A == B ? 1 : 0;\\n        if (A == -2147483648) {\\n            if (B == 1) return -2147483648;\\n            if (B == -1) return 2147483647;\\n            A += Math.abs(B);\\n            ans++;\\n        }\\n        ans += Math.floor(Math.exp(Math.log(Math.abs(A)) - Math.log(Math.abs(B))));\\n        return A > 0 == B > 0 ? ans : -ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int divide(int A, int B) {\\n        int ans = 0, sign = A > 0 == B > 0 ? 1 : -1;\\n        if (B == -2147483648) return A == B;\\n        if (A == -2147483648)\\n            if (B == 1) return -2147483648;\\n            else if (B == -1) return 2147483647;\\n            else A += abs(B), ans++;\\n        A = abs(A), B = abs(B);\\n        for (int i = 0; A >= B; i = 0) {\\n            while (A >> i >= B) i++;\\n            A -= B << i - 1, ans += 1 << i - 1;\\n        }\\n        return sign < 0 ? -ans : ans;\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    int divide(int A, int B) {\\n        int ans = 0;\\n        if (B == -2147483648) return A == B;\\n        if (A == -2147483648)\\n            if (B == 1) return -2147483648;\\n            else if (B == -1) return 2147483647;\\n            else A += abs(B), ans++;\\n        ans += floor(exp(log(abs(A)) - log(abs(B))));\\n        return A > 0 == B > 0 ? ans : -ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1084803,
                "title": "python-bitwise",
                "content": "We don\\'t need multiplication, division, or modulo operator, as long as we have addition, subtraction, and bitwise shift.\\n\\nSuppose that `x,y >0` (we handle negatives at the end) and `x = y*m + remainder` where we are interested in `m`. This multiple is a positive integer and can be expressed in binary form. Consider a simple case and say `m=16`. In terms of bit strings, `m = \\'0b10000\\'`. How do you multiply `y` by `m` here? Simply shift `y` by the number of shifts `1` has in `m`. So in python-speak this is `y<<4`. For the general case just do it iteratively.\\n\\n```python\\nclass Solution:\\n    def divide(self, x, y):\\n        ans = 0\\n        xx, yy = abs(x), abs(y)\\n        for i in range(32, -1, -1):\\n            if xx >= (yy<<i):\\n                xx -= (yy<<i)\\n                ans += (1<<i)\\n        \\n        if (x>0 and y<0) or (x<0 and y>0): \\n            ans = -ans\\n        \\n        return min(2**31-1, max(-2**31, ans))\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def divide(self, x, y):\\n        ans = 0\\n        xx, yy = abs(x), abs(y)\\n        for i in range(32, -1, -1):\\n            if xx >= (yy<<i):\\n                xx -= (yy<<i)\\n                ans += (1<<i)\\n        \\n        if (x>0 and y<0) or (x<0 and y>0): \\n            ans = -ans\\n        \\n        return min(2**31-1, max(-2**31, ans))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13524,
                "title": "summary-of-3-c-solutions",
                "content": "-1-  log-based solution\\n \\n\\n       class Solution {\\n        public:\\n            int divide(int dividend, int divisor) {\\n                /** a/b = e^(ln(a))/e^(ln(b)) = e^(ln(a)-ln(b)) **/\\n                if(dividend==0)  return 0;\\n                if(divisor==0)  return INT_MAX;\\n                \\n                double t1=log(fabs(dividend));\\n                double t2=log(fabs(divisor));\\n                long long result=double(exp(t1-t2));\\n                if((dividend<0) ^ (divisor<0))  result=-result;\\n                if(result>INT_MAX)  result=INT_MAX;\\n                return result;\\n            }\\n        };\\n\\n\\n-2-   Binary Index tree idea inspired solution, \\n\\nas we can decompose any result number to sum of the power \\n\\nof 2.\\n\\nHere is the C++ implementation.\\n\\n    class Solution {\\n    public:\\n        int divide(int dividend, int divisor) {\\n            if(!divisor || (dividend==INT_MIN && divisor==-1))   return INT_MAX;\\n            \\n            int sign=((dividend<0)^(divisor<0)) ? -1:1;\\n            long long m=labs(dividend);\\n            long long n=labs(divisor);\\n            int result=0;\\n            \\n            /** dvd >= 2^k1*dvs + 2^k2*dvs ... **/\\n            while(m>=n){\\n                long long temp=n, count=1;\\n                while(m >= (temp<<1)){\\n                    temp<<=1;\\n                    count<<=1;\\n                }\\n                m-=temp;\\n                result+=count;\\n            }\\n            \\n            return sign==1?result:-result;\\n        }\\n    };\\n\\n-3-  concise version of the solution 2\\n\\n    class Solution {\\n    public:\\n        int divide(int dividend, int divisor) {\\n            long long result=0;\\n            long long m=abs((long long)dividend);\\n            long long n=abs((long long)divisor);\\n            while(m>=n){\\n                long long s=n, power=1;\\n                while((s<<1) <= m) { s<<=1; power<<=1; }\\n                result+=power;\\n                m-=s;\\n            }\\n            \\n            if( (dividend>0) ^ (divisor>0))  result = -result;\\n            return result>INT_MAX ? INT_MAX:result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            int divide(int dividend, int divisor) {\\n                /** a/b = e^(ln(a))/e^(ln(b)) = e^(ln(a)-ln(b)) **/\\n                if(dividend==0)  return 0;\\n                if(divisor==0)  return INT_MAX;\\n                \\n                double t1=log(fabs(dividend));\\n                double t2=log(fabs(divisor));\\n                long long result=double(exp(t1-t2));\\n                if((dividend<0) ^ (divisor<0))  result=-result;\\n                if(result>INT_MAX)  result=INT_MAX;\\n                return result;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 251447,
                "title": "c-easy-to-understand-code-beat-100",
                "content": "```\\nclass Solution {\\npublic:\\n    long long divide(long long dividend, long long divisor) {\\n        if (dividend < divisor)\\n            return 0;\\n        \\n        long long sum = divisor;\\n        long long multiple = 1; // 1 2 4 8 16 32 64...\\n        while ((sum + sum) <= dividend) {\\n            sum += sum;\\n            multiple += multiple;\\n        }\\n        \\n        return multiple + divide(dividend - sum, divisor);\\n    }\\n    \\n    int divide(int dividend, int divisor) {\\n        bool positive = (dividend >= 0 == divisor > 0);\\n        \\n        long long ldividend = abs((long long) dividend);\\n        long long ldivisor = abs((long long) divisor);\\n        long long lres = divide(ldividend, ldivisor);\\n        if (lres > INT_MAX) {\\n            lres = positive ? INT_MAX : INT_MIN; \\n        } else {\\n            lres = positive ? lres : -lres;\\n        }\\n        \\n        return lres;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long divide(long long dividend, long long divisor) {\\n        if (dividend < divisor)\\n            return 0;\\n        \\n        long long sum = divisor;\\n        long long multiple = 1; // 1 2 4 8 16 32 64...\\n        while ((sum + sum) <= dividend) {\\n            sum += sum;\\n            multiple += multiple;\\n        }\\n        \\n        return multiple + divide(dividend - sum, divisor);\\n    }\\n    \\n    int divide(int dividend, int divisor) {\\n        bool positive = (dividend >= 0 == divisor > 0);\\n        \\n        long long ldividend = abs((long long) dividend);\\n        long long ldivisor = abs((long long) divisor);\\n        long long lres = divide(ldividend, ldivisor);\\n        if (lres > INT_MAX) {\\n            lres = positive ? INT_MAX : INT_MIN; \\n        } else {\\n            lres = positive ? lres : -lres;\\n        }\\n        \\n        return lres;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 179759,
                "title": "python-7-lines-beats-99-how-you-learned-to-divide-when-you-were-7-years-old",
                "content": "The core algorithm is simple. There are 2 phases:\\n1. Determine how far left to shift the divisor.\\n2. Divide like a 7-year-old (or 5, or 6, or 8, or 9, depending on where you\\'re from).\\n\\nTime: O(log(answer)) = O(log(dividend // divisor)) = O(log(dividend) - log(divisor))\\nSpace: O(1)\\n\\nAlgorithm for integer division of `p/q`, where `p` and `q` are positive:\\n```python\\ni, result = 0, 0 # Initialize stuff.\\n\\nwhile q << i <= p: i += 1 # Phase 1: Figure out how far left you should go.\\n\\nfor j in reversed(range(i)): # Phase 2: Divide like a 7-year-old.\\n    if q << j <= p:\\n        p -= q << j\\n        result += 1 << j\\n```\\n---\\n\\n### Explanation\\n\\nYou probably learned to do something like this in school:\\n```abc\\n   ?          0?         05?        056?       0565\\n  +----      +----      +----      +----      +----\\n12|6789    12|6789    12|6789    12|6789    12|6789\\n                         60         60         60  \\n                         ----       ----       ----\\n                          78         78         78 \\n                                     72         72 \\n                                    ----       ----\\n                                      69         69\\n                                                 60\\n                                               ----\\n                                                  9\\n```\\nHere\\'s a clearer view of what\\'s happening behind the scenes:\\n```abc\\n   ?          0?         05?        056?       0565\\n  +----      +----      +----      +----      +----\\n12|6789    12|6789    12|6789    12|6789    12|6789\\n              0000       0000       0000       0000\\n              ----       ----       ----       ----\\n              6789       6789       6789       6789\\n                         6000       6000       6000\\n                         ----       ----       ----\\n                          789        789        789\\n                                     720        720\\n                                    ----       ----\\n                                      69         69\\n                                                 60\\n                                               ----\\n                                                  9\\n```\\nBinary division is actually a lot easier, because at each step, `?` can only be 0 or 1. Example:\\n```\\n   00101\\n  +-----\\n11|10001\\n       0 == 0 * 110000 because 110000 >  10001\\n   -----\\n   10001\\n       0 == 0 * 11000  because  11000 >  10001\\n   -----\\n   10001\\n    1100 == 1 * 1100   because   1100 <= 10001\\n   -----\\n     101\\n       0 == 0 * 110    because    110 >  101\\n   -----\\n     101\\n      11 == 1 * 11     because     11 <= 101\\n   -----    ^\\n      10    |\\n            this column is the answer (00101)\\n```\\nThe algorithm should be pretty obvious now: First you try to subtract `110000`; it\\'s too big, so you try to subtract `11000`; it\\'s still too big, so you try to subtract `1100`; it works, so you subtract it and add `100` to the result; then you try to subtract `110`; it\\'s too big, so you try to subtract `11`; it works, so you subtract it and add `1` to the result. That\\'s it.\\n\\nOf course, in the example above, we know that the first two `0`s are unnecessary. That is what Phase 1 is for: Shift `q` as far left as possible without exceeding `p`.\\n\\nFull solution:\\n```python\\ndef divide(self, dividend, divisor):\\n\\n    # this is necessary; otherwise phase 1 never terminates\\n    if dividend == 0: return 0\\n\\n    # initialize\\n    i, result, p, q = map(abs, (0, 0, dividend, divisor))\\n    \\n    # phase 1\\n    while q << i <= p: i += 1\\n\\n    # phase 2\\n    for j in reversed(range(i)):\\n        if q << j <= p: p, result = p - (q << j), result + (1 << j)\\n\\n    # stupid leetcode restrictions\\n    if (dividend > 0) != (divisor > 0) or result < -1 << 31: result = -result\\n    return min(result, (1 << 31) - 1)\\n```",
                "solutionTags": [],
                "code": "```python\\ni, result = 0, 0 # Initialize stuff.\\n\\nwhile q << i <= p: i += 1 # Phase 1: Figure out how far left you should go.\\n\\nfor j in reversed(range(i)): # Phase 2: Divide like a 7-year-old.\\n    if q << j <= p:\\n        p -= q << j\\n        result += 1 << j\\n```\n```abc\\n   ?          0?         05?        056?       0565\\n  +----      +----      +----      +----      +----\\n12|6789    12|6789    12|6789    12|6789    12|6789\\n                         60         60         60  \\n                         ----       ----       ----\\n                          78         78         78 \\n                                     72         72 \\n                                    ----       ----\\n                                      69         69\\n                                                 60\\n                                               ----\\n                                                  9\\n```\n```abc\\n   ?          0?         05?        056?       0565\\n  +----      +----      +----      +----      +----\\n12|6789    12|6789    12|6789    12|6789    12|6789\\n              0000       0000       0000       0000\\n              ----       ----       ----       ----\\n              6789       6789       6789       6789\\n                         6000       6000       6000\\n                         ----       ----       ----\\n                          789        789        789\\n                                     720        720\\n                                    ----       ----\\n                                      69         69\\n                                                 60\\n                                               ----\\n                                                  9\\n```\n```\\n   00101\\n  +-----\\n11|10001\\n       0 == 0 * 110000 because 110000 >  10001\\n   -----\\n   10001\\n       0 == 0 * 11000  because  11000 >  10001\\n   -----\\n   10001\\n    1100 == 1 * 1100   because   1100 <= 10001\\n   -----\\n     101\\n       0 == 0 * 110    because    110 >  101\\n   -----\\n     101\\n      11 == 1 * 11     because     11 <= 101\\n   -----    ^\\n      10    |\\n            this column is the answer (00101)\\n```\n```python\\ndef divide(self, dividend, divisor):\\n\\n    # this is necessary; otherwise phase 1 never terminates\\n    if dividend == 0: return 0\\n\\n    # initialize\\n    i, result, p, q = map(abs, (0, 0, dividend, divisor))\\n    \\n    # phase 1\\n    while q << i <= p: i += 1\\n\\n    # phase 2\\n    for j in reversed(range(i)):\\n        if q << j <= p: p, result = p - (q << j), result + (1 << j)\\n\\n    # stupid leetcode restrictions\\n    if (dividend > 0) != (divisor > 0) or result < -1 << 31: result = -result\\n    return min(result, (1 << 31) - 1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 13591,
                "title": "a-readable-java-implementation",
                "content": "At first, I used dividend / divisor, just to check. But that was cheating.\\n\\nThen, I implemented a solution which failed the corner cases. I solved it by using long instead of int. But I felt that was also cheating.\\n\\nAt last, I came up with this solution. It handles all the corner cases. Running time analysis after the code.\\n\\n    public class Solution {\\n        public int divide(int dividend, int divisor) {\\n            if (divisor == 1) // Trival case 1\\n                return dividend;\\n            \\n            // Use negative integers to avoid integer overflow\\n            if (dividend > 0)\\n                return -divide(-dividend, divisor);\\n            if (divisor > 0)\\n                return -divide(dividend, -divisor);\\n            \\n            if (dividend > divisor) // Trivial case 2\\n                return 0;\\n            \\n            if ((dividend == Integer.MIN_VALUE) && (divisor == -1)) // Overflow case\\n                return Integer.MAX_VALUE;\\n            \\n            // Find the highest mult = (divisor * 2^shifts) which is <= dividend\\n            // by shifting mult to the left without causing an overflow.\\n            // At most (log2(|dividend|) - log2(|divisor|) + 1) iterations.\\n            int min_divisor = Integer.MIN_VALUE >> 1;\\n            int mult = divisor; // = divisor * 2^shifts\\n            int shifts = 0;\\n            while ((mult >= min_divisor) && (mult > dividend)) {\\n                mult <<= 1;\\n                ++shifts;\\n            }\\n            \\n            // Compute the result by shifting mult to the right.\\n            // At most (log2(|dividend|) - log2(|divisor|) + 1) iterations for the outer loop.\\n            // At most (log2(|dividend|) - log2(|divisor|) + 1) iterations for the inner loop\\n            // (in total, not per outer iteration).\\n            int result = 0;\\n            int power = 1 << shifts; // = 2^shifts\\n            while (dividend <= divisor) {\\n                shifts = 0;\\n                while (mult < dividend) {\\n                    mult >>= 1;\\n                    ++shifts;\\n                }\\n                dividend -= mult;\\n                power >>= shifts;\\n                result |= power; // Adds power to result\\n            }\\n            \\n            return result;\\n        }\\n    }\\n\\nI see lots of people talking about O(log(n)) solutions. Since n is bounded by -2^31 and 2^31-1, I'm not sure the Big-Oh notation is appropriate here. Anyway, here's a rough worst-case analysis of this code.\\n\\nThe first loop runs (log2(|dividend|) - log2(|divisor|) + 1) times. There are\\n\\n - 2 comparisons\\n - 1 bit shift\\n - 1 increment\\n\\nThe second loop runs between 1 time and (log2(|dividend|) - log2(|divisor|) + 1) times. For worst-case, we take the latter. There are\\n\\n - 1 comparison\\n - 1 assignment\\n - 1 substraction\\n - 1 bit shift\\n - 1 bitwise or\\n\\nThe inner while loop runs (log2(|dividend|) - log2(|divisor|) + 1) times also (in total, not per outer loop iteration). There are\\n\\n - 1 comparison\\n - 1 bit shift\\n - 1 increment\\n\\nSo, roughly, the overall worst-case running time is 12(log2(dividend) - log2(divisor) + 1) operations. You can notice that (log2(|dividend|) - log2(|divisor|)) = log2(|result|). Thus, the running time is (worst-case) 12(log2(|result|) + 1) operations.",
                "solutionTags": [],
                "code": "class Solution {\\n        public int divide(int dividend, int divisor) {\\n            if (divisor == 1) // Trival case 1\\n                return dividend;\\n            \\n            // Use negative integers to avoid integer overflow\\n            if (dividend > 0)\\n                return -divide(-dividend, divisor);\\n            if (divisor > 0)\\n                return -divide(dividend, -divisor);\\n            \\n            if (dividend > divisor) // Trivial case 2\\n                return 0;\\n            \\n            if ((dividend == Integer.MIN_VALUE) && (divisor == -1)) // Overflow case\\n                return Integer.MAX_VALUE;\\n            \\n            // Find the highest mult = (divisor * 2^shifts) which is <= dividend\\n            // by shifting mult to the left without causing an overflow.\\n            // At most (log2(|dividend|) - log2(|divisor|) + 1) iterations.\\n            int min_divisor = Integer.MIN_VALUE >> 1;\\n            int mult = divisor; // = divisor * 2^shifts\\n            int shifts = 0;\\n            while ((mult >= min_divisor) && (mult > dividend)) {\\n                mult <<= 1;\\n                ++shifts;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2139178,
                "title": "simple-eficient-100-faster",
                "content": "**<++++++++ Press upvote Button Please !!!!!!!**\\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n    \\n        if(dividend==INT_MIN && divisor==-1) return INT_MAX;\\n        if(dividend==INT_MIN && divisor==1) return INT_MIN;\\n\\n        \\n\\n        long int dd = abs(dividend), dv = abs(divisor);\\n        \\n     \\n        int res=0;\\n        while(dv<=dd) {\\n            long int sum=dv, count=1;\\n            while(sum<=dd-sum) {\\n                sum+=sum;\\n                count+=count;\\n            }\\n            res+=count;\\n            dd-=sum;\\n        }\\n        \\nif((dividend<0&&divisor>0) || (dividend>0&&divisor<0)) return -res;\\n        \\n        return res;\\n          \\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/da759167-b79f-448a-b13b-07fbbd8b216d_1654964334.5319335.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n    \\n        if(dividend==INT_MIN && divisor==-1) return INT_MAX;\\n        if(dividend==INT_MIN && divisor==1) return INT_MIN;\\n\\n        \\n\\n        long int dd = abs(dividend), dv = abs(divisor);\\n        \\n     \\n        int res=0;\\n        while(dv<=dd) {\\n            long int sum=dv, count=1;\\n            while(sum<=dd-sum) {\\n                sum+=sum;\\n                count+=count;\\n            }\\n            res+=count;\\n            dd-=sum;\\n        }\\n        \\nif((dividend<0&&divisor>0) || (dividend>0&&divisor<0)) return -res;\\n        \\n        return res;\\n          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 179466,
                "title": "20ms-binary-search-java-with-explanations",
                "content": "We eastablish variables `sum` and `quotient` with the invariant `quotient * divisor = sum`.\\nTake dividend = 20, divisor = 3 for example,\\n```\\nsum  quotient  target\\n3     1        17\\n6     2        14\\n9     3        11\\n12    4        8\\n15    5        5\\n18    6        2\\n ^\\n 18 + 3 > 20, so the answer is 6\\n```\\nCode\\n```\\n    public int divide(int dividend, int divisor) {\\n        // Corner cases\\n        if (dividend == 0) return 0;\\n        if (divisor == 1) return dividend;\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE;\\n        \\n        long ldividend = (long)dividend; // To avoid integer overflow in calculations after\\n        if (ldividend < 0) ldividend = -ldividend;\\n        long ldivisor = (long)divisor; // To avoid integer overflow in calculations after\\n        if (ldivisor < 0) ldivisor = -ldivisor;\\n        \\n        // sum = ldivisor * lquotient\\n        long lquotient = 1, sum = ldivisor; \\n        while (sum < ldividend) {\\n            lquotient++;  \\n            sum += ldivisor;  \\n        }\\n        \\n        if (sum > ldividend) lquotient--;\\n        boolean isPositive = (dividend > 0 && divisor > 0) || (dividend < 0 && divisor < 0);\\n        \\n        return isPositive ? (int)lquotient: -(int)lquotient;\\n    }\\n```\\n****\\nTo increase `quotient` one by one costs much time. We could apply **Binary Search** here, i.e. `quotient = quotient * 2` each time. \\n```\\nsum  quotient  target\\n3     1        17\\n6     2        14\\n12    4        8\\n ^\\n 12 + 12 > 20, so the answer is 4 --- X wrong for we missed quotient of 8 / 3\\nInstead, \\nsum  quotient  target\\n3     1        8\\n6     2        5\\n^\\n6 + 6 > 8, so the answer for 8 / 3 is 2\\n\\nThe final answer is 4 + 2 = 6\\n```\\nWe remove negative sign of dividend and divisor in the beginning and add `signNegative` to make up the difference.\\nIn case of Integer Overflows, we use long to while addition. And we need to make sure the final result is within the range `[\\u22122^31,  2^31 \\u2212 1]`.\\n\\n**Code**\\n```\\n    public int divide(int dividend, int divisor) {\\n\\n        long ldividend = (long) dividend, ldivisor = (long) divisor;\\n\\n        boolean signNegative = false;\\n        if (ldividend < 0) {\\n            signNegative = !signNegative;\\n            ldividend = -ldividend;\\n        }\\n        if (ldivisor < 0) {\\n            signNegative = !signNegative;\\n            ldivisor = -ldivisor;\\n        }\\n\\n        long result = divideRecur(ldividend, ldivisor);\\n\\n        if (result > Integer.MAX_VALUE && !signNegative) {\\n            result = Integer.MAX_VALUE;\\n        } else if (result < Integer.MIN_VALUE) {\\n            result = Integer.MIN_VALUE;\\n        }\\n\\n        return signNegative ? (int) -result : (int) result;\\n    }\\n\\n    private long divideRecur(long dividend, long divisor) {\\n\\n        if (dividend < divisor)\\n            return 0;\\n\\n        long sum = divisor, quotient = 1;\\n        while (sum + sum < dividend) {\\n            sum += sum;\\n            quotient += quotient;\\n        }\\n\\n        return quotient + divideRecur(dividend - sum, divisor);\\n    }\\n```\\n**I appreciate your VOTE UP \\u2727\\u207A\\u2E1C(\\u25CF\\u02D9\\u25BE\\u02D9\\u25CF)\\u2E1D\\u207A\\u2727**",
                "solutionTags": [],
                "code": "```\\nsum  quotient  target\\n3     1        17\\n6     2        14\\n9     3        11\\n12    4        8\\n15    5        5\\n18    6        2\\n ^\\n 18 + 3 > 20, so the answer is 6\\n```\n```\\n    public int divide(int dividend, int divisor) {\\n        // Corner cases\\n        if (dividend == 0) return 0;\\n        if (divisor == 1) return dividend;\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE;\\n        \\n        long ldividend = (long)dividend; // To avoid integer overflow in calculations after\\n        if (ldividend < 0) ldividend = -ldividend;\\n        long ldivisor = (long)divisor; // To avoid integer overflow in calculations after\\n        if (ldivisor < 0) ldivisor = -ldivisor;\\n        \\n        // sum = ldivisor * lquotient\\n        long lquotient = 1, sum = ldivisor; \\n        while (sum < ldividend) {\\n            lquotient++;  \\n            sum += ldivisor;  \\n        }\\n        \\n        if (sum > ldividend) lquotient--;\\n        boolean isPositive = (dividend > 0 && divisor > 0) || (dividend < 0 && divisor < 0);\\n        \\n        return isPositive ? (int)lquotient: -(int)lquotient;\\n    }\\n```\n```\\nsum  quotient  target\\n3     1        17\\n6     2        14\\n12    4        8\\n ^\\n 12 + 12 > 20, so the answer is 4 --- X wrong for we missed quotient of 8 / 3\\nInstead, \\nsum  quotient  target\\n3     1        8\\n6     2        5\\n^\\n6 + 6 > 8, so the answer for 8 / 3 is 2\\n\\nThe final answer is 4 + 2 = 6\\n```\n```\\n    public int divide(int dividend, int divisor) {\\n\\n        long ldividend = (long) dividend, ldivisor = (long) divisor;\\n\\n        boolean signNegative = false;\\n        if (ldividend < 0) {\\n            signNegative = !signNegative;\\n            ldividend = -ldividend;\\n        }\\n        if (ldivisor < 0) {\\n            signNegative = !signNegative;\\n            ldivisor = -ldivisor;\\n        }\\n\\n        long result = divideRecur(ldividend, ldivisor);\\n\\n        if (result > Integer.MAX_VALUE && !signNegative) {\\n            result = Integer.MAX_VALUE;\\n        } else if (result < Integer.MIN_VALUE) {\\n            result = Integer.MIN_VALUE;\\n        }\\n\\n        return signNegative ? (int) -result : (int) result;\\n    }\\n\\n    private long divideRecur(long dividend, long divisor) {\\n\\n        if (dividend < divisor)\\n            return 0;\\n\\n        long sum = divisor, quotient = 1;\\n        while (sum + sum < dividend) {\\n            sum += sum;\\n            quotient += quotient;\\n        }\\n\\n        return quotient + divideRecur(dividend - sum, divisor);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 246094,
                "title": "java-solutions",
                "content": "**Solution 1: Brute-Force Algorithm**\\n\\n- A **brute-force** approach is to iteratively subtract `y` from `x` until what remains is less than `y`. The number of such subtractions is exactly the quotient, `x / y`, and the remainder is the term that\\'s less than `y` the complexity of brute-force approach is very high.\\nFor Example- when x = 2<sup>31</sup> - 1 and `y = 1`, then it will take 2<sup>31</sup> - 1 iterations.\\n\\nTime complexity: `O(x) ` - where `x` is the `dividend`.\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution\\n{\\n    public int divide(int dividend, int divisor)\\n\\t{\\n        if(dividend == Integer.MIN_VALUE && divisor == -1)\\n            return Integer.MAX_VALUE;\\n        \\n\\t\\tint sign = (dividend < 0) ^ (divisor < 0) ? -1 : 1;\\n        int result = 0;\\n\\t\\tlong x = Math.abs((long)dividend);\\n        long y = Math.abs((long)divisor);\\n        \\n\\t\\twhile(x >= y)\\n\\t\\t{\\n            x -= y;\\n            result++;\\n        }\\n        return result * sign;\\n    }\\n}\\n```\\n\\n**Solution 2:**\\n\\n- A **better approach** is to try and get more work done in each iteration. The idea is to compute the largest `k` such that 2<sup>k</sup>y <= x, then subtract 2<sup>k</sup>y from `x` and 2<sup>k</sup> to the `quotient`.\\nFor Example- if x = (1011)<sub>2</sub> and y = (10)<sub>2</sub>, then `k = 2`, since 2 * 2<sup>2</sup> <= 11 and 2 * 2<sup>3</sup> > 11. We subtract (1000)<sub>2</sub> from (1011)<sub>2</sub> to get (11)<sub>2</sub>, add 2<sup>k</sup> = 2<sup>2</sup> = (100)<sub>2</sub> to the `quotient`, and continue by updating `x` to (11)<sub>2</sub>.\\n- The advantage of using 2<sup>k</sup>y is that it can be computed very efficiently using shifting, and `x` is halved in each iteration. If it takes `n` bits to represent `x / y`, there are `O(n)` iterations. If the largest `k` such that 2<sup>k</sup>y <= x is computed by iterating through `k`, and since each iteration has time complexity `O(n)`, this leads to O(n<sup>2</sup>) algorithm.\\n\\nTime complexity: O(n<sup>2</sup>) - where `n` is the number of bits required to represent `x / y`\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution\\n{\\n    public int divide(int dividend, int divisor)\\n\\t{\\n        if(dividend == Integer.MIN_VALUE && divisor == -1)\\n            return Integer.MAX_VALUE;\\n        \\n\\t\\tint sign = (dividend < 0) ^ (divisor < 0) ? -1 : 1;\\n        int result = 0;\\n\\t\\tlong x = Math.abs((long)dividend);\\n        long y = Math.abs((long)divisor);\\n        \\n\\t\\twhile(x >= y)\\n\\t\\t{\\n            int shift = 1;\\n\\n            while(x >= (y << shift))\\n\\t\\t\\t{\\n                shift++;\\n            }\\n            x -= y << (shift - 1);\\n            result += 1 << (shift - 1);\\n        }\\n        return result * sign;\\n    }\\n}\\n```\\n\\n**Solution 3:**\\n\\n- The **best way** to find the largest `k` in each iteration is to recongnize that it keeps decreasing. Therefore, instead of testing in each iteration whether 2<sup>0</sup>y, 2<sup>1</sup>y, 2<sup>2</sup>y . . . is less than or equal to `x`, after we initially find the largest `k` such that 2<sup>k</sup>y <= x, in susequent iterations we test 2<sup>k-1</sup>y, 2<sup>k-2</sup>y, 2<sup>k-3</sup>y, . . . with `x`.\\n- For the example given earliar, after setting the `quotient`, to (100)<sub>2</sub> we continue with (11)<sub>2</sub>. Now the largest `k` such that 2<sup>k</sup>y <= (11)<sub>2</sub> is `0`, so we add 2<sup>0</sup> = (1)<sub>2</sub> to the `quotient`, which is now (101)<sub>2</sub>. We continue with (11)<sub>2</sub> - (10)<sub>2</sub> = (1)<sub>2</sub>. Since (1)<sub>2</sub> < y, we are done. So the `quotient` is (101)<sub>2</sub> and the `remainder` is (1)<sub>2</sub>.\\n\\nTime complexity: `O(n)` - where `n` is the number of bits required to represent `x / y`\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution\\n{\\n    public int divide(int dividend, int divisor)\\n\\t{\\n        if(dividend == Integer.MIN_VALUE && divisor == -1)\\n            return Integer.MAX_VALUE;\\n        \\n\\t\\tint sign = (dividend < 0) ^ (divisor < 0) ? -1 : 1;\\n        int result = 0;\\n        int power = 32;\\n        long x = Math.abs((long)dividend);\\n        long y = Math.abs((long)divisor);\\n        \\n       while(x >= y)\\n\\t\\t{\\n            while((y << power) > x)\\n\\t\\t\\t{\\n                power--;\\n            }\\n            x -= y << power;\\n            result += 1 << power;\\n        }\\n        return result * sign;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public int divide(int dividend, int divisor)\\n\\t{\\n        if(dividend == Integer.MIN_VALUE && divisor == -1)\\n            return Integer.MAX_VALUE;\\n        \\n\\t\\tint sign = (dividend < 0) ^ (divisor < 0) ? -1 : 1;\\n        int result = 0;\\n\\t\\tlong x = Math.abs((long)dividend);\\n        long y = Math.abs((long)divisor);\\n        \\n\\t\\twhile(x >= y)\\n\\t\\t{\\n            x -= y;\\n            result++;\\n        }\\n        return result * sign;\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public int divide(int dividend, int divisor)\\n\\t{\\n        if(dividend == Integer.MIN_VALUE && divisor == -1)\\n            return Integer.MAX_VALUE;\\n        \\n\\t\\tint sign = (dividend < 0) ^ (divisor < 0) ? -1 : 1;\\n        int result = 0;\\n\\t\\tlong x = Math.abs((long)dividend);\\n        long y = Math.abs((long)divisor);\\n        \\n\\t\\twhile(x >= y)\\n\\t\\t{\\n            int shift = 1;\\n\\n            while(x >= (y << shift))\\n\\t\\t\\t{\\n                shift++;\\n            }\\n            x -= y << (shift - 1);\\n            result += 1 << (shift - 1);\\n        }\\n        return result * sign;\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public int divide(int dividend, int divisor)\\n\\t{\\n        if(dividend == Integer.MIN_VALUE && divisor == -1)\\n            return Integer.MAX_VALUE;\\n        \\n\\t\\tint sign = (dividend < 0) ^ (divisor < 0) ? -1 : 1;\\n        int result = 0;\\n        int power = 32;\\n        long x = Math.abs((long)dividend);\\n        long y = Math.abs((long)divisor);\\n        \\n       while(x >= y)\\n\\t\\t{\\n            while((y << power) > x)\\n\\t\\t\\t{\\n                power--;\\n            }\\n            x -= y << power;\\n            result += 1 << power;\\n        }\\n        return result * sign;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13516,
                "title": "javascript-solution-with-o-logn-time-and-o-logn-stack-space",
                "content": "    function divide(dividend, divisor) {\\n        if (dividend === -2147483648 && divisor === -1) {\\n            return 2147483647;\\n        }\\n        var isNeg = dividend > 0 ^ divisor > 0;\\n        var res = 0;\\n        \\n        dividend = Math.abs(dividend);\\n        subtract(Math.abs(divisor), 1);\\n        \\n        function subtract(d, q) {\\n            if (dividend > d) {\\n                subtract(d + d, q + q);\\n            }\\n            if (dividend >= d) {\\n                dividend -= d;\\n                res += q;\\n            }\\n        }\\n        \\n        return isNeg ? -res : res;\\n    }",
                "solutionTags": [],
                "code": "    function divide(dividend, divisor) {\\n        if (dividend === -2147483648 && divisor === -1) {\\n            return 2147483647;\\n        }\\n        var isNeg = dividend > 0 ^ divisor > 0;\\n        var res = 0;\\n        \\n        dividend = Math.abs(dividend);\\n        subtract(Math.abs(divisor), 1);\\n        \\n        function subtract(d, q) {\\n            if (dividend > d) {\\n                subtract(d + d, q + q);\\n            }\\n            if (dividend >= d) {\\n                dividend -= d;\\n                res += q;\\n            }\\n        }\\n        \\n        return isNeg ? -res : res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3222214,
                "title": "efficient-bit-manipulation-algorithm-for-integer-division-without-multiplication-or-mod-operator",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires us to divide two integers, `dividend` and `divisor`, and return the quotient without using multiplication, division, and mod operator.\\n\\nWe can solve this problem using bit manipulation and binary search. We can find the largest multiple of the divisor that is less than or equal to the dividend using bit manipulation. Then we can perform division using binary search.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Handle division by zero: If the divisor is 0, return `2**31 - 1`.\\n\\n- Handle overflow case: If the dividend is `-2**31` and divisor is `-1`, return `2**31 - 1`.\\n\\n- Get the sign of the result: If both dividend and divisor are negative or positive, the sign of the result will be positive. If either dividend or divisor is negative, the sign of the result will be negative.\\n\\n- Find the largest multiple of the divisor that is less than or equal to the dividend using bit manipulation. We can do this by left-shifting the divisor and multiple by 1 until the left-shifted divisor is greater than the dividend.\\n\\n- Perform division using binary search. We can do this by right-shifting the divisor and multiple by 1 until multiple is 0. If the dividend is greater than or equal to the divisor, subtract the divisor from the dividend and add the multiple to the quotient. Repeat until multiple is 0.\\n\\n- Apply the sign to the quotient and return it.\\n\\n# Complexity\\n- Time complexity: The time complexity of this solution is $$O(log(dividend))$$.\\n\\nFinding the largest multiple of the divisor that is less than or equal to the dividend takes `log(dividend)` iterations. Performing division using binary search takes `log(dividend) `iterations as well.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity of this solution is `O(1)`.\\n\\nWe only use a constant amount of extra space to store variables.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code Explanation\\n\\nThe code is an implementation of the binary division algorithm. The algorithm is used to divide two integers (dividend and divisor) and return the quotient (integer division result). Here is how the code works:\\n\\n- The function accepts two integer parameters, dividend and divisor, and returns an integer (quotient).\\n- The function first checks if the divisor is zero. If it is, it returns the maximum 32-bit integer value (2^31 - 1). This is because dividing by zero is not possible, and we need to handle this edge case.\\n- The function then checks for an overflow case where the dividend is the minimum 32-bit integer value (-2^31) and the divisor is -1. In this case, the quotient is the maximum 32-bit integer value (2^31 - 1) since dividing the minimum value by -1 would result in an overflow error.\\n- The function determines the sign of the result by checking the signs of the dividend and divisor. If both are negative or both are positive, the sign is positive. Otherwise, the sign is negative, and we make both values positive for the next step.\\n- The function then finds the largest multiple of the divisor that is less than or equal to the dividend. It does this by left-shifting the divisor and multiple variables (initially set to 1) until the shifted divisor is greater than the dividend. At this point, the last multiple that was less than or equal to the dividend is the largest multiple we need to find. The function keeps track of this multiple value and the divisor value for the next step.\\n- The function then performs the division using binary search. It does this by right-shifting the divisor and multiple variables until multiple is zero. At each step, it checks if the dividend is greater than or equal to the divisor. If it is, it subtracts the divisor from the dividend, adds the multiple to the quotient, and continues the loop. Otherwise, it right-shifts the divisor and multiple variables to check for the next value. At the end of this step, the quotient variable contains the integer division result.\\n- Finally, the function applies the sign to the result and returns it.\\n\\n\\nOverall, the binary division algorithm is an efficient way to perform integer division using bit manipulation. The code handles edge cases such as division by zero and overflow and returns the correct result with the correct sign.\\n\\n\\n\\n\\n\\n\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        # Handle division by zero\\n        if divisor == 0:\\n            return 2**31 - 1\\n        \\n        # Handle overflow case\\n        if dividend == -2**31 and divisor == -1:\\n            return 2**31 - 1\\n        \\n        # Get the sign of the result\\n        sign = 1\\n        if dividend < 0:\\n            dividend = -dividend\\n            sign = -sign\\n        if divisor < 0:\\n            divisor = -divisor\\n            sign = -sign\\n        \\n        # Find the largest multiple of the divisor that is less than or equal to the dividend\\n        multiple = 1\\n        while dividend >= (divisor << 1):\\n            divisor <<= 1\\n            multiple <<= 1\\n        \\n        # Perform division using binary search\\n        quotient = 0\\n        while multiple > 0:\\n            if dividend >= divisor:\\n                dividend -= divisor\\n                quotient += multiple\\n            divisor >>= 1\\n            multiple >>= 1\\n        \\n        # Apply the sign to the result\\n        return sign * quotient\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Binary Search",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        # Handle division by zero\\n        if divisor == 0:\\n            return 2**31 - 1\\n        \\n        # Handle overflow case\\n        if dividend == -2**31 and divisor == -1:\\n            return 2**31 - 1\\n        \\n        # Get the sign of the result\\n        sign = 1\\n        if dividend < 0:\\n            dividend = -dividend\\n            sign = -sign\\n        if divisor < 0:\\n            divisor = -divisor\\n            sign = -sign\\n        \\n        # Find the largest multiple of the divisor that is less than or equal to the dividend\\n        multiple = 1\\n        while dividend >= (divisor << 1):\\n            divisor <<= 1\\n            multiple <<= 1\\n        \\n        # Perform division using binary search\\n        quotient = 0\\n        while multiple > 0:\\n            if dividend >= divisor:\\n                dividend -= divisor\\n                quotient += multiple\\n            divisor >>= 1\\n            multiple >>= 1\\n        \\n        # Apply the sign to the result\\n        return sign * quotient\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1086538,
                "title": "c-bit-manipulation-o-logn-2-0ms-beats-100-explanation",
                "content": "**EXPLANATION**\\n- First, find the **highest number (less than dividend)** that can be **substracted** from the `dividend` which is a **multiple of divisor**, then subtract it from the `dividend` and add that multiplier to the answer (`ans`).\\n- **Repeat** the process as long as `dividend >= divisor`.\\n- The algorithm is implemented on positive `dividend` and positive `divisor`, so we add the **sign** at the *end*.\\n- Also, handle few **special cases** before starting the algorithm (shown in the code below).\\n\\n**Note**: Instead of directly finding the \"highest number (less than dividend) that can be subtracted from the dividend which is a multiple of divisor\", we will be finding the lowest multiple of dividend that is greater than the divisor. This is because of handling the case of **integer overflow**.\\n\\n---\\n\\n**EXAMPLE**\\nConsider the **input** as `dividend = 10` and `divisor = 3`,\\n**(1)** Now, first we find the **lowest number** (formed by dividing the `dividend` by 2) that is **greater** than the `divisor` in a loop. Initially `curr_dvd = dividend = 10` and multiplier(`t`) is `1`. The loop will continue only if `curr_dvd >= divisor`. Here, we are trying to find the multiplier by right shifting the `dividend`  by 2 (dividing by 2) in each iteration, this makes the *worst-case time complexity* of finding it `O(logn)`.\\n- **First Iteration** : 10/2 = 5, Since `5>=3(divisor)`, so `curr_dvd=5`, so our multiplier(`t`) becomes `t = t*2 = 2`.\\n- **Second Iteration** : 5/2 = 2, Since `2<3(divisor)`, so after this we will stop.\\n\\nNow, subtract `divisor * multiplier` from `dividend`, that is 10 - 3`*`**2** = 4.\\nAfter that add the multiplier to answer that is `ans+=2`\\n\\n**(2)** From the output of the previous step, since `4>=3(divisor)` repeat **(1)** on 4,\\n- **First Iteration** : 4/2 = 2, Since `2<3(divisor)`, so we will stop.\\n\\nAgain, do the same thing as **(1)**, 4 - 3`*`**1** = 1, so `ans+=1`. (As by default our *multiplier* is `1`)\\n\\n**(3)** From the output of the previous step, `1<3(divisor)`, so we will not repeat **(1)**.\\n\\nHence, the final answer is **`ans = 2 (from 1) + 1 (from 2) = 3`**.\\n\\n***Note**: The code is more optimized than explained in the above example. But, the working is the same.*\\n\\n---\\n\\n**CODE IMPLEMENTATION**\\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) { // dividend / divisor\\n        \\n        int ans = 0;\\n\\n        // Handle special cases\\n        if (divisor == INT_MIN)\\n            if (dividend == divisor) return 1;\\n            else return 0;\\n        \\n        if (dividend == INT_MIN)\\n            if (divisor == 1) return INT_MIN;\\n            else if (divisor == -1) return INT_MAX;\\n            else dividend += abs(divisor), ans++; // INT_MIN + abs(divisor) / abs(divisor) = 1 + INT_MIN / abs(divisor)\\n\\n        // find the sign of the answer\\n        int sign = dividend > 0 ^ divisor > 0 ? -1 : 1;\\n        \\n        // making both dividend and divisor positive\\n        dividend = abs(dividend), divisor = abs(divisor);\\n        \\n        // main code\\n        while(dividend >= divisor) { \\n            int t=1; // multiplier by default 1 since (dividend >= divisor)\\n            int curr_dvs=divisor;\\n            int curr_dvd=dividend >> 1;\\n            \\n            while (curr_dvd >= divisor){\\n                curr_dvs = curr_dvs << 1;\\n                t = t << 1;\\n                curr_dvd = curr_dvd>>1;\\n            }\\n\\n            dividend -= curr_dvs;\\n            ans += t;\\n        }\\n        return sign > 0 ? ans : -ans;\\n    }\\n};\\n```\\n\\n**TIME COMPLEXITY**\\n**O(logn * logn)**\\n\\n**SPACE COMPLEXITY**\\n**O(1)**",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) { // dividend / divisor\\n        \\n        int ans = 0;\\n\\n        // Handle special cases\\n        if (divisor == INT_MIN)\\n            if (dividend == divisor) return 1;\\n            else return 0;\\n        \\n        if (dividend == INT_MIN)\\n            if (divisor == 1) return INT_MIN;\\n            else if (divisor == -1) return INT_MAX;\\n            else dividend += abs(divisor), ans++; // INT_MIN + abs(divisor) / abs(divisor) = 1 + INT_MIN / abs(divisor)\\n\\n        // find the sign of the answer\\n        int sign = dividend > 0 ^ divisor > 0 ? -1 : 1;\\n        \\n        // making both dividend and divisor positive\\n        dividend = abs(dividend), divisor = abs(divisor);\\n        \\n        // main code\\n        while(dividend >= divisor) { \\n            int t=1; // multiplier by default 1 since (dividend >= divisor)\\n            int curr_dvs=divisor;\\n            int curr_dvd=dividend >> 1;\\n            \\n            while (curr_dvd >= divisor){\\n                curr_dvs = curr_dvs << 1;\\n                t = t << 1;\\n                curr_dvd = curr_dvd>>1;\\n            }\\n\\n            dividend -= curr_dvs;\\n            ans += t;\\n        }\\n        return sign > 0 ? ans : -ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367837,
                "title": "building-up-solution-in-python-with-easy-explaination",
                "content": "How do we do division if we couldn\\'t use multiplication or division? \\nThe easiest way: we just substract or diviser from the dividend until there is nothing to substract.\\n# Easy but slow\\n```\\nif not dividend:\\n\\treturn 0\\nsign = 1 if (dividend > 0 and divisor < 0) or (dividend < 0 and divisor > 0) else 0\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\nres = 0\\nwhile dividend >= divisor:\\n\\tdividend -= divisor\\n\\tres += 1\\nreturn -res if sign else res\\n```\\n\\nOnly problem with that.. It\\'s too slow. \\n# Fast solution\\nWe want to speed up the process by substracting not the divisor, but divisor multiplied by something. \\nBut we couldn\\'t multiply directly due to the task conditions.\\nHow do we do than ? \\nWe use the fact that **bitwise left shift is equal to multiplying by two**:\\n101 << 1 = 1010 \\nSo we shift the divisor left as much as we can before substracting: \\n```\\nif not dividend:\\n\\treturn 0\\nsign = 1 if (dividend > 0 and divisor < 0) or (dividend < 0 and divisor > 0) else 0\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\nres = 0\\nwhile dividend >= divisor:\\n\\tk = 0\\n\\twhile dividend >= divisor << (k + 1):\\n\\t\\tk += 1\\n\\tdividend -= (divisor << k)\\n\\tres += (1 << k)\\nreturn -res if sign else res\\n```\\n# The final solution\\nThe last thing we need to do is to account for the max number: \\n```\\nif not dividend:\\n\\treturn 0\\nsign = 1 if (dividend > 0 and divisor < 0) or (dividend < 0 and divisor > 0) else 0\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\nres = 0\\nwhile dividend >= divisor:\\n\\tk = 0\\n\\twhile dividend >= divisor << (k + 1):\\n\\t\\tk += 1\\n\\tdividend -= (divisor << k)\\n\\tres += (1 << k)\\nMAX_INT =  (1 << 31) - 1\\nreturn -res if sign else (res if res <= MAX_INT else MAX_INT)\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nif not dividend:\\n\\treturn 0\\nsign = 1 if (dividend > 0 and divisor < 0) or (dividend < 0 and divisor > 0) else 0\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\nres = 0\\nwhile dividend >= divisor:\\n\\tdividend -= divisor\\n\\tres += 1\\nreturn -res if sign else res\\n```\n```\\nif not dividend:\\n\\treturn 0\\nsign = 1 if (dividend > 0 and divisor < 0) or (dividend < 0 and divisor > 0) else 0\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\nres = 0\\nwhile dividend >= divisor:\\n\\tk = 0\\n\\twhile dividend >= divisor << (k + 1):\\n\\t\\tk += 1\\n\\tdividend -= (divisor << k)\\n\\tres += (1 << k)\\nreturn -res if sign else res\\n```\n```\\nif not dividend:\\n\\treturn 0\\nsign = 1 if (dividend > 0 and divisor < 0) or (dividend < 0 and divisor > 0) else 0\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\nres = 0\\nwhile dividend >= divisor:\\n\\tk = 0\\n\\twhile dividend >= divisor << (k + 1):\\n\\t\\tk += 1\\n\\tdividend -= (divisor << k)\\n\\tres += (1 << k)\\nMAX_INT =  (1 << 31) - 1\\nreturn -res if sign else (res if res <= MAX_INT else MAX_INT)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 13653,
                "title": "compiler-does-not-actually-check-for-division-operator",
                "content": "    return dividend / divisor;\\n\\nwas accepted.",
                "solutionTags": [],
                "code": "    return dividend / divisor;\\n\\nwas accepted.",
                "codeTag": "Unknown"
            },
            {
                "id": 1601170,
                "title": "java-1ms-single-recursive-function",
                "content": "This solution is based on the following two posts.\\nhttps://leetcode.com/problems/divide-two-integers/discuss/1579861/Java-no-longs-simple-solution-that-someone-could-actually-come-up-with\\nhttps://leetcode.com/problems/divide-two-integers/discuss/13417/No-Use-of-Long-Java-Solution\\nI thought both of these were very nice but they used two different functions so I turned it into a single recursive function mainly for aesthetic purposes. \\nThe second link has bit manipulation if you\\'re freaky like that.\\nI much prefered the easier to understand and arguably prettier solution in the first link.\\n```\\npublic class Solution {\\n    public int divide(int dividend, int divisor) {\\n\\t\\t//all of these if else statements are only for edge cases and to make both dividend and divisor negative\\n        if (dividend == Integer.MIN_VALUE && divisor == -1)\\n            return Integer.MAX_VALUE;\\n        if (divisor == 1)\\n            return dividend;\\n        if (dividend > 0 && divisor > 0)\\n            return divide(-dividend, -divisor);\\n        else if (dividend > 0)\\n            return -divide(-dividend, divisor);\\n        else if (divisor > 0)\\n            return -divide(dividend, -divisor);\\n        if (divisor < dividend || dividend == 0)\\n            return 0;\\n        int sum = divisor;\\n        int mult = 1;\\n        while ((sum + sum) < sum && (sum + sum) >= dividend) {\\n            sum += sum;\\n            mult += mult;\\n        }\\n        return mult + divide(dividend - sum, divisor);\\n    }\\n}\\n```\\nI hope this helps someone who wanted a neat answer in java.\\nthe while loop is used to basically create multiples of the divisor with the powers of 2 (eg 2 x divisor,4 x divisor,8 x divisor, ...) which makes the time complexity O(log n) vs the O(n) time complexity with the repeated subtraction method. (n being the quotient)",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n    public int divide(int dividend, int divisor) {\\n\\t\\t//all of these if else statements are only for edge cases and to make both dividend and divisor negative\\n        if (dividend == Integer.MIN_VALUE && divisor == -1)\\n            return Integer.MAX_VALUE;\\n        if (divisor == 1)\\n            return dividend;\\n        if (dividend > 0 && divisor > 0)\\n            return divide(-dividend, -divisor);\\n        else if (dividend > 0)\\n            return -divide(-dividend, divisor);\\n        else if (divisor > 0)\\n            return -divide(dividend, -divisor);\\n        if (divisor < dividend || dividend == 0)\\n            return 0;\\n        int sum = divisor;\\n        int mult = 1;\\n        while ((sum + sum) < sum && (sum + sum) >= dividend) {\\n            sum += sum;\\n            mult += mult;\\n        }\\n        return mult + divide(dividend - sum, divisor);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 837822,
                "title": "python-clean-solution",
                "content": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        \\n        sign = +1 if dividend ^ divisor >= 0 else -1\\n        \\n        dividend, divisor = abs(dividend), abs(divisor)\\n\\n        ans = 0      \\n        \\n        for power in range(31, -1, -1) :\\n            if (divisor << power) <= dividend:\\n                ans += (1 << power)\\n                dividend -= (divisor << power)\\n           \\n        ans = ans * sign\\n        \\n        if not (-2**31 <= ans <= 2**31-1):\\n            return 2**31 - 1\\n        else:\\n            return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        \\n        sign = +1 if dividend ^ divisor >= 0 else -1\\n        \\n        dividend, divisor = abs(dividend), abs(divisor)\\n\\n        ans = 0      \\n        \\n        for power in range(31, -1, -1) :\\n            if (divisor << power) <= dividend:\\n                ans += (1 << power)\\n                dividend -= (divisor << power)\\n           \\n        ans = ans * sign\\n        \\n        if not (-2**31 <= ans <= 2**31-1):\\n            return 2**31 - 1\\n        else:\\n            return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 204883,
                "title": "56ms-python-solution",
                "content": "```\\nclass Solution:\\n    def divide(self, dividend, divisor):\\n        \"\"\"\\n        :type dividend: int\\n        :type divisor: int\\n        :rtype: int\\n        \"\"\"\\n        dividend1, divisor1 = abs(dividend), abs(divisor)\\n        quotient = 0\\n        while dividend1 >= divisor1:\\n            temp, i = divisor1, 1\\n            while dividend1 >= temp:\\n                dividend1 -= temp\\n                temp += temp\\n                quotient += i\\n                i += i\\n        if (dividend < 0 and divisor > 0) or (dividend > 0 and divisor < 0):\\n            quotient = -quotient\\n        return min(max(quotient, -pow(2,31)),pow(2,31)-1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend, divisor):\\n        \"\"\"\\n        :type dividend: int\\n        :type divisor: int\\n        :rtype: int\\n        \"\"\"\\n        dividend1, divisor1 = abs(dividend), abs(divisor)\\n        quotient = 0\\n        while dividend1 >= divisor1:\\n            temp, i = divisor1, 1\\n            while dividend1 >= temp:\\n                dividend1 -= temp\\n                temp += temp\\n                quotient += i\\n                i += i\\n        if (dividend < 0 and divisor > 0) or (dividend > 0 and divisor < 0):\\n            quotient = -quotient\\n        return min(max(quotient, -pow(2,31)),pow(2,31)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13436,
                "title": "java-3ms-using-bit-operation-and-recursion",
                "content": "    public int divide(int a, int b) {\\n    \\t\\tif (b == 0)\\n    \\t\\t\\treturn Integer.MAX_VALUE;\\n    \\t\\t//\\u7531\\u4e8eInteger.MINVALUE\\u7684\\u7279\\u6b8a\\u6027(\\u5176\\u8865\\u7801\\u662f\\u5b83\\u672c\\u8eab)\\uff0c\\u4e0d\\u5f97\\u4e0d\\u5c06int\\u578b\\u8f6c\\u4e3along\\u578b\\n    \\t\\tlong dividend = (long)a;\\n    \\t\\tlong divisor = (long)b;\\n    \\t\\t//\\u7b26\\u53f7\\u4f4d\\u505a\\u548c\\uff0c-1\\u8868\\u793a\\u7ed3\\u679c\\u4e3a\\u8d1f\\uff0c\\u5426\\u5219\\u7ed3\\u679c\\u4e3a\\u6b63\\u6570\\n    \\t\\tlong sign = (dividend >> 31) + (divisor >> 31);\\n    \\t\\tdividend = (dividend >> 31) == 0 ? dividend : (~dividend + 1);\\n    \\t\\tdivisor = (divisor >> 31) == 0 ? divisor : (~divisor + 1);\\n    \\t\\t//\\u521d\\u59cb\\u5224\\u65ad\\uff0c\\u88ab\\u9664\\u6570\\u5c0f\\uff0c\\u76f4\\u63a5\\u8fd4\\u56de0\\n    \\t\\tif(divisor > dividend)\\n    \\t\\t\\treturn 0;\\n    \\t\\t//\\u5f00\\u59cb\\u9012\\u5f52\\n    \\t\\tlong quotient = recurse(dividend, divisor, divisor, 1);\\n    \\t\\t//\\u7ed9\\u5546\\u52a0\\u4e0a\\u7b26\\u53f7\\n    \\t\\tquotient = (sign == -1) ? (~quotient + 1) : quotient;\\n    \\t\\t//\\u5224\\u65ad\\u662f\\u5426\\u6ea2\\u51fa\\uff0c\\u5982a=Integer.MINVALUE,b=-1\\u7ed3\\u679c\\u662f\\u6ea2\\u51fa\\u7684\\n    \\t\\tif(quotient >= Integer.MIN_VALUE && quotient <= Integer.MAX_VALUE)\\n    \\t\\t\\treturn (int)quotient;\\n    \\t\\telse\\n    \\t\\t\\treturn Integer.MAX_VALUE;\\n    \\t}\\n    \\t/*\\n    \\t * \\u5927\\u81f4\\u601d\\u8def\\uff1a\\n    \\t * \\u9664\\u6570\\u4f9d\\u6b21\\u5de6\\u79fb\\u4e00\\u4f4d(\\u4e582)\\uff0c\\u76f4\\u81f3\\u5927\\u4e8e\\u88ab\\u9664\\u6570\\n    \\t * \\u56de\\u9000\\uff0c\\u5224\\u65ad\\uff0c\\u82e5\\u5dee\\u5c0f\\u4e8e\\u521d\\u59cb\\u9664\\u6570\\uff0c\\u7ed3\\u675f\\uff0c\\u5426\\u5219\\u88ab\\u9664\\u6570\\u7f6e\\u4e3a\\u4e24\\u8005\\u4e4b\\u5dee\\uff0c\\u9664\\u6570\\u4e3a\\u521d\\u59cb\\u6570\\uff1b\\n    \\t * \\u4f8b\\u5982\\uff0c(7,2,2,1)->(7,4,2,2)->(7,8,2,4)->(3>2)->(3,2,2,1)+2->(3,4,2,1)+2->(1<2)->return 1+2=3;\\n    \\t */\\n    \\tpublic long recurse(long dividend, long divisor, long init, long quotient){\\n    \\t\\tif(dividend > divisor){\\n    \\t\\t\\treturn recurse(dividend, divisor << 1, init, quotient << 1);\\n    \\t\\t} else if(dividend == divisor){\\n    \\t\\t\\treturn quotient;\\n    \\t\\t} else{\\n    \\t\\t\\tif(dividend-(divisor >> 1) < init)\\n    \\t\\t\\t\\treturn quotient>>1;\\n    \\t\\t\\telse\\n    \\t\\t\\t\\treturn recurse(dividend - (divisor >> 1), init, init, 1) + (quotient >> 1);\\n    \\t\\t}\\n    \\t}",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "    public int divide(int a, int b) {\\n    \\t\\tif (b == 0)\\n    \\t\\t\\treturn Integer.MAX_VALUE;\\n    \\t\\t//\\u7531\\u4e8eInteger.MINVALUE\\u7684\\u7279\\u6b8a\\u6027(\\u5176\\u8865\\u7801\\u662f\\u5b83\\u672c\\u8eab)\\uff0c\\u4e0d\\u5f97\\u4e0d\\u5c06int\\u578b\\u8f6c\\u4e3along\\u578b\\n    \\t\\tlong dividend = (long)a;\\n    \\t\\tlong divisor = (long)b;\\n    \\t\\t//\\u7b26\\u53f7\\u4f4d\\u505a\\u548c\\uff0c-1\\u8868\\u793a\\u7ed3\\u679c\\u4e3a\\u8d1f\\uff0c\\u5426\\u5219\\u7ed3\\u679c\\u4e3a\\u6b63\\u6570\\n    \\t\\tlong sign = (dividend >> 31) + (divisor >> 31);\\n    \\t\\tdividend = (dividend >> 31) == 0 ? dividend : (~dividend + 1);\\n    \\t\\tdivisor = (divisor >> 31) == 0 ? divisor : (~divisor + 1);\\n    \\t\\t//\\u521d\\u59cb\\u5224\\u65ad\\uff0c\\u88ab\\u9664\\u6570\\u5c0f\\uff0c\\u76f4\\u63a5\\u8fd4\\u56de0\\n    \\t\\tif(divisor > dividend)\\n    \\t\\t\\treturn 0;\\n    \\t\\t//\\u5f00\\u59cb\\u9012\\u5f52\\n    \\t\\tlong quotient = recurse(dividend, divisor, divisor, 1);\\n    \\t\\t//\\u7ed9\\u5546\\u52a0\\u4e0a\\u7b26\\u53f7\\n    \\t\\tquotient = (sign == -1) ? (~quotient + 1) : quotient;\\n    \\t\\t//\\u5224\\u65ad\\u662f\\u5426\\u6ea2\\u51fa\\uff0c\\u5982a=Integer.MINVALUE,b=-1\\u7ed3\\u679c\\u662f\\u6ea2\\u51fa\\u7684\\n    \\t\\tif(quotient >= Integer.MIN_VALUE && quotient <= Integer.MAX_VALUE)\\n    \\t\\t\\treturn (int)quotient;\\n    \\t\\telse\\n    \\t\\t\\treturn Integer.MAX_VALUE;\\n    \\t}\\n    \\t/*\\n    \\t * \\u5927\\u81f4\\u601d\\u8def\\uff1a\\n    \\t * \\u9664\\u6570\\u4f9d\\u6b21\\u5de6\\u79fb\\u4e00\\u4f4d(\\u4e582)\\uff0c\\u76f4\\u81f3\\u5927\\u4e8e\\u88ab\\u9664\\u6570\\n    \\t * \\u56de\\u9000\\uff0c\\u5224\\u65ad\\uff0c\\u82e5\\u5dee\\u5c0f\\u4e8e\\u521d\\u59cb\\u9664\\u6570\\uff0c\\u7ed3\\u675f\\uff0c\\u5426\\u5219\\u88ab\\u9664\\u6570\\u7f6e\\u4e3a\\u4e24\\u8005\\u4e4b\\u5dee\\uff0c\\u9664\\u6570\\u4e3a\\u521d\\u59cb\\u6570\\uff1b\\n    \\t * \\u4f8b\\u5982\\uff0c(7,2,2,1)->(7,4,2,2)->(7,8,2,4)->(3>2)->(3,2,2,1)+2->(3,4,2,1)+2->(1<2)->return 1+2=3;\\n    \\t */\\n    \\tpublic long recurse(long dividend, long divisor, long init, long quotient){\\n    \\t\\tif(dividend > divisor){\\n    \\t\\t\\treturn recurse(dividend, divisor << 1, init, quotient << 1);\\n    \\t\\t} else if(dividend == divisor){\\n    \\t\\t\\treturn quotient;\\n    \\t\\t} else{\\n    \\t\\t\\tif(dividend-(divisor >> 1) < init)\\n    \\t\\t\\t\\treturn quotient>>1;\\n    \\t\\t\\telse\\n    \\t\\t\\t\\treturn recurse(dividend - (divisor >> 1), init, init, 1) + (quotient >> 1);\\n    \\t\\t}\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2029618,
                "title": "c-easy-to-understand-detailed-explanation-beginner-friendly-bitwise-o-log-n",
                "content": "Ayo! Another question that\\'s a bit tricky to get because, you guessed it, it involves a trick lol.\\nDon\\'t worry though, here\\'s the explanation, as simple as it can get!\\n\\nWe will follow a simple rule here.\\n- We are given 2 things. Dividend and Divisor.\\n- The dividend is divided by the divisor.\\n- Our job is to multiply divisor as long as it\\'s less than dividend.\\n\\n**Take this example: Dividend = 10. Divisor = 3.**\\nWe know the answer should be 3 because 3x3=9. Which is the greatest number we can achieve, by multiplying 3 n times and when subtracted from dividend, will be as close to 0 as possible. So, 10-9=1, which is very close to 0. \\n\\nOur job is to multiply divisor again and again, to make it such a large number that when subtracted from dividend, will give us a number as close to 0 as possible.\\n\\n**Steps Taken:**\\n1. The dividend and divisor can be negative. So store their sign for later use and for now, convert them into positive integers by using the abs() function.\\n2. While dividend is greater than divisor, we do the following operations on divisor:\\n3. We take a copy of divisor and try to double it as long as it\\'s smaller than dividend.\\n4. The number of times we double, is twice the number of times we multiply. So, if we double once, we are just multiplying the number by 2^1 in reality. If we double 4 times, then we\\'re actually multiplying the number by 2^4=8 (basic math: we\\'re just multiplying the number by 2 every time).\\n5. So keep doubling divisor\\'s copy and keep tracking how many times we multiplied divisor\\'s copy.\\n6. Now after a while, the divisor\\'s copy\\'s double will be greater than the dividend. So stop the doubling loop for now.\\n7. Now, whatever we have from doubling divisor\\'s copy. Subtract that from the dividend and store that back into the dividend. So, if we doubled 5 thrice, the divisor\\'s copy will be 40 or in other words, we multiplied 5 by 2^3=8 (5 doubled=10 doubled=20 doubled=40). So if we doubled 3 times, we basically multiplied 5 by 2^3=8. So if the divisor\\'s copy is now 40 and if our dividend was 48, our dividend after subtraction will be: 48-40=8, which is still less than original divisor 5. So our loop will run once again. This time, dividend is 8. Divisor is 5. Divisor\\'s copy\\'s double is 10, which is greater than 8. So we won\\'t double the divisor this time. So, if we didn\\'t double it, we just multiplied the 5 with 1, instead of 2. Now again, subtract 8-5=3. So, we first multiplied 5 by 8, then multiplied 5 by 1. Overall, we multiplied 5 by 9 (8+1), which is our answer. More loops won\\'t work because dividend is now 3, which is less than 5.\\n8. If our original dividend and divisor would have given positive result, we return ans as is.\\n9. Otherwise, if one of the numbers was negative, then we return ans with negative sign.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int divide(int divd, int divs) {\\n        // When given dividend is -INFINITY and divisor is -1. The\\n        // answer should be -Inf*-1=Inf\\n        if(divd == INT_MIN and divs == -1){\\n            return INT_MAX;\\n        }\\n        // If dividend and divisor are both positive/negative\\n        // total is positive, else not.\\n        bool positiveSign = (divd < 0 == divs < 0);\\n        // since we know what sign the result should be,\\n        // we can remove the negative sign from both divisor and dividend\\n        long dividend = abs(divd);\\n        long divisor = abs(divs);\\n        // our final answer will be \\'ans\\', the number of times we need to multiply\\n        // divisor to make dividend as close to 0 as possible.\\n        long ans = 0;\\n        \\n        // while dividend is less/equal to divisor do the following:\\n        while(dividend >= divisor){\\n            // take a copy of divisor. we\\'re not modifying divisor,\\n            // because we still need to check if dividend is greater/equal to\\n            // our original divisor\\n            long divisor2 = divisor;\\n            // divisorMultipliedBy tells us how many times we can double\\n            // divisor so as to keep it less than dividend.\\n            // for example: 3x2=6. 3 doubled is 6, which is still less than 10\\n            long divisorMultipliedBy = 1;\\n            \\n            // while dividend is greater than double the divisor2 do the following:\\n            while(dividend >= (divisor2 << 1)){\\n                // double the divisor2, if it was 3 at first, make it 6\\n                divisor2 = divisor2 << 1;\\n                // Since we doubled divisor, store the amount of how many times\\n                // we multiplied divisor.\\n                // 3 doubled once=6, so we multiplied divisor by 2.\\n                // 3 doubled twice=12. So we multiplied 3 by 4.\\n                divisorMultipliedBy = divisorMultipliedBy << 1;\\n            }\\n            // divisorMultipliedBy should now have the number of times\\n            // we multiplied divisor to get a value less than dividend.\\n            ans+= divisorMultipliedBy;\\n            // so if now divisor2 is 6, after doubling once.\\n            // dividend was 10, but after subtracting dividend will become 10-6=4.\\n            // So now 4 is dividend, 3 is divisor and we try to find out the number\\n            // of multiplications again and add them up.\\n            // In the second iteration, we\\'ll multiply 3 by 1. So now it\\'ll be\\n            // 4-3=1. dividend is now as close to 0 as possible and is also less\\n            // than divisor. So, our final ans is 3. We x2 the 3 once and now x1.\\n            dividend -= divisor2;\\n        }\\n                  \\n        // if PositiveSign was true, then we return ans as is.\\n        if(positiveSign){\\n            return ans;\\n        }\\n        // otherwise, multiply by -1 (you can also directly write `return -ans`\\n        return ans * -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int divide(int divd, int divs) {\\n        // When given dividend is -INFINITY and divisor is -1. The\\n        // answer should be -Inf*-1=Inf\\n        if(divd == INT_MIN and divs == -1){\\n            return INT_MAX;\\n        }\\n        // If dividend and divisor are both positive/negative\\n        // total is positive, else not.\\n        bool positiveSign = (divd < 0 == divs < 0);\\n        // since we know what sign the result should be,\\n        // we can remove the negative sign from both divisor and dividend\\n        long dividend = abs(divd);\\n        long divisor = abs(divs);\\n        // our final answer will be \\'ans\\', the number of times we need to multiply\\n        // divisor to make dividend as close to 0 as possible.\\n        long ans = 0;\\n        \\n        // while dividend is less/equal to divisor do the following:\\n        while(dividend >= divisor){\\n            // take a copy of divisor. we\\'re not modifying divisor,\\n            // because we still need to check if dividend is greater/equal to\\n            // our original divisor\\n            long divisor2 = divisor;\\n            // divisorMultipliedBy tells us how many times we can double\\n            // divisor so as to keep it less than dividend.\\n            // for example: 3x2=6. 3 doubled is 6, which is still less than 10\\n            long divisorMultipliedBy = 1;\\n            \\n            // while dividend is greater than double the divisor2 do the following:\\n            while(dividend >= (divisor2 << 1)){\\n                // double the divisor2, if it was 3 at first, make it 6\\n                divisor2 = divisor2 << 1;\\n                // Since we doubled divisor, store the amount of how many times\\n                // we multiplied divisor.\\n                // 3 doubled once=6, so we multiplied divisor by 2.\\n                // 3 doubled twice=12. So we multiplied 3 by 4.\\n                divisorMultipliedBy = divisorMultipliedBy << 1;\\n            }\\n            // divisorMultipliedBy should now have the number of times\\n            // we multiplied divisor to get a value less than dividend.\\n            ans+= divisorMultipliedBy;\\n            // so if now divisor2 is 6, after doubling once.\\n            // dividend was 10, but after subtracting dividend will become 10-6=4.\\n            // So now 4 is dividend, 3 is divisor and we try to find out the number\\n            // of multiplications again and add them up.\\n            // In the second iteration, we\\'ll multiply 3 by 1. So now it\\'ll be\\n            // 4-3=1. dividend is now as close to 0 as possible and is also less\\n            // than divisor. So, our final ans is 3. We x2 the 3 once and now x1.\\n            dividend -= divisor2;\\n        }\\n                  \\n        // if PositiveSign was true, then we return ans as is.\\n        if(positiveSign){\\n            return ans;\\n        }\\n        // otherwise, multiply by -1 (you can also directly write `return -ans`\\n        return ans * -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902484,
                "title": "100-fastest-swift-solution-log-n",
                "content": "```\\nclass Solution {\\n    func divide(_ dividend: Int, _ divisor: Int) -> Int {\\n        let is_negtive = (dividend < 0 && divisor > 0) || (dividend > 0 && divisor < 0)\\n        let dividend = abs(dividend)\\n        let divisor = abs(divisor)\\n        var tmp = divisor\\n        var rem = dividend\\n        var res = 0\\n\\n        while rem >= tmp {\\n            var count = 0\\n            while rem >= tmp {\\n                count += 1\\n                tmp *= 10\\n            }\\n            tmp = divisor\\n            rem = rem - Int(pow(10, Double(count-1))) * tmp\\n            if rem >= 0 {\\n                res += Int(pow(10, Double(count-1)))\\n            }\\n        }\\n        \\n        if (is_negtive && res >= 2147483648) { res = 2147483648 }\\n        if (!is_negtive && res >= 2147483647) { res = 2147483647 }\\n        return is_negtive ? -1 * res : res\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func divide(_ dividend: Int, _ divisor: Int) -> Int {\\n        let is_negtive = (dividend < 0 && divisor > 0) || (dividend > 0 && divisor < 0)\\n        let dividend = abs(dividend)\\n        let divisor = abs(divisor)\\n        var tmp = divisor\\n        var rem = dividend\\n        var res = 0\\n\\n        while rem >= tmp {\\n            var count = 0\\n            while rem >= tmp {\\n                count += 1\\n                tmp *= 10\\n            }\\n            tmp = divisor\\n            rem = rem - Int(pow(10, Double(count-1))) * tmp\\n            if rem >= 0 {\\n                res += Int(pow(10, Double(count-1)))\\n            }\\n        }\\n        \\n        if (is_negtive && res >= 2147483648) { res = 2147483648 }\\n        if (!is_negtive && res >= 2147483647) { res = 2147483647 }\\n        return is_negtive ? -1 * res : res\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 303141,
                "title": "python-beats-99-77-time-28ms-and-88-memory",
                "content": "Uses bit shifting until it cannot be performed anymore. Shifting by 1 bit to the left means multiplying the number by 2. If we shift two times, then it means we multiplied number by 4, etc.\\nExample `dividend = 31` and `divisor = 2`:\\n```\\n2 << 1 = 4 (31 > 4 == True)\\n4 << 1 = 8 (31 > 8 == True)\\n8 << 1 = 16 (31 > 16 == True)  # <-- pause here\\n16 << 1 = 32 (31 > 32 == False)\\n```\\nSo far we got `quotient = 8`, now we adjust `dividend = divident - 16 = 15` and repeat:\\n```\\n2 << 1 = 4 < 15\\n4 << 1 = 8 < 15\\n8 << 1 = 16 > 15\\n```\\nNow `quotient = 8 + 4` and new `dividend = divident - 8 = 15 - 8 = 7`\\n```\\n2 << 1 = 4 < 7\\n4 << 1 = 8 > 7\\n```\\nUpdate `quotient = 8 + 4 + 2` and `dividend = 7 - 4 = 3`\\nAs `2 << 1 = 4` which is > 3, but 3 > 2, we add one more unit to the quotient, resulting in `q = 15`.\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        if dividend >= 0 and divisor >= 0 or (dividend < 0 and divisor < 0):\\n            sign = 1\\n        else:\\n            sign = -1\\n        \\n\\t\\t# some shortcuts\\n        if divisor == -1 and dividend == -2147483648:\\n            return 2147483647\\n        elif divisor == 1:\\n            return abs(dividend) if sign == 1 else -abs(dividend)\\n        \\n        divisor = abs(divisor)\\n        dividend = abs(dividend)\\n        \\n        if dividend < divisor:\\n            return 0\\n        \\n        d = divisor\\n        q = 1\\n        rq = 0\\n        while True:\\n            t = divisor << 1\\n            if dividend >= t:\\n                divisor = t\\n                q += q\\n            else:\\n                rq += q\\n                q = 1\\n                dividend -= divisor\\n                divisor = d\\n                if (divisor << 1) > dividend:\\n                    if dividend >= divisor:\\n                        rq += 1\\n                    break\\n\\n        return rq if sign == 1 else -rq\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n2 << 1 = 4 (31 > 4 == True)\\n4 << 1 = 8 (31 > 8 == True)\\n8 << 1 = 16 (31 > 16 == True)  # <-- pause here\\n16 << 1 = 32 (31 > 32 == False)\\n```\n```\\n2 << 1 = 4 < 15\\n4 << 1 = 8 < 15\\n8 << 1 = 16 > 15\\n```\n```\\n2 << 1 = 4 < 7\\n4 << 1 = 8 > 7\\n```\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        if dividend >= 0 and divisor >= 0 or (dividend < 0 and divisor < 0):\\n            sign = 1\\n        else:\\n            sign = -1\\n        \\n\\t\\t# some shortcuts\\n        if divisor == -1 and dividend == -2147483648:\\n            return 2147483647\\n        elif divisor == 1:\\n            return abs(dividend) if sign == 1 else -abs(dividend)\\n        \\n        divisor = abs(divisor)\\n        dividend = abs(dividend)\\n        \\n        if dividend < divisor:\\n            return 0\\n        \\n        d = divisor\\n        q = 1\\n        rq = 0\\n        while True:\\n            t = divisor << 1\\n            if dividend >= t:\\n                divisor = t\\n                q += q\\n            else:\\n                rq += q\\n                q = 1\\n                dividend -= divisor\\n                divisor = d\\n                if (divisor << 1) > dividend:\\n                    if dividend >= divisor:\\n                        rq += 1\\n                    break\\n\\n        return rq if sign == 1 else -rq\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1203085,
                "title": "python-best-explanation-line-by-line-fast-efficient-solution",
                "content": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        #A condition to check whether both are positivie or not\\n        positive = (dividend < 0) == (divisor < 0)\\n        \\n        #Now we\\'ve stored our sign in poistive variable so we make both numbers positive\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        \\n        #This is the quotient\\n        ans = 0\\n        \\n        #Outer while loop which checks the lower multiples of divisor\\n        while dividend >= divisor:\\n            temp, i = divisor, 1\\n            \\n             #Inner while loop where values value of multiples of divisor keep doubling after each iteration for less number of operations\\n            while dividend >= temp:\\n                dividend -= temp\\n                \\n                ans += i #Storing the number of times number multiplied\\n                \\n                i <<= 1 #Doubling -- 1,2,4..\\n                \\n                temp <<= 1 #Doubling Divisor values -- x,2x,4x...\\n        \\n        #Re-assigning the sign to our answer\\n        if not positive:\\n            ans = -ans\\n            \\n        #Returning answer within range\\n        return min(max(-2147483648, ans), 2147483647)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        #A condition to check whether both are positivie or not\\n        positive = (dividend < 0) == (divisor < 0)\\n        \\n        #Now we\\'ve stored our sign in poistive variable so we make both numbers positive\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        \\n        #This is the quotient\\n        ans = 0\\n        \\n        #Outer while loop which checks the lower multiples of divisor\\n        while dividend >= divisor:\\n            temp, i = divisor, 1\\n            \\n             #Inner while loop where values value of multiples of divisor keep doubling after each iteration for less number of operations\\n            while dividend >= temp:\\n                dividend -= temp\\n                \\n                ans += i #Storing the number of times number multiplied\\n                \\n                i <<= 1 #Doubling -- 1,2,4..\\n                \\n                temp <<= 1 #Doubling Divisor values -- x,2x,4x...\\n        \\n        #Re-assigning the sign to our answer\\n        if not positive:\\n            ans = -ans\\n            \\n        #Returning answer within range\\n        return min(max(-2147483648, ans), 2147483647)",
                "codeTag": "Java"
            },
            {
                "id": 314856,
                "title": "c-0ms-100-using-log",
                "content": "\\nUsing  Fact : log(a/b) = log(a)-log(b)\\nans = a/b\\nlog(ans) = log(a/b)\\nlog(ans) = log(a)-log(b)\\nans = exp( log(a)-log(b) )\\n\\n```\\n  int divide(int dividend, int divisor) {\\n        int sign= (dividend<0 ^ divisor<0) ? -1 : 1; //same ? 0(false) (XOR)\\n        \\n        long ldividend=labs(dividend);\\n        long ldivisor=labs(divisor);\\n     \\n        long res = exp(log(ldividend)-log(ldivisor));\\n        cout<<ldividend<<\"/\"<<ldivisor<<\"=\"<<res;\\n        if(res>INT_MAX)\\n            return sign==1 ? INT_MAX:INT_MIN;\\n        return sign*(int)res;\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n  int divide(int dividend, int divisor) {\\n        int sign= (dividend<0 ^ divisor<0) ? -1 : 1; //same ? 0(false) (XOR)\\n        \\n        long ldividend=labs(dividend);\\n        long ldivisor=labs(divisor);\\n     \\n        long res = exp(log(ldividend)-log(ldivisor));\\n        cout<<ldividend<<\"/\"<<ldivisor<<\"=\"<<res;\\n        if(res>INT_MAX)\\n            return sign==1 ? INT_MAX:INT_MIN;\\n        return sign*(int)res;\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 13607,
                "title": "accepted-cpp-solution-with-explainations",
                "content": "    int divide(int64_t n, int64_t m) {\\n    \\t// determine sign of the quotient\\n    \\tint sign = n < 0 ^ m < 0 ? -1 : 1;\\n    \\n    \\t// remove sign of operands\\n    \\tn = abs(n), m = abs(m);\\n    \\n    \\t// q stores the quotient in computation\\n    \\tint64_t q = 0;\\n    \\n    \\t// test down from the highest bit\\n    \\t// accumulate the tentative value for valid bits\\n    \\tfor (int64_t t = 0, i = 31; i >= 0; i--)\\n    \\t\\tif (t + (m << i) <= n)\\n    \\t\\t\\tt += m << i, q |= 1LL << i;\\n    \\n    \\t// assign back the sign\\n    \\tif (sign < 0) q = -q;\\n    \\n    \\t// check for overflow and return\\n    \\treturn q >= INT_MAX ? INT_MAX : q <= INT_MIN ? INT_MIN : q;\\n    }",
                "solutionTags": [],
                "code": "    int divide(int64_t n, int64_t m) {\\n    \\t// determine sign of the quotient\\n    \\tint sign = n < 0 ^ m < 0 ? -1 : 1;\\n    \\n    \\t// remove sign of operands\\n    \\tn = abs(n), m = abs(m);\\n    \\n    \\t// q stores the quotient in computation\\n    \\tint64_t q = 0;\\n    \\n    \\t// test down from the highest bit\\n    \\t// accumulate the tentative value for valid bits\\n    \\tfor (int64_t t = 0, i = 31; i >= 0; i--)\\n    \\t\\tif (t + (m << i) <= n)\\n    \\t\\t\\tt += m << i, q |= 1LL << i;\\n    \\n    \\t// assign back the sign\\n    \\tif (sign < 0) q = -q;\\n    \\n    \\t// check for overflow and return\\n    \\treturn q >= INT_MAX ? INT_MAX : q <= INT_MIN ? INT_MIN : q;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2089781,
                "title": "go-back-to-the-elementary-school-basics-w-examples",
                "content": "We will follow the **same exact division algorithm we all learn in elementary school** to divide integers, but in binary:\\n\\n*\"We traverse `dividend` from left to right, looking at the first `k` digits, where `k` is the number of digits of `divisor`. If the number formed by those first `k` digits is larger than or equal to `divisor`, then we write `1` in the quotient, subtract and move on to the next digit.\"*\\n\\n# Examples\\n*53 &div; 3 = 17*\\n![image](https://assets.leetcode.com/users/images/0cbe7c91-feb1-4c1b-8527-5b820aa35478_1653891963.4127522.png)\\n\\n\\n*246 &div; 7 = 35*\\n![image](https://assets.leetcode.com/users/images/5b1e8a36-cc5e-4eee-a01d-3128b1ac4f4a_1653891972.2472856.png)\\n\\n\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        if dividend == 0:\\n            return 0\\n\\t\\t# only case that gives answer outside of [-2 ** 31, 2 ** 31 - 1]\\n        if dividend == -2 ** 31 and divisor == -1:\\n            return 2 ** 31 - 1\\n\\t\\t\\t\\n\\t\\t# we work with positive numbers only and worry about the sign in the end\\n        if dividend > 0 and divisor > 0 or dividend < 0 and divisor < 0:\\n            positiveSign = True\\n        else:\\n            positiveSign = False\\n        dividend, divisor = abs(dividend), abs(divisor)\\n\\n        quotient = 0\\n        for i in reversed(range(dividend.bit_length() - divisor.bit_length() + 1)):\\n            if dividend >> i >= divisor:\\n                dividend -= divisor << i\\n                quotient |= 1 << i\\n        \\n        return quotient if positiveSign else -quotient\\n```\\n# Notes\\n* **Time complexity:** *O(log(`dividend`))*\\n* **Space complexity:** *O(1)*\\n\\nWe don\\'t need to worry about `quotient` being smaller than `-2 ** 31` since `abs(quotient) <= abs(dividend) <= 2 ** 31`.\\n\\nEdit: Updated handling of corner case so that we **only** work with integers in `[-2 ** 31, 2 ** 31 - 1]` at all times.",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        if dividend == 0:\\n            return 0\\n\\t\\t# only case that gives answer outside of [-2 ** 31, 2 ** 31 - 1]\\n        if dividend == -2 ** 31 and divisor == -1:\\n            return 2 ** 31 - 1\\n\\t\\t\\t\\n\\t\\t# we work with positive numbers only and worry about the sign in the end\\n        if dividend > 0 and divisor > 0 or dividend < 0 and divisor < 0:\\n            positiveSign = True\\n        else:\\n            positiveSign = False\\n        dividend, divisor = abs(dividend), abs(divisor)\\n\\n        quotient = 0\\n        for i in reversed(range(dividend.bit_length() - divisor.bit_length() + 1)):\\n            if dividend >> i >= divisor:\\n                dividend -= divisor << i\\n                quotient |= 1 << i\\n        \\n        return quotient if positiveSign else -quotient\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089277,
                "title": "with-explanation-3-possible-solution-in-c",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE IT\\n```\\nsolution 1:\\nSuppose dividend = 15 and divisor = 3, 15 - 3 > 0. We now try to subtract more by shifting 3 to the left by 1 bit (6). Since 15 - 6 > 0, shift 6 again to 12. Now 15 - 12 > 0, shift 12 again to 24, which is larger than 15. So we can at most subtract 12 from 15. Since 12 is obtained by shifting 3 to left twice, it is 1 << 2 = 4 times of 3. We add 4 to an answer variable (initialized to be 0). The above process is like 15 = 3 * 4 + 3. We now get part of the quotient (4), with a remaining dividend 3.\\n\\nThen we repeat the above process by subtracting divisor = 3 from the remaining dividend = 3 and obtain 0. We are done. In this case, no shift happens. We simply add 1 << 0 = 1 to the answer variable.\\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        if (dividend == INT_MIN && divisor == -1) {\\n            return INT_MAX;\\n        }\\n        long dvd = labs(dividend), dvs = labs(divisor), ans = 0;\\n        int sign = dividend > 0 ^ divisor > 0 ? -1 : 1;\\n        while (dvd >= dvs) {\\n            long temp = dvs, m = 1;\\n            while (temp << 1 <= dvd) {\\n                temp <<= 1;\\n                m <<= 1;\\n            }\\n            dvd -= temp;\\n            ans += m;\\n        }\\n        return sign * ans;\\n    }\\n};\\n```\\n\\nsolution 2:\\nBasic idea: a/b = e^(ln(a))/e^(ln(b)) = e^(ln(a)-ln(b))\\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        if (dividend==0) return 0;\\n        if (divisor==0) return INT_MAX;\\n        long long res=double(exp(log(fabs(dividend))-log(fabs(divisor))));\\n        if ((dividend<0)^(divisor<0)) res=-res;\\n        if (res>INT_MAX) res=INT_MAX;\\n        return res;\\n    }\\n};\\n```\\n\\nsolution 3:\\nLong division in binary:\\nThe outer loop reduces n by at least half each iteration. So It has O(log N) iterations.\\nThe inner loop has at most log N iterations.\\nSo the overall complexity is O(( log N)^2)\\n\\n```\\ntypedef long long ll;\\n\\nint divide(int n_, int d_) {\\n    ll ans=0;\\n    ll n=abs((ll)n_);\\n    ll d=abs((ll)d_);\\n    while(n>=d){\\n        ll a=d;\\n        ll m=1;\\n        while((a<<1) < n){a<<=1;m<<=1;}\\n        ans+=m;\\n        n-=a;\\n    }\\n    if((n_<0&&d_>=0)||(n_>=0&&d_<0))\\n        return -ans;\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE IT\\n```\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        if (dividend == INT_MIN && divisor == -1) {\\n            return INT_MAX;\\n        }\\n        long dvd = labs(dividend), dvs = labs(divisor), ans = 0;\\n        int sign = dividend > 0 ^ divisor > 0 ? -1 : 1;\\n        while (dvd >= dvs) {\\n            long temp = dvs, m = 1;\\n            while (temp << 1 <= dvd) {\\n                temp <<= 1;\\n                m <<= 1;\\n            }\\n            dvd -= temp;\\n            ans += m;\\n        }\\n        return sign * ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        if (dividend==0) return 0;\\n        if (divisor==0) return INT_MAX;\\n        long long res=double(exp(log(fabs(dividend))-log(fabs(divisor))));\\n        if ((dividend<0)^(divisor<0)) res=-res;\\n        if (res>INT_MAX) res=INT_MAX;\\n        return res;\\n    }\\n};\\n```\n```\\ntypedef long long ll;\\n\\nint divide(int n_, int d_) {\\n    ll ans=0;\\n    ll n=abs((ll)n_);\\n    ll d=abs((ll)d_);\\n    while(n>=d){\\n        ll a=d;\\n        ll m=1;\\n        while((a<<1) < n){a<<=1;m<<=1;}\\n        ans+=m;\\n        n-=a;\\n    }\\n    if((n_<0&&d_>=0)||(n_>=0&&d_<0))\\n        return -ans;\\n    return ans;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13418,
                "title": "c-8ms-solution-without-long-long",
                "content": "\\n    class Solution {\\n    public:\\n        int divide(int dividend, int divisor) {\\n            if(!divisor) return INT_MAX;\\n            if(divisor == 1) return dividend;\\n            if(divisor == -1){\\n                if(dividend == INT_MIN) {return INT_MAX;}\\n                else {return -dividend;}\\n            }\\n            \\n            bool s1 = dividend<0;\\n            bool s2 = divisor<0;\\n            \\n            unsigned int nom = s1?-dividend:dividend;\\n            unsigned int den = s2?-divisor:divisor;\\n            \\n            unsigned int rem = 0;\\n            unsigned int quot = 0;\\n            \\n            for(int i=31; i>=0;--i){\\n                rem <<= 1;\\n                rem |= (nom >> i) & 1;\\n                if(rem >= den){\\n                    rem -= den;\\n                    quot |= (1<<i);\\n                }\\n            }\\n    \\n            return s1^s2?-quot:quot;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int divide(int dividend, int divisor) {\\n            if(!divisor) return INT_MAX;\\n            if(divisor == 1) return dividend;\\n            if(divisor == -1){\\n                if(dividend == INT_MIN) {return INT_MAX;}",
                "codeTag": "Java"
            },
            {
                "id": 2719043,
                "title": "python-subtraction-o-logn",
                "content": "You can refer to this [video solution](https://www.youtube.com/watch?v=xefkgtd44hg&ab_channel=CheatCodeNinja) \\n\\nHere we are doubling the divisor everytime and hence compressing the total number of subtraction operations. \\nIf the doubled divisor is greater than the dividend, we reset our divisor to its initial value and try again.\\n\\nAt the end, we make sure that the output is within the given range and avoid an overflow.\\n\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        a = abs(dividend)\\n        b=abs(divisor)\\n        \\n        negative = (dividend<0 and divisor>=0) or (dividend>=0 and divisor<0)\\n        \\n        output = 0\\n        \\n        while a>=b:\\n            counter = 1\\n            decrement = b\\n            \\n            while a>=decrement:\\n                a-=decrement\\n                \\n                output+=counter\\n                counter+=counter\\n                decrement+=decrement\\n                \\n        output = output if not negative else -output\\n        \\n        return min(max(-2147483648, output), 2147483647)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "You can refer to this [video solution](https://www.youtube.com/watch?v=xefkgtd44hg&ab_channel=CheatCodeNinja) \\n\\nHere we are doubling the divisor everytime and hence compressing the total number of subtraction operations. \\nIf the doubled divisor is greater than the dividend, we reset our divisor to its initial value and try again.\\n\\nAt the end, we make sure that the output is within the given range and avoid an overflow.\\n\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        a = abs(dividend)\\n        b=abs(divisor)\\n        \\n        negative = (dividend<0 and divisor>=0) or (dividend>=0 and divisor<0)\\n        \\n        output = 0\\n        \\n        while a>=b:\\n            counter = 1\\n            decrement = b\\n            \\n            while a>=decrement:\\n                a-=decrement\\n                \\n                output+=counter\\n                counter+=counter\\n                decrement+=decrement\\n                \\n        output = output if not negative else -output\\n        \\n        return min(max(-2147483648, output), 2147483647)\\n",
                "codeTag": "Java"
            },
            {
                "id": 1929540,
                "title": "java-solution-with-explanation",
                "content": "Logic explain\\nA dividend can be construct by the multiple of divisor\\n\\nE.g \\n`dividend = 20, divisor = 5 => 20 = 5 + 5 + 5 + 5 = 5 * 4`\\nOR\\n`dividend = 19, divisor = 5 => 19 = 5 + 5 + 5 +4 = 5 * 3 + 4 `\\nand what we need is to return the multiply of 5, which is  4 and 3 respectively.\\n\\nFirstly, we check dividend and divisor is negative. Then to ensure divident and divisor is possitive, do absolute value. \\n\\nThen all we need to do is to find out how many divisor is needed for dividend become 0 or less than divisor\\nwe create a counter to count number of divisor. \\n```\\n while(dividend - divisor >= 0){\\n            int count = 0;\\n\\n            while(dividend - (divisor << 1 << count) >= 0){\\n                count++;\\n            }\\n            r += 1 << count;\\n\\t\\t\\tdividend -= divisor << count;\\n        }\\n```\\nThis count is number of left shift divisor did, for example 3 << 2 means 3 left shifted 2 times, each left shift equal to * 2, so 3 << 2 = 3 * 2 * 2 =  12. \\n\\nAnother example, dividend = 15, divisor = 3,\\nIn first outer loop, counter++ twice in inner loop, leading to 15 - 3 << 2, r += 1 << 2 (which is 4)\\nSince dividend (15 - 12 = 3) - divisor == 0, loop second times. Skip inner loop as the condition is false, r += 1 << 0 = 5 (1 << 0 == 1)\\n\\nLastly, if negative true, do\\n```\\n\\tr = ~r + 1;\\n```\\nwhich change a possitive number to negative, return answer.\\n\\n\\nThe most difficult part of this question is edge case.\\n\\nLets handle the first edge case, divident = -2147483648 and divisor =  -1.\\nthe answer should be 2147483648, however this overflow. We cannot calculate this, hence use this as if statement condition, and return max value directly.\\n```\\n\\tif(dividend == Integer.MIN_VALUE && divisor == -1){\\n            return Integer.MAX_VALUE;\\n        }\\n```\\n\\nAnother edge case is dividend = max_value or min_value and divisor =  1 (or -1 if divident = max_value)\\nYou can see in our inner loop, it is \\n```\\ndivisor << 1 << count\\n```\\ninstead of\\n```\\ndivisor << count\\n```\\nthis << 1 is a extra * 2 in order to prevent overflow. For example when dividend = min_value and divisor = 1, in\\n```\\n\\twhile(dividend - (divisor << 1 << count) >= 0){\\n                count++;\\n            }\\n```\\ndivisor << count will eventually equal to -2147483648 (1 << 31 will overflow and get -2147483648), while dividend (for min_value, after abs it is overflow, so remain min_value) - -2147483648, it equal to 0 and while loop repeat endlessly. Adding << 1, 1 << 1 << 31 equal 0, and min_value - 0 will break the inner while loop.\\n\\nComplete code\\n```\\npublic int divide(int dividend, int divisor) {\\n        if(dividend == Integer.MIN_VALUE && divisor == -1){\\n            return Integer.MAX_VALUE;\\n        }\\n        boolean neg = (dividend < 0 && divisor > 0) || (dividend > 0 && divisor < 0);\\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n        int r = 0;\\n        while(dividend - divisor >= 0){\\n            int count = 0;\\n\\n            while(dividend - (divisor << 1 << count) >= 0){\\n                count++;\\n            }\\n            r += 1 << count;\\n            dividend -= divisor << count;\\n        }\\n\\n        if(neg){\\n            r = ~r + 1;\\n        }\\n        return r;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\n while(dividend - divisor >= 0){\\n            int count = 0;\\n\\n            while(dividend - (divisor << 1 << count) >= 0){\\n                count++;\\n            }\\n            r += 1 << count;\\n\\t\\t\\tdividend -= divisor << count;\\n        }\\n```\n```\\n\\tr = ~r + 1;\\n```\n```\\n\\tif(dividend == Integer.MIN_VALUE && divisor == -1){\\n            return Integer.MAX_VALUE;\\n        }\\n```\n```\\ndivisor << 1 << count\\n```\n```\\ndivisor << count\\n```\n```\\n\\twhile(dividend - (divisor << 1 << count) >= 0){\\n                count++;\\n            }\\n```\n```\\npublic int divide(int dividend, int divisor) {\\n        if(dividend == Integer.MIN_VALUE && divisor == -1){\\n            return Integer.MAX_VALUE;\\n        }\\n        boolean neg = (dividend < 0 && divisor > 0) || (dividend > 0 && divisor < 0);\\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n        int r = 0;\\n        while(dividend - divisor >= 0){\\n            int count = 0;\\n\\n            while(dividend - (divisor << 1 << count) >= 0){\\n                count++;\\n            }\\n            r += 1 << count;\\n            dividend -= divisor << count;\\n        }\\n\\n        if(neg){\\n            r = ~r + 1;\\n        }\\n        return r;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1084897,
                "title": "c-o-1-using-exponential-and-log",
                "content": "**Approach** - \\n\\nLet\\'s say, a/b = c.\\n1 . Take log on both sides -> ```log(a/b) = log(c)```\\n2. Use log propery (log(a/b) = log(a) - log(b)) -> ```log(a) - log(b) = log(c)```\\n3. Take exponential on both sides (e(x) = 1/ln(x)) -> ```c = e^(log(a) - log(b))```, Find c now.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        \\n        int sign = (dividend < 0) ^ (divisor < 0);\\n        \\n        long dvnd = abs(dividend);\\n        long dvsr = abs(divisor);\\n        \\n        long res = exp(log(dvnd) - log(dvsr));\\n        \\n        res *= (sign ? -1 : 1);\\n        \\n        if(res > INT_MAX)\\n            return INT_MAX;\\n        \\n        if(res < INT_MIN)\\n            return INT_MIN;\\n        \\n        return res;\\n    }\\n};\\n\\n/*\\n\\na/b = c\\nlog(a) - log(b) = log(c)\\nc = e^(log(a) - log(b))\\n*/\\n```",
                "solutionTags": [],
                "code": "```log(a/b) = log(c)```\n```log(a) - log(b) = log(c)```\n```c = e^(log(a) - log(b))```\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        \\n        int sign = (dividend < 0) ^ (divisor < 0);\\n        \\n        long dvnd = abs(dividend);\\n        long dvsr = abs(divisor);\\n        \\n        long res = exp(log(dvnd) - log(dvsr));\\n        \\n        res *= (sign ? -1 : 1);\\n        \\n        if(res > INT_MAX)\\n            return INT_MAX;\\n        \\n        if(res < INT_MIN)\\n            return INT_MIN;\\n        \\n        return res;\\n    }\\n};\\n\\n/*\\n\\na/b = c\\nlog(a) - log(b) = log(c)\\nc = e^(log(a) - log(b))\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1016568,
                "title": "java-a-proper-approach",
                "content": "## Java: A proper approach\\n\\nSo a lot of the topics in this discussion are useless because they either do exactly what the problem tells you not to do and say \"look at me I can cheat\" or work around the problem by typecasting or some other bs. I will attempt to explain how you can implement this algorithm using only type `int`. I am open to questions, comments, concerns and improvements. \\n\\n*Note:* This problem and its solution are somewhat peculiar in that they\\'re less about practicing your algorithms than coming up with an interesting approach to a dull problem using what tools you have.\\n\\n### Approach \\n\\nSo you can\\'t (or at least the problem description tells you not to) use any math operations that would seem useful in this situation... thats a shame. \\n\\n#### Brute-force\\n\\nFrom a brute-force perspective, we can make a loop where we increment some counter by one and increment value $d$ by divisor until $d > $ dividend; then the answer we are looking for is simply the value of counter right before  $d > $ dividend. However, the runtime for this approach is linear, and so the solution won\\'t submit be accepted with a `Time Limit Exceeded` message.\\n\\nBut wait... if we can\\'t use multiplication or division to solve this problem, how can we achieve better than linear runtime (linear in the size of divisor that is)?\\n\\n#### The trick\\n\\nTurns out you can actually use integer multiplication and division ... as long as you realize that [bitwise shifting](https://stackoverflow.com/questions/3312853/how-does-bitshifting-work-in-java]) by 1 left or right is identically integer multiplication or division by 2 respectively and consequently accept that bitwise shifting is indeed allowed as part of the solution\\n\\n*Note:* I actually kind of just lied; bitwise operations only behave as I just described for `int` values $\\\\geq 0$, so well work around this by making both the dividend and that divisor positive and applying the proper sign at the end.\\n\\nNow, there are a couple of different directions we can go once we embrace the power of division by two. The solution I\\'ve chosen to role with here is simply long division... you know the long division that you learned in elementary school but don\\'t remember any more... just done in base two. Apparently this has a name, and it\\'s called binary division. If you can\\'t be bothered to remember/figure out exactly how it works, which is totally fair IMO, then the pseudo code is illustrated reasonably clearly [here](https://en.wikipedia.org/wiki/Division_algorithm#Integer_division_(unsigned)_with_remainder).\\n\\n### Why couldn\\'t they have restrained the dividend range by one more?\\n\\nI don\\'t want to spend a lot of time here, but there are some annoying and subtle problems that come with allowing the dividend to be `Int.MIN_VALUE` for example:\\n\\n``` java\\n    Math.abs(Integer.MIN_VALUE) = Integer.MIN_VALUE\\n```\\n\\nThus you need to be really careful dealing with this edge case, and I jerry-rigged my code so that I dealt with the consequences as I found them. It would have been so much nicer if LeetCode had just instead had the minimum allowed value be `Integer.MIN_VALUE + 1`\\n\\n### Runtime\\n\\nIts $O(log_2N)$ where $N$ is the size of the dividend: There only as many iterations as the number of bits in $N$. Note that in practice, we are restricting the inputs ot type `int`, which means that there is a maximum size of $N$, so in that sense the runtime is actually constant. I\\'m tired so someone else can come up with a better way to say this.\\n\\n### Ramblings\\n\\n- If you squint at the solution, you might be able to argue that binary long division is essentially\"binary-searching\" for the answer... but I think that\\'s a stretch.\\n\\n- Again, feel free to yell at me about the ways the code could be clearer... Looking back over it, it definitely doesn\\'t read easy.\\n\\n### Code\\n\\n``` java\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        \\n        //Edge cases:\\n        // min integer value breaks things...\\n        boolean minValFlag = false;\\n        if(dividend == Integer.MIN_VALUE) {\\n            if(divisor == -1) return Integer.MAX_VALUE;\\n            else if(divisor == 1) return Integer.MIN_VALUE;\\n            // do the first iteration of binary division manually below\\n            else minValFlag = true;\\n        }\\n        if(divisor == Integer.MIN_VALUE) return minValFlag ? 1 : 0;\\n        \\n        //Determine the sign of the result (we know at this point neither is 0)\\n        boolean isNegative = dividend < 0 ^ divisor < 0;\\n        \\n        //make both dividend and divisor positive\\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n        \\n        //find the number of significant bits in the dividend\\n        int n = 1, dvdn = 1;\\n        while(dvdn < dividend && dvdn != Integer.MIN_VALUE) {\\n            dvdn <<=1;\\n            n++;\\n        }\\n        \\n        //Approach: do long division in binary\\n        int quotient = 0, remainder = 0;\\n        \\n        //deal with min-value annoyance\\n        if(minValFlag) {\\n            n = 31;\\n            remainder = 1;\\n        }\\n        \\n        for(n-- ; n >= 0; n--) {\\n            remainder <<= 1;\\n            remainder += (dividend >> n ) & 1;\\n            if(remainder >= divisor || remainder == Integer.MIN_VALUE) {\\n                remainder -= divisor;\\n                quotient += 1 << n;\\n            }\\n            //System.out.println(String.format(\"n is: %d %nremainder is: %d %nquotient is: %d %n\",n,remainder,quotient));\\n        }\\n        \\n        //return statement\\n        return isNegative ? 0 - quotient : quotient;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java\\n    Math.abs(Integer.MIN_VALUE) = Integer.MIN_VALUE\\n```\n``` java\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        \\n        //Edge cases:\\n        // min integer value breaks things...\\n        boolean minValFlag = false;\\n        if(dividend == Integer.MIN_VALUE) {\\n            if(divisor == -1) return Integer.MAX_VALUE;\\n            else if(divisor == 1) return Integer.MIN_VALUE;\\n            // do the first iteration of binary division manually below\\n            else minValFlag = true;\\n        }\\n        if(divisor == Integer.MIN_VALUE) return minValFlag ? 1 : 0;\\n        \\n        //Determine the sign of the result (we know at this point neither is 0)\\n        boolean isNegative = dividend < 0 ^ divisor < 0;\\n        \\n        //make both dividend and divisor positive\\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n        \\n        //find the number of significant bits in the dividend\\n        int n = 1, dvdn = 1;\\n        while(dvdn < dividend && dvdn != Integer.MIN_VALUE) {\\n            dvdn <<=1;\\n            n++;\\n        }\\n        \\n        //Approach: do long division in binary\\n        int quotient = 0, remainder = 0;\\n        \\n        //deal with min-value annoyance\\n        if(minValFlag) {\\n            n = 31;\\n            remainder = 1;\\n        }\\n        \\n        for(n-- ; n >= 0; n--) {\\n            remainder <<= 1;\\n            remainder += (dividend >> n ) & 1;\\n            if(remainder >= divisor || remainder == Integer.MIN_VALUE) {\\n                remainder -= divisor;\\n                quotient += 1 << n;\\n            }\\n            //System.out.println(String.format(\"n is: %d %nremainder is: %d %nquotient is: %d %n\",n,remainder,quotient));\\n        }\\n        \\n        //return statement\\n        return isNegative ? 0 - quotient : quotient;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 240862,
                "title": "c-solution-without-using-long-clear-fast",
                "content": "```cpp\\ntypedef numeric_limits<int> lim;\\n\\nint divide(int A, int B) {\\n    if (B == 0) return lim::max();\\n    // Check A and B for lim::min() before applying abs() to avoid overflow.\\n    if (B == lim::min()) return A == lim::min() ? 1 : 0;\\n    int quotient = 0;\\n    if (A == lim::min()) {\\n        // quotient is int thus cannot carry -lim::min() 1s,\\n        // so take special care when abs(B) == 1.\\n        if (B == -1) return lim::max();\\n        if (B == 1) return lim::min();\\n        // Add one B to A to avoid overflow.\\n        A += abs(B);\\n        quotient = 1;\\n    }\\n    bool positive = (A >= 0) == (B > 0);\\n    A = abs(A);\\n    B = abs(B);\\n    while (A >= B) {\\n        int quotient_ = 1;\\n        int B_ = B;\\n        while (A >= (B_ << 1) && (B_ << 1) > 0) {\\n            quotient_ <<= 1;\\n            B_ <<= 1;\\n        }\\n        A -= B_;\\n        quotient += quotient_;\\n    }\\n    return positive ? quotient : -quotient;\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\ntypedef numeric_limits<int> lim;\\n\\nint divide(int A, int B) {\\n    if (B == 0) return lim::max();\\n    // Check A and B for lim::min() before applying abs() to avoid overflow.\\n    if (B == lim::min()) return A == lim::min() ? 1 : 0;\\n    int quotient = 0;\\n    if (A == lim::min()) {\\n        // quotient is int thus cannot carry -lim::min() 1s,\\n        // so take special care when abs(B) == 1.\\n        if (B == -1) return lim::max();\\n        if (B == 1) return lim::min();\\n        // Add one B to A to avoid overflow.\\n        A += abs(B);\\n        quotient = 1;\\n    }\\n    bool positive = (A >= 0) == (B > 0);\\n    A = abs(A);\\n    B = abs(B);\\n    while (A >= B) {\\n        int quotient_ = 1;\\n        int B_ = B;\\n        while (A >= (B_ << 1) && (B_ << 1) > 0) {\\n            quotient_ <<= 1;\\n            B_ <<= 1;\\n        }\\n        A -= B_;\\n        quotient += quotient_;\\n    }\\n    return positive ? quotient : -quotient;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3357353,
                "title": "beats-100-java-runtime-1ms",
                "content": "# Code\\n```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if (divisor == 0) {\\n            return 0;\\n        }\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) {\\n            return Integer.MAX_VALUE;\\n        }\\n        int quotient = 0;\\n        boolean negative = (dividend < 0) != (divisor < 0);\\n        long longDividend = Math.abs((long) dividend);\\n        long longDivisor = Math.abs((long) divisor);\\n        while (longDividend >= longDivisor) {\\n            int shift = 0;\\n            while (longDividend >= (longDivisor << shift)) {\\n                shift++;\\n            }\\n            shift--;\\n            longDividend -= longDivisor << shift;\\n            quotient += 1 << shift;\\n        }\\n        return negative ? -quotient : quotient;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if (divisor == 0) {\\n            return 0;\\n        }\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) {\\n            return Integer.MAX_VALUE;\\n        }\\n        int quotient = 0;\\n        boolean negative = (dividend < 0) != (divisor < 0);\\n        long longDividend = Math.abs((long) dividend);\\n        long longDivisor = Math.abs((long) divisor);\\n        while (longDividend >= longDivisor) {\\n            int shift = 0;\\n            while (longDividend >= (longDivisor << shift)) {\\n                shift++;\\n            }\\n            shift--;\\n            longDividend -= longDivisor << shift;\\n            quotient += 1 << shift;\\n        }\\n        return negative ? -quotient : quotient;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130236,
                "title": "best-2-lines-of-code-in-java-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend==(-2147483648) && divisor==(-1)) return 2147483647;\\n        return dividend/divisor;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend==(-2147483648) && divisor==(-1)) return 2147483647;\\n        return dividend/divisor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2563104,
                "title": "c-bit-manuplation-easy-and-fast",
                "content": "**please upvote if it\\'s helpful**\\n```\\n\\tint divide(int dividend, int divisor) {\\n        if(dividend == divisor)\\n            return 1;\\n        bool isPositive = (dividend<0 == divisor<0);    // if both are of same sign, answer is positive\\n        unsigned int a = abs(dividend);\\n        unsigned int b = abs(divisor);\\n        unsigned int ans = 0;\\n        while(a >= b){  // while dividend is greater than or equal to divisor\\n            short q = 0;\\n            while(a > (b<<(q+1)))\\n                q++;\\n            ans += (1<<q);  // add the power of 2 found to the answer\\n            a = a - (b<<q);  // reduce the dividend by divisor * power of 2 found\\n        }\\n        if(ans == (1<<31) and isPositive)   // if ans cannot be stored in signed int\\n            return INT_MAX;\\n        return isPositive ? ans : -ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\tint divide(int dividend, int divisor) {\\n        if(dividend == divisor)\\n            return 1;\\n        bool isPositive = (dividend<0 == divisor<0);    // if both are of same sign, answer is positive\\n        unsigned int a = abs(dividend);\\n        unsigned int b = abs(divisor);\\n        unsigned int ans = 0;\\n        while(a >= b){  // while dividend is greater than or equal to divisor\\n            short q = 0;\\n            while(a > (b<<(q+1)))\\n                q++;\\n            ans += (1<<q);  // add the power of 2 found to the answer\\n            a = a - (b<<q);  // reduce the dividend by divisor * power of 2 found\\n        }\\n        if(ans == (1<<31) and isPositive)   // if ans cannot be stored in signed int\\n            return INT_MAX;\\n        return isPositive ? ans : -ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1400899,
                "title": "c-2-approaches-explained-brute-to-better-accepted-4ms",
                "content": "There are various approaches for this problem, two of them here I have discussed below :\\n\\n# Approach 1\\nThe first approach which comes to our mid is : **Repeated Subtraction**.\\nAll we need to do in this approach is keep subtracting divisor from dividend until dividend becomes less than divisor. The number of times we subtract will be our quotient and what\\'s left in dividend will be the remainder.\\n\\nExample: if dividend = 33 and divisor = 6, then we do\\n33 - 6 = 27\\n27 - 6 = 21\\n21 - 6 = 15\\n15 - 6 = 9\\n9 - 6 = 3\\nnow 3<6 , so we stop here and hence our remainder is 3 and no, of times we subtracted is 5 = quotient.\\n\\nFor this approach,\\n\\n```\\nint divide(int dividend, int divisor) {\\n \\n // if any one of them is negative then quotient will be negative else positive\\n  int sign = ((dividend < 0) ^ (divisor < 0)) ? -1 : 1; \\n \\n  // Update both divisor and\\n  // dividend positive\\n  dividend = abs(dividend);\\n  divisor = abs(divisor);\\n \\n  // Initialize the quotient\\n  int quotient = 0;\\n  while (dividend >= divisor) {\\n    dividend -= divisor;\\n    ++quotient;\\n  }\\n  //if the sign value computed earlier is -1 then negate the value of quotient\\n  if(sign==-1) quotient=-quotient;\\n   \\n  return quotient;\\n}\\n```\\n\\n**Time Complexity** : O(dividend) [consider case when dividend=n and divisor=1]\\n\\nNow we\\'ll try to optimize this time complexity.\\n\\n# Approach 2\\n\\nThe second approach includes **BIT MANIPULATION**.\\n\\nconsider the same example as above , dividend=33 and divisor=6\\n\\nhere we try to increase our divisor until it attains maximum value less than or equal to dividend, i.e.\\n\\n6 < 33\\n6 + 6 = 12 < 33\\n6 + 6 + 6 = 18 < 33\\n6 + 6 + 6 + 6 = 24 < 33\\n6 + 6 + 6 + 6 + 6 = 30 < 33\\n6 + 6 + 6 + 6 + 6 + 6 = 36 > 33 -----------------> stop here\\n\\nthus, max value of divisor can be 30 which is 5 times 6, hence quotient is 5.\\nnow instead of repeatedly adding this (which is same as in case of previous approach), we\\'ll use bit manipulation to do it more efficiently.\\n\\nwe iterate from i= 31 to 0 and try to find (divisor * (2^i)) if it is less than our dividend, we store it in a var, update our quotient and do the same. like in this example where dividend = 33 and divisor = 6\\n\\nintial t=0 (here we\\'ll be storing the current updated divisor), q=0 (quotient)\\nwe\\'ll be checking if t + (divisor * (2^i) <= dividend, if it is true we\\'ll do \\nt = t + (divisor * (2^i)) and q = q + (2^i)\\n\\ni = 31 : 0 + (6 * 2^31) > 33\\ni = 30 : 0 + (6 * 2^30) > 33\\n...\\n...\\n...\\n...\\ni = 3 : 0 + (6 * 2^3) = (6 * 8) = 48 > 33\\ni = 2 : 0 + (6 * 2^2) = (6 * 4) = **24 < 33** => t= 0 + 24 = 24  and  q = 0 + (2^2) = 4\\ni = 1 : 24 + (6 * 2^1) = 24 + 12 = 36 > 33\\ni = 0 : 24 + (6 * 2^0) = 24 + 6 = **30 < 33** => t = 24 + 6 = 30  and q = 4 + (2^0) = 5 \\n\\nnow we\\'ll put appropriate sign in front of q (if any one of divisor or dividend negative the negative else positive), then if q lies in range of int ,we return q else we return INT_MAX.\\n\\n**BIT Manipulation PART :**\\nsince , we aren\\'t allowed to use multiplication operator , thus we can calculate\\n\\ndivisor * (2^i)  as (divisor<<i) as left shift by i means same as multiplyin the number by (2^i)\\n\\n**CODE :**\\n\\n```\\nint divide(int dividend, int divisor) {\\n        \\n        long long t=0, q=0, n=labs(dividend), m=labs(divisor);\\n\\t\\t\\n\\t\\t//here we find the sign of the quotient, if both dividend and divisor\\n\\t\\t//have same sign then sign will be +1 else -1\\n        int sign = (dividend<0) ^ (divisor<0) ? -1 : 1;\\n        \\n        for(long long i=31;i>=0;i--)\\n        {\\n\\t\\t\\t//(m<<i) = m * (2^i)\\n            if(t + (m<<i) <= n)\\n            {\\n                t += (m<<i);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//since 2^i here can be large for int so we typecast it in long long to prevent overflow \\n                q += (1LL<<i);\\n            }\\n        }\\n        \\n        if(sign<0) q=-q;\\n        \\n\\t\\t//if q goes out of bound, we return INT_MAX.\\n        return ((q>INT_MAX) or (q<INT_MIN)) ? INT_MAX : q;\\n        \\n        \\n    }\\n```\\n\\n**Time Complexity :** O( log(dividend) )",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint divide(int dividend, int divisor) {\\n \\n // if any one of them is negative then quotient will be negative else positive\\n  int sign = ((dividend < 0) ^ (divisor < 0)) ? -1 : 1; \\n \\n  // Update both divisor and\\n  // dividend positive\\n  dividend = abs(dividend);\\n  divisor = abs(divisor);\\n \\n  // Initialize the quotient\\n  int quotient = 0;\\n  while (dividend >= divisor) {\\n    dividend -= divisor;\\n    ++quotient;\\n  }\\n  //if the sign value computed earlier is -1 then negate the value of quotient\\n  if(sign==-1) quotient=-quotient;\\n   \\n  return quotient;\\n}\\n```\n```\\nint divide(int dividend, int divisor) {\\n        \\n        long long t=0, q=0, n=labs(dividend), m=labs(divisor);\\n\\t\\t\\n\\t\\t//here we find the sign of the quotient, if both dividend and divisor\\n\\t\\t//have same sign then sign will be +1 else -1\\n        int sign = (dividend<0) ^ (divisor<0) ? -1 : 1;\\n        \\n        for(long long i=31;i>=0;i--)\\n        {\\n\\t\\t\\t//(m<<i) = m * (2^i)\\n            if(t + (m<<i) <= n)\\n            {\\n                t += (m<<i);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//since 2^i here can be large for int so we typecast it in long long to prevent overflow \\n                q += (1LL<<i);\\n            }\\n        }\\n        \\n        if(sign<0) q=-q;\\n        \\n\\t\\t//if q goes out of bound, we return INT_MAX.\\n        return ((q>INT_MAX) or (q<INT_MIN)) ? INT_MAX : q;\\n        \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1286238,
                "title": "0ms-java-solution-complies-to-all-conditions",
                "content": "If you are furiously looking for answers as i was, let me shed some light. I had to spend a lots of time to understand the secret behind the solutions to this problem. \\n\\nFirst of all, As we all know already the basic idea for solving the problem with out the mod operator is simply **identifying the number of times the divisor can fully SUBSTRACT the dividend as a whole** but iterations are so costly and it will not work for large numbers. The obvious secret is to identify **effective way to reduce the number of substractions**\\n\\nThe following is simply my idea but there can be many as well, \\n\\n**1. Exponensly increase the divisor until before it surpass the dividend then substract with it.\\n2. Add up the divisor until reduced\\n3. Repeat the same until it brings to 0**\\n\\nFor an example, 116 divided by 3, Following is the way to gradually reduce the possibilities and idendify the final quotient\\n\\n![image](https://assets.leetcode.com/users/images/31c9c3ac-8bd5-437a-a976-ad74d369e0f0_1624215160.6451015.png)\\n\\nLets start with 3, then double it which is 6 then 12, 24,..until we stop at 96 because 192 can be substracted. So here 96 == 3 * 2^5 ==  3 << 5 and quotient = 32, remainder = 20\\n\\nLet start the same process again with 20, it can go upto which gets to 12 == 3 * 2^2 == 3 << 2 then the quotient is now 32 + 4 = 36, reminder = 8\\n\\nLets start over again, i can go upto 6 which is again 6 == 3 * 2^1 == 3 << 1 the quotient is not 36+2 = 38, remainder = 2 which is less than divisor so we can not continue with the cycle and all ends here.\\n\\nHowever multiplication is not allowed to use let see what else we can do for replacing it. \\n\\n**Programmatic Rule:**\\nLeft Shift (<<) shall be considered as multiplication by 2^N\\nSimilarly, Right Shift (>>) shall be considered as division by 2^N \\n\\nSince the environment only allows to accomodate `integer`  data type, overflow cases are the corner cases.\\n\\nLets dive into the code,\\n\\n```java\\nclass Solution {\\n     public int divide(int dividend, int divisor) {\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE; //Cornor case when -2^31 is divided by -1 will give 2^31 which doesnt exist so overflow \\n         \\n        boolean negative = dividend < 0 ^ divisor < 0; //Logical XOR will help in deciding if the results is negative only if any one of them is negative\\n        \\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n        int quotient = 0, subQuot = 0;\\n        \\n        while (dividend - divisor >= 0) {\\n            for (subQuot = 0; dividend - (divisor << subQuot << 1) >= 0; subQuot++);\\n            quotient += 1 << subQuot; //Add to the quotient\\n            dividend -= divisor << subQuot; //Substract from dividend to start over with the remaining\\n        }\\n        return negative ? -quotient : quotient;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n     public int divide(int dividend, int divisor) {\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE; //Cornor case when -2^31 is divided by -1 will give 2^31 which doesnt exist so overflow \\n         \\n        boolean negative = dividend < 0 ^ divisor < 0; //Logical XOR will help in deciding if the results is negative only if any one of them is negative\\n        \\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n        int quotient = 0, subQuot = 0;\\n        \\n        while (dividend - divisor >= 0) {\\n            for (subQuot = 0; dividend - (divisor << subQuot << 1) >= 0; subQuot++);\\n            quotient += 1 << subQuot; //Add to the quotient\\n            dividend -= divisor << subQuot; //Substract from dividend to start over with the remaining\\n        }\\n        return negative ? -quotient : quotient;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356127,
                "title": "small-c-program-logic-range",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint divide(long long int dividend, long long int divisor){\\n    if (dividend / divisor > pow(2,31) - 1)\\n    {\\n        return(pow(2,31) - 1);\\n    }\\n    else\\n     {\\n        return (dividend / divisor);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint divide(long long int dividend, long long int divisor){\\n    if (dividend / divisor > pow(2,31) - 1)\\n    {\\n        return(pow(2,31) - 1);\\n    }\\n    else\\n     {\\n        return (dividend / divisor);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2750712,
                "title": "java-faster-solution-runtime-2-ms-faster-than-81-21-of-java-online-submissions",
                "content": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        int sign,result=0,value=31;\\n\\t\\tif ((dividend > 0 && divisor > 0) || (dividend < 0 && divisor < 0)) sign = 1;  else sign = -1;\\n\\t\\tlong ldividend = Math.abs((long) dividend);\\n\\t\\tlong ldivisor = Math.abs((long) divisor);\\n\\t\\twhile (ldividend >= ldivisor) {\\n\\t\\t\\twhile (ldividend < ldivisor << value) {\\n\\t\\t\\t\\tvalue--;\\n\\t\\t\\t}\\n\\t\\t\\tldividend -= ldivisor << value;\\n\\t\\t\\tresult += 1 << value;\\n\\t\\t}\\n\\t\\tif (result > Integer.MAX_VALUE) result = Integer.MAX_VALUE;\\n\\t\\tif(dividend==Integer.MIN_VALUE && divisor==-1) result=Integer.MAX_VALUE;\\n        result= sign > 0 ? result : -result; return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        int sign,result=0,value=31;\\n\\t\\tif ((dividend > 0 && divisor > 0) || (dividend < 0 && divisor < 0)) sign = 1;  else sign = -1;\\n\\t\\tlong ldividend = Math.abs((long) dividend);\\n\\t\\tlong ldivisor = Math.abs((long) divisor);\\n\\t\\twhile (ldividend >= ldivisor) {\\n\\t\\t\\twhile (ldividend < ldivisor << value) {\\n\\t\\t\\t\\tvalue--;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2089333,
                "title": "c-short-easy-explanation-w-comments",
                "content": "**Please upvote if you like it :)**\\n\\nUsing **long long** instead of **int** or **long** to avoid overflow.`\\n\\n***Code w/ Bit Manipulation:***\\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\t\\n\\t\\t// corner cases\\n        if (dividend == INT_MIN && divisor == -1 ) return INT_MAX;\\n        if (dividend == INT_MIN && divisor == 1 ) return INT_MIN;\\n\\t\\t\\n\\t\\t// initialization\\n        long long ans = 0, sign = dividend > 0 == divisor > 0 ? 1 : -1;\\n        if (divisor == -INT_MAX) return dividend == divisor;\\n        if (dividend == -INT_MAX)\\n            if (divisor == 1) return -INT_MAX;\\n        else if (divisor == -1) return INT_MAX;\\n        else dividend += abs(divisor), ans++;\\n        long long numerator = abs(dividend), denominator = abs(divisor);\\n        for (int i = 0; numerator >= denominator; i = 0) {\\n            while (numerator >> i >= denominator) i++;\\n            numerator -= denominator << i - 1, ans += 1 << i - 1;\\n        }\\n        return sign < 0 ? -ans : ans; \\n    }\\n};\\n```\\n**Time Complexity : O(LogN^2)\\nSpace Complexity : O(N)**\\n\\n***Code w/ Logarithms:***\\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) { \\n        long long ans = 0; \\n        if ((long long)divisor== -INT_MAX) return dividend == divisor; \\n\\t\\t\\n\\t\\t//corner cases\\n        if ((long long)dividend == -INT_MAX) \\n            if ((long long)divisor == 1) return -INT_MAX; \\n            else if ((long long)divisor == -1) return INT_MAX; \\n\\t\\t\\t\\n\\t\\t\\t//update ans variable\\n            else dividend += abs((long long)divisor), ans++; \\n        ans += floor(exp(log(abs((long long)dividend)) - log(abs((long long)divisor)))); // exp(x) = e^x\\n        return dividend > 0 == divisor > 0 ? ans : -ans; \\n    }\\n};\\n```\\n**Time Complexity : O(LogN)\\nSpace Complexity : O(N)**",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\t\\n\\t\\t// corner cases\\n        if (dividend == INT_MIN && divisor == -1 ) return INT_MAX;\\n        if (dividend == INT_MIN && divisor == 1 ) return INT_MIN;\\n\\t\\t\\n\\t\\t// initialization\\n        long long ans = 0, sign = dividend > 0 == divisor > 0 ? 1 : -1;\\n        if (divisor == -INT_MAX) return dividend == divisor;\\n        if (dividend == -INT_MAX)\\n            if (divisor == 1) return -INT_MAX;\\n        else if (divisor == -1) return INT_MAX;\\n        else dividend += abs(divisor), ans++;\\n        long long numerator = abs(dividend), denominator = abs(divisor);\\n        for (int i = 0; numerator >= denominator; i = 0) {\\n            while (numerator >> i >= denominator) i++;\\n            numerator -= denominator << i - 1, ans += 1 << i - 1;\\n        }\\n        return sign < 0 ? -ans : ans; \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) { \\n        long long ans = 0; \\n        if ((long long)divisor== -INT_MAX) return dividend == divisor; \\n\\t\\t\\n\\t\\t//corner cases\\n        if ((long long)dividend == -INT_MAX) \\n            if ((long long)divisor == 1) return -INT_MAX; \\n            else if ((long long)divisor == -1) return INT_MAX; \\n\\t\\t\\t\\n\\t\\t\\t//update ans variable\\n            else dividend += abs((long long)divisor), ans++; \\n        ans += floor(exp(log(abs((long long)dividend)) - log(abs((long long)divisor)))); // exp(x) = e^x\\n        return dividend > 0 == divisor > 0 ? ans : -ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1898053,
                "title": "a-c-solution-using-bitwise-shift",
                "content": "To simplify the logic, assume dividend and divisor are positive. The main idea is making a loop to keep minusing divisor. But this way will lead to time limit exceeded when occuring a large dividend and a small divisor. So, let\\'s change the strategy. Before minusing divisor, we can make divisor as close dividend as possible but still lower than dividend. Then, we can greedily minus a large divisor in time complexity O(log(n)). And making this large divisor can be done by bitwise left-shift.\\n\\n```c++\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\t\\n\\t    // If dividend is zero, return zero directly.\\n        if (dividend == 0) {\\n            return 0;\\n        }\\n\\t\\t\\n\\t\\t// To let our strategy to work, we should handle the case if divisor is INT_MIN.\\n        if (divisor == INT_MIN) {\\n            return dividend == INT_MIN ? 1 : 0;\\n        }\\n        \\n\\t\\t// Use exclusive or to check the sign of answer.\\n        bool is_pos = (dividend > 0) ^ (divisor < 0);\\n        int ans = 0;\\n        \\n\\t\\t// Here is different from the description above.\\n\\t\\t// In practice, we force our dividend to be negative.\\n\\t\\t// Because the range of negative values (2^31) is larger than the range of positive values (2^31 - 1).\\n\\t\\t// If we force dividend to be positive, there may be integer overflow.\\n        if (dividend > 0) {\\n            dividend = 0 - dividend;\\n        }\\n        \\n\\t\\t// Divisor should be positive.\\n\\t\\t// Because we will apply bitwise shift to it.\\n\\t\\t// And we have handled the case when divisor is INT_MIN.\\n        if (divisor < 0) {\\n            divisor = 0 - divisor;\\n        }\\n        \\n\\t\\t// To compare negative dividend and positive divisor, we need to add negative sign to divisor.\\n        while (dividend <= -divisor) {\\n            int tmp = divisor;\\n            int step = 1;\\n            \\n\\t\\t\\t// \"tmp < 0x40000000\" is a trick. 0x40000000 is 2^30.\\n\\t\\t\\t// If we don\\'t limit the upper bound, tmp may keep shifting and lead an integer overflow.\\n            while (tmp < 0x40000000 && -tmp > dividend) {\\n                tmp <<= 1;\\n                step <<= 1;\\n            }\\n            \\n\\t\\t\\t// Here we find the largest divisor.\\n            if (-tmp < dividend) {\\n                tmp >>= 1;\\n                step >>= 1;\\n            }\\n            \\n            dividend += tmp;\\n\\t\\t\\t\\n\\t\\t\\t// Another trick is that using minus instead of using add.\\n\\t\\t\\t// The same reason as above: the range of negative values is larger than the range of positive values.\\n            ans -= step;\\n        }\\n        \\n        if (!is_pos) {\\n            return ans;\\n        } else {\\n            return ans == INT_MIN ? INT_MAX : -ans;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\t\\n\\t    // If dividend is zero, return zero directly.\\n        if (dividend == 0) {\\n            return 0;\\n        }\\n\\t\\t\\n\\t\\t// To let our strategy to work, we should handle the case if divisor is INT_MIN.\\n        if (divisor == INT_MIN) {\\n            return dividend == INT_MIN ? 1 : 0;\\n        }\\n        \\n\\t\\t// Use exclusive or to check the sign of answer.\\n        bool is_pos = (dividend > 0) ^ (divisor < 0);\\n        int ans = 0;\\n        \\n\\t\\t// Here is different from the description above.\\n\\t\\t// In practice, we force our dividend to be negative.\\n\\t\\t// Because the range of negative values (2^31) is larger than the range of positive values (2^31 - 1).\\n\\t\\t// If we force dividend to be positive, there may be integer overflow.\\n        if (dividend > 0) {\\n            dividend = 0 - dividend;\\n        }\\n        \\n\\t\\t// Divisor should be positive.\\n\\t\\t// Because we will apply bitwise shift to it.\\n\\t\\t// And we have handled the case when divisor is INT_MIN.\\n        if (divisor < 0) {\\n            divisor = 0 - divisor;\\n        }\\n        \\n\\t\\t// To compare negative dividend and positive divisor, we need to add negative sign to divisor.\\n        while (dividend <= -divisor) {\\n            int tmp = divisor;\\n            int step = 1;\\n            \\n\\t\\t\\t// \"tmp < 0x40000000\" is a trick. 0x40000000 is 2^30.\\n\\t\\t\\t// If we don\\'t limit the upper bound, tmp may keep shifting and lead an integer overflow.\\n            while (tmp < 0x40000000 && -tmp > dividend) {\\n                tmp <<= 1;\\n                step <<= 1;\\n            }\\n            \\n\\t\\t\\t// Here we find the largest divisor.\\n            if (-tmp < dividend) {\\n                tmp >>= 1;\\n                step >>= 1;\\n            }\\n            \\n            dividend += tmp;\\n\\t\\t\\t\\n\\t\\t\\t// Another trick is that using minus instead of using add.\\n\\t\\t\\t// The same reason as above: the range of negative values is larger than the range of positive values.\\n            ans -= step;\\n        }\\n        \\n        if (!is_pos) {\\n            return ans;\\n        } else {\\n            return ans == INT_MIN ? INT_MAX : -ans;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 914066,
                "title": "3-approach-for-your-interview-prep-o-dividend-o-1-o-logn",
                "content": "\\n<h4> <strong>Approach  1: Brute force (repetitve deduction) [ O(dividend) ] </strong> </h4><br>\\n\\n**step1:**  if a,b is like any one the below case, \\n{-ve, +ve}, or { `-a/b` }  ->set the sign flag\\n{+ve, -ve}   or  { ` a/-b` } ->set the sign flag\\n\\n**step2:** handle the overflow result at first\\n\\n**step3:** repetitive deduction logic\\n\\n**step4:** if any of them(divisor,dividend) is negative, \\nthen to match the result, we have to make the result negative \\n```\\nvar divide = function(a, b) {\\n    \\n\\t// step1\\n    let flag=0\\n    if(a<0){ if(b>0) flag = 1 }\\n    else if(b<0) flag = 1\\n    \\n\\t\\n\\t\\n\\t// step2\\n    if( a == -2147483648 && b == -1)  return 2147483647\\n    \\n\\t\\n\\t\\n    // step3 \\n    let res=0\\n    b = Math.abs(b)\\n    a = Math.abs(a)\\n    \\n    while (a >= b) {\\n      a -= b;\\n      res++;\\n    }\\n\\t\\n\\t\\n\\t\\n\\t// step4\\n    if (flag == 1 ) return (res*-1) // res = (-res)\\n    else return res\\n    \\n};\\n\\n```\\n<hr><hr><br><br> <br>\\n<h4> <strong>Approach  2: using log properties [ O(1) ] </strong> </h4>\\n\\n**step1:**  if a,b is like any one the below case, \\n{-ve, +ve}, or { `-a/b` }  ->set the sign flag\\n{+ve, -ve}   or  { ` a/-b` } ->set the sign flag\\n\\n**step2:** handle the overflow result at first\\n\\n**step3:** using formula: \\n```\\na/b = result\\nlog(a/b) = log(result)\\nlog(a)-log(b) = log(result)\\nexp(log(a) - log(b)) = result\\n```\\n**step4:** if any of them(divisor,dividend) is negative, \\nthen to match the result, we have to make the result negative \\n<br> <br> <hr><hr>\\n```\\nvar divide = function(a, b) {\\n    \\n\\t// step1\\n    let flag=0\\n    if(a<0){ if(b>0) flag = 1 }\\n    else if(b<0) flag = 1\\n\\n      \\n\\t  \\n\\t\\n\\t\\n\\t// step2 : overflow error handling\\n    if( a == -2147483648 && b == -1)  return 2147483647\\n    \\n\\t\\n\\t\\n\\t\\n\\t//step3\\n    let ans = Math.exp(   Math.log(Math.abs(a))  -  Math.log(Math.abs(b))    )\\n    ans = Math.floor(ans)\\n    \\n\\t\\n\\t\\n\\t// step4\\n    if (flag == 1 ) return (ans*-1) // ans = (-ans)\\n    else return ans\\n    \\n};\\n```\\n<hr><hr><br><br> <br>\\n<h4> <strong>Approach  3: Double the divisor everytime, and decrease it from dividend [ O(Logn) ] </strong> </h4>\\n\\n**step1:**  handle overflow cases\\n**step2:**  handle negative cases\\n**step3:**  \\nExample : dividend = 10, divisor = 3\\n```\\n 10      10                  10\\n- 3    -3x2              -3x2x2\\n---     ---               ------\\n\\n  7       4      (dvsr>dvd) exit\\n  \\nso, here twice we operated\\n\\n\\n\\n\\n 4                       4\\n-3                    -3x2\\n---                  -----\\n1            (dvsr>dvd) exit\\n\\nso here once we operated\\n\\n\\n\\n\\n\\n\\nso, twice+once= 3\\nso result is 3.\\n\\n```\\n\\n\\n\\n<br><br><br>\\n\\n```\\n\\n\\n\\n\\nvar divide = function(dividend, divisor) {\\n    \\n\\n\\n\\t // step 1 \\n     let INT_MAX =(2**31)-1, INT_MIN = -(2**31) \\n     if(dividend==INT_MIN && divisor==-1) return INT_MAX\\n     if(dividend==INT_MIN && divisor== 1) return INT_MIN\\n      \\n\\n\\t let double = 0, count = 0, res = 0\\n\\n\\n\\n\\n\\n\\t // step 2\\n     let sign = dividend<0 ^ divisor<0     \\n     dividend = Math.abs(dividend)\\n     divisor = Math.abs(divisor)\\n        \\n\\n\\n\\n\\n\\n     // step 3\\n     while (divisor <= dividend) {\\n        let double = divisor, count = 1\\n\\n        while( (double*2) <= dividend) {\\n            double = double*2\\n            count  = count*2\\n        }\\n\\n        res = res + count \\n        dividend = dividend - double\\n    }\\n\\n    return sign ? -res : res\\n};\\n    \\n\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nvar divide = function(a, b) {\\n    \\n\\t// step1\\n    let flag=0\\n    if(a<0){ if(b>0) flag = 1 }\\n    else if(b<0) flag = 1\\n    \\n\\t\\n\\t\\n\\t// step2\\n    if( a == -2147483648 && b == -1)  return 2147483647\\n    \\n\\t\\n\\t\\n    // step3 \\n    let res=0\\n    b = Math.abs(b)\\n    a = Math.abs(a)\\n    \\n    while (a >= b) {\\n      a -= b;\\n      res++;\\n    }\\n\\t\\n\\t\\n\\t\\n\\t// step4\\n    if (flag == 1 ) return (res*-1) // res = (-res)\\n    else return res\\n    \\n};\\n\\n```\n```\\na/b = result\\nlog(a/b) = log(result)\\nlog(a)-log(b) = log(result)\\nexp(log(a) - log(b)) = result\\n```\n```\\nvar divide = function(a, b) {\\n    \\n\\t// step1\\n    let flag=0\\n    if(a<0){ if(b>0) flag = 1 }\\n    else if(b<0) flag = 1\\n\\n      \\n\\t  \\n\\t\\n\\t\\n\\t// step2 : overflow error handling\\n    if( a == -2147483648 && b == -1)  return 2147483647\\n    \\n\\t\\n\\t\\n\\t\\n\\t//step3\\n    let ans = Math.exp(   Math.log(Math.abs(a))  -  Math.log(Math.abs(b))    )\\n    ans = Math.floor(ans)\\n    \\n\\t\\n\\t\\n\\t// step4\\n    if (flag == 1 ) return (ans*-1) // ans = (-ans)\\n    else return ans\\n    \\n};\\n```\n```\\n 10      10                  10\\n- 3    -3x2              -3x2x2\\n---     ---               ------\\n\\n  7       4      (dvsr>dvd) exit\\n  \\nso, here twice we operated\\n\\n\\n\\n\\n 4                       4\\n-3                    -3x2\\n---                  -----\\n1            (dvsr>dvd) exit\\n\\nso here once we operated\\n\\n\\n\\n\\n\\n\\nso, twice+once= 3\\nso result is 3.\\n\\n```\n```\\n\\n\\n\\n\\nvar divide = function(dividend, divisor) {\\n    \\n\\n\\n\\t // step 1 \\n     let INT_MAX =(2**31)-1, INT_MIN = -(2**31) \\n     if(dividend==INT_MIN && divisor==-1) return INT_MAX\\n     if(dividend==INT_MIN && divisor== 1) return INT_MIN\\n      \\n\\n\\t let double = 0, count = 0, res = 0\\n\\n\\n\\n\\n\\n\\t // step 2\\n     let sign = dividend<0 ^ divisor<0     \\n     dividend = Math.abs(dividend)\\n     divisor = Math.abs(divisor)\\n        \\n\\n\\n\\n\\n\\n     // step 3\\n     while (divisor <= dividend) {\\n        let double = divisor, count = 1\\n\\n        while( (double*2) <= dividend) {\\n            double = double*2\\n            count  = count*2\\n        }\\n\\n        res = res + count \\n        dividend = dividend - double\\n    }\\n\\n    return sign ? -res : res\\n};\\n    \\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 186952,
                "title": "notes-on-solution-not-using-long-bit-shifting-etc-for-realistic-interview",
                "content": "At this point I'm sure most solutions are well understood. Without simply posting yet another ever so slightly different solution, I want to discuss a few points where some have discussed in comments, but may not be easily found; as well as giving those who don't have as many real interview experiences some ideas about what companies may prefer. \n\nFirst of all, this question is all about the limitation and constraints. For these type of questions, there may be cheesy ways to make it easier, but in a real interview, you shouldn't bank on it being allowed. For this very question it is specified the system can only handle Integers, thus **using Long should be out of the question.** If it's not clearly stated, you can always ask, just don't assume. We see it ain't too hard without long by turning numbers negative as many solutions have.\n\nSecondly, a straight forward adding solution may return wrong answers due to overflow during adding. A better way would be to use bit shifting, but unless you started interview solution on this direction initially (which can be weird tbh unless you do bits a lot), **it is easy to add a condition check to make sure that new sum isn't overflowing by seeing if it switched signs**. Though I find this slightly hacky from coding perspective because the purpose isn't obvious from code.\n\nIt is a good chance to discuss with interviewer what's preferred. For example, another cheap way is to define a value that's half of Max or Min (for using negatives), and use that as a loop guard to be more explicit. The constraint of not allowing multiplication and division is obviously for avoiding direct solutions, but we should always be able to hardcode a value if necessary. \n\nThough for this question, **some interviewer may be looking specifically for bit shifting operations** cuz it can be better or \"leet\", in which case communication is the most important to find out. I'd argue for code readability above all else.\n\nLast but not least, when discussing edge cases, it's important to not blast thru it without thought. For things like dividing by 0, if it wasn't explicitely stated to be impossible by the question, **It should be handled as an Exception**. Same for MIN_VALUE divide by -1 as well. \n\nPeople never throw catch exceptions on Leetcode but it's a great talking point in interviews. They may follow up and say for now assume it won't happen, or return a specific value to represent error for simplicity. If the interviewer said that, it's fine, but you should never come up with that yourself, that's bad code, confusing and can be factually incorrect. Of course, Leetcode make these explicit so people don't rage over unclear requirements, but it's good to think about. If an exception is to be thrown, it's also good to discuss with interviewer about whose responsibility it should be for handling it. This method, or the caller. \n\nI will attach my solution for reference, but nothing special. Recursive, no long or bit shifting though. \n\n```\n    public int divide(int dividend, int divisor) {\n        // Handle edge cases\n        if (dividend == 0) {\n            return 0;\n        } else if (dividend == Integer.MIN_VALUE && divisor == -1) {\n            return Integer.MAX_VALUE; \n        } \n        \n        // Get sign and switch to negative\n        boolean positive = true; \n        if (dividend > 0) {\n            dividend = -dividend;\n            positive = !positive;\n        }\n        \n        if (divisor > 0) {\n            divisor = -divisor;\n            positive = !positive;\n        }\n        \n        int res = helper(dividend, divisor);\n        return positive ? res : -res;\n    }\n    \n    public int helper(int dividend, int divisor) {\n        if (dividend > divisor) {\n            return 0;\n        } \n        \n        int multiple = divisor;\n        int count = 1;\n        while (multiple + multiple > dividend && multiple + multiple < 0) {\n            count += count;\n            multiple += multiple; \n        }\n        \n        int leftOver = dividend - multiple; \n        \n        int res = count + helper(leftOver, divisor);\n        \n        return res;\n    }\n```\n\nAnd a quick reminder on throwing exceptions - if others should handle it, simply modify method signature to be \n```\n    public int divide(int dividend, int divisor) throws Exception {\n        if (divisor == 0) {\n            throw new Exception(\"plz no\"); // Can make or use a more meaningful Exception class \n        } \n        ...\n```\n\nIf you were to handle it yourself, but have to return a value for the time. Then it's pointless unless printing a message or calling a log would suffice \n```\n    public int divide(int dividend, int divisor) {\n        try {\n            ...\n        } catch (Exception e) {\n            System.out.println(e.getMessage()); // or call some log / method to make this meaningful\n            return Integer.MAX_VALUE; // or w.e defined value to resolve this so caller can move on\n        } \n```\n\nI know this isn't the standard solution for leetcode discussion. But I hope it will help some newer people out there. Cheers. ",
                "solutionTags": [],
                "code": "```\n    public int divide(int dividend, int divisor) {\n        // Handle edge cases\n        if (dividend == 0) {\n            return 0;\n        } else if (dividend == Integer.MIN_VALUE && divisor == -1) {\n            return Integer.MAX_VALUE; \n        } \n        \n        // Get sign and switch to negative\n        boolean positive = true; \n        if (dividend > 0) {\n            dividend = -dividend;\n            positive = !positive;\n        }\n        \n        if (divisor > 0) {\n            divisor = -divisor;\n            positive = !positive;\n        }\n        \n        int res = helper(dividend, divisor);\n        return positive ? res : -res;\n    }\n    \n    public int helper(int dividend, int divisor) {\n        if (dividend > divisor) {\n            return 0;\n        } \n        \n        int multiple = divisor;\n        int count = 1;\n        while (multiple + multiple > dividend && multiple + multiple < 0) {\n            count += count;\n            multiple += multiple; \n        }\n        \n        int leftOver = dividend - multiple; \n        \n        int res = count + helper(leftOver, divisor);\n        \n        return res;\n    }\n```\n```\n    public int divide(int dividend, int divisor) throws Exception {\n        if (divisor == 0) {\n            throw new Exception(\"plz no\"); // Can make or use a more meaningful Exception class \n        } \n        ...\n```\n```\n    public int divide(int dividend, int divisor) {\n        try {\n            ...\n        } catch (Exception e) {\n            System.out.println(e.getMessage()); // or call some log / method to make this meaningful\n            return Integer.MAX_VALUE; // or w.e defined value to resolve this so caller can move on\n        } \n```",
                "codeTag": "Java"
            },
            {
                "id": 13573,
                "title": "wrong-answer-input-2147483648-1-output-2147483648-expected-2147483647",
                "content": "\\n\\n{\\n\\nclass Solution:\\n    # @return an integer\\n    def divide(self, dividend, divisor):\\n        \\n        if dividend == 0:\\n            return 0\\n            \\n        sign = 1 if(dividend <0 and divisor <0) or (dividend >0 and divisor >0) else -1\\n        dividend = abs(dividend)\\n        divisor = abs(divisor)\\n        \\n        ans = 0\\n        \\n        while dividend >= divisor:\\n            shift = 0\\n            while ((divisor << shift) <= dividend):\\n                shift +=1\\n            \\n            ans += 1<<(shift-1)\\n            dividend -= divisor<<(shift-1)\\n            \\n        return ans if (sign==1) else -ans\\n}\\n\\n{\\nSubmission Result: \\nWrong Answer  Input:\\t-2147483648, -1 \\nOutput:\\t2147483648 \\nExpected:\\t2147483647\\n}\\n\\nI think my output is correct instead of the expected answer, but my code cannot be accepted. I think it should be some overflow problem. Could someone tell me how can I make this problem? Thanks!",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    # @return an integer\\n    def divide(self, dividend, divisor):\\n        \\n        if dividend == 0:\\n            return 0\\n            \\n        sign = 1 if(dividend <0 and divisor <0) or (dividend >0 and divisor >0) else -1\\n        dividend = abs(dividend)\\n        divisor = abs(divisor)\\n        \\n        ans = 0\\n        \\n        while dividend >= divisor:\\n            shift = 0\\n            while ((divisor << shift) <= dividend):\\n                shift +=1\\n            \\n            ans += 1<<(shift-1)\\n            dividend -= divisor<<(shift-1)\\n            \\n        return ans if (sign==1) else -ans\\n}",
                "codeTag": "Java"
            },
            {
                "id": 3849831,
                "title": "c-solution-with-explanation-bit-manipulation-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing the Bit Manipulation concept\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTry to represent the dividend in terms of power of 2 using divisor.\\nex1 -> `43/8 = 8*5 + 3 => 8(pow(2,2)+pow(2,0))+1`\\nex2 -> `7/3 = 3*2 + 1 => 3(pow(2,0))+1`\\n\\n1. Store the sign bit and make the dividend and divisor positive as it is difficult to work on the negative numbers \\n2. Now starting from the highest power of 2 if any multiple of (divisor * pow(2,i)) is less than dividend we add it to temp and store that power of 2 in ans. \\n3. Boundary condition are if (dividend is Minimum value and divisor is -1 then it led to bufferoverflow) and if (dividend is minimum and divisor is 1 than return the minimum value)\\n# Complexity\\n- Time complexity:O(31) ~ O(1)      \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        long long a = (long long) dividend, b = (long long)divisor;\\n        if (a == INT_MIN and b == -1) return INT_MAX;\\n        if (a == INT_MIN and b == 1) return INT_MIN;\\n        bool flg = (a > 0) == (b > 0) ? true : false;\\n        a = abs(a);\\n        b = abs(b);\\n        long long ans =0, temp = 0;\\n        for (int i = 31 ; i >= 0 ; i--){\\n            if (temp + ( b << i ) <= a){\\n                temp+= (b<<i);\\n                ans+= (1<<i);\\n            }\\n        }\\n        if (!flg) ans = -ans;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        long long a = (long long) dividend, b = (long long)divisor;\\n        if (a == INT_MIN and b == -1) return INT_MAX;\\n        if (a == INT_MIN and b == 1) return INT_MIN;\\n        bool flg = (a > 0) == (b > 0) ? true : false;\\n        a = abs(a);\\n        b = abs(b);\\n        long long ans =0, temp = 0;\\n        for (int i = 31 ; i >= 0 ; i--){\\n            if (temp + ( b << i ) <= a){\\n                temp+= (b<<i);\\n                ans+= (1<<i);\\n            }\\n        }\\n        if (!flg) ans = -ans;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219166,
                "title": "easy-and-fast-python-solution-with-explanation-and-example",
                "content": "**Approach**\\n1. Get sign \\n\\t```\\n\\tsign = 1\\n\\tif (dividend > 0 and divisor < 0) or (dividend < 0 and divisor > 0): sign = -1\\n\\t```\\n2. Till divisor exceeds dividend:\\n\\t- Get nearest multiple of 2 greater than dividend.\\n\\t- Once get the multiple, do right shift and get the multiple of 2 less than dividend.\\n\\t- Add quotient to result and update dividend.\\n\\t```\\n\\tresult = 0\\n\\tdividend = abs(dividend)\\n\\tdivisor = abs(divisor)\\n\\tmax_int = 2 ** 31 - 1\\n\\n\\twhile dividend >= divisor:\\n\\t\\ttemp = divisor\\n\\t\\tquotient = 1\\n\\t\\twhile temp <= dividend:\\n\\t\\t\\ttemp <<= 1\\n\\t\\t\\tquotient <<= 1\\n\\t\\tresult += quotient >> 1\\n\\t\\tdividend -= temp >> 1\\n\\t```\\n3. Return result based on sign.\\n\\t```\\n\\t# edge_case\\n\\tif result > max_int:\\n\\t\\tif sign == -1 and divisor == 1: return ~max_int\\n\\t\\telse: return max_int\\n\\n\\t# If sign is -1, take 1\\'s compliment of result and add 1 to get negative value\\n\\treturn ~(result) + 1 if sign == -1 else result\\n\\t```\\n\\n**Example**\\n- Lets say, dividend = 48 and divisor = 5. So its quotient should be 9 with remainder as 3.\\n- With first step sign will be 1.\\n- Here\\'s the second step:\\n![image](https://assets.leetcode.com/users/images/6504b41f-6bd5-47d1-804c-df87376c5f61_1656606768.27768.jpeg)\\n\\n- Will simply return result since sign is 1.\\n\\n\\n**Complete Solution**\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        sign = 1\\n        if (dividend > 0 and divisor < 0) or (dividend < 0 and divisor > 0): sign = -1\\n        \\n        result = 0\\n        dividend = abs(dividend)\\n        divisor = abs(divisor)\\n        max_int = 2 ** 31 - 1\\n        \\n        while dividend >= divisor:\\n            temp = divisor\\n            quotient = 1\\n            while temp <= dividend:\\n                temp <<= 1\\n                quotient <<= 1\\n            result += quotient >> 1\\n            dividend -= temp >> 1\\n        \\n        if result > max_int:\\n            if sign == -1 and divisor == 1: return ~max_int\\n            else: return max_int\\n        \\n        return ~(result) + 1 if sign == -1 else result\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\tsign = 1\\n\\tif (dividend > 0 and divisor < 0) or (dividend < 0 and divisor > 0): sign = -1\\n\\t```\n```\\n\\tresult = 0\\n\\tdividend = abs(dividend)\\n\\tdivisor = abs(divisor)\\n\\tmax_int = 2 ** 31 - 1\\n\\n\\twhile dividend >= divisor:\\n\\t\\ttemp = divisor\\n\\t\\tquotient = 1\\n\\t\\twhile temp <= dividend:\\n\\t\\t\\ttemp <<= 1\\n\\t\\t\\tquotient <<= 1\\n\\t\\tresult += quotient >> 1\\n\\t\\tdividend -= temp >> 1\\n\\t```\n```\\n\\t# edge_case\\n\\tif result > max_int:\\n\\t\\tif sign == -1 and divisor == 1: return ~max_int\\n\\t\\telse: return max_int\\n\\n\\t# If sign is -1, take 1\\'s compliment of result and add 1 to get negative value\\n\\treturn ~(result) + 1 if sign == -1 else result\\n\\t```\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        sign = 1\\n        if (dividend > 0 and divisor < 0) or (dividend < 0 and divisor > 0): sign = -1\\n        \\n        result = 0\\n        dividend = abs(dividend)\\n        divisor = abs(divisor)\\n        max_int = 2 ** 31 - 1\\n        \\n        while dividend >= divisor:\\n            temp = divisor\\n            quotient = 1\\n            while temp <= dividend:\\n                temp <<= 1\\n                quotient <<= 1\\n            result += quotient >> 1\\n            dividend -= temp >> 1\\n        \\n        if result > max_int:\\n            if sign == -1 and divisor == 1: return ~max_int\\n            else: return max_int\\n        \\n        return ~(result) + 1 if sign == -1 else result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2091540,
                "title": "c-bit-manipulation-easy",
                "content": "```\\nThe key observation is that the quotient of a division is just the number of times that we can subtract the divisor from the dividend without making\\nit negative.\\n\\nSuppose dividend = 15 and divisor = 3, 15 - 3 > 0. We now try to subtract more by shifting 3 to the left by 1 bit (6). Since 15 - 6 > 0, shift 6 again to 12.\\nNow 15 - 12 > 0, shift 12 again to 24, which is larger than 15. So we can at most subtract 12 from 15. Since 12 is obtained by shifting 3 to left twice,\\nit is 1 << 2 = 4 times of 3. We add 4 to an answer variable (initialized to be 0). The above process is like 15 = 3 * 4 + 3. We now get part of the \\nquotient (4), with a remaining dividend 3.\\n\\nThen we repeat the above process by subtracting divisor = 3 from the remaining dividend = 3 and obtain 0. We are done. In this case, no shift happens.\\nWe simply add 1 << 0 = 1 to the answer variable.\\n\\nThis is the full algorithm to perform division using bit manipulations. The sign also needs to be taken into consideration. And we still need to handle \\none overflow case: dividend = INT_MIN and divisor = -1.\\n\\n\\nclass Solution {\\npublic:\\n\\tint divide(int dividend, int divisor) {\\n         if (dividend == INT_MIN && divisor == -1) return INT_MAX;\\n\\t\\tlong a = labs(dividend), b = labs(divisor), ans = 0;\\n        long sign = dividend<0 ^ divisor<0? -1 : 1;\\n\\t\\twhile (a >= b) {\\n\\t\\t\\tlong temp = b, m = 1;\\n\\t\\t\\twhile (temp << 1 <= a) {\\n\\t\\t\\t\\ttemp <<= 1;\\n\\t\\t\\t\\tm <<= 1;\\n\\t\\t\\t}\\n\\t\\t\\ta -= temp;\\n\\t\\t\\tans += m;\\n\\t\\t}\\n\\t\\treturn sign *ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nThe key observation is that the quotient of a division is just the number of times that we can subtract the divisor from the dividend without making\\nit negative.\\n\\nSuppose dividend = 15 and divisor = 3, 15 - 3 > 0. We now try to subtract more by shifting 3 to the left by 1 bit (6). Since 15 - 6 > 0, shift 6 again to 12.\\nNow 15 - 12 > 0, shift 12 again to 24, which is larger than 15. So we can at most subtract 12 from 15. Since 12 is obtained by shifting 3 to left twice,\\nit is 1 << 2 = 4 times of 3. We add 4 to an answer variable (initialized to be 0). The above process is like 15 = 3 * 4 + 3. We now get part of the \\nquotient (4), with a remaining dividend 3.\\n\\nThen we repeat the above process by subtracting divisor = 3 from the remaining dividend = 3 and obtain 0. We are done. In this case, no shift happens.\\nWe simply add 1 << 0 = 1 to the answer variable.\\n\\nThis is the full algorithm to perform division using bit manipulations. The sign also needs to be taken into consideration. And we still need to handle \\none overflow case: dividend = INT_MIN and divisor = -1.\\n\\n\\nclass Solution {\\npublic:\\n\\tint divide(int dividend, int divisor) {\\n         if (dividend == INT_MIN && divisor == -1) return INT_MAX;\\n\\t\\tlong a = labs(dividend), b = labs(divisor), ans = 0;\\n        long sign = dividend<0 ^ divisor<0? -1 : 1;\\n\\t\\twhile (a >= b) {\\n\\t\\t\\tlong temp = b, m = 1;\\n\\t\\t\\twhile (temp << 1 <= a) {\\n\\t\\t\\t\\ttemp <<= 1;\\n\\t\\t\\t\\tm <<= 1;\\n\\t\\t\\t}\\n\\t\\t\\ta -= temp;\\n\\t\\t\\tans += m;\\n\\t\\t}\\n\\t\\treturn sign *ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2091148,
                "title": "java-solution-1ms-bit-manipulation",
                "content": "```\\nclass Solution {\\n       public static int divide(int dividend, int divisor) {\\n        if (Integer.MIN_VALUE == dividend && divisor == -1)\\n            return Integer.MAX_VALUE;\\n        int ans = 0;\\n        int a = Math.abs(dividend);\\n        int b = Math.abs(divisor);\\n        while (a - b >= 0) {\\n            int temp = b;\\n            int count = 1;\\n            while (a - (temp << 1) >= 0) {\\n                temp <<= 1;\\n                count <<= 1;\\n            }\\n            a -= temp;\\n            ans += count;\\n        }\\n        return (dividend > 0) == (divisor > 0) ? ans : -ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n       public static int divide(int dividend, int divisor) {\\n        if (Integer.MIN_VALUE == dividend && divisor == -1)\\n            return Integer.MAX_VALUE;\\n        int ans = 0;\\n        int a = Math.abs(dividend);\\n        int b = Math.abs(divisor);\\n        while (a - b >= 0) {\\n            int temp = b;\\n            int count = 1;\\n            while (a - (temp << 1) >= 0) {\\n                temp <<= 1;\\n                count <<= 1;\\n            }\\n            a -= temp;\\n            ans += count;\\n        }\\n        return (dividend > 0) == (divisor > 0) ? ans : -ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089759,
                "title": "easy-c-sol-time-o-logn-2-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n     \\n        if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n        \\n        if(dividend == divisor){\\n            return 1;\\n        }\\n        \\n        bool flag = (dividend >= 0) == (divisor>=0)?true:false;\\n        \\n       unsigned int dividnd = abs(dividend);\\n       unsigned int divsor = abs(divisor);\\n        \\n        unsigned int res = 0;\\n        \\n        while(dividnd >= divsor){\\n            \\n            short cnt=0;\\n            \\n            while(dividnd > (divsor << cnt+1)){\\n                cnt++;\\n            }\\n            res += 1 << cnt;\\n            dividnd -= divsor<<cnt;\\n        }\\n        \\n        return flag?res: - res;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n     \\n        if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 979719,
                "title": "js-bitwise-division",
                "content": "```\\nvar divide = function (dividend, divisor) {\\n    var rem = Math.abs(dividend);\\n    var div = Math.abs(divisor);\\n    var quo = 0;\\n    // subtract divisor bit by bit, starting from most significant bit\\n    for (var b = 31; b >= 0; b--) {\\n        if ((rem >>> b) >= div) {\\n            quo |= 1 << b;\\n            rem -= div << b;\\n        }\\n    }\\n    quo >>>= 0; // make unsigned\\n    if (dividend > 0 !== divisor > 0) quo = -quo; // add sign\\n    return quo > -0x80000000 ? quo < 0x7FFFFFFF ? quo : 0x7FFFFFFF : -0x80000000; // check bounds\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar divide = function (dividend, divisor) {\\n    var rem = Math.abs(dividend);\\n    var div = Math.abs(divisor);\\n    var quo = 0;\\n    // subtract divisor bit by bit, starting from most significant bit\\n    for (var b = 31; b >= 0; b--) {\\n        if ((rem >>> b) >= div) {\\n            quo |= 1 << b;\\n            rem -= div << b;\\n        }\\n    }\\n    quo >>>= 0; // make unsigned\\n    if (dividend > 0 !== divisor > 0) quo = -quo; // add sign\\n    return quo > -0x80000000 ? quo < 0x7FFFFFFF ? quo : 0x7FFFFFFF : -0x80000000; // check bounds\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 709731,
                "title": "java-very-slow-but-simple",
                "content": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        \\n        // stupid edge case\\n        if (divisor == -1 && dividend == Integer.MIN_VALUE)\\n            return Integer.MAX_VALUE;\\n        \\n        int cnt = 0;\\n        int a = Math.abs(dividend), b = Math.abs(divisor);\\n        \\n        while (a - b >= 0) {\\n            cnt++;\\n            a -= b;\\n        }\\n        \\n        return (dividend >= 0 && divisor >= 0) || (dividend <= 0 && divisor <= 0) ? cnt : -cnt;   \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        \\n        // stupid edge case\\n        if (divisor == -1 && dividend == Integer.MIN_VALUE)\\n            return Integer.MAX_VALUE;\\n        \\n        int cnt = 0;\\n        int a = Math.abs(dividend), b = Math.abs(divisor);\\n        \\n        while (a - b >= 0) {\\n            cnt++;\\n            a -= b;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 472298,
                "title": "short-python-3-only-and-logical-operators-took-20-40-ms",
                "content": "Many solutions avoid mul/div by left/right shifting operators. I don\\'t believe it\\'s cheating, because these are different operators, and because these solutions are not easier than the ones using only +-. It\\'s just absolutely unnecessary, because it\\'s enough to double value simply using a += a which is also faster than a >>= 1 in python.\\n(Abs technically also uses only logical operators and -.)\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        if dividend == 0 or divisor == 1: #not necessary but makes things simpler\\n            return dividend\\n        if dividend == -2**31 and divisor == -1: #accurately deal with overflow\\n            return 2**31-1\\n        neg = (dividend < 0) ^ (divisor < 0)\\n        dividend = abs(dividend)\\n        divisor = abs(divisor)\\n        endres = 0\\n        while dividend >= divisor:\\n\\t\\t   #At each iteration subtract the largest possible divisor*r=divisor*(2**k)\\n            resm = divisor\\n            r = 1\\n            while resm + resm < dividend:\\n                r += r\\n                resm += resm\\n            dividend -= resm\\n            endres += r\\n        return 0 - endres if neg else endres\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        if dividend == 0 or divisor == 1: #not necessary but makes things simpler\\n            return dividend\\n        if dividend == -2**31 and divisor == -1: #accurately deal with overflow\\n            return 2**31-1\\n        neg = (dividend < 0) ^ (divisor < 0)\\n        dividend = abs(dividend)\\n        divisor = abs(divisor)\\n        endres = 0\\n        while dividend >= divisor:\\n\\t\\t   #At each iteration subtract the largest possible divisor*r=divisor*(2**k)\\n            resm = divisor\\n            r = 1\\n            while resm + resm < dividend:\\n                r += r\\n                resm += resm\\n            dividend -= resm\\n            endres += r\\n        return 0 - endres if neg else endres\\n```",
                "codeTag": "Java"
            },
            {
                "id": 383218,
                "title": "easy-peasy-python-bit-solution-with-example",
                "content": "\\tdef divide(self, dividend: int, divisor: int) -> int:\\n        if dividend == -2147483648 and divisor == -1:\\n            return 2147483647\\n        if divisor == 1:\\n            return dividend\\n        negative = (dividend < 0) ^ (divisor < 0)\\n        dvd = abs(dividend)\\n        dvs = abs(divisor)\\n        res = 0\\n\\n        while dvd >= dvs:\\n            tmp = dvs\\n            m = 1\\n            while (tmp << 1) <= dvd:\\n                tmp <<= 1\\n                m <<= 1  # I am doubling m\\n            dvd -= tmp\\n            res += m\\n            \\n        if not negative:\\n            return res\\n        else:\\n            return ~res + 1\\n\\t\\t\\t\\n\\t\\n\\t# example, \\n\\tlet dividend = 23\\n\\tdivisor = 2\\n\\t\\n\\tso basically in each for loop I am finding the max number which is multiple of divisor \\n\\tif num = 23, then 16 is the max that I can reach by doubling divisor each time\\n\\tso remaning is 23 - 16 = 7\\n\\tNow, 4 is the max that I can reach by doubling 2 and still be less than 7\\n\\tremaining = 7 - 4 = 3\\n\\tand so on untill my divisor is not greater than dividend",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "\\tdef divide(self, dividend: int, divisor: int) -> int:\\n        if dividend == -2147483648 and divisor == -1:\\n            return 2147483647\\n        if divisor == 1:\\n            return dividend\\n        negative = (dividend < 0) ^ (divisor < 0)\\n        dvd = abs(dividend)\\n        dvs = abs(divisor)\\n        res = 0\\n\\n        while dvd >= dvs:\\n            tmp = dvs\\n            m = 1\\n            while (tmp << 1) <= dvd:\\n                tmp <<= 1\\n                m <<= 1  # I am doubling m\\n            dvd -= tmp\\n            res += m\\n            \\n        if not negative:\\n            return res\\n        else:\\n            return ~res + 1\\n\\t\\t\\t\\n\\t\\n\\t# example, \\n\\tlet dividend = 23\\n\\tdivisor = 2\\n\\t\\n\\tso basically in each for loop I am finding the max number which is multiple of divisor \\n\\tif num = 23, then 16 is the max that I can reach by doubling divisor each time\\n\\tso remaning is 23 - 16 = 7\\n\\tNow, 4 is the max that I can reach by doubling 2 and still be less than 7\\n\\tremaining = 7 - 4 = 3\\n\\tand so on untill my divisor is not greater than dividend",
                "codeTag": "Python3"
            },
            {
                "id": 2425683,
                "title": "using-repeated-exponential-searches-approach-c",
                "content": "Implementation\\n\\n**Using Repeated exponential searches approach\\nTime Complexity = O(logN * logN), we can store the internal while loop generated number and power of two into an array as well, but it was will cause us O(logN) space complexity as well.\\nSpace Complexity = O(1)**\\n\\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        \\n        // special case\\n        // bcz, if dividend is INT_MIN = -2147483648, and divisor is -1, and if we are converting into positive (2147483648), it will overflow the int value, so in this case we need to return the INT_MAX value which is 2147483647\\n        if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n        \\n        int HALF_INT_MIN = -1073741824;\\n        int countNegativeNumber = 2;\\n        \\n        // converting into negative to avoid int overflow\\n        if(dividend > 0){\\n            countNegativeNumber--;\\n            dividend = -dividend;\\n        }\\n        \\n        if(divisor > 0){\\n            countNegativeNumber--;\\n            divisor = -divisor;\\n        }\\n        \\n        int quotientResult = 0;\\n        while(dividend <= divisor){\\n            \\n            int value = divisor;\\n            int powerOfTwo = -1;\\n            \\n            // check HALF_INT_MIN as well bcz of the int overflow issue\\n            while(value >= HALF_INT_MIN && value+value >= dividend){\\n                value += value;\\n                powerOfTwo += powerOfTwo;\\n            }\\n            \\n            dividend -= value;\\n            quotientResult += powerOfTwo;\\n        }\\n        \\n        if(countNegativeNumber != 1){\\n            return -quotientResult;\\n        }\\n        \\n        return quotientResult;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        \\n        // special case\\n        // bcz, if dividend is INT_MIN = -2147483648, and divisor is -1, and if we are converting into positive (2147483648), it will overflow the int value, so in this case we need to return the INT_MAX value which is 2147483647\\n        if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n        \\n        int HALF_INT_MIN = -1073741824;\\n        int countNegativeNumber = 2;\\n        \\n        // converting into negative to avoid int overflow\\n        if(dividend > 0){\\n            countNegativeNumber--;\\n            dividend = -dividend;\\n        }\\n        \\n        if(divisor > 0){\\n            countNegativeNumber--;\\n            divisor = -divisor;\\n        }\\n        \\n        int quotientResult = 0;\\n        while(dividend <= divisor){\\n            \\n            int value = divisor;\\n            int powerOfTwo = -1;\\n            \\n            // check HALF_INT_MIN as well bcz of the int overflow issue\\n            while(value >= HALF_INT_MIN && value+value >= dividend){\\n                value += value;\\n                powerOfTwo += powerOfTwo;\\n            }\\n            \\n            dividend -= value;\\n            quotientResult += powerOfTwo;\\n        }\\n        \\n        if(countNegativeNumber != 1){\\n            return -quotientResult;\\n        }\\n        \\n        return quotientResult;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2194697,
                "title": "python-bit-manipulation",
                "content": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        is_negative = (dividend < 0) != (divisor < 0)\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        sum = divisor\\n        quo=0\\n        while sum<=dividend:\\n            q2=1\\n            while (sum<<1) <=dividend:\\n                sum<<=1\\n                q2<<=1\\n            dividend -= sum\\n            sum = divisor\\n            quo += q2\\n        return min(2147483647, max(-quo if is_negative else quo, -2147483648))   \\n```\\n***Pls upvote if you find it helpful.***",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        is_negative = (dividend < 0) != (divisor < 0)\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        sum = divisor\\n        quo=0\\n        while sum<=dividend:\\n            q2=1\\n            while (sum<<1) <=dividend:\\n                sum<<=1\\n                q2<<=1\\n            dividend -= sum\\n            sum = divisor\\n            quo += q2\\n        return min(2147483647, max(-quo if is_negative else quo, -2147483648))   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1889305,
                "title": "python-solution-faster-than-92",
                "content": "```\\n\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int):\\n        sign = 1 if (dividend > 0) == (divisor > 0) else -1\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        res = 0\\n        while dividend >= divisor:\\n            temp, i = divisor, 1\\n            while dividend >= temp:\\n                dividend -= temp\\n                res += i\\n                i <<= 1\\n                temp <<= 1\\n\\n        if sign < 0:\\n            res = -res\\n\\n        return min(max(-2147483648, res), 2147483647)\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int):\\n        sign = 1 if (dividend > 0) == (divisor > 0) else -1\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        res = 0\\n        while dividend >= divisor:\\n            temp, i = divisor, 1\\n            while dividend >= temp:\\n                dividend -= temp\\n                res += i\\n                i <<= 1\\n                temp <<= 1\\n\\n        if sign < 0:\\n            res = -res\\n\\n        return min(max(-2147483648, res), 2147483647)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318451,
                "title": "solution-explanation-not-just-code",
                "content": "Let\\'s assume, \\na = dividend and b = divisor\\n\\nwe can write a/b as, a/b = q  or a = b*q\\n\\nNow, any number can be expressed as a unique sum of some powers of 2\\nFor example, 7 = 2^0 + 2^1 + 2^2 and 11 = 2^0 + 2^1 + 2^3\\n\\nLet\\'s assume,\\nq = 2^p_1 + 2^p_2 + 2^p_3 + ... + 2^p_n\\n \\nNow,\\na = b * (2^p_1 + 2^p_2 + 2^p_3 + ... + 2^p_n)\\nor\\na = (b * 2^p_1) + (b * 2^p_2) +  (b * 2^p_3) + ... + (b * 2^p_n)\\n\\nWe need to calculate these terms without using any sort of multiplication or division or modulo\\n\\nThe key to the solution is the \\'<<\\' operator or the left shift operator\\nx = x << 1 is equivalent to multiplying x with 2\\n\\nConsider this code,\\n```\\nint b_value = b;\\nwhile( b_value <= a )\\n{\\n\\tb_value = b_value << 1;\\n}\\n```\\n\\nThe above for loop would calculate the following,\\nb_value = b\\nb_value = b * 2\\nb_value = b * 2^2\\nb_value = b * 2^3\\nb_value = b * 2^4 and so on.....\\n\\nBut remember q = 2^p_1 + 2^p_2 + 2^p_3 + ... + 2^p_n\\nSo we need the powers of 2\\n\\nWe can do it like this,\\n```\\nint b_value = b;\\nint q_value = 1;\\nwhile( b_value <= a )\\n{\\n\\tb_value = b_value << 1;\\n\\tq_value = q_value << 1;\\n}\\n```\\n\\nNow the for loop would calculate the following,\\nb_value = b, q_value = 1\\nb_value = b * 2, q_value = 2\\nb_value = b * 2^2, q_value = 4 or 2^2\\nb_value = b * 2^3, q_value = 8 or 2^3\\nb_value = b * 2^4, q_value = 16 or 2^4 and so on.....\\n\\nBut this for loop is just multiplying b and 1 by 2s. We need to figure out which power of 2s sum up to q.\\nTo do this we need to first collect all the b_values and q_values into two vectors,\\n```\\nint b_value = b;\\nvector<int> b_values;\\nint q_value = 1;\\nvecotr<int> q_values;\\nwhile( b_value <= a )\\n{\\n\\tb_value = b_value << 1;\\n\\tb_values.push_back(b_value);\\n\\tq_value = q_value << 1;\\n\\tq_values.push_back(q_value);\\n}\\n```\\n\\nAnother interesting fact!\\nIf we have power_of_2s = [2^0, 2^1, 2^2, ... , 2^n], we can figure out the terms that sum up to m like this (here m < 2^n+1),\\n```\\nvector<int> terms;\\nfor(int i=n-1; i>=0; i--)\\n{\\n\\tif(power_of_2s[i] <= m)\\n\\t{\\n\\t\\tterms.push_back(power_of_2s[i]);\\n\\t\\tm -= power_of_2s[];\\n\\t}\\n}\\n```\\n\\nif power_of_2s = [1, 2, 4, 8] and m = 11 the for loop proceeds like this,\\niteration 1: 8 <= 11 is true, m is changed to 3, terms = [8]\\niteration 2: 4 <= 3 is false, terms = [8]\\niteration 3: 2 <= 3 is true, m is changed to 1, terms = [8, 2]\\niteration 4: 1 <= 1 is true, m is changed to 0, terms = [8, 2, 1]\\nThe sum of the terms, 8 + 2 + 1 = 11\\n\\nNow lets see the two equations that started all this\\nq = 2^p_1 + 2^p_2 + 2^p_3 + ... + 2^p_n\\na = (b * 2^p_1) + (b * 2^p_2) +  (b * 2^p_3) + (b * 2^p_n)\\n\\nLet\\'s say we have collected the necessary b_values and q_values (see above) such that\\nq_values = [1, 2, 4, ... , 2^n]\\nb_values = [b, b * 2, b * 4, ..., b * 2^n] where a < b * 2^n+1\\nWe have to select the b_values that sum up to a\\nWhenever we select a b_value, we also select the corresponding q_value. These will sum up to q\\n```\\nvector<int> b_terms\\nvector<int> q_terms;\\nfor(int i=n-1; i>=0; i--)\\n{\\n\\tif(b_values[i] <= a)\\n\\t{\\n\\t\\tb_terms.push_back(b_values[i]);\\n\\t\\tq_terms.push_back(q_values[i]);\\n\\t\\ta -= b_values[i];\\n\\t}\\n}\\n```\\nSumming up the q_terms will get us q\\nIt can also be verified that the b_terms sum up to a\\n\\nFor a = 36 and b = 3, q_values = [1, 2, 4, 8] and b_values = [3, 6, 12, 24]\\nThe for loop proceeds like this, \\niteration 1: 24 <= 36 is true, a is changed to 12, q_terms = [8], b_terms = [24]\\niteration 2: 12 <= 12 is true, a is changed to 0, q_terms = [8, 4], b_terms = [24, 12]\\niteration 3: 4 <= 0 is false, q_terms = [8, 4], b_terms = [24, 12]\\niteration 4: 1 <= 0 is false, q_terms = [8, 4], b_terms = [24, 12]\\n\\nq = 8+4 = 12\\nand\\nb = 24+12 = 36\\n\\nHope that clears things up ^_^\\n(P.S. I omitted to discuss the overflow issues as the explanation was getting too long. The code for handling overflow can be easily understood from other user\\'s code)\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nint b_value = b;\\nwhile( b_value <= a )\\n{\\n\\tb_value = b_value << 1;\\n}\\n```\n```\\nint b_value = b;\\nint q_value = 1;\\nwhile( b_value <= a )\\n{\\n\\tb_value = b_value << 1;\\n\\tq_value = q_value << 1;\\n}\\n```\n```\\nint b_value = b;\\nvector<int> b_values;\\nint q_value = 1;\\nvecotr<int> q_values;\\nwhile( b_value <= a )\\n{\\n\\tb_value = b_value << 1;\\n\\tb_values.push_back(b_value);\\n\\tq_value = q_value << 1;\\n\\tq_values.push_back(q_value);\\n}\\n```\n```\\nvector<int> terms;\\nfor(int i=n-1; i>=0; i--)\\n{\\n\\tif(power_of_2s[i] <= m)\\n\\t{\\n\\t\\tterms.push_back(power_of_2s[i]);\\n\\t\\tm -= power_of_2s[];\\n\\t}\\n}\\n```\n```\\nvector<int> b_terms\\nvector<int> q_terms;\\nfor(int i=n-1; i>=0; i--)\\n{\\n\\tif(b_values[i] <= a)\\n\\t{\\n\\t\\tb_terms.push_back(b_values[i]);\\n\\t\\tq_terms.push_back(q_values[i]);\\n\\t\\ta -= b_values[i];\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1084794,
                "title": "divide-two-integers-java-easy-solution-w-explanation",
                "content": "In this problem we are asked two divide two integers without using multiplication, division, and mod operator.\\n\\nWe know that multiplication of M and N is nothing but addition of M, N times.\\nSimilarly, Division of M and N is nothing but subtraction of N from M as long as resulting value is positive. Here the number of subtractions made is the quotient and the last remaining positive number (including zero)  is the remainder.\\n\\nAlso, the problem wants us to limit the division result in integer range.\\nExtreme cases:\\n1. To always consider sign of the dividend and divisor. This will help in determining final sign of quotient\\n2. If dividend is Integer.MIN_VALUE and divisor is -1. Then quotient will exceed Integer.MAX_VALUE\\n\\n\\n```\\npublic int divide(int dividend, int divisor) {\\n        if(dividend == 0) {\\n            return 0;\\n        }\\n\\n        long posDivd = dividend;\\n        long posDivr = divisor;\\n        boolean divdSign = true, divrSign = true;\\n\\n        if(dividend < 0) {\\n            posDivd = -posDivd;\\n            if(posDivd < 0) {\\n                posDivd = Integer.MAX_VALUE;\\n            }\\n            divdSign = false;\\n        }\\n\\n        if(divisor < 0) {\\n            posDivr = -posDivr;\\n            if(posDivr < 0) {\\n                posDivr = Integer.MAX_VALUE;\\n            }\\n            divrSign = false;\\n        }\\n\\n        if(posDivr == 1) {\\n            if(divdSign == divrSign) {\\n                return (int) Math.min(posDivd, Integer.MAX_VALUE);\\n            } else {\\n                return (int) Math.max(-posDivd, Integer.MIN_VALUE);\\n            }\\n        }\\n\\n        long temp = posDivr;\\n        long count = 0;\\n        while(temp <= posDivd) {\\n            temp += posDivr;\\n            count++;\\n        }\\n\\n        if(divdSign == divrSign) {\\n            return (int) Math.min(count, Integer.MAX_VALUE);\\n        } else {\\n            return (int) Math.max(-count, Integer.MIN_VALUE);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int divide(int dividend, int divisor) {\\n        if(dividend == 0) {\\n            return 0;\\n        }\\n\\n        long posDivd = dividend;\\n        long posDivr = divisor;\\n        boolean divdSign = true, divrSign = true;\\n\\n        if(dividend < 0) {\\n            posDivd = -posDivd;\\n            if(posDivd < 0) {\\n                posDivd = Integer.MAX_VALUE;\\n            }\\n            divdSign = false;\\n        }\\n\\n        if(divisor < 0) {\\n            posDivr = -posDivr;\\n            if(posDivr < 0) {\\n                posDivr = Integer.MAX_VALUE;\\n            }\\n            divrSign = false;\\n        }\\n\\n        if(posDivr == 1) {\\n            if(divdSign == divrSign) {\\n                return (int) Math.min(posDivd, Integer.MAX_VALUE);\\n            } else {\\n                return (int) Math.max(-posDivd, Integer.MIN_VALUE);\\n            }\\n        }\\n\\n        long temp = posDivr;\\n        long count = 0;\\n        while(temp <= posDivd) {\\n            temp += posDivr;\\n            count++;\\n        }\\n\\n        if(divdSign == divrSign) {\\n            return (int) Math.min(count, Integer.MAX_VALUE);\\n        } else {\\n            return (int) Math.max(-count, Integer.MIN_VALUE);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 480305,
                "title": "explained-java-1ms-without-long-100",
                "content": "**LOGIC:**\\n\\n![image](https://assets.leetcode.com/users/him431/image_1579014954.png)\\n\\n\\n **For a/b,\\n  1) We check like b,2b,4b,8b ,.. max value that can be subtracted from a\\n  2) Subtract from a , add 2^x in result and continue**\\n\\n```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        \\n        //Base Cases\\n        if (divisor == 1) {\\n            return dividend;\\n        }\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) {\\n            return Integer.MAX_VALUE;\\n        }\\n        \\n        \\n        int result = 0;\\n        int a = dividend<0 ? -dividend : dividend;\\n        int b = divisor<0 ? -divisor : divisor;\\n        \\n        while(a-b>=0){\\n            int x=0;//by default start with : a-b*(2^0) = a-b\\n            while(a-(b<<x) >=0){ // a- b*(2^x) >= 0 , to get max x for this\\n                x++;\\n            }\\n            x--; // bcoz loop condition was not satisfied after last x++\\n            \\n            result += 1<<x; // count how many times b was added to itself i.e. 2^x\\n            a-= b<<x;       // subtract that max subtractable i.e. b*(2^x) from a\\n        }\\n        \\n        return (dividend >= 0) == (divisor >= 0) ? result : -result;\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        \\n        //Base Cases\\n        if (divisor == 1) {\\n            return dividend;\\n        }\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) {\\n            return Integer.MAX_VALUE;\\n        }\\n        \\n        \\n        int result = 0;\\n        int a = dividend<0 ? -dividend : dividend;\\n        int b = divisor<0 ? -divisor : divisor;\\n        \\n        while(a-b>=0){\\n            int x=0;//by default start with : a-b*(2^0) = a-b\\n            while(a-(b<<x) >=0){ // a- b*(2^x) >= 0 , to get max x for this\\n                x++;\\n            }\\n            x--; // bcoz loop condition was not satisfied after last x++\\n            \\n            result += 1<<x; // count how many times b was added to itself i.e. 2^x\\n            a-= b<<x;       // subtract that max subtractable i.e. b*(2^x) from a\\n        }\\n        \\n        return (dividend >= 0) == (divisor >= 0) ? result : -result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 448102,
                "title": "very-simple-c-solution-using-bit-shifting-using-only-32-bit-variables",
                "content": "```\\n/*\\n\\tDivision using bit manipulation without using long (constraint: use 32 bit values only)\\n    https://leetcode.com/problems/divide-two-integers/\\n*/\\nclass Solution {\\npublic:\\n    int divide(int x, int y) {\\n        unsigned int divisor = static_cast<unsigned int>(y);\\n        unsigned int dividend = static_cast<unsigned int>(x);\\n        unsigned int quotient = 0;\\n        \\n        // decide the sign\\n        bool negative = (x < 0) ^ (y < 0);\\n        if(dividend == INT_MIN  && divisor == -1)\\n            return INT_MAX;\\n        if(y < 0) \\n            divisor = -1 * divisor;\\n        if(x < 0)\\n            dividend = -1 * dividend;\\n        \\n        // We start with the largest permissible multiple for the divisor\\n        // such that the divisor is still smaller than dividend,\\n        // then we add that bit to the quotient. The dividend is updated \\n        // with dividend = dividend - divisor*multiple\\n        // Then we again find the next largest multiple that when multiplied with divisor\\n        // gives a value closer to dividend. Continue doing this till we get 0\\n        const int N_BITS = sizeof(int) * 8;\\n        \\n        // find the MSB set bit(1 indexed)\\n        int msb_pos = 0;\\n        for(int i = N_BITS - 1; i >= 0; i--) {\\n            if((1 << i) & divisor) {\\n                msb_pos = i + 1;\\n                break;\\n            }\\n        }\\n        \\n        for(int i = (N_BITS - msb_pos); i >= 0; i--) {\\n            // 2^i * divisor <= dividend\\n            if((divisor << i) <= dividend) {\\n                dividend -= divisor << i;  // dividend = dividend - divisor*2^i\\n                quotient |= 1 << i;\\n            }\\n        }\\n        \\n        // check for overflow, happens when the quotient is storing max value\\n        // which in case negative sign is not there, needs to be made +ve and that\\n        // time overflow happens, quotient = INT_MIN and nagtive = false\\n        if(quotient == numeric_limits<int>::min() && !negative)\\n            return numeric_limits<int>::max();\\n        // add the sign if required\\n        quotient = negative ? -1 * quotient: quotient;\\n\\n        return quotient; \\n      }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n\\tDivision using bit manipulation without using long (constraint: use 32 bit values only)\\n    https://leetcode.com/problems/divide-two-integers/\\n*/\\nclass Solution {\\npublic:\\n    int divide(int x, int y) {\\n        unsigned int divisor = static_cast<unsigned int>(y);\\n        unsigned int dividend = static_cast<unsigned int>(x);\\n        unsigned int quotient = 0;\\n        \\n        // decide the sign\\n        bool negative = (x < 0) ^ (y < 0);\\n        if(dividend == INT_MIN  && divisor == -1)\\n            return INT_MAX;\\n        if(y < 0) \\n            divisor = -1 * divisor;\\n        if(x < 0)\\n            dividend = -1 * dividend;\\n        \\n        // We start with the largest permissible multiple for the divisor\\n        // such that the divisor is still smaller than dividend,\\n        // then we add that bit to the quotient. The dividend is updated \\n        // with dividend = dividend - divisor*multiple\\n        // Then we again find the next largest multiple that when multiplied with divisor\\n        // gives a value closer to dividend. Continue doing this till we get 0\\n        const int N_BITS = sizeof(int) * 8;\\n        \\n        // find the MSB set bit(1 indexed)\\n        int msb_pos = 0;\\n        for(int i = N_BITS - 1; i >= 0; i--) {\\n            if((1 << i) & divisor) {\\n                msb_pos = i + 1;\\n                break;\\n            }\\n        }\\n        \\n        for(int i = (N_BITS - msb_pos); i >= 0; i--) {\\n            // 2^i * divisor <= dividend\\n            if((divisor << i) <= dividend) {\\n                dividend -= divisor << i;  // dividend = dividend - divisor*2^i\\n                quotient |= 1 << i;\\n            }\\n        }\\n        \\n        // check for overflow, happens when the quotient is storing max value\\n        // which in case negative sign is not there, needs to be made +ve and that\\n        // time overflow happens, quotient = INT_MIN and nagtive = false\\n        if(quotient == numeric_limits<int>::min() && !negative)\\n            return numeric_limits<int>::max();\\n        // add the sign if required\\n        quotient = negative ? -1 * quotient: quotient;\\n\\n        return quotient; \\n      }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13555,
                "title": "ac-python-solution",
                "content": "    MAX_INT = 0x7FFFFFFF\\n\\n    def divide(self, dividend, divisor):\\n        if divisor == 0:\\n            return self.MAX_INT\\n        if dividend == 0:\\n            return 0\\n        negative = (dividend > 0) ^ (divisor > 0)\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        ans = 0\\n        while dividend >= divisor:\\n            x = divisor\\n            i = 1\\n            while dividend >= x + x:\\n                x += x\\n                i += i\\n            dividend -= x\\n            ans += i\\n        ans = self.MAX_INT if not negative and ans > self.MAX_INT else ans\\n        return -ans if negative else ans\\n\\n\\n    # 988 / 988 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 56 ms\\n    # 85.93%",
                "solutionTags": [
                    "Python"
                ],
                "code": "    MAX_INT = 0x7FFFFFFF\\n\\n    def divide(self, dividend, divisor):\\n        if divisor == 0:\\n            return self.MAX_INT\\n        if dividend == 0:\\n            return 0\\n        negative = (dividend > 0) ^ (divisor > 0)\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        ans = 0\\n        while dividend >= divisor:\\n            x = divisor\\n            i = 1\\n            while dividend >= x + x:\\n                x += x\\n                i += i\\n            dividend -= x\\n            ans += i\\n        ans = self.MAX_INT if not negative and ans > self.MAX_INT else ans\\n        return -ans if negative else ans\\n\\n\\n    # 988 / 988 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 56 ms\\n    # 85.93%",
                "codeTag": "Python3"
            },
            {
                "id": 13605,
                "title": "15-ms-c-solution-with-explaination",
                "content": "    class Solution {\\n    public:\\n        int divide(int dividend, int divisor) {\\n            // for cases where dividend or divisor is INT_MIN, \\n            // by using a higher type, we take the whole number\\n            // else abs cannot work since its based on 2's complement\\n            // and 2's complement of n bit number is undefined if its \\n            // the min number. try taking out the 2's complement of \\n            // -8 for a 4 bit number, behaviour is undefined \\n            long a = labs(dividend);\\n            long b = labs(divisor);\\n            long sign = ((dividend < 0) ^ (divisor < 0)) ? -1 : 1;\\n            // overflow cases : denominator == 0 or dividing by a number makes the number \\n            // greater than INT_MAX\\n            if (b == 0 || dividend == INT_MIN && divisor == -1) {\\n                return INT_MAX;\\n            } else if (b == 1) {\\n                 return sign * a;\\n             }\\n            \\n            \\n            long result = 0;\\n            int i = 0;\\n            while(a >= b) {\\n                i = 0;\\n                while(a >= b<<i) {\\n                    a -= b<<i;\\n                    result += 1<<i;\\n                    i++;\\n                }\\n            }\\n            return (sign * result);\\n        }\\n    \\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int divide(int dividend, int divisor) {\\n            // for cases where dividend or divisor is INT_MIN, \\n            // by using a higher type, we take the whole number\\n            // else abs cannot work since its based on 2's complement\\n            // and 2's complement of n bit number is undefined if its \\n            // the min number. try taking out the 2's complement of \\n            // -8 for a 4 bit number, behaviour is undefined \\n            long a = labs(dividend);\\n            long b = labs(divisor);\\n            long sign = ((dividend < 0) ^ (divisor < 0)) ? -1 : 1;\\n            // overflow cases : denominator == 0 or dividing by a number makes the number \\n            // greater than INT_MAX\\n            if (b == 0 || dividend == INT_MIN && divisor == -1) {\\n                return INT_MAX;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 13631,
                "title": "difference-between-int-and-long",
                "content": "this may be so silly question, but I do not get it :\\nI found this solutions for the problem works ,\\nbut when I do not use long, it will get error, run out of time.\\nDo anyone can explain to me why. thanks a lot\\n\\n\\n\\n    public int divide(int dividend, int divisor) {\\n        boolean signA = dividend >= 0, signB = divisor > 0;\\n    \\n        long num = Math.abs((long) dividend), div = Math.abs((long) divisor), res = 0, curr = 0;\\n    // using Long division\\n        for (int idx = 31; idx >= 0; idx--) {\\n            curr <<= 1;\\n            curr |= ((num >> idx) & 1);\\n    \\n            res = res << 1;\\n            if (curr >= div) {\\n                curr -= div;\\n                res |= 1;\\n            }\\n        }\\n    \\n        if (signA ^ signB)\\n            return -(int) res;\\n        return (int) res;\\n    }\\n    }",
                "solutionTags": [],
                "code": "this may be so silly question, but I do not get it :\\nI found this solutions for the problem works ,\\nbut when I do not use long, it will get error, run out of time.\\nDo anyone can explain to me why. thanks a lot\\n\\n\\n\\n    public int divide(int dividend, int divisor) {\\n        boolean signA = dividend >= 0, signB = divisor > 0;\\n    \\n        long num = Math.abs((long) dividend), div = Math.abs((long) divisor), res = 0, curr = 0;\\n    // using Long division\\n        for (int idx = 31; idx >= 0; idx--) {\\n            curr <<= 1;\\n            curr |= ((num >> idx) & 1);\\n    \\n            res = res << 1;\\n            if (curr >= div) {\\n                curr -= div;\\n                res |= 1;\\n            }\\n        }\\n    \\n        if (signA ^ signB)\\n            return -(int) res;\\n        return (int) res;\\n    }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3795128,
                "title": "c-follow-the-rules-only-use-int-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFollow the rules, only use int + - & << operations\\n\\nIt handles edge cases like division by INT_MIN and potential overflows. The main algorithm involves repeated subtractions of B from A to calculate the quotient, accounting for signs and avoiding integer overflow. The dividend A is taken to be non-postive for the reason when A=INT_MIN, the number -INT_MAX=2^31 is not  32-bit unsigned int.\\n\\nThe implementation for integer division utilizes bit manipulation techniques. It handles edge cases and performs division using bit shifts, which is more efficient than repeated subtractions. Bit manipulation helps in efficiently doubling the divisor and finding the quotient by checking bit positions in the operands.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTry these test cases\\n```\\n-2147483648\\n2147483647\\n2147483647\\n2147483647\\n1981445587\\n1172010393\\n1100540749\\n-1090366779\\n-2147483648\\n2\\n-2147483648\\n1\\n2147483647\\n2\\n```\\n![division.png](https://assets.leetcode.com/users/images/5398d3ee-d05a-4f89-b84b-528c66ef1905_1689916104.5670538.png)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log N), where N is the absolute value of the dividend A\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code with Runtime 0 ms Beats 100%\\n```\\nclass Solution {\\npublic:\\n    int divide(int A, int B) {\\n        //Consider the edge case INT_MIN=-2^31 whose change sign is not INT\\n        if (A==INT_MIN && B==-1) \\n            return INT_MAX;\\n        if (A==INT_MIN && B==1)\\n            return INT_MIN;\\n        if (B==INT_MIN && A!=INT_MIN) return 0;\\n\\n        //Edge cases can lead to TLE\\n        if (A==B) return 1;\\n        if ( (0<=A && A<B)||(A<0 && B<A)) return 0;\\n\\n        int ch_sgn=0;\\n        if (A>0){//A!=INT_MIN\\n            A=-A;\\n            ch_sgn++;\\n        }\\n        if (B<0){//quarantee B!=INT_MIN\\n            B=-B;\\n            ch_sgn++;\\n        }\\n        int sgn=(ch_sgn&1)?1:-1;\\n        int q=0;\\n        while(-B>=A){//TLE can happen when -A/B is large if only performing A+=B\\n            int b=B;\\n            int k=0;//Performing A+=b where b=B*(2^k)<=INT_MAX\\n            while(A<=-b && b<=INT_MAX){\\n                A+=b;\\n                q+=(1<<k);\\n                if (b<(1<<30)){\\n                    b<<=1;\\n                    k++;\\n                } \\n            } \\n        }\\n        return (sgn==1)?q:-q;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\n-2147483648\\n2147483647\\n2147483647\\n2147483647\\n1981445587\\n1172010393\\n1100540749\\n-1090366779\\n-2147483648\\n2\\n-2147483648\\n1\\n2147483647\\n2\\n```\n```\\nclass Solution {\\npublic:\\n    int divide(int A, int B) {\\n        //Consider the edge case INT_MIN=-2^31 whose change sign is not INT\\n        if (A==INT_MIN && B==-1) \\n            return INT_MAX;\\n        if (A==INT_MIN && B==1)\\n            return INT_MIN;\\n        if (B==INT_MIN && A!=INT_MIN) return 0;\\n\\n        //Edge cases can lead to TLE\\n        if (A==B) return 1;\\n        if ( (0<=A && A<B)||(A<0 && B<A)) return 0;\\n\\n        int ch_sgn=0;\\n        if (A>0){//A!=INT_MIN\\n            A=-A;\\n            ch_sgn++;\\n        }\\n        if (B<0){//quarantee B!=INT_MIN\\n            B=-B;\\n            ch_sgn++;\\n        }\\n        int sgn=(ch_sgn&1)?1:-1;\\n        int q=0;\\n        while(-B>=A){//TLE can happen when -A/B is large if only performing A+=B\\n            int b=B;\\n            int k=0;//Performing A+=b where b=B*(2^k)<=INT_MAX\\n            while(A<=-b && b<=INT_MAX){\\n                A+=b;\\n                q+=(1<<k);\\n                if (b<(1<<30)){\\n                    b<<=1;\\n                    k++;\\n                } \\n            } \\n        }\\n        return (sgn==1)?q:-q;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3250771,
                "title": "superb-logic-whithout-operators",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        m,n=abs(dividend),abs(divisor)\\n        answer=0\\n        while (m-n)>=0:\\n            count=0\\n            while (m-(n<<1<<count))>=0:\\n                count+=1\\n            answer+=1<<count\\n            m-=n<<count\\n        if  dividend<0 and divisor<0:\\n            if answer>2**31-1:\\n                return 2**31-1\\n            else:\\n                return answer\\n        elif dividend<0 or divisor<0:\\n            if answer<-2**31:\\n                return -2**31\\n            return -answer\\n        else:\\n            if answer>2**31-1:\\n                return 2**31-1\\n            return answer\\n\\n\\n\\n\\n        \\n        \\n\\n\\n      \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        m,n=abs(dividend),abs(divisor)\\n        answer=0\\n        while (m-n)>=0:\\n            count=0\\n            while (m-(n<<1<<count))>=0:\\n                count+=1\\n            answer+=1<<count\\n            m-=n<<count\\n        if  dividend<0 and divisor<0:\\n            if answer>2**31-1:\\n                return 2**31-1\\n            else:\\n                return answer\\n        elif dividend<0 or divisor<0:\\n            if answer<-2**31:\\n                return -2**31\\n            return -answer\\n        else:\\n            if answer>2**31-1:\\n                return 2**31-1\\n            return answer\\n\\n\\n\\n\\n        \\n        \\n\\n\\n      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2705667,
                "title": "easy-java-solution-beats-75",
                "content": "```\\nclass Solution {\\n     public int divide(int dividend, int divisor)\\n {\\n        if (dividend == Integer.MIN_VALUE && divisor == -1)\\n             return Integer.MAX_VALUE; \\n\\n        boolean negative = dividend < 0 ^ divisor < 0; \\n        \\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n       \\n int quotient = 0, subQuotient = 0;\\n        \\n        while (dividend - divisor >= 0) {\\n            for (subQuotient = 0; dividend - (divisor << subQuotient << 1) >= 0; subQuotient++);\\n            quotient += 1 << subQuotient; \\n            dividend -= divisor << subQuotient; \\n}\\n        return negative ? -quotient : quotient;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public int divide(int dividend, int divisor)\\n {\\n        if (dividend == Integer.MIN_VALUE && divisor == -1)\\n             return Integer.MAX_VALUE; \\n\\n        boolean negative = dividend < 0 ^ divisor < 0; \\n        \\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n       \\n int quotient = 0, subQuotient = 0;\\n        \\n        while (dividend - divisor >= 0) {\\n            for (subQuotient = 0; dividend - (divisor << subQuotient << 1) >= 0; subQuotient++);\\n            quotient += 1 << subQuotient; \\n            dividend -= divisor << subQuotient; \\n}\\n        return negative ? -quotient : quotient;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2511149,
                "title": "i-think-this-is-a-mistake-check-please",
                "content": "![image](https://assets.leetcode.com/users/images/3ca98b1f-e1dc-4301-8d33-1ed9cc8d7ce4_1661981987.023198.png)\\n",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/3ca98b1f-e1dc-4301-8d33-1ed9cc8d7ce4_1661981987.023198.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2501524,
                "title": "using-substraction-and-addition-only",
                "content": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        n = 0\\n        md = 1\\n        if (dividend < 0):\\n            md = -md\\n            dividend = abs(dividend)\\n        if (divisor < 0):\\n            md = -md\\n            divisor = abs(divisor)\\n        nn = 1\\n        dvd = dividend\\n        dvr = divisor\\n        sn = 0\\n        while (dvd >= dvr):\\n            nn = 1\\n            dd = dvr\\n            while (dvd >= dd):\\n                sn += nn\\n                dvd -= dd\\n                dd += dd\\n                nn += nn\\n\\n        ans = sn\\n\\n        if (md < 0):\\n            ans = -ans\\n        if (ans > 2 ** 31 - 1):\\n            ans = 2 ** 31 - 1\\n        if (ans < -2 ** 31):\\n            ans = -2 ** 31\\n        return (ans)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        n = 0\\n        md = 1\\n        if (dividend < 0):\\n            md = -md\\n            dividend = abs(dividend)\\n        if (divisor < 0):\\n            md = -md\\n            divisor = abs(divisor)\\n        nn = 1\\n        dvd = dividend\\n        dvr = divisor\\n        sn = 0\\n        while (dvd >= dvr):\\n            nn = 1\\n            dd = dvr\\n            while (dvd >= dd):\\n                sn += nn\\n                dvd -= dd\\n                dd += dd\\n                nn += nn\\n\\n        ans = sn\\n\\n        if (md < 0):\\n            ans = -ans\\n        if (ans > 2 ** 31 - 1):\\n            ans = 2 ** 31 - 1\\n        if (ans < -2 ** 31):\\n            ans = -2 ** 31\\n        return (ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2358872,
                "title": "javascript-solution-bit-manipulation-time-log-n-space-o-1",
                "content": "It\\'s important to understand how we\\'re using base(2) for our integers and that each bit is a power of 2...so for example the first bit is 2 to the power of 0 and the second is 2 to the power 1 and the third is 2 to the power of 2...all the way to 31. Basically you should be comfortable with converting a positive numbers by hand and the basics of negative numbers in binary to understand how we can use bit manipulation to solve this problem \\n\\nWe use that logic to count the number of times our divisor fits into the dividend and since we\\'re shifting the bits to get our answer the time complexity will be O(log(n))\\n\\nBasically here initially we set our count to 1 if the dividend is greater than or equal to the divisor. We check to see if we can shift the bit over by checking to see if the number will still be greater than our dividend. If it is than we shift the bits of the count, dividend and divisor. Probably best to write it down to see how the shifts are shifting to understand how we\\'re using the power of 2 to get our result. We handle negatives by converting the input to a positive number and than adding the sign at the end.\\n```\\n/**\\n * bit manipulation\\n * space O(1) \\n * time O(log n) we\\'re shifting the n bits\\n */\\n var divide = function(n, d) {\\n    if (n === 0 || d === 0) return 0\\n    let isNegative = false;\\n    let result = 0;\\n    if ((d < 0 || n < 0) && !(d < 0 && n < 0)) isNegative = true;\\n    n = Math.abs(n)\\n    d = Math.abs(d)\\n\\n    while (n >= d) {\\n        let count = 1, temp = n, tempd = d\\n        while (tempd <= (temp >> 1)){\\n            count <<= 1\\n            temp >>= 1\\n            tempd <<= 1\\n        }\\n        result += count\\n        n -= tempd\\n    }\\n    if (isNegative) return -result\\n    if (result >= 2**31) {\\n        return 2**31 - 1\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\n/**\\n * bit manipulation\\n * space O(1) \\n * time O(log n) we\\'re shifting the n bits\\n */\\n var divide = function(n, d) {\\n    if (n === 0 || d === 0) return 0\\n    let isNegative = false;\\n    let result = 0;\\n    if ((d < 0 || n < 0) && !(d < 0 && n < 0)) isNegative = true;\\n    n = Math.abs(n)\\n    d = Math.abs(d)\\n\\n    while (n >= d) {\\n        let count = 1, temp = n, tempd = d\\n        while (tempd <= (temp >> 1)){\\n            count <<= 1\\n            temp >>= 1\\n            tempd <<= 1\\n        }\\n        result += count\\n        n -= tempd\\n    }\\n    if (isNegative) return -result\\n    if (result >= 2**31) {\\n        return 2**31 - 1\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2305274,
                "title": "easy-and-very-neat-code-bit-manipulation-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int divide(int a, int b) {\\n\\t  // When given dividend is -INFINITY and divisor is -1. The\\n        // answer should be -Inf*-1=Inf\\n        if(a == INT_MIN and b == -1) \\n            return INT_MAX;\\n        // since we know what sign the result should be,\\n        // we can remove the negative sign from both divisor and dividend\\n        long num = labs(a), div = labs(b);\\n\\t\\t// our final answer will be \\'ans\\', the number of times we need to multiply\\n        // divisor to make dividend as close to 0 as possible.\\n      \\tlong ans = 0;\\n        long temp = div, m=1;\\n        int sign = a > 0 ^ b > 0 ? -1 : 1;\\n        // while div is less/equal to num do the following:\\n        while(num >= div){\\n            if(temp <= num){\\n                temp <<= 1;\\n                m <<= 1;\\n            }\\n            else{\\n                ans += m >> 1;\\n                num -= temp >> 1;\\n                temp = div;\\n                m = 1;\\n            }\\n        }\\n        \\n        return sign*ans;\\n    }\\n};\\n```\\n**If you like the code then please upvote it. This will motivate me to post more codes with full explanation.**",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divide(int a, int b) {\\n\\t  // When given dividend is -INFINITY and divisor is -1. The\\n        // answer should be -Inf*-1=Inf\\n        if(a == INT_MIN and b == -1) \\n            return INT_MAX;\\n        // since we know what sign the result should be,\\n        // we can remove the negative sign from both divisor and dividend\\n        long num = labs(a), div = labs(b);\\n\\t\\t// our final answer will be \\'ans\\', the number of times we need to multiply\\n        // divisor to make dividend as close to 0 as possible.\\n      \\tlong ans = 0;\\n        long temp = div, m=1;\\n        int sign = a > 0 ^ b > 0 ? -1 : 1;\\n        // while div is less/equal to num do the following:\\n        while(num >= div){\\n            if(temp <= num){\\n                temp <<= 1;\\n                m <<= 1;\\n            }\\n            else{\\n                ans += m >> 1;\\n                num -= temp >> 1;\\n                temp = div;\\n                m = 1;\\n            }\\n        }\\n        \\n        return sign*ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2090734,
                "title": "c-solution-0-ms-three-approaches-bit-manipulation",
                "content": "__Thanks for checking out my solution\\nMake sureyou upvote if it helped you :)__\\n\\n__Method 1:\\nTime Complexity : O(Dividend / Divisor) \\nNaive Method to get the solution, \\nGives TLE therefore it has to be optimised__\\n\\n```\\nclass Solution\\n{ // There is Reason why this questioh has so low accuracy\\npublic:\\n    int divide(int dividend, int divisor)\\n    {\\n        int sgn = ((dividend < 0) ^ (divisor < 0));\\n        long long int d = abs(dividend), dv = abs(divisor), ans = 0;\\n        if (dv == 1)\\n            ans = d;\\n        else\\n            while (d >= dv)        //Exhaustive subtraction\\n            {\\n                ++ans;\\n                d -= dv;\\n            }\\n        if (sgn == 1)\\n            ans = -ans;\\n        return ((ans < INT_MIN) ? INT_MIN : ((ans > INT_MAX) ? INT_MAX : ans ));\\n    }\\n};\\n```\\n\\n__Now the task is to optimise the time-complexity, using bit-manipulation__\\n\\n>__The idea here is to understand that any number can be represented\\nas sum of powers of 2__\\n>>__Check for the sign of the quotient\\nint sign = (divisor < 0) ^ (divendend < 0);\\n//if only one of them is negative, sign = 1, else 0__\\n\\n>>__Pseudo Code\\nfor i = 31 to i = 0,  since the question assumes that the number is 32 bit__\\n>>>  __So check till (divisor << i)  <= dividend,    \\n>>>   i.e.  [ divisor * (2 ^ i) ]    <=  dividend \\n>>>   if true, add the power of 2 to the answer, and substract (divisor << i) from dividend\\n>>>   ans += 1 << i, i.e ans = ans + 2^i (power of 2)\\n>>>   dividend -= divisor << i__\\n\\n>>__if sign = 1\\nans = -ans;           //the quotient will be negative__\\n\\n>>__Now that we have to give the answer in the required constraints\\nif ans > INT_MAX ( 2^31 -1), return INT_MAX, min(ans, INT_MAX )\\nif ans < INT_MIN (-2^31), return INT_MIN, max(INT_MIN, ans )__\\n\\n\\n__Below is the coding implementation\\nMethod 2:\\nTime Complexity : O(31) ~ O(1)__\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int divide(int dividend, int divisor)\\n    {\\n        ios_base::sync_with_stdio(0);    //Speed Game\\n        cin.tie(0);\\n        int sgn = (dividend < 0) ^ (divisor < 0);     //Get the sign of the quotient \\n        long long int d = abs(dividend), dv = abs(divisor), ans = 0;   //Since left shift works only on positives, take absolute value\\n        for (int i = 31; i >= 0; i--)             //Explore all the 32 bits\\n            if (dv << i <= d)                     //If divisor * 2^i   <= dividend\\n            {\\n                ans += 1LL << i;                  //1LL prevents 2^31, to be treated as negative\\n                d -= dv << i;                      //Reduce the dividend\\n            }\\n        if (sgn == 1) // Number is negative\\n            ans = -ans;\\n        return ((ans < INT_MIN) ? INT_MIN : ((ans > INT_MAX) ? INT_MAX : ans ));\\n    }\\n};\\n```\\n\\n__Variation of the above given solution\\nThis time instead of taking the dividend to 0\\nWe take the divisor to the dividend\\nMethod 3:\\nTime Complexity : O(31) ~ O(1)__\\n```\\n// Same method but with addition with no subtraction\\nclass Solution\\n{\\npublic:\\n    int divide(int dividend, int divisor)\\n    {\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n        int sign = ((dividend < 0) ^ (divisor < 0));   //If only one of them is true, the quotient will be negative, i.e. sign = 1\\n        long long int d = abs(dividend), dv = abs(divisor), ans = 0, temp = 0;\\n        for (int i = 31; i >= 0; --i)\\n            if (temp + (d << i) <= dd)\\n            {\\n                temp += d << i;             //Taking the temp as close as to the dividend\\n                ans |= 1LL << i;\\n            }\\n        if (sign == 1) // Number is negative\\n            ans = -ans;\\n        return ((ans < INT_MIN) ? INT_MIN : ((ans > INT_MAX) ? INT_MAX : ans ));\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution\\n{ // There is Reason why this questioh has so low accuracy\\npublic:\\n    int divide(int dividend, int divisor)\\n    {\\n        int sgn = ((dividend < 0) ^ (divisor < 0));\\n        long long int d = abs(dividend), dv = abs(divisor), ans = 0;\\n        if (dv == 1)\\n            ans = d;\\n        else\\n            while (d >= dv)        //Exhaustive subtraction\\n            {\\n                ++ans;\\n                d -= dv;\\n            }\\n        if (sgn == 1)\\n            ans = -ans;\\n        return ((ans < INT_MIN) ? INT_MIN : ((ans > INT_MAX) ? INT_MAX : ans ));\\n    }\\n};\\n```\n```\\nclass Solution\\n{\\npublic:\\n    int divide(int dividend, int divisor)\\n    {\\n        ios_base::sync_with_stdio(0);    //Speed Game\\n        cin.tie(0);\\n        int sgn = (dividend < 0) ^ (divisor < 0);     //Get the sign of the quotient \\n        long long int d = abs(dividend), dv = abs(divisor), ans = 0;   //Since left shift works only on positives, take absolute value\\n        for (int i = 31; i >= 0; i--)             //Explore all the 32 bits\\n            if (dv << i <= d)                     //If divisor * 2^i   <= dividend\\n            {\\n                ans += 1LL << i;                  //1LL prevents 2^31, to be treated as negative\\n                d -= dv << i;                      //Reduce the dividend\\n            }\\n        if (sgn == 1) // Number is negative\\n            ans = -ans;\\n        return ((ans < INT_MIN) ? INT_MIN : ((ans > INT_MAX) ? INT_MAX : ans ));\\n    }\\n};\\n```\n```\\n// Same method but with addition with no subtraction\\nclass Solution\\n{\\npublic:\\n    int divide(int dividend, int divisor)\\n    {\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n        int sign = ((dividend < 0) ^ (divisor < 0));   //If only one of them is true, the quotient will be negative, i.e. sign = 1\\n        long long int d = abs(dividend), dv = abs(divisor), ans = 0, temp = 0;\\n        for (int i = 31; i >= 0; --i)\\n            if (temp + (d << i) <= dd)\\n            {\\n                temp += d << i;             //Taking the temp as close as to the dividend\\n                ans |= 1LL << i;\\n            }\\n        if (sign == 1) // Number is negative\\n            ans = -ans;\\n        return ((ans < INT_MIN) ? INT_MIN : ((ans > INT_MAX) ? INT_MAX : ans ));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2090591,
                "title": "rust-negative-division-i32-only",
                "content": "Since we are permitted to operate within the range of `i32` only, avoiding overflow with `i64` or `u32` should be considered illegal.\\n\\nThe problem is trivial when the dividend and the divisor are both positive. So it\\'s tempting for us to use `i32::abs()` to convert them into positive numbers and negate the result if necessary. But in this approach `i32::MIN.abs()` becomes a grave problem. According to the doc, it either panics or returns `i32::MIN` itself, which isn\\'t what we expect. So let\\'s do it the opposite way: convert both operands into their *negative* absolute values. \\n\\n```\\nimpl Solution {\\n    pub fn divide(dividend: i32, divisor: i32) -> i32 {\\n\\n        let is_neg = (dividend < 0) ^ (divisor < 0);\\n\\t\\t\\n        let mut p = if dividend > 0 { -dividend } else { dividend };\\n        let q = if divisor > 0 { -divisor } else { divisor };\\n\\n        // res is the *negative* absolute value of the quotient, in case the quotient is i32::MIN.\\n        let mut res = 0;\\n\\t\\t\\n\\t\\t// Here is the magic: the negative divisor(aka q) can left-shift atmost q.leading_ones() - 1 bits before it overflows.\\n        for shift in (0..q.leading_ones()).rev() {\\n\\t\\t\\t// Don\\'t apply \"p -= (q << shift)\" before overflow checking. Consider p = 0, q << shift = i32::MIN.\\n            if (p <= (q << shift)) {\\n                p -= q << shift;\\n                res += -1 << shift; // Not \"res -= 1 << shift;\" which may cause overflow.\\n            }\\n        }\\n        \\n        if is_neg {\\n            res\\n        } else if res == i32::MIN {\\n            i32::MAX\\n        } else {\\n            -res\\n        }\\n\\t\\t\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Rust",
                    "Bit Manipulation"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn divide(dividend: i32, divisor: i32) -> i32 {\\n\\n        let is_neg = (dividend < 0) ^ (divisor < 0);\\n\\t\\t\\n        let mut p = if dividend > 0 { -dividend } else { dividend };\\n        let q = if divisor > 0 { -divisor } else { divisor };\\n\\n        // res is the *negative* absolute value of the quotient, in case the quotient is i32::MIN.\\n        let mut res = 0;\\n\\t\\t\\n\\t\\t// Here is the magic: the negative divisor(aka q) can left-shift atmost q.leading_ones() - 1 bits before it overflows.\\n        for shift in (0..q.leading_ones()).rev() {\\n\\t\\t\\t// Don\\'t apply \"p -= (q << shift)\" before overflow checking. Consider p = 0, q << shift = i32::MIN.\\n            if (p <= (q << shift)) {\\n                p -= q << shift;\\n                res += -1 << shift; // Not \"res -= 1 << shift;\" which may cause overflow.\\n            }\\n        }\\n        \\n        if is_neg {\\n            res\\n        } else if res == i32::MIN {\\n            i32::MAX\\n        } else {\\n            -res\\n        }\\n\\t\\t\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2090009,
                "title": "c-bit-manipulation-easy-to-understand-with-example",
                "content": "```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        if(dividend == INT_MIN && divisor == -1)\\n            return INT_MAX;\\n     \\n        long long ans = 0;\\n        int s = 1;\\n        if(dividend<0 && divisor<0)\\n        s = 1;\\n        else if(divisor<0 || dividend<0)\\n        s = -1;\\n        long long dnd = abs((long)dividend),dsr = abs((long)divisor);\\n        while(dnd>=dsr)\\n        {\\n            long long temp = dsr, m = 1;\\n            while(temp<<1 <= dnd)\\n            {\\n                temp = temp<<1;\\n                m = m<<1;\\n                \\n            }\\n            dnd -= temp;\\n            ans += m;\\n        }\\n        return ans*s;\\n    }\\n};\\n```\\n\\n```\\n/*\\na = 15 , b  = 3;\\nwhile 15>=3 (outer while loop)\\n{\\ntemp = 3, m = 1;\\nif 3<<1 which is 6 <= 15\\nso, 3<<1 => temp = 6, m = m<<1 => 2;\\nif 6<<1 => 12<=15\\nso, 6<<1 => temp = 12 , m = 2<<1 => 4;\\nif(12<<1 => 24 <= 15) wrong \\nout of while loop ,\\nnow temp = 12, m = 4 => ans += 4 => 4;\\nsubtract 15-12 = 3;  \\n}  again\\nwhile 3>=3 (outer while loop)\\n{\\nso temp = 3, m = 1;\\nin inner while loop 3<<1 => 6 <= 3 (wrong) \\nso dnd = 3-3 = 0;\\nans += m => ans += 1 => ans = 5;\\n\\n}\\n(0>=3) (outer while loop ) (wrong)\\nso our ans is 5;\\n*/\\n\\n",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        if(dividend == INT_MIN && divisor == -1)\\n            return INT_MAX;\\n     \\n        long long ans = 0;\\n        int s = 1;\\n        if(dividend<0 && divisor<0)\\n        s = 1;\\n        else if(divisor<0 || dividend<0)\\n        s = -1;\\n        long long dnd = abs((long)dividend),dsr = abs((long)divisor);\\n        while(dnd>=dsr)\\n        {\\n            long long temp = dsr, m = 1;\\n            while(temp<<1 <= dnd)\\n            {\\n                temp = temp<<1;\\n                m = m<<1;\\n                \\n            }\\n            dnd -= temp;\\n            ans += m;\\n        }\\n        return ans*s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089488,
                "title": "division-using-the-left-shift-operator-python3",
                "content": "# --> Division using the left shift operator\\n**The Bitwise left shift operator:-**\\nWe know that the binary number system is based on powers of 2. So, positional weight of each of the following bits is twice the previous bit i.e. its power is increased by 1. As a result, when we push a number towards the left by 1 bit the whole number gets multiplied by 2 power 1. Similarly when a number is pushed to the left by n bits means the number is multiplied by 2 power n.\\n\\nThus in general if you shift a number to left by n bits, it gets multiplied n times by 2.\\n\\n**Steps:**\\n1. Initially, set the quotient to 0.\\n2. Check if any one of the numbers is negative and store it in a separate variable.\\n3. Make both the numbers positive.\\n4. Start from n = 31 the most significant bit and loop till n = 0 the least significant bit.\\n\\t* \\tCheck if shifting the divisor by n bits is less than or equal to the dividend\\n\\t   a) if so subtract it from the dividend and update the dividend\\n\\t   b) Add 2 power n to the answer\\n\\t   ( Note: Here the dividend is reduced to the reminder each time the condition is true. )\\n5. And finally, return the quotient after checking if it should be positive or negative with the result from step 2.\\n\\n\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        if dividend < 0 or divisor < 0:\\n\\t\\t\\t #Setting Negative Flag To true if any of the number is negative.\\n            Negative_Flag = True\\n        else:\\n            Negative_Flag = False\\n        \\n        quotient  = 0 #Initializing Quotient\\n\\t\\t\\n\\t\\t#Making negative number positive\\n        dividend = abs(dividend)\\n        divisor = abs(divisor)\\n\\t\\t\\n\\t\\t#Calculating Max and Min Limit\\n        maxLimit = (2**31)-1\\n        minLimit = -(2**31)\\n\\n        for i in range(31, -1, -1):\\n            if (divisor << i) <= dividend: # checking if divisor multiplied by 2**i is <= dividend\\n                dividend -= (divisor << i) #subtracting divisor << i from dividend\\n                quotient += 1 << i # adding 2 power i to the quotient\\n\\n\\t\\t # and finally checking if the output should be negative\\n        if Negative_Flag:\\n            quotient = -abs(quotient)\\n\\n        if quotient >= maxLimit:\\n            return maxLimit\\n        elif quotient <= minLimit:\\n            return minLimit\\n        else:\\n            return quotient\\n\\n```\\n*The time complexity of this algorithm is going to be O(log a), where a is the dividend.*\\n*The space complexity of this algorithm is O(1).*\\n\\n***Please upvote, if you found it helpful. Thanks..!!***",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        if dividend < 0 or divisor < 0:\\n\\t\\t\\t #Setting Negative Flag To true if any of the number is negative.\\n            Negative_Flag = True\\n        else:\\n            Negative_Flag = False\\n        \\n        quotient  = 0 #Initializing Quotient\\n\\t\\t\\n\\t\\t#Making negative number positive\\n        dividend = abs(dividend)\\n        divisor = abs(divisor)\\n\\t\\t\\n\\t\\t#Calculating Max and Min Limit\\n        maxLimit = (2**31)-1\\n        minLimit = -(2**31)\\n\\n        for i in range(31, -1, -1):\\n            if (divisor << i) <= dividend: # checking if divisor multiplied by 2**i is <= dividend\\n                dividend -= (divisor << i) #subtracting divisor << i from dividend\\n                quotient += 1 << i # adding 2 power i to the quotient\\n\\n\\t\\t # and finally checking if the output should be negative\\n        if Negative_Flag:\\n            quotient = -abs(quotient)\\n\\n        if quotient >= maxLimit:\\n            return maxLimit\\n        elif quotient <= minLimit:\\n            return minLimit\\n        else:\\n            return quotient\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774409,
                "title": "go-succinct-intuitive-100-with-explanation",
                "content": "```\\nfunc divide(dividend int, divisor int) int {\\n\\t// single special case that would cause overflow\\n\\tif dividend == math.MinInt32 && divisor == -1 {\\n\\t\\treturn math.MaxInt32\\n\\t}\\n\\n\\tquotient := 0\\n\\tdivid := abs(dividend)\\n\\tdivis := abs(divisor)\\n\\tfor divid >= divis {\\n\\t\\tsub := divis\\n\\t\\tadd := 1\\n\\t\\tfor divid >= sub<<1 {\\n\\t\\t\\tsub <<= 1\\n\\t\\t\\tadd <<= 1\\n\\t\\t}\\n\\t\\tdivid -= sub\\n\\t\\tquotient += add\\n\\t}\\n\\n\\tnegative := (dividend < 0) != (divisor < 0)\\n\\tif negative {\\n\\t\\treturn -quotient\\n\\t}\\n\\n\\treturn quotient\\n}\\n```\\n\\nFor anyone confused about the bitshifts (`<<`), the idea is that it makes the subtractions and additions faster by multiplying each value by a higher power of 2 with each shift, requiring fewer iterations. This is logically equivalent to this more intuitive code but much faster:\\n\\n```\\nfunc divide_intuitive_but_slow(dividend int, divisor int) int {\\n\\tif dividend == math.MinInt32 && divisor == -1 {\\n\\t\\treturn math.MaxInt32\\n\\t}\\n\\n\\tquotient := 0\\n\\tdivid := abs(dividend)\\n\\tdivis := abs(divisor)\\n\\tfor ; divid >= divis; quotient++ {\\n\\t\\tdivid -= divis\\n\\t}\\n\\n\\tnegative := (dividend < 0) != (divisor < 0)\\n\\tif negative {\\n\\t\\treturn -quotient\\n\\t}\\n\\n\\treturn quotient\\n}\\n```\\n\\nIn the most extreme case of `2147483647 / 1` (`math.MaxInt32` divided by `1`), the second program would take 2147483647 iterations and the first would only take 465.",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc divide(dividend int, divisor int) int {\\n\\t// single special case that would cause overflow\\n\\tif dividend == math.MinInt32 && divisor == -1 {\\n\\t\\treturn math.MaxInt32\\n\\t}\\n\\n\\tquotient := 0\\n\\tdivid := abs(dividend)\\n\\tdivis := abs(divisor)\\n\\tfor divid >= divis {\\n\\t\\tsub := divis\\n\\t\\tadd := 1\\n\\t\\tfor divid >= sub<<1 {\\n\\t\\t\\tsub <<= 1\\n\\t\\t\\tadd <<= 1\\n\\t\\t}\\n\\t\\tdivid -= sub\\n\\t\\tquotient += add\\n\\t}\\n\\n\\tnegative := (dividend < 0) != (divisor < 0)\\n\\tif negative {\\n\\t\\treturn -quotient\\n\\t}\\n\\n\\treturn quotient\\n}\\n```\n```\\nfunc divide_intuitive_but_slow(dividend int, divisor int) int {\\n\\tif dividend == math.MinInt32 && divisor == -1 {\\n\\t\\treturn math.MaxInt32\\n\\t}\\n\\n\\tquotient := 0\\n\\tdivid := abs(dividend)\\n\\tdivis := abs(divisor)\\n\\tfor ; divid >= divis; quotient++ {\\n\\t\\tdivid -= divis\\n\\t}\\n\\n\\tnegative := (dividend < 0) != (divisor < 0)\\n\\tif negative {\\n\\t\\treturn -quotient\\n\\t}\\n\\n\\treturn quotient\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1579861,
                "title": "java-no-longs-simple-solution-that-someone-could-actually-come-up-with",
                "content": "\\nThis post basically steals ideas from the following,\\nhttps://leetcode.com/problems/divide-two-integers/discuss/13417/No-Use-of-Long-Java-Solution\\nhttps://leetcode.com/problems/divide-two-integers/discuss/13397/Clean-Java-solution-with-some-comment.\\n\\ncombining the clean solution to use only integers, and stealing some of the logic from the first, please take a look at both if you are confused.\\n```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        \\n        if(dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE;\\n        \\n        boolean neg = false;\\n        if(dividend < 0) neg = !neg;\\n        if(divisor < 0) neg = !neg;\\n        \\n        int res = 0;\\n        \\n        if(dividend > 0  && divisor > 0)\\n            res = divideR(-dividend, -divisor);\\n        else if(dividend > 0)\\n            res = divideR(-dividend, divisor);\\n        else if(divisor > 0)\\n            res = divideR(dividend, -divisor);\\n        else \\n            res = divideR(dividend, divisor);\\n\\n        return neg ? -res : res;\\n        \\n    }\\n    \\n    private int divideR(int dividend, int divisor){\\n        \\n        \\n        if(divisor < dividend || dividend == 0) return 0;\\n        \\n        int sum = divisor;\\n        int mult = 1;\\n        \\n        while((sum + sum) < sum && (sum + sum) >= dividend){\\n            sum += sum;\\n            mult += mult;\\n        }\\n        \\n        return mult + divideR(dividend - sum, divisor);\\n    }\\n   \\n}\\n\\n```\\nI created this solution because I really did not enjoy any of the popular solutions posted here, my goals were to make it actually read-able and using the logic some of the better solutions had using longs, but supporting integers as well. There\\'s 3 things to really go over with this solution that are confusing.\\n\\n```\\n if(dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE;\\n ```\\n This case has to be checked because it\\'s a edge case, similar to other solutions.\\n \\n ```\\n if(dividend > 0  && divisor > 0)\\n            res = divideR(-dividend, -divisor);\\n        else if(dividend > 0)\\n            res = divideR(-dividend, divisor);\\n        else if(divisor > 0)\\n            res = divideR(dividend, -divisor);\\n        else \\n            res = divideR(dividend, divisor);\\n\\t\\t\\t\\n```\\n\\nHere we do a big conditional in order to conver the numbers to negative if they aren\\'t, there\\'s probably easier ways to do this. Why do we make our numbers negatives, well because programming sucks and negative numbers have 1 more than positives... so that means we get integer overflow if we try and convert all the negatives to positives. This might still not make sense why we do this, I encourage you to try programming the solution and you will see why it is advantageous to have all the numbers be either positive or negative ( makes defining the actual long division algorithm much more easy ), other solutions that don\\'t do this tend to lead to worse code in my opinion that would be hard to come up with without a lot of debugging...\\n\\n\\n\\n```\\n(sum + sum) < sum\\n```\\n\\nLastly this nice little line of code actually handles all of our overflow! since we are dealing with negatives, if we add two negative numbers and get a value that isn\\'t smaller, something went wrong!\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        \\n        if(dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE;\\n        \\n        boolean neg = false;\\n        if(dividend < 0) neg = !neg;\\n        if(divisor < 0) neg = !neg;\\n        \\n        int res = 0;\\n        \\n        if(dividend > 0  && divisor > 0)\\n            res = divideR(-dividend, -divisor);\\n        else if(dividend > 0)\\n            res = divideR(-dividend, divisor);\\n        else if(divisor > 0)\\n            res = divideR(dividend, -divisor);\\n        else \\n            res = divideR(dividend, divisor);\\n\\n        return neg ? -res : res;\\n        \\n    }\\n    \\n    private int divideR(int dividend, int divisor){\\n        \\n        \\n        if(divisor < dividend || dividend == 0) return 0;\\n        \\n        int sum = divisor;\\n        int mult = 1;\\n        \\n        while((sum + sum) < sum && (sum + sum) >= dividend){\\n            sum += sum;\\n            mult += mult;\\n        }\\n        \\n        return mult + divideR(dividend - sum, divisor);\\n    }\\n   \\n}\\n\\n```\n```\\n if(dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE;\\n ```\n```\\n if(dividend > 0  && divisor > 0)\\n            res = divideR(-dividend, -divisor);\\n        else if(dividend > 0)\\n            res = divideR(-dividend, divisor);\\n        else if(divisor > 0)\\n            res = divideR(dividend, -divisor);\\n        else \\n            res = divideR(dividend, divisor);\\n\\t\\t\\t\\n```\n```\\n(sum + sum) < sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1424021,
                "title": "c-easy-soln-using-bit-manipulation-in-o-logn-2",
                "content": "```\\n  int divide(int dividend, int divisor) {\\n        if(dividend==INT_MIN&&divisor==-1)return INT_MAX;\\n        \\n        long a = abs(dividend);\\n        long b = abs(divisor);\\n        long res=0;\\n        while(a-b>=0){\\n            int x=0;\\n            while(a-(b<<x<<1)>=0){\\n                x++;\\n            }\\n            res+= 1<<x;\\n            a-= b<<x;\\n        }\\n        return (dividend>=0)==(divisor>=0)? res: (-res);\\n    }",
                "solutionTags": [],
                "code": "```\\n  int divide(int dividend, int divisor) {\\n        if(dividend==INT_MIN&&divisor==-1)return INT_MAX;\\n        \\n        long a = abs(dividend);\\n        long b = abs(divisor);\\n        long res=0;\\n        while(a-b>=0){\\n            int x=0;\\n            while(a-(b<<x<<1)>=0){\\n                x++;\\n            }\\n            res+= 1<<x;\\n            a-= b<<x;\\n        }\\n        return (dividend>=0)==(divisor>=0)? res: (-res);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1085593,
                "title": "c-bitwise-solution-explained-100-time-85-space",
                "content": "I started to think about this problem with the same approach [I used for the power problem](https://leetcode.com/problems/powx-n/discuss/739646/): considering a number (`dividend`) as a sum of another (`divisor`) multiplied by 2 and this would have allowed me to know the quotient.\\n\\nFor example, assume that `dividend` is `60` and `divisors` is `3`: I can see `60 == 12 + 48` or, in a more explicit form (with `**` implying the power operation):\\n`60 == 3 * 2 ** 4 + 3 * 2 ** 2` and again: `60 == 1 * 3 * 2 ** 4 + 0 * 3 * 2 ** 3 + 1 * 3 * 2 ** 2 + 0 * 3 * 2 ** 1 + 0 * 3 * 2 ** 0`.\\n\\nIf I extract the first multiplying factors (`1` and `0`) and align them, I would get `10100`, which is indeed the binary representation of `20`, my goal!\\n\\nNow, to generalise this approach, we first of all need a few variables:\\n* `bits` is our counter variable that we will use in a bit (no pun intended) to know how many times we need to multiply our `divisor` by `2` to get a result, with initial value of `1`  (since down below we will increase the divisor by one extra step with my approach);\\n* `res` is our usual accumulator variable and it is going to be a `long`, same as `d1` and `d2`, to avoid annoyng overflows/edge cases;\\n* `isMinus` is a boolean to remind us what the sign of the final result should be, initially set to `false`.\\n\\nWe will then proceed making sure both `d1` and `d2` have the same sign (positive, for simplicity), flipping `isMinus` if we have to flip their sign.\\n\\nNow, in order to proceed with our logic discussed above, we will need a `d2` which is just bigger than `d1` and to keep track of how many times we need to multiply it by `2` - I know you could achieve the same with logarithms, but this is cheaper since we just stop with the last integer and on top of that we are also growing `d2` just as needed.\\n\\nAnd since after the previous loop we are going to know how many bits will make our result, time to go for a main loop `bits` time and:\\n* set `res` to double its previous value, plus `1` if `d1 >= d2` (meaning we can subtract it and it will make a bit in our final result);\\n* if the above condition is `true`, we will also have to decrease `d1` accordingly, subtracting `d2` to it;\\n* finally, time to reduce `d2` by one bit.\\n\\nA bit of (painfully annoying) extra logic to handle the edge cases and we can finally return `res` or `-res`, depending from `isMinus` :)\\n\\nOne more time, let\\'s assume we are dividing `70` by `3`, so we will have at the beginning of the main loop:\\n\\n```cpp\\n70 // d1\\n96 // d2\\n6 // bits\\n0 // res\\n```\\n\\nFirst iteration, since `70 > 96`, we proceed changing little, other than `d2` and of course decreasing `bits`:\\n\\n```cpp\\n70 // d1\\n48 // d2\\n5 // bits\\n0 // res\\n```\\n\\nOkay, now we can subtract, so we have:\\n\\n```cpp\\n22 // d1\\n24 // d2\\n4 // bits\\n1 // res\\n```\\n\\nAgain our condition `d1 >= d2` is `false`, so we just update `d2`, `bits` and this time also `res` increases (in the first step it was the same, given its initial value of `0`):\\n\\n```cpp\\n22 // d1\\n12 // d2\\n3 // bits\\n2 // res\\n```\\n\\nSince `22 >= 12`, we proceed like this:\\n\\n```cpp\\n10 // d1\\n6 // d2\\n2 // bits\\n5 // res\\n```\\n\\nAnd again, since `10 >= 4`:\\n\\n```cpp\\n4 // d1\\n3 // d2\\n1 // bits\\n11 // res\\n```\\n\\nAnd finally, since `4 >= 3`:\\n\\n```cpp\\n1 // d1\\n1 // d2\\n0 // bits\\n23 // res\\n```\\n\\nAnd at this point we can exit with the right result (and note that `d1` would also be our remainder).\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        // support variables\\n        int bits = 1;\\n        long d1 = dividend, d2 = divisor, res = 0;\\n        bool isMinus = false;\\n        // setting the sign\\n        if (d1 < 0) isMinus = !isMinus, d1 = -d1;\\n        if (d2 < 0) isMinus = !isMinus, d2 = -d2;\\n        // adjusting d2\\n        while (d2 <= d1) d2 <<= 1, bits++;\\n        // composing res\\n        while (bits--) {\\n            res = res * 2 + (d1 >= d2);\\n            if (d1 >= d2) d1 -= d2;\\n            d2 >>= 1;\\n        }\\n        // handling overflows\\n        if (res > 2147483647l + isMinus) res = 2147483647;\\n        return isMinus ? -res : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```cpp\\n70 // d1\\n96 // d2\\n6 // bits\\n0 // res\\n```\n```cpp\\n70 // d1\\n48 // d2\\n5 // bits\\n0 // res\\n```\n```cpp\\n22 // d1\\n24 // d2\\n4 // bits\\n1 // res\\n```\n```cpp\\n22 // d1\\n12 // d2\\n3 // bits\\n2 // res\\n```\n```cpp\\n10 // d1\\n6 // d2\\n2 // bits\\n5 // res\\n```\n```cpp\\n4 // d1\\n3 // d2\\n1 // bits\\n11 // res\\n```\n```cpp\\n1 // d1\\n1 // d2\\n0 // bits\\n23 // res\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        // support variables\\n        int bits = 1;\\n        long d1 = dividend, d2 = divisor, res = 0;\\n        bool isMinus = false;\\n        // setting the sign\\n        if (d1 < 0) isMinus = !isMinus, d1 = -d1;\\n        if (d2 < 0) isMinus = !isMinus, d2 = -d2;\\n        // adjusting d2\\n        while (d2 <= d1) d2 <<= 1, bits++;\\n        // composing res\\n        while (bits--) {\\n            res = res * 2 + (d1 >= d2);\\n            if (d1 >= d2) d1 -= d2;\\n            d2 >>= 1;\\n        }\\n        // handling overflows\\n        if (res > 2147483647l + isMinus) res = 2147483647;\\n        return isMinus ? -res : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1085349,
                "title": "rust-0ms-solution-using-32-bit-signed-integers-only",
                "content": "Question tells us to assume we are using an environment that only has up to 32-bit signed integers available, so let\\'s only use `i32`s for our computation.\\nAlso, we\\'re not allowed to use the `*`, `/ ` or `%` operators, obviously.\\n\\nTo achieve logarithmic runtime, we want to split the `dividend` into components of `divisor * (2^x)`, where `x` is a natural number (possibly including 0).\\nThe result of the division will be the sum of the `2^x` terms in our split components.\\n_For example, if we wish to divide 99 by 3: `99 == 3*(2^5) + 3*(2^0)`; therefore the answer is `2^5 + 2^0 == 32 + 1 == 33`._\\n\\nThe `2^x` terms are convenient, as we can use bitwise shifts to multiply and divide the `dividend` by powers of 2, due to binary being a base-2 number system.\\nIn many cases, we won\\'t be able to split `dividend` exactly, as there\\'ll be a remainder; in those cases we\\'ll want to get as close as possible such that the sum of our components doesn\\'t surpass `dividend`.\\n\\nTo avoid issues regarding overflow, we make our `dividend` and `divisor` negative, and use the negative signed integer range for our computation.\\nThe reason for this is that the negative integer range is always 1 greater than the positive range (excluding 0), which makes overflow checking a bit nicer (also avoids the temptation of cheesing the problem using `u32`s or `i64`s or similiar, **which is _very_ naughty**).\\n\\n```\\nimpl Solution {\\n    pub fn divide(mut dividend: i32, mut divisor: i32) -> i32 {\\n        assert!(divisor != 0);\\n\\n        let is_ans_neg = (dividend < 0) ^ (divisor < 0);\\n        dividend = -dividend.abs();\\n        divisor = -divisor.abs();\\n\\n        let (mut neg_ans, mut curr_div, mut curr_mul) = (0, divisor, -1);\\n        while curr_div <= divisor {\\n            if curr_div < dividend {\\n                curr_div = if curr_div == -1 { 0 } else { curr_div >> 1 };\\n                curr_mul = if curr_mul == -1 { 0 } else { curr_mul >> 1 };\\n            } else {\\n                neg_ans += curr_mul;\\n                dividend -= curr_div;\\n                curr_div <<= 1;\\n                curr_mul <<= 1;\\n            }\\n        }\\n\\n        match neg_ans {\\n            std::i32::MIN if !is_ans_neg => std::i32::MAX,\\n            _ if is_ans_neg => neg_ans,\\n            _ => -neg_ans,\\n        }\\n    }\\n}\\n```\\n\\nAlso, seeing that integers are stored as 2s complement, you may instead prefer to use `~variable + 1` to negate signs, rather than `-variable`. Do whatever suits you. :)\\n\\nTime complexity: `O(~log32) == O(1)` due to the constraints on the inputs.\\nExtra-space complexity: `O(1)`.",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn divide(mut dividend: i32, mut divisor: i32) -> i32 {\\n        assert!(divisor != 0);\\n\\n        let is_ans_neg = (dividend < 0) ^ (divisor < 0);\\n        dividend = -dividend.abs();\\n        divisor = -divisor.abs();\\n\\n        let (mut neg_ans, mut curr_div, mut curr_mul) = (0, divisor, -1);\\n        while curr_div <= divisor {\\n            if curr_div < dividend {\\n                curr_div = if curr_div == -1 { 0 } else { curr_div >> 1 };\\n                curr_mul = if curr_mul == -1 { 0 } else { curr_mul >> 1 };\\n            } else {\\n                neg_ans += curr_mul;\\n                dividend -= curr_div;\\n                curr_div <<= 1;\\n                curr_mul <<= 1;\\n            }\\n        }\\n\\n        match neg_ans {\\n            std::i32::MIN if !is_ans_neg => std::i32::MAX,\\n            _ if is_ans_neg => neg_ans,\\n            _ => -neg_ans,\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 976341,
                "title": "java-1ms-100-faster-bit-manipulation-with-comments",
                "content": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n    \\n        \\n        if(dividend==Integer.MIN_VALUE&&divisor==-1) \\n            return Integer.MAX_VALUE;\\n        \\n        boolean isNegative=false;\\n        if(dividend<0||divisor<0){\\n            isNegative = true;\\n        }\\n        // if both are -ve it will be cancelled out\\n         if(dividend<0&&divisor<0){\\n            isNegative = false;\\n        }\\n        \\n        int a = Math.abs(dividend);\\n        int b = Math.abs(divisor);\\n        int result=0;\\n        // 10-3>=0\\n        while(a-b>=0){\\n            int x = 0; //  its like 2^0=1 , at the end u will get to know\\n            \\n            //checking further we can able to subtract divisor(3)\\n            //10 - (3<<1<<0)\\n            //10 - (6) >=0\\n            while(a-(b<<1<<x)>=0){\\n                x++;\\n            }\\n            // after 1st iteration x = 1\\n            // 0 = 0 + (1<<1)\\n            // 0 = 0 + 2\\n            result +=1<<x;\\n            \\n            \\n            //10 =10 - (3<<1)\\n            //10 =10 - (6)\\n            a =  a-(b<<x);//  a = 4\\n\\t\\t\\t//again while loop continue.....\\n            \\n        }\\n        \\n        return isNegative?-result:result;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n    \\n        \\n        if(dividend==Integer.MIN_VALUE&&divisor==-1) \\n            return Integer.MAX_VALUE;\\n        \\n        boolean isNegative=false;\\n        if(dividend<0||divisor<0){\\n            isNegative = true;\\n        }\\n        // if both are -ve it will be cancelled out\\n         if(dividend<0&&divisor<0){\\n            isNegative = false;\\n        }\\n        \\n        int a = Math.abs(dividend);\\n        int b = Math.abs(divisor);\\n        int result=0;\\n        // 10-3>=0\\n        while(a-b>=0){\\n            int x = 0; //  its like 2^0=1 , at the end u will get to know\\n            \\n            //checking further we can able to subtract divisor(3)\\n            //10 - (3<<1<<0)\\n            //10 - (6) >=0\\n            while(a-(b<<1<<x)>=0){\\n                x++;\\n            }\\n            // after 1st iteration x = 1\\n            // 0 = 0 + (1<<1)\\n            // 0 = 0 + 2\\n            result +=1<<x;\\n            \\n            \\n            //10 =10 - (3<<1)\\n            //10 =10 - (6)\\n            a =  a-(b<<x);//  a = 4\\n\\t\\t\\t//again while loop continue.....\\n            \\n        }\\n        \\n        return isNegative?-result:result;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919712,
                "title": "well-explained-python-solution",
                "content": "```\\nimport math\\n\\nclass Solution:\\n    # division without using divide or multiply\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        # repeatedly subtracting divisor n times is too slow, it times out\\n        # ( O(n) where n=dividend/divisor)\\n        # To speed it up we will still subtract divisor but instead of one at a time,\\n        # we will subtract divisor, divisor*2, divisor*4, divisor*8, divisor*16 etc\\n        # O(log n)\\n        \\n        if divisor == 0:\\n            return 2147483647 # error case\\n        positive = (dividend>0) == (divisor>0) # same sign? result will be positive\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        \\n        # first find the largest power of two we need:\\n        power = 1\\n        current_divisor = divisor\\n        current_dividend = dividend\\n        while current_dividend > current_divisor:\\n            current_dividend -= current_divisor\\n            power += power # double to next power of 2\\n            current_divisor += current_divisor # double to next power of 2 * divisor\\n        # divisor is now the largest power of two * divisor smaller than the dividend\\n        # (actually one larger)\\n        \\n        quotient = 0\\n        while power >= 1:\\n            if dividend >= current_divisor: # is this power of two in our dividend?\\n                dividend -= current_divisor # subtract it out\\n                quotient += power # and count it towards our answer\\n            power >>= 1 # half to next lower power of 2\\n            current_divisor >>= 1 # half to next lower power of 2 * divisor\\n            # Using bit shift for divide by 2 isn\\'t cheating. But is it really?\\n        if positive:\\n            if quotient > 2147483647:\\n                return 2147483647\\n            return quotient\\n        else:\\n            if quotient < -2147483648:\\n                return 2147483647\\n            return -quotient\\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\n\\nclass Solution:\\n    # division without using divide or multiply\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        # repeatedly subtracting divisor n times is too slow, it times out\\n        # ( O(n) where n=dividend/divisor)\\n        # To speed it up we will still subtract divisor but instead of one at a time,\\n        # we will subtract divisor, divisor*2, divisor*4, divisor*8, divisor*16 etc\\n        # O(log n)\\n        \\n        if divisor == 0:\\n            return 2147483647 # error case\\n        positive = (dividend>0) == (divisor>0) # same sign? result will be positive\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        \\n        # first find the largest power of two we need:\\n        power = 1\\n        current_divisor = divisor\\n        current_dividend = dividend\\n        while current_dividend > current_divisor:\\n            current_dividend -= current_divisor\\n            power += power # double to next power of 2\\n            current_divisor += current_divisor # double to next power of 2 * divisor\\n        # divisor is now the largest power of two * divisor smaller than the dividend\\n        # (actually one larger)\\n        \\n        quotient = 0\\n        while power >= 1:\\n            if dividend >= current_divisor: # is this power of two in our dividend?\\n                dividend -= current_divisor # subtract it out\\n                quotient += power # and count it towards our answer\\n            power >>= 1 # half to next lower power of 2\\n            current_divisor >>= 1 # half to next lower power of 2 * divisor\\n            # Using bit shift for divide by 2 isn\\'t cheating. But is it really?\\n        if positive:\\n            if quotient > 2147483647:\\n                return 2147483647\\n            return quotient\\n        else:\\n            if quotient < -2147483648:\\n                return 2147483647\\n            return -quotient\\n```",
                "codeTag": "Java"
            },
            {
                "id": 840662,
                "title": "very-short-math-pythonic-solution",
                "content": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        \\n        if dividend == 0:\\n            return 0\\n        \\n        sign = +1 if dividend ^ divisor >= 0 else -1        \\n        dividend, divisor = abs(dividend), abs(divisor)\\n        \\n        ans = math.exp(math.log(dividend) - math.log(divisor))\\n\\n        return min(2147483647, sign*math.trunc(ans))\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        \\n        if dividend == 0:\\n            return 0\\n        \\n        sign = +1 if dividend ^ divisor >= 0 else -1        \\n        dividend, divisor = abs(dividend), abs(divisor)\\n        \\n        ans = math.exp(math.log(dividend) - math.log(divisor))\\n\\n        return min(2147483647, sign*math.trunc(ans))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 752513,
                "title": "solution-using-log-in-c",
                "content": "```\\nint divide(double dividend, double divisor) { \\n\\n        int negFlag = (dividend < 0 ^ divisor < 0) ? 1 : 0;\\n        double logDiv = log(abs(dividend)) - log(abs(divisor));\\n\\t\\t\\n\\t\\t// take antilog to calculate the value \\n        double val = exp(logDiv);\\n        \\n        if(val >= INT_MAX)\\n            return negFlag ? INT_MIN : INT_MAX;\\n    \\n        return negFlag ? -val : val;    \\n    }\\n```\\n\\nWe use the property : log(a/b) = log(a) - log(b)",
                "solutionTags": [],
                "code": "```\\nint divide(double dividend, double divisor) { \\n\\n        int negFlag = (dividend < 0 ^ divisor < 0) ? 1 : 0;\\n        double logDiv = log(abs(dividend)) - log(abs(divisor));\\n\\t\\t\\n\\t\\t// take antilog to calculate the value \\n        double val = exp(logDiv);\\n        \\n        if(val >= INT_MAX)\\n            return negFlag ? INT_MIN : INT_MAX;\\n    \\n        return negFlag ? -val : val;    \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 558335,
                "title": "seems-to-expect-the-wrong-answer-for-js",
                "content": "```\\nInput: \\n\\t-2147483648\\n\\t-1\\nOutput: \\n\\t2147483648\\nExpected: \\n\\t2147483647\\n```\\n\\nThis can\\'t be right, right? Why would it expect this 214748347? It should not be truncating when dividing by zero\\n",
                "solutionTags": [],
                "code": "```\\nInput: \\n\\t-2147483648\\n\\t-1\\nOutput: \\n\\t2147483648\\nExpected: \\n\\t2147483647\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 546970,
                "title": "c-faster-than-99-60-less-than-33-33-mem-o-1",
                "content": "O(1) since the while loops do at most 32 bit shifts combined.\\n\\nRuntime: 32 ms\\nMemory Usage: 14.7 MB\\n\\nLogic Highlights:\\n* If the dividend is int.MinValue, just remove the divisor from it one time to make sure we can convert it to a positive number. This allows us to stick to the int type. \\n* Convert dividend and divisor to positive numbers to simplify logic. \\n* Find out how many bits make up the divisor. Substracting this number from 31 gives us how far we can shift the divisor before it overflows. \\n* Starting with the largest possible multiple of the divisor to the smallest, see if we can remove it from the dividend. \\n\\nThanks to [jonlist](http://https://leetcode.com/problems/divide-two-integers/discuss/475971/C++-bitwise-and-32bit-int.-0ms-less100-8.2MBless72), that solution made me see things in a different way.\\n\\n```\\n    public int Divide(int dividend, int divisor) {\\n        if (divisor == 1) { return dividend; }\\n        if (divisor == -1 &&  dividend == int.MinValue) { return int.MaxValue; }\\n        if (dividend == divisor) { return 1; }\\n        if (dividend == 0 || divisor == int.MinValue) { return 0; }\\n        \\n        bool isNeg = (dividend < 0 && divisor > 0) ||  (dividend > 0 && divisor < 0);\\n        \\n        int count = 0;\\n        if (dividend == int.MinValue)\\n        {\\n            if (divisor < 0) {  dividend -= divisor; } else { dividend += divisor; }\\n            count++;\\n        }\\n        \\n        int dvd = (dividend < 0)? -dividend: dividend;\\n        int dvs = (divisor < 0)? -divisor: divisor;\\n         \\n        int temp = dvs;\\n        int i = 0;\\n        while(temp > 0)\\n        {\\n           i++;\\n           temp>>=1;\\n        }   \\n        \\n        int multi=31-i;\\n        \\n        while (dvd >= dvs)\\n        {   \\n            temp = dvs;\\n            while((temp << multi) > dvd) { multi--; }\\n                 \\n            dvd -= temp << multi;\\n            count += 1 << multi; \\n        }  \\n                  \\n        if (isNeg) { count = -count; }\\n        \\n        return count;\\n    }",
                "solutionTags": [],
                "code": "O(1) since the while loops do at most 32 bit shifts combined.\\n\\nRuntime: 32 ms\\nMemory Usage: 14.7 MB\\n\\nLogic Highlights:\\n* If the dividend is int.MinValue, just remove the divisor from it one time to make sure we can convert it to a positive number. This allows us to stick to the int type. \\n* Convert dividend and divisor to positive numbers to simplify logic. \\n* Find out how many bits make up the divisor. Substracting this number from 31 gives us how far we can shift the divisor before it overflows. \\n* Starting with the largest possible multiple of the divisor to the smallest, see if we can remove it from the dividend. \\n\\nThanks to [jonlist](http://https://leetcode.com/problems/divide-two-integers/discuss/475971/C++-bitwise-and-32bit-int.-0ms-less100-8.2MBless72), that solution made me see things in a different way.\\n\\n```\\n    public int Divide(int dividend, int divisor) {\\n        if (divisor == 1) { return dividend; }\\n        if (divisor == -1 &&  dividend == int.MinValue) { return int.MaxValue; }\\n        if (dividend == divisor) { return 1; }\\n        if (dividend == 0 || divisor == int.MinValue) { return 0; }\\n        \\n        bool isNeg = (dividend < 0 && divisor > 0) ||  (dividend > 0 && divisor < 0);\\n        \\n        int count = 0;\\n        if (dividend == int.MinValue)\\n        {\\n            if (divisor < 0) {  dividend -= divisor; } else { dividend += divisor; }\\n            count++;\\n        }\\n        \\n        int dvd = (dividend < 0)? -dividend: dividend;\\n        int dvs = (divisor < 0)? -divisor: divisor;\\n         \\n        int temp = dvs;\\n        int i = 0;\\n        while(temp > 0)\\n        {\\n           i++;\\n           temp>>=1;\\n        }   \\n        \\n        int multi=31-i;\\n        \\n        while (dvd >= dvs)\\n        {   \\n            temp = dvs;\\n            while((temp << multi) > dvd) { multi--; }\\n                 \\n            dvd -= temp << multi;\\n            count += 1 << multi; \\n        }  \\n                  \\n        if (isNeg) { count = -count; }\\n        \\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 484686,
                "title": "javascript",
                "content": "Runtime: 3396 ms, faster than 24.62% of JavaScript online submissions for Divide Two Integers.\\nMemory Usage: 36.2 MB, less than 33.33% of JavaScript online submissions for Divide Two Integers.\\n\\n```\\nvar divide = function(dividend, divisor) {\\n    if (dividend === -Math.pow(2, 31) && divisor === -1) {\\n      return Math.pow(2, 31) - 1;\\n    }\\n    if (divisor === 1) {\\n      return dividend;\\n    }\\n    let isNegative = false;\\n    if (dividend < 0 && divisor > 0 || (dividend > 0 && divisor < 0)) {\\n      isNegative = true;\\n    }\\n    let newDividend = Math.abs(dividend);\\n    const newDivisor = Math.abs(divisor);\\n    let result = 0;\\n    while(newDividend >= newDivisor) {\\n      newDividend = newDividend - newDivisor;\\n      result++;\\n    }\\n    return isNegative ? -result : result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar divide = function(dividend, divisor) {\\n    if (dividend === -Math.pow(2, 31) && divisor === -1) {\\n      return Math.pow(2, 31) - 1;\\n    }\\n    if (divisor === 1) {\\n      return dividend;\\n    }\\n    let isNegative = false;\\n    if (dividend < 0 && divisor > 0 || (dividend > 0 && divisor < 0)) {\\n      isNegative = true;\\n    }\\n    let newDividend = Math.abs(dividend);\\n    const newDivisor = Math.abs(divisor);\\n    let result = 0;\\n    while(newDividend >= newDivisor) {\\n      newDividend = newDividend - newDivisor;\\n      result++;\\n    }\\n    return isNegative ? -result : result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 385840,
                "title": "c-0ms-without-using-long-math-h-covert-both-to-negative-to-avoid-coding-for-different-cases",
                "content": "My idea is coverting both dividend and divisor to be negative, to make the code shorter. Here is my code:\\n```\\nint divide(int dividend, int divisor) {\\n        // I will change both dividend and divisor to be negative\\n        \\n        bool sign = true; // true -> result positive; false -> result negative;\\n        if (dividend > 0) {\\n            sign = !sign;\\n            dividend = -dividend;\\n        }\\n        if (divisor > 0){\\n            sign = !sign;\\n            divisor = -divisor;\\n        }\\n        \\n        // now dividend and divisor are both smaller than or equal to 0\\n        int res = 0;\\n        while (dividend <= divisor){\\n            int i = 0;\\n            int x = divisor;\\n            // This while loop finds i \\n            // such that  2^(i+1) * divisor < dividend <= 2^i * divisor\\n            while (true) {\\n                if (x < - (1<<30)) break; // keep x + x in integer range\\n                if (dividend > x + x) break;\\n                x = x + x;\\n                i++;\\n            }\\n            res += 1<<i;\\n            dividend -= x;\\n        }\\n        // res should be larger than 0\\n        // If res == INT_MIN && sign, \\n        // it indicates the result is -INT_MIN, which overflows;\\n        if (res == INT_MIN) return sign?INT_MAX:INT_MIN;\\n        return sign? res:-res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint divide(int dividend, int divisor) {\\n        // I will change both dividend and divisor to be negative\\n        \\n        bool sign = true; // true -> result positive; false -> result negative;\\n        if (dividend > 0) {\\n            sign = !sign;\\n            dividend = -dividend;\\n        }\\n        if (divisor > 0){\\n            sign = !sign;\\n            divisor = -divisor;\\n        }\\n        \\n        // now dividend and divisor are both smaller than or equal to 0\\n        int res = 0;\\n        while (dividend <= divisor){\\n            int i = 0;\\n            int x = divisor;\\n            // This while loop finds i \\n            // such that  2^(i+1) * divisor < dividend <= 2^i * divisor\\n            while (true) {\\n                if (x < - (1<<30)) break; // keep x + x in integer range\\n                if (dividend > x + x) break;\\n                x = x + x;\\n                i++;\\n            }\\n            res += 1<<i;\\n            dividend -= x;\\n        }\\n        // res should be larger than 0\\n        // If res == INT_MIN && sign, \\n        // it indicates the result is -INT_MIN, which overflows;\\n        if (res == INT_MIN) return sign?INT_MAX:INT_MIN;\\n        return sign? res:-res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 165649,
                "title": "another-clear-python-code-solution",
                "content": "```\\nclass Solution:\\n    def divide(self, dividend, divisor):\\n        \"\"\"\\n        :type dividend: int\\n        :type divisor: int\\n        :rtype: int\\n        \"\"\"\\n        sign = -1 if ((dividend < 0) ^ (divisor < 0)) else 1\\n        \\n        dividend = abs(dividend)\\n        divisor =  abs(divisor)\\n        \\n        if dividend == 0:\\n            return 0 \\n        else:\\n            ans = sign * math.exp(math.log(dividend) - math.log(divisor))\\n            if ans > 0:\\n        \\t    return min(max(-2147483648, math.floor(ans)), 2147483647)\\n            else:\\n                return math.ceil(ans)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n        ",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend, divisor):\\n        \"\"\"\\n        :type dividend: int\\n        :type divisor: int\\n        :rtype: int\\n        \"\"\"\\n        sign = -1 if ((dividend < 0) ^ (divisor < 0)) else 1\\n        \\n        dividend = abs(dividend)\\n        divisor =  abs(divisor)\\n        \\n        if dividend == 0:\\n            return 0 \\n        else:\\n            ans = sign * math.exp(math.log(dividend) - math.log(divisor))\\n            if ans > 0:\\n        \\t    return min(max(-2147483648, math.floor(ans)), 2147483647)\\n            else:\\n                return math.ceil(ans)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n        ",
                "codeTag": "Java"
            },
            {
                "id": 161358,
                "title": "concise-java-solution-without-using-long",
                "content": "To avoid using long, the key point is to represent both dividend and divisor as negative integer, and check the corner case that will cause overflow at the beginning.\\n\\nThen use a while loop and addition to calculate the quotients.\\n\\n\\n```java\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == Integer.MIN_VALUE && divisor == -1)\\n            return Integer.MAX_VALUE;\\n        int flag = 1;\\n        if((dividend > 0 && divisor < 0) || (dividend < 0 && divisor > 0))\\n            flag = -1;\\n        if(divisor > 0)\\n            divisor = -divisor;\\n        if(dividend > 0)\\n            dividend = -dividend;\\n        int result = 0;\\n        while(dividend <= divisor){\\n            int count = 1, tempDivisor = divisor;\\n            while(dividend - tempDivisor <= tempDivisor){\\n                count <<= 1;\\n                tempDivisor <<= 1;\\n            }\\n            result += count;\\n            dividend -= tempDivisor;\\n        }\\n        return flag * result;\\n    }\\n}\\n```\\n**UPDATE**\\nThanks to @yuhangjiang for pointing out the use of * at the return statement. Please see the updated version, to completely avoid using *, I used bit operations instead to get the negative result.\\n\\n```java\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE;\\n        boolean neg = dividend > 0 && divisor < 0 || dividend < 0 && divisor > 0;\\n        if(dividend > 0)\\n            dividend = -dividend;\\n        if(divisor > 0)\\n            divisor = -divisor;\\n        int res = 0;\\n        while(divisor >= dividend){\\n            int count = 1;\\n            int newDivisor = divisor;\\n            while(newDivisor >= dividend - newDivisor){\\n                newDivisor <<= 1;\\n                count <<= 1;\\n            }\\n            dividend -= newDivisor;\\n            res += count;\\n        }\\n        if(neg)\\n            res = ~res + 1;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == Integer.MIN_VALUE && divisor == -1)\\n            return Integer.MAX_VALUE;\\n        int flag = 1;\\n        if((dividend > 0 && divisor < 0) || (dividend < 0 && divisor > 0))\\n            flag = -1;\\n        if(divisor > 0)\\n            divisor = -divisor;\\n        if(dividend > 0)\\n            dividend = -dividend;\\n        int result = 0;\\n        while(dividend <= divisor){\\n            int count = 1, tempDivisor = divisor;\\n            while(dividend - tempDivisor <= tempDivisor){\\n                count <<= 1;\\n                tempDivisor <<= 1;\\n            }\\n            result += count;\\n            dividend -= tempDivisor;\\n        }\\n        return flag * result;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE;\\n        boolean neg = dividend > 0 && divisor < 0 || dividend < 0 && divisor > 0;\\n        if(dividend > 0)\\n            dividend = -dividend;\\n        if(divisor > 0)\\n            divisor = -divisor;\\n        int res = 0;\\n        while(divisor >= dividend){\\n            int count = 1;\\n            int newDivisor = divisor;\\n            while(newDivisor >= dividend - newDivisor){\\n                newDivisor <<= 1;\\n                count <<= 1;\\n            }\\n            dividend -= newDivisor;\\n            res += count;\\n        }\\n        if(neg)\\n            res = ~res + 1;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13543,
                "title": "a-concise-java-solution",
                "content": "        public int divide(int dividend, int divisor) {\\n            if (dividend == Integer.MIN_VALUE && divisor == -1)\\n                return Integer.MAX_VALUE;\\n    \\n            long divd = Math.abs((long)dividend);\\n            long divs = Math.abs((long)divisor);\\n    \\n            int ret = 0;\\n            while (divd >= divs) {\\n                int counter = 0;\\n                while (divd >= (divs << counter)) { // keep multiply by 2 until divs > divd\\n                    counter++;\\n                }\\n                counter--;  // rollback counter so that (divs<<counter) <= divd\\n                ret += 1 << counter;  // quotient\\n                divd -= divs << counter;\\n            }\\n    \\n            if ((dividend > 0 && divisor > 0) || (dividend < 0 && divisor < 0))\\n                return ret;\\n            else\\n                return -ret;\\n        }",
                "solutionTags": [],
                "code": "        public int divide(int dividend, int divisor) {\\n            if (dividend == Integer.MIN_VALUE && divisor == -1)\\n                return Integer.MAX_VALUE;\\n    \\n            long divd = Math.abs((long)dividend);\\n            long divs = Math.abs((long)divisor);\\n    \\n            int ret = 0;\\n            while (divd >= divs) {\\n                int counter = 0;\\n                while (divd >= (divs << counter)) { // keep multiply by 2 until divs > divd\\n                    counter++;\\n                }\\n                counter--;  // rollback counter so that (divs<<counter) <= divd\\n                ret += 1 << counter;  // quotient\\n                divd -= divs << counter;\\n            }\\n    \\n            if ((dividend > 0 && divisor > 0) || (dividend < 0 && divisor < 0))\\n                return ret;\\n            else\\n                return -ret;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 13634,
                "title": "my-fast-solution-using-bit-operation-36ms",
                "content": "As for any integer can be writen by 2n+1 or 2n. Think about 123/5:\\n\\ndivisor        dividend\\n\\n5                     123\\n\\n   <<1\\n\\n   <<1\\n\\n   <<1\\n\\n   <<1\\n\\n   5*16 = 80\\n\\n5                    123-80=43\\n\\n  <<1\\n\\n  <<1\\n\\n  <<1\\n\\n5*8 = 40\\n\\n5                     43-40=3\\n\\n5<3, thus result = 16+8 = 24\\n\\n(if dividend == 125, finally we have:)\\n\\n5==5, thus result = 16+8+1 = 25;\\n\\n\\nHowever, I play a little trick by using long long .. o_____O\\n\\n--------------------------------------------------------------------------------------------\\n\\n    int divide(long long a, long long b) {\\n        if(b==0) return a>=0?0x7fffffff:0x80000000;\\n        if(a==0) return 0;\\n        if(b==1) return a;\\n        int sgn = (a^b) & 0x80000000; //0 -> +,  0x80000000 -> -\\n        if(a<0) a=-a;\\n        if(b<0) b=-b;\\n        //a,b>0\\n        if(a<b) return 0;\\n        int res = 0, _b = b, twon;\\n        while(a>b)\\n        {\\n            twon = 1;\\n            while(a>b)\\n            {\\n                //cout <<b<<' '<<a<<' '<<twon<<endl;\\n                b<<=1;\\n                twon<<=1;\\n                //getchar();\\n            }\\n            b>>=1;\\n            twon>>=1;\\n            a -= b;\\n            b = _b;\\n            res += twon;\\n        }\\n        if(a==b) res++;\\n        if(sgn) \\n            return -res;\\n        else return res;\\n    }",
                "solutionTags": [],
                "code": "As for any integer can be writen by 2n+1 or 2n. Think about 123/5:\\n\\ndivisor        dividend\\n\\n5                     123\\n\\n   <<1\\n\\n   <<1\\n\\n   <<1\\n\\n   <<1\\n\\n   5*16 = 80\\n\\n5                    123-80=43\\n\\n  <<1\\n\\n  <<1\\n\\n  <<1\\n\\n5*8 = 40\\n\\n5                     43-40=3\\n\\n5<3, thus result = 16+8 = 24\\n\\n(if dividend == 125, finally we have:)\\n\\n5==5, thus result = 16+8+1 = 25;\\n\\n\\nHowever, I play a little trick by using long long .. o_____O\\n\\n--------------------------------------------------------------------------------------------\\n\\n    int divide(long long a, long long b) {\\n        if(b==0) return a>=0?0x7fffffff:0x80000000;\\n        if(a==0) return 0;\\n        if(b==1) return a;\\n        int sgn = (a^b) & 0x80000000; //0 -> +,  0x80000000 -> -\\n        if(a<0) a=-a;\\n        if(b<0) b=-b;\\n        //a,b>0\\n        if(a<b) return 0;\\n        int res = 0, _b = b, twon;\\n        while(a>b)\\n        {\\n            twon = 1;\\n            while(a>b)\\n            {\\n                //cout <<b<<' '<<a<<' '<<twon<<endl;\\n                b<<=1;\\n                twon<<=1;\\n                //getchar();\\n            }\\n            b>>=1;\\n            twon>>=1;\\n            a -= b;\\n            b = _b;\\n            res += twon;\\n        }\\n        if(a==b) res++;\\n        if(sgn) \\n            return -res;\\n        else return res;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 13608,
                "title": "after-5-tle-finally-got-ac-and-i-cant-figure-out-the-complexity",
                "content": "**(Given that English not my mother tongue, please forgive my mistake about my words below)**\\n\\nHere coming my code without / * % operator:\\n\\n        class Solution {\\n    public:\\n    \\tint divide(int dividend, int divisor) {\\n    \\t\\tint flag = 1;\\n    \\t\\tif (divisor > 0){\\n    \\t\\t\\tflag = -flag;\\n    \\t\\t\\tdivisor = -divisor;\\n    \\t\\t}\\n    \\t\\tif (dividend > 0){\\n    \\t\\t\\tflag = -flag;\\n    \\t\\t\\tdividend = -dividend;\\n    \\t\\t}\\n    \\n    \\t\\tunsigned int acc = divisor, tmp = 0;\\n    \\t\\tint counter = 0, ans = 0;;\\n    \\t\\twhile (dividend <= divisor){\\n    \\t\\t\\tacc = divisor; tmp = 0, counter=0;\\n    \\t\\t\\twhile (acc >= dividend){\\n    \\t\\t\\t\\ttmp = acc;\\n    \\t\\t\\t\\tacc += acc;\\n    \\t\\t\\t\\tcounter++;\\n    \\t\\t\\t}\\n    \\t\\t\\tans += (counter > 0) ? 1 << (counter - 1) : 0;// 1*pow(2, counter-1)\\n    \\t\\t\\tdividend -= tmp;\\n    \\t\\t}\\n    \\t\\treturn flag*ans;\\n    \\t}\\n    };\\n\\nFirstly, let me give you some hints with the input:\\n\\nI.have you ever thought that dividend or divisor maybe negative or both;\\n\\nII.have you ever thought about this input{2^32-1, 1};\\n\\nIII.have you ever thought that there existing -2^32 meanwhile the largest int is 2^32-1;\\n\\n**Now is my thoughts:**\\n\\nConsidering the III hints I gave above, I played a trick that making dividend and divisor both negative, and using a flag judging the sign symbol of answer. **(ooops, i use * operator in the end of my code, but never mind, it's nothing to do with my algorithm)**\\n\\n1 I double the acc (initialize  acc=divisor) if acc <= dividend. Like 1, 2, 4, 8, 16...etc; Count the times I double the acc, storage in variable counter \\n\\n2.If acc >dividend, then dividend = dividend-acc/2;(can use / operator, i used extra variable tmp to storage the acc/2 ) . \\n\\n3. calculate how many time I double the  divisor: ans += (counter > 0) ? 1 << (counter - 1) : 0;// 1*pow(2, counter-1), **Then**, dividend-=tmp;\\n\\n4. Loop 1-3  while divisor<dividend**(remember I make them both negative)**\\n\\n \\n**The complexity** when the **worst** situation dividend = 2^32 -1 and divisor = 1;\\n\\ncomplexity = (lg dividend) + (lg dividend/2) + (lg dividend/4) + (lg dividend/8) + ...=(lg dividend)^2\\n\\nI don't know if there any problems in my proof.\\n\\n\\n**FOOL I AM, I CAN USE BINARY OPERATOR**\\n\\n        class Solution {\\n    public:\\n    \\tint divide(int dividend, int divisor) {\\n    \\t\\tlong long a = abs((long long)dividend);\\n    \\t\\tlong long b = abs((long long)divisor);\\n    \\t\\tint ans = 0, i = 0;\\n    \\t\\twhile (a > b){\\n    \\t\\t\\ti++;\\n    \\t\\t\\tb = b << 1;\\n    \\t\\t}\\n    \\t\\twhile (i >= 0){\\n    \\t\\t\\tif (a >= b){\\n    \\t\\t\\t\\ta -= b;\\n    \\t\\t\\t\\tans += (1 << i);\\n    \\t\\t\\t}\\n    \\t\\t\\tb = b >> 1;\\n    \\t\\t\\ti--;\\n    \\t\\t}\\n    \\n    \\t\\treturn (((dividend >> 31)==(divisor >> 31))) ? ans : -ans\\n    \\t}\\n    };\\n\\n \\n**It's more simple somehow**",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tint divide(int dividend, int divisor) {\\n    \\t\\tint flag = 1;\\n    \\t\\tif (divisor > 0){\\n    \\t\\t\\tflag = -flag;\\n    \\t\\t\\tdivisor = -divisor;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3654349,
                "title": "bits-of-python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        sign = -1 if (dividend >= 0 and divisor < 0) or (dividend < 0 and divisor >= 0) else 1\\n        dividend = abs(dividend)\\n        divisor = abs(divisor)\\n        result = len(range(0, dividend-divisor+1, divisor))\\n        if sign == -1:\\n            result = -result\\n        minus_limit = -(2**31)\\n        plus_limit = (2**31 - 1)\\n        result = min(max(result, minus_limit), plus_limit)\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        sign = -1 if (dividend >= 0 and divisor < 0) or (dividend < 0 and divisor >= 0) else 1\\n        dividend = abs(dividend)\\n        divisor = abs(divisor)\\n        result = len(range(0, dividend-divisor+1, divisor))\\n        if sign == -1:\\n            result = -result\\n        minus_limit = -(2**31)\\n        plus_limit = (2**31 - 1)\\n        result = min(max(result, minus_limit), plus_limit)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529137,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    long ans;\\n    public int divide(int dividend, int divisor) {\\n        ans=(long)dividend/(long)divisor;\\n        if(ans > (long)Math.pow(2,31)-1) ans = (long)Math.pow(2,31)-1;\\n        if(ans < (-1)*(long)Math.pow(2,31)) ans = (long)Math.pow(-2,31);\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    long ans;\\n    public int divide(int dividend, int divisor) {\\n        ans=(long)dividend/(long)divisor;\\n        if(ans > (long)Math.pow(2,31)-1) ans = (long)Math.pow(2,31)-1;\\n        if(ans < (-1)*(long)Math.pow(2,31)) ans = (long)Math.pow(-2,31);\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268612,
                "title": "easy-c-solution-beat-100-using-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        long long int s=1,e=abs(dividend),mid=0,ans=0;\\n        if (divisor == 0 || (dividend == INT_MIN && divisor == -1)) {\\n            return INT_MAX;\\n        }\\n          if (divisor == 0 || (dividend == INT_MIN && divisor == 1)) \\n            return INT_MIN;\\n        \\n        while(s<=e){\\n            mid=s+(e-s)/2;\\n            if(abs(divisor*mid)==abs(dividend))\\n            {\\n                ans=mid;\\n                break;\\n            }\\n            else if(abs(divisor*mid)>abs(dividend))\\n            e=mid-1;\\n            else\\n            {\\n                ans=mid;\\n                s=mid+1;\\n            }\\n        }\\n        if((divisor>0&&dividend>0)||(divisor<0&&dividend<0))\\n        return ans;\\n        else\\n        return -ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        long long int s=1,e=abs(dividend),mid=0,ans=0;\\n        if (divisor == 0 || (dividend == INT_MIN && divisor == -1)) {\\n            return INT_MAX;\\n        }\\n          if (divisor == 0 || (dividend == INT_MIN && divisor == 1)) \\n            return INT_MIN;\\n        \\n        while(s<=e){\\n            mid=s+(e-s)/2;\\n            if(abs(divisor*mid)==abs(dividend))\\n            {\\n                ans=mid;\\n                break;\\n            }\\n            else if(abs(divisor*mid)>abs(dividend))\\n            e=mid-1;\\n            else\\n            {\\n                ans=mid;\\n                s=mid+1;\\n            }\\n        }\\n        if((divisor>0&&dividend>0)||(divisor<0&&dividend<0))\\n        return ans;\\n        else\\n        return -ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033336,
                "title": "100-bit-manipulation-simple-explanation-no-long-usage",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nas we cant use multiplication & division and modulo operators , first thing that comes to mind is to maintain a variable quotient and substract divisor from dividend till it is greater or equal to it.\\nthis will take a lot of time but it is a accepted solution\\ncan we do it in better Time complexity ? \\'yes\\'\\nrather substracting the divisor linearly we can do it exponentially that is using left shift operator(1<<1 == 2 left is used to multiply any number by 2 in binary);\\nit is nothing but rather substracting 3 , 6 , 9 , 12 .... we gonna substract 3 , 6 , 12 , 24 , 48 ......\\n**hope you like the intution give a \\uD83D\\uDC4D to improve my profile**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- maintain a variable `quotient`.\\n- extract the resultant sign and typecast to `long` to avoid overflows.\\n- while `dividend is >= divisor` left shift the divisor till it is smaller than dividend.maintain number of leftshifts.\\n- substract dividend with the `divisor<<shift-1` as we shifted one extra bit. add number `1<<shifts-1` to quotient(number of times divisor is multiplied).\\n- return corresponding values for signs\\n# Complexity\\n- Time complexity:$$O(log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        long quotient = 0;\\n        int sign = 1;\\n        int max = Integer.MAX_VALUE,  min = Integer.MIN_VALUE;\\n        if(dividend < 0 && divisor > 0 || dividend > 0 && divisor < 0)sign = -1;\\n        long dd = (long)dividend , dv = (long)divisor;\\n        dd = Math.abs(dd);dv = Math.abs(dv);\\n        while(dd >= dv){\\n            int shift = 0;\\n            while(dd >= (dv<<shift))shift++;\\n            quotient += (long)1l<<(shift-1);\\n            // System.out.println(quotient+\"-\"+shift);\\n            dd -= dv<<(shift-1);\\n        }\\n        if(sign == 1){\\n            if(quotient > max)return max;\\n            return (int)quotient;\\n        }else{\\n            if((~quotient)+1 < min)return min; // ~quotient+1 = -quotient\\n            return (int)(~quotient)+1;\\n        }\\n    }\\n}\\n```\\n> we can store one bigger value in negetive numbers than positive numbers so this is an asset here to avoid using long, as question clearly says the environment can only store 32 bit integers.\\n- rather performing division of positive values we can do it with negative values and even quotient also can be integer.\\n\\n**Note : while rightshifting the divisor check for overflow.**\\n### updated code:\\n```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        // System.out.println(-2147483648<<3);\\n        // System.out.println(Integer.toBinaryString(-1<<0));\\n        int quotient = 0;\\n        int sign = 1;\\n        int max = Integer.MAX_VALUE,  min = Integer.MIN_VALUE;\\n        if(dividend < 0 && divisor > 0 || dividend > 0 && divisor < 0)sign = -1;\\n        if(dividend > 0)dividend = -dividend;\\n        if(divisor > 0)divisor = -divisor;\\n        while(dividend <= divisor){\\n            int shift = 1;\\n            while((divisor<<shift) < divisor && dividend <= (divisor<<shift))shift++;\\n            quotient -= 1<<(shift-1);\\n            // System.out.println(quotient+\"-\"+shift);\\n            dividend -= divisor<<(shift-1);\\n        }\\n        if(sign == 1){\\n            if(quotient == min)return max;\\n            return -quotient;\\n        }else{\\n            return quotient;\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        long quotient = 0;\\n        int sign = 1;\\n        int max = Integer.MAX_VALUE,  min = Integer.MIN_VALUE;\\n        if(dividend < 0 && divisor > 0 || dividend > 0 && divisor < 0)sign = -1;\\n        long dd = (long)dividend , dv = (long)divisor;\\n        dd = Math.abs(dd);dv = Math.abs(dv);\\n        while(dd >= dv){\\n            int shift = 0;\\n            while(dd >= (dv<<shift))shift++;\\n            quotient += (long)1l<<(shift-1);\\n            // System.out.println(quotient+\"-\"+shift);\\n            dd -= dv<<(shift-1);\\n        }\\n        if(sign == 1){\\n            if(quotient > max)return max;\\n            return (int)quotient;\\n        }else{\\n            if((~quotient)+1 < min)return min; // ~quotient+1 = -quotient\\n            return (int)(~quotient)+1;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        // System.out.println(-2147483648<<3);\\n        // System.out.println(Integer.toBinaryString(-1<<0));\\n        int quotient = 0;\\n        int sign = 1;\\n        int max = Integer.MAX_VALUE,  min = Integer.MIN_VALUE;\\n        if(dividend < 0 && divisor > 0 || dividend > 0 && divisor < 0)sign = -1;\\n        if(dividend > 0)dividend = -dividend;\\n        if(divisor > 0)divisor = -divisor;\\n        while(dividend <= divisor){\\n            int shift = 1;\\n            while((divisor<<shift) < divisor && dividend <= (divisor<<shift))shift++;\\n            quotient -= 1<<(shift-1);\\n            // System.out.println(quotient+\"-\"+shift);\\n            dividend -= divisor<<(shift-1);\\n        }\\n        if(sign == 1){\\n            if(quotient == min)return max;\\n            return -quotient;\\n        }else{\\n            return quotient;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2644837,
                "title": "easy-c-solution-faster-than-100-00-of-c-online-submissions",
                "content": "\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t*Please Upvote If You Find It Helpful.*\\n\\n\\t int divide(int dividend, int divisor) {\\n\\t\\t\\tif(divisor==-1 && dividend == INT_MIN)\\n\\t\\t\\t\\treturn INT_MAX;\\n\\t\\t\\tbool sign = (dividend>=0) == (divisor>=0) ? true : false;\\n\\t\\t\\tlong int did = abs(dividend);\\n\\t\\t\\tlong int div = abs(divisor);\\n\\t\\t\\tlong int result=0;\\n\\t\\t\\t// int count=0, temp=divisor;\\n\\t\\t\\twhile(did - div >= 0){\\n\\t\\t\\t\\tint count=0;\\n\\t\\t\\t\\twhile((did - (div<<1<<count))>=0)\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tresult += 1<<count;\\n\\t\\t\\t\\tdid -= div<<count;\\n\\t\\t\\t}\\n\\t\\t\\treturn sign ? result : -result;\\n\\t\\t}",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t*Please Upvote If You Find It Helpful.*\\n\\n\\t int divide(int dividend, int divisor) {\\n\\t\\t\\tif(divisor==-1 && dividend == INT_MIN)\\n\\t\\t\\t\\treturn INT_MAX;\\n\\t\\t\\tbool sign = (dividend>=0) == (divisor>=0) ? true : false;\\n\\t\\t\\tlong int did = abs(dividend);\\n\\t\\t\\tlong int div = abs(divisor);\\n\\t\\t\\tlong int result=0;\\n\\t\\t\\t// int count=0, temp=divisor;\\n\\t\\t\\twhile(did - div >= 0){\\n\\t\\t\\t\\tint count=0;\\n\\t\\t\\t\\twhile((did - (div<<1<<count))>=0)\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tresult += 1<<count;\\n\\t\\t\\t\\tdid -= div<<count;\\n\\t\\t\\t}\\n\\t\\t\\treturn sign ? result : -result;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2350079,
                "title": "java-solution",
                "content": "\\n    public int divide(int dividend, int divisor) {\\n        \\n\\t\\t//edge case ( we cant have quotient 2^31 ) since -2^31 / -1 gives 2^31 ( overflow case)  \\n        if (Integer.MIN_VALUE == dividend && divisor == -1) {\\n            return Integer.MAX_VALUE;\\n        }\\n\\t\\t\\n        int a = Math.abs(dividend);\\n        int b = Math.abs(divisor);\\n        int quo = 0;\\n        while (a - b >= 0) {\\n            int x = 0;\\n            while (a - ((b << 1) << x) >= 0) {\\n                x++;\\n            }\\n            quo += 1 << x;\\n            a -= b << x;\\n        }\\n\\t\\t\\n\\t\\t//both +ve or both -ve (dividend  and divisor) should return quo as it is else with a -ve sign\\n          if ((dividend >= 0) == (divisor >= 0)) {\\n            return quo;\\n        } else {\\n            return -1 * quo;\\n        }\\n\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public int divide(int dividend, int divisor) {\\n        \\n\\t\\t//edge case ( we cant have quotient 2^31 ) since -2^31 / -1 gives 2^31 ( overflow case)  \\n        if (Integer.MIN_VALUE == dividend && divisor == -1) {\\n            return Integer.MAX_VALUE;\\n        }\\n\\t\\t\\n        int a = Math.abs(dividend);\\n        int b = Math.abs(divisor);\\n        int quo = 0;\\n        while (a - b >= 0) {\\n            int x = 0;\\n            while (a - ((b << 1) << x) >= 0) {\\n                x++;\\n            }\\n            quo += 1 << x;\\n            a -= b << x;\\n        }\\n\\t\\t\\n\\t\\t//both +ve or both -ve (dividend  and divisor) should return quo as it is else with a -ve sign\\n          if ((dividend >= 0) == (divisor >= 0)) {\\n            return quo;\\n        } else {\\n            return -1 * quo;\\n        }\\n\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2091391,
                "title": "c-bit-manipulation-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int divide(int a, int b) {\\n        if(a == INT_MIN and b == -1) return INT_MAX;\\n        long num = labs(a), div = labs(b), ans = 0;\\n        long temp = div, m=1;\\n        int sign = a > 0 ^ b > 0 ? -1 : 1;\\n\\n        while(num >= div){\\n            if(temp <= num){\\n                temp <<= 1;\\n                m <<= 1;\\n            }\\n            else{\\n                ans += m >> 1;\\n                num -= temp >> 1;\\n                temp = div;\\n                m = 1;\\n            }\\n        }\\n        \\n        return sign*ans;\\n    }\\n};\\n```\\nDo consider upvoting if found useful :)",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divide(int a, int b) {\\n        if(a == INT_MIN and b == -1) return INT_MAX;\\n        long num = labs(a), div = labs(b), ans = 0;\\n        long temp = div, m=1;\\n        int sign = a > 0 ^ b > 0 ? -1 : 1;\\n\\n        while(num >= div){\\n            if(temp <= num){\\n                temp <<= 1;\\n                m <<= 1;\\n            }\\n            else{\\n                ans += m >> 1;\\n                num -= temp >> 1;\\n                temp = div;\\n                m = 1;\\n            }\\n        }\\n        \\n        return sign*ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2090270,
                "title": "easy-to-understand-c-beats-100",
                "content": "**Pls upvote the thread if you found it helpful.**\\n\\t\\t\\n\\tint divide(int dividend, int divisor) {\\n\\t\\t\\t//Edge cases\\n\\t\\t\\tif(dividend == INT_MIN && divisor == -1) return INT_MAX;\\n\\t\\t\\tif(dividend == INT_MIN && divisor == 1) return INT_MIN;\\n\\n\\t\\t\\t//Absolute\\n\\t\\t\\tlong int dd = abs(dividend), dv = abs(divisor);\\n\\t\\t\\t\\n\\t\\t\\t//Result\\n\\t\\t\\tint res =0;\\n\\t\\t\\twhile(dv<=dd){\\n\\t\\t\\t\\tlong int mul=dv,temp=1;\\n\\t\\t\\t\\twhile(mul<=dd-mul){\\n\\t\\t\\t\\t\\tmul+=mul;\\n\\t\\t\\t\\t\\ttemp+=temp;\\n\\t\\t\\t\\t}\\n\\t\\t\\tres+=temp;\\n\\t\\t\\tdd-=mul;\\n\\t\\t}\\n\\t\\t\\t//If dividend or divisor < 0 res will be -ve\\n\\t\\t\\t if((dividend<0&&divisor>0) || (dividend>0&&divisor<0)) return -res;\\n\\n\\t\\t\\treturn res;\\n\\t\\t}",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "**Pls upvote the thread if you found it helpful.**\\n\\t\\t\\n\\tint divide(int dividend, int divisor) {\\n\\t\\t\\t//Edge cases\\n\\t\\t\\tif(dividend == INT_MIN && divisor == -1) return INT_MAX;\\n\\t\\t\\tif(dividend == INT_MIN && divisor == 1) return INT_MIN;\\n\\n\\t\\t\\t//Absolute\\n\\t\\t\\tlong int dd = abs(dividend), dv = abs(divisor);\\n\\t\\t\\t\\n\\t\\t\\t//Result\\n\\t\\t\\tint res =0;\\n\\t\\t\\twhile(dv<=dd){\\n\\t\\t\\t\\tlong int mul=dv,temp=1;\\n\\t\\t\\t\\twhile(mul<=dd-mul){\\n\\t\\t\\t\\t\\tmul+=mul;\\n\\t\\t\\t\\t\\ttemp+=temp;\\n\\t\\t\\t\\t}\\n\\t\\t\\tres+=temp;\\n\\t\\t\\tdd-=mul;\\n\\t\\t}\\n\\t\\t\\t//If dividend or divisor < 0 res will be -ve\\n\\t\\t\\t if((dividend<0&&divisor>0) || (dividend>0&&divisor<0)) return -res;\\n\\n\\t\\t\\treturn res;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2089466,
                "title": "c-do-binary-removals-explainations",
                "content": "Dividing b/a means number of times we can remove a from b \\nb - a -a - a- a- a ............k time\\nb - k*a\\n\\nInstead of removing a one by one , we can remove it in groups. How?\\nany number k , can be written in the form of 2\\'s powers. So the algorithm will be:\\nWe solve the problem for positive dividend and divisior only and then decide the sign\\n1. Iterate from i=31 to 0, and try to remove the biggestpower * divisor\\n2. If it is removable, add it to the quotient and remove from dividend . Here adding and | is same as adding 2\\'s powers will give same ans as using or operator in binary\\n3. Use long long as during multiplication the values may overflow\\n4. In the end check the limits specified by the question.\\n\\n```\\nclass Solution {\\npublic:\\n    int divide(int x, int y) {\\n        int sign = ((x<0)^(y<0))?-1:+1;\\n        long long dividend = x, divisor=y,q=0;\\n        dividend=abs(dividend), divisor = abs(divisor);\\n        for(int i=31;i>=0;i--){\\n            if((divisor<<i) > dividend) continue;  \\n            q |= (1LL<<i);\\n            dividend -=  (divisor<<i);\\n        }\\n        q*=sign;\\n        if(q<0 and q<INT_MIN) q=INT_MIN;\\n        if(q>0 and q>INT_MAX) q=INT_MAX;\\n        return q;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int divide(int x, int y) {\\n        int sign = ((x<0)^(y<0))?-1:+1;\\n        long long dividend = x, divisor=y,q=0;\\n        dividend=abs(dividend), divisor = abs(divisor);\\n        for(int i=31;i>=0;i--){\\n            if((divisor<<i) > dividend) continue;  \\n            q |= (1LL<<i);\\n            dividend -=  (divisor<<i);\\n        }\\n        q*=sign;\\n        if(q<0 and q<INT_MIN) q=INT_MIN;\\n        if(q>0 and q>INT_MAX) q=INT_MAX;\\n        return q;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089279,
                "title": "python-solution",
                "content": "*I am a bit unsure about the complexity of my solution but I think it is O(n) with n being the length of dividend,\\nplease feel free to confirm.\\nPython is not my main language, there\\'s probably some part of my code that you could write in a more elegant\\nand more readable way, same here, feel free to let me know.*\\n\\n**Full solution:**\\n\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n\\t\\tsign = 1\\n        if (dividend < 0 and divisor > 0) or (dividend > 0 and divisor < 0):\\n            sign = -1\\n        if dividend < 0 :\\n            dividend = dividend - dividend - dividend\\n        if divisor < 0:\\n            divisor = divisor - divisor - divisor\\n            \\n        if divisor == 1 :\\n            return self.handleResult(sign * dividend)\\n       \\n        result = 0\\n        while dividend >= divisor:\\n            toSubstract, quotient = self.computeIteration(dividend, divisor)\\n            dividend -= toSubstract\\n            result += quotient\\n\\n        \\n        return self.handleResult(sign * result)\\n    \\n    def handleResult(self, result):\\n        if result < pow(-2, 31):\\n            return pow(-2, 31)\\n        if result > pow(2, 31) - 1:\\n            return pow(2, 31) - 1\\n        return result\\n    \\n    def computeIteration(self, dividend, divisor):\\n        dividendStr = str(dividend)\\n        divisorStr = str(divisor)\\n        numberOfZeros = len(dividendStr) - len(divisorStr)\\n        if int(dividendStr[0:len(divisorStr)]) < divisor:\\n            numberOfZeros -= 1\\n        return int(divisorStr + \\'0\\' * numberOfZeros), int(\\'1\\' + \\'0\\' * numberOfZeros)\\n```\\n\\n**Step by step:**\\n* First handling the sign of the result and getting rid of `-` signs for simplicity (**EDIT** : **USE OF MULTIPLICATION**, see next ):\\n\\n```\\n\\t\\tsign = 1\\n        if dividend < 0 :\\n            sign *= -1\\n            dividend *= -1\\n        if divisor < 0 :\\n            sign *= -1\\n            divisor *= -1\\n```\\n**EDIT** Thanks to @mihir_jr comment, finding absolute value without multiplication:\\n\\t\\t\\t\\n```\\nsign = 1\\nif (dividend < 0 and divisor > 0) or (dividend > 0 and divisor < 0):\\n\\tsign = -1\\nif dividend < 0 :\\n\\tdividend = dividend - dividend - dividend\\nif divisor < 0:\\n\\tdivisor = divisor - divisor - divisor\\n```\\n\\n* This part is optional, just handling simple `-1 / 1` divisor case:\\n```\\nif divisor == 1 :\\n            return self.handleResult(sign * dividend)\\n```\\n\\n* All our result will for through this function before being returned, to handle `-2^31 / 2^31 - 1` result cases:\\n\\n```\\ndef handleResult(self, result):\\n        if result < pow(-2, 31):\\n            return pow(-2, 31)\\n        if result > pow(2, 31) - 1:\\n            return pow(2, 31) - 1\\n        return result\\n```\\n\\n* This is the main part of the solution: \\n\\n```\\ndef computeIteration(self, dividend, divisor):\\n        dividendStr = str(dividend)\\n        divisorStr = str(divisor)\\n        numberOfZeros = len(dividendStr) - len(divisorStr)\\n        if int(dividendStr[0:len(divisorStr)]) < divisor:\\n            numberOfZeros -= 1\\n        return int(divisorStr + \\'0\\' * numberOfZeros), int(\\'1\\' + \\'0\\' * numberOfZeros)\\n```\\n\\nWe determine the maximum number of zeros our quotient can have.\\nWe return this quotient to be added to the result and the `divisor` concatenated to the computed number of zeros which we will substract to dividend for the next loop round.\\n\\n```\\nresult = 0\\nwhile dividend >= divisor:\\n\\ttoSubstract, quotient = self.computeIteration(dividend, divisor)\\n\\tdividend -= toSubstract\\n\\tresult += quotient\\n\\nreturn self.handleResult(sign * result)\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n\\t\\tsign = 1\\n        if (dividend < 0 and divisor > 0) or (dividend > 0 and divisor < 0):\\n            sign = -1\\n        if dividend < 0 :\\n            dividend = dividend - dividend - dividend\\n        if divisor < 0:\\n            divisor = divisor - divisor - divisor\\n            \\n        if divisor == 1 :\\n            return self.handleResult(sign * dividend)\\n       \\n        result = 0\\n        while dividend >= divisor:\\n            toSubstract, quotient = self.computeIteration(dividend, divisor)\\n            dividend -= toSubstract\\n            result += quotient\\n\\n        \\n        return self.handleResult(sign * result)\\n    \\n    def handleResult(self, result):\\n        if result < pow(-2, 31):\\n            return pow(-2, 31)\\n        if result > pow(2, 31) - 1:\\n            return pow(2, 31) - 1\\n        return result\\n    \\n    def computeIteration(self, dividend, divisor):\\n        dividendStr = str(dividend)\\n        divisorStr = str(divisor)\\n        numberOfZeros = len(dividendStr) - len(divisorStr)\\n        if int(dividendStr[0:len(divisorStr)]) < divisor:\\n            numberOfZeros -= 1\\n        return int(divisorStr + \\'0\\' * numberOfZeros), int(\\'1\\' + \\'0\\' * numberOfZeros)\\n```\n```\\n\\t\\tsign = 1\\n        if dividend < 0 :\\n            sign *= -1\\n            dividend *= -1\\n        if divisor < 0 :\\n            sign *= -1\\n            divisor *= -1\\n```\n```\\nsign = 1\\nif (dividend < 0 and divisor > 0) or (dividend > 0 and divisor < 0):\\n\\tsign = -1\\nif dividend < 0 :\\n\\tdividend = dividend - dividend - dividend\\nif divisor < 0:\\n\\tdivisor = divisor - divisor - divisor\\n```\n```\\nif divisor == 1 :\\n            return self.handleResult(sign * dividend)\\n```\n```\\ndef handleResult(self, result):\\n        if result < pow(-2, 31):\\n            return pow(-2, 31)\\n        if result > pow(2, 31) - 1:\\n            return pow(2, 31) - 1\\n        return result\\n```\n```\\ndef computeIteration(self, dividend, divisor):\\n        dividendStr = str(dividend)\\n        divisorStr = str(divisor)\\n        numberOfZeros = len(dividendStr) - len(divisorStr)\\n        if int(dividendStr[0:len(divisorStr)]) < divisor:\\n            numberOfZeros -= 1\\n        return int(divisorStr + \\'0\\' * numberOfZeros), int(\\'1\\' + \\'0\\' * numberOfZeros)\\n```\n```\\nresult = 0\\nwhile dividend >= divisor:\\n\\ttoSubstract, quotient = self.computeIteration(dividend, divisor)\\n\\tdividend -= toSubstract\\n\\tresult += quotient\\n\\nreturn self.handleResult(sign * result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957404,
                "title": "java-100-faster-bit-manipulation-solution",
                "content": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == 1<<31 && divisor == -1){\\n            return Integer.MAX_VALUE;\\n        }\\n        boolean sign = (dividend >= 0) == (divisor >= 0) ? true : false;\\n        \\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n        \\n        int result = 0;\\n        while(dividend - divisor >= 0){\\n            int count = 0;\\n            while(dividend - (divisor << 1 << count) >= 0){\\n                count++;\\n            }\\n            result += 1 <<count;\\n            dividend -= divisor << count;\\n        }\\n        return sign ? result : -result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == 1<<31 && divisor == -1){\\n            return Integer.MAX_VALUE;\\n        }\\n        boolean sign = (dividend >= 0) == (divisor >= 0) ? true : false;\\n        \\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n        \\n        int result = 0;\\n        while(dividend - divisor >= 0){\\n            int count = 0;\\n            while(dividend - (divisor << 1 << count) >= 0){\\n                count++;\\n            }\\n            result += 1 <<count;\\n            dividend -= divisor << count;\\n        }\\n        return sign ? result : -result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888339,
                "title": "cpp-0ms-100",
                "content": "```\\n/*\\n    childhood method:\\n     3) 10 (2\\n         6\\n    _________\\n       3)4(\\n         3\\n    __________\\n       3)1(\\n       \\n      same here too \\n      first we will remove maximum 2 multiple of divisor\\n      example: 10 3\\n      3 6 12 24  ---doubling each time\\n      so we can subtract 6 from 10 so we remainded with 10-6=>4  add 2 to result\\n      3 6 ..  \\n      so we can subtract 3 from 4 so remainded with 4-3=>1 add 1 to result\\n      \\n      2<<1 ==>4\\n      if we left shift 1 bit it indicates we are multiplying num by\\'2\\'\\n      \\n     \\n      \\n    */\\n    int divide(int dividend, int divisor) {\\n        if(dividend==INT_MIN&&divisor==-1)return INT_MAX;\\n        bool sign= ((dividend>=0)==(divisor>=0))?true:false;\\n        long int res=0;\\n        long int ldividend=abs(dividend);\\n        long int ldivisor=abs(divisor);\\n        while((ldividend-ldivisor)>=0){\\n            int cnt=0;\\n            while(ldividend>=(ldivisor<<cnt))cnt++;\\n            res+=(1<<(cnt-1));\\n            ldividend-=ldivisor<<(cnt-1);\\n        }\\n        if(res>INT_MAX) return (sign)?INT_MAX:INT_MIN;\\n        return (sign)?res:-res;\\n    }",
                "solutionTags": [],
                "code": "```\\n/*\\n    childhood method:\\n     3) 10 (2\\n         6\\n    _________\\n       3)4(\\n         3\\n    __________\\n       3)1(\\n       \\n      same here too \\n      first we will remove maximum 2 multiple of divisor\\n      example: 10 3\\n      3 6 12 24  ---doubling each time\\n      so we can subtract 6 from 10 so we remainded with 10-6=>4  add 2 to result\\n      3 6 ..  \\n      so we can subtract 3 from 4 so remainded with 4-3=>1 add 1 to result\\n      \\n      2<<1 ==>4\\n      if we left shift 1 bit it indicates we are multiplying num by\\'2\\'\\n      \\n     \\n      \\n    */\\n    int divide(int dividend, int divisor) {\\n        if(dividend==INT_MIN&&divisor==-1)return INT_MAX;\\n        bool sign= ((dividend>=0)==(divisor>=0))?true:false;\\n        long int res=0;\\n        long int ldividend=abs(dividend);\\n        long int ldivisor=abs(divisor);\\n        while((ldividend-ldivisor)>=0){\\n            int cnt=0;\\n            while(ldividend>=(ldivisor<<cnt))cnt++;\\n            res+=(1<<(cnt-1));\\n            ldividend-=ldivisor<<(cnt-1);\\n        }\\n        if(res>INT_MAX) return (sign)?INT_MAX:INT_MIN;\\n        return (sign)?res:-res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1846693,
                "title": "c-0ms-solution-that-follows-all-constraints-explained",
                "content": "Constraints:\\n- \"Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1].\" This means **no long long or unsigned int**.\\n- \"If the quotient is strictly greater than 2^31 - 1, then return 2^31 - 1, and if the quotient is strictly less than -2^31, then return -2^31.\"\\n- No multiplication, division, or mod operator.\\n\\n```\\n    int int_min = -2147483648, int_max = 2147483647;\\n    \\n    int divide(int dividend, int divisor) {\\n        \\n        // edge cases (dividend or divisor is int_min)\\n        if(dividend == int_min) {\\n            if(divisor == -1) {return int_max;}\\n            else if(divisor == int_min) {return 1;}\\n            else if(divisor < 0) {\\n                // do this so we can avoid abs(dividend) overflowing the upper int limit\\n                return 1 + divide(dividend - divisor, divisor);\\n            }\\n            else {\\n                // same as above comment\\n                return -1 + divide(dividend + divisor, divisor);\\n            }\\n        }\\n        else if(divisor == int_min) {return 0;}\\n        \\n        // take care of negative later\\n        bool neg = (dividend < 0) ^ (divisor < 0); // final answer is negative if either dividend or divisor is negative\\n        dividend = abs(dividend); divisor = abs(divisor); // change both to positive\\n        \\n        int result = 0;\\n        for(int i = 31; i >= 0; --i) {\\n            int shifted_dividend = (dividend >> i); // = floor(dividend / 2^i)\\n            if(shifted_dividend >= divisor) { // then divisor * 2^i <= dividend\\n                result += (1 << i);\\n                dividend -= (divisor << i);\\n            }\\n        }\\n        \\n        return (neg ? -result : result);\\n    }\\n```\\n\\t\\nThe general idea is similar to many others. We change both the dividend and divisor to positive and then add in the negative sign at the end if needed. But firstly, we have a few edge cases:\\n- If dividend = int_min and divisor = -1, then the actual result of the divison would be -int_min, oer +2147483648. But this overflows int_max, so we just return int_max in this case.\\n- If dividend = int_min and divisor = int_min, then return 1.\\n- Even if the above two cases do not happen, we still need to modify dividend. The reason is if dividend = int_min, then abs(dividend) would overflow int_max, so we can\\'t allow this to happen. I take care of this by simply subtracting or adding one divisor from dividend, based on the sign of divisor. If you don\\'t understand this, consider the following logic: The quotient when 10000 is divided by 3 is also equal to 1 + the quotient of 9997 / 3. We basically remove one instance of divisor from the dividend so that abs(dividend) no longer overflows. \\n- If none of the above happens (basically, if dividend != int_min), but divisor is int_min, then obviously the correct quotient is `0`.\\n\\nWithout multiplication, division, or modulo operators, the only way we can do this is through **bit shift operators**. But more specifically, this program mainly relies on the **binary right shift (>>)** operator, because this helps us avoid overflow. This loop is the main part of the program:\\n\\n```\\nint result = 0;\\nfor(int i = 31; i >= 0; --i) {\\n\\tint shifted_dividend = (dividend >> i); // = floor(dividend / 2^i)\\n\\tif(shifted_dividend >= divisor) { // then divisor * 2^i <= dividend\\n\\t\\tresult += (1 << i);\\n\\t\\tdividend -= (divisor << i);\\n\\t}\\n}\\n```\\n\\nWhat happens here is the following.\\n- Loop from the most significant bit to the least significant bit in a 32-bit number. For each bit, we determine if the final quotient (result) should have this bit set or not. How do we decide this for each position i? Just do the following:\\n- Let ```shifted_dividend = (dividend >> i)```, which is the quotient of dividend / 2^i. Basically this is just how many times 2^i can go into dividend. Now, obviously, if 2^i can go into dividend at least ```divisor``` times, then we know that ```divisor * 2^i <= dividend```, which means that we should add 2^i to the quotient, and subtract ```divisor * 2^i``` from ```dividend```!\\n- Notice how ```(dividend >> i)``` never overflows, since it must result in a number smaller than ```dividend```. Also, it never becomes negative; if `i` too large, then ```(dividend >> i)``` would just equal `0`. This fits up with the conceptual definition that this is the number of times 2^i can go into ```dividend```.\\n- Obviously, we return ```result```, and make sure to take care of whether it\\'s negative or positive.\\n\\n**Note about C++ Undefined Behavior:** Right-shifting a negative signed integer is undefined behavior, but right-shifting a positive signed integer isn\\'t. cppreference.com says that \"For unsigned a and for signed and non-negative a, the value of a >> b is the integer part of a/2^b.\" This is one of the main reasons why we choose to change both numbers to positive before finding the quotient (and only adding the negative sign at the very end).",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int int_min = -2147483648, int_max = 2147483647;\\n    \\n    int divide(int dividend, int divisor) {\\n        \\n        // edge cases (dividend or divisor is int_min)\\n        if(dividend == int_min) {\\n            if(divisor == -1) {return int_max;}\\n            else if(divisor == int_min) {return 1;}\\n            else if(divisor < 0) {\\n                // do this so we can avoid abs(dividend) overflowing the upper int limit\\n                return 1 + divide(dividend - divisor, divisor);\\n            }\\n            else {\\n                // same as above comment\\n                return -1 + divide(dividend + divisor, divisor);\\n            }\\n        }\\n        else if(divisor == int_min) {return 0;}\\n        \\n        // take care of negative later\\n        bool neg = (dividend < 0) ^ (divisor < 0); // final answer is negative if either dividend or divisor is negative\\n        dividend = abs(dividend); divisor = abs(divisor); // change both to positive\\n        \\n        int result = 0;\\n        for(int i = 31; i >= 0; --i) {\\n            int shifted_dividend = (dividend >> i); // = floor(dividend / 2^i)\\n            if(shifted_dividend >= divisor) { // then divisor * 2^i <= dividend\\n                result += (1 << i);\\n                dividend -= (divisor << i);\\n            }\\n        }\\n        \\n        return (neg ? -result : result);\\n    }\\n```\n```\\nint result = 0;\\nfor(int i = 31; i >= 0; --i) {\\n\\tint shifted_dividend = (dividend >> i); // = floor(dividend / 2^i)\\n\\tif(shifted_dividend >= divisor) { // then divisor * 2^i <= dividend\\n\\t\\tresult += (1 << i);\\n\\t\\tdividend -= (divisor << i);\\n\\t}\\n}\\n```\n```shifted_dividend = (dividend >> i)```\n```divisor```\n```divisor * 2^i <= dividend```\n```divisor * 2^i```\n```dividend```\n```(dividend >> i)```\n```dividend```\n```(dividend >> i)```\n```dividend```\n```result```",
                "codeTag": "Unknown"
            },
            {
                "id": 1826773,
                "title": "my-o-1-solution-in-c",
                "content": "It\\'s been 15 years since I wrote C, please a gentle...\\n\\nHere\\'s my implementation based on the long division algorithm everyone learned in grade school.  It uses only 32 bit types and no multiplication or division, including in the standard library.\\n\\nThe solution is O(1) for 32 bit types, because it always loops exactly 32 times, one for each significant bit.  There\\'s probably opportunities to use bitwise math to speed up the loop body, and the loop itself could be unrolled.\\n\\n```\\n// Glibc\\'s implementation of abs uses multiplication for negative numbers and is undefined for\\n// INT_MIN as per the standard, because the return type is also a signed integer.\\ninline uint32_t uabs(int i)\\n{\\n    return i < 0 ? ~(uint32_t) i + 1 : i;\\n}\\n\\nint divide(int dividend, int divisor) {\\n    // Get rid of signs because bitwise math is easier with positive numbers\\n    uint32_t remainder = uabs(dividend);\\n    uint32_t positiveDivisor = uabs(divisor);\\n    \\n    // Long division algorithm everyone learned in grade school, except in binary instead of decimal\\n    uint32_t result = 0;\\n    for (int i = 31; i >= 0; --i) {\\n        uint32_t curDividend = remainder >> i;\\n        if (curDividend >= positiveDivisor) {\\n            result += 1u << i;\\n            remainder -= positiveDivisor << i;\\n        }\\n    }\\n    \\n    // Reintroduce the sign as appropriate\\n    if ((dividend > 0 && divisor > 0) || (dividend < 0 && divisor < 0)) {\\n        return result >= (uint32_t) INT_MAX ? INT_MAX : (int) result;\\n    }\\n    else {\\n        // Invert bits and add one instead of multiplying by -1\\n        return result > (uint32_t) INT_MAX ? INT_MIN : ((int) ~result) + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// Glibc\\'s implementation of abs uses multiplication for negative numbers and is undefined for\\n// INT_MIN as per the standard, because the return type is also a signed integer.\\ninline uint32_t uabs(int i)\\n{\\n    return i < 0 ? ~(uint32_t) i + 1 : i;\\n}\\n\\nint divide(int dividend, int divisor) {\\n    // Get rid of signs because bitwise math is easier with positive numbers\\n    uint32_t remainder = uabs(dividend);\\n    uint32_t positiveDivisor = uabs(divisor);\\n    \\n    // Long division algorithm everyone learned in grade school, except in binary instead of decimal\\n    uint32_t result = 0;\\n    for (int i = 31; i >= 0; --i) {\\n        uint32_t curDividend = remainder >> i;\\n        if (curDividend >= positiveDivisor) {\\n            result += 1u << i;\\n            remainder -= positiveDivisor << i;\\n        }\\n    }\\n    \\n    // Reintroduce the sign as appropriate\\n    if ((dividend > 0 && divisor > 0) || (dividend < 0 && divisor < 0)) {\\n        return result >= (uint32_t) INT_MAX ? INT_MAX : (int) result;\\n    }\\n    else {\\n        // Invert bits and add one instead of multiplying by -1\\n        return result > (uint32_t) INT_MAX ? INT_MIN : ((int) ~result) + 1;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1696904,
                "title": "100-faster-java-solution",
                "content": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == Integer.MIN_VALUE && divisor==-1) return Integer.MAX_VALUE;\\n        boolean sign = dividend>0 ^ divisor>0 ? true : false;\\n        int q = 0;\\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n        while(dividend - divisor >= 0) {\\n            int temp = divisor;\\n            int c=0;\\n            while (dividend - temp >= 0) {\\n                temp = temp << 1;\\n                c++;\\n            }\\n            temp = divisor;\\n            dividend = dividend - (temp << c-1);\\n            q += 1 << c-1;\\n        }\\n\\n        if(sign) return -q;\\n        return q;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == Integer.MIN_VALUE && divisor==-1) return Integer.MAX_VALUE;\\n        boolean sign = dividend>0 ^ divisor>0 ? true : false;\\n        int q = 0;\\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n        while(dividend - divisor >= 0) {\\n            int temp = divisor;\\n            int c=0;\\n            while (dividend - temp >= 0) {\\n                temp = temp << 1;\\n                c++;\\n            }\\n            temp = divisor;\\n            dividend = dividend - (temp << c-1);\\n            q += 1 << c-1;\\n        }\\n\\n        if(sign) return -q;\\n        return q;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1691917,
                "title": "c-solution-using-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        long long ans = 0;\\n        bool cneg = false;\\n        if((dividend<0 && divisor>0) || (dividend>0 && divisor<0)){\\n            cneg = true;\\n        }\\n        long long divid = abs(dividend);\\n        long long divis = abs(divisor);\\n        if((dividend == INT_MAX && divisor==1) ||(dividend == INT_MIN && divisor==-1)){\\n            return INT_MAX;\\n        }\\n        if((dividend == INT_MIN && divisor == 1) || (dividend == INT_MAX && divisor==-1)){\\n            return INT_MIN;\\n        }\\n        int count = 1;\\n        if(divid-divis<0){\\n            return 0;\\n        }\\n        divid-=divis;\\n        ans = 1;\\n        while(divid-divis >= 0){\\n            divid-=divis;\\n            divis = divis<<1;\\n            ans+=count;\\n            count = count<<1;\\n        }\\n        divisor = abs(divisor);\\n        while(divid-divisor>=0){\\n            ans++;\\n            divid-=divisor;\\n            \\n        }\\n        return cneg ? (-1*ans) : ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        long long ans = 0;\\n        bool cneg = false;\\n        if((dividend<0 && divisor>0) || (dividend>0 && divisor<0)){\\n            cneg = true;\\n        }\\n        long long divid = abs(dividend);\\n        long long divis = abs(divisor);\\n        if((dividend == INT_MAX && divisor==1) ||(dividend == INT_MIN && divisor==-1)){\\n            return INT_MAX;\\n        }\\n        if((dividend == INT_MIN && divisor == 1) || (dividend == INT_MAX && divisor==-1)){\\n            return INT_MIN;\\n        }\\n        int count = 1;\\n        if(divid-divis<0){\\n            return 0;\\n        }\\n        divid-=divis;\\n        ans = 1;\\n        while(divid-divis >= 0){\\n            divid-=divis;\\n            divis = divis<<1;\\n            ans+=count;\\n            count = count<<1;\\n        }\\n        divisor = abs(divisor);\\n        while(divid-divisor>=0){\\n            ans++;\\n            divid-=divisor;\\n            \\n        }\\n        return cneg ? (-1*ans) : ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1560454,
                "title": "python-easy-solution-faster-than-98",
                "content": "\\tclass Solution:\\n\\t\\tdef divide(self, dividend: int, divisor: int) -> int:\\n\\t\\t\\tif dividend == 0:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tsign = 1 if ((dividend < 0) ^ (divisor < 0)) else 0\\n\\t\\t\\tdividend = abs(dividend)\\n\\t\\t\\tdivisor = abs(divisor)\\n\\t\\t\\tres = 0\\n\\t\\t\\twhile dividend >= divisor:\\n\\t\\t\\t\\tk = 0\\n\\t\\t\\t\\twhile dividend >= divisor << (k+1):\\n\\t\\t\\t\\t\\tk += 1\\n\\t\\t\\t\\tdividend -= (divisor << k)\\n\\t\\t\\t\\tres += 1 << k\\n\\t\\t\\tMAX_INT = (1 << 31)-1\\n\\t\\t\\treturn -res if sign else (res if res <= MAX_INT else MAX_INT)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef divide(self, dividend: int, divisor: int) -> int:\\n\\t\\t\\tif dividend == 0:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tsign = 1 if ((dividend < 0) ^ (divisor < 0)) else 0\\n\\t\\t\\tdividend = abs(dividend)\\n\\t\\t\\tdivisor = abs(divisor)\\n\\t\\t\\tres = 0\\n\\t\\t\\twhile dividend >= divisor:\\n\\t\\t\\t\\tk = 0\\n\\t\\t\\t\\twhile dividend >= divisor << (k+1):\\n\\t\\t\\t\\t\\tk += 1\\n\\t\\t\\t\\tdividend -= (divisor << k)\\n\\t\\t\\t\\tres += 1 << k\\n\\t\\t\\tMAX_INT = (1 << 31)-1\\n\\t\\t\\treturn -res if sign else (res if res <= MAX_INT else MAX_INT)",
                "codeTag": "Java"
            },
            {
                "id": 1548253,
                "title": "python-24ms-98-38-without-bit-manipulation",
                "content": "The code is currently patchy for integer boundaries. Its on my todos.\\n\\nThe idea is to greedily increase divisor till we can\\'t.\\n\\nIf we have 14 / 2. (2 is the divisor, 14 is the dividend)\\n1. then we can increase 2 to 4 then to 8. Store the number of steps of the currend divisor 8. (4 steps)\\n2. Now reduce the dividend 14-8 = 6 and start divisor from 2 again. 2 then 4 (2 steps).\\n3. Reduce again ... 6-4=2. (1 step) since divisor == dividend.\\n\\nTotal number of steps = 7 which matches with integer divide of 14//2\\n\\nNumber of steps explanation\\nIf we have 8 .. then number of steps is 4 since .. \\nnumber of steps to reach 4 is 2 steps from 2. \\n\\nOriginal submisson:\\nhttps://leetcode.com/problems/divide-two-integers/submissions/\\n\\nLess code version:\\n\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:        \\n                        \\n        sign = False\\n        if dividend < 0 and divisor > 0:\\n            sign = True\\n        if dividend > 0 and divisor < 0:\\n            sign = True        \\n                \\n        dividend = abs(dividend)\\n        divisor = abs(divisor) # original divisor\\n        \\n        # INT MIN PART IS PATCHY ... \\n        if dividend > 2147483647 and not sign:\\n            dividend = 2147483647\\n        if divisor > 2147483647 and not sign:\\n            divisor = 2147483647        \\n                \\n        if divisor > dividend:\\n            return 0\\n        \\n        cdivisor = divisor # current divisor\\n        count = 0\\n        prevCount = 0                \\n             \\n        count = 1        \\n        while dividend >= divisor:\\n            # if dividend is 14 .. and we get o 8+8= 16 .. deduct 14 - 8 = 6            \\n            if cdivisor + cdivisor > dividend:                \\n                dividend = dividend - cdivisor\\n                prevCount = prevCount + count\\n                \\n                # test case: 2 2\\n                if dividend >= divisor:\\n                    cdivisor = divisor\\n                    count = 1\\n                else:\\n                    count = 0\\n            else:                                                    \\n                cdivisor =  cdivisor + cdivisor\\n                count = count + count                                                     \\n                \\n        if sign:\\n            return - count - prevCount\\n        return count + prevCount\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:        \\n                        \\n        sign = False\\n        if dividend < 0 and divisor > 0:\\n            sign = True\\n        if dividend > 0 and divisor < 0:\\n            sign = True        \\n                \\n        dividend = abs(dividend)\\n        divisor = abs(divisor) # original divisor\\n        \\n        # INT MIN PART IS PATCHY ... \\n        if dividend > 2147483647 and not sign:\\n            dividend = 2147483647\\n        if divisor > 2147483647 and not sign:\\n            divisor = 2147483647        \\n                \\n        if divisor > dividend:\\n            return 0\\n        \\n        cdivisor = divisor # current divisor\\n        count = 0\\n        prevCount = 0                \\n             \\n        count = 1        \\n        while dividend >= divisor:\\n            # if dividend is 14 .. and we get o 8+8= 16 .. deduct 14 - 8 = 6            \\n            if cdivisor + cdivisor > dividend:                \\n                dividend = dividend - cdivisor\\n                prevCount = prevCount + count\\n                \\n                # test case: 2 2\\n                if dividend >= divisor:\\n                    cdivisor = divisor\\n                    count = 1\\n                else:\\n                    count = 0\\n            else:                                                    \\n                cdivisor =  cdivisor + cdivisor\\n                count = count + count                                                     \\n                \\n        if sign:\\n            return - count - prevCount\\n        return count + prevCount\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532163,
                "title": "wrong-testcase",
                "content": "-2147483648\\n-1\\n\\nwith the expected result\\n2147483647\\n\\nWas forced to do some dirty hacks. Seems that the testcases are generated by running the written  code.\\n```\\nclass Solution {\\npublic:\\n    std::uint64_t divideImpl(std::uint64_t dividend, std::uint64_t divisor, std::uint64_t origin, std::uint64_t count){\\n       auto tmp_count = count; \\n       if((divisor+divisor) > dividend) {\\n           divisor = origin;\\n           tmp_count = 1;\\n       }\\n        \\n       if(dividend < divisor) return 0;\\n       return tmp_count+divideImpl(dividend - divisor, divisor+divisor, origin, tmp_count+tmp_count);\\n    }\\n    \\n    int divide(std::int64_t dividend, std::int64_t divisor) {\\n       int sign = 1;\\n       if(dividend < 0) {\\n           sign = -sign;\\n           dividend = -dividend;\\n       }\\n       if(divisor < 0) {\\n           sign = -sign;\\n           divisor = -divisor;\\n       }\\n        \\n       auto result = divideImpl(dividend, divisor, divisor, 1);\\n       return (sign > 0)? std::min<std::uint64_t>(result, 2147483647u): -result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    std::uint64_t divideImpl(std::uint64_t dividend, std::uint64_t divisor, std::uint64_t origin, std::uint64_t count){\\n       auto tmp_count = count; \\n       if((divisor+divisor) > dividend) {\\n           divisor = origin;\\n           tmp_count = 1;\\n       }\\n        \\n       if(dividend < divisor) return 0;\\n       return tmp_count+divideImpl(dividend - divisor, divisor+divisor, origin, tmp_count+tmp_count);\\n    }\\n    \\n    int divide(std::int64_t dividend, std::int64_t divisor) {\\n       int sign = 1;\\n       if(dividend < 0) {\\n           sign = -sign;\\n           dividend = -dividend;\\n       }\\n       if(divisor < 0) {\\n           sign = -sign;\\n           divisor = -divisor;\\n       }\\n        \\n       auto result = divideImpl(dividend, divisor, divisor, 1);\\n       return (sign > 0)? std::min<std::uint64_t>(result, 2147483647u): -result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450328,
                "title": "python3-python-solution-w-comments",
                "content": "**WHY on the earth you need not to use divison, muliplication and mode operator?**\\n*This problem is just waste of time*\\n```\\nclass Solution:\\n    \\n    def divide(self, dividend: int, divisor: int) -> int:\\n        \\n        # -2147483648 through 2147483647\\n        MIN_VAL = -2147483648\\n        MAX_VAL = 2147483647\\n        \\n        # If divisor is 1 or -1\\n        if abs(divisor) == 1:\\n            if dividend == MIN_VAL and divisor == -1:\\n                return MAX_VAL\\n            else:\\n                return dividend if divisor > 0 else -dividend\\n            \\n        # Get if the answer will be negative or positive\\n        sign = -1 if (dividend < 0 and divisor > 0) or (divisor < 0 and dividend > 0) else 1\\n        res = 0 # result\\n        shift = 31 # At max 31 left shift can be done on a integer value \\n        dividend = abs(dividend) # always take absolute value\\n        divisor = abs(divisor) # always take absolute value\\n        \\n        # While dividend is greater than divisor\\n        while dividend >= divisor:\\n            \\n            # Check how many shifts require of divisor\\n            # to reach dividend in whole\\n            while dividend < (divisor << shift):\\n                shift -= 1\\n            \\n            # subtract the left shifted divisor from dividend\\n            # and do the same process for the remaining value\\n            dividend = dividend - (divisor<<shift)\\n            \\n            # Answer will be how many total left shifted value of 1\\n            res = res + (1<<shift)\\n\\n        # return result within range and with proper sign\\n        res = min(MAX_VAL, max(MIN_VAL, res))\\n        \\n        # return\\n        return  res if sign > 0 else -res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def divide(self, dividend: int, divisor: int) -> int:\\n        \\n        # -2147483648 through 2147483647\\n        MIN_VAL = -2147483648\\n        MAX_VAL = 2147483647\\n        \\n        # If divisor is 1 or -1\\n        if abs(divisor) == 1:\\n            if dividend == MIN_VAL and divisor == -1:\\n                return MAX_VAL\\n            else:\\n                return dividend if divisor > 0 else -dividend\\n            \\n        # Get if the answer will be negative or positive\\n        sign = -1 if (dividend < 0 and divisor > 0) or (divisor < 0 and dividend > 0) else 1\\n        res = 0 # result\\n        shift = 31 # At max 31 left shift can be done on a integer value \\n        dividend = abs(dividend) # always take absolute value\\n        divisor = abs(divisor) # always take absolute value\\n        \\n        # While dividend is greater than divisor\\n        while dividend >= divisor:\\n            \\n            # Check how many shifts require of divisor\\n            # to reach dividend in whole\\n            while dividend < (divisor << shift):\\n                shift -= 1\\n            \\n            # subtract the left shifted divisor from dividend\\n            # and do the same process for the remaining value\\n            dividend = dividend - (divisor<<shift)\\n            \\n            # Answer will be how many total left shifted value of 1\\n            res = res + (1<<shift)\\n\\n        # return result within range and with proper sign\\n        res = min(MAX_VAL, max(MIN_VAL, res))\\n        \\n        # return\\n        return  res if sign > 0 else -res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1401070,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n\\t\\t// checking for overflow\\n        if(dividend == 1<<31 && divisor == -1) return Integer.MAX_VALUE;\\n\\t\\t\\n\\t\\t// deciding the sign of the quotient\\n        boolean sign = (dividend>=0) == (divisor >=0) ? true : false;\\n\\t\\t\\n\\t\\t//using absolute values for the answer\\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n\\t\\t\\n\\t\\t// our answer\\n        int result=0; \\n\\t\\t\\n        while(dividend - divisor >= 0 ){\\n\\t\\t // the number of times we need to left shift (or double our divisor)\\n            int count=0;\\n\\t\\t\\t\\n\\t\\t\\t// increment count till we can subtract the doubled divisor form dividend\\n            while(dividend  - (divisor<<1<<count) >= 0 ){\\n                count++; \\n            }\\n\\t\\t\\t\\n\\t\\t\\t // incrementing quotient by the power of 2 by which we multiplied divisor\\n\\t\\t\\t// 2 power x can be written as 1<<x\\n            result += 1 << count;\\n\\t\\t\\t\\n\\t\\t\\t// decrease the dividend by the maximum value we can subtract\\n\\t\\t\\t//which is divisor*(2 power count)\\n            dividend -= divisor << count ; \\n        }\\n\\t\\t // if sign is false it means negative quotient\\n        return sign?result: -result ;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n\\t\\t// checking for overflow\\n        if(dividend == 1<<31 && divisor == -1) return Integer.MAX_VALUE;\\n\\t\\t\\n\\t\\t// deciding the sign of the quotient\\n        boolean sign = (dividend>=0) == (divisor >=0) ? true : false;\\n\\t\\t\\n\\t\\t//using absolute values for the answer\\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n\\t\\t\\n\\t\\t// our answer\\n        int result=0; \\n\\t\\t\\n        while(dividend - divisor >= 0 ){\\n\\t\\t // the number of times we need to left shift (or double our divisor)\\n            int count=0;\\n\\t\\t\\t\\n\\t\\t\\t// increment count till we can subtract the doubled divisor form dividend\\n            while(dividend  - (divisor<<1<<count) >= 0 ){\\n                count++; \\n            }\\n\\t\\t\\t\\n\\t\\t\\t // incrementing quotient by the power of 2 by which we multiplied divisor\\n\\t\\t\\t// 2 power x can be written as 1<<x\\n            result += 1 << count;\\n\\t\\t\\t\\n\\t\\t\\t// decrease the dividend by the maximum value we can subtract\\n\\t\\t\\t//which is divisor*(2 power count)\\n            dividend -= divisor << count ; \\n        }\\n\\t\\t // if sign is false it means negative quotient\\n        return sign?result: -result ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1258780,
                "title": "0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "```\\n    int divide(int dividend, int divisor) {\\n        if (divisor == INT_MIN) {\\n            if (dividend == INT_MIN) {\\n                return 1;\\n            } else {\\n                return 0;\\n            }\\n        }\\n        \\n        if (dividend == INT_MIN) {\\n            if (divisor == -1) {\\n                return INT_MAX;\\n            } \\n            if (divisor > 0) {\\n                return -1+divide(dividend+divisor, divisor);\\n            } else if (divisor < 0) {\\n                return 1+divide(dividend-divisor, divisor);\\n            }\\n        }\\n        \\n        int sign = 1;\\n        if ((dividend >0 && divisor <0) || (dividend <0 && divisor >0)) {\\n            sign = -1;\\n        }\\n        dividend=abs(dividend);\\n        divisor=abs(divisor);\\n        int remainder = dividend, quotient = 0;\\n        while (remainder >= divisor) {\\n            int shift = 0;\\n            while ((divisor<<shift) <= remainder && (divisor<<shift)>0 ) {\\n                ++shift;\\n            }\\n            --shift;\\n            quotient += (1<<shift);\\n            remainder -= (divisor<<shift);\\n        }\\n        if (sign < 0) quotient = -quotient;\\n        return quotient;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int divide(int dividend, int divisor) {\\n        if (divisor == INT_MIN) {\\n            if (dividend == INT_MIN) {\\n                return 1;\\n            } else {\\n                return 0;\\n            }\\n        }\\n        \\n        if (dividend == INT_MIN) {\\n            if (divisor == -1) {\\n                return INT_MAX;\\n            } \\n            if (divisor > 0) {\\n                return -1+divide(dividend+divisor, divisor);\\n            } else if (divisor < 0) {\\n                return 1+divide(dividend-divisor, divisor);\\n            }\\n        }\\n        \\n        int sign = 1;\\n        if ((dividend >0 && divisor <0) || (dividend <0 && divisor >0)) {\\n            sign = -1;\\n        }\\n        dividend=abs(dividend);\\n        divisor=abs(divisor);\\n        int remainder = dividend, quotient = 0;\\n        while (remainder >= divisor) {\\n            int shift = 0;\\n            while ((divisor<<shift) <= remainder && (divisor<<shift)>0 ) {\\n                ++shift;\\n            }\\n            --shift;\\n            quotient += (1<<shift);\\n            remainder -= (divisor<<shift);\\n        }\\n        if (sign < 0) quotient = -quotient;\\n        return quotient;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1213715,
                "title": "simple-without-bitwise",
                "content": "\\n    public int divide(int dividend, int divisor) {\\n     \\n        if(dividend == 0)  return 0;\\n    \\n        if(dividend == Integer.MIN_VALUE && divisor == -1)  return Integer.MAX_VALUE;\\n          \\n        boolean Negative = true;\\n       \\n        if((dividend < 0 && divisor < 0) || (dividend > 0 && divisor > 0))\\n           Negative = false;\\n\\n        if(dividend > 0) {\\n            dividend = 0 - dividend;\\n        }\\n        if(divisor > 0) {\\n            divisor = 0 - divisor;\\n        }\\n\\n        int quotient = 0;\\n        while(dividend <= divisor) {\\n            dividend = dividend - divisor;\\n            quotient++;\\n        }\\n        \\n        if(Negative && quotient > 0)    return 0 - quotient;\\n        \\n         else     return quotient;\\n        \\n    \\n}",
                "solutionTags": [],
                "code": "\\n    public int divide(int dividend, int divisor) {\\n     \\n        if(dividend == 0)  return 0;\\n    \\n        if(dividend == Integer.MIN_VALUE && divisor == -1)  return Integer.MAX_VALUE;\\n          \\n        boolean Negative = true;\\n       \\n        if((dividend < 0 && divisor < 0) || (dividend > 0 && divisor > 0))\\n           Negative = false;\\n\\n        if(dividend > 0) {\\n            dividend = 0 - dividend;\\n        }\\n        if(divisor > 0) {\\n            divisor = 0 - divisor;\\n        }\\n\\n        int quotient = 0;\\n        while(dividend <= divisor) {\\n            dividend = dividend - divisor;\\n            quotient++;\\n        }\\n        \\n        if(Negative && quotient > 0)    return 0 - quotient;\\n        \\n         else     return quotient;\\n        \\n    \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1087238,
                "title": "java-no-long-no-bitwise-log-n-solution-with-explanation",
                "content": "```\\nclass Solution {\\n\\t// Can specify the exact half value here as well instead of using the divide symbol\\n\\tint HALF_INT_MIN = Integer.MIN_VALUE/2;\\n\\n    public int divide(int dividend, int divisor) {\\n        \\n\\t\\t// Satisfying the overflow condition as specified in the problem\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) \\n            return Integer.MAX_VALUE;     \\n        \\n\\t\\t// Determining if the output result should be positive or negative;\\n        boolean isResultNegative = (divisor < 0) ^ (dividend < 0);\\n        \\n\\t\\t// Converting dividend and divisor to negative values to satisfy the overflow boundary conditions\\n        dividend = dividend > 0 ? -dividend : dividend;\\n        divisor = divisor > 0 ? -divisor : divisor;        \\n\\n\\t\\t// Defining 2 arrays, one for the powers of 2 that reaches upto the quotient and the other one the doubles of divisor\\n        List<Integer> powersOf2 = new ArrayList<>();\\n        List<Integer> doublesOfDivisor = new ArrayList<>();        \\n        \\n\\t\\t// Populating the 2 arrays\\n\\t\\tint powerOf2 = 1;        \\n        while(dividend <= divisor){\\n            powersOf2.add(powerOf2);\\n            doublesOfDivisor.add(divisor);\\n\\t\\t\\t// This condition check is for overflow condition check\\n            if (divisor < HALF_INT_MIN) \\n                break;                    \\n            powerOf2 += powerOf2;\\n            divisor += divisor;\\n        }\\n        \\n\\t\\t// Now we can iterate through the multiple of divisor list to calculate the quotient -\\n\\t\\t// The quotient of current dividend is the respective power of 2 (number when multiplied with original divisor). \\n\\t\\t// Some part of remainder can again be part of the quotient so we reduce dividend by subtracting it from the corresponding multiple of divisor\\n        int quotient = 0;\\n        for(int i=doublesOfDivisor.size()-1; i >= 0 ;i--){\\n            if(dividend <= doublesOfDivisor.get(i)){\\n                quotient += powersOf2.get(i);\\n                dividend -= doublesOfDivisor.get(i);\\n            }\\n        }\\n        \\n        return isResultNegative ? -quotient : quotient;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\t// Can specify the exact half value here as well instead of using the divide symbol\\n\\tint HALF_INT_MIN = Integer.MIN_VALUE/2;\\n\\n    public int divide(int dividend, int divisor) {\\n        \\n\\t\\t// Satisfying the overflow condition as specified in the problem\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) \\n            return Integer.MAX_VALUE;     \\n        \\n\\t\\t// Determining if the output result should be positive or negative;\\n        boolean isResultNegative = (divisor < 0) ^ (dividend < 0);\\n        \\n\\t\\t// Converting dividend and divisor to negative values to satisfy the overflow boundary conditions\\n        dividend = dividend > 0 ? -dividend : dividend;\\n        divisor = divisor > 0 ? -divisor : divisor;        \\n\\n\\t\\t// Defining 2 arrays, one for the powers of 2 that reaches upto the quotient and the other one the doubles of divisor\\n        List<Integer> powersOf2 = new ArrayList<>();\\n        List<Integer> doublesOfDivisor = new ArrayList<>();        \\n        \\n\\t\\t// Populating the 2 arrays\\n\\t\\tint powerOf2 = 1;        \\n        while(dividend <= divisor){\\n            powersOf2.add(powerOf2);\\n            doublesOfDivisor.add(divisor);\\n\\t\\t\\t// This condition check is for overflow condition check\\n            if (divisor < HALF_INT_MIN) \\n                break;                    \\n            powerOf2 += powerOf2;\\n            divisor += divisor;\\n        }\\n        \\n\\t\\t// Now we can iterate through the multiple of divisor list to calculate the quotient -\\n\\t\\t// The quotient of current dividend is the respective power of 2 (number when multiplied with original divisor). \\n\\t\\t// Some part of remainder can again be part of the quotient so we reduce dividend by subtracting it from the corresponding multiple of divisor\\n        int quotient = 0;\\n        for(int i=doublesOfDivisor.size()-1; i >= 0 ;i--){\\n            if(dividend <= doublesOfDivisor.get(i)){\\n                quotient += powersOf2.get(i);\\n                dividend -= doublesOfDivisor.get(i);\\n            }\\n        }\\n        \\n        return isResultNegative ? -quotient : quotient;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1084789,
                "title": "ruby-bit-manipulation",
                "content": "```\\n# @param {Integer} dividend\\n# @param {Integer} divisor\\n# @return {Integer}\\ndef divide(dividend, divisor)\\n  sign = (divisor > 0) ^ (dividend > 0) ? -1 : 1\\n\\t\\t\\n  return 2**31-1 if dividend == -2**31 && divisor == -1\\n\\n  dividend = dividend.abs\\n  divisor = divisor.abs\\n  result = 0\\n  \\n  while divisor <= dividend\\n    div = divisor\\n    temp = 1\\n    while (div << 1) <= dividend\\n      temp <<= 1\\n      div <<= 1\\n    end\\n    dividend -= div\\n    result += temp\\n  end\\n  \\n  result*sign \\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Bit Manipulation"
                ],
                "code": "```\\n# @param {Integer} dividend\\n# @param {Integer} divisor\\n# @return {Integer}\\ndef divide(dividend, divisor)\\n  sign = (divisor > 0) ^ (dividend > 0) ? -1 : 1\\n\\t\\t\\n  return 2**31-1 if dividend == -2**31 && divisor == -1\\n\\n  dividend = dividend.abs\\n  divisor = divisor.abs\\n  result = 0\\n  \\n  while divisor <= dividend\\n    div = divisor\\n    temp = 1\\n    while (div << 1) <= dividend\\n      temp <<= 1\\n      div <<= 1\\n    end\\n    dividend -= div\\n    result += temp\\n  end\\n  \\n  result*sign \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1020340,
                "title": "shame-on-this-challange",
                "content": "To quote the website exactly, we will solve the following \"challange\":\\n> Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.\\n\\n> Return the quotient after dividing dividend by divisor.\\n\\n> The integer division should truncate toward zero, which means losing its fractional part.\\n> For example, truncate(8.345) = 8 and truncate(-2.7335) = -2.\\n\\n> Note:\\n>  Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [-2^31,  2^31 \\u2212 1].\\n>  For this problem, assume that your function returns 2^31 - 1 when the division result overflows.\\n\\nSounds easy enough, that is to people who studied a computer systems course.\\nFirst let\\'s look at a few of the \"best\" submissions that straight up violate the rules:\\n\\n1. Division operator used\\n```\\nint divide(long long dividend, long long divisor){\\n    if(dividend/divisor>pow(2,31)-1)\\n        return (pow(2,31)-1);//\\u7576\\u7D50\\u679C\\u6EA2\\u4F4D\\u6642\\u8FD4\\u56DE2^31\\u22121\\n    else\\n        return (dividend/divisor);//\\u5176\\u4ED6\\u76F4\\u63A5\\u9664\\u518D\\u8FD4\\u56DE\\u5176\\u7D50\\u679C(\\u56E0\\u6574\\u6578\\u7684\\u9664\\u6CD5\\u6703\\u76F4\\u63A5\\u6368\\u68C4\\u5C0F\\u6578\\uFF0C\\u8F38\\u51FA\\u6574\\u6578\\u503C)\\n}\\n```\\n\\n2. Impressive if ladder for sure, but the pesky division operator is still there\\n```\\n#define INT_MAX 2147483647\\n#define INT_MIN (-INT_MAX - 1)\\n\\nint divide(int dividend, int divisor){\\n    printf( \"%d\\\\n%d\", dividend, divisor );\\n    int output = 0;\\n    if ( ( dividend == 0 ) || ( divisor == 0 ) ) return 0;\\n    else if ( ( dividend <= INT_MIN ) && ( divisor < 0 ) && ( divisor != INT_MIN )  ) dividend = -INT_MAX;\\n    // else if ( ( dividend >= INT_MAX ) || ( dividend <= INT_MIN ) ) return 0;\\n    // else if ( ( divisor >= INT_MAX ) || ( divisor <= INT_MIN ) ) return 0;\\n    output = dividend / divisor;\\n    // printf(\"%d\\\\n\",output);\\n    return output;\\n}\\n```\\n\\nSo your software restoring division (or something similar) algorithm will compete against cheaters using\\ndivision hardware, no wonder you rank poorly.\\n\\nIn the end it doesn\\'t matter, as this problem in reality is asking for an algorithm that is of no use to any programmer,\\naka implementing division in software. It has a horrible number of edge cases with integer overflow, and is definitely\\nnot of \"medium\" difficulty to anyone, but a hardware designer.\\n\\nLet\\'s see the (terrible and pointless) code I came up with that should fit the requirements:\\n```\\n// This function implements restoring division taking two 32-bit unsigned inputs\\n// and outputs a 32-bit unsigned quotient, with no overflow possible\\nunsigned udiv(unsigned dividend, unsigned divisor) {\\n    unsigned quo = 0;\\n    unsigned long rem = dividend;\\n    unsigned long div = (unsigned long) divisor << 32;\\n\\n    for (int i = 0; i < 32; ++i) {\\n        rem <<= 1;\\n        if (rem >= div) {\\n            rem -= div;\\n            quo = quo << 1 | 1;\\n        } else {\\n            quo <<= 1;\\n        }\\n    }\\n\\n    return quo;\\n}\\n\\n// This function does a bunch of horrific edge case checking to\\n// make sure no integer overflow is possible\\nint divide(int dividend, int divisor) {\\n    int sgn = 0;\\n\\n    unsigned u_dividend;\\n    if (dividend < 0) {\\n        u_dividend = -(long)dividend;\\n        sgn ^= 1;\\n    } else {\\n        u_dividend = dividend;\\n    }\\n    unsigned u_divisor;\\n    if (divisor < 0) {\\n        u_divisor = -(long)divisor;\\n        sgn ^= 1;\\n    } else {\\n        u_divisor = divisor;\\n    }\\n\\n    unsigned u_result = udiv(u_dividend, u_divisor);\\n\\n    if (sgn) {\\n        if (-(long) u_result < INT_MIN)\\n            return INT_MAX;\\n        return -u_result;\\n    } else {\\n        if (u_result > INT_MAX)\\n            return  INT_MAX;\\n        return u_result;\\n    }\\n}\\n```\\n\\nTo add insult to injury, LeetCode is not able to actually measure the runtime of\\nany reasonable fast C code, so it presents mine and the two cheaters above as\\nhaving a \"0 ms\" runtime, and just as good. While mine is obviously slower, it\\nactually does what the question is asking.\\n",
                "solutionTags": [],
                "code": "```\\nint divide(long long dividend, long long divisor){\\n    if(dividend/divisor>pow(2,31)-1)\\n        return (pow(2,31)-1);//\\u7576\\u7D50\\u679C\\u6EA2\\u4F4D\\u6642\\u8FD4\\u56DE2^31\\u22121\\n    else\\n        return (dividend/divisor);//\\u5176\\u4ED6\\u76F4\\u63A5\\u9664\\u518D\\u8FD4\\u56DE\\u5176\\u7D50\\u679C(\\u56E0\\u6574\\u6578\\u7684\\u9664\\u6CD5\\u6703\\u76F4\\u63A5\\u6368\\u68C4\\u5C0F\\u6578\\uFF0C\\u8F38\\u51FA\\u6574\\u6578\\u503C)\\n}\\n```\n```\\n#define INT_MAX 2147483647\\n#define INT_MIN (-INT_MAX - 1)\\n\\nint divide(int dividend, int divisor){\\n    printf( \"%d\\\\n%d\", dividend, divisor );\\n    int output = 0;\\n    if ( ( dividend == 0 ) || ( divisor == 0 ) ) return 0;\\n    else if ( ( dividend <= INT_MIN ) && ( divisor < 0 ) && ( divisor != INT_MIN )  ) dividend = -INT_MAX;\\n    // else if ( ( dividend >= INT_MAX ) || ( dividend <= INT_MIN ) ) return 0;\\n    // else if ( ( divisor >= INT_MAX ) || ( divisor <= INT_MIN ) ) return 0;\\n    output = dividend / divisor;\\n    // printf(\"%d\\\\n\",output);\\n    return output;\\n}\\n```\n```\\n// This function implements restoring division taking two 32-bit unsigned inputs\\n// and outputs a 32-bit unsigned quotient, with no overflow possible\\nunsigned udiv(unsigned dividend, unsigned divisor) {\\n    unsigned quo = 0;\\n    unsigned long rem = dividend;\\n    unsigned long div = (unsigned long) divisor << 32;\\n\\n    for (int i = 0; i < 32; ++i) {\\n        rem <<= 1;\\n        if (rem >= div) {\\n            rem -= div;\\n            quo = quo << 1 | 1;\\n        } else {\\n            quo <<= 1;\\n        }\\n    }\\n\\n    return quo;\\n}\\n\\n// This function does a bunch of horrific edge case checking to\\n// make sure no integer overflow is possible\\nint divide(int dividend, int divisor) {\\n    int sgn = 0;\\n\\n    unsigned u_dividend;\\n    if (dividend < 0) {\\n        u_dividend = -(long)dividend;\\n        sgn ^= 1;\\n    } else {\\n        u_dividend = dividend;\\n    }\\n    unsigned u_divisor;\\n    if (divisor < 0) {\\n        u_divisor = -(long)divisor;\\n        sgn ^= 1;\\n    } else {\\n        u_divisor = divisor;\\n    }\\n\\n    unsigned u_result = udiv(u_dividend, u_divisor);\\n\\n    if (sgn) {\\n        if (-(long) u_result < INT_MIN)\\n            return INT_MAX;\\n        return -u_result;\\n    } else {\\n        if (u_result > INT_MAX)\\n            return  INT_MAX;\\n        return u_result;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 981274,
                "title": "neat-python3-solution-fast-and-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        res = 0\\n        sign = 1\\n        if dividend < 0:\\n            dividend = -dividend\\n            sign = -sign\\n        if divisor < 0:\\n            divisor = -divisor\\n            sign = -sign\\n        while dividend >= divisor:\\n            val, n = divisor, 1\\n            while val+val <= dividend:\\n                val += val\\n                n += n\\n            dividend = dividend - val\\n            res += n\\n        \\n        if sign == 1:\\n            return min(res, 2**31-1)\\n        else:\\n            return max(-res, -2**31)\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        res = 0\\n        sign = 1\\n        if dividend < 0:\\n            dividend = -dividend\\n            sign = -sign\\n        if divisor < 0:\\n            divisor = -divisor\\n            sign = -sign\\n        while dividend >= divisor:\\n            val, n = divisor, 1\\n            while val+val <= dividend:\\n                val += val\\n                n += n\\n            dividend = dividend - val\\n            res += n\\n        \\n        if sign == 1:\\n            return min(res, 2**31-1)\\n        else:\\n            return max(-res, -2**31)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937330,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        \\n        if dividend == 0:\\n            return 0\\n        \\n        sign = 1\\n        if (dividend < 0 and divisor > 0) or (dividend > 0 and divisor < 0):\\n            sign = -1\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        \\n        res = 0\\n        while dividend >= divisor:\\n            val, n = divisor, 1\\n            while val + val <= dividend:\\n                val += val\\n                n += n\\n            \\n            res += n\\n            dividend -= val\\n\\n        \\n        if sign == 1:\\n            return min(res, 2**31 -1)\\n        else: \\n            return max(-res, -2**31)\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        \\n        if dividend == 0:\\n            return 0\\n        \\n        sign = 1\\n        if (dividend < 0 and divisor > 0) or (dividend > 0 and divisor < 0):\\n            sign = -1\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        \\n        res = 0\\n        while dividend >= divisor:\\n            val, n = divisor, 1\\n            while val + val <= dividend:\\n                val += val\\n                n += n\\n            \\n            res += n\\n            dividend -= val\\n\\n        \\n        if sign == 1:\\n            return min(res, 2**31 -1)\\n        else: \\n            return max(-res, -2**31)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887275,
                "title": "python-2-solutions-recursion-non-recursion-clean-concise-o-log-n-2",
                "content": "**Solution 1: Recursion**\\n```python\\nclass Solution(object):\\n    def divide(self, a, b):\\n        def helper(a, b):\\n            if a < b: return 0\\n            multiply = 1 # 1 2 4 8 16...\\n            sum = b\\n            while (sum + sum) <= a:\\n                sum += sum\\n                multiply += multiply\\n            return multiply + helper(a - sum, b)\\n        \\n        INT_MAX = 2147483647 # 2**31 - 1\\n        positive = (a >= 0) == (b >= 0) # Positive only if a and b the same sign\\n        ans = helper(abs(a), abs(b))\\n        ans = ans if positive else -ans\\n        return min(ans, INT_MAX)\\n```\\nComplexity:\\n- Time: `O(log(N) ^ 2)`, where `N` is absolute value of `dividend`\\n\\n**Solution 2: Non recursion**\\n```python\\nclass Solution(object):\\n    def divide(self, a, b):\\n        INT_MAX = 2147483647 # 2**31 - 1\\n        positive = (a >= 0) == (b >= 0) # Positive only if a and b the same sign\\n        a, b = abs(a), abs(b)\\n        ans = 0\\n        while a >= b:\\n            multiply = 1 # 1 2 4 8 16...\\n            sum = b\\n            while (sum + sum) <= a:\\n                sum += sum\\n                multiply += multiply\\n            ans += multiply\\n            a -= sum\\n        ans = ans if positive else -ans\\n        return min(ans, INT_MAX)\\n```\\nComplexity:\\n- Time: `O(log(N) ^ 2)`, where `N` is absolute value of `dividend`\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def divide(self, a, b):\\n        def helper(a, b):\\n            if a < b: return 0\\n            multiply = 1 # 1 2 4 8 16...\\n            sum = b\\n            while (sum + sum) <= a:\\n                sum += sum\\n                multiply += multiply\\n            return multiply + helper(a - sum, b)\\n        \\n        INT_MAX = 2147483647 # 2**31 - 1\\n        positive = (a >= 0) == (b >= 0) # Positive only if a and b the same sign\\n        ans = helper(abs(a), abs(b))\\n        ans = ans if positive else -ans\\n        return min(ans, INT_MAX)\\n```\n```python\\nclass Solution(object):\\n    def divide(self, a, b):\\n        INT_MAX = 2147483647 # 2**31 - 1\\n        positive = (a >= 0) == (b >= 0) # Positive only if a and b the same sign\\n        a, b = abs(a), abs(b)\\n        ans = 0\\n        while a >= b:\\n            multiply = 1 # 1 2 4 8 16...\\n            sum = b\\n            while (sum + sum) <= a:\\n                sum += sum\\n                multiply += multiply\\n            ans += multiply\\n            a -= sum\\n        ans = ans if positive else -ans\\n        return min(ans, INT_MAX)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 829428,
                "title": "java-binary-long-division-o-31",
                "content": "\\n```\\npublic int divide(int dividend, int divisor) {\\n        if (dividend == -Integer.MIN_VALUE && divisor == -1)\\n            return Integer.MAX_VALUE;\\n\\n        // Convert to +ves\\n        int negs = 0;\\n        if (dividend < 0) {\\n            negs++;\\n            dividend = -dividend;\\n        }\\n        if (divisor < 0) {\\n            negs++;\\n            divisor = -divisor;\\n        }\\n\\n        /**\\n         * Will do binary long division\\n         * starting from Left most bit of \\'dividend\\' (32),\\n         * going through the bits, comparing with \\'divisor\\'\\n         * and as and when results in \\'>= 0\\' get reminder\\n         * and append to quotient\\n         */\\n        int q = 0;\\n        int x = 31;\\n        while (x >= 0) {\\n            //Unsigned shift to handle case where dividend = Integer.MIN_VALUE\\n            //In which case -Integer.MIN_VALUE will also be Integer.MIN_VALUE\\n            if ((dividend >>> x) - divisor >= 0) {\\n                q += 1 << x;\\n                dividend -= divisor << x;\\n            }\\n            x--;\\n        }\\n\\n        if (negs == 1) //If only one of dividend/divisor is -Ve result as well is\\n            q = -q;\\n\\n        return q;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\npublic int divide(int dividend, int divisor) {\\n        if (dividend == -Integer.MIN_VALUE && divisor == -1)\\n            return Integer.MAX_VALUE;\\n\\n        // Convert to +ves\\n        int negs = 0;\\n        if (dividend < 0) {\\n            negs++;\\n            dividend = -dividend;\\n        }\\n        if (divisor < 0) {\\n            negs++;\\n            divisor = -divisor;\\n        }\\n\\n        /**\\n         * Will do binary long division\\n         * starting from Left most bit of \\'dividend\\' (32),\\n         * going through the bits, comparing with \\'divisor\\'\\n         * and as and when results in \\'>= 0\\' get reminder\\n         * and append to quotient\\n         */\\n        int q = 0;\\n        int x = 31;\\n        while (x >= 0) {\\n            //Unsigned shift to handle case where dividend = Integer.MIN_VALUE\\n            //In which case -Integer.MIN_VALUE will also be Integer.MIN_VALUE\\n            if ((dividend >>> x) - divisor >= 0) {\\n                q += 1 << x;\\n                dividend -= divisor << x;\\n            }\\n            x--;\\n        }\\n\\n        if (negs == 1) //If only one of dividend/divisor is -Ve result as well is\\n            q = -q;\\n\\n        return q;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 824443,
                "title": "100-faster-solution-using-bit-manipulation-in-cpp",
                "content": "```\\n//----------------------------Upvote if u loved the solution---------------------------------------------------------------\\n\\n\\n    int divide(int dividend, int divisor) {\\n        if(dividend==INT_MIN&&divisor==-1)\\n            return INT_MAX;\\n        long dv=labs(dividend),ds=labs(divisor),ans=0,flag=0;\\n        if((dividend<0&&divisor>0)||(dividend>0&&divisor<0))\\n            flag=1;\\n        while(ds<=dv){\\n            long temp=ds,m=1;\\n            while(temp<<1<dv){\\n                temp<<=1;\\n                m<<=1;\\n            }\\n            ans+=m;\\n            dv-=temp;\\n        }\\n        if(flag)\\n            return -ans;\\n        return ans;\\n    }\\n\\t\\n\\t\\n//----------------------------Upvote if u loved the solution-------------------------------------------------------------\\n```",
                "solutionTags": [],
                "code": "```\\n//----------------------------Upvote if u loved the solution---------------------------------------------------------------\\n\\n\\n    int divide(int dividend, int divisor) {\\n        if(dividend==INT_MIN&&divisor==-1)\\n            return INT_MAX;\\n        long dv=labs(dividend),ds=labs(divisor),ans=0,flag=0;\\n        if((dividend<0&&divisor>0)||(dividend>0&&divisor<0))\\n            flag=1;\\n        while(ds<=dv){\\n            long temp=ds,m=1;\\n            while(temp<<1<dv){\\n                temp<<=1;\\n                m<<=1;\\n            }\\n            ans+=m;\\n            dv-=temp;\\n        }\\n        if(flag)\\n            return -ans;\\n        return ans;\\n    }\\n\\t\\n\\t\\n//----------------------------Upvote if u loved the solution-------------------------------------------------------------\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 777656,
                "title": "o-log-dividend-solution-python",
                "content": "\\n\\n    def divide(self, dividend, divisor):\\n        #The final Sign        \\n        sign = (dividend < 0) != (divisor < 0)\\n        \\n        #Absolute of dividend\\n        dividend = abs(dividend)\\n        \\n        #Absolute of divisor\\n        divisor = abs(divisor)\\n\\n        #Let\\'s Search at O(log(dividend)) complexity \\n        \\n        bit_width = 32\\n        remainder = 0\\n        modulus = 0\\n        for i in range(bit_width - 1 , -1, -1):\\n            \\n            # If we found a big 2^i slice that can be subtracted\\n            # Slice it off and search for the remaining value \\n            slice = divisor << i \\n            if remainder + slice <= dividend:\\n                remainder += slice\\n                # Since we \"add\" only less significant bits\\n                # The Addition can be replaced by Bitwise OR\\n                modulus = modulus | (1 << i)         \\n            # If the slice does not fit we continue\\n            # With the next possible slice\\n        \\n        if sign:\\n            return max(-modulus, -2147483648)\\n        else:\\n            return min( modulus,  2147483647)",
                "solutionTags": [],
                "code": "\\n\\n    def divide(self, dividend, divisor):\\n        #The final Sign        \\n        sign = (dividend < 0) != (divisor < 0)\\n        \\n        #Absolute of dividend\\n        dividend = abs(dividend)\\n        \\n        #Absolute of divisor\\n        divisor = abs(divisor)\\n\\n        #Let\\'s Search at O(log(dividend)) complexity \\n        \\n        bit_width = 32\\n        remainder = 0\\n        modulus = 0\\n        for i in range(bit_width - 1 , -1, -1):\\n            \\n            # If we found a big 2^i slice that can be subtracted\\n            # Slice it off and search for the remaining value \\n            slice = divisor << i \\n            if remainder + slice <= dividend:\\n                remainder += slice\\n                # Since we \"add\" only less significant bits\\n                # The Addition can be replaced by Bitwise OR\\n                modulus = modulus | (1 << i)         \\n            # If the slice does not fit we continue\\n            # With the next possible slice\\n        \\n        if sign:\\n            return max(-modulus, -2147483648)\\n        else:\\n            return min( modulus,  2147483647)",
                "codeTag": "Python3"
            },
            {
                "id": 554646,
                "title": "c-o-1-solution-runtime-beats-100",
                "content": "Math logic:\\n\\t\\na/b = e^(log(a) - log(b)) \\nSince log(a/b) is equal to log(a) - log(b), raise it to e power as e and log undo each other\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int divide(int a, int b) {\\n        if (a == INT_MAX && b == INT_MIN) return 0;\\n        int x = a;\\n        int y = b;\\n        bool neg1 = 0, neg2 = 0;\\n        if (a < 0) neg1 = 1;\\n        if (b < 0) neg2 = 1; \\n        a = (a == INT_MIN) ? INT_MAX : abs(a);\\n        b = (b == INT_MIN) ? INT_MAX : abs(b);\\n        int ans = exp(log(a) - log(b));\\n        if (neg1 && neg2) return ans;\\n        else if (neg1 || neg2) return ans == INT_MAX ? INT_MIN : \\n                                        ((x == INT_MIN && y == 2) ? -ans-1 :-ans);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int divide(int a, int b) {\\n        if (a == INT_MAX && b == INT_MIN) return 0;\\n        int x = a;\\n        int y = b;\\n        bool neg1 = 0, neg2 = 0;\\n        if (a < 0) neg1 = 1;\\n        if (b < 0) neg2 = 1; \\n        a = (a == INT_MIN) ? INT_MAX : abs(a);\\n        b = (b == INT_MIN) ? INT_MAX : abs(b);\\n        int ans = exp(log(a) - log(b));\\n        if (neg1 && neg2) return ans;\\n        else if (neg1 || neg2) return ans == INT_MAX ? INT_MIN : \\n                                        ((x == INT_MIN && y == 2) ? -ans-1 :-ans);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549683,
                "title": "java-o-lgn-time-o-1-space-no-bit-shift-no-long",
                "content": "I checked through all the solutions here and observed these trends:\\n- A lot of solutions use `long`, which violated the requirements of this problem\\n- Bit shift makes the code less readable\\n\\n This solution is similar to Approach 4 in this [solution](https://leetcode.com/problems/divide-two-integers/solution/). But instead of bit shifting, I am using plus and minus operations only. Below are the steps:\\n- First, we check for the special case `dividend == Integer.MIN_VALUE && divisor == -1`\\n- We get the absolute value of dividend and divisor\\n- Do the division for 2 positive numbers using \"Adding Powers Of Two\" technique\\n\\nA note on the check `dividend - divisor >= 0` instead of `divisor <= dividend` is to handle the corner case where original `dividend = Integer.MIN_VALUE` and `absDividend = Integer.MIN_VALUE`. \\n```java\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE;\\n\\n        int absDividend = getAbs(dividend);\\n        int absDivisor = getAbs(divisor);\\n        int res = dividePositive(absDividend, absDivisor);\\n        return (dividend > 0) == (divisor > 0) ? res : -res;\\n    }\\n    \\n    int getAbs(int num) {\\n        return num < 0 ? -num : num;\\n    }\\n    \\n    int dividePositive(int dividend, int divisor) {\\n        int count = 0;\\n        \\n        while (dividend - divisor >= 0) {\\n            int cur = divisor;\\n            int steps = 1; \\n            while (dividend - (cur + cur) > 0) {\\n                cur = cur + cur;\\n                steps += steps;\\n            }\\n            count += steps;\\n            dividend = dividend - cur;\\n        }\\n        \\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE;\\n\\n        int absDividend = getAbs(dividend);\\n        int absDivisor = getAbs(divisor);\\n        int res = dividePositive(absDividend, absDivisor);\\n        return (dividend > 0) == (divisor > 0) ? res : -res;\\n    }\\n    \\n    int getAbs(int num) {\\n        return num < 0 ? -num : num;\\n    }\\n    \\n    int dividePositive(int dividend, int divisor) {\\n        int count = 0;\\n        \\n        while (dividend - divisor >= 0) {\\n            int cur = divisor;\\n            int steps = 1; \\n            while (dividend - (cur + cur) > 0) {\\n                cur = cur + cur;\\n                steps += steps;\\n            }\\n            count += steps;\\n            dividend = dividend - cur;\\n        }\\n        \\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566062,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1565701,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1565492,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1566906,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1566683,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1820777,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1566695,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1566912,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1566469,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1566444,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1566062,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1565701,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1565492,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1566906,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1566683,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1820777,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1566695,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1566912,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1566469,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1566444,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1568689,
                "content": [
                    {
                        "username": "chandra627",
                        "content": "\\nInput:\\n-2147483648\\n-1\\nExpected:\\n2147483647\\n\\nHow is this correct?\\nBad test case."
                    },
                    {
                        "username": "Manish_Malik",
                        "content": "because , if you divide -2147483648 with -1 it leaves you with the quotient 2147483648 which  is               ( 2 to the power 32 +1 )which means strictly greater than( 2 to the power 32 )and in such case you have  to return  2 to the power 32 which is equal to 2147483647 mentioned above in the question.\\n "
                    },
                    {
                        "username": "AdamGold",
                        "content": "Not a bad test case. This is what makes the problem medium instead of easy. Essentially it wants the overflow behavior to cap at the bounds, rather than looping.\n\n2147483648 is greater than Int.MAX_VAUE, hence it wants the answer for that case to be Int.MAX_VAUE\n\nthis question appears too be a bit shifting problem, even though that's arguably multiplication... I got a working solution without bit shifting, but it runs out of time. "
                    },
                    {
                        "username": "bcheco",
                        "content": "Hello,\\n\\nI am currently attempting this problem in swift and the test case is \\n-2147483648\\n-1\\nMy output is 2147483648 but the expected out put is 2147483647. Can someone explained why that is the expected out put?"
                    },
                    {
                        "username": "Rahul_Agnihotri4444",
                        "content": "because 2147483648 is > 2^31 - 1  hence it should return 2^31 - 1 which is 2147483647"
                    },
                    {
                        "username": "Pranjal_Gaur",
                        "content": "I read the question, thought about it for sometime, built an approach and then implemented it. \\nThe solution didn\\'t get accepted. Till now, everything was fine, as it happens often, lol.\\nBut, it got interesting when I even tried submitting the solutions from the discussionf forum, that the solutions didn\\'t get accepted. It has happened with me for the first time."
                    },
                    {
                        "username": "Shashank_Sharma-Developer",
                        "content": "Test case of this question are sense-less\\nbut I learn many new thing in this but waste a full day on it \\nuntil no perfect solution\\n"
                    },
                    {
                        "username": "msbeens",
                        "content": "Ruby solution fails for test case\\n512 / 989 test cases passed.\\n\\nInput:\\n-2147483648\\n-1\\nOutput:\\n2147483648\\nExpected:\\n2147483647\\n\\nOutput expected is definitely wrong."
                    },
                    {
                        "username": "alpiyidir",
                        "content": "\"if the quotient is strictly greater than 2^31 - 1, then return 2^31 - 1\" you are attempting to return 2^31 which is not in the range of a 32 bit signed int."
                    },
                    {
                        "username": "jarc",
                        "content": "And then the solution will be trivial, if it's allowed :)"
                    },
                    {
                        "username": "PrasadKarunagoda",
                        "content": "Test case passes for below input with an execution time of 1792ms:\\n-2147483648\\n1\\n\\nBut when I submit, it fails **for the same input** saying \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "charonme",
                        "content": "yes, 1792ms is way too long, you should be able to do it 100x faster"
                    },
                    {
                        "username": "san_py",
                        "content": "I always wonder what do they get by asking these  questions .?"
                    },
                    {
                        "username": "laihm6",
                        "content": "what is testcase 994. it has empty test case. "
                    },
                    {
                        "username": "julianbui",
                        "content": "123456789101"
                    },
                    {
                        "username": "eiko03",
                        "content": "Why is it a wrong answer, can anyone explain please. It is showing -1 the devidend\\n\\n![image](https://assets.leetcode.com/users/images/959a97b8-f9b5-4ca9-91ec-5b386ecffc23_1645611575.0239067.png)\\n"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    }
                ]
            },
            {
                "id": 1568341,
                "content": [
                    {
                        "username": "chandra627",
                        "content": "\\nInput:\\n-2147483648\\n-1\\nExpected:\\n2147483647\\n\\nHow is this correct?\\nBad test case."
                    },
                    {
                        "username": "Manish_Malik",
                        "content": "because , if you divide -2147483648 with -1 it leaves you with the quotient 2147483648 which  is               ( 2 to the power 32 +1 )which means strictly greater than( 2 to the power 32 )and in such case you have  to return  2 to the power 32 which is equal to 2147483647 mentioned above in the question.\\n "
                    },
                    {
                        "username": "AdamGold",
                        "content": "Not a bad test case. This is what makes the problem medium instead of easy. Essentially it wants the overflow behavior to cap at the bounds, rather than looping.\n\n2147483648 is greater than Int.MAX_VAUE, hence it wants the answer for that case to be Int.MAX_VAUE\n\nthis question appears too be a bit shifting problem, even though that's arguably multiplication... I got a working solution without bit shifting, but it runs out of time. "
                    },
                    {
                        "username": "bcheco",
                        "content": "Hello,\\n\\nI am currently attempting this problem in swift and the test case is \\n-2147483648\\n-1\\nMy output is 2147483648 but the expected out put is 2147483647. Can someone explained why that is the expected out put?"
                    },
                    {
                        "username": "Rahul_Agnihotri4444",
                        "content": "because 2147483648 is > 2^31 - 1  hence it should return 2^31 - 1 which is 2147483647"
                    },
                    {
                        "username": "Pranjal_Gaur",
                        "content": "I read the question, thought about it for sometime, built an approach and then implemented it. \\nThe solution didn\\'t get accepted. Till now, everything was fine, as it happens often, lol.\\nBut, it got interesting when I even tried submitting the solutions from the discussionf forum, that the solutions didn\\'t get accepted. It has happened with me for the first time."
                    },
                    {
                        "username": "Shashank_Sharma-Developer",
                        "content": "Test case of this question are sense-less\\nbut I learn many new thing in this but waste a full day on it \\nuntil no perfect solution\\n"
                    },
                    {
                        "username": "msbeens",
                        "content": "Ruby solution fails for test case\\n512 / 989 test cases passed.\\n\\nInput:\\n-2147483648\\n-1\\nOutput:\\n2147483648\\nExpected:\\n2147483647\\n\\nOutput expected is definitely wrong."
                    },
                    {
                        "username": "alpiyidir",
                        "content": "\"if the quotient is strictly greater than 2^31 - 1, then return 2^31 - 1\" you are attempting to return 2^31 which is not in the range of a 32 bit signed int."
                    },
                    {
                        "username": "jarc",
                        "content": "And then the solution will be trivial, if it's allowed :)"
                    },
                    {
                        "username": "PrasadKarunagoda",
                        "content": "Test case passes for below input with an execution time of 1792ms:\\n-2147483648\\n1\\n\\nBut when I submit, it fails **for the same input** saying \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "charonme",
                        "content": "yes, 1792ms is way too long, you should be able to do it 100x faster"
                    },
                    {
                        "username": "san_py",
                        "content": "I always wonder what do they get by asking these  questions .?"
                    },
                    {
                        "username": "laihm6",
                        "content": "what is testcase 994. it has empty test case. "
                    },
                    {
                        "username": "julianbui",
                        "content": "123456789101"
                    },
                    {
                        "username": "eiko03",
                        "content": "Why is it a wrong answer, can anyone explain please. It is showing -1 the devidend\\n\\n![image](https://assets.leetcode.com/users/images/959a97b8-f9b5-4ca9-91ec-5b386ecffc23_1645611575.0239067.png)\\n"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    }
                ]
            },
            {
                "id": 1567137,
                "content": [
                    {
                        "username": "chandra627",
                        "content": "\\nInput:\\n-2147483648\\n-1\\nExpected:\\n2147483647\\n\\nHow is this correct?\\nBad test case."
                    },
                    {
                        "username": "Manish_Malik",
                        "content": "because , if you divide -2147483648 with -1 it leaves you with the quotient 2147483648 which  is               ( 2 to the power 32 +1 )which means strictly greater than( 2 to the power 32 )and in such case you have  to return  2 to the power 32 which is equal to 2147483647 mentioned above in the question.\\n "
                    },
                    {
                        "username": "AdamGold",
                        "content": "Not a bad test case. This is what makes the problem medium instead of easy. Essentially it wants the overflow behavior to cap at the bounds, rather than looping.\n\n2147483648 is greater than Int.MAX_VAUE, hence it wants the answer for that case to be Int.MAX_VAUE\n\nthis question appears too be a bit shifting problem, even though that's arguably multiplication... I got a working solution without bit shifting, but it runs out of time. "
                    },
                    {
                        "username": "bcheco",
                        "content": "Hello,\\n\\nI am currently attempting this problem in swift and the test case is \\n-2147483648\\n-1\\nMy output is 2147483648 but the expected out put is 2147483647. Can someone explained why that is the expected out put?"
                    },
                    {
                        "username": "Rahul_Agnihotri4444",
                        "content": "because 2147483648 is > 2^31 - 1  hence it should return 2^31 - 1 which is 2147483647"
                    },
                    {
                        "username": "Pranjal_Gaur",
                        "content": "I read the question, thought about it for sometime, built an approach and then implemented it. \\nThe solution didn\\'t get accepted. Till now, everything was fine, as it happens often, lol.\\nBut, it got interesting when I even tried submitting the solutions from the discussionf forum, that the solutions didn\\'t get accepted. It has happened with me for the first time."
                    },
                    {
                        "username": "Shashank_Sharma-Developer",
                        "content": "Test case of this question are sense-less\\nbut I learn many new thing in this but waste a full day on it \\nuntil no perfect solution\\n"
                    },
                    {
                        "username": "msbeens",
                        "content": "Ruby solution fails for test case\\n512 / 989 test cases passed.\\n\\nInput:\\n-2147483648\\n-1\\nOutput:\\n2147483648\\nExpected:\\n2147483647\\n\\nOutput expected is definitely wrong."
                    },
                    {
                        "username": "alpiyidir",
                        "content": "\"if the quotient is strictly greater than 2^31 - 1, then return 2^31 - 1\" you are attempting to return 2^31 which is not in the range of a 32 bit signed int."
                    },
                    {
                        "username": "jarc",
                        "content": "And then the solution will be trivial, if it's allowed :)"
                    },
                    {
                        "username": "PrasadKarunagoda",
                        "content": "Test case passes for below input with an execution time of 1792ms:\\n-2147483648\\n1\\n\\nBut when I submit, it fails **for the same input** saying \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "charonme",
                        "content": "yes, 1792ms is way too long, you should be able to do it 100x faster"
                    },
                    {
                        "username": "san_py",
                        "content": "I always wonder what do they get by asking these  questions .?"
                    },
                    {
                        "username": "laihm6",
                        "content": "what is testcase 994. it has empty test case. "
                    },
                    {
                        "username": "julianbui",
                        "content": "123456789101"
                    },
                    {
                        "username": "eiko03",
                        "content": "Why is it a wrong answer, can anyone explain please. It is showing -1 the devidend\\n\\n![image](https://assets.leetcode.com/users/images/959a97b8-f9b5-4ca9-91ec-5b386ecffc23_1645611575.0239067.png)\\n"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    }
                ]
            },
            {
                "id": 1568290,
                "content": [
                    {
                        "username": "chandra627",
                        "content": "\\nInput:\\n-2147483648\\n-1\\nExpected:\\n2147483647\\n\\nHow is this correct?\\nBad test case."
                    },
                    {
                        "username": "Manish_Malik",
                        "content": "because , if you divide -2147483648 with -1 it leaves you with the quotient 2147483648 which  is               ( 2 to the power 32 +1 )which means strictly greater than( 2 to the power 32 )and in such case you have  to return  2 to the power 32 which is equal to 2147483647 mentioned above in the question.\\n "
                    },
                    {
                        "username": "AdamGold",
                        "content": "Not a bad test case. This is what makes the problem medium instead of easy. Essentially it wants the overflow behavior to cap at the bounds, rather than looping.\n\n2147483648 is greater than Int.MAX_VAUE, hence it wants the answer for that case to be Int.MAX_VAUE\n\nthis question appears too be a bit shifting problem, even though that's arguably multiplication... I got a working solution without bit shifting, but it runs out of time. "
                    },
                    {
                        "username": "bcheco",
                        "content": "Hello,\\n\\nI am currently attempting this problem in swift and the test case is \\n-2147483648\\n-1\\nMy output is 2147483648 but the expected out put is 2147483647. Can someone explained why that is the expected out put?"
                    },
                    {
                        "username": "Rahul_Agnihotri4444",
                        "content": "because 2147483648 is > 2^31 - 1  hence it should return 2^31 - 1 which is 2147483647"
                    },
                    {
                        "username": "Pranjal_Gaur",
                        "content": "I read the question, thought about it for sometime, built an approach and then implemented it. \\nThe solution didn\\'t get accepted. Till now, everything was fine, as it happens often, lol.\\nBut, it got interesting when I even tried submitting the solutions from the discussionf forum, that the solutions didn\\'t get accepted. It has happened with me for the first time."
                    },
                    {
                        "username": "Shashank_Sharma-Developer",
                        "content": "Test case of this question are sense-less\\nbut I learn many new thing in this but waste a full day on it \\nuntil no perfect solution\\n"
                    },
                    {
                        "username": "msbeens",
                        "content": "Ruby solution fails for test case\\n512 / 989 test cases passed.\\n\\nInput:\\n-2147483648\\n-1\\nOutput:\\n2147483648\\nExpected:\\n2147483647\\n\\nOutput expected is definitely wrong."
                    },
                    {
                        "username": "alpiyidir",
                        "content": "\"if the quotient is strictly greater than 2^31 - 1, then return 2^31 - 1\" you are attempting to return 2^31 which is not in the range of a 32 bit signed int."
                    },
                    {
                        "username": "jarc",
                        "content": "And then the solution will be trivial, if it's allowed :)"
                    },
                    {
                        "username": "PrasadKarunagoda",
                        "content": "Test case passes for below input with an execution time of 1792ms:\\n-2147483648\\n1\\n\\nBut when I submit, it fails **for the same input** saying \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "charonme",
                        "content": "yes, 1792ms is way too long, you should be able to do it 100x faster"
                    },
                    {
                        "username": "san_py",
                        "content": "I always wonder what do they get by asking these  questions .?"
                    },
                    {
                        "username": "laihm6",
                        "content": "what is testcase 994. it has empty test case. "
                    },
                    {
                        "username": "julianbui",
                        "content": "123456789101"
                    },
                    {
                        "username": "eiko03",
                        "content": "Why is it a wrong answer, can anyone explain please. It is showing -1 the devidend\\n\\n![image](https://assets.leetcode.com/users/images/959a97b8-f9b5-4ca9-91ec-5b386ecffc23_1645611575.0239067.png)\\n"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    }
                ]
            },
            {
                "id": 1566739,
                "content": [
                    {
                        "username": "chandra627",
                        "content": "\\nInput:\\n-2147483648\\n-1\\nExpected:\\n2147483647\\n\\nHow is this correct?\\nBad test case."
                    },
                    {
                        "username": "Manish_Malik",
                        "content": "because , if you divide -2147483648 with -1 it leaves you with the quotient 2147483648 which  is               ( 2 to the power 32 +1 )which means strictly greater than( 2 to the power 32 )and in such case you have  to return  2 to the power 32 which is equal to 2147483647 mentioned above in the question.\\n "
                    },
                    {
                        "username": "AdamGold",
                        "content": "Not a bad test case. This is what makes the problem medium instead of easy. Essentially it wants the overflow behavior to cap at the bounds, rather than looping.\n\n2147483648 is greater than Int.MAX_VAUE, hence it wants the answer for that case to be Int.MAX_VAUE\n\nthis question appears too be a bit shifting problem, even though that's arguably multiplication... I got a working solution without bit shifting, but it runs out of time. "
                    },
                    {
                        "username": "bcheco",
                        "content": "Hello,\\n\\nI am currently attempting this problem in swift and the test case is \\n-2147483648\\n-1\\nMy output is 2147483648 but the expected out put is 2147483647. Can someone explained why that is the expected out put?"
                    },
                    {
                        "username": "Rahul_Agnihotri4444",
                        "content": "because 2147483648 is > 2^31 - 1  hence it should return 2^31 - 1 which is 2147483647"
                    },
                    {
                        "username": "Pranjal_Gaur",
                        "content": "I read the question, thought about it for sometime, built an approach and then implemented it. \\nThe solution didn\\'t get accepted. Till now, everything was fine, as it happens often, lol.\\nBut, it got interesting when I even tried submitting the solutions from the discussionf forum, that the solutions didn\\'t get accepted. It has happened with me for the first time."
                    },
                    {
                        "username": "Shashank_Sharma-Developer",
                        "content": "Test case of this question are sense-less\\nbut I learn many new thing in this but waste a full day on it \\nuntil no perfect solution\\n"
                    },
                    {
                        "username": "msbeens",
                        "content": "Ruby solution fails for test case\\n512 / 989 test cases passed.\\n\\nInput:\\n-2147483648\\n-1\\nOutput:\\n2147483648\\nExpected:\\n2147483647\\n\\nOutput expected is definitely wrong."
                    },
                    {
                        "username": "alpiyidir",
                        "content": "\"if the quotient is strictly greater than 2^31 - 1, then return 2^31 - 1\" you are attempting to return 2^31 which is not in the range of a 32 bit signed int."
                    },
                    {
                        "username": "jarc",
                        "content": "And then the solution will be trivial, if it's allowed :)"
                    },
                    {
                        "username": "PrasadKarunagoda",
                        "content": "Test case passes for below input with an execution time of 1792ms:\\n-2147483648\\n1\\n\\nBut when I submit, it fails **for the same input** saying \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "charonme",
                        "content": "yes, 1792ms is way too long, you should be able to do it 100x faster"
                    },
                    {
                        "username": "san_py",
                        "content": "I always wonder what do they get by asking these  questions .?"
                    },
                    {
                        "username": "laihm6",
                        "content": "what is testcase 994. it has empty test case. "
                    },
                    {
                        "username": "julianbui",
                        "content": "123456789101"
                    },
                    {
                        "username": "eiko03",
                        "content": "Why is it a wrong answer, can anyone explain please. It is showing -1 the devidend\\n\\n![image](https://assets.leetcode.com/users/images/959a97b8-f9b5-4ca9-91ec-5b386ecffc23_1645611575.0239067.png)\\n"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    }
                ]
            },
            {
                "id": 1567540,
                "content": [
                    {
                        "username": "chandra627",
                        "content": "\\nInput:\\n-2147483648\\n-1\\nExpected:\\n2147483647\\n\\nHow is this correct?\\nBad test case."
                    },
                    {
                        "username": "Manish_Malik",
                        "content": "because , if you divide -2147483648 with -1 it leaves you with the quotient 2147483648 which  is               ( 2 to the power 32 +1 )which means strictly greater than( 2 to the power 32 )and in such case you have  to return  2 to the power 32 which is equal to 2147483647 mentioned above in the question.\\n "
                    },
                    {
                        "username": "AdamGold",
                        "content": "Not a bad test case. This is what makes the problem medium instead of easy. Essentially it wants the overflow behavior to cap at the bounds, rather than looping.\n\n2147483648 is greater than Int.MAX_VAUE, hence it wants the answer for that case to be Int.MAX_VAUE\n\nthis question appears too be a bit shifting problem, even though that's arguably multiplication... I got a working solution without bit shifting, but it runs out of time. "
                    },
                    {
                        "username": "bcheco",
                        "content": "Hello,\\n\\nI am currently attempting this problem in swift and the test case is \\n-2147483648\\n-1\\nMy output is 2147483648 but the expected out put is 2147483647. Can someone explained why that is the expected out put?"
                    },
                    {
                        "username": "Rahul_Agnihotri4444",
                        "content": "because 2147483648 is > 2^31 - 1  hence it should return 2^31 - 1 which is 2147483647"
                    },
                    {
                        "username": "Pranjal_Gaur",
                        "content": "I read the question, thought about it for sometime, built an approach and then implemented it. \\nThe solution didn\\'t get accepted. Till now, everything was fine, as it happens often, lol.\\nBut, it got interesting when I even tried submitting the solutions from the discussionf forum, that the solutions didn\\'t get accepted. It has happened with me for the first time."
                    },
                    {
                        "username": "Shashank_Sharma-Developer",
                        "content": "Test case of this question are sense-less\\nbut I learn many new thing in this but waste a full day on it \\nuntil no perfect solution\\n"
                    },
                    {
                        "username": "msbeens",
                        "content": "Ruby solution fails for test case\\n512 / 989 test cases passed.\\n\\nInput:\\n-2147483648\\n-1\\nOutput:\\n2147483648\\nExpected:\\n2147483647\\n\\nOutput expected is definitely wrong."
                    },
                    {
                        "username": "alpiyidir",
                        "content": "\"if the quotient is strictly greater than 2^31 - 1, then return 2^31 - 1\" you are attempting to return 2^31 which is not in the range of a 32 bit signed int."
                    },
                    {
                        "username": "jarc",
                        "content": "And then the solution will be trivial, if it's allowed :)"
                    },
                    {
                        "username": "PrasadKarunagoda",
                        "content": "Test case passes for below input with an execution time of 1792ms:\\n-2147483648\\n1\\n\\nBut when I submit, it fails **for the same input** saying \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "charonme",
                        "content": "yes, 1792ms is way too long, you should be able to do it 100x faster"
                    },
                    {
                        "username": "san_py",
                        "content": "I always wonder what do they get by asking these  questions .?"
                    },
                    {
                        "username": "laihm6",
                        "content": "what is testcase 994. it has empty test case. "
                    },
                    {
                        "username": "julianbui",
                        "content": "123456789101"
                    },
                    {
                        "username": "eiko03",
                        "content": "Why is it a wrong answer, can anyone explain please. It is showing -1 the devidend\\n\\n![image](https://assets.leetcode.com/users/images/959a97b8-f9b5-4ca9-91ec-5b386ecffc23_1645611575.0239067.png)\\n"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    }
                ]
            },
            {
                "id": 1569289,
                "content": [
                    {
                        "username": "chandra627",
                        "content": "\\nInput:\\n-2147483648\\n-1\\nExpected:\\n2147483647\\n\\nHow is this correct?\\nBad test case."
                    },
                    {
                        "username": "Manish_Malik",
                        "content": "because , if you divide -2147483648 with -1 it leaves you with the quotient 2147483648 which  is               ( 2 to the power 32 +1 )which means strictly greater than( 2 to the power 32 )and in such case you have  to return  2 to the power 32 which is equal to 2147483647 mentioned above in the question.\\n "
                    },
                    {
                        "username": "AdamGold",
                        "content": "Not a bad test case. This is what makes the problem medium instead of easy. Essentially it wants the overflow behavior to cap at the bounds, rather than looping.\n\n2147483648 is greater than Int.MAX_VAUE, hence it wants the answer for that case to be Int.MAX_VAUE\n\nthis question appears too be a bit shifting problem, even though that's arguably multiplication... I got a working solution without bit shifting, but it runs out of time. "
                    },
                    {
                        "username": "bcheco",
                        "content": "Hello,\\n\\nI am currently attempting this problem in swift and the test case is \\n-2147483648\\n-1\\nMy output is 2147483648 but the expected out put is 2147483647. Can someone explained why that is the expected out put?"
                    },
                    {
                        "username": "Rahul_Agnihotri4444",
                        "content": "because 2147483648 is > 2^31 - 1  hence it should return 2^31 - 1 which is 2147483647"
                    },
                    {
                        "username": "Pranjal_Gaur",
                        "content": "I read the question, thought about it for sometime, built an approach and then implemented it. \\nThe solution didn\\'t get accepted. Till now, everything was fine, as it happens often, lol.\\nBut, it got interesting when I even tried submitting the solutions from the discussionf forum, that the solutions didn\\'t get accepted. It has happened with me for the first time."
                    },
                    {
                        "username": "Shashank_Sharma-Developer",
                        "content": "Test case of this question are sense-less\\nbut I learn many new thing in this but waste a full day on it \\nuntil no perfect solution\\n"
                    },
                    {
                        "username": "msbeens",
                        "content": "Ruby solution fails for test case\\n512 / 989 test cases passed.\\n\\nInput:\\n-2147483648\\n-1\\nOutput:\\n2147483648\\nExpected:\\n2147483647\\n\\nOutput expected is definitely wrong."
                    },
                    {
                        "username": "alpiyidir",
                        "content": "\"if the quotient is strictly greater than 2^31 - 1, then return 2^31 - 1\" you are attempting to return 2^31 which is not in the range of a 32 bit signed int."
                    },
                    {
                        "username": "jarc",
                        "content": "And then the solution will be trivial, if it's allowed :)"
                    },
                    {
                        "username": "PrasadKarunagoda",
                        "content": "Test case passes for below input with an execution time of 1792ms:\\n-2147483648\\n1\\n\\nBut when I submit, it fails **for the same input** saying \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "charonme",
                        "content": "yes, 1792ms is way too long, you should be able to do it 100x faster"
                    },
                    {
                        "username": "san_py",
                        "content": "I always wonder what do they get by asking these  questions .?"
                    },
                    {
                        "username": "laihm6",
                        "content": "what is testcase 994. it has empty test case. "
                    },
                    {
                        "username": "julianbui",
                        "content": "123456789101"
                    },
                    {
                        "username": "eiko03",
                        "content": "Why is it a wrong answer, can anyone explain please. It is showing -1 the devidend\\n\\n![image](https://assets.leetcode.com/users/images/959a97b8-f9b5-4ca9-91ec-5b386ecffc23_1645611575.0239067.png)\\n"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    }
                ]
            },
            {
                "id": 1874916,
                "content": [
                    {
                        "username": "chandra627",
                        "content": "\\nInput:\\n-2147483648\\n-1\\nExpected:\\n2147483647\\n\\nHow is this correct?\\nBad test case."
                    },
                    {
                        "username": "Manish_Malik",
                        "content": "because , if you divide -2147483648 with -1 it leaves you with the quotient 2147483648 which  is               ( 2 to the power 32 +1 )which means strictly greater than( 2 to the power 32 )and in such case you have  to return  2 to the power 32 which is equal to 2147483647 mentioned above in the question.\\n "
                    },
                    {
                        "username": "AdamGold",
                        "content": "Not a bad test case. This is what makes the problem medium instead of easy. Essentially it wants the overflow behavior to cap at the bounds, rather than looping.\n\n2147483648 is greater than Int.MAX_VAUE, hence it wants the answer for that case to be Int.MAX_VAUE\n\nthis question appears too be a bit shifting problem, even though that's arguably multiplication... I got a working solution without bit shifting, but it runs out of time. "
                    },
                    {
                        "username": "bcheco",
                        "content": "Hello,\\n\\nI am currently attempting this problem in swift and the test case is \\n-2147483648\\n-1\\nMy output is 2147483648 but the expected out put is 2147483647. Can someone explained why that is the expected out put?"
                    },
                    {
                        "username": "Rahul_Agnihotri4444",
                        "content": "because 2147483648 is > 2^31 - 1  hence it should return 2^31 - 1 which is 2147483647"
                    },
                    {
                        "username": "Pranjal_Gaur",
                        "content": "I read the question, thought about it for sometime, built an approach and then implemented it. \\nThe solution didn\\'t get accepted. Till now, everything was fine, as it happens often, lol.\\nBut, it got interesting when I even tried submitting the solutions from the discussionf forum, that the solutions didn\\'t get accepted. It has happened with me for the first time."
                    },
                    {
                        "username": "Shashank_Sharma-Developer",
                        "content": "Test case of this question are sense-less\\nbut I learn many new thing in this but waste a full day on it \\nuntil no perfect solution\\n"
                    },
                    {
                        "username": "msbeens",
                        "content": "Ruby solution fails for test case\\n512 / 989 test cases passed.\\n\\nInput:\\n-2147483648\\n-1\\nOutput:\\n2147483648\\nExpected:\\n2147483647\\n\\nOutput expected is definitely wrong."
                    },
                    {
                        "username": "alpiyidir",
                        "content": "\"if the quotient is strictly greater than 2^31 - 1, then return 2^31 - 1\" you are attempting to return 2^31 which is not in the range of a 32 bit signed int."
                    },
                    {
                        "username": "jarc",
                        "content": "And then the solution will be trivial, if it's allowed :)"
                    },
                    {
                        "username": "PrasadKarunagoda",
                        "content": "Test case passes for below input with an execution time of 1792ms:\\n-2147483648\\n1\\n\\nBut when I submit, it fails **for the same input** saying \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "charonme",
                        "content": "yes, 1792ms is way too long, you should be able to do it 100x faster"
                    },
                    {
                        "username": "san_py",
                        "content": "I always wonder what do they get by asking these  questions .?"
                    },
                    {
                        "username": "laihm6",
                        "content": "what is testcase 994. it has empty test case. "
                    },
                    {
                        "username": "julianbui",
                        "content": "123456789101"
                    },
                    {
                        "username": "eiko03",
                        "content": "Why is it a wrong answer, can anyone explain please. It is showing -1 the devidend\\n\\n![image](https://assets.leetcode.com/users/images/959a97b8-f9b5-4ca9-91ec-5b386ecffc23_1645611575.0239067.png)\\n"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    }
                ]
            },
            {
                "id": 1567735,
                "content": [
                    {
                        "username": "chandra627",
                        "content": "\\nInput:\\n-2147483648\\n-1\\nExpected:\\n2147483647\\n\\nHow is this correct?\\nBad test case."
                    },
                    {
                        "username": "Manish_Malik",
                        "content": "because , if you divide -2147483648 with -1 it leaves you with the quotient 2147483648 which  is               ( 2 to the power 32 +1 )which means strictly greater than( 2 to the power 32 )and in such case you have  to return  2 to the power 32 which is equal to 2147483647 mentioned above in the question.\\n "
                    },
                    {
                        "username": "AdamGold",
                        "content": "Not a bad test case. This is what makes the problem medium instead of easy. Essentially it wants the overflow behavior to cap at the bounds, rather than looping.\n\n2147483648 is greater than Int.MAX_VAUE, hence it wants the answer for that case to be Int.MAX_VAUE\n\nthis question appears too be a bit shifting problem, even though that's arguably multiplication... I got a working solution without bit shifting, but it runs out of time. "
                    },
                    {
                        "username": "bcheco",
                        "content": "Hello,\\n\\nI am currently attempting this problem in swift and the test case is \\n-2147483648\\n-1\\nMy output is 2147483648 but the expected out put is 2147483647. Can someone explained why that is the expected out put?"
                    },
                    {
                        "username": "Rahul_Agnihotri4444",
                        "content": "because 2147483648 is > 2^31 - 1  hence it should return 2^31 - 1 which is 2147483647"
                    },
                    {
                        "username": "Pranjal_Gaur",
                        "content": "I read the question, thought about it for sometime, built an approach and then implemented it. \\nThe solution didn\\'t get accepted. Till now, everything was fine, as it happens often, lol.\\nBut, it got interesting when I even tried submitting the solutions from the discussionf forum, that the solutions didn\\'t get accepted. It has happened with me for the first time."
                    },
                    {
                        "username": "Shashank_Sharma-Developer",
                        "content": "Test case of this question are sense-less\\nbut I learn many new thing in this but waste a full day on it \\nuntil no perfect solution\\n"
                    },
                    {
                        "username": "msbeens",
                        "content": "Ruby solution fails for test case\\n512 / 989 test cases passed.\\n\\nInput:\\n-2147483648\\n-1\\nOutput:\\n2147483648\\nExpected:\\n2147483647\\n\\nOutput expected is definitely wrong."
                    },
                    {
                        "username": "alpiyidir",
                        "content": "\"if the quotient is strictly greater than 2^31 - 1, then return 2^31 - 1\" you are attempting to return 2^31 which is not in the range of a 32 bit signed int."
                    },
                    {
                        "username": "jarc",
                        "content": "And then the solution will be trivial, if it's allowed :)"
                    },
                    {
                        "username": "PrasadKarunagoda",
                        "content": "Test case passes for below input with an execution time of 1792ms:\\n-2147483648\\n1\\n\\nBut when I submit, it fails **for the same input** saying \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "charonme",
                        "content": "yes, 1792ms is way too long, you should be able to do it 100x faster"
                    },
                    {
                        "username": "san_py",
                        "content": "I always wonder what do they get by asking these  questions .?"
                    },
                    {
                        "username": "laihm6",
                        "content": "what is testcase 994. it has empty test case. "
                    },
                    {
                        "username": "julianbui",
                        "content": "123456789101"
                    },
                    {
                        "username": "eiko03",
                        "content": "Why is it a wrong answer, can anyone explain please. It is showing -1 the devidend\\n\\n![image](https://assets.leetcode.com/users/images/959a97b8-f9b5-4ca9-91ec-5b386ecffc23_1645611575.0239067.png)\\n"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    }
                ]
            },
            {
                "id": 1567731,
                "content": [
                    {
                        "username": "chandra627",
                        "content": "\\nInput:\\n-2147483648\\n-1\\nExpected:\\n2147483647\\n\\nHow is this correct?\\nBad test case."
                    },
                    {
                        "username": "Manish_Malik",
                        "content": "because , if you divide -2147483648 with -1 it leaves you with the quotient 2147483648 which  is               ( 2 to the power 32 +1 )which means strictly greater than( 2 to the power 32 )and in such case you have  to return  2 to the power 32 which is equal to 2147483647 mentioned above in the question.\\n "
                    },
                    {
                        "username": "AdamGold",
                        "content": "Not a bad test case. This is what makes the problem medium instead of easy. Essentially it wants the overflow behavior to cap at the bounds, rather than looping.\n\n2147483648 is greater than Int.MAX_VAUE, hence it wants the answer for that case to be Int.MAX_VAUE\n\nthis question appears too be a bit shifting problem, even though that's arguably multiplication... I got a working solution without bit shifting, but it runs out of time. "
                    },
                    {
                        "username": "bcheco",
                        "content": "Hello,\\n\\nI am currently attempting this problem in swift and the test case is \\n-2147483648\\n-1\\nMy output is 2147483648 but the expected out put is 2147483647. Can someone explained why that is the expected out put?"
                    },
                    {
                        "username": "Rahul_Agnihotri4444",
                        "content": "because 2147483648 is > 2^31 - 1  hence it should return 2^31 - 1 which is 2147483647"
                    },
                    {
                        "username": "Pranjal_Gaur",
                        "content": "I read the question, thought about it for sometime, built an approach and then implemented it. \\nThe solution didn\\'t get accepted. Till now, everything was fine, as it happens often, lol.\\nBut, it got interesting when I even tried submitting the solutions from the discussionf forum, that the solutions didn\\'t get accepted. It has happened with me for the first time."
                    },
                    {
                        "username": "Shashank_Sharma-Developer",
                        "content": "Test case of this question are sense-less\\nbut I learn many new thing in this but waste a full day on it \\nuntil no perfect solution\\n"
                    },
                    {
                        "username": "msbeens",
                        "content": "Ruby solution fails for test case\\n512 / 989 test cases passed.\\n\\nInput:\\n-2147483648\\n-1\\nOutput:\\n2147483648\\nExpected:\\n2147483647\\n\\nOutput expected is definitely wrong."
                    },
                    {
                        "username": "alpiyidir",
                        "content": "\"if the quotient is strictly greater than 2^31 - 1, then return 2^31 - 1\" you are attempting to return 2^31 which is not in the range of a 32 bit signed int."
                    },
                    {
                        "username": "jarc",
                        "content": "And then the solution will be trivial, if it's allowed :)"
                    },
                    {
                        "username": "PrasadKarunagoda",
                        "content": "Test case passes for below input with an execution time of 1792ms:\\n-2147483648\\n1\\n\\nBut when I submit, it fails **for the same input** saying \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "charonme",
                        "content": "yes, 1792ms is way too long, you should be able to do it 100x faster"
                    },
                    {
                        "username": "san_py",
                        "content": "I always wonder what do they get by asking these  questions .?"
                    },
                    {
                        "username": "laihm6",
                        "content": "what is testcase 994. it has empty test case. "
                    },
                    {
                        "username": "julianbui",
                        "content": "123456789101"
                    },
                    {
                        "username": "eiko03",
                        "content": "Why is it a wrong answer, can anyone explain please. It is showing -1 the devidend\\n\\n![image](https://assets.leetcode.com/users/images/959a97b8-f9b5-4ca9-91ec-5b386ecffc23_1645611575.0239067.png)\\n"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    }
                ]
            },
            {
                "id": 1979403,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Try these 7 test cases , before submitting\n```\n-2147483648\n2147483647\n2147483647\n2147483647\n1981445587\n1172010393\n1100540749\n-1090366779\n-2147483648\n2\n-2147483648\n1\n2147483647\n2\n```"
                    },
                    {
                        "username": "user9348239482934",
                        "content": "Has anyone had such an error?\\n![image](https://i.ibb.co/S5zVR0K/2023-06-15-10-11-03.png)"
                    },
                    {
                        "username": "niketsharma22",
                        "content": "Leetcode: How many corner scenarios will you add? \\nComposer: YES!!!!!!!"
                    },
                    {
                        "username": "Timy3005",
                        "content": "The last test case is just empty although it clearly said that dividend and divisor are numbers. (-2^31 <= dividend, divisor <= 2^31 - 1)\\n\\nIt says: \"dividend =\"\\n\\nNo number"
                    },
                    {
                        "username": "Ghosted",
                        "content": "[@Timy3005](/Timy3005) same for me. good.times."
                    },
                    {
                        "username": "Timy3005",
                        "content": "Furthermore, if I try and put \"empty\" (just nothing) in the test case it gives me an error \" is not a valid value or type integer\""
                    },
                    {
                        "username": "priyatanwar2009",
                        "content": "Approach -2 , powerOfTwo = -1 is being initizalized with -1. Why??"
                    },
                    {
                        "username": "MR-D05",
                        "content": "Just curious what some of your thoughts are about why this problem sucks."
                    },
                    {
                        "username": "calvin-li",
                        "content": "-2147483648 / -1 == -2147483648, but output is -2147483647 for python"
                    },
                    {
                        "username": "larryleguo",
                        "content": "https://leetcode.com/submissions/detail/29323275/\\n\\n987 / 988 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 1 minute ago\\nInput:\\t-2147483648, -1\\nOutput:\\t2147483648\\nExpected:\\t2147483647\\n\\nClearly the test case gives the wrong results. I use python. I think this may be related with a bug in python:\\nFor integer division in C and Java, we have\\n1/2 = 0, \\n-1/2 = 0.\\nHowever, in python, we have\\n1/2 = 0\\n-1/2 = -1.\\nSomeone may argue this is what python defines, but I think it should be a bug since it is incompatible to other programming languages."
                    },
                    {
                        "username": "bodypainter",
                        "content": "Most test cases hinge on the input values being INT_MIN. So, you need to either type cast to long long to solve or do a cumbersome switch case :( :("
                    },
                    {
                        "username": "kemp",
                        "content": "Ah, now I remember why I hate leetcode \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1929966,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Try these 7 test cases , before submitting\n```\n-2147483648\n2147483647\n2147483647\n2147483647\n1981445587\n1172010393\n1100540749\n-1090366779\n-2147483648\n2\n-2147483648\n1\n2147483647\n2\n```"
                    },
                    {
                        "username": "user9348239482934",
                        "content": "Has anyone had such an error?\\n![image](https://i.ibb.co/S5zVR0K/2023-06-15-10-11-03.png)"
                    },
                    {
                        "username": "niketsharma22",
                        "content": "Leetcode: How many corner scenarios will you add? \\nComposer: YES!!!!!!!"
                    },
                    {
                        "username": "Timy3005",
                        "content": "The last test case is just empty although it clearly said that dividend and divisor are numbers. (-2^31 <= dividend, divisor <= 2^31 - 1)\\n\\nIt says: \"dividend =\"\\n\\nNo number"
                    },
                    {
                        "username": "Ghosted",
                        "content": "[@Timy3005](/Timy3005) same for me. good.times."
                    },
                    {
                        "username": "Timy3005",
                        "content": "Furthermore, if I try and put \"empty\" (just nothing) in the test case it gives me an error \" is not a valid value or type integer\""
                    },
                    {
                        "username": "priyatanwar2009",
                        "content": "Approach -2 , powerOfTwo = -1 is being initizalized with -1. Why??"
                    },
                    {
                        "username": "MR-D05",
                        "content": "Just curious what some of your thoughts are about why this problem sucks."
                    },
                    {
                        "username": "calvin-li",
                        "content": "-2147483648 / -1 == -2147483648, but output is -2147483647 for python"
                    },
                    {
                        "username": "larryleguo",
                        "content": "https://leetcode.com/submissions/detail/29323275/\\n\\n987 / 988 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 1 minute ago\\nInput:\\t-2147483648, -1\\nOutput:\\t2147483648\\nExpected:\\t2147483647\\n\\nClearly the test case gives the wrong results. I use python. I think this may be related with a bug in python:\\nFor integer division in C and Java, we have\\n1/2 = 0, \\n-1/2 = 0.\\nHowever, in python, we have\\n1/2 = 0\\n-1/2 = -1.\\nSomeone may argue this is what python defines, but I think it should be a bug since it is incompatible to other programming languages."
                    },
                    {
                        "username": "bodypainter",
                        "content": "Most test cases hinge on the input values being INT_MIN. So, you need to either type cast to long long to solve or do a cumbersome switch case :( :("
                    },
                    {
                        "username": "kemp",
                        "content": "Ah, now I remember why I hate leetcode \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1840585,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Try these 7 test cases , before submitting\n```\n-2147483648\n2147483647\n2147483647\n2147483647\n1981445587\n1172010393\n1100540749\n-1090366779\n-2147483648\n2\n-2147483648\n1\n2147483647\n2\n```"
                    },
                    {
                        "username": "user9348239482934",
                        "content": "Has anyone had such an error?\\n![image](https://i.ibb.co/S5zVR0K/2023-06-15-10-11-03.png)"
                    },
                    {
                        "username": "niketsharma22",
                        "content": "Leetcode: How many corner scenarios will you add? \\nComposer: YES!!!!!!!"
                    },
                    {
                        "username": "Timy3005",
                        "content": "The last test case is just empty although it clearly said that dividend and divisor are numbers. (-2^31 <= dividend, divisor <= 2^31 - 1)\\n\\nIt says: \"dividend =\"\\n\\nNo number"
                    },
                    {
                        "username": "Ghosted",
                        "content": "[@Timy3005](/Timy3005) same for me. good.times."
                    },
                    {
                        "username": "Timy3005",
                        "content": "Furthermore, if I try and put \"empty\" (just nothing) in the test case it gives me an error \" is not a valid value or type integer\""
                    },
                    {
                        "username": "priyatanwar2009",
                        "content": "Approach -2 , powerOfTwo = -1 is being initizalized with -1. Why??"
                    },
                    {
                        "username": "MR-D05",
                        "content": "Just curious what some of your thoughts are about why this problem sucks."
                    },
                    {
                        "username": "calvin-li",
                        "content": "-2147483648 / -1 == -2147483648, but output is -2147483647 for python"
                    },
                    {
                        "username": "larryleguo",
                        "content": "https://leetcode.com/submissions/detail/29323275/\\n\\n987 / 988 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 1 minute ago\\nInput:\\t-2147483648, -1\\nOutput:\\t2147483648\\nExpected:\\t2147483647\\n\\nClearly the test case gives the wrong results. I use python. I think this may be related with a bug in python:\\nFor integer division in C and Java, we have\\n1/2 = 0, \\n-1/2 = 0.\\nHowever, in python, we have\\n1/2 = 0\\n-1/2 = -1.\\nSomeone may argue this is what python defines, but I think it should be a bug since it is incompatible to other programming languages."
                    },
                    {
                        "username": "bodypainter",
                        "content": "Most test cases hinge on the input values being INT_MIN. So, you need to either type cast to long long to solve or do a cumbersome switch case :( :("
                    },
                    {
                        "username": "kemp",
                        "content": "Ah, now I remember why I hate leetcode \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1816498,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Try these 7 test cases , before submitting\n```\n-2147483648\n2147483647\n2147483647\n2147483647\n1981445587\n1172010393\n1100540749\n-1090366779\n-2147483648\n2\n-2147483648\n1\n2147483647\n2\n```"
                    },
                    {
                        "username": "user9348239482934",
                        "content": "Has anyone had such an error?\\n![image](https://i.ibb.co/S5zVR0K/2023-06-15-10-11-03.png)"
                    },
                    {
                        "username": "niketsharma22",
                        "content": "Leetcode: How many corner scenarios will you add? \\nComposer: YES!!!!!!!"
                    },
                    {
                        "username": "Timy3005",
                        "content": "The last test case is just empty although it clearly said that dividend and divisor are numbers. (-2^31 <= dividend, divisor <= 2^31 - 1)\\n\\nIt says: \"dividend =\"\\n\\nNo number"
                    },
                    {
                        "username": "Ghosted",
                        "content": "[@Timy3005](/Timy3005) same for me. good.times."
                    },
                    {
                        "username": "Timy3005",
                        "content": "Furthermore, if I try and put \"empty\" (just nothing) in the test case it gives me an error \" is not a valid value or type integer\""
                    },
                    {
                        "username": "priyatanwar2009",
                        "content": "Approach -2 , powerOfTwo = -1 is being initizalized with -1. Why??"
                    },
                    {
                        "username": "MR-D05",
                        "content": "Just curious what some of your thoughts are about why this problem sucks."
                    },
                    {
                        "username": "calvin-li",
                        "content": "-2147483648 / -1 == -2147483648, but output is -2147483647 for python"
                    },
                    {
                        "username": "larryleguo",
                        "content": "https://leetcode.com/submissions/detail/29323275/\\n\\n987 / 988 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 1 minute ago\\nInput:\\t-2147483648, -1\\nOutput:\\t2147483648\\nExpected:\\t2147483647\\n\\nClearly the test case gives the wrong results. I use python. I think this may be related with a bug in python:\\nFor integer division in C and Java, we have\\n1/2 = 0, \\n-1/2 = 0.\\nHowever, in python, we have\\n1/2 = 0\\n-1/2 = -1.\\nSomeone may argue this is what python defines, but I think it should be a bug since it is incompatible to other programming languages."
                    },
                    {
                        "username": "bodypainter",
                        "content": "Most test cases hinge on the input values being INT_MIN. So, you need to either type cast to long long to solve or do a cumbersome switch case :( :("
                    },
                    {
                        "username": "kemp",
                        "content": "Ah, now I remember why I hate leetcode \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1568477,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Try these 7 test cases , before submitting\n```\n-2147483648\n2147483647\n2147483647\n2147483647\n1981445587\n1172010393\n1100540749\n-1090366779\n-2147483648\n2\n-2147483648\n1\n2147483647\n2\n```"
                    },
                    {
                        "username": "user9348239482934",
                        "content": "Has anyone had such an error?\\n![image](https://i.ibb.co/S5zVR0K/2023-06-15-10-11-03.png)"
                    },
                    {
                        "username": "niketsharma22",
                        "content": "Leetcode: How many corner scenarios will you add? \\nComposer: YES!!!!!!!"
                    },
                    {
                        "username": "Timy3005",
                        "content": "The last test case is just empty although it clearly said that dividend and divisor are numbers. (-2^31 <= dividend, divisor <= 2^31 - 1)\\n\\nIt says: \"dividend =\"\\n\\nNo number"
                    },
                    {
                        "username": "Ghosted",
                        "content": "[@Timy3005](/Timy3005) same for me. good.times."
                    },
                    {
                        "username": "Timy3005",
                        "content": "Furthermore, if I try and put \"empty\" (just nothing) in the test case it gives me an error \" is not a valid value or type integer\""
                    },
                    {
                        "username": "priyatanwar2009",
                        "content": "Approach -2 , powerOfTwo = -1 is being initizalized with -1. Why??"
                    },
                    {
                        "username": "MR-D05",
                        "content": "Just curious what some of your thoughts are about why this problem sucks."
                    },
                    {
                        "username": "calvin-li",
                        "content": "-2147483648 / -1 == -2147483648, but output is -2147483647 for python"
                    },
                    {
                        "username": "larryleguo",
                        "content": "https://leetcode.com/submissions/detail/29323275/\\n\\n987 / 988 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 1 minute ago\\nInput:\\t-2147483648, -1\\nOutput:\\t2147483648\\nExpected:\\t2147483647\\n\\nClearly the test case gives the wrong results. I use python. I think this may be related with a bug in python:\\nFor integer division in C and Java, we have\\n1/2 = 0, \\n-1/2 = 0.\\nHowever, in python, we have\\n1/2 = 0\\n-1/2 = -1.\\nSomeone may argue this is what python defines, but I think it should be a bug since it is incompatible to other programming languages."
                    },
                    {
                        "username": "bodypainter",
                        "content": "Most test cases hinge on the input values being INT_MIN. So, you need to either type cast to long long to solve or do a cumbersome switch case :( :("
                    },
                    {
                        "username": "kemp",
                        "content": "Ah, now I remember why I hate leetcode \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1568331,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Try these 7 test cases , before submitting\n```\n-2147483648\n2147483647\n2147483647\n2147483647\n1981445587\n1172010393\n1100540749\n-1090366779\n-2147483648\n2\n-2147483648\n1\n2147483647\n2\n```"
                    },
                    {
                        "username": "user9348239482934",
                        "content": "Has anyone had such an error?\\n![image](https://i.ibb.co/S5zVR0K/2023-06-15-10-11-03.png)"
                    },
                    {
                        "username": "niketsharma22",
                        "content": "Leetcode: How many corner scenarios will you add? \\nComposer: YES!!!!!!!"
                    },
                    {
                        "username": "Timy3005",
                        "content": "The last test case is just empty although it clearly said that dividend and divisor are numbers. (-2^31 <= dividend, divisor <= 2^31 - 1)\\n\\nIt says: \"dividend =\"\\n\\nNo number"
                    },
                    {
                        "username": "Ghosted",
                        "content": "[@Timy3005](/Timy3005) same for me. good.times."
                    },
                    {
                        "username": "Timy3005",
                        "content": "Furthermore, if I try and put \"empty\" (just nothing) in the test case it gives me an error \" is not a valid value or type integer\""
                    },
                    {
                        "username": "priyatanwar2009",
                        "content": "Approach -2 , powerOfTwo = -1 is being initizalized with -1. Why??"
                    },
                    {
                        "username": "MR-D05",
                        "content": "Just curious what some of your thoughts are about why this problem sucks."
                    },
                    {
                        "username": "calvin-li",
                        "content": "-2147483648 / -1 == -2147483648, but output is -2147483647 for python"
                    },
                    {
                        "username": "larryleguo",
                        "content": "https://leetcode.com/submissions/detail/29323275/\\n\\n987 / 988 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 1 minute ago\\nInput:\\t-2147483648, -1\\nOutput:\\t2147483648\\nExpected:\\t2147483647\\n\\nClearly the test case gives the wrong results. I use python. I think this may be related with a bug in python:\\nFor integer division in C and Java, we have\\n1/2 = 0, \\n-1/2 = 0.\\nHowever, in python, we have\\n1/2 = 0\\n-1/2 = -1.\\nSomeone may argue this is what python defines, but I think it should be a bug since it is incompatible to other programming languages."
                    },
                    {
                        "username": "bodypainter",
                        "content": "Most test cases hinge on the input values being INT_MIN. So, you need to either type cast to long long to solve or do a cumbersome switch case :( :("
                    },
                    {
                        "username": "kemp",
                        "content": "Ah, now I remember why I hate leetcode \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1568111,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Try these 7 test cases , before submitting\n```\n-2147483648\n2147483647\n2147483647\n2147483647\n1981445587\n1172010393\n1100540749\n-1090366779\n-2147483648\n2\n-2147483648\n1\n2147483647\n2\n```"
                    },
                    {
                        "username": "user9348239482934",
                        "content": "Has anyone had such an error?\\n![image](https://i.ibb.co/S5zVR0K/2023-06-15-10-11-03.png)"
                    },
                    {
                        "username": "niketsharma22",
                        "content": "Leetcode: How many corner scenarios will you add? \\nComposer: YES!!!!!!!"
                    },
                    {
                        "username": "Timy3005",
                        "content": "The last test case is just empty although it clearly said that dividend and divisor are numbers. (-2^31 <= dividend, divisor <= 2^31 - 1)\\n\\nIt says: \"dividend =\"\\n\\nNo number"
                    },
                    {
                        "username": "Ghosted",
                        "content": "[@Timy3005](/Timy3005) same for me. good.times."
                    },
                    {
                        "username": "Timy3005",
                        "content": "Furthermore, if I try and put \"empty\" (just nothing) in the test case it gives me an error \" is not a valid value or type integer\""
                    },
                    {
                        "username": "priyatanwar2009",
                        "content": "Approach -2 , powerOfTwo = -1 is being initizalized with -1. Why??"
                    },
                    {
                        "username": "MR-D05",
                        "content": "Just curious what some of your thoughts are about why this problem sucks."
                    },
                    {
                        "username": "calvin-li",
                        "content": "-2147483648 / -1 == -2147483648, but output is -2147483647 for python"
                    },
                    {
                        "username": "larryleguo",
                        "content": "https://leetcode.com/submissions/detail/29323275/\\n\\n987 / 988 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 1 minute ago\\nInput:\\t-2147483648, -1\\nOutput:\\t2147483648\\nExpected:\\t2147483647\\n\\nClearly the test case gives the wrong results. I use python. I think this may be related with a bug in python:\\nFor integer division in C and Java, we have\\n1/2 = 0, \\n-1/2 = 0.\\nHowever, in python, we have\\n1/2 = 0\\n-1/2 = -1.\\nSomeone may argue this is what python defines, but I think it should be a bug since it is incompatible to other programming languages."
                    },
                    {
                        "username": "bodypainter",
                        "content": "Most test cases hinge on the input values being INT_MIN. So, you need to either type cast to long long to solve or do a cumbersome switch case :( :("
                    },
                    {
                        "username": "kemp",
                        "content": "Ah, now I remember why I hate leetcode \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1567815,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Try these 7 test cases , before submitting\n```\n-2147483648\n2147483647\n2147483647\n2147483647\n1981445587\n1172010393\n1100540749\n-1090366779\n-2147483648\n2\n-2147483648\n1\n2147483647\n2\n```"
                    },
                    {
                        "username": "user9348239482934",
                        "content": "Has anyone had such an error?\\n![image](https://i.ibb.co/S5zVR0K/2023-06-15-10-11-03.png)"
                    },
                    {
                        "username": "niketsharma22",
                        "content": "Leetcode: How many corner scenarios will you add? \\nComposer: YES!!!!!!!"
                    },
                    {
                        "username": "Timy3005",
                        "content": "The last test case is just empty although it clearly said that dividend and divisor are numbers. (-2^31 <= dividend, divisor <= 2^31 - 1)\\n\\nIt says: \"dividend =\"\\n\\nNo number"
                    },
                    {
                        "username": "Ghosted",
                        "content": "[@Timy3005](/Timy3005) same for me. good.times."
                    },
                    {
                        "username": "Timy3005",
                        "content": "Furthermore, if I try and put \"empty\" (just nothing) in the test case it gives me an error \" is not a valid value or type integer\""
                    },
                    {
                        "username": "priyatanwar2009",
                        "content": "Approach -2 , powerOfTwo = -1 is being initizalized with -1. Why??"
                    },
                    {
                        "username": "MR-D05",
                        "content": "Just curious what some of your thoughts are about why this problem sucks."
                    },
                    {
                        "username": "calvin-li",
                        "content": "-2147483648 / -1 == -2147483648, but output is -2147483647 for python"
                    },
                    {
                        "username": "larryleguo",
                        "content": "https://leetcode.com/submissions/detail/29323275/\\n\\n987 / 988 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 1 minute ago\\nInput:\\t-2147483648, -1\\nOutput:\\t2147483648\\nExpected:\\t2147483647\\n\\nClearly the test case gives the wrong results. I use python. I think this may be related with a bug in python:\\nFor integer division in C and Java, we have\\n1/2 = 0, \\n-1/2 = 0.\\nHowever, in python, we have\\n1/2 = 0\\n-1/2 = -1.\\nSomeone may argue this is what python defines, but I think it should be a bug since it is incompatible to other programming languages."
                    },
                    {
                        "username": "bodypainter",
                        "content": "Most test cases hinge on the input values being INT_MIN. So, you need to either type cast to long long to solve or do a cumbersome switch case :( :("
                    },
                    {
                        "username": "kemp",
                        "content": "Ah, now I remember why I hate leetcode \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1566392,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Try these 7 test cases , before submitting\n```\n-2147483648\n2147483647\n2147483647\n2147483647\n1981445587\n1172010393\n1100540749\n-1090366779\n-2147483648\n2\n-2147483648\n1\n2147483647\n2\n```"
                    },
                    {
                        "username": "user9348239482934",
                        "content": "Has anyone had such an error?\\n![image](https://i.ibb.co/S5zVR0K/2023-06-15-10-11-03.png)"
                    },
                    {
                        "username": "niketsharma22",
                        "content": "Leetcode: How many corner scenarios will you add? \\nComposer: YES!!!!!!!"
                    },
                    {
                        "username": "Timy3005",
                        "content": "The last test case is just empty although it clearly said that dividend and divisor are numbers. (-2^31 <= dividend, divisor <= 2^31 - 1)\\n\\nIt says: \"dividend =\"\\n\\nNo number"
                    },
                    {
                        "username": "Ghosted",
                        "content": "[@Timy3005](/Timy3005) same for me. good.times."
                    },
                    {
                        "username": "Timy3005",
                        "content": "Furthermore, if I try and put \"empty\" (just nothing) in the test case it gives me an error \" is not a valid value or type integer\""
                    },
                    {
                        "username": "priyatanwar2009",
                        "content": "Approach -2 , powerOfTwo = -1 is being initizalized with -1. Why??"
                    },
                    {
                        "username": "MR-D05",
                        "content": "Just curious what some of your thoughts are about why this problem sucks."
                    },
                    {
                        "username": "calvin-li",
                        "content": "-2147483648 / -1 == -2147483648, but output is -2147483647 for python"
                    },
                    {
                        "username": "larryleguo",
                        "content": "https://leetcode.com/submissions/detail/29323275/\\n\\n987 / 988 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 1 minute ago\\nInput:\\t-2147483648, -1\\nOutput:\\t2147483648\\nExpected:\\t2147483647\\n\\nClearly the test case gives the wrong results. I use python. I think this may be related with a bug in python:\\nFor integer division in C and Java, we have\\n1/2 = 0, \\n-1/2 = 0.\\nHowever, in python, we have\\n1/2 = 0\\n-1/2 = -1.\\nSomeone may argue this is what python defines, but I think it should be a bug since it is incompatible to other programming languages."
                    },
                    {
                        "username": "bodypainter",
                        "content": "Most test cases hinge on the input values being INT_MIN. So, you need to either type cast to long long to solve or do a cumbersome switch case :( :("
                    },
                    {
                        "username": "kemp",
                        "content": "Ah, now I remember why I hate leetcode \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1962762,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Try these 7 test cases , before submitting\n```\n-2147483648\n2147483647\n2147483647\n2147483647\n1981445587\n1172010393\n1100540749\n-1090366779\n-2147483648\n2\n-2147483648\n1\n2147483647\n2\n```"
                    },
                    {
                        "username": "user9348239482934",
                        "content": "Has anyone had such an error?\\n![image](https://i.ibb.co/S5zVR0K/2023-06-15-10-11-03.png)"
                    },
                    {
                        "username": "niketsharma22",
                        "content": "Leetcode: How many corner scenarios will you add? \\nComposer: YES!!!!!!!"
                    },
                    {
                        "username": "Timy3005",
                        "content": "The last test case is just empty although it clearly said that dividend and divisor are numbers. (-2^31 <= dividend, divisor <= 2^31 - 1)\\n\\nIt says: \"dividend =\"\\n\\nNo number"
                    },
                    {
                        "username": "Ghosted",
                        "content": "[@Timy3005](/Timy3005) same for me. good.times."
                    },
                    {
                        "username": "Timy3005",
                        "content": "Furthermore, if I try and put \"empty\" (just nothing) in the test case it gives me an error \" is not a valid value or type integer\""
                    },
                    {
                        "username": "priyatanwar2009",
                        "content": "Approach -2 , powerOfTwo = -1 is being initizalized with -1. Why??"
                    },
                    {
                        "username": "MR-D05",
                        "content": "Just curious what some of your thoughts are about why this problem sucks."
                    },
                    {
                        "username": "calvin-li",
                        "content": "-2147483648 / -1 == -2147483648, but output is -2147483647 for python"
                    },
                    {
                        "username": "larryleguo",
                        "content": "https://leetcode.com/submissions/detail/29323275/\\n\\n987 / 988 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 1 minute ago\\nInput:\\t-2147483648, -1\\nOutput:\\t2147483648\\nExpected:\\t2147483647\\n\\nClearly the test case gives the wrong results. I use python. I think this may be related with a bug in python:\\nFor integer division in C and Java, we have\\n1/2 = 0, \\n-1/2 = 0.\\nHowever, in python, we have\\n1/2 = 0\\n-1/2 = -1.\\nSomeone may argue this is what python defines, but I think it should be a bug since it is incompatible to other programming languages."
                    },
                    {
                        "username": "bodypainter",
                        "content": "Most test cases hinge on the input values being INT_MIN. So, you need to either type cast to long long to solve or do a cumbersome switch case :( :("
                    },
                    {
                        "username": "kemp",
                        "content": "Ah, now I remember why I hate leetcode \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1570818,
                "content": [
                    {
                        "username": "waseehaque",
                        "content": "![image](https://assets.leetcode.com/users/images/4b770e88-0628-4893-af62-4663af5dbc28_1647061138.8385103.png)\\nOne of the test cases has wrong answer. Javascript."
                    },
                    {
                        "username": "heyjordn",
                        "content": "Hi, Why is this particular test case wrong?\\n\\nAny number divided by one isnt itself?\\n![image](https://assets.leetcode.com/users/images/7111ea2b-3b46-4837-b889-0891244bdbd1_1638381391.0029366.png)\\n"
                    },
                    {
                        "username": "yogesh_nazi",
                        "content": "-2147483648\\n-1\\n their answer should be  2147483648\\n but its answer is show as 2147483647 \\n correct me if i am wrong"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "bullpup",
                        "content": "My time complexity analysis of the standard algorithm. Sorry for the ugly presentation and bad handwriting. Open to corrections and suggestions.\\n![image](https://assets.leetcode.com/users/bullpup/image_1568425821.png)\\n"
                    },
                    {
                        "username": "ishthefish11",
                        "content": "did u end up solving it 4 years later?"
                    },
                    {
                        "username": "dexx1220",
                        "content": "![image](https://assets.leetcode.com/users/dexx1220/image_1548028697.png)\\nI"
                    },
                    {
                        "username": "easonok",
                        "content": "I cannot pass this test case but my answer looks correct to me. I am suspecting there is an off-by-one error in OJ. Does an admin mind checking?\\n\\n![0_1483931624514_Screen Shot 2017-01-08 at 7.11.42 PM.png](/uploads/files/1483931625836-screen-shot-2017-01-08-at-7.11.42-pm.png) \\n\\nPlease see my recent submission for my code if that matters - thanks!"
                    },
                    {
                        "username": "edwardcui",
                        "content": "Python has arbitrary precision integers so there is no true fixed maximum (limited by memory). People have to hard code this overflow limitation if they want their code to be accepted! Is it against the purpose of this website?"
                    },
                    {
                        "username": "sftrytry",
                        "content": "They actually works as * 2 and / 2."
                    },
                    {
                        "username": "jatinx",
                        "content": "The question is good. Some test cases it uses to verify are stupid.\\n\\nOne of the test case is: division of -2147483648 by -1 cannot be represented in type \\'int\\'\\nThats undefined behavior, now just because you(test case writer) think it should round off to a certain number i.e. 2147483647, does not mean it will, its still UB.\\n\\nSince we are not using any division here, we need to understand what you (the test case writer) think will happen (out of many other way better answer) and make sure the code does that.\\n\\nMaybe thats why this question has so few acceptance rate.\\n\\nA good read for test case writer: https://en.cppreference.com/w/cpp/language/ub"
                    },
                    {
                        "username": "haphanquang",
                        "content": "why do we try to reinvent the wheel?"
                    }
                ]
            },
            {
                "id": 1576037,
                "content": [
                    {
                        "username": "waseehaque",
                        "content": "![image](https://assets.leetcode.com/users/images/4b770e88-0628-4893-af62-4663af5dbc28_1647061138.8385103.png)\\nOne of the test cases has wrong answer. Javascript."
                    },
                    {
                        "username": "heyjordn",
                        "content": "Hi, Why is this particular test case wrong?\\n\\nAny number divided by one isnt itself?\\n![image](https://assets.leetcode.com/users/images/7111ea2b-3b46-4837-b889-0891244bdbd1_1638381391.0029366.png)\\n"
                    },
                    {
                        "username": "yogesh_nazi",
                        "content": "-2147483648\\n-1\\n their answer should be  2147483648\\n but its answer is show as 2147483647 \\n correct me if i am wrong"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "bullpup",
                        "content": "My time complexity analysis of the standard algorithm. Sorry for the ugly presentation and bad handwriting. Open to corrections and suggestions.\\n![image](https://assets.leetcode.com/users/bullpup/image_1568425821.png)\\n"
                    },
                    {
                        "username": "ishthefish11",
                        "content": "did u end up solving it 4 years later?"
                    },
                    {
                        "username": "dexx1220",
                        "content": "![image](https://assets.leetcode.com/users/dexx1220/image_1548028697.png)\\nI"
                    },
                    {
                        "username": "easonok",
                        "content": "I cannot pass this test case but my answer looks correct to me. I am suspecting there is an off-by-one error in OJ. Does an admin mind checking?\\n\\n![0_1483931624514_Screen Shot 2017-01-08 at 7.11.42 PM.png](/uploads/files/1483931625836-screen-shot-2017-01-08-at-7.11.42-pm.png) \\n\\nPlease see my recent submission for my code if that matters - thanks!"
                    },
                    {
                        "username": "edwardcui",
                        "content": "Python has arbitrary precision integers so there is no true fixed maximum (limited by memory). People have to hard code this overflow limitation if they want their code to be accepted! Is it against the purpose of this website?"
                    },
                    {
                        "username": "sftrytry",
                        "content": "They actually works as * 2 and / 2."
                    },
                    {
                        "username": "jatinx",
                        "content": "The question is good. Some test cases it uses to verify are stupid.\\n\\nOne of the test case is: division of -2147483648 by -1 cannot be represented in type \\'int\\'\\nThats undefined behavior, now just because you(test case writer) think it should round off to a certain number i.e. 2147483647, does not mean it will, its still UB.\\n\\nSince we are not using any division here, we need to understand what you (the test case writer) think will happen (out of many other way better answer) and make sure the code does that.\\n\\nMaybe thats why this question has so few acceptance rate.\\n\\nA good read for test case writer: https://en.cppreference.com/w/cpp/language/ub"
                    },
                    {
                        "username": "haphanquang",
                        "content": "why do we try to reinvent the wheel?"
                    }
                ]
            },
            {
                "id": 1570024,
                "content": [
                    {
                        "username": "waseehaque",
                        "content": "![image](https://assets.leetcode.com/users/images/4b770e88-0628-4893-af62-4663af5dbc28_1647061138.8385103.png)\\nOne of the test cases has wrong answer. Javascript."
                    },
                    {
                        "username": "heyjordn",
                        "content": "Hi, Why is this particular test case wrong?\\n\\nAny number divided by one isnt itself?\\n![image](https://assets.leetcode.com/users/images/7111ea2b-3b46-4837-b889-0891244bdbd1_1638381391.0029366.png)\\n"
                    },
                    {
                        "username": "yogesh_nazi",
                        "content": "-2147483648\\n-1\\n their answer should be  2147483648\\n but its answer is show as 2147483647 \\n correct me if i am wrong"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "bullpup",
                        "content": "My time complexity analysis of the standard algorithm. Sorry for the ugly presentation and bad handwriting. Open to corrections and suggestions.\\n![image](https://assets.leetcode.com/users/bullpup/image_1568425821.png)\\n"
                    },
                    {
                        "username": "ishthefish11",
                        "content": "did u end up solving it 4 years later?"
                    },
                    {
                        "username": "dexx1220",
                        "content": "![image](https://assets.leetcode.com/users/dexx1220/image_1548028697.png)\\nI"
                    },
                    {
                        "username": "easonok",
                        "content": "I cannot pass this test case but my answer looks correct to me. I am suspecting there is an off-by-one error in OJ. Does an admin mind checking?\\n\\n![0_1483931624514_Screen Shot 2017-01-08 at 7.11.42 PM.png](/uploads/files/1483931625836-screen-shot-2017-01-08-at-7.11.42-pm.png) \\n\\nPlease see my recent submission for my code if that matters - thanks!"
                    },
                    {
                        "username": "edwardcui",
                        "content": "Python has arbitrary precision integers so there is no true fixed maximum (limited by memory). People have to hard code this overflow limitation if they want their code to be accepted! Is it against the purpose of this website?"
                    },
                    {
                        "username": "sftrytry",
                        "content": "They actually works as * 2 and / 2."
                    },
                    {
                        "username": "jatinx",
                        "content": "The question is good. Some test cases it uses to verify are stupid.\\n\\nOne of the test case is: division of -2147483648 by -1 cannot be represented in type \\'int\\'\\nThats undefined behavior, now just because you(test case writer) think it should round off to a certain number i.e. 2147483647, does not mean it will, its still UB.\\n\\nSince we are not using any division here, we need to understand what you (the test case writer) think will happen (out of many other way better answer) and make sure the code does that.\\n\\nMaybe thats why this question has so few acceptance rate.\\n\\nA good read for test case writer: https://en.cppreference.com/w/cpp/language/ub"
                    },
                    {
                        "username": "haphanquang",
                        "content": "why do we try to reinvent the wheel?"
                    }
                ]
            },
            {
                "id": 1569624,
                "content": [
                    {
                        "username": "waseehaque",
                        "content": "![image](https://assets.leetcode.com/users/images/4b770e88-0628-4893-af62-4663af5dbc28_1647061138.8385103.png)\\nOne of the test cases has wrong answer. Javascript."
                    },
                    {
                        "username": "heyjordn",
                        "content": "Hi, Why is this particular test case wrong?\\n\\nAny number divided by one isnt itself?\\n![image](https://assets.leetcode.com/users/images/7111ea2b-3b46-4837-b889-0891244bdbd1_1638381391.0029366.png)\\n"
                    },
                    {
                        "username": "yogesh_nazi",
                        "content": "-2147483648\\n-1\\n their answer should be  2147483648\\n but its answer is show as 2147483647 \\n correct me if i am wrong"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "bullpup",
                        "content": "My time complexity analysis of the standard algorithm. Sorry for the ugly presentation and bad handwriting. Open to corrections and suggestions.\\n![image](https://assets.leetcode.com/users/bullpup/image_1568425821.png)\\n"
                    },
                    {
                        "username": "ishthefish11",
                        "content": "did u end up solving it 4 years later?"
                    },
                    {
                        "username": "dexx1220",
                        "content": "![image](https://assets.leetcode.com/users/dexx1220/image_1548028697.png)\\nI"
                    },
                    {
                        "username": "easonok",
                        "content": "I cannot pass this test case but my answer looks correct to me. I am suspecting there is an off-by-one error in OJ. Does an admin mind checking?\\n\\n![0_1483931624514_Screen Shot 2017-01-08 at 7.11.42 PM.png](/uploads/files/1483931625836-screen-shot-2017-01-08-at-7.11.42-pm.png) \\n\\nPlease see my recent submission for my code if that matters - thanks!"
                    },
                    {
                        "username": "edwardcui",
                        "content": "Python has arbitrary precision integers so there is no true fixed maximum (limited by memory). People have to hard code this overflow limitation if they want their code to be accepted! Is it against the purpose of this website?"
                    },
                    {
                        "username": "sftrytry",
                        "content": "They actually works as * 2 and / 2."
                    },
                    {
                        "username": "jatinx",
                        "content": "The question is good. Some test cases it uses to verify are stupid.\\n\\nOne of the test case is: division of -2147483648 by -1 cannot be represented in type \\'int\\'\\nThats undefined behavior, now just because you(test case writer) think it should round off to a certain number i.e. 2147483647, does not mean it will, its still UB.\\n\\nSince we are not using any division here, we need to understand what you (the test case writer) think will happen (out of many other way better answer) and make sure the code does that.\\n\\nMaybe thats why this question has so few acceptance rate.\\n\\nA good read for test case writer: https://en.cppreference.com/w/cpp/language/ub"
                    },
                    {
                        "username": "haphanquang",
                        "content": "why do we try to reinvent the wheel?"
                    }
                ]
            },
            {
                "id": 1569408,
                "content": [
                    {
                        "username": "waseehaque",
                        "content": "![image](https://assets.leetcode.com/users/images/4b770e88-0628-4893-af62-4663af5dbc28_1647061138.8385103.png)\\nOne of the test cases has wrong answer. Javascript."
                    },
                    {
                        "username": "heyjordn",
                        "content": "Hi, Why is this particular test case wrong?\\n\\nAny number divided by one isnt itself?\\n![image](https://assets.leetcode.com/users/images/7111ea2b-3b46-4837-b889-0891244bdbd1_1638381391.0029366.png)\\n"
                    },
                    {
                        "username": "yogesh_nazi",
                        "content": "-2147483648\\n-1\\n their answer should be  2147483648\\n but its answer is show as 2147483647 \\n correct me if i am wrong"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "bullpup",
                        "content": "My time complexity analysis of the standard algorithm. Sorry for the ugly presentation and bad handwriting. Open to corrections and suggestions.\\n![image](https://assets.leetcode.com/users/bullpup/image_1568425821.png)\\n"
                    },
                    {
                        "username": "ishthefish11",
                        "content": "did u end up solving it 4 years later?"
                    },
                    {
                        "username": "dexx1220",
                        "content": "![image](https://assets.leetcode.com/users/dexx1220/image_1548028697.png)\\nI"
                    },
                    {
                        "username": "easonok",
                        "content": "I cannot pass this test case but my answer looks correct to me. I am suspecting there is an off-by-one error in OJ. Does an admin mind checking?\\n\\n![0_1483931624514_Screen Shot 2017-01-08 at 7.11.42 PM.png](/uploads/files/1483931625836-screen-shot-2017-01-08-at-7.11.42-pm.png) \\n\\nPlease see my recent submission for my code if that matters - thanks!"
                    },
                    {
                        "username": "edwardcui",
                        "content": "Python has arbitrary precision integers so there is no true fixed maximum (limited by memory). People have to hard code this overflow limitation if they want their code to be accepted! Is it against the purpose of this website?"
                    },
                    {
                        "username": "sftrytry",
                        "content": "They actually works as * 2 and / 2."
                    },
                    {
                        "username": "jatinx",
                        "content": "The question is good. Some test cases it uses to verify are stupid.\\n\\nOne of the test case is: division of -2147483648 by -1 cannot be represented in type \\'int\\'\\nThats undefined behavior, now just because you(test case writer) think it should round off to a certain number i.e. 2147483647, does not mean it will, its still UB.\\n\\nSince we are not using any division here, we need to understand what you (the test case writer) think will happen (out of many other way better answer) and make sure the code does that.\\n\\nMaybe thats why this question has so few acceptance rate.\\n\\nA good read for test case writer: https://en.cppreference.com/w/cpp/language/ub"
                    },
                    {
                        "username": "haphanquang",
                        "content": "why do we try to reinvent the wheel?"
                    }
                ]
            },
            {
                "id": 1568849,
                "content": [
                    {
                        "username": "waseehaque",
                        "content": "![image](https://assets.leetcode.com/users/images/4b770e88-0628-4893-af62-4663af5dbc28_1647061138.8385103.png)\\nOne of the test cases has wrong answer. Javascript."
                    },
                    {
                        "username": "heyjordn",
                        "content": "Hi, Why is this particular test case wrong?\\n\\nAny number divided by one isnt itself?\\n![image](https://assets.leetcode.com/users/images/7111ea2b-3b46-4837-b889-0891244bdbd1_1638381391.0029366.png)\\n"
                    },
                    {
                        "username": "yogesh_nazi",
                        "content": "-2147483648\\n-1\\n their answer should be  2147483648\\n but its answer is show as 2147483647 \\n correct me if i am wrong"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "bullpup",
                        "content": "My time complexity analysis of the standard algorithm. Sorry for the ugly presentation and bad handwriting. Open to corrections and suggestions.\\n![image](https://assets.leetcode.com/users/bullpup/image_1568425821.png)\\n"
                    },
                    {
                        "username": "ishthefish11",
                        "content": "did u end up solving it 4 years later?"
                    },
                    {
                        "username": "dexx1220",
                        "content": "![image](https://assets.leetcode.com/users/dexx1220/image_1548028697.png)\\nI"
                    },
                    {
                        "username": "easonok",
                        "content": "I cannot pass this test case but my answer looks correct to me. I am suspecting there is an off-by-one error in OJ. Does an admin mind checking?\\n\\n![0_1483931624514_Screen Shot 2017-01-08 at 7.11.42 PM.png](/uploads/files/1483931625836-screen-shot-2017-01-08-at-7.11.42-pm.png) \\n\\nPlease see my recent submission for my code if that matters - thanks!"
                    },
                    {
                        "username": "edwardcui",
                        "content": "Python has arbitrary precision integers so there is no true fixed maximum (limited by memory). People have to hard code this overflow limitation if they want their code to be accepted! Is it against the purpose of this website?"
                    },
                    {
                        "username": "sftrytry",
                        "content": "They actually works as * 2 and / 2."
                    },
                    {
                        "username": "jatinx",
                        "content": "The question is good. Some test cases it uses to verify are stupid.\\n\\nOne of the test case is: division of -2147483648 by -1 cannot be represented in type \\'int\\'\\nThats undefined behavior, now just because you(test case writer) think it should round off to a certain number i.e. 2147483647, does not mean it will, its still UB.\\n\\nSince we are not using any division here, we need to understand what you (the test case writer) think will happen (out of many other way better answer) and make sure the code does that.\\n\\nMaybe thats why this question has so few acceptance rate.\\n\\nA good read for test case writer: https://en.cppreference.com/w/cpp/language/ub"
                    },
                    {
                        "username": "haphanquang",
                        "content": "why do we try to reinvent the wheel?"
                    }
                ]
            },
            {
                "id": 1568850,
                "content": [
                    {
                        "username": "waseehaque",
                        "content": "![image](https://assets.leetcode.com/users/images/4b770e88-0628-4893-af62-4663af5dbc28_1647061138.8385103.png)\\nOne of the test cases has wrong answer. Javascript."
                    },
                    {
                        "username": "heyjordn",
                        "content": "Hi, Why is this particular test case wrong?\\n\\nAny number divided by one isnt itself?\\n![image](https://assets.leetcode.com/users/images/7111ea2b-3b46-4837-b889-0891244bdbd1_1638381391.0029366.png)\\n"
                    },
                    {
                        "username": "yogesh_nazi",
                        "content": "-2147483648\\n-1\\n their answer should be  2147483648\\n but its answer is show as 2147483647 \\n correct me if i am wrong"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "bullpup",
                        "content": "My time complexity analysis of the standard algorithm. Sorry for the ugly presentation and bad handwriting. Open to corrections and suggestions.\\n![image](https://assets.leetcode.com/users/bullpup/image_1568425821.png)\\n"
                    },
                    {
                        "username": "ishthefish11",
                        "content": "did u end up solving it 4 years later?"
                    },
                    {
                        "username": "dexx1220",
                        "content": "![image](https://assets.leetcode.com/users/dexx1220/image_1548028697.png)\\nI"
                    },
                    {
                        "username": "easonok",
                        "content": "I cannot pass this test case but my answer looks correct to me. I am suspecting there is an off-by-one error in OJ. Does an admin mind checking?\\n\\n![0_1483931624514_Screen Shot 2017-01-08 at 7.11.42 PM.png](/uploads/files/1483931625836-screen-shot-2017-01-08-at-7.11.42-pm.png) \\n\\nPlease see my recent submission for my code if that matters - thanks!"
                    },
                    {
                        "username": "edwardcui",
                        "content": "Python has arbitrary precision integers so there is no true fixed maximum (limited by memory). People have to hard code this overflow limitation if they want their code to be accepted! Is it against the purpose of this website?"
                    },
                    {
                        "username": "sftrytry",
                        "content": "They actually works as * 2 and / 2."
                    },
                    {
                        "username": "jatinx",
                        "content": "The question is good. Some test cases it uses to verify are stupid.\\n\\nOne of the test case is: division of -2147483648 by -1 cannot be represented in type \\'int\\'\\nThats undefined behavior, now just because you(test case writer) think it should round off to a certain number i.e. 2147483647, does not mean it will, its still UB.\\n\\nSince we are not using any division here, we need to understand what you (the test case writer) think will happen (out of many other way better answer) and make sure the code does that.\\n\\nMaybe thats why this question has so few acceptance rate.\\n\\nA good read for test case writer: https://en.cppreference.com/w/cpp/language/ub"
                    },
                    {
                        "username": "haphanquang",
                        "content": "why do we try to reinvent the wheel?"
                    }
                ]
            },
            {
                "id": 1568851,
                "content": [
                    {
                        "username": "waseehaque",
                        "content": "![image](https://assets.leetcode.com/users/images/4b770e88-0628-4893-af62-4663af5dbc28_1647061138.8385103.png)\\nOne of the test cases has wrong answer. Javascript."
                    },
                    {
                        "username": "heyjordn",
                        "content": "Hi, Why is this particular test case wrong?\\n\\nAny number divided by one isnt itself?\\n![image](https://assets.leetcode.com/users/images/7111ea2b-3b46-4837-b889-0891244bdbd1_1638381391.0029366.png)\\n"
                    },
                    {
                        "username": "yogesh_nazi",
                        "content": "-2147483648\\n-1\\n their answer should be  2147483648\\n but its answer is show as 2147483647 \\n correct me if i am wrong"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "bullpup",
                        "content": "My time complexity analysis of the standard algorithm. Sorry for the ugly presentation and bad handwriting. Open to corrections and suggestions.\\n![image](https://assets.leetcode.com/users/bullpup/image_1568425821.png)\\n"
                    },
                    {
                        "username": "ishthefish11",
                        "content": "did u end up solving it 4 years later?"
                    },
                    {
                        "username": "dexx1220",
                        "content": "![image](https://assets.leetcode.com/users/dexx1220/image_1548028697.png)\\nI"
                    },
                    {
                        "username": "easonok",
                        "content": "I cannot pass this test case but my answer looks correct to me. I am suspecting there is an off-by-one error in OJ. Does an admin mind checking?\\n\\n![0_1483931624514_Screen Shot 2017-01-08 at 7.11.42 PM.png](/uploads/files/1483931625836-screen-shot-2017-01-08-at-7.11.42-pm.png) \\n\\nPlease see my recent submission for my code if that matters - thanks!"
                    },
                    {
                        "username": "edwardcui",
                        "content": "Python has arbitrary precision integers so there is no true fixed maximum (limited by memory). People have to hard code this overflow limitation if they want their code to be accepted! Is it against the purpose of this website?"
                    },
                    {
                        "username": "sftrytry",
                        "content": "They actually works as * 2 and / 2."
                    },
                    {
                        "username": "jatinx",
                        "content": "The question is good. Some test cases it uses to verify are stupid.\\n\\nOne of the test case is: division of -2147483648 by -1 cannot be represented in type \\'int\\'\\nThats undefined behavior, now just because you(test case writer) think it should round off to a certain number i.e. 2147483647, does not mean it will, its still UB.\\n\\nSince we are not using any division here, we need to understand what you (the test case writer) think will happen (out of many other way better answer) and make sure the code does that.\\n\\nMaybe thats why this question has so few acceptance rate.\\n\\nA good read for test case writer: https://en.cppreference.com/w/cpp/language/ub"
                    },
                    {
                        "username": "haphanquang",
                        "content": "why do we try to reinvent the wheel?"
                    }
                ]
            },
            {
                "id": 1568548,
                "content": [
                    {
                        "username": "waseehaque",
                        "content": "![image](https://assets.leetcode.com/users/images/4b770e88-0628-4893-af62-4663af5dbc28_1647061138.8385103.png)\\nOne of the test cases has wrong answer. Javascript."
                    },
                    {
                        "username": "heyjordn",
                        "content": "Hi, Why is this particular test case wrong?\\n\\nAny number divided by one isnt itself?\\n![image](https://assets.leetcode.com/users/images/7111ea2b-3b46-4837-b889-0891244bdbd1_1638381391.0029366.png)\\n"
                    },
                    {
                        "username": "yogesh_nazi",
                        "content": "-2147483648\\n-1\\n their answer should be  2147483648\\n but its answer is show as 2147483647 \\n correct me if i am wrong"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "bullpup",
                        "content": "My time complexity analysis of the standard algorithm. Sorry for the ugly presentation and bad handwriting. Open to corrections and suggestions.\\n![image](https://assets.leetcode.com/users/bullpup/image_1568425821.png)\\n"
                    },
                    {
                        "username": "ishthefish11",
                        "content": "did u end up solving it 4 years later?"
                    },
                    {
                        "username": "dexx1220",
                        "content": "![image](https://assets.leetcode.com/users/dexx1220/image_1548028697.png)\\nI"
                    },
                    {
                        "username": "easonok",
                        "content": "I cannot pass this test case but my answer looks correct to me. I am suspecting there is an off-by-one error in OJ. Does an admin mind checking?\\n\\n![0_1483931624514_Screen Shot 2017-01-08 at 7.11.42 PM.png](/uploads/files/1483931625836-screen-shot-2017-01-08-at-7.11.42-pm.png) \\n\\nPlease see my recent submission for my code if that matters - thanks!"
                    },
                    {
                        "username": "edwardcui",
                        "content": "Python has arbitrary precision integers so there is no true fixed maximum (limited by memory). People have to hard code this overflow limitation if they want their code to be accepted! Is it against the purpose of this website?"
                    },
                    {
                        "username": "sftrytry",
                        "content": "They actually works as * 2 and / 2."
                    },
                    {
                        "username": "jatinx",
                        "content": "The question is good. Some test cases it uses to verify are stupid.\\n\\nOne of the test case is: division of -2147483648 by -1 cannot be represented in type \\'int\\'\\nThats undefined behavior, now just because you(test case writer) think it should round off to a certain number i.e. 2147483647, does not mean it will, its still UB.\\n\\nSince we are not using any division here, we need to understand what you (the test case writer) think will happen (out of many other way better answer) and make sure the code does that.\\n\\nMaybe thats why this question has so few acceptance rate.\\n\\nA good read for test case writer: https://en.cppreference.com/w/cpp/language/ub"
                    },
                    {
                        "username": "haphanquang",
                        "content": "why do we try to reinvent the wheel?"
                    }
                ]
            },
            {
                "id": 1858559,
                "content": [
                    {
                        "username": "waseehaque",
                        "content": "![image](https://assets.leetcode.com/users/images/4b770e88-0628-4893-af62-4663af5dbc28_1647061138.8385103.png)\\nOne of the test cases has wrong answer. Javascript."
                    },
                    {
                        "username": "heyjordn",
                        "content": "Hi, Why is this particular test case wrong?\\n\\nAny number divided by one isnt itself?\\n![image](https://assets.leetcode.com/users/images/7111ea2b-3b46-4837-b889-0891244bdbd1_1638381391.0029366.png)\\n"
                    },
                    {
                        "username": "yogesh_nazi",
                        "content": "-2147483648\\n-1\\n their answer should be  2147483648\\n but its answer is show as 2147483647 \\n correct me if i am wrong"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "bullpup",
                        "content": "My time complexity analysis of the standard algorithm. Sorry for the ugly presentation and bad handwriting. Open to corrections and suggestions.\\n![image](https://assets.leetcode.com/users/bullpup/image_1568425821.png)\\n"
                    },
                    {
                        "username": "ishthefish11",
                        "content": "did u end up solving it 4 years later?"
                    },
                    {
                        "username": "dexx1220",
                        "content": "![image](https://assets.leetcode.com/users/dexx1220/image_1548028697.png)\\nI"
                    },
                    {
                        "username": "easonok",
                        "content": "I cannot pass this test case but my answer looks correct to me. I am suspecting there is an off-by-one error in OJ. Does an admin mind checking?\\n\\n![0_1483931624514_Screen Shot 2017-01-08 at 7.11.42 PM.png](/uploads/files/1483931625836-screen-shot-2017-01-08-at-7.11.42-pm.png) \\n\\nPlease see my recent submission for my code if that matters - thanks!"
                    },
                    {
                        "username": "edwardcui",
                        "content": "Python has arbitrary precision integers so there is no true fixed maximum (limited by memory). People have to hard code this overflow limitation if they want their code to be accepted! Is it against the purpose of this website?"
                    },
                    {
                        "username": "sftrytry",
                        "content": "They actually works as * 2 and / 2."
                    },
                    {
                        "username": "jatinx",
                        "content": "The question is good. Some test cases it uses to verify are stupid.\\n\\nOne of the test case is: division of -2147483648 by -1 cannot be represented in type \\'int\\'\\nThats undefined behavior, now just because you(test case writer) think it should round off to a certain number i.e. 2147483647, does not mean it will, its still UB.\\n\\nSince we are not using any division here, we need to understand what you (the test case writer) think will happen (out of many other way better answer) and make sure the code does that.\\n\\nMaybe thats why this question has so few acceptance rate.\\n\\nA good read for test case writer: https://en.cppreference.com/w/cpp/language/ub"
                    },
                    {
                        "username": "haphanquang",
                        "content": "why do we try to reinvent the wheel?"
                    }
                ]
            },
            {
                "id": 1803482,
                "content": [
                    {
                        "username": "nbeau",
                        "content": "I\\'m getting Time Limit Exceeded even though I have 994/994 test cases passed, why is this happening?"
                    },
                    {
                        "username": "Andrew0000",
                        "content": "I have the same"
                    },
                    {
                        "username": "mediterraneam",
                        "content": "At first I was wondering why such a simple question have so low pass rate. Now I know it\\'s due to a non-sense test case."
                    },
                    {
                        "username": "ifezec",
                        "content": "I was having a difficult time accepting the solution to the bitshifting approach as I was not able to mentally connect with the answer in code. Therefore, I needed to write it out on paper to make it clearer to reinforce this as a solution that I could reference for any future encounter.\\n\\nI wanted to share an image which may help make this clearer for others. The caveat is that it will only be clear if you know how to work with binary.\\n\\nI have 2 examples.  10/2 which would be 5. and 100/7 which is 14.\\n\\n\\n![image](https://assets.leetcode.com/users/images/8be3abf3-ba7f-415e-be00-ebc273003936_1647196362.826863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "NOMAD14",
                        "content": "**Original post**: [https://leetcode.com/explore/interview/card/top-interview-questions-medium/113/math/820/discuss/13467/Very-detailed-step-by-step-explanation-(Java-solution)](http://)\\n\\nEven though he has explained it well, I could not understand the concept the first time. But then I did a dry run...\\n**Here is the logic if someone is still struggling.**\\nex. 10/3\\nHere we need to get 10 by adding a bunch of 3\\'s multiplications.\\nSince every operation is off-limit, we need to think of something different. \\nWe can obtain multiplication and division by using the left and right shits. But these operations gives (num * 2) or (num / 2) respectively. \\nSo, we need to find a way to express 10 as a sum of `3*(power of 2)`.\\nwe can write it like this: `10 = 3*2 + 3*1 = 3*(2^1) + 3*(2^0) = 3*((2^1)+(2^0))`\\n(here, we only need a quotient as an answer. It will be the same as int division)\\nso every inner loop is finding the second term(count in the original post). \\n1st outer loop:\\n    inner loop finds (2^1)\\n2nd outer loop:\\n    inner loop finds (2^0)\\nVOLLA... we have our answer=>  `((2^1)+(2^0)) = 3`\\nHere\\'s another example : `20 = 3*4+3*2 = 3*(2^2) + 3*(2^1) = 3*((2^2)+(2^1))`\\nHope this helps someone and saves some time!!"
                    },
                    {
                        "username": "jomogalla",
                        "content": "I\\'m using Javascript for this challenge, and LeetCode is telling me my answer is incorrect, when it looks like theirs is?\\n\\n![image](https://assets.leetcode.com/users/images/2d8f9764-6fd7-4641-b1b0-2489d00f1ec8_1638217466.509745.png)\\n"
                    },
                    {
                        "username": "markaleptic",
                        "content": "Perhaps a bad test case, but my understanding was that -2147483648 / -1 = 2147483648.\\n![image](https://assets.leetcode.com/users/images/f9f7c8ed-225d-4076-8121-1931d720c528_1619064244.2609332.png)\\n\\n"
                    },
                    {
                        "username": "ratatouille117",
                        "content": "![image](https://assets.leetcode.com/users/images/2cd2f82e-6302-4f53-bed7-438d3edbcc67_1599423087.9170322.png)\\n"
                    },
                    {
                        "username": "ilias-t",
                        "content": "![image](https://assets.leetcode.com/users/images/cacd01af-7650-4da3-a4bf-40159f4b4680_1596308798.4310975.png)\\n"
                    },
                    {
                        "username": "user2451S",
                        "content": "is\\'nt -2147483648 divided by -1 = 2147483648? why is there a missing 1 in the answer\\n![image](https://assets.leetcode.com/users/user2451s/image_1566028161.png)\\n"
                    },
                    {
                        "username": "diewelt",
                        "content": "C language : -2147483648 / -1 = 2147483648 which can\\'t be expressed in 4 byte integer.\\n\\nWhy is the answer 2147483647?\\n\\nIt should be corrected."
                    }
                ]
            },
            {
                "id": 1734718,
                "content": [
                    {
                        "username": "nbeau",
                        "content": "I\\'m getting Time Limit Exceeded even though I have 994/994 test cases passed, why is this happening?"
                    },
                    {
                        "username": "Andrew0000",
                        "content": "I have the same"
                    },
                    {
                        "username": "mediterraneam",
                        "content": "At first I was wondering why such a simple question have so low pass rate. Now I know it\\'s due to a non-sense test case."
                    },
                    {
                        "username": "ifezec",
                        "content": "I was having a difficult time accepting the solution to the bitshifting approach as I was not able to mentally connect with the answer in code. Therefore, I needed to write it out on paper to make it clearer to reinforce this as a solution that I could reference for any future encounter.\\n\\nI wanted to share an image which may help make this clearer for others. The caveat is that it will only be clear if you know how to work with binary.\\n\\nI have 2 examples.  10/2 which would be 5. and 100/7 which is 14.\\n\\n\\n![image](https://assets.leetcode.com/users/images/8be3abf3-ba7f-415e-be00-ebc273003936_1647196362.826863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "NOMAD14",
                        "content": "**Original post**: [https://leetcode.com/explore/interview/card/top-interview-questions-medium/113/math/820/discuss/13467/Very-detailed-step-by-step-explanation-(Java-solution)](http://)\\n\\nEven though he has explained it well, I could not understand the concept the first time. But then I did a dry run...\\n**Here is the logic if someone is still struggling.**\\nex. 10/3\\nHere we need to get 10 by adding a bunch of 3\\'s multiplications.\\nSince every operation is off-limit, we need to think of something different. \\nWe can obtain multiplication and division by using the left and right shits. But these operations gives (num * 2) or (num / 2) respectively. \\nSo, we need to find a way to express 10 as a sum of `3*(power of 2)`.\\nwe can write it like this: `10 = 3*2 + 3*1 = 3*(2^1) + 3*(2^0) = 3*((2^1)+(2^0))`\\n(here, we only need a quotient as an answer. It will be the same as int division)\\nso every inner loop is finding the second term(count in the original post). \\n1st outer loop:\\n    inner loop finds (2^1)\\n2nd outer loop:\\n    inner loop finds (2^0)\\nVOLLA... we have our answer=>  `((2^1)+(2^0)) = 3`\\nHere\\'s another example : `20 = 3*4+3*2 = 3*(2^2) + 3*(2^1) = 3*((2^2)+(2^1))`\\nHope this helps someone and saves some time!!"
                    },
                    {
                        "username": "jomogalla",
                        "content": "I\\'m using Javascript for this challenge, and LeetCode is telling me my answer is incorrect, when it looks like theirs is?\\n\\n![image](https://assets.leetcode.com/users/images/2d8f9764-6fd7-4641-b1b0-2489d00f1ec8_1638217466.509745.png)\\n"
                    },
                    {
                        "username": "markaleptic",
                        "content": "Perhaps a bad test case, but my understanding was that -2147483648 / -1 = 2147483648.\\n![image](https://assets.leetcode.com/users/images/f9f7c8ed-225d-4076-8121-1931d720c528_1619064244.2609332.png)\\n\\n"
                    },
                    {
                        "username": "ratatouille117",
                        "content": "![image](https://assets.leetcode.com/users/images/2cd2f82e-6302-4f53-bed7-438d3edbcc67_1599423087.9170322.png)\\n"
                    },
                    {
                        "username": "ilias-t",
                        "content": "![image](https://assets.leetcode.com/users/images/cacd01af-7650-4da3-a4bf-40159f4b4680_1596308798.4310975.png)\\n"
                    },
                    {
                        "username": "user2451S",
                        "content": "is\\'nt -2147483648 divided by -1 = 2147483648? why is there a missing 1 in the answer\\n![image](https://assets.leetcode.com/users/user2451s/image_1566028161.png)\\n"
                    },
                    {
                        "username": "diewelt",
                        "content": "C language : -2147483648 / -1 = 2147483648 which can\\'t be expressed in 4 byte integer.\\n\\nWhy is the answer 2147483647?\\n\\nIt should be corrected."
                    }
                ]
            },
            {
                "id": 1576500,
                "content": [
                    {
                        "username": "nbeau",
                        "content": "I\\'m getting Time Limit Exceeded even though I have 994/994 test cases passed, why is this happening?"
                    },
                    {
                        "username": "Andrew0000",
                        "content": "I have the same"
                    },
                    {
                        "username": "mediterraneam",
                        "content": "At first I was wondering why such a simple question have so low pass rate. Now I know it\\'s due to a non-sense test case."
                    },
                    {
                        "username": "ifezec",
                        "content": "I was having a difficult time accepting the solution to the bitshifting approach as I was not able to mentally connect with the answer in code. Therefore, I needed to write it out on paper to make it clearer to reinforce this as a solution that I could reference for any future encounter.\\n\\nI wanted to share an image which may help make this clearer for others. The caveat is that it will only be clear if you know how to work with binary.\\n\\nI have 2 examples.  10/2 which would be 5. and 100/7 which is 14.\\n\\n\\n![image](https://assets.leetcode.com/users/images/8be3abf3-ba7f-415e-be00-ebc273003936_1647196362.826863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "NOMAD14",
                        "content": "**Original post**: [https://leetcode.com/explore/interview/card/top-interview-questions-medium/113/math/820/discuss/13467/Very-detailed-step-by-step-explanation-(Java-solution)](http://)\\n\\nEven though he has explained it well, I could not understand the concept the first time. But then I did a dry run...\\n**Here is the logic if someone is still struggling.**\\nex. 10/3\\nHere we need to get 10 by adding a bunch of 3\\'s multiplications.\\nSince every operation is off-limit, we need to think of something different. \\nWe can obtain multiplication and division by using the left and right shits. But these operations gives (num * 2) or (num / 2) respectively. \\nSo, we need to find a way to express 10 as a sum of `3*(power of 2)`.\\nwe can write it like this: `10 = 3*2 + 3*1 = 3*(2^1) + 3*(2^0) = 3*((2^1)+(2^0))`\\n(here, we only need a quotient as an answer. It will be the same as int division)\\nso every inner loop is finding the second term(count in the original post). \\n1st outer loop:\\n    inner loop finds (2^1)\\n2nd outer loop:\\n    inner loop finds (2^0)\\nVOLLA... we have our answer=>  `((2^1)+(2^0)) = 3`\\nHere\\'s another example : `20 = 3*4+3*2 = 3*(2^2) + 3*(2^1) = 3*((2^2)+(2^1))`\\nHope this helps someone and saves some time!!"
                    },
                    {
                        "username": "jomogalla",
                        "content": "I\\'m using Javascript for this challenge, and LeetCode is telling me my answer is incorrect, when it looks like theirs is?\\n\\n![image](https://assets.leetcode.com/users/images/2d8f9764-6fd7-4641-b1b0-2489d00f1ec8_1638217466.509745.png)\\n"
                    },
                    {
                        "username": "markaleptic",
                        "content": "Perhaps a bad test case, but my understanding was that -2147483648 / -1 = 2147483648.\\n![image](https://assets.leetcode.com/users/images/f9f7c8ed-225d-4076-8121-1931d720c528_1619064244.2609332.png)\\n\\n"
                    },
                    {
                        "username": "ratatouille117",
                        "content": "![image](https://assets.leetcode.com/users/images/2cd2f82e-6302-4f53-bed7-438d3edbcc67_1599423087.9170322.png)\\n"
                    },
                    {
                        "username": "ilias-t",
                        "content": "![image](https://assets.leetcode.com/users/images/cacd01af-7650-4da3-a4bf-40159f4b4680_1596308798.4310975.png)\\n"
                    },
                    {
                        "username": "user2451S",
                        "content": "is\\'nt -2147483648 divided by -1 = 2147483648? why is there a missing 1 in the answer\\n![image](https://assets.leetcode.com/users/user2451s/image_1566028161.png)\\n"
                    },
                    {
                        "username": "diewelt",
                        "content": "C language : -2147483648 / -1 = 2147483648 which can\\'t be expressed in 4 byte integer.\\n\\nWhy is the answer 2147483647?\\n\\nIt should be corrected."
                    }
                ]
            },
            {
                "id": 1576029,
                "content": [
                    {
                        "username": "nbeau",
                        "content": "I\\'m getting Time Limit Exceeded even though I have 994/994 test cases passed, why is this happening?"
                    },
                    {
                        "username": "Andrew0000",
                        "content": "I have the same"
                    },
                    {
                        "username": "mediterraneam",
                        "content": "At first I was wondering why such a simple question have so low pass rate. Now I know it\\'s due to a non-sense test case."
                    },
                    {
                        "username": "ifezec",
                        "content": "I was having a difficult time accepting the solution to the bitshifting approach as I was not able to mentally connect with the answer in code. Therefore, I needed to write it out on paper to make it clearer to reinforce this as a solution that I could reference for any future encounter.\\n\\nI wanted to share an image which may help make this clearer for others. The caveat is that it will only be clear if you know how to work with binary.\\n\\nI have 2 examples.  10/2 which would be 5. and 100/7 which is 14.\\n\\n\\n![image](https://assets.leetcode.com/users/images/8be3abf3-ba7f-415e-be00-ebc273003936_1647196362.826863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "NOMAD14",
                        "content": "**Original post**: [https://leetcode.com/explore/interview/card/top-interview-questions-medium/113/math/820/discuss/13467/Very-detailed-step-by-step-explanation-(Java-solution)](http://)\\n\\nEven though he has explained it well, I could not understand the concept the first time. But then I did a dry run...\\n**Here is the logic if someone is still struggling.**\\nex. 10/3\\nHere we need to get 10 by adding a bunch of 3\\'s multiplications.\\nSince every operation is off-limit, we need to think of something different. \\nWe can obtain multiplication and division by using the left and right shits. But these operations gives (num * 2) or (num / 2) respectively. \\nSo, we need to find a way to express 10 as a sum of `3*(power of 2)`.\\nwe can write it like this: `10 = 3*2 + 3*1 = 3*(2^1) + 3*(2^0) = 3*((2^1)+(2^0))`\\n(here, we only need a quotient as an answer. It will be the same as int division)\\nso every inner loop is finding the second term(count in the original post). \\n1st outer loop:\\n    inner loop finds (2^1)\\n2nd outer loop:\\n    inner loop finds (2^0)\\nVOLLA... we have our answer=>  `((2^1)+(2^0)) = 3`\\nHere\\'s another example : `20 = 3*4+3*2 = 3*(2^2) + 3*(2^1) = 3*((2^2)+(2^1))`\\nHope this helps someone and saves some time!!"
                    },
                    {
                        "username": "jomogalla",
                        "content": "I\\'m using Javascript for this challenge, and LeetCode is telling me my answer is incorrect, when it looks like theirs is?\\n\\n![image](https://assets.leetcode.com/users/images/2d8f9764-6fd7-4641-b1b0-2489d00f1ec8_1638217466.509745.png)\\n"
                    },
                    {
                        "username": "markaleptic",
                        "content": "Perhaps a bad test case, but my understanding was that -2147483648 / -1 = 2147483648.\\n![image](https://assets.leetcode.com/users/images/f9f7c8ed-225d-4076-8121-1931d720c528_1619064244.2609332.png)\\n\\n"
                    },
                    {
                        "username": "ratatouille117",
                        "content": "![image](https://assets.leetcode.com/users/images/2cd2f82e-6302-4f53-bed7-438d3edbcc67_1599423087.9170322.png)\\n"
                    },
                    {
                        "username": "ilias-t",
                        "content": "![image](https://assets.leetcode.com/users/images/cacd01af-7650-4da3-a4bf-40159f4b4680_1596308798.4310975.png)\\n"
                    },
                    {
                        "username": "user2451S",
                        "content": "is\\'nt -2147483648 divided by -1 = 2147483648? why is there a missing 1 in the answer\\n![image](https://assets.leetcode.com/users/user2451s/image_1566028161.png)\\n"
                    },
                    {
                        "username": "diewelt",
                        "content": "C language : -2147483648 / -1 = 2147483648 which can\\'t be expressed in 4 byte integer.\\n\\nWhy is the answer 2147483647?\\n\\nIt should be corrected."
                    }
                ]
            },
            {
                "id": 1576026,
                "content": [
                    {
                        "username": "nbeau",
                        "content": "I\\'m getting Time Limit Exceeded even though I have 994/994 test cases passed, why is this happening?"
                    },
                    {
                        "username": "Andrew0000",
                        "content": "I have the same"
                    },
                    {
                        "username": "mediterraneam",
                        "content": "At first I was wondering why such a simple question have so low pass rate. Now I know it\\'s due to a non-sense test case."
                    },
                    {
                        "username": "ifezec",
                        "content": "I was having a difficult time accepting the solution to the bitshifting approach as I was not able to mentally connect with the answer in code. Therefore, I needed to write it out on paper to make it clearer to reinforce this as a solution that I could reference for any future encounter.\\n\\nI wanted to share an image which may help make this clearer for others. The caveat is that it will only be clear if you know how to work with binary.\\n\\nI have 2 examples.  10/2 which would be 5. and 100/7 which is 14.\\n\\n\\n![image](https://assets.leetcode.com/users/images/8be3abf3-ba7f-415e-be00-ebc273003936_1647196362.826863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "NOMAD14",
                        "content": "**Original post**: [https://leetcode.com/explore/interview/card/top-interview-questions-medium/113/math/820/discuss/13467/Very-detailed-step-by-step-explanation-(Java-solution)](http://)\\n\\nEven though he has explained it well, I could not understand the concept the first time. But then I did a dry run...\\n**Here is the logic if someone is still struggling.**\\nex. 10/3\\nHere we need to get 10 by adding a bunch of 3\\'s multiplications.\\nSince every operation is off-limit, we need to think of something different. \\nWe can obtain multiplication and division by using the left and right shits. But these operations gives (num * 2) or (num / 2) respectively. \\nSo, we need to find a way to express 10 as a sum of `3*(power of 2)`.\\nwe can write it like this: `10 = 3*2 + 3*1 = 3*(2^1) + 3*(2^0) = 3*((2^1)+(2^0))`\\n(here, we only need a quotient as an answer. It will be the same as int division)\\nso every inner loop is finding the second term(count in the original post). \\n1st outer loop:\\n    inner loop finds (2^1)\\n2nd outer loop:\\n    inner loop finds (2^0)\\nVOLLA... we have our answer=>  `((2^1)+(2^0)) = 3`\\nHere\\'s another example : `20 = 3*4+3*2 = 3*(2^2) + 3*(2^1) = 3*((2^2)+(2^1))`\\nHope this helps someone and saves some time!!"
                    },
                    {
                        "username": "jomogalla",
                        "content": "I\\'m using Javascript for this challenge, and LeetCode is telling me my answer is incorrect, when it looks like theirs is?\\n\\n![image](https://assets.leetcode.com/users/images/2d8f9764-6fd7-4641-b1b0-2489d00f1ec8_1638217466.509745.png)\\n"
                    },
                    {
                        "username": "markaleptic",
                        "content": "Perhaps a bad test case, but my understanding was that -2147483648 / -1 = 2147483648.\\n![image](https://assets.leetcode.com/users/images/f9f7c8ed-225d-4076-8121-1931d720c528_1619064244.2609332.png)\\n\\n"
                    },
                    {
                        "username": "ratatouille117",
                        "content": "![image](https://assets.leetcode.com/users/images/2cd2f82e-6302-4f53-bed7-438d3edbcc67_1599423087.9170322.png)\\n"
                    },
                    {
                        "username": "ilias-t",
                        "content": "![image](https://assets.leetcode.com/users/images/cacd01af-7650-4da3-a4bf-40159f4b4680_1596308798.4310975.png)\\n"
                    },
                    {
                        "username": "user2451S",
                        "content": "is\\'nt -2147483648 divided by -1 = 2147483648? why is there a missing 1 in the answer\\n![image](https://assets.leetcode.com/users/user2451s/image_1566028161.png)\\n"
                    },
                    {
                        "username": "diewelt",
                        "content": "C language : -2147483648 / -1 = 2147483648 which can\\'t be expressed in 4 byte integer.\\n\\nWhy is the answer 2147483647?\\n\\nIt should be corrected."
                    }
                ]
            },
            {
                "id": 1575168,
                "content": [
                    {
                        "username": "nbeau",
                        "content": "I\\'m getting Time Limit Exceeded even though I have 994/994 test cases passed, why is this happening?"
                    },
                    {
                        "username": "Andrew0000",
                        "content": "I have the same"
                    },
                    {
                        "username": "mediterraneam",
                        "content": "At first I was wondering why such a simple question have so low pass rate. Now I know it\\'s due to a non-sense test case."
                    },
                    {
                        "username": "ifezec",
                        "content": "I was having a difficult time accepting the solution to the bitshifting approach as I was not able to mentally connect with the answer in code. Therefore, I needed to write it out on paper to make it clearer to reinforce this as a solution that I could reference for any future encounter.\\n\\nI wanted to share an image which may help make this clearer for others. The caveat is that it will only be clear if you know how to work with binary.\\n\\nI have 2 examples.  10/2 which would be 5. and 100/7 which is 14.\\n\\n\\n![image](https://assets.leetcode.com/users/images/8be3abf3-ba7f-415e-be00-ebc273003936_1647196362.826863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "NOMAD14",
                        "content": "**Original post**: [https://leetcode.com/explore/interview/card/top-interview-questions-medium/113/math/820/discuss/13467/Very-detailed-step-by-step-explanation-(Java-solution)](http://)\\n\\nEven though he has explained it well, I could not understand the concept the first time. But then I did a dry run...\\n**Here is the logic if someone is still struggling.**\\nex. 10/3\\nHere we need to get 10 by adding a bunch of 3\\'s multiplications.\\nSince every operation is off-limit, we need to think of something different. \\nWe can obtain multiplication and division by using the left and right shits. But these operations gives (num * 2) or (num / 2) respectively. \\nSo, we need to find a way to express 10 as a sum of `3*(power of 2)`.\\nwe can write it like this: `10 = 3*2 + 3*1 = 3*(2^1) + 3*(2^0) = 3*((2^1)+(2^0))`\\n(here, we only need a quotient as an answer. It will be the same as int division)\\nso every inner loop is finding the second term(count in the original post). \\n1st outer loop:\\n    inner loop finds (2^1)\\n2nd outer loop:\\n    inner loop finds (2^0)\\nVOLLA... we have our answer=>  `((2^1)+(2^0)) = 3`\\nHere\\'s another example : `20 = 3*4+3*2 = 3*(2^2) + 3*(2^1) = 3*((2^2)+(2^1))`\\nHope this helps someone and saves some time!!"
                    },
                    {
                        "username": "jomogalla",
                        "content": "I\\'m using Javascript for this challenge, and LeetCode is telling me my answer is incorrect, when it looks like theirs is?\\n\\n![image](https://assets.leetcode.com/users/images/2d8f9764-6fd7-4641-b1b0-2489d00f1ec8_1638217466.509745.png)\\n"
                    },
                    {
                        "username": "markaleptic",
                        "content": "Perhaps a bad test case, but my understanding was that -2147483648 / -1 = 2147483648.\\n![image](https://assets.leetcode.com/users/images/f9f7c8ed-225d-4076-8121-1931d720c528_1619064244.2609332.png)\\n\\n"
                    },
                    {
                        "username": "ratatouille117",
                        "content": "![image](https://assets.leetcode.com/users/images/2cd2f82e-6302-4f53-bed7-438d3edbcc67_1599423087.9170322.png)\\n"
                    },
                    {
                        "username": "ilias-t",
                        "content": "![image](https://assets.leetcode.com/users/images/cacd01af-7650-4da3-a4bf-40159f4b4680_1596308798.4310975.png)\\n"
                    },
                    {
                        "username": "user2451S",
                        "content": "is\\'nt -2147483648 divided by -1 = 2147483648? why is there a missing 1 in the answer\\n![image](https://assets.leetcode.com/users/user2451s/image_1566028161.png)\\n"
                    },
                    {
                        "username": "diewelt",
                        "content": "C language : -2147483648 / -1 = 2147483648 which can\\'t be expressed in 4 byte integer.\\n\\nWhy is the answer 2147483647?\\n\\nIt should be corrected."
                    }
                ]
            },
            {
                "id": 1574339,
                "content": [
                    {
                        "username": "nbeau",
                        "content": "I\\'m getting Time Limit Exceeded even though I have 994/994 test cases passed, why is this happening?"
                    },
                    {
                        "username": "Andrew0000",
                        "content": "I have the same"
                    },
                    {
                        "username": "mediterraneam",
                        "content": "At first I was wondering why such a simple question have so low pass rate. Now I know it\\'s due to a non-sense test case."
                    },
                    {
                        "username": "ifezec",
                        "content": "I was having a difficult time accepting the solution to the bitshifting approach as I was not able to mentally connect with the answer in code. Therefore, I needed to write it out on paper to make it clearer to reinforce this as a solution that I could reference for any future encounter.\\n\\nI wanted to share an image which may help make this clearer for others. The caveat is that it will only be clear if you know how to work with binary.\\n\\nI have 2 examples.  10/2 which would be 5. and 100/7 which is 14.\\n\\n\\n![image](https://assets.leetcode.com/users/images/8be3abf3-ba7f-415e-be00-ebc273003936_1647196362.826863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "NOMAD14",
                        "content": "**Original post**: [https://leetcode.com/explore/interview/card/top-interview-questions-medium/113/math/820/discuss/13467/Very-detailed-step-by-step-explanation-(Java-solution)](http://)\\n\\nEven though he has explained it well, I could not understand the concept the first time. But then I did a dry run...\\n**Here is the logic if someone is still struggling.**\\nex. 10/3\\nHere we need to get 10 by adding a bunch of 3\\'s multiplications.\\nSince every operation is off-limit, we need to think of something different. \\nWe can obtain multiplication and division by using the left and right shits. But these operations gives (num * 2) or (num / 2) respectively. \\nSo, we need to find a way to express 10 as a sum of `3*(power of 2)`.\\nwe can write it like this: `10 = 3*2 + 3*1 = 3*(2^1) + 3*(2^0) = 3*((2^1)+(2^0))`\\n(here, we only need a quotient as an answer. It will be the same as int division)\\nso every inner loop is finding the second term(count in the original post). \\n1st outer loop:\\n    inner loop finds (2^1)\\n2nd outer loop:\\n    inner loop finds (2^0)\\nVOLLA... we have our answer=>  `((2^1)+(2^0)) = 3`\\nHere\\'s another example : `20 = 3*4+3*2 = 3*(2^2) + 3*(2^1) = 3*((2^2)+(2^1))`\\nHope this helps someone and saves some time!!"
                    },
                    {
                        "username": "jomogalla",
                        "content": "I\\'m using Javascript for this challenge, and LeetCode is telling me my answer is incorrect, when it looks like theirs is?\\n\\n![image](https://assets.leetcode.com/users/images/2d8f9764-6fd7-4641-b1b0-2489d00f1ec8_1638217466.509745.png)\\n"
                    },
                    {
                        "username": "markaleptic",
                        "content": "Perhaps a bad test case, but my understanding was that -2147483648 / -1 = 2147483648.\\n![image](https://assets.leetcode.com/users/images/f9f7c8ed-225d-4076-8121-1931d720c528_1619064244.2609332.png)\\n\\n"
                    },
                    {
                        "username": "ratatouille117",
                        "content": "![image](https://assets.leetcode.com/users/images/2cd2f82e-6302-4f53-bed7-438d3edbcc67_1599423087.9170322.png)\\n"
                    },
                    {
                        "username": "ilias-t",
                        "content": "![image](https://assets.leetcode.com/users/images/cacd01af-7650-4da3-a4bf-40159f4b4680_1596308798.4310975.png)\\n"
                    },
                    {
                        "username": "user2451S",
                        "content": "is\\'nt -2147483648 divided by -1 = 2147483648? why is there a missing 1 in the answer\\n![image](https://assets.leetcode.com/users/user2451s/image_1566028161.png)\\n"
                    },
                    {
                        "username": "diewelt",
                        "content": "C language : -2147483648 / -1 = 2147483648 which can\\'t be expressed in 4 byte integer.\\n\\nWhy is the answer 2147483647?\\n\\nIt should be corrected."
                    }
                ]
            },
            {
                "id": 1574140,
                "content": [
                    {
                        "username": "nbeau",
                        "content": "I\\'m getting Time Limit Exceeded even though I have 994/994 test cases passed, why is this happening?"
                    },
                    {
                        "username": "Andrew0000",
                        "content": "I have the same"
                    },
                    {
                        "username": "mediterraneam",
                        "content": "At first I was wondering why such a simple question have so low pass rate. Now I know it\\'s due to a non-sense test case."
                    },
                    {
                        "username": "ifezec",
                        "content": "I was having a difficult time accepting the solution to the bitshifting approach as I was not able to mentally connect with the answer in code. Therefore, I needed to write it out on paper to make it clearer to reinforce this as a solution that I could reference for any future encounter.\\n\\nI wanted to share an image which may help make this clearer for others. The caveat is that it will only be clear if you know how to work with binary.\\n\\nI have 2 examples.  10/2 which would be 5. and 100/7 which is 14.\\n\\n\\n![image](https://assets.leetcode.com/users/images/8be3abf3-ba7f-415e-be00-ebc273003936_1647196362.826863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "NOMAD14",
                        "content": "**Original post**: [https://leetcode.com/explore/interview/card/top-interview-questions-medium/113/math/820/discuss/13467/Very-detailed-step-by-step-explanation-(Java-solution)](http://)\\n\\nEven though he has explained it well, I could not understand the concept the first time. But then I did a dry run...\\n**Here is the logic if someone is still struggling.**\\nex. 10/3\\nHere we need to get 10 by adding a bunch of 3\\'s multiplications.\\nSince every operation is off-limit, we need to think of something different. \\nWe can obtain multiplication and division by using the left and right shits. But these operations gives (num * 2) or (num / 2) respectively. \\nSo, we need to find a way to express 10 as a sum of `3*(power of 2)`.\\nwe can write it like this: `10 = 3*2 + 3*1 = 3*(2^1) + 3*(2^0) = 3*((2^1)+(2^0))`\\n(here, we only need a quotient as an answer. It will be the same as int division)\\nso every inner loop is finding the second term(count in the original post). \\n1st outer loop:\\n    inner loop finds (2^1)\\n2nd outer loop:\\n    inner loop finds (2^0)\\nVOLLA... we have our answer=>  `((2^1)+(2^0)) = 3`\\nHere\\'s another example : `20 = 3*4+3*2 = 3*(2^2) + 3*(2^1) = 3*((2^2)+(2^1))`\\nHope this helps someone and saves some time!!"
                    },
                    {
                        "username": "jomogalla",
                        "content": "I\\'m using Javascript for this challenge, and LeetCode is telling me my answer is incorrect, when it looks like theirs is?\\n\\n![image](https://assets.leetcode.com/users/images/2d8f9764-6fd7-4641-b1b0-2489d00f1ec8_1638217466.509745.png)\\n"
                    },
                    {
                        "username": "markaleptic",
                        "content": "Perhaps a bad test case, but my understanding was that -2147483648 / -1 = 2147483648.\\n![image](https://assets.leetcode.com/users/images/f9f7c8ed-225d-4076-8121-1931d720c528_1619064244.2609332.png)\\n\\n"
                    },
                    {
                        "username": "ratatouille117",
                        "content": "![image](https://assets.leetcode.com/users/images/2cd2f82e-6302-4f53-bed7-438d3edbcc67_1599423087.9170322.png)\\n"
                    },
                    {
                        "username": "ilias-t",
                        "content": "![image](https://assets.leetcode.com/users/images/cacd01af-7650-4da3-a4bf-40159f4b4680_1596308798.4310975.png)\\n"
                    },
                    {
                        "username": "user2451S",
                        "content": "is\\'nt -2147483648 divided by -1 = 2147483648? why is there a missing 1 in the answer\\n![image](https://assets.leetcode.com/users/user2451s/image_1566028161.png)\\n"
                    },
                    {
                        "username": "diewelt",
                        "content": "C language : -2147483648 / -1 = 2147483648 which can\\'t be expressed in 4 byte integer.\\n\\nWhy is the answer 2147483647?\\n\\nIt should be corrected."
                    }
                ]
            },
            {
                "id": 1572931,
                "content": [
                    {
                        "username": "nbeau",
                        "content": "I\\'m getting Time Limit Exceeded even though I have 994/994 test cases passed, why is this happening?"
                    },
                    {
                        "username": "Andrew0000",
                        "content": "I have the same"
                    },
                    {
                        "username": "mediterraneam",
                        "content": "At first I was wondering why such a simple question have so low pass rate. Now I know it\\'s due to a non-sense test case."
                    },
                    {
                        "username": "ifezec",
                        "content": "I was having a difficult time accepting the solution to the bitshifting approach as I was not able to mentally connect with the answer in code. Therefore, I needed to write it out on paper to make it clearer to reinforce this as a solution that I could reference for any future encounter.\\n\\nI wanted to share an image which may help make this clearer for others. The caveat is that it will only be clear if you know how to work with binary.\\n\\nI have 2 examples.  10/2 which would be 5. and 100/7 which is 14.\\n\\n\\n![image](https://assets.leetcode.com/users/images/8be3abf3-ba7f-415e-be00-ebc273003936_1647196362.826863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "NOMAD14",
                        "content": "**Original post**: [https://leetcode.com/explore/interview/card/top-interview-questions-medium/113/math/820/discuss/13467/Very-detailed-step-by-step-explanation-(Java-solution)](http://)\\n\\nEven though he has explained it well, I could not understand the concept the first time. But then I did a dry run...\\n**Here is the logic if someone is still struggling.**\\nex. 10/3\\nHere we need to get 10 by adding a bunch of 3\\'s multiplications.\\nSince every operation is off-limit, we need to think of something different. \\nWe can obtain multiplication and division by using the left and right shits. But these operations gives (num * 2) or (num / 2) respectively. \\nSo, we need to find a way to express 10 as a sum of `3*(power of 2)`.\\nwe can write it like this: `10 = 3*2 + 3*1 = 3*(2^1) + 3*(2^0) = 3*((2^1)+(2^0))`\\n(here, we only need a quotient as an answer. It will be the same as int division)\\nso every inner loop is finding the second term(count in the original post). \\n1st outer loop:\\n    inner loop finds (2^1)\\n2nd outer loop:\\n    inner loop finds (2^0)\\nVOLLA... we have our answer=>  `((2^1)+(2^0)) = 3`\\nHere\\'s another example : `20 = 3*4+3*2 = 3*(2^2) + 3*(2^1) = 3*((2^2)+(2^1))`\\nHope this helps someone and saves some time!!"
                    },
                    {
                        "username": "jomogalla",
                        "content": "I\\'m using Javascript for this challenge, and LeetCode is telling me my answer is incorrect, when it looks like theirs is?\\n\\n![image](https://assets.leetcode.com/users/images/2d8f9764-6fd7-4641-b1b0-2489d00f1ec8_1638217466.509745.png)\\n"
                    },
                    {
                        "username": "markaleptic",
                        "content": "Perhaps a bad test case, but my understanding was that -2147483648 / -1 = 2147483648.\\n![image](https://assets.leetcode.com/users/images/f9f7c8ed-225d-4076-8121-1931d720c528_1619064244.2609332.png)\\n\\n"
                    },
                    {
                        "username": "ratatouille117",
                        "content": "![image](https://assets.leetcode.com/users/images/2cd2f82e-6302-4f53-bed7-438d3edbcc67_1599423087.9170322.png)\\n"
                    },
                    {
                        "username": "ilias-t",
                        "content": "![image](https://assets.leetcode.com/users/images/cacd01af-7650-4da3-a4bf-40159f4b4680_1596308798.4310975.png)\\n"
                    },
                    {
                        "username": "user2451S",
                        "content": "is\\'nt -2147483648 divided by -1 = 2147483648? why is there a missing 1 in the answer\\n![image](https://assets.leetcode.com/users/user2451s/image_1566028161.png)\\n"
                    },
                    {
                        "username": "diewelt",
                        "content": "C language : -2147483648 / -1 = 2147483648 which can\\'t be expressed in 4 byte integer.\\n\\nWhy is the answer 2147483647?\\n\\nIt should be corrected."
                    }
                ]
            },
            {
                "id": 1572613,
                "content": [
                    {
                        "username": "nbeau",
                        "content": "I\\'m getting Time Limit Exceeded even though I have 994/994 test cases passed, why is this happening?"
                    },
                    {
                        "username": "Andrew0000",
                        "content": "I have the same"
                    },
                    {
                        "username": "mediterraneam",
                        "content": "At first I was wondering why such a simple question have so low pass rate. Now I know it\\'s due to a non-sense test case."
                    },
                    {
                        "username": "ifezec",
                        "content": "I was having a difficult time accepting the solution to the bitshifting approach as I was not able to mentally connect with the answer in code. Therefore, I needed to write it out on paper to make it clearer to reinforce this as a solution that I could reference for any future encounter.\\n\\nI wanted to share an image which may help make this clearer for others. The caveat is that it will only be clear if you know how to work with binary.\\n\\nI have 2 examples.  10/2 which would be 5. and 100/7 which is 14.\\n\\n\\n![image](https://assets.leetcode.com/users/images/8be3abf3-ba7f-415e-be00-ebc273003936_1647196362.826863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "NOMAD14",
                        "content": "**Original post**: [https://leetcode.com/explore/interview/card/top-interview-questions-medium/113/math/820/discuss/13467/Very-detailed-step-by-step-explanation-(Java-solution)](http://)\\n\\nEven though he has explained it well, I could not understand the concept the first time. But then I did a dry run...\\n**Here is the logic if someone is still struggling.**\\nex. 10/3\\nHere we need to get 10 by adding a bunch of 3\\'s multiplications.\\nSince every operation is off-limit, we need to think of something different. \\nWe can obtain multiplication and division by using the left and right shits. But these operations gives (num * 2) or (num / 2) respectively. \\nSo, we need to find a way to express 10 as a sum of `3*(power of 2)`.\\nwe can write it like this: `10 = 3*2 + 3*1 = 3*(2^1) + 3*(2^0) = 3*((2^1)+(2^0))`\\n(here, we only need a quotient as an answer. It will be the same as int division)\\nso every inner loop is finding the second term(count in the original post). \\n1st outer loop:\\n    inner loop finds (2^1)\\n2nd outer loop:\\n    inner loop finds (2^0)\\nVOLLA... we have our answer=>  `((2^1)+(2^0)) = 3`\\nHere\\'s another example : `20 = 3*4+3*2 = 3*(2^2) + 3*(2^1) = 3*((2^2)+(2^1))`\\nHope this helps someone and saves some time!!"
                    },
                    {
                        "username": "jomogalla",
                        "content": "I\\'m using Javascript for this challenge, and LeetCode is telling me my answer is incorrect, when it looks like theirs is?\\n\\n![image](https://assets.leetcode.com/users/images/2d8f9764-6fd7-4641-b1b0-2489d00f1ec8_1638217466.509745.png)\\n"
                    },
                    {
                        "username": "markaleptic",
                        "content": "Perhaps a bad test case, but my understanding was that -2147483648 / -1 = 2147483648.\\n![image](https://assets.leetcode.com/users/images/f9f7c8ed-225d-4076-8121-1931d720c528_1619064244.2609332.png)\\n\\n"
                    },
                    {
                        "username": "ratatouille117",
                        "content": "![image](https://assets.leetcode.com/users/images/2cd2f82e-6302-4f53-bed7-438d3edbcc67_1599423087.9170322.png)\\n"
                    },
                    {
                        "username": "ilias-t",
                        "content": "![image](https://assets.leetcode.com/users/images/cacd01af-7650-4da3-a4bf-40159f4b4680_1596308798.4310975.png)\\n"
                    },
                    {
                        "username": "user2451S",
                        "content": "is\\'nt -2147483648 divided by -1 = 2147483648? why is there a missing 1 in the answer\\n![image](https://assets.leetcode.com/users/user2451s/image_1566028161.png)\\n"
                    },
                    {
                        "username": "diewelt",
                        "content": "C language : -2147483648 / -1 = 2147483648 which can\\'t be expressed in 4 byte integer.\\n\\nWhy is the answer 2147483647?\\n\\nIt should be corrected."
                    }
                ]
            },
            {
                "id": 1571072,
                "content": [
                    {
                        "username": "anthony11",
                        "content": "Dividing Integer.MIN_VALUE by -1 should cause overflow, but here's what I get. Sorry, folks, Int.MAX_VALUE is not the correct answer.\\n`\\nInput:\\n-2147483648\\n-1\\nOutput:\\n0\\nExpected:\\n2147483647`"
                    },
                    {
                        "username": "alexgaas",
                        "content": "Hi,\\n\\nGot pretty funny \"Expected\" answer about this problem - https://leetcode.com/problems/divide-two-integers\\n\\nI've tried to check my solution few times but every time getting:\\n\\nRun Code Result:\\n\\nYour input\\n**-2147483648\\n-1**\\n\\nYour answer\\n**2147483648**\\n\\nExpected answer\\n**2147483647**\\n\\n*Language - javascript*\\n\\nCould someone help to solve this \"issue\" :)? Thanks"
                    },
                    {
                        "username": "nanshu",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nOutput:\\n**2147483648**\\n\\nExpected:\\n**2147483647**"
                    },
                    {
                        "username": "l328",
                        "content": "I wrote the program in JavaScript and it is able to output the correct answer \"2147483648\" based on the given input \"-2147483648, -1\". However OJ is expecting an answer of \"2147483647\" ---> this probably will happen when overflow happens during bitshift. Using \">>>\" unsigned bitshift this shouldn't happen though."
                    },
                    {
                        "username": "erhkang2",
                        "content": "Python gives -1 on my local machine."
                    },
                    {
                        "username": "monte",
                        "content": "I know it depends on the compiler. I am just curious that why with a similar algorithm c version code seems to be always faster than c++ version based on the results from the leetcode OJ. Especially when is no advanced c++ features (e.g. virtual functions) involved like in this \"divide two integers\" problem."
                    },
                    {
                        "username": "rdnz",
                        "content": "The problem did not specify what value is returned for the division. Res?"
                    },
                    {
                        "username": "atul",
                        "content": "What is Expected output when divisor is 0?"
                    },
                    {
                        "username": "luciferjain277",
                        "content": "Easy step by step explanation video in Hindi: https://youtu.be/vgfB4r2HQck\\nIf you like the content do up-vote the post so that it could reach to a larger audience.\\n"
                    },
                    {
                        "username": "nchait",
                        "content": "![image](https://assets.leetcode.com/users/images/a2c5c58d-c7d6-40ab-b9e7-94743475aa96_1614364479.9338746.png)\\nwhy is this output incorrect? last i checked, -x/-1=x not x-1??"
                    }
                ]
            },
            {
                "id": 1571071,
                "content": [
                    {
                        "username": "anthony11",
                        "content": "Dividing Integer.MIN_VALUE by -1 should cause overflow, but here's what I get. Sorry, folks, Int.MAX_VALUE is not the correct answer.\\n`\\nInput:\\n-2147483648\\n-1\\nOutput:\\n0\\nExpected:\\n2147483647`"
                    },
                    {
                        "username": "alexgaas",
                        "content": "Hi,\\n\\nGot pretty funny \"Expected\" answer about this problem - https://leetcode.com/problems/divide-two-integers\\n\\nI've tried to check my solution few times but every time getting:\\n\\nRun Code Result:\\n\\nYour input\\n**-2147483648\\n-1**\\n\\nYour answer\\n**2147483648**\\n\\nExpected answer\\n**2147483647**\\n\\n*Language - javascript*\\n\\nCould someone help to solve this \"issue\" :)? Thanks"
                    },
                    {
                        "username": "nanshu",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nOutput:\\n**2147483648**\\n\\nExpected:\\n**2147483647**"
                    },
                    {
                        "username": "l328",
                        "content": "I wrote the program in JavaScript and it is able to output the correct answer \"2147483648\" based on the given input \"-2147483648, -1\". However OJ is expecting an answer of \"2147483647\" ---> this probably will happen when overflow happens during bitshift. Using \">>>\" unsigned bitshift this shouldn't happen though."
                    },
                    {
                        "username": "erhkang2",
                        "content": "Python gives -1 on my local machine."
                    },
                    {
                        "username": "monte",
                        "content": "I know it depends on the compiler. I am just curious that why with a similar algorithm c version code seems to be always faster than c++ version based on the results from the leetcode OJ. Especially when is no advanced c++ features (e.g. virtual functions) involved like in this \"divide two integers\" problem."
                    },
                    {
                        "username": "rdnz",
                        "content": "The problem did not specify what value is returned for the division. Res?"
                    },
                    {
                        "username": "atul",
                        "content": "What is Expected output when divisor is 0?"
                    },
                    {
                        "username": "luciferjain277",
                        "content": "Easy step by step explanation video in Hindi: https://youtu.be/vgfB4r2HQck\\nIf you like the content do up-vote the post so that it could reach to a larger audience.\\n"
                    },
                    {
                        "username": "nchait",
                        "content": "![image](https://assets.leetcode.com/users/images/a2c5c58d-c7d6-40ab-b9e7-94743475aa96_1614364479.9338746.png)\\nwhy is this output incorrect? last i checked, -x/-1=x not x-1??"
                    }
                ]
            },
            {
                "id": 1571075,
                "content": [
                    {
                        "username": "anthony11",
                        "content": "Dividing Integer.MIN_VALUE by -1 should cause overflow, but here's what I get. Sorry, folks, Int.MAX_VALUE is not the correct answer.\\n`\\nInput:\\n-2147483648\\n-1\\nOutput:\\n0\\nExpected:\\n2147483647`"
                    },
                    {
                        "username": "alexgaas",
                        "content": "Hi,\\n\\nGot pretty funny \"Expected\" answer about this problem - https://leetcode.com/problems/divide-two-integers\\n\\nI've tried to check my solution few times but every time getting:\\n\\nRun Code Result:\\n\\nYour input\\n**-2147483648\\n-1**\\n\\nYour answer\\n**2147483648**\\n\\nExpected answer\\n**2147483647**\\n\\n*Language - javascript*\\n\\nCould someone help to solve this \"issue\" :)? Thanks"
                    },
                    {
                        "username": "nanshu",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nOutput:\\n**2147483648**\\n\\nExpected:\\n**2147483647**"
                    },
                    {
                        "username": "l328",
                        "content": "I wrote the program in JavaScript and it is able to output the correct answer \"2147483648\" based on the given input \"-2147483648, -1\". However OJ is expecting an answer of \"2147483647\" ---> this probably will happen when overflow happens during bitshift. Using \">>>\" unsigned bitshift this shouldn't happen though."
                    },
                    {
                        "username": "erhkang2",
                        "content": "Python gives -1 on my local machine."
                    },
                    {
                        "username": "monte",
                        "content": "I know it depends on the compiler. I am just curious that why with a similar algorithm c version code seems to be always faster than c++ version based on the results from the leetcode OJ. Especially when is no advanced c++ features (e.g. virtual functions) involved like in this \"divide two integers\" problem."
                    },
                    {
                        "username": "rdnz",
                        "content": "The problem did not specify what value is returned for the division. Res?"
                    },
                    {
                        "username": "atul",
                        "content": "What is Expected output when divisor is 0?"
                    },
                    {
                        "username": "luciferjain277",
                        "content": "Easy step by step explanation video in Hindi: https://youtu.be/vgfB4r2HQck\\nIf you like the content do up-vote the post so that it could reach to a larger audience.\\n"
                    },
                    {
                        "username": "nchait",
                        "content": "![image](https://assets.leetcode.com/users/images/a2c5c58d-c7d6-40ab-b9e7-94743475aa96_1614364479.9338746.png)\\nwhy is this output incorrect? last i checked, -x/-1=x not x-1??"
                    }
                ]
            },
            {
                "id": 1571076,
                "content": [
                    {
                        "username": "anthony11",
                        "content": "Dividing Integer.MIN_VALUE by -1 should cause overflow, but here's what I get. Sorry, folks, Int.MAX_VALUE is not the correct answer.\\n`\\nInput:\\n-2147483648\\n-1\\nOutput:\\n0\\nExpected:\\n2147483647`"
                    },
                    {
                        "username": "alexgaas",
                        "content": "Hi,\\n\\nGot pretty funny \"Expected\" answer about this problem - https://leetcode.com/problems/divide-two-integers\\n\\nI've tried to check my solution few times but every time getting:\\n\\nRun Code Result:\\n\\nYour input\\n**-2147483648\\n-1**\\n\\nYour answer\\n**2147483648**\\n\\nExpected answer\\n**2147483647**\\n\\n*Language - javascript*\\n\\nCould someone help to solve this \"issue\" :)? Thanks"
                    },
                    {
                        "username": "nanshu",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nOutput:\\n**2147483648**\\n\\nExpected:\\n**2147483647**"
                    },
                    {
                        "username": "l328",
                        "content": "I wrote the program in JavaScript and it is able to output the correct answer \"2147483648\" based on the given input \"-2147483648, -1\". However OJ is expecting an answer of \"2147483647\" ---> this probably will happen when overflow happens during bitshift. Using \">>>\" unsigned bitshift this shouldn't happen though."
                    },
                    {
                        "username": "erhkang2",
                        "content": "Python gives -1 on my local machine."
                    },
                    {
                        "username": "monte",
                        "content": "I know it depends on the compiler. I am just curious that why with a similar algorithm c version code seems to be always faster than c++ version based on the results from the leetcode OJ. Especially when is no advanced c++ features (e.g. virtual functions) involved like in this \"divide two integers\" problem."
                    },
                    {
                        "username": "rdnz",
                        "content": "The problem did not specify what value is returned for the division. Res?"
                    },
                    {
                        "username": "atul",
                        "content": "What is Expected output when divisor is 0?"
                    },
                    {
                        "username": "luciferjain277",
                        "content": "Easy step by step explanation video in Hindi: https://youtu.be/vgfB4r2HQck\\nIf you like the content do up-vote the post so that it could reach to a larger audience.\\n"
                    },
                    {
                        "username": "nchait",
                        "content": "![image](https://assets.leetcode.com/users/images/a2c5c58d-c7d6-40ab-b9e7-94743475aa96_1614364479.9338746.png)\\nwhy is this output incorrect? last i checked, -x/-1=x not x-1??"
                    }
                ]
            },
            {
                "id": 1571077,
                "content": [
                    {
                        "username": "anthony11",
                        "content": "Dividing Integer.MIN_VALUE by -1 should cause overflow, but here's what I get. Sorry, folks, Int.MAX_VALUE is not the correct answer.\\n`\\nInput:\\n-2147483648\\n-1\\nOutput:\\n0\\nExpected:\\n2147483647`"
                    },
                    {
                        "username": "alexgaas",
                        "content": "Hi,\\n\\nGot pretty funny \"Expected\" answer about this problem - https://leetcode.com/problems/divide-two-integers\\n\\nI've tried to check my solution few times but every time getting:\\n\\nRun Code Result:\\n\\nYour input\\n**-2147483648\\n-1**\\n\\nYour answer\\n**2147483648**\\n\\nExpected answer\\n**2147483647**\\n\\n*Language - javascript*\\n\\nCould someone help to solve this \"issue\" :)? Thanks"
                    },
                    {
                        "username": "nanshu",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nOutput:\\n**2147483648**\\n\\nExpected:\\n**2147483647**"
                    },
                    {
                        "username": "l328",
                        "content": "I wrote the program in JavaScript and it is able to output the correct answer \"2147483648\" based on the given input \"-2147483648, -1\". However OJ is expecting an answer of \"2147483647\" ---> this probably will happen when overflow happens during bitshift. Using \">>>\" unsigned bitshift this shouldn't happen though."
                    },
                    {
                        "username": "erhkang2",
                        "content": "Python gives -1 on my local machine."
                    },
                    {
                        "username": "monte",
                        "content": "I know it depends on the compiler. I am just curious that why with a similar algorithm c version code seems to be always faster than c++ version based on the results from the leetcode OJ. Especially when is no advanced c++ features (e.g. virtual functions) involved like in this \"divide two integers\" problem."
                    },
                    {
                        "username": "rdnz",
                        "content": "The problem did not specify what value is returned for the division. Res?"
                    },
                    {
                        "username": "atul",
                        "content": "What is Expected output when divisor is 0?"
                    },
                    {
                        "username": "luciferjain277",
                        "content": "Easy step by step explanation video in Hindi: https://youtu.be/vgfB4r2HQck\\nIf you like the content do up-vote the post so that it could reach to a larger audience.\\n"
                    },
                    {
                        "username": "nchait",
                        "content": "![image](https://assets.leetcode.com/users/images/a2c5c58d-c7d6-40ab-b9e7-94743475aa96_1614364479.9338746.png)\\nwhy is this output incorrect? last i checked, -x/-1=x not x-1??"
                    }
                ]
            },
            {
                "id": 1571078,
                "content": [
                    {
                        "username": "anthony11",
                        "content": "Dividing Integer.MIN_VALUE by -1 should cause overflow, but here's what I get. Sorry, folks, Int.MAX_VALUE is not the correct answer.\\n`\\nInput:\\n-2147483648\\n-1\\nOutput:\\n0\\nExpected:\\n2147483647`"
                    },
                    {
                        "username": "alexgaas",
                        "content": "Hi,\\n\\nGot pretty funny \"Expected\" answer about this problem - https://leetcode.com/problems/divide-two-integers\\n\\nI've tried to check my solution few times but every time getting:\\n\\nRun Code Result:\\n\\nYour input\\n**-2147483648\\n-1**\\n\\nYour answer\\n**2147483648**\\n\\nExpected answer\\n**2147483647**\\n\\n*Language - javascript*\\n\\nCould someone help to solve this \"issue\" :)? Thanks"
                    },
                    {
                        "username": "nanshu",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nOutput:\\n**2147483648**\\n\\nExpected:\\n**2147483647**"
                    },
                    {
                        "username": "l328",
                        "content": "I wrote the program in JavaScript and it is able to output the correct answer \"2147483648\" based on the given input \"-2147483648, -1\". However OJ is expecting an answer of \"2147483647\" ---> this probably will happen when overflow happens during bitshift. Using \">>>\" unsigned bitshift this shouldn't happen though."
                    },
                    {
                        "username": "erhkang2",
                        "content": "Python gives -1 on my local machine."
                    },
                    {
                        "username": "monte",
                        "content": "I know it depends on the compiler. I am just curious that why with a similar algorithm c version code seems to be always faster than c++ version based on the results from the leetcode OJ. Especially when is no advanced c++ features (e.g. virtual functions) involved like in this \"divide two integers\" problem."
                    },
                    {
                        "username": "rdnz",
                        "content": "The problem did not specify what value is returned for the division. Res?"
                    },
                    {
                        "username": "atul",
                        "content": "What is Expected output when divisor is 0?"
                    },
                    {
                        "username": "luciferjain277",
                        "content": "Easy step by step explanation video in Hindi: https://youtu.be/vgfB4r2HQck\\nIf you like the content do up-vote the post so that it could reach to a larger audience.\\n"
                    },
                    {
                        "username": "nchait",
                        "content": "![image](https://assets.leetcode.com/users/images/a2c5c58d-c7d6-40ab-b9e7-94743475aa96_1614364479.9338746.png)\\nwhy is this output incorrect? last i checked, -x/-1=x not x-1??"
                    }
                ]
            },
            {
                "id": 1571079,
                "content": [
                    {
                        "username": "anthony11",
                        "content": "Dividing Integer.MIN_VALUE by -1 should cause overflow, but here's what I get. Sorry, folks, Int.MAX_VALUE is not the correct answer.\\n`\\nInput:\\n-2147483648\\n-1\\nOutput:\\n0\\nExpected:\\n2147483647`"
                    },
                    {
                        "username": "alexgaas",
                        "content": "Hi,\\n\\nGot pretty funny \"Expected\" answer about this problem - https://leetcode.com/problems/divide-two-integers\\n\\nI've tried to check my solution few times but every time getting:\\n\\nRun Code Result:\\n\\nYour input\\n**-2147483648\\n-1**\\n\\nYour answer\\n**2147483648**\\n\\nExpected answer\\n**2147483647**\\n\\n*Language - javascript*\\n\\nCould someone help to solve this \"issue\" :)? Thanks"
                    },
                    {
                        "username": "nanshu",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nOutput:\\n**2147483648**\\n\\nExpected:\\n**2147483647**"
                    },
                    {
                        "username": "l328",
                        "content": "I wrote the program in JavaScript and it is able to output the correct answer \"2147483648\" based on the given input \"-2147483648, -1\". However OJ is expecting an answer of \"2147483647\" ---> this probably will happen when overflow happens during bitshift. Using \">>>\" unsigned bitshift this shouldn't happen though."
                    },
                    {
                        "username": "erhkang2",
                        "content": "Python gives -1 on my local machine."
                    },
                    {
                        "username": "monte",
                        "content": "I know it depends on the compiler. I am just curious that why with a similar algorithm c version code seems to be always faster than c++ version based on the results from the leetcode OJ. Especially when is no advanced c++ features (e.g. virtual functions) involved like in this \"divide two integers\" problem."
                    },
                    {
                        "username": "rdnz",
                        "content": "The problem did not specify what value is returned for the division. Res?"
                    },
                    {
                        "username": "atul",
                        "content": "What is Expected output when divisor is 0?"
                    },
                    {
                        "username": "luciferjain277",
                        "content": "Easy step by step explanation video in Hindi: https://youtu.be/vgfB4r2HQck\\nIf you like the content do up-vote the post so that it could reach to a larger audience.\\n"
                    },
                    {
                        "username": "nchait",
                        "content": "![image](https://assets.leetcode.com/users/images/a2c5c58d-c7d6-40ab-b9e7-94743475aa96_1614364479.9338746.png)\\nwhy is this output incorrect? last i checked, -x/-1=x not x-1??"
                    }
                ]
            },
            {
                "id": 1571080,
                "content": [
                    {
                        "username": "anthony11",
                        "content": "Dividing Integer.MIN_VALUE by -1 should cause overflow, but here's what I get. Sorry, folks, Int.MAX_VALUE is not the correct answer.\\n`\\nInput:\\n-2147483648\\n-1\\nOutput:\\n0\\nExpected:\\n2147483647`"
                    },
                    {
                        "username": "alexgaas",
                        "content": "Hi,\\n\\nGot pretty funny \"Expected\" answer about this problem - https://leetcode.com/problems/divide-two-integers\\n\\nI've tried to check my solution few times but every time getting:\\n\\nRun Code Result:\\n\\nYour input\\n**-2147483648\\n-1**\\n\\nYour answer\\n**2147483648**\\n\\nExpected answer\\n**2147483647**\\n\\n*Language - javascript*\\n\\nCould someone help to solve this \"issue\" :)? Thanks"
                    },
                    {
                        "username": "nanshu",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nOutput:\\n**2147483648**\\n\\nExpected:\\n**2147483647**"
                    },
                    {
                        "username": "l328",
                        "content": "I wrote the program in JavaScript and it is able to output the correct answer \"2147483648\" based on the given input \"-2147483648, -1\". However OJ is expecting an answer of \"2147483647\" ---> this probably will happen when overflow happens during bitshift. Using \">>>\" unsigned bitshift this shouldn't happen though."
                    },
                    {
                        "username": "erhkang2",
                        "content": "Python gives -1 on my local machine."
                    },
                    {
                        "username": "monte",
                        "content": "I know it depends on the compiler. I am just curious that why with a similar algorithm c version code seems to be always faster than c++ version based on the results from the leetcode OJ. Especially when is no advanced c++ features (e.g. virtual functions) involved like in this \"divide two integers\" problem."
                    },
                    {
                        "username": "rdnz",
                        "content": "The problem did not specify what value is returned for the division. Res?"
                    },
                    {
                        "username": "atul",
                        "content": "What is Expected output when divisor is 0?"
                    },
                    {
                        "username": "luciferjain277",
                        "content": "Easy step by step explanation video in Hindi: https://youtu.be/vgfB4r2HQck\\nIf you like the content do up-vote the post so that it could reach to a larger audience.\\n"
                    },
                    {
                        "username": "nchait",
                        "content": "![image](https://assets.leetcode.com/users/images/a2c5c58d-c7d6-40ab-b9e7-94743475aa96_1614364479.9338746.png)\\nwhy is this output incorrect? last i checked, -x/-1=x not x-1??"
                    }
                ]
            },
            {
                "id": 1576825,
                "content": [
                    {
                        "username": "anthony11",
                        "content": "Dividing Integer.MIN_VALUE by -1 should cause overflow, but here's what I get. Sorry, folks, Int.MAX_VALUE is not the correct answer.\\n`\\nInput:\\n-2147483648\\n-1\\nOutput:\\n0\\nExpected:\\n2147483647`"
                    },
                    {
                        "username": "alexgaas",
                        "content": "Hi,\\n\\nGot pretty funny \"Expected\" answer about this problem - https://leetcode.com/problems/divide-two-integers\\n\\nI've tried to check my solution few times but every time getting:\\n\\nRun Code Result:\\n\\nYour input\\n**-2147483648\\n-1**\\n\\nYour answer\\n**2147483648**\\n\\nExpected answer\\n**2147483647**\\n\\n*Language - javascript*\\n\\nCould someone help to solve this \"issue\" :)? Thanks"
                    },
                    {
                        "username": "nanshu",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nOutput:\\n**2147483648**\\n\\nExpected:\\n**2147483647**"
                    },
                    {
                        "username": "l328",
                        "content": "I wrote the program in JavaScript and it is able to output the correct answer \"2147483648\" based on the given input \"-2147483648, -1\". However OJ is expecting an answer of \"2147483647\" ---> this probably will happen when overflow happens during bitshift. Using \">>>\" unsigned bitshift this shouldn't happen though."
                    },
                    {
                        "username": "erhkang2",
                        "content": "Python gives -1 on my local machine."
                    },
                    {
                        "username": "monte",
                        "content": "I know it depends on the compiler. I am just curious that why with a similar algorithm c version code seems to be always faster than c++ version based on the results from the leetcode OJ. Especially when is no advanced c++ features (e.g. virtual functions) involved like in this \"divide two integers\" problem."
                    },
                    {
                        "username": "rdnz",
                        "content": "The problem did not specify what value is returned for the division. Res?"
                    },
                    {
                        "username": "atul",
                        "content": "What is Expected output when divisor is 0?"
                    },
                    {
                        "username": "luciferjain277",
                        "content": "Easy step by step explanation video in Hindi: https://youtu.be/vgfB4r2HQck\\nIf you like the content do up-vote the post so that it could reach to a larger audience.\\n"
                    },
                    {
                        "username": "nchait",
                        "content": "![image](https://assets.leetcode.com/users/images/a2c5c58d-c7d6-40ab-b9e7-94743475aa96_1614364479.9338746.png)\\nwhy is this output incorrect? last i checked, -x/-1=x not x-1??"
                    }
                ]
            },
            {
                "id": 1574983,
                "content": [
                    {
                        "username": "anthony11",
                        "content": "Dividing Integer.MIN_VALUE by -1 should cause overflow, but here's what I get. Sorry, folks, Int.MAX_VALUE is not the correct answer.\\n`\\nInput:\\n-2147483648\\n-1\\nOutput:\\n0\\nExpected:\\n2147483647`"
                    },
                    {
                        "username": "alexgaas",
                        "content": "Hi,\\n\\nGot pretty funny \"Expected\" answer about this problem - https://leetcode.com/problems/divide-two-integers\\n\\nI've tried to check my solution few times but every time getting:\\n\\nRun Code Result:\\n\\nYour input\\n**-2147483648\\n-1**\\n\\nYour answer\\n**2147483648**\\n\\nExpected answer\\n**2147483647**\\n\\n*Language - javascript*\\n\\nCould someone help to solve this \"issue\" :)? Thanks"
                    },
                    {
                        "username": "nanshu",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nOutput:\\n**2147483648**\\n\\nExpected:\\n**2147483647**"
                    },
                    {
                        "username": "l328",
                        "content": "I wrote the program in JavaScript and it is able to output the correct answer \"2147483648\" based on the given input \"-2147483648, -1\". However OJ is expecting an answer of \"2147483647\" ---> this probably will happen when overflow happens during bitshift. Using \">>>\" unsigned bitshift this shouldn't happen though."
                    },
                    {
                        "username": "erhkang2",
                        "content": "Python gives -1 on my local machine."
                    },
                    {
                        "username": "monte",
                        "content": "I know it depends on the compiler. I am just curious that why with a similar algorithm c version code seems to be always faster than c++ version based on the results from the leetcode OJ. Especially when is no advanced c++ features (e.g. virtual functions) involved like in this \"divide two integers\" problem."
                    },
                    {
                        "username": "rdnz",
                        "content": "The problem did not specify what value is returned for the division. Res?"
                    },
                    {
                        "username": "atul",
                        "content": "What is Expected output when divisor is 0?"
                    },
                    {
                        "username": "luciferjain277",
                        "content": "Easy step by step explanation video in Hindi: https://youtu.be/vgfB4r2HQck\\nIf you like the content do up-vote the post so that it could reach to a larger audience.\\n"
                    },
                    {
                        "username": "nchait",
                        "content": "![image](https://assets.leetcode.com/users/images/a2c5c58d-c7d6-40ab-b9e7-94743475aa96_1614364479.9338746.png)\\nwhy is this output incorrect? last i checked, -x/-1=x not x-1??"
                    }
                ]
            },
            {
                "id": 1573475,
                "content": [
                    {
                        "username": "Mlizhardy",
                        "content": "Input\\n-2147483648\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nproper output IS 2147483648"
                    },
                    {
                        "username": "shashankvashistha1",
                        "content": "gandu question dont do it here."
                    },
                    {
                        "username": "mahmoodn",
                        "content": "For -231/3 the shift algorithm (M and AQ registers) yields Q=-76 and R=-3. So \\n-76x3-3=-231\\nBut the expected output is -77."
                    },
                    {
                        "username": "rgestudillo",
                        "content": "very easy, should be easy"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Why Binary search is not in \"related topics\" of this question??"
                    },
                    {
                        "username": "stonethrow-leetcode",
                        "content": "I think I've encountered the same issue reported by [@jayramesh0](/jayramesh0) on Mar 03, 2023 -- 994/994 testcases passed, yet there is a claimed time limit exceeded.\nIf I try \"Use Testcase\" to add the \"failed\" testcase to my test runs, that testcase _has no dividend or divisor_!\nThis feels like a bug in how this problem or acceptance criteria are implemented.\nIs there a way to get leetcode admins to look into this?\nOr does anyone else who's encountered this problem know what's going on or how to address it?\n\nI'm assuming that \"n/n testcases passed\" is advertised honestly, and that there are therefore no other conditions to that solution being flagged successful."
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "If I ever get this problem in an interview, I\\'ll happily shake hands with the interviewer and walk out the room.\\n"
                    },
                    {
                        "username": "phuonganhthanh1107",
                        "content": "using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace ConsoleApplication3\\n{\\n    class Program\\n    {\\n        public static void Divide(long dividend , long divisor)\\n        {\\n            if (dividend == 0 || Math.Abs(dividend) < Math.Abs(divisor))\\n            {\\n                Console.Write(0);\\n            }\\n            else \\n            {\\n                int devidend_isGreater_than_0 = 1;\\n                int divisor_isGreater_than_0 = 1;\\n                if (dividend < 0) \\n                {\\n                    dividend = dividend * (-1);\\n                    devidend_isGreater_than_0 = -1;\\n                }\\n                if (divisor < 0) \\n                {\\n                    divisor = divisor * (-1);\\n                    divisor_isGreater_than_0 = -1;\\n                }\\n\\n                long count = 0;\\n                for (long i = 0; i < long.MaxValue; i++) \\n                {\\n                    dividend = dividend - divisor;\\n                    if (dividend >= 0)\\n                    {\\n                        count++;\\n                    }\\n                    else \\n                    {\\n                        break;\\n                    }\\n                }\\n                if (devidend_isGreater_than_0 * divisor_isGreater_than_0 < 0) \\n                {\\n                    count *= -1;\\n                }\\n\\n                Console.Write(count);\\n            }\\n        }\\n        static void Main(string[] args)\\n        {\\n            string dividend, divisor;\\n            dividend = Console.ReadLine();\\n            long DIVIDEND = long.Parse(dividend);\\n\\n            long DIVISOR;\\n            do\\n            {\\n                divisor = Console.ReadLine();\\n                DIVISOR = long.Parse(divisor);\\n            } while (DIVISOR == 0);\\n\\n            Divide(DIVIDEND, DIVISOR);\\n            Console.ReadKey();\\n        }\\n    }\\n}\\n\\n\\nnot template , it used to reference \\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was always wondering about those 'smarties' who add tescases with numbers beyond the 32 bit integers range.  For what, do you wanna win the system? \nCongrats, your testcase was conditioned. \n```\n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n```\n\nLol, keep wasting your time. \n"
                    },
                    {
                        "username": "maxlee577",
                        "content": "-231/3 = -77 but according to the test case it should be 76 makes no sense"
                    }
                ]
            },
            {
                "id": 2067311,
                "content": [
                    {
                        "username": "Mlizhardy",
                        "content": "Input\\n-2147483648\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nproper output IS 2147483648"
                    },
                    {
                        "username": "shashankvashistha1",
                        "content": "gandu question dont do it here."
                    },
                    {
                        "username": "mahmoodn",
                        "content": "For -231/3 the shift algorithm (M and AQ registers) yields Q=-76 and R=-3. So \\n-76x3-3=-231\\nBut the expected output is -77."
                    },
                    {
                        "username": "rgestudillo",
                        "content": "very easy, should be easy"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Why Binary search is not in \"related topics\" of this question??"
                    },
                    {
                        "username": "stonethrow-leetcode",
                        "content": "I think I've encountered the same issue reported by [@jayramesh0](/jayramesh0) on Mar 03, 2023 -- 994/994 testcases passed, yet there is a claimed time limit exceeded.\nIf I try \"Use Testcase\" to add the \"failed\" testcase to my test runs, that testcase _has no dividend or divisor_!\nThis feels like a bug in how this problem or acceptance criteria are implemented.\nIs there a way to get leetcode admins to look into this?\nOr does anyone else who's encountered this problem know what's going on or how to address it?\n\nI'm assuming that \"n/n testcases passed\" is advertised honestly, and that there are therefore no other conditions to that solution being flagged successful."
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "If I ever get this problem in an interview, I\\'ll happily shake hands with the interviewer and walk out the room.\\n"
                    },
                    {
                        "username": "phuonganhthanh1107",
                        "content": "using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace ConsoleApplication3\\n{\\n    class Program\\n    {\\n        public static void Divide(long dividend , long divisor)\\n        {\\n            if (dividend == 0 || Math.Abs(dividend) < Math.Abs(divisor))\\n            {\\n                Console.Write(0);\\n            }\\n            else \\n            {\\n                int devidend_isGreater_than_0 = 1;\\n                int divisor_isGreater_than_0 = 1;\\n                if (dividend < 0) \\n                {\\n                    dividend = dividend * (-1);\\n                    devidend_isGreater_than_0 = -1;\\n                }\\n                if (divisor < 0) \\n                {\\n                    divisor = divisor * (-1);\\n                    divisor_isGreater_than_0 = -1;\\n                }\\n\\n                long count = 0;\\n                for (long i = 0; i < long.MaxValue; i++) \\n                {\\n                    dividend = dividend - divisor;\\n                    if (dividend >= 0)\\n                    {\\n                        count++;\\n                    }\\n                    else \\n                    {\\n                        break;\\n                    }\\n                }\\n                if (devidend_isGreater_than_0 * divisor_isGreater_than_0 < 0) \\n                {\\n                    count *= -1;\\n                }\\n\\n                Console.Write(count);\\n            }\\n        }\\n        static void Main(string[] args)\\n        {\\n            string dividend, divisor;\\n            dividend = Console.ReadLine();\\n            long DIVIDEND = long.Parse(dividend);\\n\\n            long DIVISOR;\\n            do\\n            {\\n                divisor = Console.ReadLine();\\n                DIVISOR = long.Parse(divisor);\\n            } while (DIVISOR == 0);\\n\\n            Divide(DIVIDEND, DIVISOR);\\n            Console.ReadKey();\\n        }\\n    }\\n}\\n\\n\\nnot template , it used to reference \\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was always wondering about those 'smarties' who add tescases with numbers beyond the 32 bit integers range.  For what, do you wanna win the system? \nCongrats, your testcase was conditioned. \n```\n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n```\n\nLol, keep wasting your time. \n"
                    },
                    {
                        "username": "maxlee577",
                        "content": "-231/3 = -77 but according to the test case it should be 76 makes no sense"
                    }
                ]
            },
            {
                "id": 2055990,
                "content": [
                    {
                        "username": "Mlizhardy",
                        "content": "Input\\n-2147483648\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nproper output IS 2147483648"
                    },
                    {
                        "username": "shashankvashistha1",
                        "content": "gandu question dont do it here."
                    },
                    {
                        "username": "mahmoodn",
                        "content": "For -231/3 the shift algorithm (M and AQ registers) yields Q=-76 and R=-3. So \\n-76x3-3=-231\\nBut the expected output is -77."
                    },
                    {
                        "username": "rgestudillo",
                        "content": "very easy, should be easy"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Why Binary search is not in \"related topics\" of this question??"
                    },
                    {
                        "username": "stonethrow-leetcode",
                        "content": "I think I've encountered the same issue reported by [@jayramesh0](/jayramesh0) on Mar 03, 2023 -- 994/994 testcases passed, yet there is a claimed time limit exceeded.\nIf I try \"Use Testcase\" to add the \"failed\" testcase to my test runs, that testcase _has no dividend or divisor_!\nThis feels like a bug in how this problem or acceptance criteria are implemented.\nIs there a way to get leetcode admins to look into this?\nOr does anyone else who's encountered this problem know what's going on or how to address it?\n\nI'm assuming that \"n/n testcases passed\" is advertised honestly, and that there are therefore no other conditions to that solution being flagged successful."
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "If I ever get this problem in an interview, I\\'ll happily shake hands with the interviewer and walk out the room.\\n"
                    },
                    {
                        "username": "phuonganhthanh1107",
                        "content": "using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace ConsoleApplication3\\n{\\n    class Program\\n    {\\n        public static void Divide(long dividend , long divisor)\\n        {\\n            if (dividend == 0 || Math.Abs(dividend) < Math.Abs(divisor))\\n            {\\n                Console.Write(0);\\n            }\\n            else \\n            {\\n                int devidend_isGreater_than_0 = 1;\\n                int divisor_isGreater_than_0 = 1;\\n                if (dividend < 0) \\n                {\\n                    dividend = dividend * (-1);\\n                    devidend_isGreater_than_0 = -1;\\n                }\\n                if (divisor < 0) \\n                {\\n                    divisor = divisor * (-1);\\n                    divisor_isGreater_than_0 = -1;\\n                }\\n\\n                long count = 0;\\n                for (long i = 0; i < long.MaxValue; i++) \\n                {\\n                    dividend = dividend - divisor;\\n                    if (dividend >= 0)\\n                    {\\n                        count++;\\n                    }\\n                    else \\n                    {\\n                        break;\\n                    }\\n                }\\n                if (devidend_isGreater_than_0 * divisor_isGreater_than_0 < 0) \\n                {\\n                    count *= -1;\\n                }\\n\\n                Console.Write(count);\\n            }\\n        }\\n        static void Main(string[] args)\\n        {\\n            string dividend, divisor;\\n            dividend = Console.ReadLine();\\n            long DIVIDEND = long.Parse(dividend);\\n\\n            long DIVISOR;\\n            do\\n            {\\n                divisor = Console.ReadLine();\\n                DIVISOR = long.Parse(divisor);\\n            } while (DIVISOR == 0);\\n\\n            Divide(DIVIDEND, DIVISOR);\\n            Console.ReadKey();\\n        }\\n    }\\n}\\n\\n\\nnot template , it used to reference \\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was always wondering about those 'smarties' who add tescases with numbers beyond the 32 bit integers range.  For what, do you wanna win the system? \nCongrats, your testcase was conditioned. \n```\n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n```\n\nLol, keep wasting your time. \n"
                    },
                    {
                        "username": "maxlee577",
                        "content": "-231/3 = -77 but according to the test case it should be 76 makes no sense"
                    }
                ]
            },
            {
                "id": 2055445,
                "content": [
                    {
                        "username": "Mlizhardy",
                        "content": "Input\\n-2147483648\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nproper output IS 2147483648"
                    },
                    {
                        "username": "shashankvashistha1",
                        "content": "gandu question dont do it here."
                    },
                    {
                        "username": "mahmoodn",
                        "content": "For -231/3 the shift algorithm (M and AQ registers) yields Q=-76 and R=-3. So \\n-76x3-3=-231\\nBut the expected output is -77."
                    },
                    {
                        "username": "rgestudillo",
                        "content": "very easy, should be easy"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Why Binary search is not in \"related topics\" of this question??"
                    },
                    {
                        "username": "stonethrow-leetcode",
                        "content": "I think I've encountered the same issue reported by [@jayramesh0](/jayramesh0) on Mar 03, 2023 -- 994/994 testcases passed, yet there is a claimed time limit exceeded.\nIf I try \"Use Testcase\" to add the \"failed\" testcase to my test runs, that testcase _has no dividend or divisor_!\nThis feels like a bug in how this problem or acceptance criteria are implemented.\nIs there a way to get leetcode admins to look into this?\nOr does anyone else who's encountered this problem know what's going on or how to address it?\n\nI'm assuming that \"n/n testcases passed\" is advertised honestly, and that there are therefore no other conditions to that solution being flagged successful."
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "If I ever get this problem in an interview, I\\'ll happily shake hands with the interviewer and walk out the room.\\n"
                    },
                    {
                        "username": "phuonganhthanh1107",
                        "content": "using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace ConsoleApplication3\\n{\\n    class Program\\n    {\\n        public static void Divide(long dividend , long divisor)\\n        {\\n            if (dividend == 0 || Math.Abs(dividend) < Math.Abs(divisor))\\n            {\\n                Console.Write(0);\\n            }\\n            else \\n            {\\n                int devidend_isGreater_than_0 = 1;\\n                int divisor_isGreater_than_0 = 1;\\n                if (dividend < 0) \\n                {\\n                    dividend = dividend * (-1);\\n                    devidend_isGreater_than_0 = -1;\\n                }\\n                if (divisor < 0) \\n                {\\n                    divisor = divisor * (-1);\\n                    divisor_isGreater_than_0 = -1;\\n                }\\n\\n                long count = 0;\\n                for (long i = 0; i < long.MaxValue; i++) \\n                {\\n                    dividend = dividend - divisor;\\n                    if (dividend >= 0)\\n                    {\\n                        count++;\\n                    }\\n                    else \\n                    {\\n                        break;\\n                    }\\n                }\\n                if (devidend_isGreater_than_0 * divisor_isGreater_than_0 < 0) \\n                {\\n                    count *= -1;\\n                }\\n\\n                Console.Write(count);\\n            }\\n        }\\n        static void Main(string[] args)\\n        {\\n            string dividend, divisor;\\n            dividend = Console.ReadLine();\\n            long DIVIDEND = long.Parse(dividend);\\n\\n            long DIVISOR;\\n            do\\n            {\\n                divisor = Console.ReadLine();\\n                DIVISOR = long.Parse(divisor);\\n            } while (DIVISOR == 0);\\n\\n            Divide(DIVIDEND, DIVISOR);\\n            Console.ReadKey();\\n        }\\n    }\\n}\\n\\n\\nnot template , it used to reference \\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was always wondering about those 'smarties' who add tescases with numbers beyond the 32 bit integers range.  For what, do you wanna win the system? \nCongrats, your testcase was conditioned. \n```\n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n```\n\nLol, keep wasting your time. \n"
                    },
                    {
                        "username": "maxlee577",
                        "content": "-231/3 = -77 but according to the test case it should be 76 makes no sense"
                    }
                ]
            },
            {
                "id": 2050348,
                "content": [
                    {
                        "username": "Mlizhardy",
                        "content": "Input\\n-2147483648\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nproper output IS 2147483648"
                    },
                    {
                        "username": "shashankvashistha1",
                        "content": "gandu question dont do it here."
                    },
                    {
                        "username": "mahmoodn",
                        "content": "For -231/3 the shift algorithm (M and AQ registers) yields Q=-76 and R=-3. So \\n-76x3-3=-231\\nBut the expected output is -77."
                    },
                    {
                        "username": "rgestudillo",
                        "content": "very easy, should be easy"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Why Binary search is not in \"related topics\" of this question??"
                    },
                    {
                        "username": "stonethrow-leetcode",
                        "content": "I think I've encountered the same issue reported by [@jayramesh0](/jayramesh0) on Mar 03, 2023 -- 994/994 testcases passed, yet there is a claimed time limit exceeded.\nIf I try \"Use Testcase\" to add the \"failed\" testcase to my test runs, that testcase _has no dividend or divisor_!\nThis feels like a bug in how this problem or acceptance criteria are implemented.\nIs there a way to get leetcode admins to look into this?\nOr does anyone else who's encountered this problem know what's going on or how to address it?\n\nI'm assuming that \"n/n testcases passed\" is advertised honestly, and that there are therefore no other conditions to that solution being flagged successful."
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "If I ever get this problem in an interview, I\\'ll happily shake hands with the interviewer and walk out the room.\\n"
                    },
                    {
                        "username": "phuonganhthanh1107",
                        "content": "using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace ConsoleApplication3\\n{\\n    class Program\\n    {\\n        public static void Divide(long dividend , long divisor)\\n        {\\n            if (dividend == 0 || Math.Abs(dividend) < Math.Abs(divisor))\\n            {\\n                Console.Write(0);\\n            }\\n            else \\n            {\\n                int devidend_isGreater_than_0 = 1;\\n                int divisor_isGreater_than_0 = 1;\\n                if (dividend < 0) \\n                {\\n                    dividend = dividend * (-1);\\n                    devidend_isGreater_than_0 = -1;\\n                }\\n                if (divisor < 0) \\n                {\\n                    divisor = divisor * (-1);\\n                    divisor_isGreater_than_0 = -1;\\n                }\\n\\n                long count = 0;\\n                for (long i = 0; i < long.MaxValue; i++) \\n                {\\n                    dividend = dividend - divisor;\\n                    if (dividend >= 0)\\n                    {\\n                        count++;\\n                    }\\n                    else \\n                    {\\n                        break;\\n                    }\\n                }\\n                if (devidend_isGreater_than_0 * divisor_isGreater_than_0 < 0) \\n                {\\n                    count *= -1;\\n                }\\n\\n                Console.Write(count);\\n            }\\n        }\\n        static void Main(string[] args)\\n        {\\n            string dividend, divisor;\\n            dividend = Console.ReadLine();\\n            long DIVIDEND = long.Parse(dividend);\\n\\n            long DIVISOR;\\n            do\\n            {\\n                divisor = Console.ReadLine();\\n                DIVISOR = long.Parse(divisor);\\n            } while (DIVISOR == 0);\\n\\n            Divide(DIVIDEND, DIVISOR);\\n            Console.ReadKey();\\n        }\\n    }\\n}\\n\\n\\nnot template , it used to reference \\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was always wondering about those 'smarties' who add tescases with numbers beyond the 32 bit integers range.  For what, do you wanna win the system? \nCongrats, your testcase was conditioned. \n```\n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n```\n\nLol, keep wasting your time. \n"
                    },
                    {
                        "username": "maxlee577",
                        "content": "-231/3 = -77 but according to the test case it should be 76 makes no sense"
                    }
                ]
            },
            {
                "id": 2039619,
                "content": [
                    {
                        "username": "Mlizhardy",
                        "content": "Input\\n-2147483648\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nproper output IS 2147483648"
                    },
                    {
                        "username": "shashankvashistha1",
                        "content": "gandu question dont do it here."
                    },
                    {
                        "username": "mahmoodn",
                        "content": "For -231/3 the shift algorithm (M and AQ registers) yields Q=-76 and R=-3. So \\n-76x3-3=-231\\nBut the expected output is -77."
                    },
                    {
                        "username": "rgestudillo",
                        "content": "very easy, should be easy"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Why Binary search is not in \"related topics\" of this question??"
                    },
                    {
                        "username": "stonethrow-leetcode",
                        "content": "I think I've encountered the same issue reported by [@jayramesh0](/jayramesh0) on Mar 03, 2023 -- 994/994 testcases passed, yet there is a claimed time limit exceeded.\nIf I try \"Use Testcase\" to add the \"failed\" testcase to my test runs, that testcase _has no dividend or divisor_!\nThis feels like a bug in how this problem or acceptance criteria are implemented.\nIs there a way to get leetcode admins to look into this?\nOr does anyone else who's encountered this problem know what's going on or how to address it?\n\nI'm assuming that \"n/n testcases passed\" is advertised honestly, and that there are therefore no other conditions to that solution being flagged successful."
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "If I ever get this problem in an interview, I\\'ll happily shake hands with the interviewer and walk out the room.\\n"
                    },
                    {
                        "username": "phuonganhthanh1107",
                        "content": "using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace ConsoleApplication3\\n{\\n    class Program\\n    {\\n        public static void Divide(long dividend , long divisor)\\n        {\\n            if (dividend == 0 || Math.Abs(dividend) < Math.Abs(divisor))\\n            {\\n                Console.Write(0);\\n            }\\n            else \\n            {\\n                int devidend_isGreater_than_0 = 1;\\n                int divisor_isGreater_than_0 = 1;\\n                if (dividend < 0) \\n                {\\n                    dividend = dividend * (-1);\\n                    devidend_isGreater_than_0 = -1;\\n                }\\n                if (divisor < 0) \\n                {\\n                    divisor = divisor * (-1);\\n                    divisor_isGreater_than_0 = -1;\\n                }\\n\\n                long count = 0;\\n                for (long i = 0; i < long.MaxValue; i++) \\n                {\\n                    dividend = dividend - divisor;\\n                    if (dividend >= 0)\\n                    {\\n                        count++;\\n                    }\\n                    else \\n                    {\\n                        break;\\n                    }\\n                }\\n                if (devidend_isGreater_than_0 * divisor_isGreater_than_0 < 0) \\n                {\\n                    count *= -1;\\n                }\\n\\n                Console.Write(count);\\n            }\\n        }\\n        static void Main(string[] args)\\n        {\\n            string dividend, divisor;\\n            dividend = Console.ReadLine();\\n            long DIVIDEND = long.Parse(dividend);\\n\\n            long DIVISOR;\\n            do\\n            {\\n                divisor = Console.ReadLine();\\n                DIVISOR = long.Parse(divisor);\\n            } while (DIVISOR == 0);\\n\\n            Divide(DIVIDEND, DIVISOR);\\n            Console.ReadKey();\\n        }\\n    }\\n}\\n\\n\\nnot template , it used to reference \\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was always wondering about those 'smarties' who add tescases with numbers beyond the 32 bit integers range.  For what, do you wanna win the system? \nCongrats, your testcase was conditioned. \n```\n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n```\n\nLol, keep wasting your time. \n"
                    },
                    {
                        "username": "maxlee577",
                        "content": "-231/3 = -77 but according to the test case it should be 76 makes no sense"
                    }
                ]
            },
            {
                "id": 2026681,
                "content": [
                    {
                        "username": "Mlizhardy",
                        "content": "Input\\n-2147483648\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nproper output IS 2147483648"
                    },
                    {
                        "username": "shashankvashistha1",
                        "content": "gandu question dont do it here."
                    },
                    {
                        "username": "mahmoodn",
                        "content": "For -231/3 the shift algorithm (M and AQ registers) yields Q=-76 and R=-3. So \\n-76x3-3=-231\\nBut the expected output is -77."
                    },
                    {
                        "username": "rgestudillo",
                        "content": "very easy, should be easy"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Why Binary search is not in \"related topics\" of this question??"
                    },
                    {
                        "username": "stonethrow-leetcode",
                        "content": "I think I've encountered the same issue reported by [@jayramesh0](/jayramesh0) on Mar 03, 2023 -- 994/994 testcases passed, yet there is a claimed time limit exceeded.\nIf I try \"Use Testcase\" to add the \"failed\" testcase to my test runs, that testcase _has no dividend or divisor_!\nThis feels like a bug in how this problem or acceptance criteria are implemented.\nIs there a way to get leetcode admins to look into this?\nOr does anyone else who's encountered this problem know what's going on or how to address it?\n\nI'm assuming that \"n/n testcases passed\" is advertised honestly, and that there are therefore no other conditions to that solution being flagged successful."
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "If I ever get this problem in an interview, I\\'ll happily shake hands with the interviewer and walk out the room.\\n"
                    },
                    {
                        "username": "phuonganhthanh1107",
                        "content": "using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace ConsoleApplication3\\n{\\n    class Program\\n    {\\n        public static void Divide(long dividend , long divisor)\\n        {\\n            if (dividend == 0 || Math.Abs(dividend) < Math.Abs(divisor))\\n            {\\n                Console.Write(0);\\n            }\\n            else \\n            {\\n                int devidend_isGreater_than_0 = 1;\\n                int divisor_isGreater_than_0 = 1;\\n                if (dividend < 0) \\n                {\\n                    dividend = dividend * (-1);\\n                    devidend_isGreater_than_0 = -1;\\n                }\\n                if (divisor < 0) \\n                {\\n                    divisor = divisor * (-1);\\n                    divisor_isGreater_than_0 = -1;\\n                }\\n\\n                long count = 0;\\n                for (long i = 0; i < long.MaxValue; i++) \\n                {\\n                    dividend = dividend - divisor;\\n                    if (dividend >= 0)\\n                    {\\n                        count++;\\n                    }\\n                    else \\n                    {\\n                        break;\\n                    }\\n                }\\n                if (devidend_isGreater_than_0 * divisor_isGreater_than_0 < 0) \\n                {\\n                    count *= -1;\\n                }\\n\\n                Console.Write(count);\\n            }\\n        }\\n        static void Main(string[] args)\\n        {\\n            string dividend, divisor;\\n            dividend = Console.ReadLine();\\n            long DIVIDEND = long.Parse(dividend);\\n\\n            long DIVISOR;\\n            do\\n            {\\n                divisor = Console.ReadLine();\\n                DIVISOR = long.Parse(divisor);\\n            } while (DIVISOR == 0);\\n\\n            Divide(DIVIDEND, DIVISOR);\\n            Console.ReadKey();\\n        }\\n    }\\n}\\n\\n\\nnot template , it used to reference \\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was always wondering about those 'smarties' who add tescases with numbers beyond the 32 bit integers range.  For what, do you wanna win the system? \nCongrats, your testcase was conditioned. \n```\n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n```\n\nLol, keep wasting your time. \n"
                    },
                    {
                        "username": "maxlee577",
                        "content": "-231/3 = -77 but according to the test case it should be 76 makes no sense"
                    }
                ]
            },
            {
                "id": 1996576,
                "content": [
                    {
                        "username": "Mlizhardy",
                        "content": "Input\\n-2147483648\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nproper output IS 2147483648"
                    },
                    {
                        "username": "shashankvashistha1",
                        "content": "gandu question dont do it here."
                    },
                    {
                        "username": "mahmoodn",
                        "content": "For -231/3 the shift algorithm (M and AQ registers) yields Q=-76 and R=-3. So \\n-76x3-3=-231\\nBut the expected output is -77."
                    },
                    {
                        "username": "rgestudillo",
                        "content": "very easy, should be easy"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Why Binary search is not in \"related topics\" of this question??"
                    },
                    {
                        "username": "stonethrow-leetcode",
                        "content": "I think I've encountered the same issue reported by [@jayramesh0](/jayramesh0) on Mar 03, 2023 -- 994/994 testcases passed, yet there is a claimed time limit exceeded.\nIf I try \"Use Testcase\" to add the \"failed\" testcase to my test runs, that testcase _has no dividend or divisor_!\nThis feels like a bug in how this problem or acceptance criteria are implemented.\nIs there a way to get leetcode admins to look into this?\nOr does anyone else who's encountered this problem know what's going on or how to address it?\n\nI'm assuming that \"n/n testcases passed\" is advertised honestly, and that there are therefore no other conditions to that solution being flagged successful."
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "If I ever get this problem in an interview, I\\'ll happily shake hands with the interviewer and walk out the room.\\n"
                    },
                    {
                        "username": "phuonganhthanh1107",
                        "content": "using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace ConsoleApplication3\\n{\\n    class Program\\n    {\\n        public static void Divide(long dividend , long divisor)\\n        {\\n            if (dividend == 0 || Math.Abs(dividend) < Math.Abs(divisor))\\n            {\\n                Console.Write(0);\\n            }\\n            else \\n            {\\n                int devidend_isGreater_than_0 = 1;\\n                int divisor_isGreater_than_0 = 1;\\n                if (dividend < 0) \\n                {\\n                    dividend = dividend * (-1);\\n                    devidend_isGreater_than_0 = -1;\\n                }\\n                if (divisor < 0) \\n                {\\n                    divisor = divisor * (-1);\\n                    divisor_isGreater_than_0 = -1;\\n                }\\n\\n                long count = 0;\\n                for (long i = 0; i < long.MaxValue; i++) \\n                {\\n                    dividend = dividend - divisor;\\n                    if (dividend >= 0)\\n                    {\\n                        count++;\\n                    }\\n                    else \\n                    {\\n                        break;\\n                    }\\n                }\\n                if (devidend_isGreater_than_0 * divisor_isGreater_than_0 < 0) \\n                {\\n                    count *= -1;\\n                }\\n\\n                Console.Write(count);\\n            }\\n        }\\n        static void Main(string[] args)\\n        {\\n            string dividend, divisor;\\n            dividend = Console.ReadLine();\\n            long DIVIDEND = long.Parse(dividend);\\n\\n            long DIVISOR;\\n            do\\n            {\\n                divisor = Console.ReadLine();\\n                DIVISOR = long.Parse(divisor);\\n            } while (DIVISOR == 0);\\n\\n            Divide(DIVIDEND, DIVISOR);\\n            Console.ReadKey();\\n        }\\n    }\\n}\\n\\n\\nnot template , it used to reference \\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was always wondering about those 'smarties' who add tescases with numbers beyond the 32 bit integers range.  For what, do you wanna win the system? \nCongrats, your testcase was conditioned. \n```\n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n```\n\nLol, keep wasting your time. \n"
                    },
                    {
                        "username": "maxlee577",
                        "content": "-231/3 = -77 but according to the test case it should be 76 makes no sense"
                    }
                ]
            },
            {
                "id": 1976165,
                "content": [
                    {
                        "username": "Mlizhardy",
                        "content": "Input\\n-2147483648\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nproper output IS 2147483648"
                    },
                    {
                        "username": "shashankvashistha1",
                        "content": "gandu question dont do it here."
                    },
                    {
                        "username": "mahmoodn",
                        "content": "For -231/3 the shift algorithm (M and AQ registers) yields Q=-76 and R=-3. So \\n-76x3-3=-231\\nBut the expected output is -77."
                    },
                    {
                        "username": "rgestudillo",
                        "content": "very easy, should be easy"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Why Binary search is not in \"related topics\" of this question??"
                    },
                    {
                        "username": "stonethrow-leetcode",
                        "content": "I think I've encountered the same issue reported by [@jayramesh0](/jayramesh0) on Mar 03, 2023 -- 994/994 testcases passed, yet there is a claimed time limit exceeded.\nIf I try \"Use Testcase\" to add the \"failed\" testcase to my test runs, that testcase _has no dividend or divisor_!\nThis feels like a bug in how this problem or acceptance criteria are implemented.\nIs there a way to get leetcode admins to look into this?\nOr does anyone else who's encountered this problem know what's going on or how to address it?\n\nI'm assuming that \"n/n testcases passed\" is advertised honestly, and that there are therefore no other conditions to that solution being flagged successful."
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "If I ever get this problem in an interview, I\\'ll happily shake hands with the interviewer and walk out the room.\\n"
                    },
                    {
                        "username": "phuonganhthanh1107",
                        "content": "using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace ConsoleApplication3\\n{\\n    class Program\\n    {\\n        public static void Divide(long dividend , long divisor)\\n        {\\n            if (dividend == 0 || Math.Abs(dividend) < Math.Abs(divisor))\\n            {\\n                Console.Write(0);\\n            }\\n            else \\n            {\\n                int devidend_isGreater_than_0 = 1;\\n                int divisor_isGreater_than_0 = 1;\\n                if (dividend < 0) \\n                {\\n                    dividend = dividend * (-1);\\n                    devidend_isGreater_than_0 = -1;\\n                }\\n                if (divisor < 0) \\n                {\\n                    divisor = divisor * (-1);\\n                    divisor_isGreater_than_0 = -1;\\n                }\\n\\n                long count = 0;\\n                for (long i = 0; i < long.MaxValue; i++) \\n                {\\n                    dividend = dividend - divisor;\\n                    if (dividend >= 0)\\n                    {\\n                        count++;\\n                    }\\n                    else \\n                    {\\n                        break;\\n                    }\\n                }\\n                if (devidend_isGreater_than_0 * divisor_isGreater_than_0 < 0) \\n                {\\n                    count *= -1;\\n                }\\n\\n                Console.Write(count);\\n            }\\n        }\\n        static void Main(string[] args)\\n        {\\n            string dividend, divisor;\\n            dividend = Console.ReadLine();\\n            long DIVIDEND = long.Parse(dividend);\\n\\n            long DIVISOR;\\n            do\\n            {\\n                divisor = Console.ReadLine();\\n                DIVISOR = long.Parse(divisor);\\n            } while (DIVISOR == 0);\\n\\n            Divide(DIVIDEND, DIVISOR);\\n            Console.ReadKey();\\n        }\\n    }\\n}\\n\\n\\nnot template , it used to reference \\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was always wondering about those 'smarties' who add tescases with numbers beyond the 32 bit integers range.  For what, do you wanna win the system? \nCongrats, your testcase was conditioned. \n```\n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n```\n\nLol, keep wasting your time. \n"
                    },
                    {
                        "username": "maxlee577",
                        "content": "-231/3 = -77 but according to the test case it should be 76 makes no sense"
                    }
                ]
            },
            {
                "id": 1975112,
                "content": [
                    {
                        "username": "Mlizhardy",
                        "content": "Input\\n-2147483648\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nproper output IS 2147483648"
                    },
                    {
                        "username": "shashankvashistha1",
                        "content": "gandu question dont do it here."
                    },
                    {
                        "username": "mahmoodn",
                        "content": "For -231/3 the shift algorithm (M and AQ registers) yields Q=-76 and R=-3. So \\n-76x3-3=-231\\nBut the expected output is -77."
                    },
                    {
                        "username": "rgestudillo",
                        "content": "very easy, should be easy"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Why Binary search is not in \"related topics\" of this question??"
                    },
                    {
                        "username": "stonethrow-leetcode",
                        "content": "I think I've encountered the same issue reported by [@jayramesh0](/jayramesh0) on Mar 03, 2023 -- 994/994 testcases passed, yet there is a claimed time limit exceeded.\nIf I try \"Use Testcase\" to add the \"failed\" testcase to my test runs, that testcase _has no dividend or divisor_!\nThis feels like a bug in how this problem or acceptance criteria are implemented.\nIs there a way to get leetcode admins to look into this?\nOr does anyone else who's encountered this problem know what's going on or how to address it?\n\nI'm assuming that \"n/n testcases passed\" is advertised honestly, and that there are therefore no other conditions to that solution being flagged successful."
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "If I ever get this problem in an interview, I\\'ll happily shake hands with the interviewer and walk out the room.\\n"
                    },
                    {
                        "username": "phuonganhthanh1107",
                        "content": "using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace ConsoleApplication3\\n{\\n    class Program\\n    {\\n        public static void Divide(long dividend , long divisor)\\n        {\\n            if (dividend == 0 || Math.Abs(dividend) < Math.Abs(divisor))\\n            {\\n                Console.Write(0);\\n            }\\n            else \\n            {\\n                int devidend_isGreater_than_0 = 1;\\n                int divisor_isGreater_than_0 = 1;\\n                if (dividend < 0) \\n                {\\n                    dividend = dividend * (-1);\\n                    devidend_isGreater_than_0 = -1;\\n                }\\n                if (divisor < 0) \\n                {\\n                    divisor = divisor * (-1);\\n                    divisor_isGreater_than_0 = -1;\\n                }\\n\\n                long count = 0;\\n                for (long i = 0; i < long.MaxValue; i++) \\n                {\\n                    dividend = dividend - divisor;\\n                    if (dividend >= 0)\\n                    {\\n                        count++;\\n                    }\\n                    else \\n                    {\\n                        break;\\n                    }\\n                }\\n                if (devidend_isGreater_than_0 * divisor_isGreater_than_0 < 0) \\n                {\\n                    count *= -1;\\n                }\\n\\n                Console.Write(count);\\n            }\\n        }\\n        static void Main(string[] args)\\n        {\\n            string dividend, divisor;\\n            dividend = Console.ReadLine();\\n            long DIVIDEND = long.Parse(dividend);\\n\\n            long DIVISOR;\\n            do\\n            {\\n                divisor = Console.ReadLine();\\n                DIVISOR = long.Parse(divisor);\\n            } while (DIVISOR == 0);\\n\\n            Divide(DIVIDEND, DIVISOR);\\n            Console.ReadKey();\\n        }\\n    }\\n}\\n\\n\\nnot template , it used to reference \\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was always wondering about those 'smarties' who add tescases with numbers beyond the 32 bit integers range.  For what, do you wanna win the system? \nCongrats, your testcase was conditioned. \n```\n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n```\n\nLol, keep wasting your time. \n"
                    },
                    {
                        "username": "maxlee577",
                        "content": "-231/3 = -77 but according to the test case it should be 76 makes no sense"
                    }
                ]
            },
            {
                "id": 1966655,
                "content": [
                    {
                        "username": "ankith_t22",
                        "content": "How do we account for when the divisor is 0? I do not know what to return then."
                    },
                    {
                        "username": "raflyirham",
                        "content": "Constraint: divisor != 0\\n\\nMeaning that the value of the divisor will never be 0."
                    },
                    {
                        "username": "Pratish10",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIn the above case we can se that dividend has the minimum value and divisor is -1 and the expected output is max value\\n\\nSo handle this error properly\\n1. Check that dividend contains minimum value and divisor is -1 then return the max value\\n2. Check that dividend contains minimum value and divisor is 1 then return min value\\n\\nHit like if it helps you"
                    },
                    {
                        "username": "Saitama109",
                        "content": "bro INT_MIN with some Random Integer is just not possible without using long.... its just too hard for me in int32...cause it overflows every damn second..\\n"
                    },
                    {
                        "username": "awesomeRj01",
                        "content": "what to do when 994/994 testcases passed and it shows TLE"
                    },
                    {
                        "username": "illay8",
                        "content": "rule no 1, it should not use multiplication, division, and mod operator. When I tried a solution that uses division on Solution tab , it can be summited. What a rubbish"
                    },
                    {
                        "username": "aj24197",
                        "content": "can we solve this question by bit manipulations"
                    },
                    {
                        "username": "rajshish333",
                        "content": "my all answer is correct but 1/2 is showing result 1 why ?\\n"
                    },
                    {
                        "username": "talhasebtian",
                        "content": "Here\\'s an example code in Python that performs integer division without using multiplication, division, and mod operator:\\n\\npython\\ndef divide(dividend, divisor):\\n# Handle the case when the dividend is 0\\nif dividend == 0:\\nreturn 0\\n\\n# Handle the case when the divisor is 0\\nif divisor == 0:\\n    raise ZeroDivisionError(\"Cannot divide by zero\")\\n\\n# Handle the case when the dividend and divisor are the same\\nif dividend == divisor:\\n    return 1\\n\\n# Handle the case when the dividend is the minimum value and the divisor is -1\\nif dividend == -2**31 and divisor == -1:\\n    return 2**31 - 1\\n\\n# Determine the sign of the quotient\\nnegative = (dividend < 0) ^ (divisor < 0)\\n\\n# Convert both dividend and divisor to positive\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\n\\n# Initialize the quotient\\nquotient = 0\\n\\n# Keep subtracting the divisor from the dividend until the dividend becomes smaller than the divisor\\nwhile dividend >= divisor:\\n    # Subtract the divisor from the dividend\\n    dividend -= divisor\\n    # Increment the quotient by 1\\n    quotient += 1\\n\\n# Apply the sign to the quotient\\nif negative:\\n    quotient = -quotient\\n\\nreturn quotient\\nExample usage:\\ndividend = 10\\ndivisor = 3\\nresult = divide(dividend, divisor)\\nprint(result)\\nThe code handles several special cases such as when the dividend is 0, the divisor is 0, or the dividend is the minimum value and the divisor is -1. It determines the sign of the quotient and converts both the dividend and divisor to positive values, pintdd.com. Then, it repeatedly subtracts the divisor from the dividend and increments the quotient until the dividend becomes smaller than the divisor. Finally, it applies the sign to the quotient and returns the result.\\n\\nIn the example usage, the code is called with dividend = 10 and divisor = 3. The result is then printed, which will be 3, representing the quotient after dividing the dividend by the divisor."
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "cannot complete this task because of shitty testcase:\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nwhaaa? -2147483648 / -1 must be 2147483647 ? really ?"
                    },
                    {
                        "username": "Fandrir",
                        "content": "It must be 2147483647, because 2147483648 would be an int overflow. The largest allowed absolute value for negative numbers is one larger than the largest allowed value for positive numbers. Therefore this falls under the requirement that everything above 2147483647 has to return 2147483647. \\nBasically all this task is, is to account for these weird int rules and exceptions."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "to solve this problem, you just need some basic school math and type casting."
                    }
                ]
            },
            {
                "id": 1966415,
                "content": [
                    {
                        "username": "ankith_t22",
                        "content": "How do we account for when the divisor is 0? I do not know what to return then."
                    },
                    {
                        "username": "raflyirham",
                        "content": "Constraint: divisor != 0\\n\\nMeaning that the value of the divisor will never be 0."
                    },
                    {
                        "username": "Pratish10",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIn the above case we can se that dividend has the minimum value and divisor is -1 and the expected output is max value\\n\\nSo handle this error properly\\n1. Check that dividend contains minimum value and divisor is -1 then return the max value\\n2. Check that dividend contains minimum value and divisor is 1 then return min value\\n\\nHit like if it helps you"
                    },
                    {
                        "username": "Saitama109",
                        "content": "bro INT_MIN with some Random Integer is just not possible without using long.... its just too hard for me in int32...cause it overflows every damn second..\\n"
                    },
                    {
                        "username": "awesomeRj01",
                        "content": "what to do when 994/994 testcases passed and it shows TLE"
                    },
                    {
                        "username": "illay8",
                        "content": "rule no 1, it should not use multiplication, division, and mod operator. When I tried a solution that uses division on Solution tab , it can be summited. What a rubbish"
                    },
                    {
                        "username": "aj24197",
                        "content": "can we solve this question by bit manipulations"
                    },
                    {
                        "username": "rajshish333",
                        "content": "my all answer is correct but 1/2 is showing result 1 why ?\\n"
                    },
                    {
                        "username": "talhasebtian",
                        "content": "Here\\'s an example code in Python that performs integer division without using multiplication, division, and mod operator:\\n\\npython\\ndef divide(dividend, divisor):\\n# Handle the case when the dividend is 0\\nif dividend == 0:\\nreturn 0\\n\\n# Handle the case when the divisor is 0\\nif divisor == 0:\\n    raise ZeroDivisionError(\"Cannot divide by zero\")\\n\\n# Handle the case when the dividend and divisor are the same\\nif dividend == divisor:\\n    return 1\\n\\n# Handle the case when the dividend is the minimum value and the divisor is -1\\nif dividend == -2**31 and divisor == -1:\\n    return 2**31 - 1\\n\\n# Determine the sign of the quotient\\nnegative = (dividend < 0) ^ (divisor < 0)\\n\\n# Convert both dividend and divisor to positive\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\n\\n# Initialize the quotient\\nquotient = 0\\n\\n# Keep subtracting the divisor from the dividend until the dividend becomes smaller than the divisor\\nwhile dividend >= divisor:\\n    # Subtract the divisor from the dividend\\n    dividend -= divisor\\n    # Increment the quotient by 1\\n    quotient += 1\\n\\n# Apply the sign to the quotient\\nif negative:\\n    quotient = -quotient\\n\\nreturn quotient\\nExample usage:\\ndividend = 10\\ndivisor = 3\\nresult = divide(dividend, divisor)\\nprint(result)\\nThe code handles several special cases such as when the dividend is 0, the divisor is 0, or the dividend is the minimum value and the divisor is -1. It determines the sign of the quotient and converts both the dividend and divisor to positive values, pintdd.com. Then, it repeatedly subtracts the divisor from the dividend and increments the quotient until the dividend becomes smaller than the divisor. Finally, it applies the sign to the quotient and returns the result.\\n\\nIn the example usage, the code is called with dividend = 10 and divisor = 3. The result is then printed, which will be 3, representing the quotient after dividing the dividend by the divisor."
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "cannot complete this task because of shitty testcase:\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nwhaaa? -2147483648 / -1 must be 2147483647 ? really ?"
                    },
                    {
                        "username": "Fandrir",
                        "content": "It must be 2147483647, because 2147483648 would be an int overflow. The largest allowed absolute value for negative numbers is one larger than the largest allowed value for positive numbers. Therefore this falls under the requirement that everything above 2147483647 has to return 2147483647. \\nBasically all this task is, is to account for these weird int rules and exceptions."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "to solve this problem, you just need some basic school math and type casting."
                    }
                ]
            },
            {
                "id": 1956654,
                "content": [
                    {
                        "username": "ankith_t22",
                        "content": "How do we account for when the divisor is 0? I do not know what to return then."
                    },
                    {
                        "username": "raflyirham",
                        "content": "Constraint: divisor != 0\\n\\nMeaning that the value of the divisor will never be 0."
                    },
                    {
                        "username": "Pratish10",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIn the above case we can se that dividend has the minimum value and divisor is -1 and the expected output is max value\\n\\nSo handle this error properly\\n1. Check that dividend contains minimum value and divisor is -1 then return the max value\\n2. Check that dividend contains minimum value and divisor is 1 then return min value\\n\\nHit like if it helps you"
                    },
                    {
                        "username": "Saitama109",
                        "content": "bro INT_MIN with some Random Integer is just not possible without using long.... its just too hard for me in int32...cause it overflows every damn second..\\n"
                    },
                    {
                        "username": "awesomeRj01",
                        "content": "what to do when 994/994 testcases passed and it shows TLE"
                    },
                    {
                        "username": "illay8",
                        "content": "rule no 1, it should not use multiplication, division, and mod operator. When I tried a solution that uses division on Solution tab , it can be summited. What a rubbish"
                    },
                    {
                        "username": "aj24197",
                        "content": "can we solve this question by bit manipulations"
                    },
                    {
                        "username": "rajshish333",
                        "content": "my all answer is correct but 1/2 is showing result 1 why ?\\n"
                    },
                    {
                        "username": "talhasebtian",
                        "content": "Here\\'s an example code in Python that performs integer division without using multiplication, division, and mod operator:\\n\\npython\\ndef divide(dividend, divisor):\\n# Handle the case when the dividend is 0\\nif dividend == 0:\\nreturn 0\\n\\n# Handle the case when the divisor is 0\\nif divisor == 0:\\n    raise ZeroDivisionError(\"Cannot divide by zero\")\\n\\n# Handle the case when the dividend and divisor are the same\\nif dividend == divisor:\\n    return 1\\n\\n# Handle the case when the dividend is the minimum value and the divisor is -1\\nif dividend == -2**31 and divisor == -1:\\n    return 2**31 - 1\\n\\n# Determine the sign of the quotient\\nnegative = (dividend < 0) ^ (divisor < 0)\\n\\n# Convert both dividend and divisor to positive\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\n\\n# Initialize the quotient\\nquotient = 0\\n\\n# Keep subtracting the divisor from the dividend until the dividend becomes smaller than the divisor\\nwhile dividend >= divisor:\\n    # Subtract the divisor from the dividend\\n    dividend -= divisor\\n    # Increment the quotient by 1\\n    quotient += 1\\n\\n# Apply the sign to the quotient\\nif negative:\\n    quotient = -quotient\\n\\nreturn quotient\\nExample usage:\\ndividend = 10\\ndivisor = 3\\nresult = divide(dividend, divisor)\\nprint(result)\\nThe code handles several special cases such as when the dividend is 0, the divisor is 0, or the dividend is the minimum value and the divisor is -1. It determines the sign of the quotient and converts both the dividend and divisor to positive values, pintdd.com. Then, it repeatedly subtracts the divisor from the dividend and increments the quotient until the dividend becomes smaller than the divisor. Finally, it applies the sign to the quotient and returns the result.\\n\\nIn the example usage, the code is called with dividend = 10 and divisor = 3. The result is then printed, which will be 3, representing the quotient after dividing the dividend by the divisor."
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "cannot complete this task because of shitty testcase:\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nwhaaa? -2147483648 / -1 must be 2147483647 ? really ?"
                    },
                    {
                        "username": "Fandrir",
                        "content": "It must be 2147483647, because 2147483648 would be an int overflow. The largest allowed absolute value for negative numbers is one larger than the largest allowed value for positive numbers. Therefore this falls under the requirement that everything above 2147483647 has to return 2147483647. \\nBasically all this task is, is to account for these weird int rules and exceptions."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "to solve this problem, you just need some basic school math and type casting."
                    }
                ]
            },
            {
                "id": 1951407,
                "content": [
                    {
                        "username": "ankith_t22",
                        "content": "How do we account for when the divisor is 0? I do not know what to return then."
                    },
                    {
                        "username": "raflyirham",
                        "content": "Constraint: divisor != 0\\n\\nMeaning that the value of the divisor will never be 0."
                    },
                    {
                        "username": "Pratish10",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIn the above case we can se that dividend has the minimum value and divisor is -1 and the expected output is max value\\n\\nSo handle this error properly\\n1. Check that dividend contains minimum value and divisor is -1 then return the max value\\n2. Check that dividend contains minimum value and divisor is 1 then return min value\\n\\nHit like if it helps you"
                    },
                    {
                        "username": "Saitama109",
                        "content": "bro INT_MIN with some Random Integer is just not possible without using long.... its just too hard for me in int32...cause it overflows every damn second..\\n"
                    },
                    {
                        "username": "awesomeRj01",
                        "content": "what to do when 994/994 testcases passed and it shows TLE"
                    },
                    {
                        "username": "illay8",
                        "content": "rule no 1, it should not use multiplication, division, and mod operator. When I tried a solution that uses division on Solution tab , it can be summited. What a rubbish"
                    },
                    {
                        "username": "aj24197",
                        "content": "can we solve this question by bit manipulations"
                    },
                    {
                        "username": "rajshish333",
                        "content": "my all answer is correct but 1/2 is showing result 1 why ?\\n"
                    },
                    {
                        "username": "talhasebtian",
                        "content": "Here\\'s an example code in Python that performs integer division without using multiplication, division, and mod operator:\\n\\npython\\ndef divide(dividend, divisor):\\n# Handle the case when the dividend is 0\\nif dividend == 0:\\nreturn 0\\n\\n# Handle the case when the divisor is 0\\nif divisor == 0:\\n    raise ZeroDivisionError(\"Cannot divide by zero\")\\n\\n# Handle the case when the dividend and divisor are the same\\nif dividend == divisor:\\n    return 1\\n\\n# Handle the case when the dividend is the minimum value and the divisor is -1\\nif dividend == -2**31 and divisor == -1:\\n    return 2**31 - 1\\n\\n# Determine the sign of the quotient\\nnegative = (dividend < 0) ^ (divisor < 0)\\n\\n# Convert both dividend and divisor to positive\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\n\\n# Initialize the quotient\\nquotient = 0\\n\\n# Keep subtracting the divisor from the dividend until the dividend becomes smaller than the divisor\\nwhile dividend >= divisor:\\n    # Subtract the divisor from the dividend\\n    dividend -= divisor\\n    # Increment the quotient by 1\\n    quotient += 1\\n\\n# Apply the sign to the quotient\\nif negative:\\n    quotient = -quotient\\n\\nreturn quotient\\nExample usage:\\ndividend = 10\\ndivisor = 3\\nresult = divide(dividend, divisor)\\nprint(result)\\nThe code handles several special cases such as when the dividend is 0, the divisor is 0, or the dividend is the minimum value and the divisor is -1. It determines the sign of the quotient and converts both the dividend and divisor to positive values, pintdd.com. Then, it repeatedly subtracts the divisor from the dividend and increments the quotient until the dividend becomes smaller than the divisor. Finally, it applies the sign to the quotient and returns the result.\\n\\nIn the example usage, the code is called with dividend = 10 and divisor = 3. The result is then printed, which will be 3, representing the quotient after dividing the dividend by the divisor."
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "cannot complete this task because of shitty testcase:\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nwhaaa? -2147483648 / -1 must be 2147483647 ? really ?"
                    },
                    {
                        "username": "Fandrir",
                        "content": "It must be 2147483647, because 2147483648 would be an int overflow. The largest allowed absolute value for negative numbers is one larger than the largest allowed value for positive numbers. Therefore this falls under the requirement that everything above 2147483647 has to return 2147483647. \\nBasically all this task is, is to account for these weird int rules and exceptions."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "to solve this problem, you just need some basic school math and type casting."
                    }
                ]
            },
            {
                "id": 1950343,
                "content": [
                    {
                        "username": "ankith_t22",
                        "content": "How do we account for when the divisor is 0? I do not know what to return then."
                    },
                    {
                        "username": "raflyirham",
                        "content": "Constraint: divisor != 0\\n\\nMeaning that the value of the divisor will never be 0."
                    },
                    {
                        "username": "Pratish10",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIn the above case we can se that dividend has the minimum value and divisor is -1 and the expected output is max value\\n\\nSo handle this error properly\\n1. Check that dividend contains minimum value and divisor is -1 then return the max value\\n2. Check that dividend contains minimum value and divisor is 1 then return min value\\n\\nHit like if it helps you"
                    },
                    {
                        "username": "Saitama109",
                        "content": "bro INT_MIN with some Random Integer is just not possible without using long.... its just too hard for me in int32...cause it overflows every damn second..\\n"
                    },
                    {
                        "username": "awesomeRj01",
                        "content": "what to do when 994/994 testcases passed and it shows TLE"
                    },
                    {
                        "username": "illay8",
                        "content": "rule no 1, it should not use multiplication, division, and mod operator. When I tried a solution that uses division on Solution tab , it can be summited. What a rubbish"
                    },
                    {
                        "username": "aj24197",
                        "content": "can we solve this question by bit manipulations"
                    },
                    {
                        "username": "rajshish333",
                        "content": "my all answer is correct but 1/2 is showing result 1 why ?\\n"
                    },
                    {
                        "username": "talhasebtian",
                        "content": "Here\\'s an example code in Python that performs integer division without using multiplication, division, and mod operator:\\n\\npython\\ndef divide(dividend, divisor):\\n# Handle the case when the dividend is 0\\nif dividend == 0:\\nreturn 0\\n\\n# Handle the case when the divisor is 0\\nif divisor == 0:\\n    raise ZeroDivisionError(\"Cannot divide by zero\")\\n\\n# Handle the case when the dividend and divisor are the same\\nif dividend == divisor:\\n    return 1\\n\\n# Handle the case when the dividend is the minimum value and the divisor is -1\\nif dividend == -2**31 and divisor == -1:\\n    return 2**31 - 1\\n\\n# Determine the sign of the quotient\\nnegative = (dividend < 0) ^ (divisor < 0)\\n\\n# Convert both dividend and divisor to positive\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\n\\n# Initialize the quotient\\nquotient = 0\\n\\n# Keep subtracting the divisor from the dividend until the dividend becomes smaller than the divisor\\nwhile dividend >= divisor:\\n    # Subtract the divisor from the dividend\\n    dividend -= divisor\\n    # Increment the quotient by 1\\n    quotient += 1\\n\\n# Apply the sign to the quotient\\nif negative:\\n    quotient = -quotient\\n\\nreturn quotient\\nExample usage:\\ndividend = 10\\ndivisor = 3\\nresult = divide(dividend, divisor)\\nprint(result)\\nThe code handles several special cases such as when the dividend is 0, the divisor is 0, or the dividend is the minimum value and the divisor is -1. It determines the sign of the quotient and converts both the dividend and divisor to positive values, pintdd.com. Then, it repeatedly subtracts the divisor from the dividend and increments the quotient until the dividend becomes smaller than the divisor. Finally, it applies the sign to the quotient and returns the result.\\n\\nIn the example usage, the code is called with dividend = 10 and divisor = 3. The result is then printed, which will be 3, representing the quotient after dividing the dividend by the divisor."
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "cannot complete this task because of shitty testcase:\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nwhaaa? -2147483648 / -1 must be 2147483647 ? really ?"
                    },
                    {
                        "username": "Fandrir",
                        "content": "It must be 2147483647, because 2147483648 would be an int overflow. The largest allowed absolute value for negative numbers is one larger than the largest allowed value for positive numbers. Therefore this falls under the requirement that everything above 2147483647 has to return 2147483647. \\nBasically all this task is, is to account for these weird int rules and exceptions."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "to solve this problem, you just need some basic school math and type casting."
                    }
                ]
            },
            {
                "id": 1944023,
                "content": [
                    {
                        "username": "ankith_t22",
                        "content": "How do we account for when the divisor is 0? I do not know what to return then."
                    },
                    {
                        "username": "raflyirham",
                        "content": "Constraint: divisor != 0\\n\\nMeaning that the value of the divisor will never be 0."
                    },
                    {
                        "username": "Pratish10",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIn the above case we can se that dividend has the minimum value and divisor is -1 and the expected output is max value\\n\\nSo handle this error properly\\n1. Check that dividend contains minimum value and divisor is -1 then return the max value\\n2. Check that dividend contains minimum value and divisor is 1 then return min value\\n\\nHit like if it helps you"
                    },
                    {
                        "username": "Saitama109",
                        "content": "bro INT_MIN with some Random Integer is just not possible without using long.... its just too hard for me in int32...cause it overflows every damn second..\\n"
                    },
                    {
                        "username": "awesomeRj01",
                        "content": "what to do when 994/994 testcases passed and it shows TLE"
                    },
                    {
                        "username": "illay8",
                        "content": "rule no 1, it should not use multiplication, division, and mod operator. When I tried a solution that uses division on Solution tab , it can be summited. What a rubbish"
                    },
                    {
                        "username": "aj24197",
                        "content": "can we solve this question by bit manipulations"
                    },
                    {
                        "username": "rajshish333",
                        "content": "my all answer is correct but 1/2 is showing result 1 why ?\\n"
                    },
                    {
                        "username": "talhasebtian",
                        "content": "Here\\'s an example code in Python that performs integer division without using multiplication, division, and mod operator:\\n\\npython\\ndef divide(dividend, divisor):\\n# Handle the case when the dividend is 0\\nif dividend == 0:\\nreturn 0\\n\\n# Handle the case when the divisor is 0\\nif divisor == 0:\\n    raise ZeroDivisionError(\"Cannot divide by zero\")\\n\\n# Handle the case when the dividend and divisor are the same\\nif dividend == divisor:\\n    return 1\\n\\n# Handle the case when the dividend is the minimum value and the divisor is -1\\nif dividend == -2**31 and divisor == -1:\\n    return 2**31 - 1\\n\\n# Determine the sign of the quotient\\nnegative = (dividend < 0) ^ (divisor < 0)\\n\\n# Convert both dividend and divisor to positive\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\n\\n# Initialize the quotient\\nquotient = 0\\n\\n# Keep subtracting the divisor from the dividend until the dividend becomes smaller than the divisor\\nwhile dividend >= divisor:\\n    # Subtract the divisor from the dividend\\n    dividend -= divisor\\n    # Increment the quotient by 1\\n    quotient += 1\\n\\n# Apply the sign to the quotient\\nif negative:\\n    quotient = -quotient\\n\\nreturn quotient\\nExample usage:\\ndividend = 10\\ndivisor = 3\\nresult = divide(dividend, divisor)\\nprint(result)\\nThe code handles several special cases such as when the dividend is 0, the divisor is 0, or the dividend is the minimum value and the divisor is -1. It determines the sign of the quotient and converts both the dividend and divisor to positive values, pintdd.com. Then, it repeatedly subtracts the divisor from the dividend and increments the quotient until the dividend becomes smaller than the divisor. Finally, it applies the sign to the quotient and returns the result.\\n\\nIn the example usage, the code is called with dividend = 10 and divisor = 3. The result is then printed, which will be 3, representing the quotient after dividing the dividend by the divisor."
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "cannot complete this task because of shitty testcase:\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nwhaaa? -2147483648 / -1 must be 2147483647 ? really ?"
                    },
                    {
                        "username": "Fandrir",
                        "content": "It must be 2147483647, because 2147483648 would be an int overflow. The largest allowed absolute value for negative numbers is one larger than the largest allowed value for positive numbers. Therefore this falls under the requirement that everything above 2147483647 has to return 2147483647. \\nBasically all this task is, is to account for these weird int rules and exceptions."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "to solve this problem, you just need some basic school math and type casting."
                    }
                ]
            },
            {
                "id": 1927471,
                "content": [
                    {
                        "username": "ankith_t22",
                        "content": "How do we account for when the divisor is 0? I do not know what to return then."
                    },
                    {
                        "username": "raflyirham",
                        "content": "Constraint: divisor != 0\\n\\nMeaning that the value of the divisor will never be 0."
                    },
                    {
                        "username": "Pratish10",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIn the above case we can se that dividend has the minimum value and divisor is -1 and the expected output is max value\\n\\nSo handle this error properly\\n1. Check that dividend contains minimum value and divisor is -1 then return the max value\\n2. Check that dividend contains minimum value and divisor is 1 then return min value\\n\\nHit like if it helps you"
                    },
                    {
                        "username": "Saitama109",
                        "content": "bro INT_MIN with some Random Integer is just not possible without using long.... its just too hard for me in int32...cause it overflows every damn second..\\n"
                    },
                    {
                        "username": "awesomeRj01",
                        "content": "what to do when 994/994 testcases passed and it shows TLE"
                    },
                    {
                        "username": "illay8",
                        "content": "rule no 1, it should not use multiplication, division, and mod operator. When I tried a solution that uses division on Solution tab , it can be summited. What a rubbish"
                    },
                    {
                        "username": "aj24197",
                        "content": "can we solve this question by bit manipulations"
                    },
                    {
                        "username": "rajshish333",
                        "content": "my all answer is correct but 1/2 is showing result 1 why ?\\n"
                    },
                    {
                        "username": "talhasebtian",
                        "content": "Here\\'s an example code in Python that performs integer division without using multiplication, division, and mod operator:\\n\\npython\\ndef divide(dividend, divisor):\\n# Handle the case when the dividend is 0\\nif dividend == 0:\\nreturn 0\\n\\n# Handle the case when the divisor is 0\\nif divisor == 0:\\n    raise ZeroDivisionError(\"Cannot divide by zero\")\\n\\n# Handle the case when the dividend and divisor are the same\\nif dividend == divisor:\\n    return 1\\n\\n# Handle the case when the dividend is the minimum value and the divisor is -1\\nif dividend == -2**31 and divisor == -1:\\n    return 2**31 - 1\\n\\n# Determine the sign of the quotient\\nnegative = (dividend < 0) ^ (divisor < 0)\\n\\n# Convert both dividend and divisor to positive\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\n\\n# Initialize the quotient\\nquotient = 0\\n\\n# Keep subtracting the divisor from the dividend until the dividend becomes smaller than the divisor\\nwhile dividend >= divisor:\\n    # Subtract the divisor from the dividend\\n    dividend -= divisor\\n    # Increment the quotient by 1\\n    quotient += 1\\n\\n# Apply the sign to the quotient\\nif negative:\\n    quotient = -quotient\\n\\nreturn quotient\\nExample usage:\\ndividend = 10\\ndivisor = 3\\nresult = divide(dividend, divisor)\\nprint(result)\\nThe code handles several special cases such as when the dividend is 0, the divisor is 0, or the dividend is the minimum value and the divisor is -1. It determines the sign of the quotient and converts both the dividend and divisor to positive values, pintdd.com. Then, it repeatedly subtracts the divisor from the dividend and increments the quotient until the dividend becomes smaller than the divisor. Finally, it applies the sign to the quotient and returns the result.\\n\\nIn the example usage, the code is called with dividend = 10 and divisor = 3. The result is then printed, which will be 3, representing the quotient after dividing the dividend by the divisor."
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "cannot complete this task because of shitty testcase:\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nwhaaa? -2147483648 / -1 must be 2147483647 ? really ?"
                    },
                    {
                        "username": "Fandrir",
                        "content": "It must be 2147483647, because 2147483648 would be an int overflow. The largest allowed absolute value for negative numbers is one larger than the largest allowed value for positive numbers. Therefore this falls under the requirement that everything above 2147483647 has to return 2147483647. \\nBasically all this task is, is to account for these weird int rules and exceptions."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "to solve this problem, you just need some basic school math and type casting."
                    }
                ]
            },
            {
                "id": 1913151,
                "content": [
                    {
                        "username": "ankith_t22",
                        "content": "How do we account for when the divisor is 0? I do not know what to return then."
                    },
                    {
                        "username": "raflyirham",
                        "content": "Constraint: divisor != 0\\n\\nMeaning that the value of the divisor will never be 0."
                    },
                    {
                        "username": "Pratish10",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIn the above case we can se that dividend has the minimum value and divisor is -1 and the expected output is max value\\n\\nSo handle this error properly\\n1. Check that dividend contains minimum value and divisor is -1 then return the max value\\n2. Check that dividend contains minimum value and divisor is 1 then return min value\\n\\nHit like if it helps you"
                    },
                    {
                        "username": "Saitama109",
                        "content": "bro INT_MIN with some Random Integer is just not possible without using long.... its just too hard for me in int32...cause it overflows every damn second..\\n"
                    },
                    {
                        "username": "awesomeRj01",
                        "content": "what to do when 994/994 testcases passed and it shows TLE"
                    },
                    {
                        "username": "illay8",
                        "content": "rule no 1, it should not use multiplication, division, and mod operator. When I tried a solution that uses division on Solution tab , it can be summited. What a rubbish"
                    },
                    {
                        "username": "aj24197",
                        "content": "can we solve this question by bit manipulations"
                    },
                    {
                        "username": "rajshish333",
                        "content": "my all answer is correct but 1/2 is showing result 1 why ?\\n"
                    },
                    {
                        "username": "talhasebtian",
                        "content": "Here\\'s an example code in Python that performs integer division without using multiplication, division, and mod operator:\\n\\npython\\ndef divide(dividend, divisor):\\n# Handle the case when the dividend is 0\\nif dividend == 0:\\nreturn 0\\n\\n# Handle the case when the divisor is 0\\nif divisor == 0:\\n    raise ZeroDivisionError(\"Cannot divide by zero\")\\n\\n# Handle the case when the dividend and divisor are the same\\nif dividend == divisor:\\n    return 1\\n\\n# Handle the case when the dividend is the minimum value and the divisor is -1\\nif dividend == -2**31 and divisor == -1:\\n    return 2**31 - 1\\n\\n# Determine the sign of the quotient\\nnegative = (dividend < 0) ^ (divisor < 0)\\n\\n# Convert both dividend and divisor to positive\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\n\\n# Initialize the quotient\\nquotient = 0\\n\\n# Keep subtracting the divisor from the dividend until the dividend becomes smaller than the divisor\\nwhile dividend >= divisor:\\n    # Subtract the divisor from the dividend\\n    dividend -= divisor\\n    # Increment the quotient by 1\\n    quotient += 1\\n\\n# Apply the sign to the quotient\\nif negative:\\n    quotient = -quotient\\n\\nreturn quotient\\nExample usage:\\ndividend = 10\\ndivisor = 3\\nresult = divide(dividend, divisor)\\nprint(result)\\nThe code handles several special cases such as when the dividend is 0, the divisor is 0, or the dividend is the minimum value and the divisor is -1. It determines the sign of the quotient and converts both the dividend and divisor to positive values, pintdd.com. Then, it repeatedly subtracts the divisor from the dividend and increments the quotient until the dividend becomes smaller than the divisor. Finally, it applies the sign to the quotient and returns the result.\\n\\nIn the example usage, the code is called with dividend = 10 and divisor = 3. The result is then printed, which will be 3, representing the quotient after dividing the dividend by the divisor."
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "cannot complete this task because of shitty testcase:\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nwhaaa? -2147483648 / -1 must be 2147483647 ? really ?"
                    },
                    {
                        "username": "Fandrir",
                        "content": "It must be 2147483647, because 2147483648 would be an int overflow. The largest allowed absolute value for negative numbers is one larger than the largest allowed value for positive numbers. Therefore this falls under the requirement that everything above 2147483647 has to return 2147483647. \\nBasically all this task is, is to account for these weird int rules and exceptions."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "to solve this problem, you just need some basic school math and type casting."
                    }
                ]
            },
            {
                "id": 1906055,
                "content": [
                    {
                        "username": "ankith_t22",
                        "content": "How do we account for when the divisor is 0? I do not know what to return then."
                    },
                    {
                        "username": "raflyirham",
                        "content": "Constraint: divisor != 0\\n\\nMeaning that the value of the divisor will never be 0."
                    },
                    {
                        "username": "Pratish10",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIn the above case we can se that dividend has the minimum value and divisor is -1 and the expected output is max value\\n\\nSo handle this error properly\\n1. Check that dividend contains minimum value and divisor is -1 then return the max value\\n2. Check that dividend contains minimum value and divisor is 1 then return min value\\n\\nHit like if it helps you"
                    },
                    {
                        "username": "Saitama109",
                        "content": "bro INT_MIN with some Random Integer is just not possible without using long.... its just too hard for me in int32...cause it overflows every damn second..\\n"
                    },
                    {
                        "username": "awesomeRj01",
                        "content": "what to do when 994/994 testcases passed and it shows TLE"
                    },
                    {
                        "username": "illay8",
                        "content": "rule no 1, it should not use multiplication, division, and mod operator. When I tried a solution that uses division on Solution tab , it can be summited. What a rubbish"
                    },
                    {
                        "username": "aj24197",
                        "content": "can we solve this question by bit manipulations"
                    },
                    {
                        "username": "rajshish333",
                        "content": "my all answer is correct but 1/2 is showing result 1 why ?\\n"
                    },
                    {
                        "username": "talhasebtian",
                        "content": "Here\\'s an example code in Python that performs integer division without using multiplication, division, and mod operator:\\n\\npython\\ndef divide(dividend, divisor):\\n# Handle the case when the dividend is 0\\nif dividend == 0:\\nreturn 0\\n\\n# Handle the case when the divisor is 0\\nif divisor == 0:\\n    raise ZeroDivisionError(\"Cannot divide by zero\")\\n\\n# Handle the case when the dividend and divisor are the same\\nif dividend == divisor:\\n    return 1\\n\\n# Handle the case when the dividend is the minimum value and the divisor is -1\\nif dividend == -2**31 and divisor == -1:\\n    return 2**31 - 1\\n\\n# Determine the sign of the quotient\\nnegative = (dividend < 0) ^ (divisor < 0)\\n\\n# Convert both dividend and divisor to positive\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\n\\n# Initialize the quotient\\nquotient = 0\\n\\n# Keep subtracting the divisor from the dividend until the dividend becomes smaller than the divisor\\nwhile dividend >= divisor:\\n    # Subtract the divisor from the dividend\\n    dividend -= divisor\\n    # Increment the quotient by 1\\n    quotient += 1\\n\\n# Apply the sign to the quotient\\nif negative:\\n    quotient = -quotient\\n\\nreturn quotient\\nExample usage:\\ndividend = 10\\ndivisor = 3\\nresult = divide(dividend, divisor)\\nprint(result)\\nThe code handles several special cases such as when the dividend is 0, the divisor is 0, or the dividend is the minimum value and the divisor is -1. It determines the sign of the quotient and converts both the dividend and divisor to positive values, pintdd.com. Then, it repeatedly subtracts the divisor from the dividend and increments the quotient until the dividend becomes smaller than the divisor. Finally, it applies the sign to the quotient and returns the result.\\n\\nIn the example usage, the code is called with dividend = 10 and divisor = 3. The result is then printed, which will be 3, representing the quotient after dividing the dividend by the divisor."
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "cannot complete this task because of shitty testcase:\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nwhaaa? -2147483648 / -1 must be 2147483647 ? really ?"
                    },
                    {
                        "username": "Fandrir",
                        "content": "It must be 2147483647, because 2147483648 would be an int overflow. The largest allowed absolute value for negative numbers is one larger than the largest allowed value for positive numbers. Therefore this falls under the requirement that everything above 2147483647 has to return 2147483647. \\nBasically all this task is, is to account for these weird int rules and exceptions."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "to solve this problem, you just need some basic school math and type casting."
                    }
                ]
            },
            {
                "id": 1900273,
                "content": [
                    {
                        "username": "ankith_t22",
                        "content": "How do we account for when the divisor is 0? I do not know what to return then."
                    },
                    {
                        "username": "raflyirham",
                        "content": "Constraint: divisor != 0\\n\\nMeaning that the value of the divisor will never be 0."
                    },
                    {
                        "username": "Pratish10",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIn the above case we can se that dividend has the minimum value and divisor is -1 and the expected output is max value\\n\\nSo handle this error properly\\n1. Check that dividend contains minimum value and divisor is -1 then return the max value\\n2. Check that dividend contains minimum value and divisor is 1 then return min value\\n\\nHit like if it helps you"
                    },
                    {
                        "username": "Saitama109",
                        "content": "bro INT_MIN with some Random Integer is just not possible without using long.... its just too hard for me in int32...cause it overflows every damn second..\\n"
                    },
                    {
                        "username": "awesomeRj01",
                        "content": "what to do when 994/994 testcases passed and it shows TLE"
                    },
                    {
                        "username": "illay8",
                        "content": "rule no 1, it should not use multiplication, division, and mod operator. When I tried a solution that uses division on Solution tab , it can be summited. What a rubbish"
                    },
                    {
                        "username": "aj24197",
                        "content": "can we solve this question by bit manipulations"
                    },
                    {
                        "username": "rajshish333",
                        "content": "my all answer is correct but 1/2 is showing result 1 why ?\\n"
                    },
                    {
                        "username": "talhasebtian",
                        "content": "Here\\'s an example code in Python that performs integer division without using multiplication, division, and mod operator:\\n\\npython\\ndef divide(dividend, divisor):\\n# Handle the case when the dividend is 0\\nif dividend == 0:\\nreturn 0\\n\\n# Handle the case when the divisor is 0\\nif divisor == 0:\\n    raise ZeroDivisionError(\"Cannot divide by zero\")\\n\\n# Handle the case when the dividend and divisor are the same\\nif dividend == divisor:\\n    return 1\\n\\n# Handle the case when the dividend is the minimum value and the divisor is -1\\nif dividend == -2**31 and divisor == -1:\\n    return 2**31 - 1\\n\\n# Determine the sign of the quotient\\nnegative = (dividend < 0) ^ (divisor < 0)\\n\\n# Convert both dividend and divisor to positive\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\n\\n# Initialize the quotient\\nquotient = 0\\n\\n# Keep subtracting the divisor from the dividend until the dividend becomes smaller than the divisor\\nwhile dividend >= divisor:\\n    # Subtract the divisor from the dividend\\n    dividend -= divisor\\n    # Increment the quotient by 1\\n    quotient += 1\\n\\n# Apply the sign to the quotient\\nif negative:\\n    quotient = -quotient\\n\\nreturn quotient\\nExample usage:\\ndividend = 10\\ndivisor = 3\\nresult = divide(dividend, divisor)\\nprint(result)\\nThe code handles several special cases such as when the dividend is 0, the divisor is 0, or the dividend is the minimum value and the divisor is -1. It determines the sign of the quotient and converts both the dividend and divisor to positive values, pintdd.com. Then, it repeatedly subtracts the divisor from the dividend and increments the quotient until the dividend becomes smaller than the divisor. Finally, it applies the sign to the quotient and returns the result.\\n\\nIn the example usage, the code is called with dividend = 10 and divisor = 3. The result is then printed, which will be 3, representing the quotient after dividing the dividend by the divisor."
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "cannot complete this task because of shitty testcase:\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nwhaaa? -2147483648 / -1 must be 2147483647 ? really ?"
                    },
                    {
                        "username": "Fandrir",
                        "content": "It must be 2147483647, because 2147483648 would be an int overflow. The largest allowed absolute value for negative numbers is one larger than the largest allowed value for positive numbers. Therefore this falls under the requirement that everything above 2147483647 has to return 2147483647. \\nBasically all this task is, is to account for these weird int rules and exceptions."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "to solve this problem, you just need some basic school math and type casting."
                    }
                ]
            },
            {
                "id": 1899087,
                "content": [
                    {
                        "username": "pratyushshandilyajha2",
                        "content": "The  issue with the problem can be resolved easily by changing the type of dividend , the return type and the type of variable accepting the return to long. "
                    },
                    {
                        "username": "user5037rv",
                        "content": "Time limit exceeded on dividend = 2147483647 divisor = 3, When included in the testcase, the result is accurate"
                    },
                    {
                        "username": "shaikdada",
                        "content": "Why am getting error in leetcode its running fine in my local machine\\ndef divide(dividend, divisor):\\n        s=dividend/divisor\\n        val=f\\'{s:.0f}\\'\\n        return val"
                    },
                    {
                        "username": "user5508IZ",
                        "content": "ValueError: invalid literal for int() with base 10: \\'-\\'\\n    return (int(ch))\\nLine 5 in divide (Solution.py)\\n    ret = Solution().divide(param_1, param_2)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n\\nMeanwhile testcases work perfectly fine in VS and online compilers :/"
                    },
                    {
                        "username": "user5991g",
                        "content": "For the case\\n`dividend =  2147483647 `\\nAnd \\n` divisor = 2 `\\n\\nI am getting error as `Memory Limit Exceeded`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "> For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\\n\\nWe have *dividend* and *divisor* in problem definition. What is ***quotient*** ???"
                    },
                    {
                        "username": "ajay1208",
                        "content": "Read the description carefully, edge cases are mentioned"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this question is playing a little too much with integer limit :("
                    },
                    {
                        "username": "Vinayak-Pandey",
                        "content": "In the testcase the same code is correct but when submittin it is failing?"
                    },
                    {
                        "username": "Abraha111",
                        "content": "Do not try to solve this question, absalutely incorrect in testcase 551!"
                    }
                ]
            },
            {
                "id": 1896844,
                "content": [
                    {
                        "username": "pratyushshandilyajha2",
                        "content": "The  issue with the problem can be resolved easily by changing the type of dividend , the return type and the type of variable accepting the return to long. "
                    },
                    {
                        "username": "user5037rv",
                        "content": "Time limit exceeded on dividend = 2147483647 divisor = 3, When included in the testcase, the result is accurate"
                    },
                    {
                        "username": "shaikdada",
                        "content": "Why am getting error in leetcode its running fine in my local machine\\ndef divide(dividend, divisor):\\n        s=dividend/divisor\\n        val=f\\'{s:.0f}\\'\\n        return val"
                    },
                    {
                        "username": "user5508IZ",
                        "content": "ValueError: invalid literal for int() with base 10: \\'-\\'\\n    return (int(ch))\\nLine 5 in divide (Solution.py)\\n    ret = Solution().divide(param_1, param_2)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n\\nMeanwhile testcases work perfectly fine in VS and online compilers :/"
                    },
                    {
                        "username": "user5991g",
                        "content": "For the case\\n`dividend =  2147483647 `\\nAnd \\n` divisor = 2 `\\n\\nI am getting error as `Memory Limit Exceeded`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "> For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\\n\\nWe have *dividend* and *divisor* in problem definition. What is ***quotient*** ???"
                    },
                    {
                        "username": "ajay1208",
                        "content": "Read the description carefully, edge cases are mentioned"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this question is playing a little too much with integer limit :("
                    },
                    {
                        "username": "Vinayak-Pandey",
                        "content": "In the testcase the same code is correct but when submittin it is failing?"
                    },
                    {
                        "username": "Abraha111",
                        "content": "Do not try to solve this question, absalutely incorrect in testcase 551!"
                    }
                ]
            },
            {
                "id": 1890247,
                "content": [
                    {
                        "username": "pratyushshandilyajha2",
                        "content": "The  issue with the problem can be resolved easily by changing the type of dividend , the return type and the type of variable accepting the return to long. "
                    },
                    {
                        "username": "user5037rv",
                        "content": "Time limit exceeded on dividend = 2147483647 divisor = 3, When included in the testcase, the result is accurate"
                    },
                    {
                        "username": "shaikdada",
                        "content": "Why am getting error in leetcode its running fine in my local machine\\ndef divide(dividend, divisor):\\n        s=dividend/divisor\\n        val=f\\'{s:.0f}\\'\\n        return val"
                    },
                    {
                        "username": "user5508IZ",
                        "content": "ValueError: invalid literal for int() with base 10: \\'-\\'\\n    return (int(ch))\\nLine 5 in divide (Solution.py)\\n    ret = Solution().divide(param_1, param_2)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n\\nMeanwhile testcases work perfectly fine in VS and online compilers :/"
                    },
                    {
                        "username": "user5991g",
                        "content": "For the case\\n`dividend =  2147483647 `\\nAnd \\n` divisor = 2 `\\n\\nI am getting error as `Memory Limit Exceeded`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "> For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\\n\\nWe have *dividend* and *divisor* in problem definition. What is ***quotient*** ???"
                    },
                    {
                        "username": "ajay1208",
                        "content": "Read the description carefully, edge cases are mentioned"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this question is playing a little too much with integer limit :("
                    },
                    {
                        "username": "Vinayak-Pandey",
                        "content": "In the testcase the same code is correct but when submittin it is failing?"
                    },
                    {
                        "username": "Abraha111",
                        "content": "Do not try to solve this question, absalutely incorrect in testcase 551!"
                    }
                ]
            },
            {
                "id": 1875356,
                "content": [
                    {
                        "username": "pratyushshandilyajha2",
                        "content": "The  issue with the problem can be resolved easily by changing the type of dividend , the return type and the type of variable accepting the return to long. "
                    },
                    {
                        "username": "user5037rv",
                        "content": "Time limit exceeded on dividend = 2147483647 divisor = 3, When included in the testcase, the result is accurate"
                    },
                    {
                        "username": "shaikdada",
                        "content": "Why am getting error in leetcode its running fine in my local machine\\ndef divide(dividend, divisor):\\n        s=dividend/divisor\\n        val=f\\'{s:.0f}\\'\\n        return val"
                    },
                    {
                        "username": "user5508IZ",
                        "content": "ValueError: invalid literal for int() with base 10: \\'-\\'\\n    return (int(ch))\\nLine 5 in divide (Solution.py)\\n    ret = Solution().divide(param_1, param_2)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n\\nMeanwhile testcases work perfectly fine in VS and online compilers :/"
                    },
                    {
                        "username": "user5991g",
                        "content": "For the case\\n`dividend =  2147483647 `\\nAnd \\n` divisor = 2 `\\n\\nI am getting error as `Memory Limit Exceeded`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "> For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\\n\\nWe have *dividend* and *divisor* in problem definition. What is ***quotient*** ???"
                    },
                    {
                        "username": "ajay1208",
                        "content": "Read the description carefully, edge cases are mentioned"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this question is playing a little too much with integer limit :("
                    },
                    {
                        "username": "Vinayak-Pandey",
                        "content": "In the testcase the same code is correct but when submittin it is failing?"
                    },
                    {
                        "username": "Abraha111",
                        "content": "Do not try to solve this question, absalutely incorrect in testcase 551!"
                    }
                ]
            },
            {
                "id": 1870594,
                "content": [
                    {
                        "username": "pratyushshandilyajha2",
                        "content": "The  issue with the problem can be resolved easily by changing the type of dividend , the return type and the type of variable accepting the return to long. "
                    },
                    {
                        "username": "user5037rv",
                        "content": "Time limit exceeded on dividend = 2147483647 divisor = 3, When included in the testcase, the result is accurate"
                    },
                    {
                        "username": "shaikdada",
                        "content": "Why am getting error in leetcode its running fine in my local machine\\ndef divide(dividend, divisor):\\n        s=dividend/divisor\\n        val=f\\'{s:.0f}\\'\\n        return val"
                    },
                    {
                        "username": "user5508IZ",
                        "content": "ValueError: invalid literal for int() with base 10: \\'-\\'\\n    return (int(ch))\\nLine 5 in divide (Solution.py)\\n    ret = Solution().divide(param_1, param_2)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n\\nMeanwhile testcases work perfectly fine in VS and online compilers :/"
                    },
                    {
                        "username": "user5991g",
                        "content": "For the case\\n`dividend =  2147483647 `\\nAnd \\n` divisor = 2 `\\n\\nI am getting error as `Memory Limit Exceeded`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "> For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\\n\\nWe have *dividend* and *divisor* in problem definition. What is ***quotient*** ???"
                    },
                    {
                        "username": "ajay1208",
                        "content": "Read the description carefully, edge cases are mentioned"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this question is playing a little too much with integer limit :("
                    },
                    {
                        "username": "Vinayak-Pandey",
                        "content": "In the testcase the same code is correct but when submittin it is failing?"
                    },
                    {
                        "username": "Abraha111",
                        "content": "Do not try to solve this question, absalutely incorrect in testcase 551!"
                    }
                ]
            },
            {
                "id": 1869263,
                "content": [
                    {
                        "username": "pratyushshandilyajha2",
                        "content": "The  issue with the problem can be resolved easily by changing the type of dividend , the return type and the type of variable accepting the return to long. "
                    },
                    {
                        "username": "user5037rv",
                        "content": "Time limit exceeded on dividend = 2147483647 divisor = 3, When included in the testcase, the result is accurate"
                    },
                    {
                        "username": "shaikdada",
                        "content": "Why am getting error in leetcode its running fine in my local machine\\ndef divide(dividend, divisor):\\n        s=dividend/divisor\\n        val=f\\'{s:.0f}\\'\\n        return val"
                    },
                    {
                        "username": "user5508IZ",
                        "content": "ValueError: invalid literal for int() with base 10: \\'-\\'\\n    return (int(ch))\\nLine 5 in divide (Solution.py)\\n    ret = Solution().divide(param_1, param_2)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n\\nMeanwhile testcases work perfectly fine in VS and online compilers :/"
                    },
                    {
                        "username": "user5991g",
                        "content": "For the case\\n`dividend =  2147483647 `\\nAnd \\n` divisor = 2 `\\n\\nI am getting error as `Memory Limit Exceeded`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "> For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\\n\\nWe have *dividend* and *divisor* in problem definition. What is ***quotient*** ???"
                    },
                    {
                        "username": "ajay1208",
                        "content": "Read the description carefully, edge cases are mentioned"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this question is playing a little too much with integer limit :("
                    },
                    {
                        "username": "Vinayak-Pandey",
                        "content": "In the testcase the same code is correct but when submittin it is failing?"
                    },
                    {
                        "username": "Abraha111",
                        "content": "Do not try to solve this question, absalutely incorrect in testcase 551!"
                    }
                ]
            },
            {
                "id": 1866761,
                "content": [
                    {
                        "username": "pratyushshandilyajha2",
                        "content": "The  issue with the problem can be resolved easily by changing the type of dividend , the return type and the type of variable accepting the return to long. "
                    },
                    {
                        "username": "user5037rv",
                        "content": "Time limit exceeded on dividend = 2147483647 divisor = 3, When included in the testcase, the result is accurate"
                    },
                    {
                        "username": "shaikdada",
                        "content": "Why am getting error in leetcode its running fine in my local machine\\ndef divide(dividend, divisor):\\n        s=dividend/divisor\\n        val=f\\'{s:.0f}\\'\\n        return val"
                    },
                    {
                        "username": "user5508IZ",
                        "content": "ValueError: invalid literal for int() with base 10: \\'-\\'\\n    return (int(ch))\\nLine 5 in divide (Solution.py)\\n    ret = Solution().divide(param_1, param_2)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n\\nMeanwhile testcases work perfectly fine in VS and online compilers :/"
                    },
                    {
                        "username": "user5991g",
                        "content": "For the case\\n`dividend =  2147483647 `\\nAnd \\n` divisor = 2 `\\n\\nI am getting error as `Memory Limit Exceeded`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "> For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\\n\\nWe have *dividend* and *divisor* in problem definition. What is ***quotient*** ???"
                    },
                    {
                        "username": "ajay1208",
                        "content": "Read the description carefully, edge cases are mentioned"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this question is playing a little too much with integer limit :("
                    },
                    {
                        "username": "Vinayak-Pandey",
                        "content": "In the testcase the same code is correct but when submittin it is failing?"
                    },
                    {
                        "username": "Abraha111",
                        "content": "Do not try to solve this question, absalutely incorrect in testcase 551!"
                    }
                ]
            },
            {
                "id": 1855176,
                "content": [
                    {
                        "username": "pratyushshandilyajha2",
                        "content": "The  issue with the problem can be resolved easily by changing the type of dividend , the return type and the type of variable accepting the return to long. "
                    },
                    {
                        "username": "user5037rv",
                        "content": "Time limit exceeded on dividend = 2147483647 divisor = 3, When included in the testcase, the result is accurate"
                    },
                    {
                        "username": "shaikdada",
                        "content": "Why am getting error in leetcode its running fine in my local machine\\ndef divide(dividend, divisor):\\n        s=dividend/divisor\\n        val=f\\'{s:.0f}\\'\\n        return val"
                    },
                    {
                        "username": "user5508IZ",
                        "content": "ValueError: invalid literal for int() with base 10: \\'-\\'\\n    return (int(ch))\\nLine 5 in divide (Solution.py)\\n    ret = Solution().divide(param_1, param_2)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n\\nMeanwhile testcases work perfectly fine in VS and online compilers :/"
                    },
                    {
                        "username": "user5991g",
                        "content": "For the case\\n`dividend =  2147483647 `\\nAnd \\n` divisor = 2 `\\n\\nI am getting error as `Memory Limit Exceeded`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "> For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\\n\\nWe have *dividend* and *divisor* in problem definition. What is ***quotient*** ???"
                    },
                    {
                        "username": "ajay1208",
                        "content": "Read the description carefully, edge cases are mentioned"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this question is playing a little too much with integer limit :("
                    },
                    {
                        "username": "Vinayak-Pandey",
                        "content": "In the testcase the same code is correct but when submittin it is failing?"
                    },
                    {
                        "username": "Abraha111",
                        "content": "Do not try to solve this question, absalutely incorrect in testcase 551!"
                    }
                ]
            },
            {
                "id": 1852708,
                "content": [
                    {
                        "username": "pratyushshandilyajha2",
                        "content": "The  issue with the problem can be resolved easily by changing the type of dividend , the return type and the type of variable accepting the return to long. "
                    },
                    {
                        "username": "user5037rv",
                        "content": "Time limit exceeded on dividend = 2147483647 divisor = 3, When included in the testcase, the result is accurate"
                    },
                    {
                        "username": "shaikdada",
                        "content": "Why am getting error in leetcode its running fine in my local machine\\ndef divide(dividend, divisor):\\n        s=dividend/divisor\\n        val=f\\'{s:.0f}\\'\\n        return val"
                    },
                    {
                        "username": "user5508IZ",
                        "content": "ValueError: invalid literal for int() with base 10: \\'-\\'\\n    return (int(ch))\\nLine 5 in divide (Solution.py)\\n    ret = Solution().divide(param_1, param_2)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n\\nMeanwhile testcases work perfectly fine in VS and online compilers :/"
                    },
                    {
                        "username": "user5991g",
                        "content": "For the case\\n`dividend =  2147483647 `\\nAnd \\n` divisor = 2 `\\n\\nI am getting error as `Memory Limit Exceeded`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "> For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\\n\\nWe have *dividend* and *divisor* in problem definition. What is ***quotient*** ???"
                    },
                    {
                        "username": "ajay1208",
                        "content": "Read the description carefully, edge cases are mentioned"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this question is playing a little too much with integer limit :("
                    },
                    {
                        "username": "Vinayak-Pandey",
                        "content": "In the testcase the same code is correct but when submittin it is failing?"
                    },
                    {
                        "username": "Abraha111",
                        "content": "Do not try to solve this question, absalutely incorrect in testcase 551!"
                    }
                ]
            },
            {
                "id": 1846237,
                "content": [
                    {
                        "username": "pratyushshandilyajha2",
                        "content": "The  issue with the problem can be resolved easily by changing the type of dividend , the return type and the type of variable accepting the return to long. "
                    },
                    {
                        "username": "user5037rv",
                        "content": "Time limit exceeded on dividend = 2147483647 divisor = 3, When included in the testcase, the result is accurate"
                    },
                    {
                        "username": "shaikdada",
                        "content": "Why am getting error in leetcode its running fine in my local machine\\ndef divide(dividend, divisor):\\n        s=dividend/divisor\\n        val=f\\'{s:.0f}\\'\\n        return val"
                    },
                    {
                        "username": "user5508IZ",
                        "content": "ValueError: invalid literal for int() with base 10: \\'-\\'\\n    return (int(ch))\\nLine 5 in divide (Solution.py)\\n    ret = Solution().divide(param_1, param_2)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n\\nMeanwhile testcases work perfectly fine in VS and online compilers :/"
                    },
                    {
                        "username": "user5991g",
                        "content": "For the case\\n`dividend =  2147483647 `\\nAnd \\n` divisor = 2 `\\n\\nI am getting error as `Memory Limit Exceeded`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "> For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\\n\\nWe have *dividend* and *divisor* in problem definition. What is ***quotient*** ???"
                    },
                    {
                        "username": "ajay1208",
                        "content": "Read the description carefully, edge cases are mentioned"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this question is playing a little too much with integer limit :("
                    },
                    {
                        "username": "Vinayak-Pandey",
                        "content": "In the testcase the same code is correct but when submittin it is failing?"
                    },
                    {
                        "username": "Abraha111",
                        "content": "Do not try to solve this question, absalutely incorrect in testcase 551!"
                    }
                ]
            },
            {
                "id": 1845848,
                "content": [
                    {
                        "username": "aman3091",
                        "content": "   int divide(int dividend, int divisor) {\\n      if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n\\n        return dividend/divisor;\\n     \\n       \\n    }\\n\\nin this code why are we taking dividend ==INT_MIN not INT_MAX . pleas answer\\n"
                    },
                    {
                        "username": "rohit_gupta1001",
                        "content": "Hello everyone ,This question is asked by me in today\\'s Online assessment of Scaler."
                    },
                    {
                        "username": "RaRafiq3",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647 \\nfor this problem try this-->\\nif(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }"
                    },
                    {
                        "username": "neilkumarwb",
                        "content": "whats the point of solving these type of questions"
                    },
                    {
                        "username": "tonkei0361",
                        "content": "I was first annoyed by this question, especially when I got stuck on the 2**31-1 test case. However, after studying solutions posted by others, I feel this is an underrated question in terms of likes vs. dislikes."
                    },
                    {
                        "username": "CoderrrrMan",
                        "content": "i am gay, what the hell is that ?"
                    },
                    {
                        "username": "andysem3",
                        "content": "I REALY appreciate to this PROBLEM for my 14% acceptance rate."
                    },
                    {
                        "username": "RAJINIKANTH-KAKARLA",
                        "content": "test case2 is wrong!"
                    },
                    {
                        "username": "congener",
                        "content": "Fun problem. Definitely requires careful reading of the description, but its a valuable lesson in types, their sizes and the problems that may arise when pushed to their limits. "
                    },
                    {
                        "username": "jayramesh0",
                        "content": "I have this weird problem where I get a timelimit exceeded  error after only passing 17 cases but other times I passed 990.  Why does this happen?"
                    }
                ]
            },
            {
                "id": 1841568,
                "content": [
                    {
                        "username": "aman3091",
                        "content": "   int divide(int dividend, int divisor) {\\n      if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n\\n        return dividend/divisor;\\n     \\n       \\n    }\\n\\nin this code why are we taking dividend ==INT_MIN not INT_MAX . pleas answer\\n"
                    },
                    {
                        "username": "rohit_gupta1001",
                        "content": "Hello everyone ,This question is asked by me in today\\'s Online assessment of Scaler."
                    },
                    {
                        "username": "RaRafiq3",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647 \\nfor this problem try this-->\\nif(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }"
                    },
                    {
                        "username": "neilkumarwb",
                        "content": "whats the point of solving these type of questions"
                    },
                    {
                        "username": "tonkei0361",
                        "content": "I was first annoyed by this question, especially when I got stuck on the 2**31-1 test case. However, after studying solutions posted by others, I feel this is an underrated question in terms of likes vs. dislikes."
                    },
                    {
                        "username": "CoderrrrMan",
                        "content": "i am gay, what the hell is that ?"
                    },
                    {
                        "username": "andysem3",
                        "content": "I REALY appreciate to this PROBLEM for my 14% acceptance rate."
                    },
                    {
                        "username": "RAJINIKANTH-KAKARLA",
                        "content": "test case2 is wrong!"
                    },
                    {
                        "username": "congener",
                        "content": "Fun problem. Definitely requires careful reading of the description, but its a valuable lesson in types, their sizes and the problems that may arise when pushed to their limits. "
                    },
                    {
                        "username": "jayramesh0",
                        "content": "I have this weird problem where I get a timelimit exceeded  error after only passing 17 cases but other times I passed 990.  Why does this happen?"
                    }
                ]
            },
            {
                "id": 1840442,
                "content": [
                    {
                        "username": "aman3091",
                        "content": "   int divide(int dividend, int divisor) {\\n      if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n\\n        return dividend/divisor;\\n     \\n       \\n    }\\n\\nin this code why are we taking dividend ==INT_MIN not INT_MAX . pleas answer\\n"
                    },
                    {
                        "username": "rohit_gupta1001",
                        "content": "Hello everyone ,This question is asked by me in today\\'s Online assessment of Scaler."
                    },
                    {
                        "username": "RaRafiq3",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647 \\nfor this problem try this-->\\nif(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }"
                    },
                    {
                        "username": "neilkumarwb",
                        "content": "whats the point of solving these type of questions"
                    },
                    {
                        "username": "tonkei0361",
                        "content": "I was first annoyed by this question, especially when I got stuck on the 2**31-1 test case. However, after studying solutions posted by others, I feel this is an underrated question in terms of likes vs. dislikes."
                    },
                    {
                        "username": "CoderrrrMan",
                        "content": "i am gay, what the hell is that ?"
                    },
                    {
                        "username": "andysem3",
                        "content": "I REALY appreciate to this PROBLEM for my 14% acceptance rate."
                    },
                    {
                        "username": "RAJINIKANTH-KAKARLA",
                        "content": "test case2 is wrong!"
                    },
                    {
                        "username": "congener",
                        "content": "Fun problem. Definitely requires careful reading of the description, but its a valuable lesson in types, their sizes and the problems that may arise when pushed to their limits. "
                    },
                    {
                        "username": "jayramesh0",
                        "content": "I have this weird problem where I get a timelimit exceeded  error after only passing 17 cases but other times I passed 990.  Why does this happen?"
                    }
                ]
            },
            {
                "id": 1834980,
                "content": [
                    {
                        "username": "aman3091",
                        "content": "   int divide(int dividend, int divisor) {\\n      if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n\\n        return dividend/divisor;\\n     \\n       \\n    }\\n\\nin this code why are we taking dividend ==INT_MIN not INT_MAX . pleas answer\\n"
                    },
                    {
                        "username": "rohit_gupta1001",
                        "content": "Hello everyone ,This question is asked by me in today\\'s Online assessment of Scaler."
                    },
                    {
                        "username": "RaRafiq3",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647 \\nfor this problem try this-->\\nif(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }"
                    },
                    {
                        "username": "neilkumarwb",
                        "content": "whats the point of solving these type of questions"
                    },
                    {
                        "username": "tonkei0361",
                        "content": "I was first annoyed by this question, especially when I got stuck on the 2**31-1 test case. However, after studying solutions posted by others, I feel this is an underrated question in terms of likes vs. dislikes."
                    },
                    {
                        "username": "CoderrrrMan",
                        "content": "i am gay, what the hell is that ?"
                    },
                    {
                        "username": "andysem3",
                        "content": "I REALY appreciate to this PROBLEM for my 14% acceptance rate."
                    },
                    {
                        "username": "RAJINIKANTH-KAKARLA",
                        "content": "test case2 is wrong!"
                    },
                    {
                        "username": "congener",
                        "content": "Fun problem. Definitely requires careful reading of the description, but its a valuable lesson in types, their sizes and the problems that may arise when pushed to their limits. "
                    },
                    {
                        "username": "jayramesh0",
                        "content": "I have this weird problem where I get a timelimit exceeded  error after only passing 17 cases but other times I passed 990.  Why does this happen?"
                    }
                ]
            },
            {
                "id": 1827868,
                "content": [
                    {
                        "username": "aman3091",
                        "content": "   int divide(int dividend, int divisor) {\\n      if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n\\n        return dividend/divisor;\\n     \\n       \\n    }\\n\\nin this code why are we taking dividend ==INT_MIN not INT_MAX . pleas answer\\n"
                    },
                    {
                        "username": "rohit_gupta1001",
                        "content": "Hello everyone ,This question is asked by me in today\\'s Online assessment of Scaler."
                    },
                    {
                        "username": "RaRafiq3",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647 \\nfor this problem try this-->\\nif(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }"
                    },
                    {
                        "username": "neilkumarwb",
                        "content": "whats the point of solving these type of questions"
                    },
                    {
                        "username": "tonkei0361",
                        "content": "I was first annoyed by this question, especially when I got stuck on the 2**31-1 test case. However, after studying solutions posted by others, I feel this is an underrated question in terms of likes vs. dislikes."
                    },
                    {
                        "username": "CoderrrrMan",
                        "content": "i am gay, what the hell is that ?"
                    },
                    {
                        "username": "andysem3",
                        "content": "I REALY appreciate to this PROBLEM for my 14% acceptance rate."
                    },
                    {
                        "username": "RAJINIKANTH-KAKARLA",
                        "content": "test case2 is wrong!"
                    },
                    {
                        "username": "congener",
                        "content": "Fun problem. Definitely requires careful reading of the description, but its a valuable lesson in types, their sizes and the problems that may arise when pushed to their limits. "
                    },
                    {
                        "username": "jayramesh0",
                        "content": "I have this weird problem where I get a timelimit exceeded  error after only passing 17 cases but other times I passed 990.  Why does this happen?"
                    }
                ]
            },
            {
                "id": 1824198,
                "content": [
                    {
                        "username": "aman3091",
                        "content": "   int divide(int dividend, int divisor) {\\n      if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n\\n        return dividend/divisor;\\n     \\n       \\n    }\\n\\nin this code why are we taking dividend ==INT_MIN not INT_MAX . pleas answer\\n"
                    },
                    {
                        "username": "rohit_gupta1001",
                        "content": "Hello everyone ,This question is asked by me in today\\'s Online assessment of Scaler."
                    },
                    {
                        "username": "RaRafiq3",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647 \\nfor this problem try this-->\\nif(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }"
                    },
                    {
                        "username": "neilkumarwb",
                        "content": "whats the point of solving these type of questions"
                    },
                    {
                        "username": "tonkei0361",
                        "content": "I was first annoyed by this question, especially when I got stuck on the 2**31-1 test case. However, after studying solutions posted by others, I feel this is an underrated question in terms of likes vs. dislikes."
                    },
                    {
                        "username": "CoderrrrMan",
                        "content": "i am gay, what the hell is that ?"
                    },
                    {
                        "username": "andysem3",
                        "content": "I REALY appreciate to this PROBLEM for my 14% acceptance rate."
                    },
                    {
                        "username": "RAJINIKANTH-KAKARLA",
                        "content": "test case2 is wrong!"
                    },
                    {
                        "username": "congener",
                        "content": "Fun problem. Definitely requires careful reading of the description, but its a valuable lesson in types, their sizes and the problems that may arise when pushed to their limits. "
                    },
                    {
                        "username": "jayramesh0",
                        "content": "I have this weird problem where I get a timelimit exceeded  error after only passing 17 cases but other times I passed 990.  Why does this happen?"
                    }
                ]
            },
            {
                "id": 1823408,
                "content": [
                    {
                        "username": "aman3091",
                        "content": "   int divide(int dividend, int divisor) {\\n      if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n\\n        return dividend/divisor;\\n     \\n       \\n    }\\n\\nin this code why are we taking dividend ==INT_MIN not INT_MAX . pleas answer\\n"
                    },
                    {
                        "username": "rohit_gupta1001",
                        "content": "Hello everyone ,This question is asked by me in today\\'s Online assessment of Scaler."
                    },
                    {
                        "username": "RaRafiq3",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647 \\nfor this problem try this-->\\nif(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }"
                    },
                    {
                        "username": "neilkumarwb",
                        "content": "whats the point of solving these type of questions"
                    },
                    {
                        "username": "tonkei0361",
                        "content": "I was first annoyed by this question, especially when I got stuck on the 2**31-1 test case. However, after studying solutions posted by others, I feel this is an underrated question in terms of likes vs. dislikes."
                    },
                    {
                        "username": "CoderrrrMan",
                        "content": "i am gay, what the hell is that ?"
                    },
                    {
                        "username": "andysem3",
                        "content": "I REALY appreciate to this PROBLEM for my 14% acceptance rate."
                    },
                    {
                        "username": "RAJINIKANTH-KAKARLA",
                        "content": "test case2 is wrong!"
                    },
                    {
                        "username": "congener",
                        "content": "Fun problem. Definitely requires careful reading of the description, but its a valuable lesson in types, their sizes and the problems that may arise when pushed to their limits. "
                    },
                    {
                        "username": "jayramesh0",
                        "content": "I have this weird problem where I get a timelimit exceeded  error after only passing 17 cases but other times I passed 990.  Why does this happen?"
                    }
                ]
            },
            {
                "id": 1819980,
                "content": [
                    {
                        "username": "aman3091",
                        "content": "   int divide(int dividend, int divisor) {\\n      if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n\\n        return dividend/divisor;\\n     \\n       \\n    }\\n\\nin this code why are we taking dividend ==INT_MIN not INT_MAX . pleas answer\\n"
                    },
                    {
                        "username": "rohit_gupta1001",
                        "content": "Hello everyone ,This question is asked by me in today\\'s Online assessment of Scaler."
                    },
                    {
                        "username": "RaRafiq3",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647 \\nfor this problem try this-->\\nif(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }"
                    },
                    {
                        "username": "neilkumarwb",
                        "content": "whats the point of solving these type of questions"
                    },
                    {
                        "username": "tonkei0361",
                        "content": "I was first annoyed by this question, especially when I got stuck on the 2**31-1 test case. However, after studying solutions posted by others, I feel this is an underrated question in terms of likes vs. dislikes."
                    },
                    {
                        "username": "CoderrrrMan",
                        "content": "i am gay, what the hell is that ?"
                    },
                    {
                        "username": "andysem3",
                        "content": "I REALY appreciate to this PROBLEM for my 14% acceptance rate."
                    },
                    {
                        "username": "RAJINIKANTH-KAKARLA",
                        "content": "test case2 is wrong!"
                    },
                    {
                        "username": "congener",
                        "content": "Fun problem. Definitely requires careful reading of the description, but its a valuable lesson in types, their sizes and the problems that may arise when pushed to their limits. "
                    },
                    {
                        "username": "jayramesh0",
                        "content": "I have this weird problem where I get a timelimit exceeded  error after only passing 17 cases but other times I passed 990.  Why does this happen?"
                    }
                ]
            },
            {
                "id": 1819431,
                "content": [
                    {
                        "username": "aman3091",
                        "content": "   int divide(int dividend, int divisor) {\\n      if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n\\n        return dividend/divisor;\\n     \\n       \\n    }\\n\\nin this code why are we taking dividend ==INT_MIN not INT_MAX . pleas answer\\n"
                    },
                    {
                        "username": "rohit_gupta1001",
                        "content": "Hello everyone ,This question is asked by me in today\\'s Online assessment of Scaler."
                    },
                    {
                        "username": "RaRafiq3",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647 \\nfor this problem try this-->\\nif(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }"
                    },
                    {
                        "username": "neilkumarwb",
                        "content": "whats the point of solving these type of questions"
                    },
                    {
                        "username": "tonkei0361",
                        "content": "I was first annoyed by this question, especially when I got stuck on the 2**31-1 test case. However, after studying solutions posted by others, I feel this is an underrated question in terms of likes vs. dislikes."
                    },
                    {
                        "username": "CoderrrrMan",
                        "content": "i am gay, what the hell is that ?"
                    },
                    {
                        "username": "andysem3",
                        "content": "I REALY appreciate to this PROBLEM for my 14% acceptance rate."
                    },
                    {
                        "username": "RAJINIKANTH-KAKARLA",
                        "content": "test case2 is wrong!"
                    },
                    {
                        "username": "congener",
                        "content": "Fun problem. Definitely requires careful reading of the description, but its a valuable lesson in types, their sizes and the problems that may arise when pushed to their limits. "
                    },
                    {
                        "username": "jayramesh0",
                        "content": "I have this weird problem where I get a timelimit exceeded  error after only passing 17 cases but other times I passed 990.  Why does this happen?"
                    }
                ]
            },
            {
                "id": 1818772,
                "content": [
                    {
                        "username": "aman3091",
                        "content": "   int divide(int dividend, int divisor) {\\n      if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n\\n        return dividend/divisor;\\n     \\n       \\n    }\\n\\nin this code why are we taking dividend ==INT_MIN not INT_MAX . pleas answer\\n"
                    },
                    {
                        "username": "rohit_gupta1001",
                        "content": "Hello everyone ,This question is asked by me in today\\'s Online assessment of Scaler."
                    },
                    {
                        "username": "RaRafiq3",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647 \\nfor this problem try this-->\\nif(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }"
                    },
                    {
                        "username": "neilkumarwb",
                        "content": "whats the point of solving these type of questions"
                    },
                    {
                        "username": "tonkei0361",
                        "content": "I was first annoyed by this question, especially when I got stuck on the 2**31-1 test case. However, after studying solutions posted by others, I feel this is an underrated question in terms of likes vs. dislikes."
                    },
                    {
                        "username": "CoderrrrMan",
                        "content": "i am gay, what the hell is that ?"
                    },
                    {
                        "username": "andysem3",
                        "content": "I REALY appreciate to this PROBLEM for my 14% acceptance rate."
                    },
                    {
                        "username": "RAJINIKANTH-KAKARLA",
                        "content": "test case2 is wrong!"
                    },
                    {
                        "username": "congener",
                        "content": "Fun problem. Definitely requires careful reading of the description, but its a valuable lesson in types, their sizes and the problems that may arise when pushed to their limits. "
                    },
                    {
                        "username": "jayramesh0",
                        "content": "I have this weird problem where I get a timelimit exceeded  error after only passing 17 cases but other times I passed 990.  Why does this happen?"
                    }
                ]
            },
            {
                "id": 1810021,
                "content": [
                    {
                        "username": "akashshaw01",
                        "content": "\\n#binary search simple solution\\n **take all  long datatype for integer overflow case. and another if condition for INT_MIN test case see my code below for reference**\\n\\n\\nmy code link - https://leetcode.com/problems/divide-two-integers/solutions/3216421/c-binary-search-solution-o-log-n-beginner-frindly-all-tc-handled/?orderBy=most_votes"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Why are you so mad? I solve this within 5 min. What is funny is that I took two days per problem to solve each, which is all acceptance is over 70%.  "
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "This beats 100 % on leetocode--> \\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\n  int negative=1;\\n  if(dividend==INT_MIN && divisor<0){\\n      dividend++;\\n  }\\n  if(divisor==INT_MIN && dividend<0){\\n      divisor++;\\n  }\\n  \\n  long long diviS=divisor;\\n  long long diviD=dividend;\\n\\n   if(((diviD^diviS)>0) && (diviD<0)){\\n    // cout << \"inside -> (dividend^divisor > 0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }else if((diviD^diviS)<0 && (diviD<0)){\\n    // cout << \"(dividend^divisor<0) && (dividend<0))\" << endl;\\n    diviD=-1*diviD;\\n    negative=-1;\\n    // cout << \"dividend ->\" << dividend << endl;\\n  }else if((diviD^diviS)<0 && (diviS<0)){\\n    // cout << \"(dividend^divisor<0) && (divisor<0)\" << endl;\\n    diviS=(diviS*(-1));\\n    negative=-1;\\n  }else if((diviD^diviS)==0 && (diviD<0)){\\n    // cout << \"(dividend^divisor==0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }\\n\\n\\n\\n\\n\\n  long long start=0;\\n  long long end=diviD;\\n\\n  long mid=start+(end-start)/2;\\n\\n  long ans=0;\\n  \\n  while(start<=end){\\n    if(mid*diviS==diviD){\\n      ans=mid;\\n      break;\\n    }else if(mid*diviS>diviD){\\n      end=mid-1;\\n    }else if(mid*diviS<diviD){\\n      ans=mid;\\n      start=mid+1;\\n    }\\n    mid=start+(end-start)/2;\\n  }\\n\\n    return (ans*negative);\\n}};"
                    },
                    {
                        "username": "ssgyanibaba",
                        "content": "This problem is so annoying...I just solved it but using long long int.\\nI wonder how can we solve this by only using int instead of long long int"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "I\\'m at the brink of jumping out the window. My Code works but always gets me Time Limit Exceeded \"dividend =\\n-2147483648\\ndivisor =\\n1\"\\n\\nor other problems because of the int range. I tried using if() but still getting errors. Can someone please help me?\\n\\nThis is my whole code, i tried to use int divided as long long int and normal int.\\n\\nint divide(int dividend, int divisor)\\n{\\n    long long int divided = 0;\\n    \\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divisor >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    if(divisor == 0) // durch 0 kann man nicht teilen\\n    {\\n        return 0;\\n    }\\n    else if( divisor < 0 && dividend > 0 ) // Bsp: 6 / -3 = -2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend < 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend > 0) // Bsp: 10 / 5 = 2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend - divisor;\\n            divided += 1;\\n            if(dividend < 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend < 0) // Bsp: -10 / 2 = -5\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend > 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor < 0 && dividend < 0) // Bsp: -12 / -2  = 6\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = (dividend) - (divisor);\\n            divided += 1;\\n            if(dividend > 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n\\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    return divided;\\n} "
                    },
                    {
                        "username": "dimitryku",
                        "content": "It is clearly stated, that we should not use \"multiplication, division, and mod operator\". And anyway, the most efficient submission (and the most popular too) made by using multiplication. Of cource, my solution is far from the best, I don\\'t pretending for that, but it feels unfair. "
                    },
                    {
                        "username": "andrew99154",
                        "content": "The corner cases suck. And when will a PRO engineer use these codes instead of **\" / \"**?"
                    },
                    {
                        "username": "shweta_raj",
                        "content": "my noob solution:\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend==-2147483648 and divisor==-1:\n            return 2147483647\n        if  dividend<0 and divisor<0: \n            return dividend//divisor\n        if dividend<0 or divisor<0:\n            if dividend<0 :\n                dividend=-1*dividend\n            if divisor<0:\n                divisor=-1*divisor\n            return -1*(dividend//divisor)\n        else:\n            return dividend//divisor         \n\n\n "
                    },
                    {
                        "username": "Andrew0000",
                        "content": "Does the time limit work on per case bases or the limit is set for all the cases together or both?"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == -2147483648 && divisor == -1){\\n                return 2147483647;\\n       }\\n       else{\\n       int n = dividend/divisor;\\n       return n;\\n       }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1808333,
                "content": [
                    {
                        "username": "akashshaw01",
                        "content": "\\n#binary search simple solution\\n **take all  long datatype for integer overflow case. and another if condition for INT_MIN test case see my code below for reference**\\n\\n\\nmy code link - https://leetcode.com/problems/divide-two-integers/solutions/3216421/c-binary-search-solution-o-log-n-beginner-frindly-all-tc-handled/?orderBy=most_votes"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Why are you so mad? I solve this within 5 min. What is funny is that I took two days per problem to solve each, which is all acceptance is over 70%.  "
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "This beats 100 % on leetocode--> \\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\n  int negative=1;\\n  if(dividend==INT_MIN && divisor<0){\\n      dividend++;\\n  }\\n  if(divisor==INT_MIN && dividend<0){\\n      divisor++;\\n  }\\n  \\n  long long diviS=divisor;\\n  long long diviD=dividend;\\n\\n   if(((diviD^diviS)>0) && (diviD<0)){\\n    // cout << \"inside -> (dividend^divisor > 0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }else if((diviD^diviS)<0 && (diviD<0)){\\n    // cout << \"(dividend^divisor<0) && (dividend<0))\" << endl;\\n    diviD=-1*diviD;\\n    negative=-1;\\n    // cout << \"dividend ->\" << dividend << endl;\\n  }else if((diviD^diviS)<0 && (diviS<0)){\\n    // cout << \"(dividend^divisor<0) && (divisor<0)\" << endl;\\n    diviS=(diviS*(-1));\\n    negative=-1;\\n  }else if((diviD^diviS)==0 && (diviD<0)){\\n    // cout << \"(dividend^divisor==0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }\\n\\n\\n\\n\\n\\n  long long start=0;\\n  long long end=diviD;\\n\\n  long mid=start+(end-start)/2;\\n\\n  long ans=0;\\n  \\n  while(start<=end){\\n    if(mid*diviS==diviD){\\n      ans=mid;\\n      break;\\n    }else if(mid*diviS>diviD){\\n      end=mid-1;\\n    }else if(mid*diviS<diviD){\\n      ans=mid;\\n      start=mid+1;\\n    }\\n    mid=start+(end-start)/2;\\n  }\\n\\n    return (ans*negative);\\n}};"
                    },
                    {
                        "username": "ssgyanibaba",
                        "content": "This problem is so annoying...I just solved it but using long long int.\\nI wonder how can we solve this by only using int instead of long long int"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "I\\'m at the brink of jumping out the window. My Code works but always gets me Time Limit Exceeded \"dividend =\\n-2147483648\\ndivisor =\\n1\"\\n\\nor other problems because of the int range. I tried using if() but still getting errors. Can someone please help me?\\n\\nThis is my whole code, i tried to use int divided as long long int and normal int.\\n\\nint divide(int dividend, int divisor)\\n{\\n    long long int divided = 0;\\n    \\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divisor >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    if(divisor == 0) // durch 0 kann man nicht teilen\\n    {\\n        return 0;\\n    }\\n    else if( divisor < 0 && dividend > 0 ) // Bsp: 6 / -3 = -2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend < 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend > 0) // Bsp: 10 / 5 = 2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend - divisor;\\n            divided += 1;\\n            if(dividend < 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend < 0) // Bsp: -10 / 2 = -5\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend > 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor < 0 && dividend < 0) // Bsp: -12 / -2  = 6\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = (dividend) - (divisor);\\n            divided += 1;\\n            if(dividend > 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n\\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    return divided;\\n} "
                    },
                    {
                        "username": "dimitryku",
                        "content": "It is clearly stated, that we should not use \"multiplication, division, and mod operator\". And anyway, the most efficient submission (and the most popular too) made by using multiplication. Of cource, my solution is far from the best, I don\\'t pretending for that, but it feels unfair. "
                    },
                    {
                        "username": "andrew99154",
                        "content": "The corner cases suck. And when will a PRO engineer use these codes instead of **\" / \"**?"
                    },
                    {
                        "username": "shweta_raj",
                        "content": "my noob solution:\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend==-2147483648 and divisor==-1:\n            return 2147483647\n        if  dividend<0 and divisor<0: \n            return dividend//divisor\n        if dividend<0 or divisor<0:\n            if dividend<0 :\n                dividend=-1*dividend\n            if divisor<0:\n                divisor=-1*divisor\n            return -1*(dividend//divisor)\n        else:\n            return dividend//divisor         \n\n\n "
                    },
                    {
                        "username": "Andrew0000",
                        "content": "Does the time limit work on per case bases or the limit is set for all the cases together or both?"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == -2147483648 && divisor == -1){\\n                return 2147483647;\\n       }\\n       else{\\n       int n = dividend/divisor;\\n       return n;\\n       }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1807452,
                "content": [
                    {
                        "username": "akashshaw01",
                        "content": "\\n#binary search simple solution\\n **take all  long datatype for integer overflow case. and another if condition for INT_MIN test case see my code below for reference**\\n\\n\\nmy code link - https://leetcode.com/problems/divide-two-integers/solutions/3216421/c-binary-search-solution-o-log-n-beginner-frindly-all-tc-handled/?orderBy=most_votes"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Why are you so mad? I solve this within 5 min. What is funny is that I took two days per problem to solve each, which is all acceptance is over 70%.  "
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "This beats 100 % on leetocode--> \\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\n  int negative=1;\\n  if(dividend==INT_MIN && divisor<0){\\n      dividend++;\\n  }\\n  if(divisor==INT_MIN && dividend<0){\\n      divisor++;\\n  }\\n  \\n  long long diviS=divisor;\\n  long long diviD=dividend;\\n\\n   if(((diviD^diviS)>0) && (diviD<0)){\\n    // cout << \"inside -> (dividend^divisor > 0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }else if((diviD^diviS)<0 && (diviD<0)){\\n    // cout << \"(dividend^divisor<0) && (dividend<0))\" << endl;\\n    diviD=-1*diviD;\\n    negative=-1;\\n    // cout << \"dividend ->\" << dividend << endl;\\n  }else if((diviD^diviS)<0 && (diviS<0)){\\n    // cout << \"(dividend^divisor<0) && (divisor<0)\" << endl;\\n    diviS=(diviS*(-1));\\n    negative=-1;\\n  }else if((diviD^diviS)==0 && (diviD<0)){\\n    // cout << \"(dividend^divisor==0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }\\n\\n\\n\\n\\n\\n  long long start=0;\\n  long long end=diviD;\\n\\n  long mid=start+(end-start)/2;\\n\\n  long ans=0;\\n  \\n  while(start<=end){\\n    if(mid*diviS==diviD){\\n      ans=mid;\\n      break;\\n    }else if(mid*diviS>diviD){\\n      end=mid-1;\\n    }else if(mid*diviS<diviD){\\n      ans=mid;\\n      start=mid+1;\\n    }\\n    mid=start+(end-start)/2;\\n  }\\n\\n    return (ans*negative);\\n}};"
                    },
                    {
                        "username": "ssgyanibaba",
                        "content": "This problem is so annoying...I just solved it but using long long int.\\nI wonder how can we solve this by only using int instead of long long int"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "I\\'m at the brink of jumping out the window. My Code works but always gets me Time Limit Exceeded \"dividend =\\n-2147483648\\ndivisor =\\n1\"\\n\\nor other problems because of the int range. I tried using if() but still getting errors. Can someone please help me?\\n\\nThis is my whole code, i tried to use int divided as long long int and normal int.\\n\\nint divide(int dividend, int divisor)\\n{\\n    long long int divided = 0;\\n    \\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divisor >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    if(divisor == 0) // durch 0 kann man nicht teilen\\n    {\\n        return 0;\\n    }\\n    else if( divisor < 0 && dividend > 0 ) // Bsp: 6 / -3 = -2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend < 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend > 0) // Bsp: 10 / 5 = 2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend - divisor;\\n            divided += 1;\\n            if(dividend < 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend < 0) // Bsp: -10 / 2 = -5\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend > 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor < 0 && dividend < 0) // Bsp: -12 / -2  = 6\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = (dividend) - (divisor);\\n            divided += 1;\\n            if(dividend > 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n\\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    return divided;\\n} "
                    },
                    {
                        "username": "dimitryku",
                        "content": "It is clearly stated, that we should not use \"multiplication, division, and mod operator\". And anyway, the most efficient submission (and the most popular too) made by using multiplication. Of cource, my solution is far from the best, I don\\'t pretending for that, but it feels unfair. "
                    },
                    {
                        "username": "andrew99154",
                        "content": "The corner cases suck. And when will a PRO engineer use these codes instead of **\" / \"**?"
                    },
                    {
                        "username": "shweta_raj",
                        "content": "my noob solution:\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend==-2147483648 and divisor==-1:\n            return 2147483647\n        if  dividend<0 and divisor<0: \n            return dividend//divisor\n        if dividend<0 or divisor<0:\n            if dividend<0 :\n                dividend=-1*dividend\n            if divisor<0:\n                divisor=-1*divisor\n            return -1*(dividend//divisor)\n        else:\n            return dividend//divisor         \n\n\n "
                    },
                    {
                        "username": "Andrew0000",
                        "content": "Does the time limit work on per case bases or the limit is set for all the cases together or both?"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == -2147483648 && divisor == -1){\\n                return 2147483647;\\n       }\\n       else{\\n       int n = dividend/divisor;\\n       return n;\\n       }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1804280,
                "content": [
                    {
                        "username": "akashshaw01",
                        "content": "\\n#binary search simple solution\\n **take all  long datatype for integer overflow case. and another if condition for INT_MIN test case see my code below for reference**\\n\\n\\nmy code link - https://leetcode.com/problems/divide-two-integers/solutions/3216421/c-binary-search-solution-o-log-n-beginner-frindly-all-tc-handled/?orderBy=most_votes"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Why are you so mad? I solve this within 5 min. What is funny is that I took two days per problem to solve each, which is all acceptance is over 70%.  "
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "This beats 100 % on leetocode--> \\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\n  int negative=1;\\n  if(dividend==INT_MIN && divisor<0){\\n      dividend++;\\n  }\\n  if(divisor==INT_MIN && dividend<0){\\n      divisor++;\\n  }\\n  \\n  long long diviS=divisor;\\n  long long diviD=dividend;\\n\\n   if(((diviD^diviS)>0) && (diviD<0)){\\n    // cout << \"inside -> (dividend^divisor > 0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }else if((diviD^diviS)<0 && (diviD<0)){\\n    // cout << \"(dividend^divisor<0) && (dividend<0))\" << endl;\\n    diviD=-1*diviD;\\n    negative=-1;\\n    // cout << \"dividend ->\" << dividend << endl;\\n  }else if((diviD^diviS)<0 && (diviS<0)){\\n    // cout << \"(dividend^divisor<0) && (divisor<0)\" << endl;\\n    diviS=(diviS*(-1));\\n    negative=-1;\\n  }else if((diviD^diviS)==0 && (diviD<0)){\\n    // cout << \"(dividend^divisor==0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }\\n\\n\\n\\n\\n\\n  long long start=0;\\n  long long end=diviD;\\n\\n  long mid=start+(end-start)/2;\\n\\n  long ans=0;\\n  \\n  while(start<=end){\\n    if(mid*diviS==diviD){\\n      ans=mid;\\n      break;\\n    }else if(mid*diviS>diviD){\\n      end=mid-1;\\n    }else if(mid*diviS<diviD){\\n      ans=mid;\\n      start=mid+1;\\n    }\\n    mid=start+(end-start)/2;\\n  }\\n\\n    return (ans*negative);\\n}};"
                    },
                    {
                        "username": "ssgyanibaba",
                        "content": "This problem is so annoying...I just solved it but using long long int.\\nI wonder how can we solve this by only using int instead of long long int"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "I\\'m at the brink of jumping out the window. My Code works but always gets me Time Limit Exceeded \"dividend =\\n-2147483648\\ndivisor =\\n1\"\\n\\nor other problems because of the int range. I tried using if() but still getting errors. Can someone please help me?\\n\\nThis is my whole code, i tried to use int divided as long long int and normal int.\\n\\nint divide(int dividend, int divisor)\\n{\\n    long long int divided = 0;\\n    \\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divisor >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    if(divisor == 0) // durch 0 kann man nicht teilen\\n    {\\n        return 0;\\n    }\\n    else if( divisor < 0 && dividend > 0 ) // Bsp: 6 / -3 = -2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend < 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend > 0) // Bsp: 10 / 5 = 2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend - divisor;\\n            divided += 1;\\n            if(dividend < 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend < 0) // Bsp: -10 / 2 = -5\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend > 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor < 0 && dividend < 0) // Bsp: -12 / -2  = 6\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = (dividend) - (divisor);\\n            divided += 1;\\n            if(dividend > 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n\\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    return divided;\\n} "
                    },
                    {
                        "username": "dimitryku",
                        "content": "It is clearly stated, that we should not use \"multiplication, division, and mod operator\". And anyway, the most efficient submission (and the most popular too) made by using multiplication. Of cource, my solution is far from the best, I don\\'t pretending for that, but it feels unfair. "
                    },
                    {
                        "username": "andrew99154",
                        "content": "The corner cases suck. And when will a PRO engineer use these codes instead of **\" / \"**?"
                    },
                    {
                        "username": "shweta_raj",
                        "content": "my noob solution:\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend==-2147483648 and divisor==-1:\n            return 2147483647\n        if  dividend<0 and divisor<0: \n            return dividend//divisor\n        if dividend<0 or divisor<0:\n            if dividend<0 :\n                dividend=-1*dividend\n            if divisor<0:\n                divisor=-1*divisor\n            return -1*(dividend//divisor)\n        else:\n            return dividend//divisor         \n\n\n "
                    },
                    {
                        "username": "Andrew0000",
                        "content": "Does the time limit work on per case bases or the limit is set for all the cases together or both?"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == -2147483648 && divisor == -1){\\n                return 2147483647;\\n       }\\n       else{\\n       int n = dividend/divisor;\\n       return n;\\n       }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1803658,
                "content": [
                    {
                        "username": "akashshaw01",
                        "content": "\\n#binary search simple solution\\n **take all  long datatype for integer overflow case. and another if condition for INT_MIN test case see my code below for reference**\\n\\n\\nmy code link - https://leetcode.com/problems/divide-two-integers/solutions/3216421/c-binary-search-solution-o-log-n-beginner-frindly-all-tc-handled/?orderBy=most_votes"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Why are you so mad? I solve this within 5 min. What is funny is that I took two days per problem to solve each, which is all acceptance is over 70%.  "
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "This beats 100 % on leetocode--> \\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\n  int negative=1;\\n  if(dividend==INT_MIN && divisor<0){\\n      dividend++;\\n  }\\n  if(divisor==INT_MIN && dividend<0){\\n      divisor++;\\n  }\\n  \\n  long long diviS=divisor;\\n  long long diviD=dividend;\\n\\n   if(((diviD^diviS)>0) && (diviD<0)){\\n    // cout << \"inside -> (dividend^divisor > 0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }else if((diviD^diviS)<0 && (diviD<0)){\\n    // cout << \"(dividend^divisor<0) && (dividend<0))\" << endl;\\n    diviD=-1*diviD;\\n    negative=-1;\\n    // cout << \"dividend ->\" << dividend << endl;\\n  }else if((diviD^diviS)<0 && (diviS<0)){\\n    // cout << \"(dividend^divisor<0) && (divisor<0)\" << endl;\\n    diviS=(diviS*(-1));\\n    negative=-1;\\n  }else if((diviD^diviS)==0 && (diviD<0)){\\n    // cout << \"(dividend^divisor==0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }\\n\\n\\n\\n\\n\\n  long long start=0;\\n  long long end=diviD;\\n\\n  long mid=start+(end-start)/2;\\n\\n  long ans=0;\\n  \\n  while(start<=end){\\n    if(mid*diviS==diviD){\\n      ans=mid;\\n      break;\\n    }else if(mid*diviS>diviD){\\n      end=mid-1;\\n    }else if(mid*diviS<diviD){\\n      ans=mid;\\n      start=mid+1;\\n    }\\n    mid=start+(end-start)/2;\\n  }\\n\\n    return (ans*negative);\\n}};"
                    },
                    {
                        "username": "ssgyanibaba",
                        "content": "This problem is so annoying...I just solved it but using long long int.\\nI wonder how can we solve this by only using int instead of long long int"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "I\\'m at the brink of jumping out the window. My Code works but always gets me Time Limit Exceeded \"dividend =\\n-2147483648\\ndivisor =\\n1\"\\n\\nor other problems because of the int range. I tried using if() but still getting errors. Can someone please help me?\\n\\nThis is my whole code, i tried to use int divided as long long int and normal int.\\n\\nint divide(int dividend, int divisor)\\n{\\n    long long int divided = 0;\\n    \\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divisor >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    if(divisor == 0) // durch 0 kann man nicht teilen\\n    {\\n        return 0;\\n    }\\n    else if( divisor < 0 && dividend > 0 ) // Bsp: 6 / -3 = -2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend < 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend > 0) // Bsp: 10 / 5 = 2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend - divisor;\\n            divided += 1;\\n            if(dividend < 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend < 0) // Bsp: -10 / 2 = -5\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend > 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor < 0 && dividend < 0) // Bsp: -12 / -2  = 6\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = (dividend) - (divisor);\\n            divided += 1;\\n            if(dividend > 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n\\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    return divided;\\n} "
                    },
                    {
                        "username": "dimitryku",
                        "content": "It is clearly stated, that we should not use \"multiplication, division, and mod operator\". And anyway, the most efficient submission (and the most popular too) made by using multiplication. Of cource, my solution is far from the best, I don\\'t pretending for that, but it feels unfair. "
                    },
                    {
                        "username": "andrew99154",
                        "content": "The corner cases suck. And when will a PRO engineer use these codes instead of **\" / \"**?"
                    },
                    {
                        "username": "shweta_raj",
                        "content": "my noob solution:\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend==-2147483648 and divisor==-1:\n            return 2147483647\n        if  dividend<0 and divisor<0: \n            return dividend//divisor\n        if dividend<0 or divisor<0:\n            if dividend<0 :\n                dividend=-1*dividend\n            if divisor<0:\n                divisor=-1*divisor\n            return -1*(dividend//divisor)\n        else:\n            return dividend//divisor         \n\n\n "
                    },
                    {
                        "username": "Andrew0000",
                        "content": "Does the time limit work on per case bases or the limit is set for all the cases together or both?"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == -2147483648 && divisor == -1){\\n                return 2147483647;\\n       }\\n       else{\\n       int n = dividend/divisor;\\n       return n;\\n       }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1803105,
                "content": [
                    {
                        "username": "akashshaw01",
                        "content": "\\n#binary search simple solution\\n **take all  long datatype for integer overflow case. and another if condition for INT_MIN test case see my code below for reference**\\n\\n\\nmy code link - https://leetcode.com/problems/divide-two-integers/solutions/3216421/c-binary-search-solution-o-log-n-beginner-frindly-all-tc-handled/?orderBy=most_votes"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Why are you so mad? I solve this within 5 min. What is funny is that I took two days per problem to solve each, which is all acceptance is over 70%.  "
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "This beats 100 % on leetocode--> \\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\n  int negative=1;\\n  if(dividend==INT_MIN && divisor<0){\\n      dividend++;\\n  }\\n  if(divisor==INT_MIN && dividend<0){\\n      divisor++;\\n  }\\n  \\n  long long diviS=divisor;\\n  long long diviD=dividend;\\n\\n   if(((diviD^diviS)>0) && (diviD<0)){\\n    // cout << \"inside -> (dividend^divisor > 0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }else if((diviD^diviS)<0 && (diviD<0)){\\n    // cout << \"(dividend^divisor<0) && (dividend<0))\" << endl;\\n    diviD=-1*diviD;\\n    negative=-1;\\n    // cout << \"dividend ->\" << dividend << endl;\\n  }else if((diviD^diviS)<0 && (diviS<0)){\\n    // cout << \"(dividend^divisor<0) && (divisor<0)\" << endl;\\n    diviS=(diviS*(-1));\\n    negative=-1;\\n  }else if((diviD^diviS)==0 && (diviD<0)){\\n    // cout << \"(dividend^divisor==0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }\\n\\n\\n\\n\\n\\n  long long start=0;\\n  long long end=diviD;\\n\\n  long mid=start+(end-start)/2;\\n\\n  long ans=0;\\n  \\n  while(start<=end){\\n    if(mid*diviS==diviD){\\n      ans=mid;\\n      break;\\n    }else if(mid*diviS>diviD){\\n      end=mid-1;\\n    }else if(mid*diviS<diviD){\\n      ans=mid;\\n      start=mid+1;\\n    }\\n    mid=start+(end-start)/2;\\n  }\\n\\n    return (ans*negative);\\n}};"
                    },
                    {
                        "username": "ssgyanibaba",
                        "content": "This problem is so annoying...I just solved it but using long long int.\\nI wonder how can we solve this by only using int instead of long long int"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "I\\'m at the brink of jumping out the window. My Code works but always gets me Time Limit Exceeded \"dividend =\\n-2147483648\\ndivisor =\\n1\"\\n\\nor other problems because of the int range. I tried using if() but still getting errors. Can someone please help me?\\n\\nThis is my whole code, i tried to use int divided as long long int and normal int.\\n\\nint divide(int dividend, int divisor)\\n{\\n    long long int divided = 0;\\n    \\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divisor >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    if(divisor == 0) // durch 0 kann man nicht teilen\\n    {\\n        return 0;\\n    }\\n    else if( divisor < 0 && dividend > 0 ) // Bsp: 6 / -3 = -2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend < 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend > 0) // Bsp: 10 / 5 = 2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend - divisor;\\n            divided += 1;\\n            if(dividend < 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend < 0) // Bsp: -10 / 2 = -5\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend > 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor < 0 && dividend < 0) // Bsp: -12 / -2  = 6\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = (dividend) - (divisor);\\n            divided += 1;\\n            if(dividend > 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n\\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    return divided;\\n} "
                    },
                    {
                        "username": "dimitryku",
                        "content": "It is clearly stated, that we should not use \"multiplication, division, and mod operator\". And anyway, the most efficient submission (and the most popular too) made by using multiplication. Of cource, my solution is far from the best, I don\\'t pretending for that, but it feels unfair. "
                    },
                    {
                        "username": "andrew99154",
                        "content": "The corner cases suck. And when will a PRO engineer use these codes instead of **\" / \"**?"
                    },
                    {
                        "username": "shweta_raj",
                        "content": "my noob solution:\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend==-2147483648 and divisor==-1:\n            return 2147483647\n        if  dividend<0 and divisor<0: \n            return dividend//divisor\n        if dividend<0 or divisor<0:\n            if dividend<0 :\n                dividend=-1*dividend\n            if divisor<0:\n                divisor=-1*divisor\n            return -1*(dividend//divisor)\n        else:\n            return dividend//divisor         \n\n\n "
                    },
                    {
                        "username": "Andrew0000",
                        "content": "Does the time limit work on per case bases or the limit is set for all the cases together or both?"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == -2147483648 && divisor == -1){\\n                return 2147483647;\\n       }\\n       else{\\n       int n = dividend/divisor;\\n       return n;\\n       }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1802264,
                "content": [
                    {
                        "username": "akashshaw01",
                        "content": "\\n#binary search simple solution\\n **take all  long datatype for integer overflow case. and another if condition for INT_MIN test case see my code below for reference**\\n\\n\\nmy code link - https://leetcode.com/problems/divide-two-integers/solutions/3216421/c-binary-search-solution-o-log-n-beginner-frindly-all-tc-handled/?orderBy=most_votes"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Why are you so mad? I solve this within 5 min. What is funny is that I took two days per problem to solve each, which is all acceptance is over 70%.  "
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "This beats 100 % on leetocode--> \\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\n  int negative=1;\\n  if(dividend==INT_MIN && divisor<0){\\n      dividend++;\\n  }\\n  if(divisor==INT_MIN && dividend<0){\\n      divisor++;\\n  }\\n  \\n  long long diviS=divisor;\\n  long long diviD=dividend;\\n\\n   if(((diviD^diviS)>0) && (diviD<0)){\\n    // cout << \"inside -> (dividend^divisor > 0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }else if((diviD^diviS)<0 && (diviD<0)){\\n    // cout << \"(dividend^divisor<0) && (dividend<0))\" << endl;\\n    diviD=-1*diviD;\\n    negative=-1;\\n    // cout << \"dividend ->\" << dividend << endl;\\n  }else if((diviD^diviS)<0 && (diviS<0)){\\n    // cout << \"(dividend^divisor<0) && (divisor<0)\" << endl;\\n    diviS=(diviS*(-1));\\n    negative=-1;\\n  }else if((diviD^diviS)==0 && (diviD<0)){\\n    // cout << \"(dividend^divisor==0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }\\n\\n\\n\\n\\n\\n  long long start=0;\\n  long long end=diviD;\\n\\n  long mid=start+(end-start)/2;\\n\\n  long ans=0;\\n  \\n  while(start<=end){\\n    if(mid*diviS==diviD){\\n      ans=mid;\\n      break;\\n    }else if(mid*diviS>diviD){\\n      end=mid-1;\\n    }else if(mid*diviS<diviD){\\n      ans=mid;\\n      start=mid+1;\\n    }\\n    mid=start+(end-start)/2;\\n  }\\n\\n    return (ans*negative);\\n}};"
                    },
                    {
                        "username": "ssgyanibaba",
                        "content": "This problem is so annoying...I just solved it but using long long int.\\nI wonder how can we solve this by only using int instead of long long int"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "I\\'m at the brink of jumping out the window. My Code works but always gets me Time Limit Exceeded \"dividend =\\n-2147483648\\ndivisor =\\n1\"\\n\\nor other problems because of the int range. I tried using if() but still getting errors. Can someone please help me?\\n\\nThis is my whole code, i tried to use int divided as long long int and normal int.\\n\\nint divide(int dividend, int divisor)\\n{\\n    long long int divided = 0;\\n    \\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divisor >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    if(divisor == 0) // durch 0 kann man nicht teilen\\n    {\\n        return 0;\\n    }\\n    else if( divisor < 0 && dividend > 0 ) // Bsp: 6 / -3 = -2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend < 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend > 0) // Bsp: 10 / 5 = 2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend - divisor;\\n            divided += 1;\\n            if(dividend < 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend < 0) // Bsp: -10 / 2 = -5\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend > 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor < 0 && dividend < 0) // Bsp: -12 / -2  = 6\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = (dividend) - (divisor);\\n            divided += 1;\\n            if(dividend > 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n\\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    return divided;\\n} "
                    },
                    {
                        "username": "dimitryku",
                        "content": "It is clearly stated, that we should not use \"multiplication, division, and mod operator\". And anyway, the most efficient submission (and the most popular too) made by using multiplication. Of cource, my solution is far from the best, I don\\'t pretending for that, but it feels unfair. "
                    },
                    {
                        "username": "andrew99154",
                        "content": "The corner cases suck. And when will a PRO engineer use these codes instead of **\" / \"**?"
                    },
                    {
                        "username": "shweta_raj",
                        "content": "my noob solution:\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend==-2147483648 and divisor==-1:\n            return 2147483647\n        if  dividend<0 and divisor<0: \n            return dividend//divisor\n        if dividend<0 or divisor<0:\n            if dividend<0 :\n                dividend=-1*dividend\n            if divisor<0:\n                divisor=-1*divisor\n            return -1*(dividend//divisor)\n        else:\n            return dividend//divisor         \n\n\n "
                    },
                    {
                        "username": "Andrew0000",
                        "content": "Does the time limit work on per case bases or the limit is set for all the cases together or both?"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == -2147483648 && divisor == -1){\\n                return 2147483647;\\n       }\\n       else{\\n       int n = dividend/divisor;\\n       return n;\\n       }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1797100,
                "content": [
                    {
                        "username": "akashshaw01",
                        "content": "\\n#binary search simple solution\\n **take all  long datatype for integer overflow case. and another if condition for INT_MIN test case see my code below for reference**\\n\\n\\nmy code link - https://leetcode.com/problems/divide-two-integers/solutions/3216421/c-binary-search-solution-o-log-n-beginner-frindly-all-tc-handled/?orderBy=most_votes"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Why are you so mad? I solve this within 5 min. What is funny is that I took two days per problem to solve each, which is all acceptance is over 70%.  "
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "This beats 100 % on leetocode--> \\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\n  int negative=1;\\n  if(dividend==INT_MIN && divisor<0){\\n      dividend++;\\n  }\\n  if(divisor==INT_MIN && dividend<0){\\n      divisor++;\\n  }\\n  \\n  long long diviS=divisor;\\n  long long diviD=dividend;\\n\\n   if(((diviD^diviS)>0) && (diviD<0)){\\n    // cout << \"inside -> (dividend^divisor > 0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }else if((diviD^diviS)<0 && (diviD<0)){\\n    // cout << \"(dividend^divisor<0) && (dividend<0))\" << endl;\\n    diviD=-1*diviD;\\n    negative=-1;\\n    // cout << \"dividend ->\" << dividend << endl;\\n  }else if((diviD^diviS)<0 && (diviS<0)){\\n    // cout << \"(dividend^divisor<0) && (divisor<0)\" << endl;\\n    diviS=(diviS*(-1));\\n    negative=-1;\\n  }else if((diviD^diviS)==0 && (diviD<0)){\\n    // cout << \"(dividend^divisor==0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }\\n\\n\\n\\n\\n\\n  long long start=0;\\n  long long end=diviD;\\n\\n  long mid=start+(end-start)/2;\\n\\n  long ans=0;\\n  \\n  while(start<=end){\\n    if(mid*diviS==diviD){\\n      ans=mid;\\n      break;\\n    }else if(mid*diviS>diviD){\\n      end=mid-1;\\n    }else if(mid*diviS<diviD){\\n      ans=mid;\\n      start=mid+1;\\n    }\\n    mid=start+(end-start)/2;\\n  }\\n\\n    return (ans*negative);\\n}};"
                    },
                    {
                        "username": "ssgyanibaba",
                        "content": "This problem is so annoying...I just solved it but using long long int.\\nI wonder how can we solve this by only using int instead of long long int"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "I\\'m at the brink of jumping out the window. My Code works but always gets me Time Limit Exceeded \"dividend =\\n-2147483648\\ndivisor =\\n1\"\\n\\nor other problems because of the int range. I tried using if() but still getting errors. Can someone please help me?\\n\\nThis is my whole code, i tried to use int divided as long long int and normal int.\\n\\nint divide(int dividend, int divisor)\\n{\\n    long long int divided = 0;\\n    \\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divisor >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    if(divisor == 0) // durch 0 kann man nicht teilen\\n    {\\n        return 0;\\n    }\\n    else if( divisor < 0 && dividend > 0 ) // Bsp: 6 / -3 = -2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend < 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend > 0) // Bsp: 10 / 5 = 2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend - divisor;\\n            divided += 1;\\n            if(dividend < 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend < 0) // Bsp: -10 / 2 = -5\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend > 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor < 0 && dividend < 0) // Bsp: -12 / -2  = 6\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = (dividend) - (divisor);\\n            divided += 1;\\n            if(dividend > 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n\\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    return divided;\\n} "
                    },
                    {
                        "username": "dimitryku",
                        "content": "It is clearly stated, that we should not use \"multiplication, division, and mod operator\". And anyway, the most efficient submission (and the most popular too) made by using multiplication. Of cource, my solution is far from the best, I don\\'t pretending for that, but it feels unfair. "
                    },
                    {
                        "username": "andrew99154",
                        "content": "The corner cases suck. And when will a PRO engineer use these codes instead of **\" / \"**?"
                    },
                    {
                        "username": "shweta_raj",
                        "content": "my noob solution:\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend==-2147483648 and divisor==-1:\n            return 2147483647\n        if  dividend<0 and divisor<0: \n            return dividend//divisor\n        if dividend<0 or divisor<0:\n            if dividend<0 :\n                dividend=-1*dividend\n            if divisor<0:\n                divisor=-1*divisor\n            return -1*(dividend//divisor)\n        else:\n            return dividend//divisor         \n\n\n "
                    },
                    {
                        "username": "Andrew0000",
                        "content": "Does the time limit work on per case bases or the limit is set for all the cases together or both?"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == -2147483648 && divisor == -1){\\n                return 2147483647;\\n       }\\n       else{\\n       int n = dividend/divisor;\\n       return n;\\n       }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1795698,
                "content": [
                    {
                        "username": "akashshaw01",
                        "content": "\\n#binary search simple solution\\n **take all  long datatype for integer overflow case. and another if condition for INT_MIN test case see my code below for reference**\\n\\n\\nmy code link - https://leetcode.com/problems/divide-two-integers/solutions/3216421/c-binary-search-solution-o-log-n-beginner-frindly-all-tc-handled/?orderBy=most_votes"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Why are you so mad? I solve this within 5 min. What is funny is that I took two days per problem to solve each, which is all acceptance is over 70%.  "
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "This beats 100 % on leetocode--> \\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\n  int negative=1;\\n  if(dividend==INT_MIN && divisor<0){\\n      dividend++;\\n  }\\n  if(divisor==INT_MIN && dividend<0){\\n      divisor++;\\n  }\\n  \\n  long long diviS=divisor;\\n  long long diviD=dividend;\\n\\n   if(((diviD^diviS)>0) && (diviD<0)){\\n    // cout << \"inside -> (dividend^divisor > 0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }else if((diviD^diviS)<0 && (diviD<0)){\\n    // cout << \"(dividend^divisor<0) && (dividend<0))\" << endl;\\n    diviD=-1*diviD;\\n    negative=-1;\\n    // cout << \"dividend ->\" << dividend << endl;\\n  }else if((diviD^diviS)<0 && (diviS<0)){\\n    // cout << \"(dividend^divisor<0) && (divisor<0)\" << endl;\\n    diviS=(diviS*(-1));\\n    negative=-1;\\n  }else if((diviD^diviS)==0 && (diviD<0)){\\n    // cout << \"(dividend^divisor==0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }\\n\\n\\n\\n\\n\\n  long long start=0;\\n  long long end=diviD;\\n\\n  long mid=start+(end-start)/2;\\n\\n  long ans=0;\\n  \\n  while(start<=end){\\n    if(mid*diviS==diviD){\\n      ans=mid;\\n      break;\\n    }else if(mid*diviS>diviD){\\n      end=mid-1;\\n    }else if(mid*diviS<diviD){\\n      ans=mid;\\n      start=mid+1;\\n    }\\n    mid=start+(end-start)/2;\\n  }\\n\\n    return (ans*negative);\\n}};"
                    },
                    {
                        "username": "ssgyanibaba",
                        "content": "This problem is so annoying...I just solved it but using long long int.\\nI wonder how can we solve this by only using int instead of long long int"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "I\\'m at the brink of jumping out the window. My Code works but always gets me Time Limit Exceeded \"dividend =\\n-2147483648\\ndivisor =\\n1\"\\n\\nor other problems because of the int range. I tried using if() but still getting errors. Can someone please help me?\\n\\nThis is my whole code, i tried to use int divided as long long int and normal int.\\n\\nint divide(int dividend, int divisor)\\n{\\n    long long int divided = 0;\\n    \\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divisor >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    if(divisor == 0) // durch 0 kann man nicht teilen\\n    {\\n        return 0;\\n    }\\n    else if( divisor < 0 && dividend > 0 ) // Bsp: 6 / -3 = -2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend < 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend > 0) // Bsp: 10 / 5 = 2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend - divisor;\\n            divided += 1;\\n            if(dividend < 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend < 0) // Bsp: -10 / 2 = -5\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend > 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor < 0 && dividend < 0) // Bsp: -12 / -2  = 6\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = (dividend) - (divisor);\\n            divided += 1;\\n            if(dividend > 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n\\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    return divided;\\n} "
                    },
                    {
                        "username": "dimitryku",
                        "content": "It is clearly stated, that we should not use \"multiplication, division, and mod operator\". And anyway, the most efficient submission (and the most popular too) made by using multiplication. Of cource, my solution is far from the best, I don\\'t pretending for that, but it feels unfair. "
                    },
                    {
                        "username": "andrew99154",
                        "content": "The corner cases suck. And when will a PRO engineer use these codes instead of **\" / \"**?"
                    },
                    {
                        "username": "shweta_raj",
                        "content": "my noob solution:\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend==-2147483648 and divisor==-1:\n            return 2147483647\n        if  dividend<0 and divisor<0: \n            return dividend//divisor\n        if dividend<0 or divisor<0:\n            if dividend<0 :\n                dividend=-1*dividend\n            if divisor<0:\n                divisor=-1*divisor\n            return -1*(dividend//divisor)\n        else:\n            return dividend//divisor         \n\n\n "
                    },
                    {
                        "username": "Andrew0000",
                        "content": "Does the time limit work on per case bases or the limit is set for all the cases together or both?"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == -2147483648 && divisor == -1){\\n                return 2147483647;\\n       }\\n       else{\\n       int n = dividend/divisor;\\n       return n;\\n       }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1795003,
                "content": [
                    {
                        "username": "akashshaw01",
                        "content": "\\n#binary search simple solution\\n **take all  long datatype for integer overflow case. and another if condition for INT_MIN test case see my code below for reference**\\n\\n\\nmy code link - https://leetcode.com/problems/divide-two-integers/solutions/3216421/c-binary-search-solution-o-log-n-beginner-frindly-all-tc-handled/?orderBy=most_votes"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Why are you so mad? I solve this within 5 min. What is funny is that I took two days per problem to solve each, which is all acceptance is over 70%.  "
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "This beats 100 % on leetocode--> \\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\n  int negative=1;\\n  if(dividend==INT_MIN && divisor<0){\\n      dividend++;\\n  }\\n  if(divisor==INT_MIN && dividend<0){\\n      divisor++;\\n  }\\n  \\n  long long diviS=divisor;\\n  long long diviD=dividend;\\n\\n   if(((diviD^diviS)>0) && (diviD<0)){\\n    // cout << \"inside -> (dividend^divisor > 0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }else if((diviD^diviS)<0 && (diviD<0)){\\n    // cout << \"(dividend^divisor<0) && (dividend<0))\" << endl;\\n    diviD=-1*diviD;\\n    negative=-1;\\n    // cout << \"dividend ->\" << dividend << endl;\\n  }else if((diviD^diviS)<0 && (diviS<0)){\\n    // cout << \"(dividend^divisor<0) && (divisor<0)\" << endl;\\n    diviS=(diviS*(-1));\\n    negative=-1;\\n  }else if((diviD^diviS)==0 && (diviD<0)){\\n    // cout << \"(dividend^divisor==0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }\\n\\n\\n\\n\\n\\n  long long start=0;\\n  long long end=diviD;\\n\\n  long mid=start+(end-start)/2;\\n\\n  long ans=0;\\n  \\n  while(start<=end){\\n    if(mid*diviS==diviD){\\n      ans=mid;\\n      break;\\n    }else if(mid*diviS>diviD){\\n      end=mid-1;\\n    }else if(mid*diviS<diviD){\\n      ans=mid;\\n      start=mid+1;\\n    }\\n    mid=start+(end-start)/2;\\n  }\\n\\n    return (ans*negative);\\n}};"
                    },
                    {
                        "username": "ssgyanibaba",
                        "content": "This problem is so annoying...I just solved it but using long long int.\\nI wonder how can we solve this by only using int instead of long long int"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "I\\'m at the brink of jumping out the window. My Code works but always gets me Time Limit Exceeded \"dividend =\\n-2147483648\\ndivisor =\\n1\"\\n\\nor other problems because of the int range. I tried using if() but still getting errors. Can someone please help me?\\n\\nThis is my whole code, i tried to use int divided as long long int and normal int.\\n\\nint divide(int dividend, int divisor)\\n{\\n    long long int divided = 0;\\n    \\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divisor >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    if(divisor == 0) // durch 0 kann man nicht teilen\\n    {\\n        return 0;\\n    }\\n    else if( divisor < 0 && dividend > 0 ) // Bsp: 6 / -3 = -2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend < 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend > 0) // Bsp: 10 / 5 = 2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend - divisor;\\n            divided += 1;\\n            if(dividend < 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend < 0) // Bsp: -10 / 2 = -5\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend > 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor < 0 && dividend < 0) // Bsp: -12 / -2  = 6\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = (dividend) - (divisor);\\n            divided += 1;\\n            if(dividend > 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n\\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    return divided;\\n} "
                    },
                    {
                        "username": "dimitryku",
                        "content": "It is clearly stated, that we should not use \"multiplication, division, and mod operator\". And anyway, the most efficient submission (and the most popular too) made by using multiplication. Of cource, my solution is far from the best, I don\\'t pretending for that, but it feels unfair. "
                    },
                    {
                        "username": "andrew99154",
                        "content": "The corner cases suck. And when will a PRO engineer use these codes instead of **\" / \"**?"
                    },
                    {
                        "username": "shweta_raj",
                        "content": "my noob solution:\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend==-2147483648 and divisor==-1:\n            return 2147483647\n        if  dividend<0 and divisor<0: \n            return dividend//divisor\n        if dividend<0 or divisor<0:\n            if dividend<0 :\n                dividend=-1*dividend\n            if divisor<0:\n                divisor=-1*divisor\n            return -1*(dividend//divisor)\n        else:\n            return dividend//divisor         \n\n\n "
                    },
                    {
                        "username": "Andrew0000",
                        "content": "Does the time limit work on per case bases or the limit is set for all the cases together or both?"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == -2147483648 && divisor == -1){\\n                return 2147483647;\\n       }\\n       else{\\n       int n = dividend/divisor;\\n       return n;\\n       }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1794172,
                "content": [
                    {
                        "username": "shivamtherexpandey",
                        "content": "Lets Just look at the Test Case :\\nDividend: -2147483648\\nDivisor: -1\\n\\nUse a Calculator, It\\'s a tricky problem,\\n\\n\\n\\n\\n\\n\\n\\n\\nYour Result Would be....\\n2147483648 \\nCongratulations, Your a normal intelligent person like us.\\nBUT............\\nExpected Result:\\n2147483647\\nBy Leetcode.\\n\\nMessage to Leetcode:\\nKindly Verify this Test Case as this will create issues in the future."
                    },
                    {
                        "username": "Neptuuno",
                        "content": "very annoying\\n"
                    },
                    {
                        "username": "user9215S",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIt\\'s that wrong!"
                    },
                    {
                        "username": "gk779866",
                        "content": "What could i do if encounter error with input  -2147483648, -1 and ZeroSM in runtime??\\n "
                    },
                    {
                        "username": "DLH06",
                        "content": "Can anyone tell me how I pass this thing with python xD\ndividend = -2147483648\ndivisor = -1\nOutput\n2147483648\nExpected\n2147483647"
                    },
                    {
                        "username": "Apr26",
                        "content": "It\\'s given in the question itself if the answer is less than -2147483648 return -2147483648 and if the answer is greater than 2147483647 return 2147483647"
                    },
                    {
                        "username": "podopo34",
                        "content": "Most solutions disregard the requirements that can\\'t be checked. It\\'s a shame too because the whole point of this website is to practice."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": " public int divide(int dividend, int divisor) {\\n        if(dividend==0) return 0; // corner case \\n        if(divisor==0) return Integer.MAX_VALUE; // corner case\\n        int p = 0;\\n        if(divisor==-1) return Integer.MAX_VALUE;\\n        boolean sign = (dividend<0) ^ (divisor<0); // used turnery operator for true/false\\n       dividend = Math.abs(dividend); // find absolute value\\n       divisor  = Math.abs(divisor);// find absolute value \\n       if(divisor==1){\\n           return ((sign==false)?dividend:-dividend);// after comparing\\n       }\\n    //    Basic Idea : a/b = e ln(a) / e ln(b) = e( ln(a) \\u2013 ln(b) )\\n       int ans =(int) Math.exp(Math.log(dividend)-Math.log(divisor)+0.0000000001);//\\n       return ((sign==false)?ans:-ans);"
                    },
                    {
                        "username": "dewei",
                        "content": "My thoughts on a solution:\\n1. The original problem can be mapped to only positive situation + sign manipulation. (as many solution already suggested)\\n\\nThe solution to a positive positive problem:\\n1. use bit operation to re-define a multiplication function. for example, x * 6 = x*4 + x*2 =  x * (2**2) + x * 2**1 = x >> 2 + x >> 1\\n2. use power of 2\\'s to divide the dividen range into a few sub windows. (use bit operation, x/2**k = x >>k, we can quickly find those windows.)\\n3. find the window contains divisor\\'s results, we do this by comparing divisor with the window start 2**(k) and ends 2**(k+1)\\n4. apply binary search in that window. (using the multiplication function defined in 2)\\n\\nTime complexity: log(log(N))\\nSpace complexity: O(1)"
                    },
                    {
                        "username": "vik24k",
                        "content": "\\n        total = str(eval(f\"{dividend} / {divisor}\"))\\n\\n        if int(total[:total.index(\".\")]) > pow(2, 31) -1:\\n            return pow(2, 31) -1\\n        elif int(total[:total.index(\".\")]) < -pow(2, 31):\\n            return -pow(2, 31)\\n        else:\\n            return int(total[:total.index(\".\")]) \\n\\ndoes this count? lol\\n"
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "993/994 testcases passed:\\n\\n```class Solution {\\n    public int divide(int dividend, int divisor) {\\n        int ans=dividend/divisor;\\n        return ans;\\n    }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1791787,
                "content": [
                    {
                        "username": "shivamtherexpandey",
                        "content": "Lets Just look at the Test Case :\\nDividend: -2147483648\\nDivisor: -1\\n\\nUse a Calculator, It\\'s a tricky problem,\\n\\n\\n\\n\\n\\n\\n\\n\\nYour Result Would be....\\n2147483648 \\nCongratulations, Your a normal intelligent person like us.\\nBUT............\\nExpected Result:\\n2147483647\\nBy Leetcode.\\n\\nMessage to Leetcode:\\nKindly Verify this Test Case as this will create issues in the future."
                    },
                    {
                        "username": "Neptuuno",
                        "content": "very annoying\\n"
                    },
                    {
                        "username": "user9215S",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIt\\'s that wrong!"
                    },
                    {
                        "username": "gk779866",
                        "content": "What could i do if encounter error with input  -2147483648, -1 and ZeroSM in runtime??\\n "
                    },
                    {
                        "username": "DLH06",
                        "content": "Can anyone tell me how I pass this thing with python xD\ndividend = -2147483648\ndivisor = -1\nOutput\n2147483648\nExpected\n2147483647"
                    },
                    {
                        "username": "Apr26",
                        "content": "It\\'s given in the question itself if the answer is less than -2147483648 return -2147483648 and if the answer is greater than 2147483647 return 2147483647"
                    },
                    {
                        "username": "podopo34",
                        "content": "Most solutions disregard the requirements that can\\'t be checked. It\\'s a shame too because the whole point of this website is to practice."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": " public int divide(int dividend, int divisor) {\\n        if(dividend==0) return 0; // corner case \\n        if(divisor==0) return Integer.MAX_VALUE; // corner case\\n        int p = 0;\\n        if(divisor==-1) return Integer.MAX_VALUE;\\n        boolean sign = (dividend<0) ^ (divisor<0); // used turnery operator for true/false\\n       dividend = Math.abs(dividend); // find absolute value\\n       divisor  = Math.abs(divisor);// find absolute value \\n       if(divisor==1){\\n           return ((sign==false)?dividend:-dividend);// after comparing\\n       }\\n    //    Basic Idea : a/b = e ln(a) / e ln(b) = e( ln(a) \\u2013 ln(b) )\\n       int ans =(int) Math.exp(Math.log(dividend)-Math.log(divisor)+0.0000000001);//\\n       return ((sign==false)?ans:-ans);"
                    },
                    {
                        "username": "dewei",
                        "content": "My thoughts on a solution:\\n1. The original problem can be mapped to only positive situation + sign manipulation. (as many solution already suggested)\\n\\nThe solution to a positive positive problem:\\n1. use bit operation to re-define a multiplication function. for example, x * 6 = x*4 + x*2 =  x * (2**2) + x * 2**1 = x >> 2 + x >> 1\\n2. use power of 2\\'s to divide the dividen range into a few sub windows. (use bit operation, x/2**k = x >>k, we can quickly find those windows.)\\n3. find the window contains divisor\\'s results, we do this by comparing divisor with the window start 2**(k) and ends 2**(k+1)\\n4. apply binary search in that window. (using the multiplication function defined in 2)\\n\\nTime complexity: log(log(N))\\nSpace complexity: O(1)"
                    },
                    {
                        "username": "vik24k",
                        "content": "\\n        total = str(eval(f\"{dividend} / {divisor}\"))\\n\\n        if int(total[:total.index(\".\")]) > pow(2, 31) -1:\\n            return pow(2, 31) -1\\n        elif int(total[:total.index(\".\")]) < -pow(2, 31):\\n            return -pow(2, 31)\\n        else:\\n            return int(total[:total.index(\".\")]) \\n\\ndoes this count? lol\\n"
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "993/994 testcases passed:\\n\\n```class Solution {\\n    public int divide(int dividend, int divisor) {\\n        int ans=dividend/divisor;\\n        return ans;\\n    }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1778332,
                "content": [
                    {
                        "username": "shivamtherexpandey",
                        "content": "Lets Just look at the Test Case :\\nDividend: -2147483648\\nDivisor: -1\\n\\nUse a Calculator, It\\'s a tricky problem,\\n\\n\\n\\n\\n\\n\\n\\n\\nYour Result Would be....\\n2147483648 \\nCongratulations, Your a normal intelligent person like us.\\nBUT............\\nExpected Result:\\n2147483647\\nBy Leetcode.\\n\\nMessage to Leetcode:\\nKindly Verify this Test Case as this will create issues in the future."
                    },
                    {
                        "username": "Neptuuno",
                        "content": "very annoying\\n"
                    },
                    {
                        "username": "user9215S",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIt\\'s that wrong!"
                    },
                    {
                        "username": "gk779866",
                        "content": "What could i do if encounter error with input  -2147483648, -1 and ZeroSM in runtime??\\n "
                    },
                    {
                        "username": "DLH06",
                        "content": "Can anyone tell me how I pass this thing with python xD\ndividend = -2147483648\ndivisor = -1\nOutput\n2147483648\nExpected\n2147483647"
                    },
                    {
                        "username": "Apr26",
                        "content": "It\\'s given in the question itself if the answer is less than -2147483648 return -2147483648 and if the answer is greater than 2147483647 return 2147483647"
                    },
                    {
                        "username": "podopo34",
                        "content": "Most solutions disregard the requirements that can\\'t be checked. It\\'s a shame too because the whole point of this website is to practice."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": " public int divide(int dividend, int divisor) {\\n        if(dividend==0) return 0; // corner case \\n        if(divisor==0) return Integer.MAX_VALUE; // corner case\\n        int p = 0;\\n        if(divisor==-1) return Integer.MAX_VALUE;\\n        boolean sign = (dividend<0) ^ (divisor<0); // used turnery operator for true/false\\n       dividend = Math.abs(dividend); // find absolute value\\n       divisor  = Math.abs(divisor);// find absolute value \\n       if(divisor==1){\\n           return ((sign==false)?dividend:-dividend);// after comparing\\n       }\\n    //    Basic Idea : a/b = e ln(a) / e ln(b) = e( ln(a) \\u2013 ln(b) )\\n       int ans =(int) Math.exp(Math.log(dividend)-Math.log(divisor)+0.0000000001);//\\n       return ((sign==false)?ans:-ans);"
                    },
                    {
                        "username": "dewei",
                        "content": "My thoughts on a solution:\\n1. The original problem can be mapped to only positive situation + sign manipulation. (as many solution already suggested)\\n\\nThe solution to a positive positive problem:\\n1. use bit operation to re-define a multiplication function. for example, x * 6 = x*4 + x*2 =  x * (2**2) + x * 2**1 = x >> 2 + x >> 1\\n2. use power of 2\\'s to divide the dividen range into a few sub windows. (use bit operation, x/2**k = x >>k, we can quickly find those windows.)\\n3. find the window contains divisor\\'s results, we do this by comparing divisor with the window start 2**(k) and ends 2**(k+1)\\n4. apply binary search in that window. (using the multiplication function defined in 2)\\n\\nTime complexity: log(log(N))\\nSpace complexity: O(1)"
                    },
                    {
                        "username": "vik24k",
                        "content": "\\n        total = str(eval(f\"{dividend} / {divisor}\"))\\n\\n        if int(total[:total.index(\".\")]) > pow(2, 31) -1:\\n            return pow(2, 31) -1\\n        elif int(total[:total.index(\".\")]) < -pow(2, 31):\\n            return -pow(2, 31)\\n        else:\\n            return int(total[:total.index(\".\")]) \\n\\ndoes this count? lol\\n"
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "993/994 testcases passed:\\n\\n```class Solution {\\n    public int divide(int dividend, int divisor) {\\n        int ans=dividend/divisor;\\n        return ans;\\n    }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1764711,
                "content": [
                    {
                        "username": "shivamtherexpandey",
                        "content": "Lets Just look at the Test Case :\\nDividend: -2147483648\\nDivisor: -1\\n\\nUse a Calculator, It\\'s a tricky problem,\\n\\n\\n\\n\\n\\n\\n\\n\\nYour Result Would be....\\n2147483648 \\nCongratulations, Your a normal intelligent person like us.\\nBUT............\\nExpected Result:\\n2147483647\\nBy Leetcode.\\n\\nMessage to Leetcode:\\nKindly Verify this Test Case as this will create issues in the future."
                    },
                    {
                        "username": "Neptuuno",
                        "content": "very annoying\\n"
                    },
                    {
                        "username": "user9215S",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIt\\'s that wrong!"
                    },
                    {
                        "username": "gk779866",
                        "content": "What could i do if encounter error with input  -2147483648, -1 and ZeroSM in runtime??\\n "
                    },
                    {
                        "username": "DLH06",
                        "content": "Can anyone tell me how I pass this thing with python xD\ndividend = -2147483648\ndivisor = -1\nOutput\n2147483648\nExpected\n2147483647"
                    },
                    {
                        "username": "Apr26",
                        "content": "It\\'s given in the question itself if the answer is less than -2147483648 return -2147483648 and if the answer is greater than 2147483647 return 2147483647"
                    },
                    {
                        "username": "podopo34",
                        "content": "Most solutions disregard the requirements that can\\'t be checked. It\\'s a shame too because the whole point of this website is to practice."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": " public int divide(int dividend, int divisor) {\\n        if(dividend==0) return 0; // corner case \\n        if(divisor==0) return Integer.MAX_VALUE; // corner case\\n        int p = 0;\\n        if(divisor==-1) return Integer.MAX_VALUE;\\n        boolean sign = (dividend<0) ^ (divisor<0); // used turnery operator for true/false\\n       dividend = Math.abs(dividend); // find absolute value\\n       divisor  = Math.abs(divisor);// find absolute value \\n       if(divisor==1){\\n           return ((sign==false)?dividend:-dividend);// after comparing\\n       }\\n    //    Basic Idea : a/b = e ln(a) / e ln(b) = e( ln(a) \\u2013 ln(b) )\\n       int ans =(int) Math.exp(Math.log(dividend)-Math.log(divisor)+0.0000000001);//\\n       return ((sign==false)?ans:-ans);"
                    },
                    {
                        "username": "dewei",
                        "content": "My thoughts on a solution:\\n1. The original problem can be mapped to only positive situation + sign manipulation. (as many solution already suggested)\\n\\nThe solution to a positive positive problem:\\n1. use bit operation to re-define a multiplication function. for example, x * 6 = x*4 + x*2 =  x * (2**2) + x * 2**1 = x >> 2 + x >> 1\\n2. use power of 2\\'s to divide the dividen range into a few sub windows. (use bit operation, x/2**k = x >>k, we can quickly find those windows.)\\n3. find the window contains divisor\\'s results, we do this by comparing divisor with the window start 2**(k) and ends 2**(k+1)\\n4. apply binary search in that window. (using the multiplication function defined in 2)\\n\\nTime complexity: log(log(N))\\nSpace complexity: O(1)"
                    },
                    {
                        "username": "vik24k",
                        "content": "\\n        total = str(eval(f\"{dividend} / {divisor}\"))\\n\\n        if int(total[:total.index(\".\")]) > pow(2, 31) -1:\\n            return pow(2, 31) -1\\n        elif int(total[:total.index(\".\")]) < -pow(2, 31):\\n            return -pow(2, 31)\\n        else:\\n            return int(total[:total.index(\".\")]) \\n\\ndoes this count? lol\\n"
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "993/994 testcases passed:\\n\\n```class Solution {\\n    public int divide(int dividend, int divisor) {\\n        int ans=dividend/divisor;\\n        return ans;\\n    }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1762923,
                "content": [
                    {
                        "username": "shivamtherexpandey",
                        "content": "Lets Just look at the Test Case :\\nDividend: -2147483648\\nDivisor: -1\\n\\nUse a Calculator, It\\'s a tricky problem,\\n\\n\\n\\n\\n\\n\\n\\n\\nYour Result Would be....\\n2147483648 \\nCongratulations, Your a normal intelligent person like us.\\nBUT............\\nExpected Result:\\n2147483647\\nBy Leetcode.\\n\\nMessage to Leetcode:\\nKindly Verify this Test Case as this will create issues in the future."
                    },
                    {
                        "username": "Neptuuno",
                        "content": "very annoying\\n"
                    },
                    {
                        "username": "user9215S",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIt\\'s that wrong!"
                    },
                    {
                        "username": "gk779866",
                        "content": "What could i do if encounter error with input  -2147483648, -1 and ZeroSM in runtime??\\n "
                    },
                    {
                        "username": "DLH06",
                        "content": "Can anyone tell me how I pass this thing with python xD\ndividend = -2147483648\ndivisor = -1\nOutput\n2147483648\nExpected\n2147483647"
                    },
                    {
                        "username": "Apr26",
                        "content": "It\\'s given in the question itself if the answer is less than -2147483648 return -2147483648 and if the answer is greater than 2147483647 return 2147483647"
                    },
                    {
                        "username": "podopo34",
                        "content": "Most solutions disregard the requirements that can\\'t be checked. It\\'s a shame too because the whole point of this website is to practice."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": " public int divide(int dividend, int divisor) {\\n        if(dividend==0) return 0; // corner case \\n        if(divisor==0) return Integer.MAX_VALUE; // corner case\\n        int p = 0;\\n        if(divisor==-1) return Integer.MAX_VALUE;\\n        boolean sign = (dividend<0) ^ (divisor<0); // used turnery operator for true/false\\n       dividend = Math.abs(dividend); // find absolute value\\n       divisor  = Math.abs(divisor);// find absolute value \\n       if(divisor==1){\\n           return ((sign==false)?dividend:-dividend);// after comparing\\n       }\\n    //    Basic Idea : a/b = e ln(a) / e ln(b) = e( ln(a) \\u2013 ln(b) )\\n       int ans =(int) Math.exp(Math.log(dividend)-Math.log(divisor)+0.0000000001);//\\n       return ((sign==false)?ans:-ans);"
                    },
                    {
                        "username": "dewei",
                        "content": "My thoughts on a solution:\\n1. The original problem can be mapped to only positive situation + sign manipulation. (as many solution already suggested)\\n\\nThe solution to a positive positive problem:\\n1. use bit operation to re-define a multiplication function. for example, x * 6 = x*4 + x*2 =  x * (2**2) + x * 2**1 = x >> 2 + x >> 1\\n2. use power of 2\\'s to divide the dividen range into a few sub windows. (use bit operation, x/2**k = x >>k, we can quickly find those windows.)\\n3. find the window contains divisor\\'s results, we do this by comparing divisor with the window start 2**(k) and ends 2**(k+1)\\n4. apply binary search in that window. (using the multiplication function defined in 2)\\n\\nTime complexity: log(log(N))\\nSpace complexity: O(1)"
                    },
                    {
                        "username": "vik24k",
                        "content": "\\n        total = str(eval(f\"{dividend} / {divisor}\"))\\n\\n        if int(total[:total.index(\".\")]) > pow(2, 31) -1:\\n            return pow(2, 31) -1\\n        elif int(total[:total.index(\".\")]) < -pow(2, 31):\\n            return -pow(2, 31)\\n        else:\\n            return int(total[:total.index(\".\")]) \\n\\ndoes this count? lol\\n"
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "993/994 testcases passed:\\n\\n```class Solution {\\n    public int divide(int dividend, int divisor) {\\n        int ans=dividend/divisor;\\n        return ans;\\n    }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1761438,
                "content": [
                    {
                        "username": "shivamtherexpandey",
                        "content": "Lets Just look at the Test Case :\\nDividend: -2147483648\\nDivisor: -1\\n\\nUse a Calculator, It\\'s a tricky problem,\\n\\n\\n\\n\\n\\n\\n\\n\\nYour Result Would be....\\n2147483648 \\nCongratulations, Your a normal intelligent person like us.\\nBUT............\\nExpected Result:\\n2147483647\\nBy Leetcode.\\n\\nMessage to Leetcode:\\nKindly Verify this Test Case as this will create issues in the future."
                    },
                    {
                        "username": "Neptuuno",
                        "content": "very annoying\\n"
                    },
                    {
                        "username": "user9215S",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIt\\'s that wrong!"
                    },
                    {
                        "username": "gk779866",
                        "content": "What could i do if encounter error with input  -2147483648, -1 and ZeroSM in runtime??\\n "
                    },
                    {
                        "username": "DLH06",
                        "content": "Can anyone tell me how I pass this thing with python xD\ndividend = -2147483648\ndivisor = -1\nOutput\n2147483648\nExpected\n2147483647"
                    },
                    {
                        "username": "Apr26",
                        "content": "It\\'s given in the question itself if the answer is less than -2147483648 return -2147483648 and if the answer is greater than 2147483647 return 2147483647"
                    },
                    {
                        "username": "podopo34",
                        "content": "Most solutions disregard the requirements that can\\'t be checked. It\\'s a shame too because the whole point of this website is to practice."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": " public int divide(int dividend, int divisor) {\\n        if(dividend==0) return 0; // corner case \\n        if(divisor==0) return Integer.MAX_VALUE; // corner case\\n        int p = 0;\\n        if(divisor==-1) return Integer.MAX_VALUE;\\n        boolean sign = (dividend<0) ^ (divisor<0); // used turnery operator for true/false\\n       dividend = Math.abs(dividend); // find absolute value\\n       divisor  = Math.abs(divisor);// find absolute value \\n       if(divisor==1){\\n           return ((sign==false)?dividend:-dividend);// after comparing\\n       }\\n    //    Basic Idea : a/b = e ln(a) / e ln(b) = e( ln(a) \\u2013 ln(b) )\\n       int ans =(int) Math.exp(Math.log(dividend)-Math.log(divisor)+0.0000000001);//\\n       return ((sign==false)?ans:-ans);"
                    },
                    {
                        "username": "dewei",
                        "content": "My thoughts on a solution:\\n1. The original problem can be mapped to only positive situation + sign manipulation. (as many solution already suggested)\\n\\nThe solution to a positive positive problem:\\n1. use bit operation to re-define a multiplication function. for example, x * 6 = x*4 + x*2 =  x * (2**2) + x * 2**1 = x >> 2 + x >> 1\\n2. use power of 2\\'s to divide the dividen range into a few sub windows. (use bit operation, x/2**k = x >>k, we can quickly find those windows.)\\n3. find the window contains divisor\\'s results, we do this by comparing divisor with the window start 2**(k) and ends 2**(k+1)\\n4. apply binary search in that window. (using the multiplication function defined in 2)\\n\\nTime complexity: log(log(N))\\nSpace complexity: O(1)"
                    },
                    {
                        "username": "vik24k",
                        "content": "\\n        total = str(eval(f\"{dividend} / {divisor}\"))\\n\\n        if int(total[:total.index(\".\")]) > pow(2, 31) -1:\\n            return pow(2, 31) -1\\n        elif int(total[:total.index(\".\")]) < -pow(2, 31):\\n            return -pow(2, 31)\\n        else:\\n            return int(total[:total.index(\".\")]) \\n\\ndoes this count? lol\\n"
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "993/994 testcases passed:\\n\\n```class Solution {\\n    public int divide(int dividend, int divisor) {\\n        int ans=dividend/divisor;\\n        return ans;\\n    }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1757201,
                "content": [
                    {
                        "username": "shivamtherexpandey",
                        "content": "Lets Just look at the Test Case :\\nDividend: -2147483648\\nDivisor: -1\\n\\nUse a Calculator, It\\'s a tricky problem,\\n\\n\\n\\n\\n\\n\\n\\n\\nYour Result Would be....\\n2147483648 \\nCongratulations, Your a normal intelligent person like us.\\nBUT............\\nExpected Result:\\n2147483647\\nBy Leetcode.\\n\\nMessage to Leetcode:\\nKindly Verify this Test Case as this will create issues in the future."
                    },
                    {
                        "username": "Neptuuno",
                        "content": "very annoying\\n"
                    },
                    {
                        "username": "user9215S",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIt\\'s that wrong!"
                    },
                    {
                        "username": "gk779866",
                        "content": "What could i do if encounter error with input  -2147483648, -1 and ZeroSM in runtime??\\n "
                    },
                    {
                        "username": "DLH06",
                        "content": "Can anyone tell me how I pass this thing with python xD\ndividend = -2147483648\ndivisor = -1\nOutput\n2147483648\nExpected\n2147483647"
                    },
                    {
                        "username": "Apr26",
                        "content": "It\\'s given in the question itself if the answer is less than -2147483648 return -2147483648 and if the answer is greater than 2147483647 return 2147483647"
                    },
                    {
                        "username": "podopo34",
                        "content": "Most solutions disregard the requirements that can\\'t be checked. It\\'s a shame too because the whole point of this website is to practice."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": " public int divide(int dividend, int divisor) {\\n        if(dividend==0) return 0; // corner case \\n        if(divisor==0) return Integer.MAX_VALUE; // corner case\\n        int p = 0;\\n        if(divisor==-1) return Integer.MAX_VALUE;\\n        boolean sign = (dividend<0) ^ (divisor<0); // used turnery operator for true/false\\n       dividend = Math.abs(dividend); // find absolute value\\n       divisor  = Math.abs(divisor);// find absolute value \\n       if(divisor==1){\\n           return ((sign==false)?dividend:-dividend);// after comparing\\n       }\\n    //    Basic Idea : a/b = e ln(a) / e ln(b) = e( ln(a) \\u2013 ln(b) )\\n       int ans =(int) Math.exp(Math.log(dividend)-Math.log(divisor)+0.0000000001);//\\n       return ((sign==false)?ans:-ans);"
                    },
                    {
                        "username": "dewei",
                        "content": "My thoughts on a solution:\\n1. The original problem can be mapped to only positive situation + sign manipulation. (as many solution already suggested)\\n\\nThe solution to a positive positive problem:\\n1. use bit operation to re-define a multiplication function. for example, x * 6 = x*4 + x*2 =  x * (2**2) + x * 2**1 = x >> 2 + x >> 1\\n2. use power of 2\\'s to divide the dividen range into a few sub windows. (use bit operation, x/2**k = x >>k, we can quickly find those windows.)\\n3. find the window contains divisor\\'s results, we do this by comparing divisor with the window start 2**(k) and ends 2**(k+1)\\n4. apply binary search in that window. (using the multiplication function defined in 2)\\n\\nTime complexity: log(log(N))\\nSpace complexity: O(1)"
                    },
                    {
                        "username": "vik24k",
                        "content": "\\n        total = str(eval(f\"{dividend} / {divisor}\"))\\n\\n        if int(total[:total.index(\".\")]) > pow(2, 31) -1:\\n            return pow(2, 31) -1\\n        elif int(total[:total.index(\".\")]) < -pow(2, 31):\\n            return -pow(2, 31)\\n        else:\\n            return int(total[:total.index(\".\")]) \\n\\ndoes this count? lol\\n"
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "993/994 testcases passed:\\n\\n```class Solution {\\n    public int divide(int dividend, int divisor) {\\n        int ans=dividend/divisor;\\n        return ans;\\n    }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1754878,
                "content": [
                    {
                        "username": "shivamtherexpandey",
                        "content": "Lets Just look at the Test Case :\\nDividend: -2147483648\\nDivisor: -1\\n\\nUse a Calculator, It\\'s a tricky problem,\\n\\n\\n\\n\\n\\n\\n\\n\\nYour Result Would be....\\n2147483648 \\nCongratulations, Your a normal intelligent person like us.\\nBUT............\\nExpected Result:\\n2147483647\\nBy Leetcode.\\n\\nMessage to Leetcode:\\nKindly Verify this Test Case as this will create issues in the future."
                    },
                    {
                        "username": "Neptuuno",
                        "content": "very annoying\\n"
                    },
                    {
                        "username": "user9215S",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIt\\'s that wrong!"
                    },
                    {
                        "username": "gk779866",
                        "content": "What could i do if encounter error with input  -2147483648, -1 and ZeroSM in runtime??\\n "
                    },
                    {
                        "username": "DLH06",
                        "content": "Can anyone tell me how I pass this thing with python xD\ndividend = -2147483648\ndivisor = -1\nOutput\n2147483648\nExpected\n2147483647"
                    },
                    {
                        "username": "Apr26",
                        "content": "It\\'s given in the question itself if the answer is less than -2147483648 return -2147483648 and if the answer is greater than 2147483647 return 2147483647"
                    },
                    {
                        "username": "podopo34",
                        "content": "Most solutions disregard the requirements that can\\'t be checked. It\\'s a shame too because the whole point of this website is to practice."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": " public int divide(int dividend, int divisor) {\\n        if(dividend==0) return 0; // corner case \\n        if(divisor==0) return Integer.MAX_VALUE; // corner case\\n        int p = 0;\\n        if(divisor==-1) return Integer.MAX_VALUE;\\n        boolean sign = (dividend<0) ^ (divisor<0); // used turnery operator for true/false\\n       dividend = Math.abs(dividend); // find absolute value\\n       divisor  = Math.abs(divisor);// find absolute value \\n       if(divisor==1){\\n           return ((sign==false)?dividend:-dividend);// after comparing\\n       }\\n    //    Basic Idea : a/b = e ln(a) / e ln(b) = e( ln(a) \\u2013 ln(b) )\\n       int ans =(int) Math.exp(Math.log(dividend)-Math.log(divisor)+0.0000000001);//\\n       return ((sign==false)?ans:-ans);"
                    },
                    {
                        "username": "dewei",
                        "content": "My thoughts on a solution:\\n1. The original problem can be mapped to only positive situation + sign manipulation. (as many solution already suggested)\\n\\nThe solution to a positive positive problem:\\n1. use bit operation to re-define a multiplication function. for example, x * 6 = x*4 + x*2 =  x * (2**2) + x * 2**1 = x >> 2 + x >> 1\\n2. use power of 2\\'s to divide the dividen range into a few sub windows. (use bit operation, x/2**k = x >>k, we can quickly find those windows.)\\n3. find the window contains divisor\\'s results, we do this by comparing divisor with the window start 2**(k) and ends 2**(k+1)\\n4. apply binary search in that window. (using the multiplication function defined in 2)\\n\\nTime complexity: log(log(N))\\nSpace complexity: O(1)"
                    },
                    {
                        "username": "vik24k",
                        "content": "\\n        total = str(eval(f\"{dividend} / {divisor}\"))\\n\\n        if int(total[:total.index(\".\")]) > pow(2, 31) -1:\\n            return pow(2, 31) -1\\n        elif int(total[:total.index(\".\")]) < -pow(2, 31):\\n            return -pow(2, 31)\\n        else:\\n            return int(total[:total.index(\".\")]) \\n\\ndoes this count? lol\\n"
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "993/994 testcases passed:\\n\\n```class Solution {\\n    public int divide(int dividend, int divisor) {\\n        int ans=dividend/divisor;\\n        return ans;\\n    }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1753143,
                "content": [
                    {
                        "username": "shivamtherexpandey",
                        "content": "Lets Just look at the Test Case :\\nDividend: -2147483648\\nDivisor: -1\\n\\nUse a Calculator, It\\'s a tricky problem,\\n\\n\\n\\n\\n\\n\\n\\n\\nYour Result Would be....\\n2147483648 \\nCongratulations, Your a normal intelligent person like us.\\nBUT............\\nExpected Result:\\n2147483647\\nBy Leetcode.\\n\\nMessage to Leetcode:\\nKindly Verify this Test Case as this will create issues in the future."
                    },
                    {
                        "username": "Neptuuno",
                        "content": "very annoying\\n"
                    },
                    {
                        "username": "user9215S",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIt\\'s that wrong!"
                    },
                    {
                        "username": "gk779866",
                        "content": "What could i do if encounter error with input  -2147483648, -1 and ZeroSM in runtime??\\n "
                    },
                    {
                        "username": "DLH06",
                        "content": "Can anyone tell me how I pass this thing with python xD\ndividend = -2147483648\ndivisor = -1\nOutput\n2147483648\nExpected\n2147483647"
                    },
                    {
                        "username": "Apr26",
                        "content": "It\\'s given in the question itself if the answer is less than -2147483648 return -2147483648 and if the answer is greater than 2147483647 return 2147483647"
                    },
                    {
                        "username": "podopo34",
                        "content": "Most solutions disregard the requirements that can\\'t be checked. It\\'s a shame too because the whole point of this website is to practice."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": " public int divide(int dividend, int divisor) {\\n        if(dividend==0) return 0; // corner case \\n        if(divisor==0) return Integer.MAX_VALUE; // corner case\\n        int p = 0;\\n        if(divisor==-1) return Integer.MAX_VALUE;\\n        boolean sign = (dividend<0) ^ (divisor<0); // used turnery operator for true/false\\n       dividend = Math.abs(dividend); // find absolute value\\n       divisor  = Math.abs(divisor);// find absolute value \\n       if(divisor==1){\\n           return ((sign==false)?dividend:-dividend);// after comparing\\n       }\\n    //    Basic Idea : a/b = e ln(a) / e ln(b) = e( ln(a) \\u2013 ln(b) )\\n       int ans =(int) Math.exp(Math.log(dividend)-Math.log(divisor)+0.0000000001);//\\n       return ((sign==false)?ans:-ans);"
                    },
                    {
                        "username": "dewei",
                        "content": "My thoughts on a solution:\\n1. The original problem can be mapped to only positive situation + sign manipulation. (as many solution already suggested)\\n\\nThe solution to a positive positive problem:\\n1. use bit operation to re-define a multiplication function. for example, x * 6 = x*4 + x*2 =  x * (2**2) + x * 2**1 = x >> 2 + x >> 1\\n2. use power of 2\\'s to divide the dividen range into a few sub windows. (use bit operation, x/2**k = x >>k, we can quickly find those windows.)\\n3. find the window contains divisor\\'s results, we do this by comparing divisor with the window start 2**(k) and ends 2**(k+1)\\n4. apply binary search in that window. (using the multiplication function defined in 2)\\n\\nTime complexity: log(log(N))\\nSpace complexity: O(1)"
                    },
                    {
                        "username": "vik24k",
                        "content": "\\n        total = str(eval(f\"{dividend} / {divisor}\"))\\n\\n        if int(total[:total.index(\".\")]) > pow(2, 31) -1:\\n            return pow(2, 31) -1\\n        elif int(total[:total.index(\".\")]) < -pow(2, 31):\\n            return -pow(2, 31)\\n        else:\\n            return int(total[:total.index(\".\")]) \\n\\ndoes this count? lol\\n"
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "993/994 testcases passed:\\n\\n```class Solution {\\n    public int divide(int dividend, int divisor) {\\n        int ans=dividend/divisor;\\n        return ans;\\n    }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1752956,
                "content": [
                    {
                        "username": "shivamtherexpandey",
                        "content": "Lets Just look at the Test Case :\\nDividend: -2147483648\\nDivisor: -1\\n\\nUse a Calculator, It\\'s a tricky problem,\\n\\n\\n\\n\\n\\n\\n\\n\\nYour Result Would be....\\n2147483648 \\nCongratulations, Your a normal intelligent person like us.\\nBUT............\\nExpected Result:\\n2147483647\\nBy Leetcode.\\n\\nMessage to Leetcode:\\nKindly Verify this Test Case as this will create issues in the future."
                    },
                    {
                        "username": "Neptuuno",
                        "content": "very annoying\\n"
                    },
                    {
                        "username": "user9215S",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIt\\'s that wrong!"
                    },
                    {
                        "username": "gk779866",
                        "content": "What could i do if encounter error with input  -2147483648, -1 and ZeroSM in runtime??\\n "
                    },
                    {
                        "username": "DLH06",
                        "content": "Can anyone tell me how I pass this thing with python xD\ndividend = -2147483648\ndivisor = -1\nOutput\n2147483648\nExpected\n2147483647"
                    },
                    {
                        "username": "Apr26",
                        "content": "It\\'s given in the question itself if the answer is less than -2147483648 return -2147483648 and if the answer is greater than 2147483647 return 2147483647"
                    },
                    {
                        "username": "podopo34",
                        "content": "Most solutions disregard the requirements that can\\'t be checked. It\\'s a shame too because the whole point of this website is to practice."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": " public int divide(int dividend, int divisor) {\\n        if(dividend==0) return 0; // corner case \\n        if(divisor==0) return Integer.MAX_VALUE; // corner case\\n        int p = 0;\\n        if(divisor==-1) return Integer.MAX_VALUE;\\n        boolean sign = (dividend<0) ^ (divisor<0); // used turnery operator for true/false\\n       dividend = Math.abs(dividend); // find absolute value\\n       divisor  = Math.abs(divisor);// find absolute value \\n       if(divisor==1){\\n           return ((sign==false)?dividend:-dividend);// after comparing\\n       }\\n    //    Basic Idea : a/b = e ln(a) / e ln(b) = e( ln(a) \\u2013 ln(b) )\\n       int ans =(int) Math.exp(Math.log(dividend)-Math.log(divisor)+0.0000000001);//\\n       return ((sign==false)?ans:-ans);"
                    },
                    {
                        "username": "dewei",
                        "content": "My thoughts on a solution:\\n1. The original problem can be mapped to only positive situation + sign manipulation. (as many solution already suggested)\\n\\nThe solution to a positive positive problem:\\n1. use bit operation to re-define a multiplication function. for example, x * 6 = x*4 + x*2 =  x * (2**2) + x * 2**1 = x >> 2 + x >> 1\\n2. use power of 2\\'s to divide the dividen range into a few sub windows. (use bit operation, x/2**k = x >>k, we can quickly find those windows.)\\n3. find the window contains divisor\\'s results, we do this by comparing divisor with the window start 2**(k) and ends 2**(k+1)\\n4. apply binary search in that window. (using the multiplication function defined in 2)\\n\\nTime complexity: log(log(N))\\nSpace complexity: O(1)"
                    },
                    {
                        "username": "vik24k",
                        "content": "\\n        total = str(eval(f\"{dividend} / {divisor}\"))\\n\\n        if int(total[:total.index(\".\")]) > pow(2, 31) -1:\\n            return pow(2, 31) -1\\n        elif int(total[:total.index(\".\")]) < -pow(2, 31):\\n            return -pow(2, 31)\\n        else:\\n            return int(total[:total.index(\".\")]) \\n\\ndoes this count? lol\\n"
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "993/994 testcases passed:\\n\\n```class Solution {\\n    public int divide(int dividend, int divisor) {\\n        int ans=dividend/divisor;\\n        return ans;\\n    }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1751661,
                "content": [
                    {
                        "username": "om_2209",
                        "content": "Same code is working in Java but not in CPP"
                    },
                    {
                        "username": "Konduru_sai",
                        "content": "  if divisor==0:\\n            return 0\\n        if divisor <0 and dividend<0:\\n            D=(dividend//divisor)\\n            if D>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return D\\n        elif (divisor<0 and dividend>0) or (divisor>0 and dividend<0):\\n            A=abs(divisor)\\n            E=abs(dividend)\\n            b=-(E//A)\\n            if b<=-2**31:\\n                return -2**31\\n            else:\\n                return b\\n            return -(dividend//A)\\n        else:\\n            c=int(dividend//divisor)\\n            if c>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return c"
                    },
                    {
                        "username": "tarikin",
                        "content": "-2147483648 / -1 = 2147483647, yes Leet this makes a lot sense"
                    },
                    {
                        "username": "trantatxep",
                        "content": "Input\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nWhat problems ? I have only case "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "wtf???\\n\\nTime Limit Exceeded\\nLast Executed Input\\n994 / 994 testcases passed\\ndividend =\\n\\nWhat is the input???"
                    },
                    {
                        "username": "Rohit_Singhal_0904",
                        "content": "Wrong Answer\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n-2147483648\\nExpected\\n2147483647"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/29_devide_2_int.cpp"
                    },
                    {
                        "username": "kSt_how",
                        "content": "why c++ example code is ruby ?"
                    },
                    {
                        "username": "Neo_09",
                        "content": "The test case\\n-2147483648\\n1\\nruns absolutely fine and shows the correct ans.\\nBut as soon as I submit it, the same test case shows time limit exceeded.\\nWhy?"
                    },
                    {
                        "username": "shivangshrivastavaprogramming",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend==-2147483648 && divisor==-1){\\n            return 2147483647;\\n        }\\n        return dividend/divisor;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1740547,
                "content": [
                    {
                        "username": "om_2209",
                        "content": "Same code is working in Java but not in CPP"
                    },
                    {
                        "username": "Konduru_sai",
                        "content": "  if divisor==0:\\n            return 0\\n        if divisor <0 and dividend<0:\\n            D=(dividend//divisor)\\n            if D>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return D\\n        elif (divisor<0 and dividend>0) or (divisor>0 and dividend<0):\\n            A=abs(divisor)\\n            E=abs(dividend)\\n            b=-(E//A)\\n            if b<=-2**31:\\n                return -2**31\\n            else:\\n                return b\\n            return -(dividend//A)\\n        else:\\n            c=int(dividend//divisor)\\n            if c>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return c"
                    },
                    {
                        "username": "tarikin",
                        "content": "-2147483648 / -1 = 2147483647, yes Leet this makes a lot sense"
                    },
                    {
                        "username": "trantatxep",
                        "content": "Input\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nWhat problems ? I have only case "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "wtf???\\n\\nTime Limit Exceeded\\nLast Executed Input\\n994 / 994 testcases passed\\ndividend =\\n\\nWhat is the input???"
                    },
                    {
                        "username": "Rohit_Singhal_0904",
                        "content": "Wrong Answer\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n-2147483648\\nExpected\\n2147483647"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/29_devide_2_int.cpp"
                    },
                    {
                        "username": "kSt_how",
                        "content": "why c++ example code is ruby ?"
                    },
                    {
                        "username": "Neo_09",
                        "content": "The test case\\n-2147483648\\n1\\nruns absolutely fine and shows the correct ans.\\nBut as soon as I submit it, the same test case shows time limit exceeded.\\nWhy?"
                    },
                    {
                        "username": "shivangshrivastavaprogramming",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend==-2147483648 && divisor==-1){\\n            return 2147483647;\\n        }\\n        return dividend/divisor;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1734768,
                "content": [
                    {
                        "username": "om_2209",
                        "content": "Same code is working in Java but not in CPP"
                    },
                    {
                        "username": "Konduru_sai",
                        "content": "  if divisor==0:\\n            return 0\\n        if divisor <0 and dividend<0:\\n            D=(dividend//divisor)\\n            if D>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return D\\n        elif (divisor<0 and dividend>0) or (divisor>0 and dividend<0):\\n            A=abs(divisor)\\n            E=abs(dividend)\\n            b=-(E//A)\\n            if b<=-2**31:\\n                return -2**31\\n            else:\\n                return b\\n            return -(dividend//A)\\n        else:\\n            c=int(dividend//divisor)\\n            if c>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return c"
                    },
                    {
                        "username": "tarikin",
                        "content": "-2147483648 / -1 = 2147483647, yes Leet this makes a lot sense"
                    },
                    {
                        "username": "trantatxep",
                        "content": "Input\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nWhat problems ? I have only case "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "wtf???\\n\\nTime Limit Exceeded\\nLast Executed Input\\n994 / 994 testcases passed\\ndividend =\\n\\nWhat is the input???"
                    },
                    {
                        "username": "Rohit_Singhal_0904",
                        "content": "Wrong Answer\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n-2147483648\\nExpected\\n2147483647"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/29_devide_2_int.cpp"
                    },
                    {
                        "username": "kSt_how",
                        "content": "why c++ example code is ruby ?"
                    },
                    {
                        "username": "Neo_09",
                        "content": "The test case\\n-2147483648\\n1\\nruns absolutely fine and shows the correct ans.\\nBut as soon as I submit it, the same test case shows time limit exceeded.\\nWhy?"
                    },
                    {
                        "username": "shivangshrivastavaprogramming",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend==-2147483648 && divisor==-1){\\n            return 2147483647;\\n        }\\n        return dividend/divisor;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1731871,
                "content": [
                    {
                        "username": "om_2209",
                        "content": "Same code is working in Java but not in CPP"
                    },
                    {
                        "username": "Konduru_sai",
                        "content": "  if divisor==0:\\n            return 0\\n        if divisor <0 and dividend<0:\\n            D=(dividend//divisor)\\n            if D>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return D\\n        elif (divisor<0 and dividend>0) or (divisor>0 and dividend<0):\\n            A=abs(divisor)\\n            E=abs(dividend)\\n            b=-(E//A)\\n            if b<=-2**31:\\n                return -2**31\\n            else:\\n                return b\\n            return -(dividend//A)\\n        else:\\n            c=int(dividend//divisor)\\n            if c>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return c"
                    },
                    {
                        "username": "tarikin",
                        "content": "-2147483648 / -1 = 2147483647, yes Leet this makes a lot sense"
                    },
                    {
                        "username": "trantatxep",
                        "content": "Input\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nWhat problems ? I have only case "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "wtf???\\n\\nTime Limit Exceeded\\nLast Executed Input\\n994 / 994 testcases passed\\ndividend =\\n\\nWhat is the input???"
                    },
                    {
                        "username": "Rohit_Singhal_0904",
                        "content": "Wrong Answer\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n-2147483648\\nExpected\\n2147483647"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/29_devide_2_int.cpp"
                    },
                    {
                        "username": "kSt_how",
                        "content": "why c++ example code is ruby ?"
                    },
                    {
                        "username": "Neo_09",
                        "content": "The test case\\n-2147483648\\n1\\nruns absolutely fine and shows the correct ans.\\nBut as soon as I submit it, the same test case shows time limit exceeded.\\nWhy?"
                    },
                    {
                        "username": "shivangshrivastavaprogramming",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend==-2147483648 && divisor==-1){\\n            return 2147483647;\\n        }\\n        return dividend/divisor;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1729208,
                "content": [
                    {
                        "username": "om_2209",
                        "content": "Same code is working in Java but not in CPP"
                    },
                    {
                        "username": "Konduru_sai",
                        "content": "  if divisor==0:\\n            return 0\\n        if divisor <0 and dividend<0:\\n            D=(dividend//divisor)\\n            if D>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return D\\n        elif (divisor<0 and dividend>0) or (divisor>0 and dividend<0):\\n            A=abs(divisor)\\n            E=abs(dividend)\\n            b=-(E//A)\\n            if b<=-2**31:\\n                return -2**31\\n            else:\\n                return b\\n            return -(dividend//A)\\n        else:\\n            c=int(dividend//divisor)\\n            if c>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return c"
                    },
                    {
                        "username": "tarikin",
                        "content": "-2147483648 / -1 = 2147483647, yes Leet this makes a lot sense"
                    },
                    {
                        "username": "trantatxep",
                        "content": "Input\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nWhat problems ? I have only case "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "wtf???\\n\\nTime Limit Exceeded\\nLast Executed Input\\n994 / 994 testcases passed\\ndividend =\\n\\nWhat is the input???"
                    },
                    {
                        "username": "Rohit_Singhal_0904",
                        "content": "Wrong Answer\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n-2147483648\\nExpected\\n2147483647"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/29_devide_2_int.cpp"
                    },
                    {
                        "username": "kSt_how",
                        "content": "why c++ example code is ruby ?"
                    },
                    {
                        "username": "Neo_09",
                        "content": "The test case\\n-2147483648\\n1\\nruns absolutely fine and shows the correct ans.\\nBut as soon as I submit it, the same test case shows time limit exceeded.\\nWhy?"
                    },
                    {
                        "username": "shivangshrivastavaprogramming",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend==-2147483648 && divisor==-1){\\n            return 2147483647;\\n        }\\n        return dividend/divisor;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1729170,
                "content": [
                    {
                        "username": "om_2209",
                        "content": "Same code is working in Java but not in CPP"
                    },
                    {
                        "username": "Konduru_sai",
                        "content": "  if divisor==0:\\n            return 0\\n        if divisor <0 and dividend<0:\\n            D=(dividend//divisor)\\n            if D>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return D\\n        elif (divisor<0 and dividend>0) or (divisor>0 and dividend<0):\\n            A=abs(divisor)\\n            E=abs(dividend)\\n            b=-(E//A)\\n            if b<=-2**31:\\n                return -2**31\\n            else:\\n                return b\\n            return -(dividend//A)\\n        else:\\n            c=int(dividend//divisor)\\n            if c>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return c"
                    },
                    {
                        "username": "tarikin",
                        "content": "-2147483648 / -1 = 2147483647, yes Leet this makes a lot sense"
                    },
                    {
                        "username": "trantatxep",
                        "content": "Input\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nWhat problems ? I have only case "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "wtf???\\n\\nTime Limit Exceeded\\nLast Executed Input\\n994 / 994 testcases passed\\ndividend =\\n\\nWhat is the input???"
                    },
                    {
                        "username": "Rohit_Singhal_0904",
                        "content": "Wrong Answer\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n-2147483648\\nExpected\\n2147483647"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/29_devide_2_int.cpp"
                    },
                    {
                        "username": "kSt_how",
                        "content": "why c++ example code is ruby ?"
                    },
                    {
                        "username": "Neo_09",
                        "content": "The test case\\n-2147483648\\n1\\nruns absolutely fine and shows the correct ans.\\nBut as soon as I submit it, the same test case shows time limit exceeded.\\nWhy?"
                    },
                    {
                        "username": "shivangshrivastavaprogramming",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend==-2147483648 && divisor==-1){\\n            return 2147483647;\\n        }\\n        return dividend/divisor;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1728779,
                "content": [
                    {
                        "username": "om_2209",
                        "content": "Same code is working in Java but not in CPP"
                    },
                    {
                        "username": "Konduru_sai",
                        "content": "  if divisor==0:\\n            return 0\\n        if divisor <0 and dividend<0:\\n            D=(dividend//divisor)\\n            if D>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return D\\n        elif (divisor<0 and dividend>0) or (divisor>0 and dividend<0):\\n            A=abs(divisor)\\n            E=abs(dividend)\\n            b=-(E//A)\\n            if b<=-2**31:\\n                return -2**31\\n            else:\\n                return b\\n            return -(dividend//A)\\n        else:\\n            c=int(dividend//divisor)\\n            if c>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return c"
                    },
                    {
                        "username": "tarikin",
                        "content": "-2147483648 / -1 = 2147483647, yes Leet this makes a lot sense"
                    },
                    {
                        "username": "trantatxep",
                        "content": "Input\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nWhat problems ? I have only case "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "wtf???\\n\\nTime Limit Exceeded\\nLast Executed Input\\n994 / 994 testcases passed\\ndividend =\\n\\nWhat is the input???"
                    },
                    {
                        "username": "Rohit_Singhal_0904",
                        "content": "Wrong Answer\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n-2147483648\\nExpected\\n2147483647"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/29_devide_2_int.cpp"
                    },
                    {
                        "username": "kSt_how",
                        "content": "why c++ example code is ruby ?"
                    },
                    {
                        "username": "Neo_09",
                        "content": "The test case\\n-2147483648\\n1\\nruns absolutely fine and shows the correct ans.\\nBut as soon as I submit it, the same test case shows time limit exceeded.\\nWhy?"
                    },
                    {
                        "username": "shivangshrivastavaprogramming",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend==-2147483648 && divisor==-1){\\n            return 2147483647;\\n        }\\n        return dividend/divisor;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1728067,
                "content": [
                    {
                        "username": "om_2209",
                        "content": "Same code is working in Java but not in CPP"
                    },
                    {
                        "username": "Konduru_sai",
                        "content": "  if divisor==0:\\n            return 0\\n        if divisor <0 and dividend<0:\\n            D=(dividend//divisor)\\n            if D>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return D\\n        elif (divisor<0 and dividend>0) or (divisor>0 and dividend<0):\\n            A=abs(divisor)\\n            E=abs(dividend)\\n            b=-(E//A)\\n            if b<=-2**31:\\n                return -2**31\\n            else:\\n                return b\\n            return -(dividend//A)\\n        else:\\n            c=int(dividend//divisor)\\n            if c>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return c"
                    },
                    {
                        "username": "tarikin",
                        "content": "-2147483648 / -1 = 2147483647, yes Leet this makes a lot sense"
                    },
                    {
                        "username": "trantatxep",
                        "content": "Input\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nWhat problems ? I have only case "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "wtf???\\n\\nTime Limit Exceeded\\nLast Executed Input\\n994 / 994 testcases passed\\ndividend =\\n\\nWhat is the input???"
                    },
                    {
                        "username": "Rohit_Singhal_0904",
                        "content": "Wrong Answer\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n-2147483648\\nExpected\\n2147483647"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/29_devide_2_int.cpp"
                    },
                    {
                        "username": "kSt_how",
                        "content": "why c++ example code is ruby ?"
                    },
                    {
                        "username": "Neo_09",
                        "content": "The test case\\n-2147483648\\n1\\nruns absolutely fine and shows the correct ans.\\nBut as soon as I submit it, the same test case shows time limit exceeded.\\nWhy?"
                    },
                    {
                        "username": "shivangshrivastavaprogramming",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend==-2147483648 && divisor==-1){\\n            return 2147483647;\\n        }\\n        return dividend/divisor;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1726065,
                "content": [
                    {
                        "username": "om_2209",
                        "content": "Same code is working in Java but not in CPP"
                    },
                    {
                        "username": "Konduru_sai",
                        "content": "  if divisor==0:\\n            return 0\\n        if divisor <0 and dividend<0:\\n            D=(dividend//divisor)\\n            if D>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return D\\n        elif (divisor<0 and dividend>0) or (divisor>0 and dividend<0):\\n            A=abs(divisor)\\n            E=abs(dividend)\\n            b=-(E//A)\\n            if b<=-2**31:\\n                return -2**31\\n            else:\\n                return b\\n            return -(dividend//A)\\n        else:\\n            c=int(dividend//divisor)\\n            if c>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return c"
                    },
                    {
                        "username": "tarikin",
                        "content": "-2147483648 / -1 = 2147483647, yes Leet this makes a lot sense"
                    },
                    {
                        "username": "trantatxep",
                        "content": "Input\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nWhat problems ? I have only case "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "wtf???\\n\\nTime Limit Exceeded\\nLast Executed Input\\n994 / 994 testcases passed\\ndividend =\\n\\nWhat is the input???"
                    },
                    {
                        "username": "Rohit_Singhal_0904",
                        "content": "Wrong Answer\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n-2147483648\\nExpected\\n2147483647"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/29_devide_2_int.cpp"
                    },
                    {
                        "username": "kSt_how",
                        "content": "why c++ example code is ruby ?"
                    },
                    {
                        "username": "Neo_09",
                        "content": "The test case\\n-2147483648\\n1\\nruns absolutely fine and shows the correct ans.\\nBut as soon as I submit it, the same test case shows time limit exceeded.\\nWhy?"
                    },
                    {
                        "username": "shivangshrivastavaprogramming",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend==-2147483648 && divisor==-1){\\n            return 2147483647;\\n        }\\n        return dividend/divisor;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1724578,
                "content": [
                    {
                        "username": "om_2209",
                        "content": "Same code is working in Java but not in CPP"
                    },
                    {
                        "username": "Konduru_sai",
                        "content": "  if divisor==0:\\n            return 0\\n        if divisor <0 and dividend<0:\\n            D=(dividend//divisor)\\n            if D>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return D\\n        elif (divisor<0 and dividend>0) or (divisor>0 and dividend<0):\\n            A=abs(divisor)\\n            E=abs(dividend)\\n            b=-(E//A)\\n            if b<=-2**31:\\n                return -2**31\\n            else:\\n                return b\\n            return -(dividend//A)\\n        else:\\n            c=int(dividend//divisor)\\n            if c>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return c"
                    },
                    {
                        "username": "tarikin",
                        "content": "-2147483648 / -1 = 2147483647, yes Leet this makes a lot sense"
                    },
                    {
                        "username": "trantatxep",
                        "content": "Input\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nWhat problems ? I have only case "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "wtf???\\n\\nTime Limit Exceeded\\nLast Executed Input\\n994 / 994 testcases passed\\ndividend =\\n\\nWhat is the input???"
                    },
                    {
                        "username": "Rohit_Singhal_0904",
                        "content": "Wrong Answer\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n-2147483648\\nExpected\\n2147483647"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/29_devide_2_int.cpp"
                    },
                    {
                        "username": "kSt_how",
                        "content": "why c++ example code is ruby ?"
                    },
                    {
                        "username": "Neo_09",
                        "content": "The test case\\n-2147483648\\n1\\nruns absolutely fine and shows the correct ans.\\nBut as soon as I submit it, the same test case shows time limit exceeded.\\nWhy?"
                    },
                    {
                        "username": "shivangshrivastavaprogramming",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend==-2147483648 && divisor==-1){\\n            return 2147483647;\\n        }\\n        return dividend/divisor;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1724023,
                "content": [
                    {
                        "username": "chopuryan",
                        "content": "I\\'m getting a `Time Limit Exceeded` error for this particular case\\n```\\ndividend =\\n2147483647\\ndivisor =\\n3\\n```\\nBut if I copy these into a custom test case and run, everything works! \\n\\nCan anyone help me understand what is the problem? I\\'m using simple `addition` algorithm written in JS"
                    },
                    {
                        "username": "jrespond00",
                        "content": "we can apply division by successive subtractions "
                    },
                    {
                        "username": "jrespond00",
                        "content": "It comes to my mind to make an algorithm that is done at a binary level, that is, the issue of converting a number to binary, there is an operation for this"
                    },
                    {
                        "username": "charonme",
                        "content": "in most languages numbers already are in binary and you can use binary operations to work with them without conversion: https://en.wikipedia.org/wiki/Bitwise_operation"
                    },
                    {
                        "username": "rahulseith",
                        "content": "Regarding Test case:\\nInput : dividend: -2147483648, divisor = -1, expected 2147483647\\nI see many people are justifying the expected as the resultant of max value of int....  but that shouldnt be the point... point should be what is the ans irrespective of approach... , u ask any 3rd grader  he would say 2147484648 only...  which is again overflow , can u please update test case."
                    },
                    {
                        "username": "charonme",
                        "content": "The justification is that that is what the problem description says. The overflow protection is part of the problem and reflects the reality that needs to be accounted for in practice when building a computer"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why it is necessry to use abs(divident) and abs(divisor)"
                    },
                    {
                        "username": "fahimmakhanifm",
                        "content": "what does \"Time Limit Exceeded\" means while submitting "
                    },
                    {
                        "username": "LoopSkywalker",
                        "content": ">993 / 993 testcases passed\n>Time Limit Exceeded\n\nWhat are they trying to tell me?"
                    },
                    {
                        "username": "revathivalligatla",
                        "content": "class Solution {\n    public int divide(int dividend, int divisor) {\n        if(dividend==1<<31&&divisor==-1) return Integer.MAX_VALUE;\n        boolean sign =(dividend>=0)==(divisor>=0)? true:false;\n        divisor=Math.abs(divisor);\n        dividend=Math.abs(dividend);\n        int result=0;\n        while(dividend-divisor>=0){\n            int count=0;\n        while(dividend-(divisor << 1 << count)>=0){\n             count++;\n        }\n        result+=1 << count;\n        }\n        return sign ? result:-result; \n    }\n}\nwith this im getting time limit exceeded,can any one help me out"
                    },
                    {
                        "username": "aniketdali",
                        "content": "the official solution on c++ has time limit exceeded error"
                    },
                    {
                        "username": "rohangautam219",
                        "content": "what is the time complexity of this code and how I will reduce its memory.\\n\\nif(dividend == Integer.MIN_VALUE && divisor==-1){\\n            return -(dividend-1 / divisor);\\n        } \\n        else {\\n            int ans = dividend/divisor;\\n            return ans;\\n        }\\n        \\n"
                    }
                ]
            },
            {
                "id": 1722109,
                "content": [
                    {
                        "username": "chopuryan",
                        "content": "I\\'m getting a `Time Limit Exceeded` error for this particular case\\n```\\ndividend =\\n2147483647\\ndivisor =\\n3\\n```\\nBut if I copy these into a custom test case and run, everything works! \\n\\nCan anyone help me understand what is the problem? I\\'m using simple `addition` algorithm written in JS"
                    },
                    {
                        "username": "jrespond00",
                        "content": "we can apply division by successive subtractions "
                    },
                    {
                        "username": "jrespond00",
                        "content": "It comes to my mind to make an algorithm that is done at a binary level, that is, the issue of converting a number to binary, there is an operation for this"
                    },
                    {
                        "username": "charonme",
                        "content": "in most languages numbers already are in binary and you can use binary operations to work with them without conversion: https://en.wikipedia.org/wiki/Bitwise_operation"
                    },
                    {
                        "username": "rahulseith",
                        "content": "Regarding Test case:\\nInput : dividend: -2147483648, divisor = -1, expected 2147483647\\nI see many people are justifying the expected as the resultant of max value of int....  but that shouldnt be the point... point should be what is the ans irrespective of approach... , u ask any 3rd grader  he would say 2147484648 only...  which is again overflow , can u please update test case."
                    },
                    {
                        "username": "charonme",
                        "content": "The justification is that that is what the problem description says. The overflow protection is part of the problem and reflects the reality that needs to be accounted for in practice when building a computer"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why it is necessry to use abs(divident) and abs(divisor)"
                    },
                    {
                        "username": "fahimmakhanifm",
                        "content": "what does \"Time Limit Exceeded\" means while submitting "
                    },
                    {
                        "username": "LoopSkywalker",
                        "content": ">993 / 993 testcases passed\n>Time Limit Exceeded\n\nWhat are they trying to tell me?"
                    },
                    {
                        "username": "revathivalligatla",
                        "content": "class Solution {\n    public int divide(int dividend, int divisor) {\n        if(dividend==1<<31&&divisor==-1) return Integer.MAX_VALUE;\n        boolean sign =(dividend>=0)==(divisor>=0)? true:false;\n        divisor=Math.abs(divisor);\n        dividend=Math.abs(dividend);\n        int result=0;\n        while(dividend-divisor>=0){\n            int count=0;\n        while(dividend-(divisor << 1 << count)>=0){\n             count++;\n        }\n        result+=1 << count;\n        }\n        return sign ? result:-result; \n    }\n}\nwith this im getting time limit exceeded,can any one help me out"
                    },
                    {
                        "username": "aniketdali",
                        "content": "the official solution on c++ has time limit exceeded error"
                    },
                    {
                        "username": "rohangautam219",
                        "content": "what is the time complexity of this code and how I will reduce its memory.\\n\\nif(dividend == Integer.MIN_VALUE && divisor==-1){\\n            return -(dividend-1 / divisor);\\n        } \\n        else {\\n            int ans = dividend/divisor;\\n            return ans;\\n        }\\n        \\n"
                    }
                ]
            },
            {
                "id": 1720936,
                "content": [
                    {
                        "username": "chopuryan",
                        "content": "I\\'m getting a `Time Limit Exceeded` error for this particular case\\n```\\ndividend =\\n2147483647\\ndivisor =\\n3\\n```\\nBut if I copy these into a custom test case and run, everything works! \\n\\nCan anyone help me understand what is the problem? I\\'m using simple `addition` algorithm written in JS"
                    },
                    {
                        "username": "jrespond00",
                        "content": "we can apply division by successive subtractions "
                    },
                    {
                        "username": "jrespond00",
                        "content": "It comes to my mind to make an algorithm that is done at a binary level, that is, the issue of converting a number to binary, there is an operation for this"
                    },
                    {
                        "username": "charonme",
                        "content": "in most languages numbers already are in binary and you can use binary operations to work with them without conversion: https://en.wikipedia.org/wiki/Bitwise_operation"
                    },
                    {
                        "username": "rahulseith",
                        "content": "Regarding Test case:\\nInput : dividend: -2147483648, divisor = -1, expected 2147483647\\nI see many people are justifying the expected as the resultant of max value of int....  but that shouldnt be the point... point should be what is the ans irrespective of approach... , u ask any 3rd grader  he would say 2147484648 only...  which is again overflow , can u please update test case."
                    },
                    {
                        "username": "charonme",
                        "content": "The justification is that that is what the problem description says. The overflow protection is part of the problem and reflects the reality that needs to be accounted for in practice when building a computer"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why it is necessry to use abs(divident) and abs(divisor)"
                    },
                    {
                        "username": "fahimmakhanifm",
                        "content": "what does \"Time Limit Exceeded\" means while submitting "
                    },
                    {
                        "username": "LoopSkywalker",
                        "content": ">993 / 993 testcases passed\n>Time Limit Exceeded\n\nWhat are they trying to tell me?"
                    },
                    {
                        "username": "revathivalligatla",
                        "content": "class Solution {\n    public int divide(int dividend, int divisor) {\n        if(dividend==1<<31&&divisor==-1) return Integer.MAX_VALUE;\n        boolean sign =(dividend>=0)==(divisor>=0)? true:false;\n        divisor=Math.abs(divisor);\n        dividend=Math.abs(dividend);\n        int result=0;\n        while(dividend-divisor>=0){\n            int count=0;\n        while(dividend-(divisor << 1 << count)>=0){\n             count++;\n        }\n        result+=1 << count;\n        }\n        return sign ? result:-result; \n    }\n}\nwith this im getting time limit exceeded,can any one help me out"
                    },
                    {
                        "username": "aniketdali",
                        "content": "the official solution on c++ has time limit exceeded error"
                    },
                    {
                        "username": "rohangautam219",
                        "content": "what is the time complexity of this code and how I will reduce its memory.\\n\\nif(dividend == Integer.MIN_VALUE && divisor==-1){\\n            return -(dividend-1 / divisor);\\n        } \\n        else {\\n            int ans = dividend/divisor;\\n            return ans;\\n        }\\n        \\n"
                    }
                ]
            },
            {
                "id": 1719339,
                "content": [
                    {
                        "username": "chopuryan",
                        "content": "I\\'m getting a `Time Limit Exceeded` error for this particular case\\n```\\ndividend =\\n2147483647\\ndivisor =\\n3\\n```\\nBut if I copy these into a custom test case and run, everything works! \\n\\nCan anyone help me understand what is the problem? I\\'m using simple `addition` algorithm written in JS"
                    },
                    {
                        "username": "jrespond00",
                        "content": "we can apply division by successive subtractions "
                    },
                    {
                        "username": "jrespond00",
                        "content": "It comes to my mind to make an algorithm that is done at a binary level, that is, the issue of converting a number to binary, there is an operation for this"
                    },
                    {
                        "username": "charonme",
                        "content": "in most languages numbers already are in binary and you can use binary operations to work with them without conversion: https://en.wikipedia.org/wiki/Bitwise_operation"
                    },
                    {
                        "username": "rahulseith",
                        "content": "Regarding Test case:\\nInput : dividend: -2147483648, divisor = -1, expected 2147483647\\nI see many people are justifying the expected as the resultant of max value of int....  but that shouldnt be the point... point should be what is the ans irrespective of approach... , u ask any 3rd grader  he would say 2147484648 only...  which is again overflow , can u please update test case."
                    },
                    {
                        "username": "charonme",
                        "content": "The justification is that that is what the problem description says. The overflow protection is part of the problem and reflects the reality that needs to be accounted for in practice when building a computer"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why it is necessry to use abs(divident) and abs(divisor)"
                    },
                    {
                        "username": "fahimmakhanifm",
                        "content": "what does \"Time Limit Exceeded\" means while submitting "
                    },
                    {
                        "username": "LoopSkywalker",
                        "content": ">993 / 993 testcases passed\n>Time Limit Exceeded\n\nWhat are they trying to tell me?"
                    },
                    {
                        "username": "revathivalligatla",
                        "content": "class Solution {\n    public int divide(int dividend, int divisor) {\n        if(dividend==1<<31&&divisor==-1) return Integer.MAX_VALUE;\n        boolean sign =(dividend>=0)==(divisor>=0)? true:false;\n        divisor=Math.abs(divisor);\n        dividend=Math.abs(dividend);\n        int result=0;\n        while(dividend-divisor>=0){\n            int count=0;\n        while(dividend-(divisor << 1 << count)>=0){\n             count++;\n        }\n        result+=1 << count;\n        }\n        return sign ? result:-result; \n    }\n}\nwith this im getting time limit exceeded,can any one help me out"
                    },
                    {
                        "username": "aniketdali",
                        "content": "the official solution on c++ has time limit exceeded error"
                    },
                    {
                        "username": "rohangautam219",
                        "content": "what is the time complexity of this code and how I will reduce its memory.\\n\\nif(dividend == Integer.MIN_VALUE && divisor==-1){\\n            return -(dividend-1 / divisor);\\n        } \\n        else {\\n            int ans = dividend/divisor;\\n            return ans;\\n        }\\n        \\n"
                    }
                ]
            },
            {
                "id": 1709932,
                "content": [
                    {
                        "username": "chopuryan",
                        "content": "I\\'m getting a `Time Limit Exceeded` error for this particular case\\n```\\ndividend =\\n2147483647\\ndivisor =\\n3\\n```\\nBut if I copy these into a custom test case and run, everything works! \\n\\nCan anyone help me understand what is the problem? I\\'m using simple `addition` algorithm written in JS"
                    },
                    {
                        "username": "jrespond00",
                        "content": "we can apply division by successive subtractions "
                    },
                    {
                        "username": "jrespond00",
                        "content": "It comes to my mind to make an algorithm that is done at a binary level, that is, the issue of converting a number to binary, there is an operation for this"
                    },
                    {
                        "username": "charonme",
                        "content": "in most languages numbers already are in binary and you can use binary operations to work with them without conversion: https://en.wikipedia.org/wiki/Bitwise_operation"
                    },
                    {
                        "username": "rahulseith",
                        "content": "Regarding Test case:\\nInput : dividend: -2147483648, divisor = -1, expected 2147483647\\nI see many people are justifying the expected as the resultant of max value of int....  but that shouldnt be the point... point should be what is the ans irrespective of approach... , u ask any 3rd grader  he would say 2147484648 only...  which is again overflow , can u please update test case."
                    },
                    {
                        "username": "charonme",
                        "content": "The justification is that that is what the problem description says. The overflow protection is part of the problem and reflects the reality that needs to be accounted for in practice when building a computer"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why it is necessry to use abs(divident) and abs(divisor)"
                    },
                    {
                        "username": "fahimmakhanifm",
                        "content": "what does \"Time Limit Exceeded\" means while submitting "
                    },
                    {
                        "username": "LoopSkywalker",
                        "content": ">993 / 993 testcases passed\n>Time Limit Exceeded\n\nWhat are they trying to tell me?"
                    },
                    {
                        "username": "revathivalligatla",
                        "content": "class Solution {\n    public int divide(int dividend, int divisor) {\n        if(dividend==1<<31&&divisor==-1) return Integer.MAX_VALUE;\n        boolean sign =(dividend>=0)==(divisor>=0)? true:false;\n        divisor=Math.abs(divisor);\n        dividend=Math.abs(dividend);\n        int result=0;\n        while(dividend-divisor>=0){\n            int count=0;\n        while(dividend-(divisor << 1 << count)>=0){\n             count++;\n        }\n        result+=1 << count;\n        }\n        return sign ? result:-result; \n    }\n}\nwith this im getting time limit exceeded,can any one help me out"
                    },
                    {
                        "username": "aniketdali",
                        "content": "the official solution on c++ has time limit exceeded error"
                    },
                    {
                        "username": "rohangautam219",
                        "content": "what is the time complexity of this code and how I will reduce its memory.\\n\\nif(dividend == Integer.MIN_VALUE && divisor==-1){\\n            return -(dividend-1 / divisor);\\n        } \\n        else {\\n            int ans = dividend/divisor;\\n            return ans;\\n        }\\n        \\n"
                    }
                ]
            },
            {
                "id": 1709351,
                "content": [
                    {
                        "username": "chopuryan",
                        "content": "I\\'m getting a `Time Limit Exceeded` error for this particular case\\n```\\ndividend =\\n2147483647\\ndivisor =\\n3\\n```\\nBut if I copy these into a custom test case and run, everything works! \\n\\nCan anyone help me understand what is the problem? I\\'m using simple `addition` algorithm written in JS"
                    },
                    {
                        "username": "jrespond00",
                        "content": "we can apply division by successive subtractions "
                    },
                    {
                        "username": "jrespond00",
                        "content": "It comes to my mind to make an algorithm that is done at a binary level, that is, the issue of converting a number to binary, there is an operation for this"
                    },
                    {
                        "username": "charonme",
                        "content": "in most languages numbers already are in binary and you can use binary operations to work with them without conversion: https://en.wikipedia.org/wiki/Bitwise_operation"
                    },
                    {
                        "username": "rahulseith",
                        "content": "Regarding Test case:\\nInput : dividend: -2147483648, divisor = -1, expected 2147483647\\nI see many people are justifying the expected as the resultant of max value of int....  but that shouldnt be the point... point should be what is the ans irrespective of approach... , u ask any 3rd grader  he would say 2147484648 only...  which is again overflow , can u please update test case."
                    },
                    {
                        "username": "charonme",
                        "content": "The justification is that that is what the problem description says. The overflow protection is part of the problem and reflects the reality that needs to be accounted for in practice when building a computer"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why it is necessry to use abs(divident) and abs(divisor)"
                    },
                    {
                        "username": "fahimmakhanifm",
                        "content": "what does \"Time Limit Exceeded\" means while submitting "
                    },
                    {
                        "username": "LoopSkywalker",
                        "content": ">993 / 993 testcases passed\n>Time Limit Exceeded\n\nWhat are they trying to tell me?"
                    },
                    {
                        "username": "revathivalligatla",
                        "content": "class Solution {\n    public int divide(int dividend, int divisor) {\n        if(dividend==1<<31&&divisor==-1) return Integer.MAX_VALUE;\n        boolean sign =(dividend>=0)==(divisor>=0)? true:false;\n        divisor=Math.abs(divisor);\n        dividend=Math.abs(dividend);\n        int result=0;\n        while(dividend-divisor>=0){\n            int count=0;\n        while(dividend-(divisor << 1 << count)>=0){\n             count++;\n        }\n        result+=1 << count;\n        }\n        return sign ? result:-result; \n    }\n}\nwith this im getting time limit exceeded,can any one help me out"
                    },
                    {
                        "username": "aniketdali",
                        "content": "the official solution on c++ has time limit exceeded error"
                    },
                    {
                        "username": "rohangautam219",
                        "content": "what is the time complexity of this code and how I will reduce its memory.\\n\\nif(dividend == Integer.MIN_VALUE && divisor==-1){\\n            return -(dividend-1 / divisor);\\n        } \\n        else {\\n            int ans = dividend/divisor;\\n            return ans;\\n        }\\n        \\n"
                    }
                ]
            },
            {
                "id": 1707888,
                "content": [
                    {
                        "username": "chopuryan",
                        "content": "I\\'m getting a `Time Limit Exceeded` error for this particular case\\n```\\ndividend =\\n2147483647\\ndivisor =\\n3\\n```\\nBut if I copy these into a custom test case and run, everything works! \\n\\nCan anyone help me understand what is the problem? I\\'m using simple `addition` algorithm written in JS"
                    },
                    {
                        "username": "jrespond00",
                        "content": "we can apply division by successive subtractions "
                    },
                    {
                        "username": "jrespond00",
                        "content": "It comes to my mind to make an algorithm that is done at a binary level, that is, the issue of converting a number to binary, there is an operation for this"
                    },
                    {
                        "username": "charonme",
                        "content": "in most languages numbers already are in binary and you can use binary operations to work with them without conversion: https://en.wikipedia.org/wiki/Bitwise_operation"
                    },
                    {
                        "username": "rahulseith",
                        "content": "Regarding Test case:\\nInput : dividend: -2147483648, divisor = -1, expected 2147483647\\nI see many people are justifying the expected as the resultant of max value of int....  but that shouldnt be the point... point should be what is the ans irrespective of approach... , u ask any 3rd grader  he would say 2147484648 only...  which is again overflow , can u please update test case."
                    },
                    {
                        "username": "charonme",
                        "content": "The justification is that that is what the problem description says. The overflow protection is part of the problem and reflects the reality that needs to be accounted for in practice when building a computer"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why it is necessry to use abs(divident) and abs(divisor)"
                    },
                    {
                        "username": "fahimmakhanifm",
                        "content": "what does \"Time Limit Exceeded\" means while submitting "
                    },
                    {
                        "username": "LoopSkywalker",
                        "content": ">993 / 993 testcases passed\n>Time Limit Exceeded\n\nWhat are they trying to tell me?"
                    },
                    {
                        "username": "revathivalligatla",
                        "content": "class Solution {\n    public int divide(int dividend, int divisor) {\n        if(dividend==1<<31&&divisor==-1) return Integer.MAX_VALUE;\n        boolean sign =(dividend>=0)==(divisor>=0)? true:false;\n        divisor=Math.abs(divisor);\n        dividend=Math.abs(dividend);\n        int result=0;\n        while(dividend-divisor>=0){\n            int count=0;\n        while(dividend-(divisor << 1 << count)>=0){\n             count++;\n        }\n        result+=1 << count;\n        }\n        return sign ? result:-result; \n    }\n}\nwith this im getting time limit exceeded,can any one help me out"
                    },
                    {
                        "username": "aniketdali",
                        "content": "the official solution on c++ has time limit exceeded error"
                    },
                    {
                        "username": "rohangautam219",
                        "content": "what is the time complexity of this code and how I will reduce its memory.\\n\\nif(dividend == Integer.MIN_VALUE && divisor==-1){\\n            return -(dividend-1 / divisor);\\n        } \\n        else {\\n            int ans = dividend/divisor;\\n            return ans;\\n        }\\n        \\n"
                    }
                ]
            },
            {
                "id": 1700876,
                "content": [
                    {
                        "username": "chopuryan",
                        "content": "I\\'m getting a `Time Limit Exceeded` error for this particular case\\n```\\ndividend =\\n2147483647\\ndivisor =\\n3\\n```\\nBut if I copy these into a custom test case and run, everything works! \\n\\nCan anyone help me understand what is the problem? I\\'m using simple `addition` algorithm written in JS"
                    },
                    {
                        "username": "jrespond00",
                        "content": "we can apply division by successive subtractions "
                    },
                    {
                        "username": "jrespond00",
                        "content": "It comes to my mind to make an algorithm that is done at a binary level, that is, the issue of converting a number to binary, there is an operation for this"
                    },
                    {
                        "username": "charonme",
                        "content": "in most languages numbers already are in binary and you can use binary operations to work with them without conversion: https://en.wikipedia.org/wiki/Bitwise_operation"
                    },
                    {
                        "username": "rahulseith",
                        "content": "Regarding Test case:\\nInput : dividend: -2147483648, divisor = -1, expected 2147483647\\nI see many people are justifying the expected as the resultant of max value of int....  but that shouldnt be the point... point should be what is the ans irrespective of approach... , u ask any 3rd grader  he would say 2147484648 only...  which is again overflow , can u please update test case."
                    },
                    {
                        "username": "charonme",
                        "content": "The justification is that that is what the problem description says. The overflow protection is part of the problem and reflects the reality that needs to be accounted for in practice when building a computer"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why it is necessry to use abs(divident) and abs(divisor)"
                    },
                    {
                        "username": "fahimmakhanifm",
                        "content": "what does \"Time Limit Exceeded\" means while submitting "
                    },
                    {
                        "username": "LoopSkywalker",
                        "content": ">993 / 993 testcases passed\n>Time Limit Exceeded\n\nWhat are they trying to tell me?"
                    },
                    {
                        "username": "revathivalligatla",
                        "content": "class Solution {\n    public int divide(int dividend, int divisor) {\n        if(dividend==1<<31&&divisor==-1) return Integer.MAX_VALUE;\n        boolean sign =(dividend>=0)==(divisor>=0)? true:false;\n        divisor=Math.abs(divisor);\n        dividend=Math.abs(dividend);\n        int result=0;\n        while(dividend-divisor>=0){\n            int count=0;\n        while(dividend-(divisor << 1 << count)>=0){\n             count++;\n        }\n        result+=1 << count;\n        }\n        return sign ? result:-result; \n    }\n}\nwith this im getting time limit exceeded,can any one help me out"
                    },
                    {
                        "username": "aniketdali",
                        "content": "the official solution on c++ has time limit exceeded error"
                    },
                    {
                        "username": "rohangautam219",
                        "content": "what is the time complexity of this code and how I will reduce its memory.\\n\\nif(dividend == Integer.MIN_VALUE && divisor==-1){\\n            return -(dividend-1 / divisor);\\n        } \\n        else {\\n            int ans = dividend/divisor;\\n            return ans;\\n        }\\n        \\n"
                    }
                ]
            },
            {
                "id": 1699724,
                "content": [
                    {
                        "username": "chopuryan",
                        "content": "I\\'m getting a `Time Limit Exceeded` error for this particular case\\n```\\ndividend =\\n2147483647\\ndivisor =\\n3\\n```\\nBut if I copy these into a custom test case and run, everything works! \\n\\nCan anyone help me understand what is the problem? I\\'m using simple `addition` algorithm written in JS"
                    },
                    {
                        "username": "jrespond00",
                        "content": "we can apply division by successive subtractions "
                    },
                    {
                        "username": "jrespond00",
                        "content": "It comes to my mind to make an algorithm that is done at a binary level, that is, the issue of converting a number to binary, there is an operation for this"
                    },
                    {
                        "username": "charonme",
                        "content": "in most languages numbers already are in binary and you can use binary operations to work with them without conversion: https://en.wikipedia.org/wiki/Bitwise_operation"
                    },
                    {
                        "username": "rahulseith",
                        "content": "Regarding Test case:\\nInput : dividend: -2147483648, divisor = -1, expected 2147483647\\nI see many people are justifying the expected as the resultant of max value of int....  but that shouldnt be the point... point should be what is the ans irrespective of approach... , u ask any 3rd grader  he would say 2147484648 only...  which is again overflow , can u please update test case."
                    },
                    {
                        "username": "charonme",
                        "content": "The justification is that that is what the problem description says. The overflow protection is part of the problem and reflects the reality that needs to be accounted for in practice when building a computer"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why it is necessry to use abs(divident) and abs(divisor)"
                    },
                    {
                        "username": "fahimmakhanifm",
                        "content": "what does \"Time Limit Exceeded\" means while submitting "
                    },
                    {
                        "username": "LoopSkywalker",
                        "content": ">993 / 993 testcases passed\n>Time Limit Exceeded\n\nWhat are they trying to tell me?"
                    },
                    {
                        "username": "revathivalligatla",
                        "content": "class Solution {\n    public int divide(int dividend, int divisor) {\n        if(dividend==1<<31&&divisor==-1) return Integer.MAX_VALUE;\n        boolean sign =(dividend>=0)==(divisor>=0)? true:false;\n        divisor=Math.abs(divisor);\n        dividend=Math.abs(dividend);\n        int result=0;\n        while(dividend-divisor>=0){\n            int count=0;\n        while(dividend-(divisor << 1 << count)>=0){\n             count++;\n        }\n        result+=1 << count;\n        }\n        return sign ? result:-result; \n    }\n}\nwith this im getting time limit exceeded,can any one help me out"
                    },
                    {
                        "username": "aniketdali",
                        "content": "the official solution on c++ has time limit exceeded error"
                    },
                    {
                        "username": "rohangautam219",
                        "content": "what is the time complexity of this code and how I will reduce its memory.\\n\\nif(dividend == Integer.MIN_VALUE && divisor==-1){\\n            return -(dividend-1 / divisor);\\n        } \\n        else {\\n            int ans = dividend/divisor;\\n            return ans;\\n        }\\n        \\n"
                    }
                ]
            },
            {
                "id": 1693543,
                "content": [
                    {
                        "username": "chopuryan",
                        "content": "I\\'m getting a `Time Limit Exceeded` error for this particular case\\n```\\ndividend =\\n2147483647\\ndivisor =\\n3\\n```\\nBut if I copy these into a custom test case and run, everything works! \\n\\nCan anyone help me understand what is the problem? I\\'m using simple `addition` algorithm written in JS"
                    },
                    {
                        "username": "jrespond00",
                        "content": "we can apply division by successive subtractions "
                    },
                    {
                        "username": "jrespond00",
                        "content": "It comes to my mind to make an algorithm that is done at a binary level, that is, the issue of converting a number to binary, there is an operation for this"
                    },
                    {
                        "username": "charonme",
                        "content": "in most languages numbers already are in binary and you can use binary operations to work with them without conversion: https://en.wikipedia.org/wiki/Bitwise_operation"
                    },
                    {
                        "username": "rahulseith",
                        "content": "Regarding Test case:\\nInput : dividend: -2147483648, divisor = -1, expected 2147483647\\nI see many people are justifying the expected as the resultant of max value of int....  but that shouldnt be the point... point should be what is the ans irrespective of approach... , u ask any 3rd grader  he would say 2147484648 only...  which is again overflow , can u please update test case."
                    },
                    {
                        "username": "charonme",
                        "content": "The justification is that that is what the problem description says. The overflow protection is part of the problem and reflects the reality that needs to be accounted for in practice when building a computer"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why it is necessry to use abs(divident) and abs(divisor)"
                    },
                    {
                        "username": "fahimmakhanifm",
                        "content": "what does \"Time Limit Exceeded\" means while submitting "
                    },
                    {
                        "username": "LoopSkywalker",
                        "content": ">993 / 993 testcases passed\n>Time Limit Exceeded\n\nWhat are they trying to tell me?"
                    },
                    {
                        "username": "revathivalligatla",
                        "content": "class Solution {\n    public int divide(int dividend, int divisor) {\n        if(dividend==1<<31&&divisor==-1) return Integer.MAX_VALUE;\n        boolean sign =(dividend>=0)==(divisor>=0)? true:false;\n        divisor=Math.abs(divisor);\n        dividend=Math.abs(dividend);\n        int result=0;\n        while(dividend-divisor>=0){\n            int count=0;\n        while(dividend-(divisor << 1 << count)>=0){\n             count++;\n        }\n        result+=1 << count;\n        }\n        return sign ? result:-result; \n    }\n}\nwith this im getting time limit exceeded,can any one help me out"
                    },
                    {
                        "username": "aniketdali",
                        "content": "the official solution on c++ has time limit exceeded error"
                    },
                    {
                        "username": "rohangautam219",
                        "content": "what is the time complexity of this code and how I will reduce its memory.\\n\\nif(dividend == Integer.MIN_VALUE && divisor==-1){\\n            return -(dividend-1 / divisor);\\n        } \\n        else {\\n            int ans = dividend/divisor;\\n            return ans;\\n        }\\n        \\n"
                    }
                ]
            },
            {
                "id": 1684081,
                "content": [
                    {
                        "username": "Luna-martinez",
                        "content": "Hey i used absolute functions, to return the value and then add a - sign, but there is some error when the input is -2^31"
                    },
                    {
                        "username": "zOrOjUrO_",
                        "content": "__The log based approach doesn\\'t work?__\\n\\n_Case 1:_\\nDividend = 2147483647\\nDivisor = 2\\nExpected = 1073741823\\n\\n_Case 2:_\\nDividend = -231\\nDivisor = 3\\nExpected = -77\\n\\nThe first case fails if taken as\\n`round(2**(log(dividend,2)-log(divisor,2)))`\\n\\nWhile second fails if taken as\\n`int(2**(log(dividend,2)-log(divisor,2)))`\\n\\nTried with different bases as well. Am I missing something? "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html](https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html)"
                    },
                    {
                        "username": "bonasero",
                        "content": "invalid test:\\nInput (dividend = -2147483648; divisor = -1)\\nExpected (2147483647)"
                    },
                    {
                        "username": "soumya00",
                        "content": "This is a very good problem based on Bit Manipulations, and can be done by several approaches. I don't know why there are so many dislikes! There are some of the edge cases like combinations of (+ve, -ve) dividend and (+ve, -ve) divisor, and that needs to be handled carefully. Also, when divisor == -1 or +1. Other than that, this is a nice problem."
                    },
                    {
                        "username": "oritzau",
                        "content": "I keep getting \"runtime exceeded\" despite my code working fine and fast when I run it on the terminal. Anyone else encounter something similar?"
                    },
                    {
                        "username": "Xylys",
                        "content": "i made this code for the solution but it says its wrong but when i tested it on my own computer it works\n\nheres what i did on here:\n\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        temp = dividend\n        run = True\n        while run:\n            if temp - divisor < 0:\n                run = False\n                return count\n            elif temp - divisor > 0:\n                temp = temp - divisor\n                count = count + 1\n\n                \n\nheres what i did on my own computer:\n dividend = 10\ndivisor = 3\n\ncount = 0\ntemp = dividend\nrun = True\nwhile run:\n    if temp - divisor < 0:\n        run = False\n        print(count)\n    elif temp - divisor > 0:\n        temp = temp - divisor\n        count = count + 1\n\ncan someone tell me whats wrong"
                    },
                    {
                        "username": "fgg192",
                        "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Divide Two Integers.\\n\\nJust use Ian Kaplan\\'s 1996 binary solution, only using bitwise operators. Gotta check for negative values and overflow cases though.\\n\\nLink below:\\n\\nhttp://bearcave.com/software/divide.htm\\n"
                    },
                    {
                        "username": "manish47",
                        "content": "-2147483648\\n-1\\n\\nExpected Output is 2147483647\\nwhich is wrong.\\nif you multiply -1 with 2147483648, you will receive value = -2147483648."
                    },
                    {
                        "username": "TheBeliever",
                        "content": "Question has restriction to not use multiplication, division or mod operator.\\nDivison is obvious.\\nHow can you effectively solve the problem using multiplication or mod operator ?"
                    }
                ]
            },
            {
                "id": 1678534,
                "content": [
                    {
                        "username": "Luna-martinez",
                        "content": "Hey i used absolute functions, to return the value and then add a - sign, but there is some error when the input is -2^31"
                    },
                    {
                        "username": "zOrOjUrO_",
                        "content": "__The log based approach doesn\\'t work?__\\n\\n_Case 1:_\\nDividend = 2147483647\\nDivisor = 2\\nExpected = 1073741823\\n\\n_Case 2:_\\nDividend = -231\\nDivisor = 3\\nExpected = -77\\n\\nThe first case fails if taken as\\n`round(2**(log(dividend,2)-log(divisor,2)))`\\n\\nWhile second fails if taken as\\n`int(2**(log(dividend,2)-log(divisor,2)))`\\n\\nTried with different bases as well. Am I missing something? "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html](https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html)"
                    },
                    {
                        "username": "bonasero",
                        "content": "invalid test:\\nInput (dividend = -2147483648; divisor = -1)\\nExpected (2147483647)"
                    },
                    {
                        "username": "soumya00",
                        "content": "This is a very good problem based on Bit Manipulations, and can be done by several approaches. I don't know why there are so many dislikes! There are some of the edge cases like combinations of (+ve, -ve) dividend and (+ve, -ve) divisor, and that needs to be handled carefully. Also, when divisor == -1 or +1. Other than that, this is a nice problem."
                    },
                    {
                        "username": "oritzau",
                        "content": "I keep getting \"runtime exceeded\" despite my code working fine and fast when I run it on the terminal. Anyone else encounter something similar?"
                    },
                    {
                        "username": "Xylys",
                        "content": "i made this code for the solution but it says its wrong but when i tested it on my own computer it works\n\nheres what i did on here:\n\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        temp = dividend\n        run = True\n        while run:\n            if temp - divisor < 0:\n                run = False\n                return count\n            elif temp - divisor > 0:\n                temp = temp - divisor\n                count = count + 1\n\n                \n\nheres what i did on my own computer:\n dividend = 10\ndivisor = 3\n\ncount = 0\ntemp = dividend\nrun = True\nwhile run:\n    if temp - divisor < 0:\n        run = False\n        print(count)\n    elif temp - divisor > 0:\n        temp = temp - divisor\n        count = count + 1\n\ncan someone tell me whats wrong"
                    },
                    {
                        "username": "fgg192",
                        "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Divide Two Integers.\\n\\nJust use Ian Kaplan\\'s 1996 binary solution, only using bitwise operators. Gotta check for negative values and overflow cases though.\\n\\nLink below:\\n\\nhttp://bearcave.com/software/divide.htm\\n"
                    },
                    {
                        "username": "manish47",
                        "content": "-2147483648\\n-1\\n\\nExpected Output is 2147483647\\nwhich is wrong.\\nif you multiply -1 with 2147483648, you will receive value = -2147483648."
                    },
                    {
                        "username": "TheBeliever",
                        "content": "Question has restriction to not use multiplication, division or mod operator.\\nDivison is obvious.\\nHow can you effectively solve the problem using multiplication or mod operator ?"
                    }
                ]
            },
            {
                "id": 1671289,
                "content": [
                    {
                        "username": "Luna-martinez",
                        "content": "Hey i used absolute functions, to return the value and then add a - sign, but there is some error when the input is -2^31"
                    },
                    {
                        "username": "zOrOjUrO_",
                        "content": "__The log based approach doesn\\'t work?__\\n\\n_Case 1:_\\nDividend = 2147483647\\nDivisor = 2\\nExpected = 1073741823\\n\\n_Case 2:_\\nDividend = -231\\nDivisor = 3\\nExpected = -77\\n\\nThe first case fails if taken as\\n`round(2**(log(dividend,2)-log(divisor,2)))`\\n\\nWhile second fails if taken as\\n`int(2**(log(dividend,2)-log(divisor,2)))`\\n\\nTried with different bases as well. Am I missing something? "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html](https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html)"
                    },
                    {
                        "username": "bonasero",
                        "content": "invalid test:\\nInput (dividend = -2147483648; divisor = -1)\\nExpected (2147483647)"
                    },
                    {
                        "username": "soumya00",
                        "content": "This is a very good problem based on Bit Manipulations, and can be done by several approaches. I don't know why there are so many dislikes! There are some of the edge cases like combinations of (+ve, -ve) dividend and (+ve, -ve) divisor, and that needs to be handled carefully. Also, when divisor == -1 or +1. Other than that, this is a nice problem."
                    },
                    {
                        "username": "oritzau",
                        "content": "I keep getting \"runtime exceeded\" despite my code working fine and fast when I run it on the terminal. Anyone else encounter something similar?"
                    },
                    {
                        "username": "Xylys",
                        "content": "i made this code for the solution but it says its wrong but when i tested it on my own computer it works\n\nheres what i did on here:\n\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        temp = dividend\n        run = True\n        while run:\n            if temp - divisor < 0:\n                run = False\n                return count\n            elif temp - divisor > 0:\n                temp = temp - divisor\n                count = count + 1\n\n                \n\nheres what i did on my own computer:\n dividend = 10\ndivisor = 3\n\ncount = 0\ntemp = dividend\nrun = True\nwhile run:\n    if temp - divisor < 0:\n        run = False\n        print(count)\n    elif temp - divisor > 0:\n        temp = temp - divisor\n        count = count + 1\n\ncan someone tell me whats wrong"
                    },
                    {
                        "username": "fgg192",
                        "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Divide Two Integers.\\n\\nJust use Ian Kaplan\\'s 1996 binary solution, only using bitwise operators. Gotta check for negative values and overflow cases though.\\n\\nLink below:\\n\\nhttp://bearcave.com/software/divide.htm\\n"
                    },
                    {
                        "username": "manish47",
                        "content": "-2147483648\\n-1\\n\\nExpected Output is 2147483647\\nwhich is wrong.\\nif you multiply -1 with 2147483648, you will receive value = -2147483648."
                    },
                    {
                        "username": "TheBeliever",
                        "content": "Question has restriction to not use multiplication, division or mod operator.\\nDivison is obvious.\\nHow can you effectively solve the problem using multiplication or mod operator ?"
                    }
                ]
            },
            {
                "id": 1666480,
                "content": [
                    {
                        "username": "Luna-martinez",
                        "content": "Hey i used absolute functions, to return the value and then add a - sign, but there is some error when the input is -2^31"
                    },
                    {
                        "username": "zOrOjUrO_",
                        "content": "__The log based approach doesn\\'t work?__\\n\\n_Case 1:_\\nDividend = 2147483647\\nDivisor = 2\\nExpected = 1073741823\\n\\n_Case 2:_\\nDividend = -231\\nDivisor = 3\\nExpected = -77\\n\\nThe first case fails if taken as\\n`round(2**(log(dividend,2)-log(divisor,2)))`\\n\\nWhile second fails if taken as\\n`int(2**(log(dividend,2)-log(divisor,2)))`\\n\\nTried with different bases as well. Am I missing something? "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html](https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html)"
                    },
                    {
                        "username": "bonasero",
                        "content": "invalid test:\\nInput (dividend = -2147483648; divisor = -1)\\nExpected (2147483647)"
                    },
                    {
                        "username": "soumya00",
                        "content": "This is a very good problem based on Bit Manipulations, and can be done by several approaches. I don't know why there are so many dislikes! There are some of the edge cases like combinations of (+ve, -ve) dividend and (+ve, -ve) divisor, and that needs to be handled carefully. Also, when divisor == -1 or +1. Other than that, this is a nice problem."
                    },
                    {
                        "username": "oritzau",
                        "content": "I keep getting \"runtime exceeded\" despite my code working fine and fast when I run it on the terminal. Anyone else encounter something similar?"
                    },
                    {
                        "username": "Xylys",
                        "content": "i made this code for the solution but it says its wrong but when i tested it on my own computer it works\n\nheres what i did on here:\n\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        temp = dividend\n        run = True\n        while run:\n            if temp - divisor < 0:\n                run = False\n                return count\n            elif temp - divisor > 0:\n                temp = temp - divisor\n                count = count + 1\n\n                \n\nheres what i did on my own computer:\n dividend = 10\ndivisor = 3\n\ncount = 0\ntemp = dividend\nrun = True\nwhile run:\n    if temp - divisor < 0:\n        run = False\n        print(count)\n    elif temp - divisor > 0:\n        temp = temp - divisor\n        count = count + 1\n\ncan someone tell me whats wrong"
                    },
                    {
                        "username": "fgg192",
                        "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Divide Two Integers.\\n\\nJust use Ian Kaplan\\'s 1996 binary solution, only using bitwise operators. Gotta check for negative values and overflow cases though.\\n\\nLink below:\\n\\nhttp://bearcave.com/software/divide.htm\\n"
                    },
                    {
                        "username": "manish47",
                        "content": "-2147483648\\n-1\\n\\nExpected Output is 2147483647\\nwhich is wrong.\\nif you multiply -1 with 2147483648, you will receive value = -2147483648."
                    },
                    {
                        "username": "TheBeliever",
                        "content": "Question has restriction to not use multiplication, division or mod operator.\\nDivison is obvious.\\nHow can you effectively solve the problem using multiplication or mod operator ?"
                    }
                ]
            },
            {
                "id": 1654024,
                "content": [
                    {
                        "username": "Luna-martinez",
                        "content": "Hey i used absolute functions, to return the value and then add a - sign, but there is some error when the input is -2^31"
                    },
                    {
                        "username": "zOrOjUrO_",
                        "content": "__The log based approach doesn\\'t work?__\\n\\n_Case 1:_\\nDividend = 2147483647\\nDivisor = 2\\nExpected = 1073741823\\n\\n_Case 2:_\\nDividend = -231\\nDivisor = 3\\nExpected = -77\\n\\nThe first case fails if taken as\\n`round(2**(log(dividend,2)-log(divisor,2)))`\\n\\nWhile second fails if taken as\\n`int(2**(log(dividend,2)-log(divisor,2)))`\\n\\nTried with different bases as well. Am I missing something? "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html](https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html)"
                    },
                    {
                        "username": "bonasero",
                        "content": "invalid test:\\nInput (dividend = -2147483648; divisor = -1)\\nExpected (2147483647)"
                    },
                    {
                        "username": "soumya00",
                        "content": "This is a very good problem based on Bit Manipulations, and can be done by several approaches. I don't know why there are so many dislikes! There are some of the edge cases like combinations of (+ve, -ve) dividend and (+ve, -ve) divisor, and that needs to be handled carefully. Also, when divisor == -1 or +1. Other than that, this is a nice problem."
                    },
                    {
                        "username": "oritzau",
                        "content": "I keep getting \"runtime exceeded\" despite my code working fine and fast when I run it on the terminal. Anyone else encounter something similar?"
                    },
                    {
                        "username": "Xylys",
                        "content": "i made this code for the solution but it says its wrong but when i tested it on my own computer it works\n\nheres what i did on here:\n\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        temp = dividend\n        run = True\n        while run:\n            if temp - divisor < 0:\n                run = False\n                return count\n            elif temp - divisor > 0:\n                temp = temp - divisor\n                count = count + 1\n\n                \n\nheres what i did on my own computer:\n dividend = 10\ndivisor = 3\n\ncount = 0\ntemp = dividend\nrun = True\nwhile run:\n    if temp - divisor < 0:\n        run = False\n        print(count)\n    elif temp - divisor > 0:\n        temp = temp - divisor\n        count = count + 1\n\ncan someone tell me whats wrong"
                    },
                    {
                        "username": "fgg192",
                        "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Divide Two Integers.\\n\\nJust use Ian Kaplan\\'s 1996 binary solution, only using bitwise operators. Gotta check for negative values and overflow cases though.\\n\\nLink below:\\n\\nhttp://bearcave.com/software/divide.htm\\n"
                    },
                    {
                        "username": "manish47",
                        "content": "-2147483648\\n-1\\n\\nExpected Output is 2147483647\\nwhich is wrong.\\nif you multiply -1 with 2147483648, you will receive value = -2147483648."
                    },
                    {
                        "username": "TheBeliever",
                        "content": "Question has restriction to not use multiplication, division or mod operator.\\nDivison is obvious.\\nHow can you effectively solve the problem using multiplication or mod operator ?"
                    }
                ]
            },
            {
                "id": 1649596,
                "content": [
                    {
                        "username": "Luna-martinez",
                        "content": "Hey i used absolute functions, to return the value and then add a - sign, but there is some error when the input is -2^31"
                    },
                    {
                        "username": "zOrOjUrO_",
                        "content": "__The log based approach doesn\\'t work?__\\n\\n_Case 1:_\\nDividend = 2147483647\\nDivisor = 2\\nExpected = 1073741823\\n\\n_Case 2:_\\nDividend = -231\\nDivisor = 3\\nExpected = -77\\n\\nThe first case fails if taken as\\n`round(2**(log(dividend,2)-log(divisor,2)))`\\n\\nWhile second fails if taken as\\n`int(2**(log(dividend,2)-log(divisor,2)))`\\n\\nTried with different bases as well. Am I missing something? "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html](https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html)"
                    },
                    {
                        "username": "bonasero",
                        "content": "invalid test:\\nInput (dividend = -2147483648; divisor = -1)\\nExpected (2147483647)"
                    },
                    {
                        "username": "soumya00",
                        "content": "This is a very good problem based on Bit Manipulations, and can be done by several approaches. I don't know why there are so many dislikes! There are some of the edge cases like combinations of (+ve, -ve) dividend and (+ve, -ve) divisor, and that needs to be handled carefully. Also, when divisor == -1 or +1. Other than that, this is a nice problem."
                    },
                    {
                        "username": "oritzau",
                        "content": "I keep getting \"runtime exceeded\" despite my code working fine and fast when I run it on the terminal. Anyone else encounter something similar?"
                    },
                    {
                        "username": "Xylys",
                        "content": "i made this code for the solution but it says its wrong but when i tested it on my own computer it works\n\nheres what i did on here:\n\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        temp = dividend\n        run = True\n        while run:\n            if temp - divisor < 0:\n                run = False\n                return count\n            elif temp - divisor > 0:\n                temp = temp - divisor\n                count = count + 1\n\n                \n\nheres what i did on my own computer:\n dividend = 10\ndivisor = 3\n\ncount = 0\ntemp = dividend\nrun = True\nwhile run:\n    if temp - divisor < 0:\n        run = False\n        print(count)\n    elif temp - divisor > 0:\n        temp = temp - divisor\n        count = count + 1\n\ncan someone tell me whats wrong"
                    },
                    {
                        "username": "fgg192",
                        "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Divide Two Integers.\\n\\nJust use Ian Kaplan\\'s 1996 binary solution, only using bitwise operators. Gotta check for negative values and overflow cases though.\\n\\nLink below:\\n\\nhttp://bearcave.com/software/divide.htm\\n"
                    },
                    {
                        "username": "manish47",
                        "content": "-2147483648\\n-1\\n\\nExpected Output is 2147483647\\nwhich is wrong.\\nif you multiply -1 with 2147483648, you will receive value = -2147483648."
                    },
                    {
                        "username": "TheBeliever",
                        "content": "Question has restriction to not use multiplication, division or mod operator.\\nDivison is obvious.\\nHow can you effectively solve the problem using multiplication or mod operator ?"
                    }
                ]
            },
            {
                "id": 1627800,
                "content": [
                    {
                        "username": "Luna-martinez",
                        "content": "Hey i used absolute functions, to return the value and then add a - sign, but there is some error when the input is -2^31"
                    },
                    {
                        "username": "zOrOjUrO_",
                        "content": "__The log based approach doesn\\'t work?__\\n\\n_Case 1:_\\nDividend = 2147483647\\nDivisor = 2\\nExpected = 1073741823\\n\\n_Case 2:_\\nDividend = -231\\nDivisor = 3\\nExpected = -77\\n\\nThe first case fails if taken as\\n`round(2**(log(dividend,2)-log(divisor,2)))`\\n\\nWhile second fails if taken as\\n`int(2**(log(dividend,2)-log(divisor,2)))`\\n\\nTried with different bases as well. Am I missing something? "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html](https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html)"
                    },
                    {
                        "username": "bonasero",
                        "content": "invalid test:\\nInput (dividend = -2147483648; divisor = -1)\\nExpected (2147483647)"
                    },
                    {
                        "username": "soumya00",
                        "content": "This is a very good problem based on Bit Manipulations, and can be done by several approaches. I don't know why there are so many dislikes! There are some of the edge cases like combinations of (+ve, -ve) dividend and (+ve, -ve) divisor, and that needs to be handled carefully. Also, when divisor == -1 or +1. Other than that, this is a nice problem."
                    },
                    {
                        "username": "oritzau",
                        "content": "I keep getting \"runtime exceeded\" despite my code working fine and fast when I run it on the terminal. Anyone else encounter something similar?"
                    },
                    {
                        "username": "Xylys",
                        "content": "i made this code for the solution but it says its wrong but when i tested it on my own computer it works\n\nheres what i did on here:\n\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        temp = dividend\n        run = True\n        while run:\n            if temp - divisor < 0:\n                run = False\n                return count\n            elif temp - divisor > 0:\n                temp = temp - divisor\n                count = count + 1\n\n                \n\nheres what i did on my own computer:\n dividend = 10\ndivisor = 3\n\ncount = 0\ntemp = dividend\nrun = True\nwhile run:\n    if temp - divisor < 0:\n        run = False\n        print(count)\n    elif temp - divisor > 0:\n        temp = temp - divisor\n        count = count + 1\n\ncan someone tell me whats wrong"
                    },
                    {
                        "username": "fgg192",
                        "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Divide Two Integers.\\n\\nJust use Ian Kaplan\\'s 1996 binary solution, only using bitwise operators. Gotta check for negative values and overflow cases though.\\n\\nLink below:\\n\\nhttp://bearcave.com/software/divide.htm\\n"
                    },
                    {
                        "username": "manish47",
                        "content": "-2147483648\\n-1\\n\\nExpected Output is 2147483647\\nwhich is wrong.\\nif you multiply -1 with 2147483648, you will receive value = -2147483648."
                    },
                    {
                        "username": "TheBeliever",
                        "content": "Question has restriction to not use multiplication, division or mod operator.\\nDivison is obvious.\\nHow can you effectively solve the problem using multiplication or mod operator ?"
                    }
                ]
            },
            {
                "id": 1570090,
                "content": [
                    {
                        "username": "Luna-martinez",
                        "content": "Hey i used absolute functions, to return the value and then add a - sign, but there is some error when the input is -2^31"
                    },
                    {
                        "username": "zOrOjUrO_",
                        "content": "__The log based approach doesn\\'t work?__\\n\\n_Case 1:_\\nDividend = 2147483647\\nDivisor = 2\\nExpected = 1073741823\\n\\n_Case 2:_\\nDividend = -231\\nDivisor = 3\\nExpected = -77\\n\\nThe first case fails if taken as\\n`round(2**(log(dividend,2)-log(divisor,2)))`\\n\\nWhile second fails if taken as\\n`int(2**(log(dividend,2)-log(divisor,2)))`\\n\\nTried with different bases as well. Am I missing something? "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html](https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html)"
                    },
                    {
                        "username": "bonasero",
                        "content": "invalid test:\\nInput (dividend = -2147483648; divisor = -1)\\nExpected (2147483647)"
                    },
                    {
                        "username": "soumya00",
                        "content": "This is a very good problem based on Bit Manipulations, and can be done by several approaches. I don't know why there are so many dislikes! There are some of the edge cases like combinations of (+ve, -ve) dividend and (+ve, -ve) divisor, and that needs to be handled carefully. Also, when divisor == -1 or +1. Other than that, this is a nice problem."
                    },
                    {
                        "username": "oritzau",
                        "content": "I keep getting \"runtime exceeded\" despite my code working fine and fast when I run it on the terminal. Anyone else encounter something similar?"
                    },
                    {
                        "username": "Xylys",
                        "content": "i made this code for the solution but it says its wrong but when i tested it on my own computer it works\n\nheres what i did on here:\n\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        temp = dividend\n        run = True\n        while run:\n            if temp - divisor < 0:\n                run = False\n                return count\n            elif temp - divisor > 0:\n                temp = temp - divisor\n                count = count + 1\n\n                \n\nheres what i did on my own computer:\n dividend = 10\ndivisor = 3\n\ncount = 0\ntemp = dividend\nrun = True\nwhile run:\n    if temp - divisor < 0:\n        run = False\n        print(count)\n    elif temp - divisor > 0:\n        temp = temp - divisor\n        count = count + 1\n\ncan someone tell me whats wrong"
                    },
                    {
                        "username": "fgg192",
                        "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Divide Two Integers.\\n\\nJust use Ian Kaplan\\'s 1996 binary solution, only using bitwise operators. Gotta check for negative values and overflow cases though.\\n\\nLink below:\\n\\nhttp://bearcave.com/software/divide.htm\\n"
                    },
                    {
                        "username": "manish47",
                        "content": "-2147483648\\n-1\\n\\nExpected Output is 2147483647\\nwhich is wrong.\\nif you multiply -1 with 2147483648, you will receive value = -2147483648."
                    },
                    {
                        "username": "TheBeliever",
                        "content": "Question has restriction to not use multiplication, division or mod operator.\\nDivison is obvious.\\nHow can you effectively solve the problem using multiplication or mod operator ?"
                    }
                ]
            },
            {
                "id": 1575027,
                "content": [
                    {
                        "username": "Luna-martinez",
                        "content": "Hey i used absolute functions, to return the value and then add a - sign, but there is some error when the input is -2^31"
                    },
                    {
                        "username": "zOrOjUrO_",
                        "content": "__The log based approach doesn\\'t work?__\\n\\n_Case 1:_\\nDividend = 2147483647\\nDivisor = 2\\nExpected = 1073741823\\n\\n_Case 2:_\\nDividend = -231\\nDivisor = 3\\nExpected = -77\\n\\nThe first case fails if taken as\\n`round(2**(log(dividend,2)-log(divisor,2)))`\\n\\nWhile second fails if taken as\\n`int(2**(log(dividend,2)-log(divisor,2)))`\\n\\nTried with different bases as well. Am I missing something? "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html](https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html)"
                    },
                    {
                        "username": "bonasero",
                        "content": "invalid test:\\nInput (dividend = -2147483648; divisor = -1)\\nExpected (2147483647)"
                    },
                    {
                        "username": "soumya00",
                        "content": "This is a very good problem based on Bit Manipulations, and can be done by several approaches. I don't know why there are so many dislikes! There are some of the edge cases like combinations of (+ve, -ve) dividend and (+ve, -ve) divisor, and that needs to be handled carefully. Also, when divisor == -1 or +1. Other than that, this is a nice problem."
                    },
                    {
                        "username": "oritzau",
                        "content": "I keep getting \"runtime exceeded\" despite my code working fine and fast when I run it on the terminal. Anyone else encounter something similar?"
                    },
                    {
                        "username": "Xylys",
                        "content": "i made this code for the solution but it says its wrong but when i tested it on my own computer it works\n\nheres what i did on here:\n\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        temp = dividend\n        run = True\n        while run:\n            if temp - divisor < 0:\n                run = False\n                return count\n            elif temp - divisor > 0:\n                temp = temp - divisor\n                count = count + 1\n\n                \n\nheres what i did on my own computer:\n dividend = 10\ndivisor = 3\n\ncount = 0\ntemp = dividend\nrun = True\nwhile run:\n    if temp - divisor < 0:\n        run = False\n        print(count)\n    elif temp - divisor > 0:\n        temp = temp - divisor\n        count = count + 1\n\ncan someone tell me whats wrong"
                    },
                    {
                        "username": "fgg192",
                        "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Divide Two Integers.\\n\\nJust use Ian Kaplan\\'s 1996 binary solution, only using bitwise operators. Gotta check for negative values and overflow cases though.\\n\\nLink below:\\n\\nhttp://bearcave.com/software/divide.htm\\n"
                    },
                    {
                        "username": "manish47",
                        "content": "-2147483648\\n-1\\n\\nExpected Output is 2147483647\\nwhich is wrong.\\nif you multiply -1 with 2147483648, you will receive value = -2147483648."
                    },
                    {
                        "username": "TheBeliever",
                        "content": "Question has restriction to not use multiplication, division or mod operator.\\nDivison is obvious.\\nHow can you effectively solve the problem using multiplication or mod operator ?"
                    }
                ]
            },
            {
                "id": 1574713,
                "content": [
                    {
                        "username": "Luna-martinez",
                        "content": "Hey i used absolute functions, to return the value and then add a - sign, but there is some error when the input is -2^31"
                    },
                    {
                        "username": "zOrOjUrO_",
                        "content": "__The log based approach doesn\\'t work?__\\n\\n_Case 1:_\\nDividend = 2147483647\\nDivisor = 2\\nExpected = 1073741823\\n\\n_Case 2:_\\nDividend = -231\\nDivisor = 3\\nExpected = -77\\n\\nThe first case fails if taken as\\n`round(2**(log(dividend,2)-log(divisor,2)))`\\n\\nWhile second fails if taken as\\n`int(2**(log(dividend,2)-log(divisor,2)))`\\n\\nTried with different bases as well. Am I missing something? "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html](https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html)"
                    },
                    {
                        "username": "bonasero",
                        "content": "invalid test:\\nInput (dividend = -2147483648; divisor = -1)\\nExpected (2147483647)"
                    },
                    {
                        "username": "soumya00",
                        "content": "This is a very good problem based on Bit Manipulations, and can be done by several approaches. I don't know why there are so many dislikes! There are some of the edge cases like combinations of (+ve, -ve) dividend and (+ve, -ve) divisor, and that needs to be handled carefully. Also, when divisor == -1 or +1. Other than that, this is a nice problem."
                    },
                    {
                        "username": "oritzau",
                        "content": "I keep getting \"runtime exceeded\" despite my code working fine and fast when I run it on the terminal. Anyone else encounter something similar?"
                    },
                    {
                        "username": "Xylys",
                        "content": "i made this code for the solution but it says its wrong but when i tested it on my own computer it works\n\nheres what i did on here:\n\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        temp = dividend\n        run = True\n        while run:\n            if temp - divisor < 0:\n                run = False\n                return count\n            elif temp - divisor > 0:\n                temp = temp - divisor\n                count = count + 1\n\n                \n\nheres what i did on my own computer:\n dividend = 10\ndivisor = 3\n\ncount = 0\ntemp = dividend\nrun = True\nwhile run:\n    if temp - divisor < 0:\n        run = False\n        print(count)\n    elif temp - divisor > 0:\n        temp = temp - divisor\n        count = count + 1\n\ncan someone tell me whats wrong"
                    },
                    {
                        "username": "fgg192",
                        "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Divide Two Integers.\\n\\nJust use Ian Kaplan\\'s 1996 binary solution, only using bitwise operators. Gotta check for negative values and overflow cases though.\\n\\nLink below:\\n\\nhttp://bearcave.com/software/divide.htm\\n"
                    },
                    {
                        "username": "manish47",
                        "content": "-2147483648\\n-1\\n\\nExpected Output is 2147483647\\nwhich is wrong.\\nif you multiply -1 with 2147483648, you will receive value = -2147483648."
                    },
                    {
                        "username": "TheBeliever",
                        "content": "Question has restriction to not use multiplication, division or mod operator.\\nDivison is obvious.\\nHow can you effectively solve the problem using multiplication or mod operator ?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Sum Root to Leaf Numbers",
        "question_content": "<p>You are given the <code>root</code> of a binary tree containing digits from <code>0</code> to <code>9</code> only.</p>\n\n<p>Each root-to-leaf path in the tree represents a number.</p>\n\n<ul>\n\t<li>For example, the root-to-leaf path <code>1 -&gt; 2 -&gt; 3</code> represents the number <code>123</code>.</li>\n</ul>\n\n<p>Return <em>the total sum of all root-to-leaf numbers</em>. Test cases are generated so that the answer will fit in a <strong>32-bit</strong> integer.</p>\n\n<p>A <strong>leaf</strong> node is a node with no children.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg\" style=\"width: 212px; height: 182px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3]\n<strong>Output:</strong> 25\n<strong>Explanation:</strong>\nThe root-to-leaf path <code>1-&gt;2</code> represents the number <code>12</code>.\nThe root-to-leaf path <code>1-&gt;3</code> represents the number <code>13</code>.\nTherefore, sum = 12 + 13 = <code>25</code>.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg\" style=\"width: 292px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [4,9,0,5,1]\n<strong>Output:</strong> 1026\n<strong>Explanation:</strong>\nThe root-to-leaf path <code>4-&gt;9-&gt;5</code> represents the number 495.\nThe root-to-leaf path <code>4-&gt;9-&gt;1</code> represents the number 491.\nThe root-to-leaf path <code>4-&gt;0</code> represents the number 40.\nTherefore, sum = 495 + 491 + 40 = <code>1026</code>.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 9</code></li>\n\t<li>The depth of the tree will not exceed <code>10</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 41363,
                "title": "short-java-solution-recursion",
                "content": "\\x01I use recursive solution to solve the problem.\\n\\n    public int sumNumbers(TreeNode root) {\\n\\t\\treturn sum(root, 0);\\n\\t}\\n\\t\\n\\tpublic int sum(TreeNode n, int s){\\n\\t\\tif (n == null) return 0;\\n\\t\\tif (n.right == null && n.left == null) return s*10 + n.val;\\n\\t\\treturn sum(n.left, s*10 + n.val) + sum(n.right, s*10 + n.val);\\n\\t}",
                "solutionTags": [],
                "code": "\\x01I use recursive solution to solve the problem.\\n\\n    public int sumNumbers(TreeNode root) {\\n\\t\\treturn sum(root, 0);\\n\\t}\\n\\t\\n\\tpublic int sum(TreeNode n, int s){\\n\\t\\tif (n == null) return 0;\\n\\t\\tif (n.right == null && n.left == null) return s*10 + n.val;\\n\\t\\treturn sum(n.left, s*10 + n.val) + sum(n.right, s*10 + n.val);\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1556417,
                "title": "c-python-recursive-iterative-dfs-bfs-morris-traversal-o-1-beats-100",
                "content": "We are given a binary tree consisting of nodes with digit values. We need to consider every possible root-to-leaf path. Each of these path represent a number. We need to return the total sum of all the number represented by each of these paths.\\n\\n---\\n\\n\\u2714\\uFE0F **Solution - I (Recursive DFS - Preorder)**\\n\\nWe can intuitively see that a DFS solution will fit well here since we traverse from root to leaf in a DFS traversal and thus we can use it to form number represented by each root-to-leaf path. In DFS traversal -\\n* We start at the root with current number `cur = 0`. \\n* Every time, the current node\\'s digit will be appended to `cur` from root to leaf and we recurse for left and right child.\\n* If we reach a leaf node (a node not having any left or right child), we have formed the complete root-to-leaf number. We will then add this number `cur` to the overall sum.\\n\\nSum = 0, Cur = 4             |  Sum = 0, Cur = 49 | Sum = 495, Cur = 495 |  Sum = 986, Cur = 491 |  Sum = 1026, Cur = 40 |\\n:-------------------------:|:-------------------------:|:-------------------------:|:-------------------------:|:-------------------------:\\n<img src = \"https://assets.leetcode.com/users/images/a5b455fb-e770-4524-a184-74bf2706a4ea_1635906783.6132123.png\" width=\"250\"/>  |  <img src = \"https://assets.leetcode.com/users/images/0ee98d35-30fb-4861-9700-85570c479cee_1635906909.2482471.png\" width=\"250\"/>  | <img src = \"https://assets.leetcode.com/users/images/7561acf8-a3d6-4168-a053-962c1361b9e6_1635906994.7047894.png\" width=\"250\"/> | <img src = \"https://assets.leetcode.com/users/images/1e46e1e7-1b90-4d10-8d65-ab0a29c1a284_1635907048.6978989.png\" width=\"250\"/> | <img src = \"https://assets.leetcode.com/users/images/0eea2cdb-7d3b-4920-975b-26e027d96325_1635907121.5094054.png\" width=\"250\"/>\\n\\n<iframe src=\"https://leetcode.com/playground/AQ2Gx6hC/shared\" frameBorder=\"0\" width=100% height=380></iframe>\\n\\n\\n***Time Complexity :*** **`O(N)`**, where `N` is the number of nodes in the tree. We are doing a standard DFS traversal which takes `O(N)` time\\n***Space Complexity :*** **`O(H)`**, where `H` is the maximum depth of tree. This space is required for implicit recursive stack space. In the worst case, the tree maybe skewed and `H = N` in which case space required is equal to `O(N)`.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Iterative DFS - preorder)***\\n\\nThe same as above but converted to iterative solution using an explicit stack. The working and complexities should be about the same for both the solutions. But, an interviewer may ocassionally ask to implement iterative version, so it\\'s good to know this as well.\\n\\n<iframe src=\"https://leetcode.com/playground/bv9YkhoL/shared\" frameBorder=\"0\" width=100% height=\"330\"></iframe>\\n\\n***Time Complexity :*** **`O(N)`**, where `N` is the number of nodes in the tree. We are doing a standard DFS traversal which takes `O(N)` time\\n***Space Complexity :*** **`O(H)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (BFS)***\\n\\nThe problem doesn\\'t intuitively fall under BFS but it can be solved using this traversal approach as well.\\n\\n```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        int sum = 0;\\n        queue<pair<TreeNode*, int>> q;\\n        q.push({root, 0});\\n        while(q.size()) {\\n            auto [n, cur] = q.front(); q.pop();\\n            cur = cur * 10 + n -> val;\\n            if(n -> left) q.push({n -> left, cur});      \\n            if(n -> right) q.push({n -> right, cur});\\n            if(!n -> left && !n -> right) sum += cur;   // add to total sum if we are at leaf node\\n        }\\n        return sum;\\n    }\\n};\\n```\\n\\n***Time Complexity :*** **`O(N)`**, standard time complexity of a BFS. Each node is only visited once.\\n***Space Complexity :*** **`O(N)`**, atmost `(N+1)/2` elements will be stored in queue in case of complete binary tree.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Morris Traversal - Preorder)***\\n\\nThis solution involves using the morris traversal technique to solve the problem. The advantage of this traversal is that we can traverse the tree in O(1) space complexity. The basic idea is to link predecessors to root nodes so we can trace it back once we have traversed a side without need of using a stack. It\\'s a bit hard to explain in words so I have attached an image of how it works below. You can also find some good explanation **[here](https://stackoverflow.com/questions/5502916/explain-morris-inorder-tree-traversal-without-using-stacks-or-recursion)**.\\n\\n| Morris Traversal Steps           | \\n| :-------------------------: |\\n| <img src=\"https://assets.leetcode.com/users/images/0f71f814-93c8-4fdb-b240-f397b12201a1_1635917043.0594902.jpeg\" height=\"600\"/> |\\n\\n\\n\\n<iframe src=\"https://leetcode.com/playground/JfeqynTR/shared\" frameBorder=\"0\" width=100% height=550></iframe>\\n\\n***Time Complexity :*** **`O(N)`**\\n***Space Complexity :*** **`O(1)`**\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        int sum = 0;\\n        queue<pair<TreeNode*, int>> q;\\n        q.push({root, 0});\\n        while(q.size()) {\\n            auto [n, cur] = q.front(); q.pop();\\n            cur = cur * 10 + n -> val;\\n            if(n -> left) q.push({n -> left, cur});      \\n            if(n -> right) q.push({n -> right, cur});\\n            if(!n -> left && !n -> right) sum += cur;   // add to total sum if we are at leaf node\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41383,
                "title": "python-solutions-dfs-stack-bfs-queue-dfs-recursively",
                "content": "```\\nclass Solution(object):\\n    def sumNumbers1(self, root): # DFS recursively \\n        self.res = 0\\n        self.dfs(root, 0)\\n        return self.res\\n    \\n    def dfs(self, root, path):\\n        if root:\\n            if not root.left and not root.right:\\n                path = path*10 + root.val\\n                self.res += path\\n            self.dfs(root.left, path*10+root.val)\\n            self.dfs(root.right, path*10+root.val)\\n            \\n    def sumNumbers2(self, root): # BFS with queue\\n        deque, res = collections.deque(), 0\\n        if root:\\n            deque.append(root)\\n        while deque:\\n            node = deque.popleft()\\n            if not node.left and not node.right:\\n                res += node.val\\n            if node.left:\\n                node.left.val += node.val*10\\n                deque.append(node.left)\\n            if node.right:\\n                node.right.val += node.val*10\\n                deque.append(node.right)\\n        return res\\n    \\n    def sumNumbers(self, root): # DFS with stack\\n        stack, res = [], 0\\n        if root:\\n            stack.append(root)\\n        while stack:\\n            node = stack.pop()\\n            if not node.left and not node.right:\\n                res += node.val\\n            if node.right:\\n                node.right.val += node.val*10\\n                stack.append(node.right)\\n            if node.left:\\n                node.left.val += node.val*10\\n                stack.append(node.left)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution(object):\\n    def sumNumbers1(self, root): # DFS recursively \\n        self.res = 0\\n        self.dfs(root, 0)\\n        return self.res\\n    \\n    def dfs(self, root, path):\\n        if root:\\n            if not root.left and not root.right:\\n                path = path*10 + root.val\\n                self.res += path\\n            self.dfs(root.left, path*10+root.val)\\n            self.dfs(root.right, path*10+root.val)\\n            \\n    def sumNumbers2(self, root): # BFS with queue\\n        deque, res = collections.deque(), 0\\n        if root:\\n            deque.append(root)\\n        while deque:\\n            node = deque.popleft()\\n            if not node.left and not node.right:\\n                res += node.val\\n            if node.left:\\n                node.left.val += node.val*10\\n                deque.append(node.left)\\n            if node.right:\\n                node.right.val += node.val*10\\n                deque.append(node.right)\\n        return res\\n    \\n    def sumNumbers(self, root): # DFS with stack\\n        stack, res = [], 0\\n        if root:\\n            stack.append(root)\\n        while stack:\\n            node = stack.pop()\\n            if not node.left and not node.right:\\n                res += node.val\\n            if node.right:\\n                node.right.val += node.val*10\\n                stack.append(node.right)\\n            if node.left:\\n                node.left.val += node.val*10\\n                stack.append(node.left)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41531,
                "title": "clean-java-dfs-solution-preorder-traversal",
                "content": "    public class Solution {\\n        int total;\\n        \\n        public int sumNumbers(TreeNode root) {\\n            total = 0;\\n            helper(root, 0);\\n            return total;\\n        }\\n        \\n        void helper(TreeNode root, int sum) {\\n            if (root == null) return;\\n            \\n            sum = sum * 10 + root.val;\\n            \\n            if (root.left == null && root.right == null) {\\n                total += sum;\\n                return;\\n            }\\n            \\n            helper(root.left, sum);\\n            helper(root.right, sum);\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n        int total;\\n        \\n        public int sumNumbers(TreeNode root) {\\n            total = 0;\\n            helper(root, 0);\\n            return total;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3294054,
                "title": "java-easy-recursion-with-explanation",
                "content": "**Basically we are just taking sum as a global variable. Then we are just traversing the tree using preorder traversal. What can be our base cases?? So one thing we can know that if we get node\\'s value as null then we will simply return it .The second base condition is if we find left and right of the node to be null then we simply add it to our global variable sum by converting the string to integer. If the node is not null and the left and right of that node is not null then we simply concatenate the node\\'s val to the string. This recursive process continues and atlast we get our sum.**\\n```\\nclass Solution {\\n    int sum=0;\\n    public int sumNumbers(TreeNode root) {\\n        helper(root,\"\");\\n        return sum;\\n    }\\n    public void helper(TreeNode root,String str){\\n        if(root==null){\\n            return;\\n        }\\n        str+=root.val;\\n        if(root.left==null && root.right==null){\\n            sum+=Integer.parseInt(str);\\n            return;\\n        }\\n        helper(root.left,str);\\n        helper(root.right,str);\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/38d4b216-38c7-4a68-bd64-bf483ca0bdb8_1678756977.3545482.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int sum=0;\\n    public int sumNumbers(TreeNode root) {\\n        helper(root,\"\");\\n        return sum;\\n    }\\n    public void helper(TreeNode root,String str){\\n        if(root==null){\\n            return;\\n        }\\n        str+=root.val;\\n        if(root.left==null && root.right==null){\\n            sum+=Integer.parseInt(str);\\n            return;\\n        }\\n        helper(root.left,str);\\n        helper(root.right,str);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1555940,
                "title": "c-easy-clean-solution-fastest-0ms-1-liner-dfs-detailed-explanation-dry-run",
                "content": "##### Method: DFS [T(n) = O(n) and S(n) = O(H) [recursion stack space]]\\nIdea is to use DFS (Top Down) and generate number (starting with 0) going root to leaf. At each level, we have: `currNum = prevNum * 10 + root->val`. We compute this number for both left and right subtrees and finally return the sum of both subtree numbers.\\n*Base case:* `root->left == root->right` (only possbile for leaf node).\\n\\n##### Dry Run:\\n```\\nSuppose Binary Tree is:\\n\\t\\t1\\n\\t  /    \\\\\\n\\t2       3\\n\\t\\t  /\\n\\t\\t4\\nLet func. name be DFS (for explaination only).\\nDFS(1) = DFS(2, 1) + DFS(3, 1)\\nDFS(2, 1) = 10 + 2 = 12     // Base case\\nDFS(3, 1) = DFS(4, 10 + 3) + 0 = DFS(4, 13)\\nDFS(4, 13) = 130 + 4 = 134    // Base Case\\n=> DFS(1) = 12 + 134 = 146\\n```\\n\\n**NOTE:** \\n1. Below code (sumNumbers func. implementation) is actually 1 liner, Only for readability, I have presented it in 3 lines.\\n2. This problem is a perfect example of how we can use already known solution(s) to solve a new problem. The below solution is very similar to 4th Nov 2021 Daily LC Challenge [here](https://leetcode.com/problems/sum-of-left-leaves/discuss/1558669/c-easy-clean-solution-fastest-0ms-1-liner-dfs-detailed-explanation-dry-run) on leetcode.\\n\\n```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root, int num=0) {\\n        return root->left == root->right ? num * 10 + root->val :\\n            ((root->left ? sumNumbers(root->left, num * 10 + root->val) : 0) + \\n            (root->right ? sumNumbers(root->right, num * 10 + root->val) : 0));\\n    }\\n};\\n```\\n\\n**NOTE:**\\n*If you find this post helpful then please **upvote**. It keeps me **motivated** to post such helpful solutions. Thanks!*\\n\\n**PS:**\\nI have also written posts on:\\n1. All C++ (15+) sorting algorithms in a cleaner way [here](https://leetcode.com/problems/sort-an-array/discuss/1401412/C%2B%2B-Clean-Code-Solution-or-Fastest-or-All-(15%2B)-Sorting-Methods-or-Detailed) on leetcode.\\n2. Kadane\\'s Algorithm and Follow up Questions [C++] in a cleaner way [here](https://leetcode.com/problems/maximum-subarray/discuss/1470547/C++-Easy-and-Clean-Solution-or-Fastest:-0ms-or-All-Methods-or-Follow-Ups-or-Detailed-Explanation) on leetcode.\\n\\n*Do check it out/ bookmark (and upvote :)) to revise those concepts for the interview. Thanks!*",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nSuppose Binary Tree is:\\n\\t\\t1\\n\\t  /    \\\\\\n\\t2       3\\n\\t\\t  /\\n\\t\\t4\\nLet func. name be DFS (for explaination only).\\nDFS(1) = DFS(2, 1) + DFS(3, 1)\\nDFS(2, 1) = 10 + 2 = 12     // Base case\\nDFS(3, 1) = DFS(4, 10 + 3) + 0 = DFS(4, 13)\\nDFS(4, 13) = 130 + 4 = 134    // Base Case\\n=> DFS(1) = 12 + 134 = 146\\n```\n```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root, int num=0) {\\n        return root->left == root->right ? num * 10 + root->val :\\n            ((root->left ? sumNumbers(root->left, num * 10 + root->val) : 0) + \\n            (root->right ? sumNumbers(root->right, num * 10 + root->val) : 0));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41400,
                "title": "can-you-improve-this-algorithm",
                "content": "    /**\\n     * Definition for binary tree\\n     * public class TreeNode {\\n     *     int val;\\n     *     TreeNode left;\\n     *     TreeNode right;\\n     *     TreeNode(int x) { val = x; }\\n     * }\\n     */\\n    public class Solution {\\n        public int sumNumbers(TreeNode root) {\\n            if (root == null)\\n                return 0;\\n            return sumR(root, 0);\\n        }\\n        public int sumR(TreeNode root, int x) {\\n            if (root.right == null && root.left == null)\\n                return 10 * x + root.val;\\n            int val = 0;\\n            if (root.left != null)\\n                val += sumR(root.left, 10 * x + root.val);\\n            if (root.right != null)\\n                val += sumR(root.right, 10 * x + root.val);\\n            return val;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int sumNumbers(TreeNode root) {\\n            if (root == null)\\n                return 0;\\n            return sumR(root, 0);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3294304,
                "title": "image-explanation-3-methods-recursive-bfs-o-1-space-morris-traversal-preorder",
                "content": "# Video Solution\\nhttps://youtu.be/fkqobtlcF9A\\n\\n# Intuition & Approach\\nMethod1: Recursive Approach O(N) Space\\nMethod2: Iterative Approach-BFS O(N) Space\\nMethod3: Morris Traversal O(1) Space\\n\\n![image.png](https://assets.leetcode.com/users/images/791a0ae6-6dd4-49e1-8aa4-ab057b902480_1678764496.115488.png)\\n![image.png](https://assets.leetcode.com/users/images/07ad840f-5051-43a6-9d3a-3991320f9193_1678764507.0180266.png)\\n![image.png](https://assets.leetcode.com/users/images/468212b6-faa5-4b31-8724-5c946ffcac84_1678764518.7442815.png)\\n![image.png](https://assets.leetcode.com/users/images/7ca968bd-69d1-4851-b631-cc17ea7c612c_1678764529.2572453.png)\\n![image.png](https://assets.leetcode.com/users/images/3a21daec-db21-41c8-bab4-62dabec54e66_1678764537.1934292.png)\\n![image.png](https://assets.leetcode.com/users/images/8f9b9265-f935-4042-93d8-574865099acd_1678764556.4629147.png)\\n![image.png](https://assets.leetcode.com/users/images/7b79be39-a4b4-4f04-beb8-3d4406cc6ea4_1678764564.5119863.png)\\n![image.png](https://assets.leetcode.com/users/images/07fa78c3-8abd-4a6f-a47f-da73f2a0068a_1678764575.7467487.png)\\n![image.png](https://assets.leetcode.com/users/images/0a359d0f-6ec8-4bcf-9041-23e4176bb5c5_1678764600.991705.png)\\n![image.png](https://assets.leetcode.com/users/images/c61dc4c8-20c9-4ff9-b222-dbc90ea880e2_1678764614.2367642.png)\\n![image.png](https://assets.leetcode.com/users/images/8f51bc34-69f4-42d6-9cd9-601b9bc6799d_1678764646.0626986.png)\\n![image.png](https://assets.leetcode.com/users/images/f368550f-ff3a-4d7d-b6b7-2a0b933b83cb_1678764656.7012725.png)\\n![image.png](https://assets.leetcode.com/users/images/1d9d6cec-6793-43a1-8a64-a210aca83b6e_1678764664.9558482.png)\\n![image.png](https://assets.leetcode.com/users/images/ff894ab9-9cfa-4a76-9768-50a61e5e796c_1678764673.095142.png)\\n![image.png](https://assets.leetcode.com/users/images/fb8be609-c2b5-466d-ba22-2b76ec4a3e8c_1678764684.9639466.png)\\n![image.png](https://assets.leetcode.com/users/images/ecf6b892-28bc-44aa-9c9e-6a9651e00e51_1678766505.5274205.png)\\n\\n\\n# Recursive Code\\n```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        int currentSum = 0;\\n        return sumNodes(root, currentSum);\\n    }\\n\\n    int sumNodes(TreeNode* root, int currentSum){\\n        if(root == NULL) return 0;\\n        currentSum = currentSum * 10 + root->val;\\n        if(root->left==NULL && root->right==NULL) return currentSum;\\n\\n        int leftSum = sumNodes(root->left, currentSum);\\n        int rightSum = sumNodes(root->right, currentSum);\\n        return leftSum + rightSum; \\n    }\\n};\\n```\\n\\n# Iterative Code\\n```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        int totalSum = 0;\\n        queue<pair<TreeNode*, int>> q; // <TreeNode*, sumSoFar>\\n        q.push({root, 0});\\n\\n        while(!q.empty()){\\n            auto [root, currentSum] = q.front(); q.pop();\\n            currentSum = currentSum*10 + root->val;\\n            if(root->left==NULL && root->right==NULL) totalSum += currentSum;\\n\\n            if(root->left) q.push({root->left, currentSum});\\n            if(root->right) q.push({root->right, currentSum});\\n        }\\n        return totalSum;\\n    }\\n};\\n```\\n\\n# Morris Traversal - Preorder Code\\n```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        TreeNode *cur = root;\\n        int totalSum=0, currentSum=0, depth=0;\\n        while(cur != NULL){\\n            if(cur->left == NULL){ // left side is not there\\n                currentSum = currentSum * 10 + cur->val; // preorder(cur->val)\\n                if(cur->right == NULL) totalSum += currentSum;\\n                cur = cur->right;\\n            }else{ // left side is there (explore it) \\n                TreeNode *prev = cur->left;\\n                depth=1;\\n                while(prev->right && prev->right!=cur) prev = prev->right, depth++;\\n\\n                if(prev->right == NULL){ // Root\\'s Left\\'s Rightmost node has no attachments (means first time visit)\\n                    prev->right = cur;\\n                    currentSum = currentSum * 10 + cur->val; // preorder(cur->val)\\n                    cur = cur->left;\\n                }else{ // Root\\'s Left\\'s Rightmost node has threaded attachments (means Root\\'s Left Visited already)\\n                    prev->right = NULL;\\n                    if(prev->left == NULL) totalSum += currentSum; // that node is being visited last time\\n                    currentSum = currentSum/pow(10, depth);\\n                    cur = cur->right;\\n                }\\n            }\\n        }\\n        return totalSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        int currentSum = 0;\\n        return sumNodes(root, currentSum);\\n    }\\n\\n    int sumNodes(TreeNode* root, int currentSum){\\n        if(root == NULL) return 0;\\n        currentSum = currentSum * 10 + root->val;\\n        if(root->left==NULL && root->right==NULL) return currentSum;\\n\\n        int leftSum = sumNodes(root->left, currentSum);\\n        int rightSum = sumNodes(root->right, currentSum);\\n        return leftSum + rightSum; \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        int totalSum = 0;\\n        queue<pair<TreeNode*, int>> q; // <TreeNode*, sumSoFar>\\n        q.push({root, 0});\\n\\n        while(!q.empty()){\\n            auto [root, currentSum] = q.front(); q.pop();\\n            currentSum = currentSum*10 + root->val;\\n            if(root->left==NULL && root->right==NULL) totalSum += currentSum;\\n\\n            if(root->left) q.push({root->left, currentSum});\\n            if(root->right) q.push({root->right, currentSum});\\n        }\\n        return totalSum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        TreeNode *cur = root;\\n        int totalSum=0, currentSum=0, depth=0;\\n        while(cur != NULL){\\n            if(cur->left == NULL){ // left side is not there\\n                currentSum = currentSum * 10 + cur->val; // preorder(cur->val)\\n                if(cur->right == NULL) totalSum += currentSum;\\n                cur = cur->right;\\n            }else{ // left side is there (explore it) \\n                TreeNode *prev = cur->left;\\n                depth=1;\\n                while(prev->right && prev->right!=cur) prev = prev->right, depth++;\\n\\n                if(prev->right == NULL){ // Root\\'s Left\\'s Rightmost node has no attachments (means first time visit)\\n                    prev->right = cur;\\n                    currentSum = currentSum * 10 + cur->val; // preorder(cur->val)\\n                    cur = cur->left;\\n                }else{ // Root\\'s Left\\'s Rightmost node has threaded attachments (means Root\\'s Left Visited already)\\n                    prev->right = NULL;\\n                    if(prev->left == NULL) totalSum += currentSum; // that node is being visited last time\\n                    currentSum = currentSum/pow(10, depth);\\n                    cur = cur->right;\\n                }\\n            }\\n        }\\n        return totalSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306331,
                "title": "simple-and-easy-way",
                "content": "# Approach\\nThe problem can be solved using a recursive approach. We can traverse the binary tree using a pre-order traversal and concatenate the node values into a string. When we reach a leaf node, we can add the string as an integer to our running sum. We repeat this process for each root-to-leaf path in the tree.\\n\\n# Complexity\\n- *Time complexity:*\\nO(n), where n is the number of nodes in the binary tree. We visit each node once.\\n\\n- *Space complexity:*\\n O(h), where h is the height of the binary tree. This is the maximum depth of our recursive stack. In the worst case, where the tree is a linked list, the space complexity is O(n).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    void solve(TreeNode* root, string str){\\n        if(!root) return;\\n        if(!root->left && !root->right){\\n            str += to_string(root->val);\\n            sum += stoi(str);\\n            return;\\n        }\\n        str += to_string(root->val);\\n\\n        solve(root->left, str);\\n        solve(root->right, str);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        string str = \"\";\\n        solve(root, str);\\n        return sum;\\n    }\\n};\\n```\\n- If you like my solution then don\\'t forget to upvote it :)",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    void solve(TreeNode* root, string str){\\n        if(!root) return;\\n        if(!root->left && !root->right){\\n            str += to_string(root->val);\\n            sum += stoi(str);\\n            return;\\n        }\\n        str += to_string(root->val);\\n\\n        solve(root->left, str);\\n        solve(root->right, str);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        string str = \"\";\\n        solve(root, str);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1555847,
                "title": "java-tc-o-n-sc-o-treeheight-3-simple-dfs-solutions-recursive-iterative",
                "content": "This is a classic DFS (Depth-First Search) problem. Here we have to explore all paths starting from Root Node to each Leaf Node.\\n\\n**Recursive DFS Solution**\\n```java\\n/**\\n * Recursive DFS Solution\\n *\\n * Time Complexity: O(N). Each node is visited once.\\n *\\n * Space Complexity: O(H). Stack space.\\n * In case of balanced tree (best case) it will be O(log N) and in case of Skewed Tree (worst case) it will be O(N)\\n *\\n * N = Total number of nodes in the tree. H = Height of the tree.\\n */\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n\\n        return sumNumbersHelper(root, 0);\\n    }\\n\\n    private int sumNumbersHelper(TreeNode node, int curVal) {\\n        if (node == null) {\\n            return 0;\\n        }\\n\\n        curVal = curVal * 10 + node.val;\\n        if (node.left == null && node.right == null) {\\n            return curVal;\\n        }\\n\\n        return sumNumbersHelper(node.left, curVal) + sumNumbersHelper(node.right, curVal);\\n    }\\n}\\n```\\n\\n---\\n**Iterative Post-Order Traversal**\\n```java\\n/**\\n * Iterative Post-Order Traversal\\n *\\n * Time Complexity: O(N). Each node is visited once.\\n *\\n * Space Complexity: O(H). Stack space.\\n * In case of balanced tree (best case) it will be O(log N) and in case of Skewed Tree (worst case) it will be O(N)\\n *\\n * N = Total number of nodes in the tree. H = Height of the tree.\\n */\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode cur = root;\\n        TreeNode pre = null;\\n        int curVal = 0;\\n        int sum = 0;\\n\\n        while (cur != null || !stack.isEmpty()) {\\n            while (cur != null) {\\n                curVal = curVal * 10 + cur.val;\\n                stack.push(cur);\\n                cur = cur.left;\\n            }\\n\\n            cur = stack.peek();\\n            if (cur.right != null && cur.right != pre) {\\n                cur = cur.right;\\n                continue;\\n            }\\n\\n            if (cur.right == null && cur.left == null) {\\n                sum += curVal;\\n            }\\n\\n            pre = stack.pop();\\n            curVal /= 10;\\n            cur = null;\\n        }\\n\\n        return sum;\\n    }\\n}\\n```\\n\\n---\\n**Iterative Pre-Order Traversal**\\n\\n```java\\n/**\\n * Iterative Pre-Order Traversal\\n *\\n * Time Complexity: O(N). Each node is visited once.\\n *\\n * Space Complexity: O(H). Stack space.\\n * In case of balanced tree (best case) it will be O(log N) and in case of Skewed Tree (worst case) it will be O(N)\\n *\\n * N = Total number of nodes in the tree. H = Height of the tree.\\n */\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        if (root.left == null && root.right == null) {\\n            return root.val;\\n        }\\n\\n        Deque<Pair<TreeNode, Integer>> stack = new ArrayDeque<>();\\n        stack.push(new Pair<>(root, root.val));\\n\\n        int sum = 0;\\n\\n        while (!stack.isEmpty()) {\\n            Pair<TreeNode, Integer> cur = stack.pop();\\n            TreeNode node = cur.getKey();\\n            int num = cur.getValue();\\n\\n            if (node.left == null && node.right == null) {\\n                sum += num;\\n                continue;\\n            }\\n\\t\\t\\t\\n\\t\\t\\tif (node.right != null) {\\n                stack.push(new Pair<>(node.right, num * 10 + node.right.val));\\n            }\\n            if (node.left != null) {\\n                stack.push(new Pair<>(node.left, num * 10 + node.left.val));\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```java\\n/**\\n * Recursive DFS Solution\\n *\\n * Time Complexity: O(N). Each node is visited once.\\n *\\n * Space Complexity: O(H). Stack space.\\n * In case of balanced tree (best case) it will be O(log N) and in case of Skewed Tree (worst case) it will be O(N)\\n *\\n * N = Total number of nodes in the tree. H = Height of the tree.\\n */\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n\\n        return sumNumbersHelper(root, 0);\\n    }\\n\\n    private int sumNumbersHelper(TreeNode node, int curVal) {\\n        if (node == null) {\\n            return 0;\\n        }\\n\\n        curVal = curVal * 10 + node.val;\\n        if (node.left == null && node.right == null) {\\n            return curVal;\\n        }\\n\\n        return sumNumbersHelper(node.left, curVal) + sumNumbersHelper(node.right, curVal);\\n    }\\n}\\n```\n```java\\n/**\\n * Iterative Post-Order Traversal\\n *\\n * Time Complexity: O(N). Each node is visited once.\\n *\\n * Space Complexity: O(H). Stack space.\\n * In case of balanced tree (best case) it will be O(log N) and in case of Skewed Tree (worst case) it will be O(N)\\n *\\n * N = Total number of nodes in the tree. H = Height of the tree.\\n */\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode cur = root;\\n        TreeNode pre = null;\\n        int curVal = 0;\\n        int sum = 0;\\n\\n        while (cur != null || !stack.isEmpty()) {\\n            while (cur != null) {\\n                curVal = curVal * 10 + cur.val;\\n                stack.push(cur);\\n                cur = cur.left;\\n            }\\n\\n            cur = stack.peek();\\n            if (cur.right != null && cur.right != pre) {\\n                cur = cur.right;\\n                continue;\\n            }\\n\\n            if (cur.right == null && cur.left == null) {\\n                sum += curVal;\\n            }\\n\\n            pre = stack.pop();\\n            curVal /= 10;\\n            cur = null;\\n        }\\n\\n        return sum;\\n    }\\n}\\n```\n```java\\n/**\\n * Iterative Pre-Order Traversal\\n *\\n * Time Complexity: O(N). Each node is visited once.\\n *\\n * Space Complexity: O(H). Stack space.\\n * In case of balanced tree (best case) it will be O(log N) and in case of Skewed Tree (worst case) it will be O(N)\\n *\\n * N = Total number of nodes in the tree. H = Height of the tree.\\n */\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        if (root.left == null && root.right == null) {\\n            return root.val;\\n        }\\n\\n        Deque<Pair<TreeNode, Integer>> stack = new ArrayDeque<>();\\n        stack.push(new Pair<>(root, root.val));\\n\\n        int sum = 0;\\n\\n        while (!stack.isEmpty()) {\\n            Pair<TreeNode, Integer> cur = stack.pop();\\n            TreeNode node = cur.getKey();\\n            int num = cur.getValue();\\n\\n            if (node.left == null && node.right == null) {\\n                sum += num;\\n                continue;\\n            }\\n\\t\\t\\t\\n\\t\\t\\tif (node.right != null) {\\n                stack.push(new Pair<>(node.right, num * 10 + node.right.val));\\n            }\\n            if (node.left != null) {\\n                stack.push(new Pair<>(node.left, num * 10 + node.left.val));\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1555932,
                "title": "c-recursive-and-iterative-simple-explanation-100-faster-o-n",
                "content": "**Problem statement :** We have to find the sum of all the root to leaf number nodes.\\n\\n**Approach**\\n1.Recursive\\n2.Iterative\\n\\n**Time and space complexity**\\n1. Recursive :  Time complexity: O(N)  Auxiliary space: O(H)  H-> height of tree\\n2. Iterative : Time Complexity: O(N)  Space complexity: O(N) ->Stack\\n\\n**Recursive**\\n# Digramatical representation\\n![image](https://assets.leetcode.com/users/images/43858b45-c24a-499e-974e-f815b0156226_1635901771.7337537.png)\\n![image](https://assets.leetcode.com/users/images/39588670-34c9-43a2-b4de-f1adc7e47e69_1635901846.167564.png)\\n![image](https://assets.leetcode.com/users/images/1c0e94a7-d2b5-4aee-95e2-2cbb38edee1b_1635901895.8840768.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void findSum(TreeNode* root, int temp ,int &ans){\\n        if(root==NULL){\\n            return;\\n        }\\n        temp=temp*10+root->val;\\n        //If reached the last node\\n        if(root->left==NULL and root->right==NULL){\\n            ans+=temp;\\n        }\\n        findSum(root->left,temp,ans);\\n        findSum(root->right,temp,ans);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        if(root==NULL){\\n            return 0;\\n        }\\n        //Output\\n        int ans=0;\\n        findSum(root,0,ans);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Iterative**\\n# Diagramatical representation\\n![image](https://assets.leetcode.com/users/images/28a5ee8f-cb28-484c-918c-342bc99d6cf8_1635902017.2172806.png)\\n![image](https://assets.leetcode.com/users/images/d5da6674-a394-40c9-aaa5-e21041652e1a_1635902096.774102.png)\\n![image](https://assets.leetcode.com/users/images/fa5c6344-2628-4208-ad41-705ef2e5f013_1635902145.8339965.png)\\n![image](https://assets.leetcode.com/users/images/4e64de9d-5368-4d0a-b937-a92f8c5706cb_1635902183.3103824.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        int totalSum=0;\\n        stack<pair<TreeNode*,int>> stck;\\n        stck.push({root,0});\\n        while(!stck.empty()){\\n            pair<TreeNode*,int> p=stck.top();\\n            stck.pop();\\n            TreeNode* cur_node=p.first;\\n            int cur_sum=p.second;\\n            if(cur_node!=NULL){\\n                cur_sum=cur_sum*10+cur_node->val;\\n                if(cur_node->left==NULL and cur_node->right==NULL){\\n                    totalSum+=cur_sum;\\n                }\\n                else{\\n                    if(cur_node->right){\\n                        stck.push({cur_node->right,cur_sum});\\n                    }\\n                    if(cur_node->left){\\n                        stck.push({cur_node->left,cur_sum});\\n                    }\\n                }\\n            }\\n        }\\n        return totalSum;\\n    }\\n};\\n```\\n\\nThank you so much for reading my article, if you like then please like and share.\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void findSum(TreeNode* root, int temp ,int &ans){\\n        if(root==NULL){\\n            return;\\n        }\\n        temp=temp*10+root->val;\\n        //If reached the last node\\n        if(root->left==NULL and root->right==NULL){\\n            ans+=temp;\\n        }\\n        findSum(root->left,temp,ans);\\n        findSum(root->right,temp,ans);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        if(root==NULL){\\n            return 0;\\n        }\\n        //Output\\n        int ans=0;\\n        findSum(root,0,ans);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        int totalSum=0;\\n        stack<pair<TreeNode*,int>> stck;\\n        stck.push({root,0});\\n        while(!stck.empty()){\\n            pair<TreeNode*,int> p=stck.top();\\n            stck.pop();\\n            TreeNode* cur_node=p.first;\\n            int cur_sum=p.second;\\n            if(cur_node!=NULL){\\n                cur_sum=cur_sum*10+cur_node->val;\\n                if(cur_node->left==NULL and cur_node->right==NULL){\\n                    totalSum+=cur_sum;\\n                }\\n                else{\\n                    if(cur_node->right){\\n                        stck.push({cur_node->right,cur_sum});\\n                    }\\n                    if(cur_node->left){\\n                        stck.push({cur_node->left,cur_sum});\\n                    }\\n                }\\n            }\\n        }\\n        return totalSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293880,
                "title": "easy-solutions-in-java-python-and-c-look-at-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to find the sum of all root-to-leaf paths in the binary tree, where each root-to-leaf path represents a number. To do this, we can traverse the tree in a depth-first manner, keeping track of the current number formed by the path from the root to the current node. When we reach a leaf node, we add the current number to our running sum.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use a recursive approach to traverse the tree. We start with the root node and a current number of 0. At each node, we multiply the current number by 10 and add the node\\'s value to get the new current number. If the current node is a leaf node, we add the current number to our running sum. Otherwise, we recursively traverse the left and right subtrees, passing the new current number to each.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nWe visit each node exactly once, so the time complexity is $$O(n)$$, where n is the number of nodes in the tree.\\n- Space complexity:\\nThe space complexity is $$O(h)$$, where h is the height of the tree, due to the recursive calls on the function call stack. In the worst case, the tree is a skewed tree with a height of n, resulting in a space complexity of $$O(n)$$. However, in the best case, the tree is a balanced tree with a height of log n, resulting in a space complexity of O(log n).\\n\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n# Code\\n``` Java []\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        return dfs(root, 0);\\n    }\\n    \\n    private int dfs(TreeNode root, int sum) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        sum = sum * 10 + root.val;\\n        if (root.left == null && root.right == null) {\\n            return sum;\\n        }\\n        return dfs(root.left, sum) + dfs(root.right, sum);\\n    }\\n}\\n\\n\\n```\\n```Python []\\nclass Solution(object):\\n    def sumNumbers(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        return self.dfs(root, 0)\\n    \\n    def dfs(self, root, sum):\\n        if not root:\\n            return 0\\n        sum = sum * 10 + root.val\\n        if not root.left and not root.right:\\n            return sum\\n        return self.dfs(root.left, sum) + self.dfs(root.right, sum)\\n\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        return dfs(root, 0);\\n    }\\n    \\n    int dfs(TreeNode* root, int sum) {\\n        if (!root) {\\n            return 0;\\n        }\\n        sum = sum * 10 + root->val;\\n        if (!root->left && !root->right) {\\n            return sum;\\n        }\\n        return dfs(root->left, sum) + dfs(root->right, sum);\\n    }\\n};\\n\\n\\n```\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n``` Java []\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        return dfs(root, 0);\\n    }\\n    \\n    private int dfs(TreeNode root, int sum) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        sum = sum * 10 + root.val;\\n        if (root.left == null && root.right == null) {\\n            return sum;\\n        }\\n        return dfs(root.left, sum) + dfs(root.right, sum);\\n    }\\n}\\n\\n\\n```\n```Python []\\nclass Solution(object):\\n    def sumNumbers(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        return self.dfs(root, 0)\\n    \\n    def dfs(self, root, sum):\\n        if not root:\\n            return 0\\n        sum = sum * 10 + root.val\\n        if not root.left and not root.right:\\n            return sum\\n        return self.dfs(root.left, sum) + self.dfs(root.right, sum)\\n\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        return dfs(root, 0);\\n    }\\n    \\n    int dfs(TreeNode* root, int sum) {\\n        if (!root) {\\n            return 0;\\n        }\\n        sum = sum * 10 + root->val;\\n        if (!root->left && !root->right) {\\n            return sum;\\n        }\\n        return dfs(root->left, sum) + dfs(root->right, sum);\\n    }\\n};\\n\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41566,
                "title": "5-ms-c-code-using-dfs",
                "content": "    class Solution {\\n    public:\\n        int sumNumbers(TreeNode *root) {\\n            if(!root)\\n                return 0;\\n            sum=0;\\n            DFS(root, 0);\\n            return sum;\\n        }\\n        \\n        void DFS(TreeNode *&node, int currentSum)\\n        {\\n            currentSum=currentSum*10+node->val;\\n            if(!node->left&&!node->right)\\n                sum+=currentSum;\\n            if(node->left)\\n                DFS(node->left, currentSum);\\n            if(node->right)\\n                DFS(node->right, currentSum);\\n        }\\n    private:\\n        int sum;\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int sumNumbers(TreeNode *root) {\\n            if(!root)\\n                return 0;\\n            sum=0;\\n            DFS(root, 0);\\n            return sum;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1508493,
                "title": "c-simple-recursive-solution",
                "content": "**C++ :**\\n\\n```\\nint sumNumbersHelper(TreeNode* root, int sum)\\n{\\n\\tif(!root)\\n\\t\\treturn 0;\\n\\n\\tsum = sum * 10 + root -> val;\\n\\n\\tif(!root -> left && !root -> right)\\n\\t\\treturn sum;\\n\\n\\treturn sumNumbersHelper(root -> left, sum) + sumNumbersHelper(root -> right, sum);\\n}\\n\\nint sumNumbers(TreeNode* root) {\\n\\treturn sumNumbersHelper(root, 0);\\n}\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nint sumNumbersHelper(TreeNode* root, int sum)\\n{\\n\\tif(!root)\\n\\t\\treturn 0;\\n\\n\\tsum = sum * 10 + root -> val;\\n\\n\\tif(!root -> left && !root -> right)\\n\\t\\treturn sum;\\n\\n\\treturn sumNumbersHelper(root -> left, sum) + sumNumbersHelper(root -> right, sum);\\n}\\n\\nint sumNumbers(TreeNode* root) {\\n\\treturn sumNumbersHelper(root, 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 41367,
                "title": "non-recursive-preorder-traverse-java-solution",
                "content": "    \\n    public class Solution {\\n            public int sumNumbers(TreeNode root) {\\n                if(root==null){\\n                    return 0;\\n                }\\n                int sum = 0;\\n                TreeNode curr;\\n                Stack<TreeNode> ws = new Stack<TreeNode>();\\n                ws.push(root);\\n                \\n                while(!ws.empty()){\\n                    curr = ws.pop();\\n                    \\n                    if(curr.right!=null){\\n                        curr.right.val = curr.val*10+curr.right.val;\\n                        ws.push(curr.right);\\n                    }\\n                    \\n                    if(curr.left!=null){\\n                        curr.left.val = curr.val*10+curr.left.val;\\n                        ws.push(curr.left);\\n                    }\\n                    \\n                    if(curr.left==null && curr.right==null){ // leaf node\\n                        sum+=curr.val;\\n                    }\\n                }\\n                return sum;\\n            }\\n        }",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n            public int sumNumbers(TreeNode root) {\\n                if(root==null){\\n                    return 0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3294242,
                "title": "c-recursive-100-beat-easy-o-n",
                "content": "# Intuition\\nwe need to visit leaf node and creating number from the root to leaf node , we need search for a leaf node and creating a number their digits, and need to repeat for all root to leaf node , At last we need to add all root to leaf created number.\\n\\n# Approach\\nTo find out the leaf node , simply traverse in preoder way (root, left,right) and when ever we find root->left == NULL and root->right==NULL , we can say that it is our leaf node , by preoder traversal we will be getting from root node to left leaf node, same goes goes for right one , After  getting one root to leaf node we will add to our final answer. When recursion comes back we are not considering value of their initial time not the updated one.\\n\\nUPVOTE if you read it!!! \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(H) hight of tree\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n #define ll long long\\nclass Solution {\\npublic:\\n\\n    void dfs(TreeNode *root, ll &ans , ll tmp){\\n        if(root->left== NULL && root->right==NULL){\\n            tmp = tmp*10 + root->val;\\n            ans+=tmp;\\n            return;\\n        }\\n        tmp = tmp*10 + root->val;\\n        if(root->left) dfs(root->left,ans,tmp);\\n        if(root->right) dfs(root->right,ans,tmp);\\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n        ll ans =0;\\n        dfs(root,ans,0);\\n        return int(ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n #define ll long long\\nclass Solution {\\npublic:\\n\\n    void dfs(TreeNode *root, ll &ans , ll tmp){\\n        if(root->left== NULL && root->right==NULL){\\n            tmp = tmp*10 + root->val;\\n            ans+=tmp;\\n            return;\\n        }\\n        tmp = tmp*10 + root->val;\\n        if(root->left) dfs(root->left,ans,tmp);\\n        if(root->right) dfs(root->right,ans,tmp);\\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n        ll ans =0;\\n        dfs(root,ans,0);\\n        return int(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41603,
                "title": "one-of-the-easier-solution-using-preorder-traversal-recursion",
                "content": "**The idea is to do a preorder traversal of the tree. In the preorder traversal, keep track of the value calculated till the current node, let this value be val. For every node, we update the val as val*10 plus node\\u2019s data.**\\n\\n\\n    /**\\n     * Definition for binary tree\\n     * struct TreeNode {\\n     *     int val;\\n     *     TreeNode *left;\\n     *     TreeNode *right;\\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        int sumNumbers(TreeNode *root) {\\n           return  sumNumberUtil(root,0);\\n            \\n        }\\n        // preorder\\n        int sumNumberUtil(struct TreeNode* node, int val)\\n        {\\n            if(node==NULL)\\n            return 0;\\n            \\n            val= val*10+node->val;\\n            if(node->left==NULL && node->right==NULL)\\n            {\\n                return val;\\n            }\\n            \\n            return sumNumberUtil(node->left,val)+sumNumberUtil(node->right, val);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int sumNumbers(TreeNode *root) {\\n           return  sumNumberUtil(root,0);\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 706982,
                "title": "c-4-lines-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root, int sum = 0) {\\n        if(!root) return 0;\\n        sum = sum*10 + root->val;\\n        if(!root->left && !root->right) return sum;\\n        return sumNumbers(root->left, sum) + sumNumbers(root->right, sum);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root, int sum = 0) {\\n        if(!root) return 0;\\n        sum = sum*10 + root->val;\\n        if(!root->left && !root->right) return sum;\\n        return sumNumbers(root->left, sum) + sumNumbers(root->right, sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1556690,
                "title": "c-short-explained-solution-dfs-100-faster",
                "content": "\\nI promise I did not read any other solutions when writing my code.\\nThe Idea:\\nThere is a function DFS, depth-first-search, and it does...\\n* If ```current == NULL``` return as you cannot do anything.\\n* If ```current->left == NULL && current->right == NULL``` there are no children. We will then do ```total += current->val```.\\n* Else, recurse ```DFS(current->left, value*10+current->val)``` and ```DFS(current->right, value*10+current->val)```.\\n\\nTime Complexity --> O(N), N is the number nodes in the tree.\\nSpace Complexity --> O(1).\\n\\n**Test Run:**\\n```\\nLets say the tree is:\\n\\t\\t\\t4\\n\\t\\t  /   \\\\\\n\\t\\t9      0\\n\\t             \\\\\\n\\t\\t\\t\\t  1\\nDFS(4, 0) runs DFS(9, 4) + DFS(0, 4).\\nDFS(9, 4) adds 49 to total.\\nDFS(0, 4) adds runs DFS(NULL, 40) + DFS(1, 40).\\nDFS(NULL, 40) doesn\\'t do anything.\\nDFS(1, 40) adds 401 to total.\\nIn the total == 450.\\n```\\n**Note:** DFS is a void function.\\n```\\nclass Solution {\\npublic:\\n    \\n    //This is the output.\\n    int total = 0;\\n    \\n    void DFS(TreeNode* current, int value){\\n        //If current == NULL, return.\\n        if (current == NULL){\\n            return;\\n        }\\n        \\n        //If current has no children add value*10+current->val to total. Then return.\\n        if (current->left == NULL && current->right == NULL){\\n            total += current->val;\\n            total += value*10;\\n            return\\n        }\\n        \\n        //If not run DFS(current->left&right, (value*10)+current->val)\\n        DFS(current->left, (value*10)+current->val);\\n        DFS(current->right, (value*10)+current->val);  \\n    }\\n    \\n    int sumNumbers(TreeNode* root) {\\n        //Run DFS to change total.\\n        DFS(root, 0);\\n        //Return total.\\n        return total;\\n    }\\n};\\n```\\n\\u263AThanks for reading this! \\u263B\\n\\u2705 Please Upvote! \\u2705",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```current == NULL```\n```current->left == NULL && current->right == NULL```\n```total += current->val```\n```DFS(current->left, value*10+current->val)```\n```DFS(current->right, value*10+current->val)```\n```\\nLets say the tree is:\\n\\t\\t\\t4\\n\\t\\t  /   \\\\\\n\\t\\t9      0\\n\\t             \\\\\\n\\t\\t\\t\\t  1\\nDFS(4, 0) runs DFS(9, 4) + DFS(0, 4).\\nDFS(9, 4) adds 49 to total.\\nDFS(0, 4) adds runs DFS(NULL, 40) + DFS(1, 40).\\nDFS(NULL, 40) doesn\\'t do anything.\\nDFS(1, 40) adds 401 to total.\\nIn the total == 450.\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    //This is the output.\\n    int total = 0;\\n    \\n    void DFS(TreeNode* current, int value){\\n        //If current == NULL, return.\\n        if (current == NULL){\\n            return;\\n        }\\n        \\n        //If current has no children add value*10+current->val to total. Then return.\\n        if (current->left == NULL && current->right == NULL){\\n            total += current->val;\\n            total += value*10;\\n            return\\n        }\\n        \\n        //If not run DFS(current->left&right, (value*10)+current->val)\\n        DFS(current->left, (value*10)+current->val);\\n        DFS(current->right, (value*10)+current->val);  \\n    }\\n    \\n    int sumNumbers(TreeNode* root) {\\n        //Run DFS to change total.\\n        DFS(root, 0);\\n        //Return total.\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41513,
                "title": "super-simple-dfs-solution",
                "content": "    public class Solution {\\n        public int sumNumbers(TreeNode root) {\\n            return sumNumbers(root, 0);\\n        }\\n        \\n        private int sumNumbers(TreeNode root, int sum){\\n            if(root == null) return 0;\\n            if(root.left == null && root.right == null)\\n                return sum + root.val;\\n            \\n            return sumNumbers(root.left, (sum + root.val) * 10) + sumNumbers(root.right, (sum + root.val) * 10);\\n            \\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int sumNumbers(TreeNode root) {\\n            return sumNumbers(root, 0);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 41474,
                "title": "java-iterative-and-recursive-solutions",
                "content": "        \\n    // dfs recursively\\n    public int sumNumbers1(TreeNode root) {\\n        return dfs(root, 0);\\n    }\\n    \\n    private int dfs(TreeNode node, int path) {\\n        if (node == null) {\\n            return 0;\\n        }\\n        path = path*10 + node.val;\\n        if (node.left == null && node.right == null) {\\n            return path;\\n        }\\n        return dfs(node.left, path) + dfs(node.right, path);\\n    }\\n    \\n    // import javafx.util.Pair;\\n    //dfs iteratively \\n    public int sumNumbers2(TreeNode root) {\\n        int ret = 0;\\n        Stack<Pair<TreeNode, Integer>> stack = new Stack<>();\\n        stack.push(new Pair(root, 0));\\n        while (!stack.isEmpty()) {\\n            Pair<TreeNode, Integer> p = stack.pop();\\n            TreeNode node = p.getKey();\\n            int value = p.getValue();\\n            if (node != null) {\\n                value = value*10 + node.val;\\n                if (node.left == null && node.right == null) {\\n                    ret += value;\\n                }\\n                stack.push(new Pair(node.right, value));\\n                stack.push(new Pair(node.left, value));\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    // bfs iteratively \\n    public int sumNumbers(TreeNode root) {\\n        int ret = 0;\\n        Queue<Pair<TreeNode, Integer>> queue = new LinkedList<>();\\n        queue.add(new Pair(root, 0));\\n        while (!queue.isEmpty()) {\\n            Pair<TreeNode, Integer> p = queue.poll();\\n            TreeNode node = p.getKey();\\n            int value = p.getValue();\\n            if (node != null) {\\n                value = value * 10 + node.val;\\n                if (node.left == null && node.right == null) {\\n                    ret += value;\\n                }\\n                queue.add(new Pair(node.left, value));\\n                queue.add(new Pair(node.right, value));\\n            }\\n        }\\n        return ret;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "        \\n    // dfs recursively\\n    public int sumNumbers1(TreeNode root) {\\n        return dfs(root, 0);\\n    }\\n    \\n    private int dfs(TreeNode node, int path) {\\n        if (node == null) {\\n            return 0;\\n        }\\n        path = path*10 + node.val;\\n        if (node.left == null && node.right == null) {\\n            return path;\\n        }\\n        return dfs(node.left, path) + dfs(node.right, path);\\n    }\\n    \\n    // import javafx.util.Pair;\\n    //dfs iteratively \\n    public int sumNumbers2(TreeNode root) {\\n        int ret = 0;\\n        Stack<Pair<TreeNode, Integer>> stack = new Stack<>();\\n        stack.push(new Pair(root, 0));\\n        while (!stack.isEmpty()) {\\n            Pair<TreeNode, Integer> p = stack.pop();\\n            TreeNode node = p.getKey();\\n            int value = p.getValue();\\n            if (node != null) {\\n                value = value*10 + node.val;\\n                if (node.left == null && node.right == null) {\\n                    ret += value;\\n                }\\n                stack.push(new Pair(node.right, value));\\n                stack.push(new Pair(node.left, value));\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    // bfs iteratively \\n    public int sumNumbers(TreeNode root) {\\n        int ret = 0;\\n        Queue<Pair<TreeNode, Integer>> queue = new LinkedList<>();\\n        queue.add(new Pair(root, 0));\\n        while (!queue.isEmpty()) {\\n            Pair<TreeNode, Integer> p = queue.poll();\\n            TreeNode node = p.getKey();\\n            int value = p.getValue();\\n            if (node != null) {\\n                value = value * 10 + node.val;\\n                if (node.left == null && node.right == null) {\\n                    ret += value;\\n                }\\n                queue.add(new Pair(node.left, value));\\n                queue.add(new Pair(node.right, value));\\n            }\\n        }\\n        return ret;\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 706148,
                "title": "java-short-easy-solution-100-faster",
                "content": "Do Upvote if this helps\\n```\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        return cal(0, root);\\n    }\\n    int cal(int curr, TreeNode root){\\n        if(root == null) return 0;\\n        curr = (10*curr) + root.val;\\n        if(root.left == null && root.right == null)  return curr;\\n        return cal(curr, root.left) + cal(curr, root.right);        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public int sumNumbers(TreeNode root) {\\n        return cal(0, root);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 41468,
                "title": "clean-python-solution",
                "content": "    def sumNumbers(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        def helper(sum, root):\\n            if not root:\\n                return 0   \\n            sum = sum * 10 + root.val\\n            if not root.left and not root.right:\\n                return sum\\n            return helper(sum, root.left) + helper(sum, root.right)\\n         \\n        return helper(0, root)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def sumNumbers(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        def helper(sum, root):\\n            if not root:\\n                return 0   \\n            sum = sum * 10 + root.val\\n            if not root.left and not root.right:\\n                return sum\\n            return helper(sum, root.left) + helper(sum, root.right)\\n         \\n        return helper(0, root)",
                "codeTag": "Python3"
            },
            {
                "id": 1556357,
                "title": "java-simple-and-readable-solution-dfs",
                "content": "**Problem statement at a glance:** Given, a tree. We need to find the sum of all root to leaf paths.\\n**Approach:**\\n1) We need to go from root to leaf, and whenever we are at leaf, form a number and add it to your result.\\n2) This can be done with DFS Traversal. Because in DFS we traverse child nodes and we go deep.\\n**Pictorial Representation:**\\n![image](https://assets.leetcode.com/users/images/4e9a516b-e912-4e64-8094-851adbab83f1_1635917131.9978747.png)\\n\\n**Time Complexity:** As we are traversing each node once, the time complexity will be O(N), where N is number of nodes.\\n**Space Complexity:** It takes stack space, as we are doing recursion. So space complexity is O(H), where H is the height of tree.\\n**Code:**\\n```\\n\\nclass Solution {\\n    // A helper function to perform DFS\\n    public int sumNumbersHelper(TreeNode root,int sum)\\n    {\\n        // Base case: If the root is null, then it doesnt have any value. So sum is 0\\n        if(root==null)\\n        {\\n            return 0; \\n        }\\n        // If tree has only one node, then the sum is value itself\\n        if(root.left==null && root.right==null)\\n        {\\n            int temp=sum*10+root.val;\\n            return temp;\\n        }\\n        // Else we take the previous sum and move it to left by one digit and root.val should be on unit digit. This can be done as sum*10+root.val\\n        int temp=sum*10+root.val;\\n        // Call the left subtree and right subtree and return the sum of them.\\n        return sumNumbersHelper(root.left,temp)+sumNumbersHelper(root.right,temp);\\n     }\\n    public int sumNumbers(TreeNode root) {\\n      // Calling helper function to perform DFS\\n      return sumNumbersHelper(root,0);\\n    }\\n}\\n```\\nThanks for reading! Please upvote and comment if you got a clear idea:)\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    // A helper function to perform DFS\\n    public int sumNumbersHelper(TreeNode root,int sum)\\n    {\\n        // Base case: If the root is null, then it doesnt have any value. So sum is 0\\n        if(root==null)\\n        {\\n            return 0; \\n        }\\n        // If tree has only one node, then the sum is value itself\\n        if(root.left==null && root.right==null)\\n        {\\n            int temp=sum*10+root.val;\\n            return temp;\\n        }\\n        // Else we take the previous sum and move it to left by one digit and root.val should be on unit digit. This can be done as sum*10+root.val\\n        int temp=sum*10+root.val;\\n        // Call the left subtree and right subtree and return the sum of them.\\n        return sumNumbersHelper(root.left,temp)+sumNumbersHelper(root.right,temp);\\n     }\\n    public int sumNumbers(TreeNode root) {\\n      // Calling helper function to perform DFS\\n      return sumNumbersHelper(root,0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297708,
                "title": "simple-dfs-using-python-by-akash-sinha",
                "content": "**Coder: Akash Sinha**\\n\\n# Intuition\\nAs we have to calculate the path of each leaf node so we have to use **DFS**, the **base condition** must be if both the left and right child of the node are **None**.\\n\\n# Approach\\nOnce the base condition is decided just apply simple DFS and keep on adding the node value in a string. Also make a copy of this string because while applying DFS we will give a recursive call on both left child and right child, so we will require **2 copies of string** for these **2 recursive calls**. Once the base condition is reached, just **append the string into a global list**. Finally the list will contain all the paths from root to leaf nodes. Run a loop on it and add the numbers and return the sum.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        global l\\n        l=[]\\n        def f(root,s):\\n            if(root is None):\\n                pass\\n            elif(root.left is None and root.right is None):\\n                s+=str(root.val)\\n                l.append(s)\\n            else:\\n                s+=str(root.val)\\n                s1=s[::]\\n                f(root.left,s)\\n                f(root.right,s1)\\n        f(root,\"\")\\n        ans=0\\n        for i in l:\\n            ans+=int(i)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        global l\\n        l=[]\\n        def f(root,s):\\n            if(root is None):\\n                pass\\n            elif(root.left is None and root.right is None):\\n                s+=str(root.val)\\n                l.append(s)\\n            else:\\n                s+=str(root.val)\\n                s1=s[::]\\n                f(root.left,s)\\n                f(root.right,s1)\\n        f(root,\"\")\\n        ans=0\\n        for i in l:\\n            ans+=int(i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 706461,
                "title": "javascript-2-clean-code-dfs-solutions",
                "content": "### Approach - 1 \\n```javascript\\nvar sumNumbers = function(root) {\\n    \\n    function traverse(node, num) {\\n        if(!node) return null;\\n        num += node.val\\n        if(!node.left && !node.right) return +num;\\n        return traverse(node.left, num) + traverse(node.right, num);\\n    }\\n    return traverse(root, \\'\\');\\n};\\n```\\n\\n### Approach - 2\\n```javascript\\nvar sumNumbers = function(root) {\\n    if(!root) return null;\\n    let sum = 0;\\n    \\n    function traverse(node, num) {\\n        num += node.val\\n        if(!node.left && !node.right) sum += +num;\\n        if(node.left) traverse(node.left, num)\\n        if(node.right) traverse(node.right, num);\\n    }\\n    traverse(root, \\'\\');\\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar sumNumbers = function(root) {\\n    \\n    function traverse(node, num) {\\n        if(!node) return null;\\n        num += node.val\\n        if(!node.left && !node.right) return +num;\\n        return traverse(node.left, num) + traverse(node.right, num);\\n    }\\n    return traverse(root, \\'\\');\\n};\\n```\n```javascript\\nvar sumNumbers = function(root) {\\n    if(!root) return null;\\n    let sum = 0;\\n    \\n    function traverse(node, num) {\\n        num += node.val\\n        if(!node.left && !node.right) sum += +num;\\n        if(node.left) traverse(node.left, num)\\n        if(node.right) traverse(node.right, num);\\n    }\\n    traverse(root, \\'\\');\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1935362,
                "title": "100-fastest-swift-solution-time-o-n-space-o-n",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in binary tree.\\n    //   - space: O(n), where n is the number of nodes in binary tree.\\n    \\n    func sumNumbers(_ root: TreeNode?) -> Int {\\n        guard let root = root else { return 0 }\\n        return sumNumbers(root, sum: 0)\\n    }\\n    \\n\\n    private func sumNumbers(_ root: TreeNode?, sum: Int) -> Int {\\n        guard let root = root else { return 0 }\\n\\n        if root.left == nil, root.right == nil {\\n            return 10 * sum + root.val\\n        }\\n\\n        return sumNumbers(root.left, sum: 10 * sum + root.val) + sumNumbers(root.right, sum: 10 * sum + root.val)\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in binary tree.\\n    //   - space: O(n), where n is the number of nodes in binary tree.\\n    \\n    func sumNumbers(_ root: TreeNode?) -> Int {\\n        guard let root = root else { return 0 }\\n        return sumNumbers(root, sum: 0)\\n    }\\n    \\n\\n    private func sumNumbers(_ root: TreeNode?, sum: Int) -> Int {\\n        guard let root = root else { return 0 }\\n\\n        if root.left == nil, root.right == nil {\\n            return 10 * sum + root.val\\n        }\\n\\n        return sumNumbers(root.left, sum: 10 * sum + root.val) + sumNumbers(root.right, sum: 10 * sum + root.val)\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1555854,
                "title": "c-simple-and-clean-recursive-solution-explained",
                "content": "**Explanation:**\\nWe are using typical preorder traversal on a tree.\\nIn each node we visit, first we concatenate the value to the current number.\\nIf we are in a leaf, we add `curr` to the result.\\nOtherwise, we continue recursion with `curr`.\\n\\n**Time Complexity:** O(n), we visit each node exactly once.\\n**Space Complexity:** O(1) if we don\\'t consider recursion stack. With recursion call stack it\\'s O(height-of-tree).\\n```\\nclass Solution {\\npublic:\\n    int res = 0;\\n    void rec(TreeNode* node, int curr) {\\n        if (!node) return;\\n        \\n        curr = curr * 10 + node->val;\\n        \\n        if (!node->left && !node->right) {\\n            res += curr;\\n            return;\\n        }\\n        \\n        rec(node->left, curr);\\n        rec(node->right, curr);\\n    }\\n    \\n    int sumNumbers(TreeNode* root) {\\n        rec(root, 0);\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int res = 0;\\n    void rec(TreeNode* node, int curr) {\\n        if (!node) return;\\n        \\n        curr = curr * 10 + node->val;\\n        \\n        if (!node->left && !node->right) {\\n            res += curr;\\n            return;\\n        }\\n        \\n        rec(node->left, curr);\\n        rec(node->right, curr);\\n    }\\n    \\n    int sumNumbers(TreeNode* root) {\\n        rec(root, 0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297233,
                "title": "day-73-dfs-easiest-beginner-friendly-sol",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Intuition of this Problem:\\nThe intuition behind the problem is to traverse the binary tree using a depth-first search (DFS) approach and keep track of the sum of the numbers formed so far along each path from the root to the leaf nodes.\\n\\nAs we traverse each path from the root to a leaf node, we can calculate the sum of the numbers formed by concatenating the values of each node along the path. We can then add this sum to a running total.\\n\\nOnce we have traversed all possible paths from the root to the leaf nodes, we will have accumulated the sum of all root-to-leaf paths in the binary tree. Finally, we can return this sum as the solution to the problem.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem:\\n1. Define a helper function that takes in the current node, the total sum, and the sum till the current node.\\n2. If the current node is null, return.\\n3. Calculate the sum till the current node by multiplying the sum till the previous node by 10 and adding the value of the current node.\\n4. If the current node is a leaf node, add the sum till the current node to the total sum.\\n5. Recursively call the helper function for the left and right child of the current node with updated parameters.\\n6. Define the main function that initializes the total sum to 0 and calls the helper function with the root node and the total sum.\\n7. Return the total sum.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code:\\n```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void helper (TreeNode *root, int &totalSum, int sumTillCurrNode) {\\n        if (root == nullptr)\\n            return; \\n        sumTillCurrNode = sumTillCurrNode * 10 + root -> val;\\n        if (root -> left == nullptr && root -> right == nullptr)\\n            totalSum += sumTillCurrNode;\\n        helper(root -> left, totalSum, sumTillCurrNode);\\n        helper(root -> right, totalSum, sumTillCurrNode);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        int sum = 0;\\n        helper (root, sum, 0);\\n        return sum;\\n    }\\n};\\n```\\n```Java []\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        int[] totalSum = new int[1];\\n        helper(root, totalSum, 0);\\n        return totalSum[0];\\n    }\\n\\n    private void helper(TreeNode root, int[] totalSum, int sumTillCurrNode) {\\n        if (root == null) {\\n            return;\\n        }\\n        sumTillCurrNode = sumTillCurrNode * 10 + root.val;\\n        if (root.left == null && root.right == null) {\\n            totalSum[0] += sumTillCurrNode;\\n        }\\n        helper(root.left, totalSum, sumTillCurrNode);\\n        helper(root.right, totalSum, sumTillCurrNode);\\n    }\\n}\\n\\n```\\n```Python []\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sumNumbers(self, root: TreeNode) -> int:\\n        totalSum = [0]\\n        self.helper(root, totalSum, 0)\\n        return totalSum[0]\\n\\n    def helper(self, root: TreeNode, totalSum: List[int], sumTillCurrNode: int) -> None:\\n        if root is None:\\n            return\\n        sumTillCurrNode = sumTillCurrNode * 10 + root.val\\n        if root.left is None and root.right is None:\\n            totalSum[0] += sumTillCurrNode\\n        self.helper(root.left, totalSum, sumTillCurrNode)\\n        self.helper(root.right, totalSum, sumTillCurrNode)\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(n)**, where n is the number of nodes in the tree. We need to visit every node in the worst case.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(h)**, where h is the height of the tree. This is the space used by the call stack during recursion, which can go up to the height of the tree. Where O(h) equals O(n) in the worst case and O(log(n)) in the best case.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void helper (TreeNode *root, int &totalSum, int sumTillCurrNode) {\\n        if (root == nullptr)\\n            return; \\n        sumTillCurrNode = sumTillCurrNode * 10 + root -> val;\\n        if (root -> left == nullptr && root -> right == nullptr)\\n            totalSum += sumTillCurrNode;\\n        helper(root -> left, totalSum, sumTillCurrNode);\\n        helper(root -> right, totalSum, sumTillCurrNode);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        int sum = 0;\\n        helper (root, sum, 0);\\n        return sum;\\n    }\\n};\\n```\n```Java []\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        int[] totalSum = new int[1];\\n        helper(root, totalSum, 0);\\n        return totalSum[0];\\n    }\\n\\n    private void helper(TreeNode root, int[] totalSum, int sumTillCurrNode) {\\n        if (root == null) {\\n            return;\\n        }\\n        sumTillCurrNode = sumTillCurrNode * 10 + root.val;\\n        if (root.left == null && root.right == null) {\\n            totalSum[0] += sumTillCurrNode;\\n        }\\n        helper(root.left, totalSum, sumTillCurrNode);\\n        helper(root.right, totalSum, sumTillCurrNode);\\n    }\\n}\\n\\n```\n```Python []\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sumNumbers(self, root: TreeNode) -> int:\\n        totalSum = [0]\\n        self.helper(root, totalSum, 0)\\n        return totalSum[0]\\n\\n    def helper(self, root: TreeNode, totalSum: List[int], sumTillCurrNode: int) -> None:\\n        if root is None:\\n            return\\n        sumTillCurrNode = sumTillCurrNode * 10 + root.val\\n        if root.left is None and root.right is None:\\n            totalSum[0] += sumTillCurrNode\\n        self.helper(root.left, totalSum, sumTillCurrNode)\\n        self.helper(root.right, totalSum, sumTillCurrNode)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799054,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        stack<pair<TreeNode*, int>> s;      // {node, cur}\\n        s.push({root, 0});\\n        int sum = 0;\\n        while(!s.empty()) {\\n            auto [root, cur] = s.top(); s.pop();\\n            cur = cur * 10 + root -> val;\\n            if(!root -> left && !root -> right) sum += cur;  // reached leaf node\\n            if(root -> right) s.push({root -> right, cur});\\n            if(root -> left) s.push({root -> left, cur});\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        stack<pair<TreeNode*, int>> s;      // {node, cur}\\n        s.push({root, 0});\\n        int sum = 0;\\n        while(!s.empty()) {\\n            auto [root, cur] = s.top(); s.pop();\\n            cur = cur * 10 + root -> val;\\n            if(!root -> left && !root -> right) sum += cur;  // reached leaf node\\n            if(root -> right) s.push({root -> right, cur});\\n            if(root -> left) s.push({root -> left, cur});\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1246702,
                "title": "dfs-solution-for-beginners-with-explanation-100-faster",
                "content": "Any DFS based solution follows one common structure:\\n```\\ngivenfun(TreeNode* root)\\n{\\n\\t//call helper class\\n\\thelper(root);\\n}\\n\\nvoid helper(TreeNode* root)\\n{\\n\\tif(!root) return;\\n\\t/*\\n\\tDo some necessary task here\\n\\t*/\\n\\t//call recursively to left node and right node\\n\\thelper(root->left);\\n\\thelper(root->right);\\n\\t//that\\'s it.\\n}\\n```\\n\\nHere, we need to find the sum of root-leaf path. So, we can think of storing node values in string which can be converted to integer while computing sum. \\nso here you go. \\n\\n```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    void helper(TreeNode* root, string s)\\n    {\\n        if(!root) return;\\n        if(!root->left && !root->right) \\n        {\\n            //cout<<s<<endl;\\n           sum+=stoi(s+to_string(root->val));\\n            return;\\n        }\\n        helper(root->left, s+to_string(root->val));\\n        helper(root->right, s+to_string(root->val));\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        if(!root) return 0;\\n        helper(root,\"\");\\n        return sum;\\n    }\\n};\\n```\\nBeats 100% runtime.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ngivenfun(TreeNode* root)\\n{\\n\\t//call helper class\\n\\thelper(root);\\n}\\n\\nvoid helper(TreeNode* root)\\n{\\n\\tif(!root) return;\\n\\t/*\\n\\tDo some necessary task here\\n\\t*/\\n\\t//call recursively to left node and right node\\n\\thelper(root->left);\\n\\thelper(root->right);\\n\\t//that\\'s it.\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    void helper(TreeNode* root, string s)\\n    {\\n        if(!root) return;\\n        if(!root->left && !root->right) \\n        {\\n            //cout<<s<<endl;\\n           sum+=stoi(s+to_string(root->val));\\n            return;\\n        }\\n        helper(root->left, s+to_string(root->val));\\n        helper(root->right, s+to_string(root->val));\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        if(!root) return 0;\\n        helper(root,\"\");\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 328123,
                "title": "simple-python-solution-top-down-dfs",
                "content": "Please see and vote for my solutions for these similar problems.\\n\\n[257. Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/discuss/309004/Different-DFS-Python-solutions)\\n```\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        def dfs(node, path, res):\\n            if node.left == None and node.right == None:\\n                res.append(path + str(node.val))\\n            if node.left:\\n                dfs(node.left, path + str(node.val) + \\'->\\', res)\\n            if node.right:\\n                dfs(node.right, path + str(node.val) + \\'->\\', res)\\n        \\n        if not root:\\n            return []\\n        res = []\\n        dfs(root, \"\", res)\\n        return res\\n```\\n\\n[129. Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/discuss/328123/Simple-Python-Solution%3A-top-down-DFS)\\n```\\n    def sumNumbers(self, root: TreeNode) -> int:\\n        def dfs(node, bits, res):\\n            if node.left == None and node.right == None:\\n                res[0] += int(bits + str(node.val), 10)\\n            if node.left:\\n                dfs(node.left, bits + str(node.val), res)\\n            if node.right:\\n                dfs(node.right, bits + str(node.val), res)\\n        \\n        if root == None:\\n            return 0\\n        bits, res = \\'\\', [0]\\n        dfs(root, bits, res)\\n        return res[0]\\n```\\n\\n[1022. Sum of Root To Leaf Binary Numbers](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/discuss/328033/Top-down-Python-DFS-Solution)\\n```\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        def dfs(node, bits, res):\\n            if node.left == None and node.right == None:\\n                res[0] += int(bits + str(node.val), 2)\\n            if node.left:\\n                dfs(node.left, bits + str(node.val), res)\\n            if node.right:\\n                dfs(node.right, bits + str(node.val), res)\\n        \\n        if root == None:\\n            return 0\\n        bits, res = \\'\\', [0]\\n        dfs(root, bits, res)\\n        return res[0]\\n```\\n\\n[988. Smallest String Starting From Leaf](https://leetcode.com/problems/smallest-string-starting-from-leaf/discuss/328119/Simple-Python-Solution%3A-top-down-DFS)\\n```\\n    def smallestFromLeaf(self, root: TreeNode) -> str:\\n        def dfs(root, s):\\n            s = s + chr(ord(\\'a\\') + root.val)\\n            if not root.left and not root.right:\\n                if res[0] == None:\\n                    res[0] = s[::-1]\\n                else:\\n                    res[0] = min(res[0], s[::-1])\\n            if root.left:\\n                dfs(root.left, s)\\n            if root.right:\\n                dfs(root.right, s)\\n        \\n        if not root:\\n            return \\'\\'\\n        res = [None]\\n        dfs(root, \\'\\')\\n        return res[0]\\n```\\n\\n[112. Path Sum](https://leetcode.com/problems/path-sum/discuss/328124/Simple-Python-Solution%3A-top-down-DFS)\\n\\n```\\n    def hasPathSum(self, root: TreeNode, s: int) -> bool:\\n        def dfs(root, curr_s):\\n            curr_s += root.val\\n            if not root.left and not root.right:\\n                if curr_s == s:\\n                    res[0] = True\\n                    return\\n            if not res[0] and root.left:\\n                dfs(root.left, curr_s)\\n            if not res[0] and root.right:\\n                dfs(root.right, curr_s)\\n        \\n        if not root:\\n            return False\\n        res = [False]\\n        dfs(root, 0)\\n        return res[0]\\n```\\n\\n[113. Path Sum II](https://leetcode.com/problems/path-sum-ii/discuss/328125/Simple-Python-Solution%3A-top-down-DFS)\\n```\\n    def pathSum(self, root: TreeNode, s: int) -> List[List[int]]:\\n        def dfs(root, lst, curr_s):\\n            curr_s += root.val\\n            if not root.left and not root.right:\\n                if curr_s == s:\\n                    res.append(lst + [root.val])\\n                    return\\n            if root.left:\\n                dfs(root.left, lst + [root.val], curr_s)\\n            if root.right:\\n                dfs(root.right, lst + [root.val], curr_s)\\n        \\n        if not root:\\n            return []\\n        res = []\\n        dfs(root, [], 0)\\n        return res\\n```\\n\\n[437. Path Sum III](https://leetcode.com/problems/path-sum-iii/discuss/328128/Simple-Python-Solution%3A-top-down-DFS-%2B-DP) (Similar problem: 560. Subarray Sum Equals K)\\n\\n```\\n    def pathSum(self, root, s):\\n        def dfs(root, curr_s):\\n            curr_s += root.val\\n            res[0] += pre_sums.get(curr_s - s, 0)\\n            pre_sums[curr_s] = pre_sums.get(curr_s, 0) + 1\\n            if root.left:\\n                dfs(root.left, curr_s)\\n            if root.right:\\n                dfs(root.right, curr_s)\\n            pre_sums[curr_s] -= 1\\n            if pre_sums[curr_s] == 0:\\n                del pre_sums[curr_s]\\n        \\n        res = [0]\\n        pre_sums = {0: 1}\\n        if not root:\\n            return res[0]\\n        dfs(root, 0)\\n        return res[0]\\n```",
                "solutionTags": [],
                "code": "```\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        def dfs(node, path, res):\\n            if node.left == None and node.right == None:\\n                res.append(path + str(node.val))\\n            if node.left:\\n                dfs(node.left, path + str(node.val) + \\'->\\', res)\\n            if node.right:\\n                dfs(node.right, path + str(node.val) + \\'->\\', res)\\n        \\n        if not root:\\n            return []\\n        res = []\\n        dfs(root, \"\", res)\\n        return res\\n```\n```\\n    def sumNumbers(self, root: TreeNode) -> int:\\n        def dfs(node, bits, res):\\n            if node.left == None and node.right == None:\\n                res[0] += int(bits + str(node.val), 10)\\n            if node.left:\\n                dfs(node.left, bits + str(node.val), res)\\n            if node.right:\\n                dfs(node.right, bits + str(node.val), res)\\n        \\n        if root == None:\\n            return 0\\n        bits, res = \\'\\', [0]\\n        dfs(root, bits, res)\\n        return res[0]\\n```\n```\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        def dfs(node, bits, res):\\n            if node.left == None and node.right == None:\\n                res[0] += int(bits + str(node.val), 2)\\n            if node.left:\\n                dfs(node.left, bits + str(node.val), res)\\n            if node.right:\\n                dfs(node.right, bits + str(node.val), res)\\n        \\n        if root == None:\\n            return 0\\n        bits, res = \\'\\', [0]\\n        dfs(root, bits, res)\\n        return res[0]\\n```\n```\\n    def smallestFromLeaf(self, root: TreeNode) -> str:\\n        def dfs(root, s):\\n            s = s + chr(ord(\\'a\\') + root.val)\\n            if not root.left and not root.right:\\n                if res[0] == None:\\n                    res[0] = s[::-1]\\n                else:\\n                    res[0] = min(res[0], s[::-1])\\n            if root.left:\\n                dfs(root.left, s)\\n            if root.right:\\n                dfs(root.right, s)\\n        \\n        if not root:\\n            return \\'\\'\\n        res = [None]\\n        dfs(root, \\'\\')\\n        return res[0]\\n```\n```\\n    def hasPathSum(self, root: TreeNode, s: int) -> bool:\\n        def dfs(root, curr_s):\\n            curr_s += root.val\\n            if not root.left and not root.right:\\n                if curr_s == s:\\n                    res[0] = True\\n                    return\\n            if not res[0] and root.left:\\n                dfs(root.left, curr_s)\\n            if not res[0] and root.right:\\n                dfs(root.right, curr_s)\\n        \\n        if not root:\\n            return False\\n        res = [False]\\n        dfs(root, 0)\\n        return res[0]\\n```\n```\\n    def pathSum(self, root: TreeNode, s: int) -> List[List[int]]:\\n        def dfs(root, lst, curr_s):\\n            curr_s += root.val\\n            if not root.left and not root.right:\\n                if curr_s == s:\\n                    res.append(lst + [root.val])\\n                    return\\n            if root.left:\\n                dfs(root.left, lst + [root.val], curr_s)\\n            if root.right:\\n                dfs(root.right, lst + [root.val], curr_s)\\n        \\n        if not root:\\n            return []\\n        res = []\\n        dfs(root, [], 0)\\n        return res\\n```\n```\\n    def pathSum(self, root, s):\\n        def dfs(root, curr_s):\\n            curr_s += root.val\\n            res[0] += pre_sums.get(curr_s - s, 0)\\n            pre_sums[curr_s] = pre_sums.get(curr_s, 0) + 1\\n            if root.left:\\n                dfs(root.left, curr_s)\\n            if root.right:\\n                dfs(root.right, curr_s)\\n            pre_sums[curr_s] -= 1\\n            if pre_sums[curr_s] == 0:\\n                del pre_sums[curr_s]\\n        \\n        res = [0]\\n        pre_sums = {0: 1}\\n        if not root:\\n            return res[0]\\n        dfs(root, 0)\\n        return res[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3294635,
                "title": "day-42-recursive-solution-100-fast-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMove to every path from root to each leaf and while moving keep concatenating the number and when you reach the leaf add it to your answer.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)  (stack space)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    void dfs(TreeNode* root,int& ans,int i){\\n        if(!root->left and !root->right){\\n            ans+=i;\\n            return;\\n        }\\n        if(root->left)dfs(root->left,ans,(i*10)+root->left->val);\\n        if(root->right)dfs(root->right,ans,(i*10)+root->right->val);\\n    }\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        int ans=0;\\n        dfs(root,ans,root->val);\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n***DO SHARE YOUR SOLUTION IN THE COMMENTS. HAPPY CODING!***",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\n    void dfs(TreeNode* root,int& ans,int i){\\n        if(!root->left and !root->right){\\n            ans+=i;\\n            return;\\n        }\\n        if(root->left)dfs(root->left,ans,(i*10)+root->left->val);\\n        if(root->right)dfs(root->right,ans,(i*10)+root->right->val);\\n    }\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        int ans=0;\\n        dfs(root,ans,root->val);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293914,
                "title": "easy-to-understand-with-illustration",
                "content": "![image](https://assets.leetcode.com/users/images/3f30121c-1efe-456a-ae5d-f4429ec716d8_1678753582.6372776.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* curr, int& totalSum, int numTillParent)\\n    {\\n        if (curr == NULL) return;\\n        \\n        int numTillCurr = (numTillParent * 10) + (curr->val);\\n        if (curr->left == NULL && curr->right == NULL)  //leaf node\\n        {\\n            totalSum += numTillCurr;\\n            return; \\n        }\\n        solve(curr->left, totalSum, numTillCurr);\\n        solve(curr->right, totalSum, numTillCurr);\\n    }\\n    int sumNumbers(TreeNode* root) \\n    {\\n        int totalSum = 0;\\n        solve(root, totalSum, 0);\\n        return (totalSum); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* curr, int& totalSum, int numTillParent)\\n    {\\n        if (curr == NULL) return;\\n        \\n        int numTillCurr = (numTillParent * 10) + (curr->val);\\n        if (curr->left == NULL && curr->right == NULL)  //leaf node\\n        {\\n            totalSum += numTillCurr;\\n            return; \\n        }\\n        solve(curr->left, totalSum, numTillCurr);\\n        solve(curr->right, totalSum, numTillCurr);\\n    }\\n    int sumNumbers(TreeNode* root) \\n    {\\n        int totalSum = 0;\\n        solve(root, totalSum, 0);\\n        return (totalSum); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 324261,
                "title": "c-100-beat-recursive-searching-o-n-speed-o-n-space",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int mResult;\\n    \\n    int sumNumbers(TreeNode* root) {\\n        mResult = 0;\\n        if (root != NULL) {\\n            sumNumbers(root, 0);\\n        }\\n        return mResult;\\n    }\\n    \\n    void sumNumbers(TreeNode* root, int val) {\\n        \\n        val *= 10;\\n        val += root->val;\\n        \\n        if (!root->left && !root->right) {\\n            mResult += val;\\n        }\\n        \\n        if (root->left)  { sumNumbers(root->left , val); }\\n        if (root->right) { sumNumbers(root->right, val); }\\n    }\\n    \\n};\\n```\\n\\nAs you dive deeper into the number, you can multiply the parent\\'s number by 10 and add the current node.\\n\\nFor example.\\n   [5]\\n /       \\\\\\n[3]   [6]\\n\\n--We start with 0, multiply by 10 and add 5.\\n\\n----We start with 5, multiply by 10 and add 3.\\n----We start with 5, multiply by 10 and add 6.\\n\\nSo 53 + 56",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int mResult;\\n    \\n    int sumNumbers(TreeNode* root) {\\n        mResult = 0;\\n        if (root != NULL) {\\n            sumNumbers(root, 0);\\n        }\\n        return mResult;\\n    }\\n    \\n    void sumNumbers(TreeNode* root, int val) {\\n        \\n        val *= 10;\\n        val += root->val;\\n        \\n        if (!root->left && !root->right) {\\n            mResult += val;\\n        }\\n        \\n        if (root->left)  { sumNumbers(root->left , val); }\\n        if (root->right) { sumNumbers(root->right, val); }\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41541,
                "title": "3-line-c-solution",
                "content": "    /**\\n     * Definition for a binary tree node.\\n     * struct TreeNode {\\n     *     int val;\\n     *     TreeNode *left;\\n     *     TreeNode *right;\\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        int sumNumbers(TreeNode* r, int b=0) {\\n            if (!r) return 0;\\n            if (r->left || r->right) return sumNumbers(r->left, 10*b + r->val) + sumNumbers(r->right, 10*b + r->val);\\n            else return 10*b + r->val;\\n        }\\n    };",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n        int sumNumbers(TreeNode* r, int b=0) {\\n            if (!r) return 0;\\n            if (r->left || r->right) return sumNumbers(r->left, 10*b + r->val) + sumNumbers(r->right, 10*b + r->val);\\n            else return 10*b + r->val;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 41585,
                "title": "c-only-3-line-and-8ms-for-my-code",
                "content": "class Solution {\\n\\npublic:\\n\\n    int sumNumbers(TreeNode *root) {\\n\\n        if (!root) return 0;\\n\\n        if (!root->left && !root->right) return root->val;\\n\\n        return (root->left ? root->left->val += root->val * 10, sumNumbers(root->left) : 0) + (root->right ? root->right->val += root->val * 10, sumNumbers(root->right) : 0);\\n\\n    } \\n\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\npublic:\\n\\n    int sumNumbers(TreeNode *root) {\\n\\n        if (!root) return 0;\\n\\n        if (!root->left && !root->right) return root->val;\\n\\n        return (root->left ? root->left->val += root->val * 10, sumNumbers(root->left) : 0) + (root->right ? root->right->val += root->val * 10, sumNumbers(root->right) : 0);\\n\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3352371,
                "title": "easy-java-recusion-solution-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The sumNumbers method is called with the root of the binary tree as an argument.\\n- The makeSumTrav method is called with the root of the tree and an initial sum of 0 as arguments.\\n- In the makeSumTrav method, if the current node is null, the method returns without doing anything.\\n- The current sum is updated by multiplying it by 10 and adding the value of the current node.\\n- If the current node is a leaf node (i.e., it has no left or right children), its value is added to the final result (ans) and the method returns.\\n- The makeSumTrav method is called recursively for the left and right children of the current node with the updated sum as an argument.\\n- This process continues until all root-to-leaf paths in the tree have been traversed and their values have been added to the final result (ans).\\n- The final result (ans) is returned by the sumNumbers method.\\n\\n# Complexity\\n- Time complexity: **Beats 100%**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this code is **O(n)**, where n is the number of nodes in the binary tree. This is because the algorithm needs to visit each node in the tree once to calculate the sum of all root-to-leaf numbers.\\n\\n- Space complexity: **Beats 72%**\\n\\nThe space complexity of this code is **O(h)**, where h is the height of the binary tree. This is because the recursive call stack can grow up to a maximum depth of h.\\n\\n# Code\\n```\\nclass Solution {\\n    public int ans=0;\\n    public int sumNumbers(TreeNode root) {\\n        makeSumTrav(root,0);\\n        return ans;\\n    }\\n    public void makeSumTrav(TreeNode curr,int sum)\\n    {\\n        \\n        if(curr==null)\\n            return;\\n        sum=sum*10+curr.val;\\n        if(curr.left==null&&curr.right==null)\\n        {\\n         ans+=sum;\\n         return;\\n        }\\n        makeSumTrav(curr.left,sum);\\n        makeSumTrav(curr.right,sum);\\n        \\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int ans=0;\\n    public int sumNumbers(TreeNode root) {\\n        makeSumTrav(root,0);\\n        return ans;\\n    }\\n    public void makeSumTrav(TreeNode curr,int sum)\\n    {\\n        \\n        if(curr==null)\\n            return;\\n        sum=sum*10+curr.val;\\n        if(curr.left==null&&curr.right==null)\\n        {\\n         ans+=sum;\\n         return;\\n        }\\n        makeSumTrav(curr.left,sum);\\n        makeSumTrav(curr.right,sum);\\n        \\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296649,
                "title": "c-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        return dfs(root, 0);\\n    }\\n    \\n    int dfs(TreeNode* root, int sum) {\\n        if (!root) {\\n            return 0;\\n        }\\n        sum = sum * 10 + root->val;\\n        if (!root->left && !root->right) {\\n            return sum;\\n        }\\n        return dfs(root->left, sum) + dfs(root->right, sum);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        return dfs(root, 0);\\n    }\\n    \\n    int dfs(TreeNode* root, int sum) {\\n        if (!root) {\\n            return 0;\\n        }\\n        sum = sum * 10 + root->val;\\n        if (!root->left && !root->right) {\\n            return sum;\\n        }\\n        return dfs(root->left, sum) + dfs(root->right, sum);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3295156,
                "title": "easiest-7-lines-code-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        def dfs(curr,num):\\n            if curr is None:\\n                return 0\\n            num=num*10+curr.val\\n            if not curr.left  and not curr.right:\\n                return num\\n            return dfs(curr.left,num)+dfs(curr.right,num)\\n        return dfs(root,0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        def dfs(curr,num):\\n            if curr is None:\\n                return 0\\n            num=num*10+curr.val\\n            if not curr.left  and not curr.right:\\n                return num\\n            return dfs(curr.left,num)+dfs(curr.right,num)\\n        return dfs(root,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654589,
                "title": "python3-dfs-easy-understanding",
                "content": "```\\ndef sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        self.ans = 0\\n        \\n        def dfs(cur_node: Optional[TreeNode], num: int):\\n            if not cur_node.left and not cur_node.right:\\n                self.ans += num * 10 + cur_node.val\\n                return\\n            \\n            if cur_node.left:\\n                dfs(cur_node.left, num * 10 + cur_node.val)\\n            \\n            if cur_node.right:\\n                dfs(cur_node.right, num * 10 + cur_node.val)\\n            \\n        dfs(root, 0)\\n        \\n        return self.ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ndef sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        self.ans = 0\\n        \\n        def dfs(cur_node: Optional[TreeNode], num: int):\\n            if not cur_node.left and not cur_node.right:\\n                self.ans += num * 10 + cur_node.val\\n                return\\n            \\n            if cur_node.left:\\n                dfs(cur_node.left, num * 10 + cur_node.val)\\n            \\n            if cur_node.right:\\n                dfs(cur_node.right, num * 10 + cur_node.val)\\n            \\n        dfs(root, 0)\\n        \\n        return self.ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 706363,
                "title": "c-general-approach-for-similar-problems",
                "content": "Our goal is to find the sum of all the numbers that are formed by each root to leaf path. For example, consider the tree\\n<pre>\\n    4\\n   / \\\\ \\n  9   0\\n / \\\\\\n5   1\\n</pre>\\n\\nThe answer is 495 + 491 + 40 = 1026\\n\\nWe traverse through all the nodes and compute the number formed from root to the current node. Whenever we come across a leaf node, we add the number to our answer. The code for this logic is as follows.\\n\\n```\\nclass Solution {\\nprivate:\\n    void traverse(TreeNode *root, long num, long &ans)\\n    {\\n        if(!root)\\n            return;\\n        num = root->val + num * 10; // Calculate the number formed so far.\\n        if(root->left == NULL && root->right == NULL) // Leaf node condition\\n        {\\n            ans += num;\\n            return;\\n        }\\n\\t\\t\\n        traverse(root->left, num, ans);\\n        traverse(root->right, num, ans);\\n    }\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        \\n        long ans = 0;\\n        traverse(root, 0, ans);\\n        return ans;\\n    }\\n};\\n```\\n\\nThe time complexity will O(n) where n is the number of nodes in the tree.\\n\\nThis problem is similar to the Problem 257: Binary Tree Paths (https://leetcode.com/problems/binary-tree-paths/), where we have to return all the root to leaf paths. Do give it a try as well, if you have not already solved it.",
                "solutionTags": [
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void traverse(TreeNode *root, long num, long &ans)\\n    {\\n        if(!root)\\n            return;\\n        num = root->val + num * 10; // Calculate the number formed so far.\\n        if(root->left == NULL && root->right == NULL) // Leaf node condition\\n        {\\n            ans += num;\\n            return;\\n        }\\n\\t\\t\\n        traverse(root->left, num, ans);\\n        traverse(root->right, num, ans);\\n    }\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        \\n        long ans = 0;\\n        traverse(root, 0, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 706028,
                "title": "c-two-solutions",
                "content": "This problem is quite simple. We will see the first space expensive appraoch to understand the problem.\\nThen I will show you the more optimized one.\\n\\nApproach 1:\\n```\\n\\n int sumNumbers(TreeNode *root)\\n    {\\n        if (!root)  // If there is no element return 0 as the sum\\n            return 0;\\n\\t\\t// This vector will contain all the numbers from root to all leaves\\n        vector<int> v;   // so for tree in the first example after dfs this vector will have numbers 12 and 13\\n        // This array contains all the digits we came across from root to the current node.\\n\\t\\tvector<int> d;  // So when we are at 2 the array will be [1,2] and when we are at 3 it will be [1,3].\\n        dfs(root, v, d); // Perform dfs on the tree\\n        int ans = 0;\\n        for (int x : v)  // Iterate over the array and add all the values\\n        {\\n            ans += x;\\n        }\\n        return ans;\\n    }\\n\\t\\n\\t// Dfs to iterate over the nodes\\n\\t// root : the current element, v & d : as mentioned above.\\t\\n    void dfs(TreeNode *root, vector<int> &v, vector<int> &digits)\\n    {\\n        digits.push_back(root->val); //  insert the current digit to digits array\\n        if (root->left == NULL && root->right == NULL){\\n\\t\\t\\t// If we are at the leaf node add the number we have to the v array\\n            int val = 0; // Initialize the number to  be added as 0;\\n            for (int x : digits)\\n            {\\n\\t\\t\\t\\tval *=10;  // shift the number to left   \\n\\t\\t\\t\\tval += x; // add the value \\n\\t\\t\\t\\t// for array [1,2] = >\\n\\t\\t\\t\\t// 0*10 + 1 = 1 ;  1*10 + 2 = 12;\\n            }\\n            v.push_back(val); // add the value to the array\\n            digits.pop_back();  // remove this number (i.e the leaf node) and return to parent.\\n            return;\\n        }\\n        if (root->left == NULL)   // If there is only right node.\\n        {\\n            dfs(root->right, v, digits);  // go to right node\\n            digits.pop_back();  // After completing the traversal remove this element and return to parent\\n            return;\\n        }\\n        if (root->right == NULL)  // Same as we did for right do for left\\n        {\\n            dfs(root->left, v, digits);\\n            digits.pop_back();\\n            return;\\n        }\\n\\t\\t// If it has both left and right children then traverse both and return after remove the digit from array.\\n        dfs(root->left, v, digits);\\n        dfs(root->right, v, digits);\\n        digits.pop_back();\\n    }\\n```\\n\\nThe second approach is better as it does not use both the array\\n\\nApproach 2:\\n\\n```\\nint sumNumbers(TreeNode *root){\\n        return dfs(root, 0); // The second value in this function is current sum which 0 as of now.\\n }\\n int dfs(TreeNode *root, int csum) {\\n        if (!root) return 0;  // return if there is no node the value should be zero\\n        int nsum = csum * 10 + root->val;  // Calculate the number we have uptil now (Same as we did in the above apporach)\\n\\t\\t// If we are the leaf node return the value\\n        if (!root->left && !root->right) return nsum;\\n\\t\\t// In all other cases add the sum from the left and the right\\n        return dfs(root->left, nsum) + dfs(root->right, nsum); // So when we return back to the root we have the final sum.\\n}\\n\\n```\\n\\nThe important fact here is that we only need the final sum, which makes the above approach efficient.\\nIf we were asked to get all the value till leaf nodes then in the first approach we can simpy return the v array.\\nThank you! Hope it helped you.",
                "solutionTags": [],
                "code": "```\\n\\n int sumNumbers(TreeNode *root)\\n    {\\n        if (!root)  // If there is no element return 0 as the sum\\n            return 0;\\n\\t\\t// This vector will contain all the numbers from root to all leaves\\n        vector<int> v;   // so for tree in the first example after dfs this vector will have numbers 12 and 13\\n        // This array contains all the digits we came across from root to the current node.\\n\\t\\tvector<int> d;  // So when we are at 2 the array will be [1,2] and when we are at 3 it will be [1,3].\\n        dfs(root, v, d); // Perform dfs on the tree\\n        int ans = 0;\\n        for (int x : v)  // Iterate over the array and add all the values\\n        {\\n            ans += x;\\n        }\\n        return ans;\\n    }\\n\\t\\n\\t// Dfs to iterate over the nodes\\n\\t// root : the current element, v & d : as mentioned above.\\t\\n    void dfs(TreeNode *root, vector<int> &v, vector<int> &digits)\\n    {\\n        digits.push_back(root->val); //  insert the current digit to digits array\\n        if (root->left == NULL && root->right == NULL){\\n\\t\\t\\t// If we are at the leaf node add the number we have to the v array\\n            int val = 0; // Initialize the number to  be added as 0;\\n            for (int x : digits)\\n            {\\n\\t\\t\\t\\tval *=10;  // shift the number to left   \\n\\t\\t\\t\\tval += x; // add the value \\n\\t\\t\\t\\t// for array [1,2] = >\\n\\t\\t\\t\\t// 0*10 + 1 = 1 ;  1*10 + 2 = 12;\\n            }\\n            v.push_back(val); // add the value to the array\\n            digits.pop_back();  // remove this number (i.e the leaf node) and return to parent.\\n            return;\\n        }\\n        if (root->left == NULL)   // If there is only right node.\\n        {\\n            dfs(root->right, v, digits);  // go to right node\\n            digits.pop_back();  // After completing the traversal remove this element and return to parent\\n            return;\\n        }\\n        if (root->right == NULL)  // Same as we did for right do for left\\n        {\\n            dfs(root->left, v, digits);\\n            digits.pop_back();\\n            return;\\n        }\\n\\t\\t// If it has both left and right children then traverse both and return after remove the digit from array.\\n        dfs(root->left, v, digits);\\n        dfs(root->right, v, digits);\\n        digits.pop_back();\\n    }\\n```\n```\\nint sumNumbers(TreeNode *root){\\n        return dfs(root, 0); // The second value in this function is current sum which 0 as of now.\\n }\\n int dfs(TreeNode *root, int csum) {\\n        if (!root) return 0;  // return if there is no node the value should be zero\\n        int nsum = csum * 10 + root->val;  // Calculate the number we have uptil now (Same as we did in the above apporach)\\n\\t\\t// If we are the leaf node return the value\\n        if (!root->left && !root->right) return nsum;\\n\\t\\t// In all other cases add the sum from the left and the right\\n        return dfs(root->left, nsum) + dfs(root->right, nsum); // So when we return back to the root we have the final sum.\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 41492,
                "title": "very-simple-bfs-solution",
                "content": "Interviewers love to ask for an iterative solution these days. This solution uses BFS and compute level by level.\\n\\n\\tint sumNumbers(TreeNode root) {\\n\\t\\tif(root == null) return 0;\\n\\t\\tint res = 0;\\n\\t\\tQueue<NodeSum> q = new LinkedList<>();\\n\\t\\tq.add(new NodeSum(root, root.val));\\n\\t\\twhile(!q.isEmpty()) {\\n\\t\\t\\tNodeSum poll = q.poll(); \\n\\t\\t\\tTreeNode node = poll.node;\\n\\t\\t\\tint sum = poll.sum;\\n\\t\\t\\tif(node.left != null) q.add(new NodeSum(node.left, sum * 10 + node.left.val));\\n\\t\\t\\tif(node.right != null) q.add(new NodeSum(node.right, sum * 10 + node.right.val));\\n\\t\\t\\tif(node.left == null && node.right == null) res += sum;\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\n\\tclass NodeSum {\\n\\t\\tTreeNode node;\\n\\t\\tint sum;\\n\\t\\tpublic NodeSum(TreeNode node, int sum) {\\n\\t\\t\\tthis.node = node;\\n\\t\\t\\tthis.sum = sum;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "Interviewers love to ask for an iterative solution these days. This solution uses BFS and compute level by level.\\n\\n\\tint sumNumbers(TreeNode root) {\\n\\t\\tif(root == null) return 0;\\n\\t\\tint res = 0;\\n\\t\\tQueue<NodeSum> q = new LinkedList<>();\\n\\t\\tq.add(new NodeSum(root, root.val));\\n\\t\\twhile(!q.isEmpty()) {\\n\\t\\t\\tNodeSum poll = q.poll(); \\n\\t\\t\\tTreeNode node = poll.node;\\n\\t\\t\\tint sum = poll.sum;\\n\\t\\t\\tif(node.left != null) q.add(new NodeSum(node.left, sum * 10 + node.left.val));\\n\\t\\t\\tif(node.right != null) q.add(new NodeSum(node.right, sum * 10 + node.right.val));\\n\\t\\t\\tif(node.left == null && node.right == null) res += sum;\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\n\\tclass NodeSum {\\n\\t\\tTreeNode node;\\n\\t\\tint sum;\\n\\t\\tpublic NodeSum(TreeNode node, int sum) {\\n\\t\\t\\tthis.node = node;\\n\\t\\t\\tthis.sum = sum;\\n\\t\\t}\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3480131,
                "title": "easy-o-n-c-intutive-solution-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- Auxillary Stack Space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint tsum=0;\\n\\n    void solve(TreeNode* root,int c){\\n        if(!root)\\n            return;\\n        c=c*10+root->val;\\n\\n        if(!root->left and !root->right)\\n        {\\n            tsum+=c;\\n            return;\\n        }\\n        if(root->left){\\n            solve(root->left,c);\\n        }\\n        if(root->right){\\n            solve(root->right,c);\\n        }\\n\\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n        int s=0,i,j,k,c=0;\\n        if(!root)\\n        return 0;\\n\\n        solve(root,c);\\n        return tsum;\\n        \\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint tsum=0;\\n\\n    void solve(TreeNode* root,int c){\\n        if(!root)\\n            return;\\n        c=c*10+root->val;\\n\\n        if(!root->left and !root->right)\\n        {\\n            tsum+=c;\\n            return;\\n        }\\n        if(root->left){\\n            solve(root->left,c);\\n        }\\n        if(root->right){\\n            solve(root->right,c);\\n        }\\n\\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n        int s=0,i,j,k,c=0;\\n        if(!root)\\n        return 0;\\n\\n        solve(root,c);\\n        return tsum;\\n        \\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297915,
                "title": "explained-with-images-think-and-code-like-a-pro-beats-100",
                "content": "# Intuition [Top down approach]\\n\\n![image.png](https://assets.leetcode.com/users/images/a22f0c55-5dfa-4b0f-817e-c1bf24627841_1678826538.8064666.png)\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWhen you are in a node, you have two things to think:\\n1. Is this a normal node?\\n2. Is this a leaf node?\\n\\nIf this is a normal node, we somehow need to tell it\\'s child about the value we got so far. So, we will update the value by doing: `val*10 + node.val` And pass them into both left and right children.\\n\\nIf this is a leaf node, we reached a base case. We can now update the globally stored variable `total`. But we need to consider our current nodes value. That\\'s why we will do `total+=val*10 + node.val`.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\nAs we are iterating for every node.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\nAs the recursive call will iterate for every node and the function stack will be created.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` Java []\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int total = 0;\\n    public int sumNumbers(TreeNode root) {\\n        helper(root, 0);\\n        return total;\\n    }\\n\\n    private void helper(TreeNode node, int val){\\n        // is this a leaf node..\\n        if(node.left == null && node.right == null){\\n            total+=val*10 + node.val;\\n            return;\\n        }\\n        if(node.left!=null){\\n            helper(node.left, val*10+node.val);\\n        }\\n        if(node.right!=null){\\n            helper(node.right, val*10+node.val);\\n        }\\n    }\\n}\\n```\\n``` C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int total = 0;\\n    int sumNumbers(TreeNode* root) {\\n        helper(root, 0);\\n        return total;\\n    }\\n\\n    void helper(TreeNode* node, int val) {\\n        // is this a leaf node\\n        if(!node->left && !node->right) {\\n            total += val*10+node->val;\\n            return;\\n        }\\n        if(node->left){\\n            helper(node->left, val*10+node->val);\\n        }\\n        if(node->right){\\n            helper(node->right, val*10+node->val);\\n        }\\n    }\\n};\\n```\\n\\n![No Upvotes, Have a Good Day.png](https://assets.leetcode.com/users/images/92ad6871-d492-4e07-a21f-68711250cad5_1678826911.7306123.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Tree"
                ],
                "code": "``` Java []\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int total = 0;\\n    public int sumNumbers(TreeNode root) {\\n        helper(root, 0);\\n        return total;\\n    }\\n\\n    private void helper(TreeNode node, int val){\\n        // is this a leaf node..\\n        if(node.left == null && node.right == null){\\n            total+=val*10 + node.val;\\n            return;\\n        }\\n        if(node.left!=null){\\n            helper(node.left, val*10+node.val);\\n        }\\n        if(node.right!=null){\\n            helper(node.right, val*10+node.val);\\n        }\\n    }\\n}\\n```\n``` C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int total = 0;\\n    int sumNumbers(TreeNode* root) {\\n        helper(root, 0);\\n        return total;\\n    }\\n\\n    void helper(TreeNode* node, int val) {\\n        // is this a leaf node\\n        if(!node->left && !node->right) {\\n            total += val*10+node->val;\\n            return;\\n        }\\n        if(node->left){\\n            helper(node->left, val*10+node->val);\\n        }\\n        if(node->right){\\n            helper(node->right, val*10+node->val);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200174,
                "title": "129-beats-96-72-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe define a recursive function dfs that takes in a node and a path sum as arguments. We initially call dfs on the root node with a path sum of 0.\\n\\nAt each node, we add the current node\\'s value to the path sum by multiplying the current path sum by 10 and adding the node\\'s value.\\n\\nIf the current node is a leaf node (i.e., it has no left or right children), we return the path sum. Otherwise, we recursively call dfs on the left and right subtrees and sum up the returned values.\\n\\nFinally, we call dfs on the root node and return the resulting sum.\\n\\n# Complexity\\n- Time complexity:\\nBeats\\n59.76%\\n\\n- Space complexity:\\nBeats\\n96.72%\\n\\n# Code\\n```\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        # Define a recursive function to traverse the tree and sum up the numbers\\n        def dfs(node, path_sum):\\n            if not node:\\n                return 0\\n            # Add the current node\\'s value to the path sum\\n            path_sum = path_sum * 10 + node.val\\n            # If this is a leaf node, return the path sum\\n            if not node.left and not node.right:\\n                return path_sum\\n            # Otherwise, recursively traverse the left and right subtrees\\n            return dfs(node.left, path_sum) + dfs(node.right, path_sum)\\n        \\n        # Call the recursive function on the root node with an initial path sum of 0\\n        return dfs(root, 0)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        # Define a recursive function to traverse the tree and sum up the numbers\\n        def dfs(node, path_sum):\\n            if not node:\\n                return 0\\n            # Add the current node\\'s value to the path sum\\n            path_sum = path_sum * 10 + node.val\\n            # If this is a leaf node, return the path sum\\n            if not node.left and not node.right:\\n                return path_sum\\n            # Otherwise, recursively traverse the left and right subtrees\\n            return dfs(node.left, path_sum) + dfs(node.right, path_sum)\\n        \\n        # Call the recursive function on the root node with an initial path sum of 0\\n        return dfs(root, 0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2519528,
                "title": "c-0ms-faster-than-100-easy-understanding-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int sum = 0;\\n    \\n    void f(TreeNode *root, string cur_sum){\\n        \\n        if(!root) return;\\n        \\n        if(!root->left and !root->right){\\n            sum+=stoi(cur_sum + to_string(root->val));\\n            return;\\n        }\\n        \\n        f(root->left, cur_sum + to_string(root->val));\\n        f(root->right, cur_sum + to_string(root->val));\\n                \\n    }\\n    \\n    \\n    int sumNumbers(TreeNode* root) {\\n        \\n        f(root, \"\");\\n        return sum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int sum = 0;\\n    \\n    void f(TreeNode *root, string cur_sum){\\n        \\n        if(!root) return;\\n        \\n        if(!root->left and !root->right){\\n            sum+=stoi(cur_sum + to_string(root->val));\\n            return;\\n        }\\n        \\n        f(root->left, cur_sum + to_string(root->val));\\n        f(root->right, cur_sum + to_string(root->val));\\n                \\n    }\\n    \\n    \\n    int sumNumbers(TreeNode* root) {\\n        \\n        f(root, \"\");\\n        return sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845290,
                "title": "c-easy-dfs-backtracking-solution",
                "content": "**Do** \\u2B06\\uFE0F **UPVOTE IF IT WAS HELPFUL**\\n\\n\\tclass Solution {\\n\\t\\tint ans=0;\\n\\tpublic:\\n\\t\\tvoid helper(TreeNode *root,string &s){\\n\\t\\t\\tif(!root) return ;\\n\\t\\t\\ts.push_back(root->val+\\'0\\');\\n\\t\\t\\tif(root->left==root->right){\\n\\t\\t\\t\\tans+=stoi(s);\\n\\t\\t\\t}\\n\\t\\t\\thelper(root->left,s);\\n\\t\\t\\thelper(root->right,s);\\n\\t\\t\\ts.pop_back();\\n\\t\\t}\\n\\t\\tint sumNumbers(TreeNode* root) {\\n\\t\\t\\tstring s=\"\";\\n\\t\\t\\thelper(root,s);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\t\\tint ans=0;\\n\\tpublic:\\n\\t\\tvoid helper(TreeNode *root,string &s){\\n\\t\\t\\tif(!root) return ;\\n\\t\\t\\ts.push_back(root->val+\\'0\\');\\n\\t\\t\\tif(root->left==root->right){\\n\\t\\t\\t\\tans+=stoi(s);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1793789,
                "title": "solution-swift-sum-root-to-leaf-numbers",
                "content": "```swift\\nclass Solution {\\n    func sumNumbers(_ root: TreeNode?) -> Int {\\n        guard let root = root else { return 0 }\\n        \\n        var result = 0\\n        \\n        var queue: [(TreeNode, Int)] = []\\n        queue.append((root, 0))\\n        \\n        while !queue.isEmpty {\\n            let (node, val) = queue.removeFirst()\\n            let sum = ((10 * val) + node.val)\\n            \\n            let (left, right) = (node.left, node.right)\\n            if left == nil && right == nil { result += sum }\\n            \\n            if let left = left { queue.append((left, sum)) }\\n            if let right = right { queue.append((right, sum)) }\\n        }\\n        return result\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><b>TreeNode</b></summary>\\n\\n```swift\\npublic class TreeNode {\\n    public var val: Int\\n    public var left: TreeNode?\\n    public var right: TreeNode?\\n    public init() { self.val = 0; self.left = nil; self.right = nil; }\\n    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n    }\\n}\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func sumNumbers(_ root: TreeNode?) -> Int {\\n        guard let root = root else { return 0 }\\n        \\n        var result = 0\\n        \\n        var queue: [(TreeNode, Int)] = []\\n        queue.append((root, 0))\\n        \\n        while !queue.isEmpty {\\n            let (node, val) = queue.removeFirst()\\n            let sum = ((10 * val) + node.val)\\n            \\n            let (left, right) = (node.left, node.right)\\n            if left == nil && right == nil { result += sum }\\n            \\n            if let left = left { queue.append((left, sum)) }\\n            if let right = right { queue.append((right, sum)) }\\n        }\\n        return result\\n    }\\n}\\n```\n```swift\\npublic class TreeNode {\\n    public var val: Int\\n    public var left: TreeNode?\\n    public var right: TreeNode?\\n    public init() { self.val = 0; self.left = nil; self.right = nil; }\\n    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785393,
                "title": "0ms-100-solution-accepted",
                "content": "class Solution {\\npublic:\\n\\n    int sum = 0;\\n    int sumNumbers(TreeNode* root , int num = 0) {\\n        if(!root)return 0;\\n        \\n        if(!root->left and !root->right){\\n            num = num * 10 + root -> val;\\n            sum += num;\\n            return sum;\\n        }\\n        \\n        num = num * 10 + root -> val;\\n        sumNumbers(root->left , num);\\n        sumNumbers(root->right , num);\\n        \\n        return sum;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int sum = 0;\\n    int sumNumbers(TreeNode* root , int num = 0) {\\n        if(!root)return 0;\\n        \\n        if(!root->left and !root->right){\\n            num = num * 10 + root -> val;\\n            sum += num;\\n            return sum;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1556108,
                "title": "c-100-faster-dfs-recursive-explained",
                "content": "In the question, it is mentioned that the number is formed from digits, i.e. number present in the path from the  root-to-leaf. So order here is important. \\n\\nMoreover, it is evident, that one has to implement Depth- First Search to solve this problem, as the we have to traverse till the dept of the tree and get the digits to form the number. \\n\\n## Some Basics\\n### Forming the number from digits.\\nTo make a number from digits, one has to do the following:\\n1. The left most part of a number is multiplied by an order of 10.\\n2. The right most part is left at it is.\\n\\nUsing the above approch, one can form a number from the fdigits.\\n\\n### Finding the digits\\nNow the next task is to find the digits. Since the digits has to be found out by traversing the depth of the tree.\\n\\nBelow is the implementation of the above approach:\\n```\\nclass Solution {\\npublic:\\n   // Function to traverse the depth of trr\\n   // and find the sum\\n    int dfs(TreeNode* root,int prev){\\n        if(root == NULL){\\n            return 0;\\n        }\\n        if(root->left == root->right){\\n            return prev*10 + root->val;\\n        }\\n        \\n        return dfs(root->left,prev*10 + root->val) + dfs(root->right,prev*10 + root->val);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        int answer = dfs(root,0);\\n        return answer;\\n    }\\n};\\n```\\n\\n**Explanation**\\n1. FIrst check if the current node is a valid one or not. If not, return.\\n2. Check if the current node is root, if yes then add the value at root with that of the previous sum.\\n3. Recursively call the function for the left and right sub part of the tree.\\n\\nThe `prev` is used to store the sum of the previous values. \\n\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   // Function to traverse the depth of trr\\n   // and find the sum\\n    int dfs(TreeNode* root,int prev){\\n        if(root == NULL){\\n            return 0;\\n        }\\n        if(root->left == root->right){\\n            return prev*10 + root->val;\\n        }\\n        \\n        return dfs(root->left,prev*10 + root->val) + dfs(root->right,prev*10 + root->val);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        int answer = dfs(root,0);\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1481784,
                "title": "c-soln-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    \\n    void helper(TreeNode* root , int num = 0)\\n    {\\n        num = num*10 + root->val;\\n        if(root->left)helper(root->left , num);\\n        if(root->right)helper(root->right , num);\\n        \\n        if(!root->left && !root->right)\\n        {  sum += num;\\n           return;\\n        }\\n        \\n        return;\\n    }\\n    \\n    int sumNumbers(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n        helper(root);\\n        return sum;\\n    }\\n};\\n```\\nhttps://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/\\nhttps://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/discuss/1481832/Recursive-DFS-soln-c%2B%2B",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    \\n    void helper(TreeNode* root , int num = 0)\\n    {\\n        num = num*10 + root->val;\\n        if(root->left)helper(root->left , num);\\n        if(root->right)helper(root->right , num);\\n        \\n        if(!root->left && !root->right)\\n        {  sum += num;\\n           return;\\n        }\\n        \\n        return;\\n    }\\n    \\n    int sumNumbers(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n        helper(root);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 512898,
                "title": "python-o-n-sol-by-dfs-approach-90-with-explanation",
                "content": "Python O(n) sol. by DFS approach.\\n\\n---\\n**Hint**:\\n\\nThink of **DFS traversal** with leaf node judgement\\n\\nA node is **leaf node** <=> **node.left is None** and **node.right is None**\\n\\n---\\n**Algorithm**:\\n\\nStep_#1.\\n\\nStart **DFS traversal from root node** and initial tree number 0.\\n**Update tree number** with current node value **on each level**.\\n\\n\\nStep_#2.\\n\\nIf current node is  **leaf node**, **return tree number**.\\nIf current node is non-leaf node, **DFS down to next level** with **summation** (**+**).\\n\\n\\n---\\n\\n```\\n\\nclass Solution:\\n    \\n\\n    def sumNumbers(self, node: TreeNode, tree_num = 0) -> int:\\n\\n        if not node:\\n            # empty tree or empty node\\n            return 0\\n        \\n        else:\\n            # update tree_num with current node\\n            tree_num = 10 * tree_num + node.val\\n\\n            if not node.left and not node.right:\\n                # leaf is reached, return tree_num\\n                return tree_num\\n\\n            else:\\n                # DFS down to next level\\n                return self.sumNumbers( node.left, tree_num) + self.sumNumbers( node.right, tree_num) \\n```\\n\\n---\\n\\nShare another implementation with generator\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        \\n        def calc(node, val):\\n            \\n            ## base case aka stop condition:\\n            # generate decimal value on leaf node\\n            if not node.left and not node.right:\\n                yield (val * 10 + node.val)\\n                \\n            ## general cases:\\n            # visit each non-leaf nodes\\n            for child in (node.left, node.right):\\n                if child:\\n                    yield from calc(child, val * 10 + node.val)\\n            \\n        # -------------------------------------------------------------\\n        # sum of root-to-leaf numbers\\n        return sum( calc(root, 0) )\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n[Leetcode #144 Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/)\\n\\n[Leetcode #1022 Sum of Root To Leaf Binary Numbers](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/)",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\n\\nclass Solution:\\n    \\n\\n    def sumNumbers(self, node: TreeNode, tree_num = 0) -> int:\\n\\n        if not node:\\n            # empty tree or empty node\\n            return 0\\n        \\n        else:\\n            # update tree_num with current node\\n            tree_num = 10 * tree_num + node.val\\n\\n            if not node.left and not node.right:\\n                # leaf is reached, return tree_num\\n                return tree_num\\n\\n            else:\\n                # DFS down to next level\\n                return self.sumNumbers( node.left, tree_num) + self.sumNumbers( node.right, tree_num) \\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        \\n        def calc(node, val):\\n            \\n            ## base case aka stop condition:\\n            # generate decimal value on leaf node\\n            if not node.left and not node.right:\\n                yield (val * 10 + node.val)\\n                \\n            ## general cases:\\n            # visit each non-leaf nodes\\n            for child in (node.left, node.right):\\n                if child:\\n                    yield from calc(child, val * 10 + node.val)\\n            \\n        # -------------------------------------------------------------\\n        # sum of root-to-leaf numbers\\n        return sum( calc(root, 0) )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41464,
                "title": "share-my-java-solution",
                "content": "    public int sumNumbers(TreeNode root) {\\n        return dfs(root, 0);    \\n    }\\n    private int dfs(TreeNode root, int num){\\n        if(root==null){\\n            return 0;\\n        }\\n        \\n        num = num*10 + root.val;\\n        if(root.left == null && root.right == null) return num;\\n        \\n        return dfs(root.left, num) + dfs(root.right,num);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int sumNumbers(TreeNode root) {\\n        return dfs(root, 0);    \\n    }\\n    private int dfs(TreeNode root, int num){\\n        if(root==null){\\n            return 0;\\n        }\\n        \\n        num = num*10 + root.val;\\n        if(root.left == null && root.right == null) return num;\\n        \\n        return dfs(root.left, num) + dfs(root.right,num);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 41452,
                "title": "iterative-c-solution-using-stack-similar-to-postorder-traversal",
                "content": "Iterative C++ solution using postorder traversal to treat the nodes \\n\\n\\n\\n    /**\\n     * Definition for a binary tree node.\\n     * struct TreeNode {\\n     *     int val;\\n     *     TreeNode *left;\\n     *     TreeNode *right;\\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        int sumNumbers(TreeNode* root) {\\n            \\n            stack<TreeNode*> nodes;\\n            if (!root)\\n             return 0;\\n             \\n            int total = 0;\\n            int current = 0;\\n            TreeNode* last = nullptr;\\n            while (root || !nodes.empty())\\n            {\\n                if (root)\\n                {\\n                    nodes.push(root);\\n                    current *= 10;\\n                    current += root->val;\\n                    root = root->left;\\n                }\\n                else \\n                {\\n                    root = nodes.top();\\n                    if (root->right && root->right != last)\\n                    {\\n                        root = root->right;\\n                    }\\n                    else \\n                    {\\n                         nodes.pop();\\n                         last = root;\\n                         // only add sum of leaf node\\n                         if (root->right == nullptr && root->left == nullptr)\\n                            total += current;\\n                         current /= 10;\\n                         root = nullptr;\\n                    }\\n                }\\n              }\\n            \\n             return total;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Iterator"
                ],
                "code": "class Solution {\\n    public:\\n        int sumNumbers(TreeNode* root) {\\n            \\n            stack<TreeNode*> nodes;\\n            if (!root)\\n             return 0;\\n             \\n            int total = 0;\\n            int current = 0;\\n            TreeNode* last = nullptr;\\n            while (root || !nodes.empty())\\n            {\\n                if (root)\\n                {\\n                    nodes.push(root);\\n                    current *= 10;\\n                    current += root->val;\\n                    root = root->left;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3294691,
                "title": "beats-c-dfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, vector<string> &paths, string num){\\n        if(root==NULL) return;\\n        if(root->left==NULL && root->right==NULL){\\n            num+=to_string(root->val);\\n            paths.push_back(num);\\n        }\\n        solve(root->left,paths,num+to_string(root->val));\\n        solve(root->right,paths,num+to_string(root->val));\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        vector<string> paths;\\n        string num=\"\";\\n        solve(root,paths,num);\\n        int sum=0;\\n        for(auto x: paths){\\n            sum+=stoi(x);\\n        }\\n        return sum;\\n    }\\n};\\n```\\nOR\\n\\n```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, string num,int& sum){\\n        if(root==NULL) return;\\n        if(root->left==NULL && root->right==NULL){\\n            num+=to_string(root->val);\\n            sum+=stoi(num);\\n        }\\n        solve(root->left,num+to_string(root->val),sum);\\n        solve(root->right,num+to_string(root->val),sum);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        string num=\"\";\\n        int sum=0;\\n        solve(root,num,sum);\\n        return sum;\\n    }\\n};\\n```\\n\\nDO UPVOTE, IF THIS HELPED\\uD83D\\uDE01\\u2764\\uFE0F",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, vector<string> &paths, string num){\\n        if(root==NULL) return;\\n        if(root->left==NULL && root->right==NULL){\\n            num+=to_string(root->val);\\n            paths.push_back(num);\\n        }\\n        solve(root->left,paths,num+to_string(root->val));\\n        solve(root->right,paths,num+to_string(root->val));\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        vector<string> paths;\\n        string num=\"\";\\n        solve(root,paths,num);\\n        int sum=0;\\n        for(auto x: paths){\\n            sum+=stoi(x);\\n        }\\n        return sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, string num,int& sum){\\n        if(root==NULL) return;\\n        if(root->left==NULL && root->right==NULL){\\n            num+=to_string(root->val);\\n            sum+=stoi(num);\\n        }\\n        solve(root->left,num+to_string(root->val),sum);\\n        solve(root->right,num+to_string(root->val),sum);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        string num=\"\";\\n        int sum=0;\\n        solve(root,num,sum);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294261,
                "title": "python3-32ms-dfs-detailed-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Using DFS**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- we want sum all routes from root and return sum.\\n- for this appropriate method would be dfs.\\n- using dfs traverse till end of tree ie. leaf node.\\n- keep track of path from root till leaf-node, now when encountered leaf node, sum it in answer.\\n- do this till all path covered, return answer.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        ans = 0\\n        def dfs(curr=None,path=\\'\\'):\\n            nonlocal ans\\n            if curr:\\n                path += str(curr.val)\\n                dfs(curr.left,path)\\n                dfs(curr.right,path)\\n                if curr.left == None and curr.right == None:ans += int(path)\\n            return\\n        dfs(root)\\n        return ans\\n```\\n# Please like and comment below ( \\u0361\\uD83D\\uDC41\\uFE0F\\u202F\\u035C\\u0296 \\u0361\\uD83D\\uDC41\\uFE0F)\\uD83D\\uDC4C",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        ans = 0\\n        def dfs(curr=None,path=\\'\\'):\\n            nonlocal ans\\n            if curr:\\n                path += str(curr.val)\\n                dfs(curr.left,path)\\n                dfs(curr.right,path)\\n                if curr.left == None and curr.right == None:ans += int(path)\\n            return\\n        dfs(root)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180432,
                "title": "best-c-solution-dfs-stack-recursive-and-iterative-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Two Approaches. (Here I have explained all the possible solutions of this problem).\\n\\n1. Solved using DFS + Binary Search Tree. (Recursive Approach).\\n2. Solved using Stack + Binary Search Tree. (Iterative Approach).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\n\\n/*\\n\\n    Time Complexity: O(N), where N is the total number of nodes in the given tree. We visit each node\\n    at most once.\\n\\n    Space Complexity: O(N), Even though we don\\'t explicitly use any additional memory, the call stack\\n    of our recursion could be as large as the number of nodes in the worst case.\\n\\n    Solved using DFS + Binary Search Tree. (Recursive Approach)\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate:\\n    int sumNumbersHelper(TreeNode* root, int currSum){\\n        if(root == NULL){\\n            return 0;\\n        }\\n        currSum = currSum * 10 + root->val;\\n        if(root->left == NULL && root->right == NULL){\\n            return currSum;\\n        }\\n        return sumNumbersHelper(root->left, currSum) + sumNumbersHelper(root->right, currSum);\\n    }\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        int currSum = 0;\\n        return sumNumbersHelper(root, currSum);\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity: O(N), where N is the total number of nodes in the given tree. We visit each node\\n    at most once.\\n\\n    Space Complexity: O(N), Stack space.\\n\\n    Solved using Stack + Binary Search Tree. (Iterative Approach)\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        stack<pair<TreeNode*, int>> store;\\n        store.push({root, 0});\\n        int sum = 0;\\n        while(!store.empty()){\\n            auto [root, currSum] = store.top(); \\n            store.pop();\\n            currSum = currSum * 10 + root->val;\\n            if(root->left == NULL && root->right == NULL){\\n                sum += currSum;\\n            }\\n            if(root->right != NULL){\\n                store.push({root->right, currSum});\\n            }\\n            if(root->left != NULL){\\n                store.push({root->left, currSum});\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\n\\n/*\\n\\n    Time Complexity: O(N), where N is the total number of nodes in the given tree. We visit each node\\n    at most once.\\n\\n    Space Complexity: O(N), Even though we don\\'t explicitly use any additional memory, the call stack\\n    of our recursion could be as large as the number of nodes in the worst case.\\n\\n    Solved using DFS + Binary Search Tree. (Recursive Approach)\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate:\\n    int sumNumbersHelper(TreeNode* root, int currSum){\\n        if(root == NULL){\\n            return 0;\\n        }\\n        currSum = currSum * 10 + root->val;\\n        if(root->left == NULL && root->right == NULL){\\n            return currSum;\\n        }\\n        return sumNumbersHelper(root->left, currSum) + sumNumbersHelper(root->right, currSum);\\n    }\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        int currSum = 0;\\n        return sumNumbersHelper(root, currSum);\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity: O(N), where N is the total number of nodes in the given tree. We visit each node\\n    at most once.\\n\\n    Space Complexity: O(N), Stack space.\\n\\n    Solved using Stack + Binary Search Tree. (Iterative Approach)\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        stack<pair<TreeNode*, int>> store;\\n        store.push({root, 0});\\n        int sum = 0;\\n        while(!store.empty()){\\n            auto [root, currSum] = store.top(); \\n            store.pop();\\n            currSum = currSum * 10 + root->val;\\n            if(root->left == NULL && root->right == NULL){\\n                sum += currSum;\\n            }\\n            if(root->right != NULL){\\n                store.push({root->right, currSum});\\n            }\\n            if(root->left != NULL){\\n                store.push({root->left, currSum});\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557186,
                "title": "sum-root-to-leaf-numbers-cpp-c-with-detail-explanation",
                "content": "**Explanation:**\\nBasic idea is to explore all the paths and then store the digits that you encounter on the way and then find the result. So, whenever there is an exploring all the path stuff then we should think of recursion. And, since it is a tree related question then there is a high chance of using recursion.\\n\\nNow, we will do pre-order traversal for this tree and when we hit any node we will convert that node val to string and concatenate to our string `s` and whenever we hit the leaf node we will store the string `s` in a vector name `paths`.\\n\\nBasically, `paths` is a vector which stores all the path from `root-to-leaf` in a string format.\\n\\nNow, after that we will traverse the vector and convert all the strings to digits one by one and add them and return the ans i.e. sum.\\n\\n**Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> paths;\\n    int sumNumbers(TreeNode* root) {\\n        if(!root) return 0;\\n        findSumNumber(root, \"\");\\n        int sum = 0;\\n        for(auto path : paths){\\n            int n = stoi(path);\\n            sum += n;\\n        }\\n        return sum;\\n    }\\n    \\n    void findSumNumber(TreeNode* root, string s){\\n        if(!root) return;\\n        \\n        s += to_string(root->val);\\n        \\n        //if the node is a leaf node\\n        if(root->left == NULL && root->right == NULL){\\n            paths.push_back(s);\\n            s.pop_back();\\n            return;\\n        }\\n        \\n        findSumNumber(root->left, s);\\n        findSumNumber(root->right, s);\\n        s.pop_back();\\n    }\\n};\\n```\\n\\n**Discussion:**\\nNow, the problem with above approach is, we are using extra vector for storing all the paths So, we can do something to eliminate the vector. \\n\\nNow, the idea is to replicate the above solution but we will have one variable name `path` that will store the value from `root-to-leaf` in the form of number on the way i.e. as the recursion goes.\\n\\nWhen we hit the leaf node we will add that number i.e. `path` to our `sum` variable. Also, in order to exlore all paths we will remove the last digit from `path` variable.\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        if(!root) return 0;\\n        \\n        int sum = 0;\\n        findSumNumber(root, 0, sum);\\n        return sum;\\n    }\\n    \\n    void findSumNumber(TreeNode* root, int path, int& sum){\\n        if(!root) return;\\n        \\n        path = path*10 + root->val;\\n        \\n        //if the node is a leaf node\\n        if(root->left == NULL && root->right == NULL){\\n            sum += path;\\n            path = path/10;\\n            return;\\n        }\\n        \\n        findSumNumber(root->left, path, sum);\\n        findSumNumber(root->right, path, sum);\\n        path = path/10;\\n    }\\n};\\n```\\n\\nPlease do let me know, if you have another solution.\\nI hope this helps. \\nThanks \\u270C\\uD83C\\uDFFB\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> paths;\\n    int sumNumbers(TreeNode* root) {\\n        if(!root) return 0;\\n        findSumNumber(root, \"\");\\n        int sum = 0;\\n        for(auto path : paths){\\n            int n = stoi(path);\\n            sum += n;\\n        }\\n        return sum;\\n    }\\n    \\n    void findSumNumber(TreeNode* root, string s){\\n        if(!root) return;\\n        \\n        s += to_string(root->val);\\n        \\n        //if the node is a leaf node\\n        if(root->left == NULL && root->right == NULL){\\n            paths.push_back(s);\\n            s.pop_back();\\n            return;\\n        }\\n        \\n        findSumNumber(root->left, s);\\n        findSumNumber(root->right, s);\\n        s.pop_back();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        if(!root) return 0;\\n        \\n        int sum = 0;\\n        findSumNumber(root, 0, sum);\\n        return sum;\\n    }\\n    \\n    void findSumNumber(TreeNode* root, int path, int& sum){\\n        if(!root) return;\\n        \\n        path = path*10 + root->val;\\n        \\n        //if the node is a leaf node\\n        if(root->left == NULL && root->right == NULL){\\n            sum += path;\\n            path = path/10;\\n            return;\\n        }\\n        \\n        findSumNumber(root->left, path, sum);\\n        findSumNumber(root->right, path, sum);\\n        path = path/10;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1556982,
                "title": "clean-java-dfs-100-faster",
                "content": "```\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        int component = 0;    // stores current_sum till leaf\\n\\t\\tint ans = 0;     // stores sum of every number generated from root to leaf path\\n        return dfs(root, component, ans);\\n    }\\n    \\n    public int dfs(TreeNode root, int comp, int ans){\\n        if(root == null) return 0;\\n        comp = comp * 10 + root.val;    // updating the comp \\n        if(root.left == null && root.right == null){\\n            ans += comp;    // updating the sum if the curr_node is a root\\n            return ans;\\n        }\\n        int call1 = dfs(root.left, comp, ans);    // sum of numbers to all leaf nodes on the left\\n        int call2 = dfs(root.right, comp, ans);  // // sum of numbers to all leaf nodes on the right\\n        return call1 + call2;\\n    }\\n}\\nTime Complexity : O(N)\\nSpace Complexity : O(LogN) average",
                "solutionTags": [],
                "code": "class Solution {\\n    public int sumNumbers(TreeNode root) {\\n        int component = 0;    // stores current_sum till leaf\\n\\t\\tint ans = 0;     // stores sum of every number generated from root to leaf path\\n        return dfs(root, component, ans);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1556242,
                "title": "c-recursive-0-ms-code",
                "content": "Below is commented code - \\n```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root , int res=0) {\\n\\t// if no root the simply return 0\\n        if(!root)\\n        {\\n            return 0;\\n        }\\n\\t\\t// if current node is leaf node\\n        if(root->left==NULL and root->right==NULL)\\n        {\\n            return(res*10+root->val);\\n        }\\n\\t\\t// otherwise go in both direction and add both the results \\n        return(sumNumbers(root->left,res*10+root->val) +sumNumbers(root->right,res*10+root->val)); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root , int res=0) {\\n\\t// if no root the simply return 0\\n        if(!root)\\n        {\\n            return 0;\\n        }\\n\\t\\t// if current node is leaf node\\n        if(root->left==NULL and root->right==NULL)\\n        {\\n            return(res*10+root->val);\\n        }\\n\\t\\t// otherwise go in both direction and add both the results \\n        return(sumNumbers(root->left,res*10+root->val) +sumNumbers(root->right,res*10+root->val)); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1555911,
                "title": "faster-than-100-c-solutions-easy-intuitive-approach-dfs",
                "content": "Hello there my fellow reader, thanks for reading in advance!\\n\\n**Approach:** \\n\\n1. I will traverse the binary tree in a depth first search (DFS) fashion and computer the number formed so far.\\n\\n2. To compute the number: if number so far is 23 and current node value is 5 then the number will become 23*10 + 5 = 235.\\n\\n3. Then I\\'ll check for the leaf node and add the number formed so far to our result.\\n\\nBelow is the code for my approach mentioned above:\\n\\n```\\nclass Solution {\\npublic:\\n    int res{}; //result variable\\n    \\n    void dfs(TreeNode* root, int num){\\n        \\n        if(root == NULL) return;\\n        \\n        //num value at this node\\n        num = num*10 + root->val;\\n        \\n        //leaf Node\\n        if(root->left == NULL && root->right == NULL)\\n            res += num;\\n        \\n        dfs(root->left, num);\\n        dfs(root->right, num);\\n    }\\n    \\n    int sumNumbers(TreeNode* root) {\\n        if(root == NULL) return 0;\\n        dfs(root, 0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int res{}; //result variable\\n    \\n    void dfs(TreeNode* root, int num){\\n        \\n        if(root == NULL) return;\\n        \\n        //num value at this node\\n        num = num*10 + root->val;\\n        \\n        //leaf Node\\n        if(root->left == NULL && root->right == NULL)\\n            res += num;\\n        \\n        dfs(root->left, num);\\n        dfs(root->right, num);\\n    }\\n    \\n    int sumNumbers(TreeNode* root) {\\n        if(root == NULL) return 0;\\n        dfs(root, 0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1440005,
                "title": "0-ms-c-super-easy",
                "content": "**The value of sum at each point of recursive call is saved in inbuilt Stack and that sum is added to answer when both children of root becomes NULL.**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n\\tint ans=0;  \\n\\tint sumNumbers(TreeNode* root,int sum=0)\\n    {\\n\\t\\n        if(root==NULL)\\n            return 0;\\n        \\n          sum=sum*10+root->val;\\n          sumNumbers(root->left,sum);\\n          sumNumbers(root->right,sum);\\n\\t\\t  \\n        if(root->left==root->right && root->left==NULL)\\n        {\\n            ans+=sum;\\n        }\\n        return ans;\\n    }\\n };\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n\\tint ans=0;  \\n\\tint sumNumbers(TreeNode* root,int sum=0)\\n    {\\n\\t\\n        if(root==NULL)\\n            return 0;\\n        \\n          sum=sum*10+root->val;\\n          sumNumbers(root->left,sum);\\n          sumNumbers(root->right,sum);\\n\\t\\t  \\n        if(root->left==root->right && root->left==NULL)\\n        {\\n            ans+=sum;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 41497,
                "title": "share-my-c-code-using-0ms",
                "content": "int sumTreeNodes(struct TreeNode* root, int parent) {\\n\\n    if (root == NULL)\\n        return 0;\\n    if (root->left == NULL && root->right == NULL) \\n        return parent * 10 + root->val;\\n    \\n    return sumTreeNodes(root->left, parent * 10 + root->val) + \\n           sumTreeNodes(root->right, parent * 10 + root->val);\\n}\\n\\n\\nint sumNumbers(struct TreeNode* root) {\\n\\n    return (root == NULL) ? 0 : sumTreeNodes(root, 0);\\n}",
                "solutionTags": [],
                "code": "int sumTreeNodes(struct TreeNode* root, int parent) {\\n\\n    if (root == NULL)\\n        return 0;\\n    if (root->left == NULL && root->right == NULL) \\n        return parent * 10 + root->val;\\n    \\n    return sumTreeNodes(root->left, parent * 10 + root->val) + \\n           sumTreeNodes(root->right, parent * 10 + root->val);\\n}\\n\\n\\nint sumNumbers(struct TreeNode* root) {\\n\\n    return (root == NULL) ? 0 : sumTreeNodes(root, 0);\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 4076700,
                "title": "best-o-n-solution",
                "content": "# Approach\\nPreorder Traversal\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(h)$$ --> h is height of the binary tree\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void path(TreeNode* root, int& sum, int& num) {\\n        if (!root) \\n            return;\\n        if (!root->left && !root->right) {\\n            sum += num * 10 + root->val;\\n            return;\\n        }\\n        num = num * 10 + root->val;\\n        path(root->left, sum, num);\\n        path(root->right, sum, num);\\n        num = num / 10;\\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n        int sum = 0, num = 0;\\n        path(root, sum, num);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void path(TreeNode* root, int& sum, int& num) {\\n        if (!root) \\n            return;\\n        if (!root->left && !root->right) {\\n            sum += num * 10 + root->val;\\n            return;\\n        }\\n        num = num * 10 + root->val;\\n        path(root->left, sum, num);\\n        path(root->right, sum, num);\\n        num = num / 10;\\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n        int sum = 0, num = 0;\\n        path(root, sum, num);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3310003,
                "title": "c-recursive-100-beat-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\uD83D\\uDCAFFirst reach to leaf nodes by traversing in dfs manner .\\nOnce you are in leaf node add it to global variable answer.\\uD83D\\uDCAF\\n\\n\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void helper(TreeNode* root, int val){\\n        if(root->left==NULL and root->right==NULL){\\n            val=val*10+(root->val);\\n            ans+=val;\\n            return ;\\n        }\\n        val=(val*10)+(root->val);\\n        cout<<val<<endl;\\n        if(root->left!=NULL)\\n        helper(root->left,val);\\n        if(root->right!=NULL)\\n        helper(root->right,val);\\n        \\n    }\\n    int sumNumbers(TreeNode* root) {\\n        \\n        \\n        helper(root, 0);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void helper(TreeNode* root, int val){\\n        if(root->left==NULL and root->right==NULL){\\n            val=val*10+(root->val);\\n            ans+=val;\\n            return ;\\n        }\\n        val=(val*10)+(root->val);\\n        cout<<val<<endl;\\n        if(root->left!=NULL)\\n        helper(root->left,val);\\n        if(root->right!=NULL)\\n        helper(root->right,val);\\n        \\n    }\\n    int sumNumbers(TreeNode* root) {\\n        \\n        \\n        helper(root, 0);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3295495,
                "title": "dfs-c-short-sweet-code",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,int &ans,int x){\\n        if(root == NULL){\\n            return;\\n        }\\n        x = x*10+root->val;\\n        solve(root->left,ans,x);\\n        solve(root->right,ans,x);\\n        if(root->left==NULL&&root->right==NULL){\\n            ans += x;\\n        }\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        int ans = 0;\\n        solve(root,ans,0);\\n        return (ans);\\n    }\\n\\t\\t};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,int &ans,int x){\\n        if(root == NULL){\\n            return;\\n        }\\n        x = x*10+root->val;\\n        solve(root->left,ans,x);\\n        solve(root->right,ans,x);\\n        if(root->left==NULL&&root->right==NULL){\\n            ans += x;\\n        }\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        int ans = 0;\\n        solve(root,ans,0);\\n        return (ans);\\n    }\\n\\t\\t};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294307,
                "title": "java-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    static ArrayList<String> sum( TreeNode root , ArrayList<String> arr , String str )\\n    {\\n        if( root==null ) return arr;\\n        if( root.left ==null && root.right==null ){\\n            str+=Integer.toString(root.val) ;\\n            arr.add( str );\\n        }\\n        if( root.left!=null && root.right != null ){\\n            str+=Integer.toString(root.val) ;\\n            sum( root.left , arr , str );\\n            sum( root.right , arr , str );\\n        }\\n        if( root.left!=null && root.right == null ){\\n            str+=Integer.toString(root.val) ;\\n            sum( root.left , arr , str  );\\n        }\\n        if( root.left==null && root.right != null ) {\\n            str+=Integer.toString(root.val) ;\\n            sum( root.right , arr , str  );\\n        }\\n\\n        return arr ;\\n\\n    }\\n    public int sumNumbers(TreeNode root) {\\n        ArrayList<String> arr = new ArrayList<>();\\n        int sum = 0;\\n        sum( root , arr , \"\"  );\\n        for( int i = 0 ; i<arr.size() ; i++ )\\n        {\\n            sum+= Integer.valueOf( arr.get(i) );\\n        }\\n        return sum  ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    static ArrayList<String> sum( TreeNode root , ArrayList<String> arr , String str )\\n    {\\n        if( root==null ) return arr;\\n        if( root.left ==null && root.right==null ){\\n            str+=Integer.toString(root.val) ;\\n            arr.add( str );\\n        }\\n        if( root.left!=null && root.right != null ){\\n            str+=Integer.toString(root.val) ;\\n            sum( root.left , arr , str );\\n            sum( root.right , arr , str );\\n        }\\n        if( root.left!=null && root.right == null ){\\n            str+=Integer.toString(root.val) ;\\n            sum( root.left , arr , str  );\\n        }\\n        if( root.left==null && root.right != null ) {\\n            str+=Integer.toString(root.val) ;\\n            sum( root.right , arr , str  );\\n        }\\n\\n        return arr ;\\n\\n    }\\n    public int sumNumbers(TreeNode root) {\\n        ArrayList<String> arr = new ArrayList<>();\\n        int sum = 0;\\n        sum( root , arr , \"\"  );\\n        for( int i = 0 ; i<arr.size() ; i++ )\\n        {\\n            sum+= Integer.valueOf( arr.get(i) );\\n        }\\n        return sum  ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293870,
                "title": "java-easy-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        if (root.left == null && root.right == null) {\\n            return root.val;\\n        }\\n\\n        Deque<Pair<TreeNode, Integer>> stack = new ArrayDeque<>();\\n        stack.push(new Pair<>(root, root.val));\\n\\n        int sum = 0;\\n\\n        while (!stack.isEmpty()) {\\n            Pair<TreeNode, Integer> cur = stack.pop();\\n            TreeNode node = cur.getKey();\\n            int num = cur.getValue();\\n\\n            if (node.left == null && node.right == null) {\\n                sum += num;\\n                continue;\\n            }\\n\\n            if (node.left != null) {\\n                stack.push(new Pair<>(node.left, num * 10 + node.left.val));\\n            }\\n            if (node.right != null) {\\n                stack.push(new Pair<>(node.right, num * 10 + node.right.val));\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        if (root.left == null && root.right == null) {\\n            return root.val;\\n        }\\n\\n        Deque<Pair<TreeNode, Integer>> stack = new ArrayDeque<>();\\n        stack.push(new Pair<>(root, root.val));\\n\\n        int sum = 0;\\n\\n        while (!stack.isEmpty()) {\\n            Pair<TreeNode, Integer> cur = stack.pop();\\n            TreeNode node = cur.getKey();\\n            int num = cur.getValue();\\n\\n            if (node.left == null && node.right == null) {\\n                sum += num;\\n                continue;\\n            }\\n\\n            if (node.left != null) {\\n                stack.push(new Pair<>(node.left, num * 10 + node.left.val));\\n            }\\n            if (node.right != null) {\\n                stack.push(new Pair<>(node.right, num * 10 + node.right.val));\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044969,
                "title": "simple-and-easy-c-recursion",
                "content": "# Intuition\\ngenerate a number from moving root to leaf , once you reach the leaf node add it to the ans and return.\\n\\n# Approach\\ninitialise x as 0 then after visiting each node do \"x=10*x + node->val;\" this will keep on making your number. once you reach the the leaf node add that x to ans;\\n\\nafter recursion completes return ans;\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n) recursion stack space\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\n    void sum(TreeNode* t,int &ans,int x)\\n    {\\n        if(t==NULL)\\n            return;\\n        x=10*x+t->val;\\n        if(t->left==NULL&&t->right==NULL)\\n        {\\n            ans=ans+x;\\n            return;\\n        }\\n        sum(t->left,ans,x);\\n        sum(t->right,ans,x);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        int ans=0,x=0;\\n        sum(root,ans,x);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    void sum(TreeNode* t,int &ans,int x)\\n    {\\n        if(t==NULL)\\n            return;\\n        x=10*x+t->val;\\n        if(t->left==NULL&&t->right==NULL)\\n        {\\n            ans=ans+x;\\n            return;\\n        }\\n        sum(t->left,ans,x);\\n        sum(t->right,ans,x);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        int ans=0,x=0;\\n        sum(root,ans,x);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648129,
                "title": "c-solution-sum-root-to-leaf-numbers",
                "content": "```\\nclass Solution {\\nprivate:\\n    void solve(TreeNode* root , int &ans, vector<int> path){\\n        //base case \\n        if(root == NULL)\\n            return;\\n\\t\\t\\t\\n        path.push_back(root->val);\\n        \\n        if(root->left == NULL && root->right == NULL){\\n            int num = 0;\\n            for(int i = 0 ; i < path.size() ; i++){\\n                num = num*10 + path[i];\\n            }\\n            ans += num;\\n        } \\n        solve(root->left , ans, path);\\n        solve(root->right , ans, path);\\n        \\n        path.pop_back();\\n    }\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        if(root == NULL)\\n            return 0;\\n        \\n        int ans = 0; vector<int> path;\\n        solve(root, ans,path);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void solve(TreeNode* root , int &ans, vector<int> path){\\n        //base case \\n        if(root == NULL)\\n            return;\\n\\t\\t\\t\\n        path.push_back(root->val);\\n        \\n        if(root->left == NULL && root->right == NULL){\\n            int num = 0;\\n            for(int i = 0 ; i < path.size() ; i++){\\n                num = num*10 + path[i];\\n            }\\n            ans += num;\\n        } \\n        solve(root->left , ans, path);\\n        solve(root->right , ans, path);\\n        \\n        path.pop_back();\\n    }\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        if(root == NULL)\\n            return 0;\\n        \\n        int ans = 0; vector<int> path;\\n        solve(root, ans,path);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756021,
                "title": "easy-cpp-solution",
                "content": "The basic concept I applied here is, while traversing down (in fonc function) I just took root->val and multiplied it by 10 + its successor, this will make all numbers we want to add and stored the numbers in a vector.\\nIn sumNumbers function I just add all numbers present in vector ans.\\n\\n\\n\\n     vector<int> ans;\\n\\n     //Helper Function\\n    void fonc(TreeNode* root,int total){\\n        if(root==NULL){\\n            return;\\n        }\\n        total+= root->val;\\n        if(root->left ==NULL && root->right ==NULL){\\n            ans.push_back(total);\\n            return;\\n        }\\n        fonc(root->left, total * 10);\\n        fonc(root->right, total * 10);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        int total=0;\\n        int s=0;\\n        fonc(root,total);\\n        for(int i=0;i<ans.size();i++){\\n            s+=ans[i]; \\n        }\\n        return s;\\n    }",
                "solutionTags": [
                    "Math",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "The basic concept I applied here is, while traversing down (in fonc function) I just took root->val and multiplied it by 10 + its successor, this will make all numbers we want to add and stored the numbers in a vector.\\nIn sumNumbers function I just add all numbers present in vector ans.\\n\\n\\n\\n     vector<int> ans;\\n\\n     //Helper Function\\n    void fonc(TreeNode* root,int total){\\n        if(root==NULL){\\n            return;\\n        }\\n        total+= root->val;\\n        if(root->left ==NULL && root->right ==NULL){\\n            ans.push_back(total);\\n            return;\\n        }\\n        fonc(root->left, total * 10);\\n        fonc(root->right, total * 10);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        int total=0;\\n        int s=0;\\n        fonc(root,total);\\n        for(int i=0;i<ans.size();i++){\\n            s+=ans[i]; \\n        }\\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1708624,
                "title": "c-simple-solution-using-preorder-traversal-sum-root-to-leaf-numbers",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> answer;\\n    void preorder(TreeNode* root, string str){\\n        if(root == NULL){\\n            return;\\n        }\\n        if(root -> left == NULL and root -> right == NULL){\\n            str = str+to_string(root -> val);\\n            answer.push_back(str);\\n            return;\\n        }\\n        str = str+to_string(root -> val);\\n        preorder(root -> left,str);\\n        preorder(root -> right,str);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        string str;\\n        preorder(root,str);\\n        int sum = 0;\\n        for(int i = 0 ; i < answer.size(); i++){\\n            // reverse(answer[i].begin(), answer[i].end());\\n            int x = stoi(answer[i]);\\n            sum+=x;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> answer;\\n    void preorder(TreeNode* root, string str){\\n        if(root == NULL){\\n            return;\\n        }\\n        if(root -> left == NULL and root -> right == NULL){\\n            str = str+to_string(root -> val);\\n            answer.push_back(str);\\n            return;\\n        }\\n        str = str+to_string(root -> val);\\n        preorder(root -> left,str);\\n        preorder(root -> right,str);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        string str;\\n        preorder(root,str);\\n        int sum = 0;\\n        for(int i = 0 ; i < answer.size(); i++){\\n            // reverse(answer[i].begin(), answer[i].end());\\n            int x = stoi(answer[i]);\\n            sum+=x;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662966,
                "title": "java-bfs-dfs",
                "content": "BFS: 2ms, 38.7 MB\\n```\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        int res = 0;\\n        Queue<Pair<TreeNode,Integer>> q = new LinkedList<>();\\n        q.offer(new Pair<>(root,root.val));\\n        while(!q.isEmpty()){\\n            int s = q.size();\\n            for(int i = 0;i<s;i++){\\n                Pair<TreeNode,Integer> pair = q.poll();\\n                root = pair.getKey();\\n                int value = pair.getValue();\\n                if(root.left==null && root.right==null){\\n                    res += value;\\n                    continue;\\n                }\\n                if(root.left!=null){\\n                    q.offer(new Pair<>(root.left,value*10+root.left.val));\\n                }\\n                if(root.right!=null){\\n                    q.offer(new Pair<>(root.right,value*10+root.right.val));\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\nDFS: 0 ms, 38.3 MB\\n```\\nclass Solution {\\n    int res = 0;\\n    public int sumNumbers(TreeNode root) {\\n        dfs(root,root.val);\\n        return res;\\n    }\\n    public void dfs(TreeNode root, int total){\\n        if(root.left==null && root.right==null){\\n            res+=total;\\n            return;\\n        }\\n        if(root.left!=null){\\n            dfs(root.left, total*10 + root.left.val);\\n        }\\n        if(root.right!=null){\\n            dfs(root.right, total*10 + root.right.val);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        int res = 0;\\n        Queue<Pair<TreeNode,Integer>> q = new LinkedList<>();\\n        q.offer(new Pair<>(root,root.val));\\n        while(!q.isEmpty()){\\n            int s = q.size();\\n            for(int i = 0;i<s;i++){\\n                Pair<TreeNode,Integer> pair = q.poll();\\n                root = pair.getKey();\\n                int value = pair.getValue();\\n                if(root.left==null && root.right==null){\\n                    res += value;\\n                    continue;\\n                }\\n                if(root.left!=null){\\n                    q.offer(new Pair<>(root.left,value*10+root.left.val));\\n                }\\n                if(root.right!=null){\\n                    q.offer(new Pair<>(root.right,value*10+root.right.val));\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int res = 0;\\n    public int sumNumbers(TreeNode root) {\\n        dfs(root,root.val);\\n        return res;\\n    }\\n    public void dfs(TreeNode root, int total){\\n        if(root.left==null && root.right==null){\\n            res+=total;\\n            return;\\n        }\\n        if(root.left!=null){\\n            dfs(root.left, total*10 + root.left.val);\\n        }\\n        if(root.right!=null){\\n            dfs(root.right, total*10 + root.right.val);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557540,
                "title": "python-99-speed-99-memory",
                "content": "```\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        def helper(node, num):\\n            if node is None:\\n                return 0\\n            num = num * 10 + node.val\\n            if node.left is None and node.right is None:\\n                return num\\n            return helper(node.left, num) + helper(node.right, num)\\n        \\n        return helper(root, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        def helper(node, num):\\n            if node is None:\\n                return 0\\n            num = num * 10 + node.val\\n            if node.left is None and node.right is None:\\n                return num\\n            return helper(node.left, num) + helper(node.right, num)\\n        \\n        return helper(root, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557343,
                "title": "rust-dfs-iterative",
                "content": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn sum_numbers(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        let mut res = 0;\\n        let mut stack = vec![(root, 0)];\\n\\n        while let Some(node_sum) = stack.pop() {\\n            if let Some(node) = node_sum.0 {\\n                let node = node.borrow();\\n                let cur_sum = 10 * node_sum.1 + node.val;\\n\\n                if node.left.is_none() && node.right.is_none() {\\n                    res += cur_sum;\\n                    continue;\\n                }\\n\\n                stack.push((node.left.clone(), cur_sum));\\n                stack.push((node.right.clone(), cur_sum));\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Stack",
                    "Depth-First Search"
                ],
                "code": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn sum_numbers(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        let mut res = 0;\\n        let mut stack = vec![(root, 0)];\\n\\n        while let Some(node_sum) = stack.pop() {\\n            if let Some(node) = node_sum.0 {\\n                let node = node.borrow();\\n                let cur_sum = 10 * node_sum.1 + node.val;\\n\\n                if node.left.is_none() && node.right.is_none() {\\n                    res += cur_sum;\\n                    continue;\\n                }\\n\\n                stack.push((node.left.clone(), cur_sum));\\n                stack.push((node.right.clone(), cur_sum));\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1557135,
                "title": "python-simple-and-recursive-solution",
                "content": "```\\nclass Solution:\\n\\n    def dfs(self, val, node) -> int:\\n        if node is None:\\n            return 0\\n        # The node is leaf:\\n        elif node.left is None and node.right is None:\\n            return int(val+str(node.val))\\n        else:\\n            return self.dfs(val + str(node.val), node.right) + self.dfs(val + str(node.val), node.left)\\n\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        return self.dfs(\"\", root)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\n    def dfs(self, val, node) -> int:\\n        if node is None:\\n            return 0\\n        # The node is leaf:\\n        elif node.left is None and node.right is None:\\n            return int(val+str(node.val))\\n        else:\\n            return self.dfs(val + str(node.val), node.right) + self.dfs(val + str(node.val), node.left)\\n\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        return self.dfs(\"\", root)",
                "codeTag": "Java"
            },
            {
                "id": 1556479,
                "title": "c-easy-to-understand-solution-using-recursion",
                "content": "```\\n//variable to store our answer\\nlong long sum = 0;\\n\\t\\n\\t//function for dfs\\n    void recur(TreeNode *root,long long num)\\n    {\\n\\t//base case\\n        if(!root) return;\\n\\t\\t\\n\\t\\t//update num as num*10 + root->val\\n        num *= 10;\\n        num += root->val;\\n\\t\\t\\n\\t\\t//if current node is leaf node, update sum and return\\n        if(!root->left and !root->right)\\n        {\\n            sum += num;\\n            return;\\n        }\\n        \\n\\t\\t//recur for left and right\\n        recur(root->left,num);\\n        recur(root->right,num);\\n    }\\n\\t\\n\\tint sumNumbers(TreeNode* root) {\\n        sum = 0;\\n\\t\\t//call dfs\\n        recur(root,0);\\n\\t\\t\\n\\t\\t//return answer\\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n//variable to store our answer\\nlong long sum = 0;\\n\\t\\n\\t//function for dfs\\n    void recur(TreeNode *root,long long num)\\n    {\\n\\t//base case\\n        if(!root) return;\\n\\t\\t\\n\\t\\t//update num as num*10 + root->val\\n        num *= 10;\\n        num += root->val;\\n\\t\\t\\n\\t\\t//if current node is leaf node, update sum and return\\n        if(!root->left and !root->right)\\n        {\\n            sum += num;\\n            return;\\n        }\\n        \\n\\t\\t//recur for left and right\\n        recur(root->left,num);\\n        recur(root->right,num);\\n    }\\n\\t\\n\\tint sumNumbers(TreeNode* root) {\\n        sum = 0;\\n\\t\\t//call dfs\\n        recur(root,0);\\n\\t\\t\\n\\t\\t//return answer\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1555889,
                "title": "java-easy-solution-dfs-preorder-traversal-explanation-simplified",
                "content": "Hey Programmers,\\nI tried to solve this question using DFS with preorder traversal :\\n\\nLet\\'s Understand this with an example : \\n![image](https://assets.leetcode.com/users/images/9d953701-8857-4132-beb8-2368fde88872_1635899796.6375616.png)\\n\\nThe idea is to do a preorder traversal of the tree. In the preorder traversal, keep track of the value calculated till the current node, let this value be sum. For every node, we update the sum as sum*10 plus node\\u2019s data.\\n\\n![image](https://assets.leetcode.com/users/images/293397a3-8b2a-4edf-90b7-dd0b2ac36a3e_1635899830.6428554.png)\\n\\n```\\nclass Solution {\\n    \\n    int total = 0; // Global variable which hold our sum;\\n    \\n    public int sumNumbers(TreeNode root) {\\n        total = 0;\\n        helper(root, 0); // helper functions holds the root i.e. 4 & leaf node which is intially 0\\n        return total;\\n    }\\n    \\n    void helper(TreeNode root, int sum){\\n        // Base Condition\\n        if(root == null) return;\\n        \\n        sum = sum * 10 + root.val;\\n        \\n        if(root.left == null && root.right == null){\\n            total += sum;\\n            return;\\n        }\\n        \\n        helper(root.left, sum);\\n        helper(root.right, sum);\\n    }\\n}\\n```\\n\\nI hope this help\\'s you to understand. Thanks (:",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int total = 0; // Global variable which hold our sum;\\n    \\n    public int sumNumbers(TreeNode root) {\\n        total = 0;\\n        helper(root, 0); // helper functions holds the root i.e. 4 & leaf node which is intially 0\\n        return total;\\n    }\\n    \\n    void helper(TreeNode root, int sum){\\n        // Base Condition\\n        if(root == null) return;\\n        \\n        sum = sum * 10 + root.val;\\n        \\n        if(root.left == null && root.right == null){\\n            total += sum;\\n            return;\\n        }\\n        \\n        helper(root.left, sum);\\n        helper(root.right, sum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 717793,
                "title": "c-2-solutions-bfs-and-dfs-preorder",
                "content": "**BFS**\\n```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        if(root == NULL) return 0;\\n        \\n        queue<pair<TreeNode*, int>> bfs;\\n        bfs.push({root, root->val});\\n        \\n        pair<TreeNode*, int> curr;\\n        int total_sum = 0;\\n        \\n        while(!bfs.empty()){\\n            curr = bfs.front();\\n            bfs.pop();\\n            \\n            if(!curr.first->left && !curr.first->right)\\n                total_sum += curr.second;\\n            \\n            if(curr.first->left)\\n                bfs.push({curr.first->left, (curr.second * 10 + curr.first->left->val)});\\n            if(curr.first->right)\\n                bfs.push({curr.first->right, (curr.second * 10 + curr.first->right->val)});\\n        }\\n        \\n        return total_sum;\\n    }\\n};\\n```\\n**DFS**\\n```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        int total_sum = 0;\\n        \\n        dfs(root, total_sum, 0);\\n        \\n        return total_sum;\\n    }\\n    \\n    void dfs(TreeNode* root, int& total_sum, int curr){\\n        if(root == NULL) return;\\n        \\n        curr = (curr * 10) + root->val;\\n        \\n        if(!root->right && !root->left) total_sum += curr;\\n        \\n        if(root->left) dfs(root->left, total_sum, curr);\\n        if(root->right) dfs(root->right, total_sum, curr);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        if(root == NULL) return 0;\\n        \\n        queue<pair<TreeNode*, int>> bfs;\\n        bfs.push({root, root->val});\\n        \\n        pair<TreeNode*, int> curr;\\n        int total_sum = 0;\\n        \\n        while(!bfs.empty()){\\n            curr = bfs.front();\\n            bfs.pop();\\n            \\n            if(!curr.first->left && !curr.first->right)\\n                total_sum += curr.second;\\n            \\n            if(curr.first->left)\\n                bfs.push({curr.first->left, (curr.second * 10 + curr.first->left->val)});\\n            if(curr.first->right)\\n                bfs.push({curr.first->right, (curr.second * 10 + curr.first->right->val)});\\n        }\\n        \\n        return total_sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        int total_sum = 0;\\n        \\n        dfs(root, total_sum, 0);\\n        \\n        return total_sum;\\n    }\\n    \\n    void dfs(TreeNode* root, int& total_sum, int curr){\\n        if(root == NULL) return;\\n        \\n        curr = (curr * 10) + root->val;\\n        \\n        if(!root->right && !root->left) total_sum += curr;\\n        \\n        if(root->left) dfs(root->left, total_sum, curr);\\n        if(root->right) dfs(root->right, total_sum, curr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517515,
                "title": "python3-bfs-solution-faster-than-99-submissions",
                "content": "```\\nRuntime: 20 ms, faster than 99.42% of Python3 online submissions for Sum Root to Leaf Numbers.\\nMemory Usage: 12.9 MB, less than 100.00% of Python3 online submissions for Sum Root to Leaf Numbers.\\n```\\n\\n```\\n\\tfrom collections import deque\\n\\n    def sum_numbers_bfs(self, root: TreeNode) -> int:\\n        if not root: return 0\\n\\n        node_queue = deque([(root, root.val)])\\n        total_sum = 0\\n        while node_queue:\\n            cur_node, cur_sum = node_queue.popleft()\\n            if cur_node.left:\\n                node_queue.append((cur_node.left, cur_sum * 10 + cur_node.left.val))\\n\\n            if cur_node.right:\\n                node_queue.append((cur_node.right, cur_sum * 10 + cur_node.right.val))\\n\\n            if not cur_node.left and not cur_node.right:\\n                total_sum += cur_sum\\n\\n        return total_sum\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nRuntime: 20 ms, faster than 99.42% of Python3 online submissions for Sum Root to Leaf Numbers.\\nMemory Usage: 12.9 MB, less than 100.00% of Python3 online submissions for Sum Root to Leaf Numbers.\\n```\n```\\n\\tfrom collections import deque\\n\\n    def sum_numbers_bfs(self, root: TreeNode) -> int:\\n        if not root: return 0\\n\\n        node_queue = deque([(root, root.val)])\\n        total_sum = 0\\n        while node_queue:\\n            cur_node, cur_sum = node_queue.popleft()\\n            if cur_node.left:\\n                node_queue.append((cur_node.left, cur_sum * 10 + cur_node.left.val))\\n\\n            if cur_node.right:\\n                node_queue.append((cur_node.right, cur_sum * 10 + cur_node.right.val))\\n\\n            if not cur_node.left and not cur_node.right:\\n                total_sum += cur_sum\\n\\n        return total_sum\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 413263,
                "title": "python-solution-using-iterative-dfs-approach",
                "content": "Here\\'s my solution for Python.\\n\\nAny type of tree traversal problem you must decided to first either use recursion OR iterative.  The downside to recursion, aside from being challenging if you don\\'t know the patterns, is that is has the potential for Stackoverflow for very large trees.  I like the iterative approach better, since in order to solve the problem, I\\'ll need to traverse the tree in a DFS fashion.\\n\\n```\\nclass Solution:\\n    def sumNumbers(self, root: TreeNode) -> int:\\n        summation = 0\\n        if root is None:\\n            return summation\\n        \\n        stack = [(root, root.val)]\\n        \\n        while len(stack) != 0:\\n            node, running_sum = stack.pop()\\n            \\n            if node.left is None and node.right is None:\\n                summation += running_sum\\n                continue\\n            \\n            if node.left:\\n                new_sum = int(str(running_sum) + str(node.left.val))\\n                stack.append((node.left, new_sum))\\n            if node.right:\\n                new_sum = int(str(running_sum) + str(node.right.val))\\n                stack.append((node.right, new_sum))                \\n                \\n        return summation\\n```\\n\\nAnalysis of time and space complexity is as follows:\\n\\nTime: O(N)\\n    Since I need to traverse through each node to figure out the summations.\\n\\t\\nSpace: O(log N) on average, O(N) worst case\\nExplanation:\\nIf you have unbalanced tree, then the stack reaches N nodes, so its worst case O(N).  To better understand this, imagine a tree that only has node.right branches, and no left branches.  Then DFS traverses through goes through all N nodes to figure out the summation.  \\nIf you have a balanced tree, then you only traverse the depth of the tree (or the height) and thus you only store those nodes in the stack.  To figure out the height of a balanced tree, I recommend google searching the math proof, but that evaluates to O(log N).  So assuming most trees we recieved are balanced, then on average its O(log N).  \\n\\nThe key to solving this problem is recognizing the code pattern used for DFS traversals.  If your not familiar, then I suggest studying the different ways to solve the isValidBST problem\\nhttps://leetcode.com/problems/validate-binary-search-tree/\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumNumbers(self, root: TreeNode) -> int:\\n        summation = 0\\n        if root is None:\\n            return summation\\n        \\n        stack = [(root, root.val)]\\n        \\n        while len(stack) != 0:\\n            node, running_sum = stack.pop()\\n            \\n            if node.left is None and node.right is None:\\n                summation += running_sum\\n                continue\\n            \\n            if node.left:\\n                new_sum = int(str(running_sum) + str(node.left.val))\\n                stack.append((node.left, new_sum))\\n            if node.right:\\n                new_sum = int(str(running_sum) + str(node.right.val))\\n                stack.append((node.right, new_sum))                \\n                \\n        return summation\\n```",
                "codeTag": "Java"
            },
            {
                "id": 248949,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    var s = 0\\n    \\n    func sumNumbers(_ root: TreeNode?) -> Int {\\n        var p = 0\\n        f(root, &p)\\n        \\n        return s\\n    }\\n    \\n    func f(_ root: TreeNode?, _ p: inout Int) {\\n        guard let r = root else { return }\\n        \\n        p = p * 10 + r.val\\n        if r.left == nil && r.right == nil {\\n            s += p\\n        }\\n        \\n        f(r.left, &p)\\n        f(r.right, &p)\\n        p -= r.val\\n        p /= 10\\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    var s = 0\\n    \\n    func sumNumbers(_ root: TreeNode?) -> Int {\\n        var p = 0\\n        f(root, &p)\\n        \\n        return s\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 41480,
                "title": "very-simple-recursion-solution-using-c",
                "content": "    int helper(TreeNode* root, int prev)\\n    {\\n        if(!root)\\n            return 0;\\n        int num = prev * 10 + (root->val);\\n        if(!root->left && !root->right)//if node is leaf\\n            return num;\\n        else\\n            return helper(root->left, num) + helper(root->right, num);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        return helper(root, 0);\\n    }",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "    int helper(TreeNode* root, int prev)\\n    {\\n        if(!root)\\n            return 0;\\n        int num = prev * 10 + (root->val);\\n        if(!root->left && !root->right)//if node is leaf\\n            return num;\\n        else\\n            return helper(root->left, num) + helper(root->right, num);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        return helper(root, 0);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 41527,
                "title": "clean-java-solution-preorder-traversal",
                "content": "    public class Q129 {\\n        int result=0;\\n        public int sumNumbers(TreeNode root) {\\n            if (root==null) return 0;\\n            addValues(root, root.val);\\n            return result;\\n        }\\n    \\n        public void addValues(TreeNode node, int value){\\n            if (node.left==null && node.right==null) result+=value;\\n            if (node.left!=null) addValues(node.left, value*10+node.left.val);\\n            if (node.right!=null) addValues(node.right, value*10+node.right.val);\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public class Q129 {\\n        int result=0;\\n        public int sumNumbers(TreeNode root) {\\n            if (root==null) return 0;\\n            addValues(root, root.val);\\n            return result;\\n        }\\n    \\n        public void addValues(TreeNode node, int value){\\n            if (node.left==null && node.right==null) result+=value;\\n            if (node.left!=null) addValues(node.left, value*10+node.left.val);\\n            if (node.right!=null) addValues(node.right, value*10+node.right.val);\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 41530,
                "title": "simple-and-clean-java-solution-based-on-pre-order-traversal",
                "content": "     public int sumNumbers(TreeNode root) {\\n        return sumNumbers(root, 0);\\n     }\\n\\n\\tprivate int sumNumbers(TreeNode root, int sum) {\\n\\t\\tif (root == null) return 0;\\n\\t\\tsum = sum * 10 + root.val;\\n\\t\\tif (root.left == null && root.right == null) {\\n\\t\\t\\treturn sum;\\n\\t\\t}\\n\\t\\treturn sumNumbers(root.left, sum) + sumNumbers(root.right, sum);\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "     public int sumNumbers(TreeNode root) {\\n        return sumNumbers(root, 0);\\n     }\\n\\n\\tprivate int sumNumbers(TreeNode root, int sum) {\\n\\t\\tif (root == null) return 0;\\n\\t\\tsum = sum * 10 + root.val;\\n\\t\\tif (root.left == null && root.right == null) {\\n\\t\\t\\treturn sum;\\n\\t\\t}\\n\\t\\treturn sumNumbers(root.left, sum) + sumNumbers(root.right, sum);\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 41544,
                "title": "my-c-solution-with-2-parameters",
                "content": "    class Solution {\\n    public:\\n        int sum(TreeNode*root, int subsum) {\\n            if(!root)   return 0;\\n            if(!root->left && !root->right) return subsum*10+root->val;\\n            return sum(root->left, subsum*10+root->val)+sum(root->right, subsum*10+root->val);\\n        }\\n        int sumNumbers(TreeNode* root) {\\n            return sum(root, 0);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int sum(TreeNode*root, int subsum) {\\n            if(!root)   return 0;\\n            if(!root->left && !root->right) return subsum*10+root->val;\\n            return sum(root->left, subsum*10+root->val)+sum(root->right, subsum*10+root->val);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 41575,
                "title": "simple-no-recursive-using-queue-java",
                "content": "     public static int sumNumbers(TreeNode root) {\\n        if(root==null)\\n        \\treturn 0;\\n        Queue<TreeNode> node=new LinkedList<TreeNode>();\\n        Queue<Integer> sum=new LinkedList<Integer>();\\n        node.add(root);\\n        sum.add(root.val);\\n        int res=0;\\n        while(!node.isEmpty()){\\n        \\tTreeNode cur=node.poll();\\n        \\tInteger num=sum.poll();\\n        \\n        \\tif(cur.left!=null){\\n        \\t\\tnode.offer(cur.left);\\n        \\t\\tsum.offer((Integer)((int)(num)*10+cur.left.val));\\n        \\t}\\n        \\tif(cur.right!=null){\\n        \\t\\tnode.offer(cur.right);\\n        \\t\\tsum.offer((Integer)((int)(num)*10+cur.right.val));\\n        \\t}     \\n        \\tif(cur.left==null&&cur.right==null){\\n        \\t\\tres=(int)num+res;\\n        \\t}\\n        \\n        } \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "     public static int sumNumbers(TreeNode root) {\\n        if(root==null)\\n        \\treturn 0;\\n        Queue<TreeNode> node=new LinkedList<TreeNode>();\\n        Queue<Integer> sum=new LinkedList<Integer>();\\n        node.add(root);\\n        sum.add(root.val);\\n        int res=0;\\n        while(!node.isEmpty()){\\n        \\tTreeNode cur=node.poll();\\n        \\tInteger num=sum.poll();\\n        \\n        \\tif(cur.left!=null){\\n        \\t\\tnode.offer(cur.left);\\n        \\t\\tsum.offer((Integer)((int)(num)*10+cur.left.val));\\n        \\t}\\n        \\tif(cur.right!=null){\\n        \\t\\tnode.offer(cur.right);\\n        \\t\\tsum.offer((Integer)((int)(num)*10+cur.right.val));\\n        \\t}     \\n        \\tif(cur.left==null&&cur.right==null){\\n        \\t\\tres=(int)num+res;\\n        \\t}\\n        \\n        } \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 41577,
                "title": "c-5ms-dfs-code-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    int sumNumbers(TreeNode *root) {\\n        return traverse(0, root);\\n    }\\n    \\n    int traverse(int fathers, TreeNode *root) {\\n        if (root == NULL) {\\n            return 0;\\n        }\\n        \\n        int cur = fathers * 10 + root->val;\\n        \\n        int sum = traverse(cur, root->left) + traverse(cur, root->right);\\n        \\n        return (sum != 0) ? sum : cur;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int sumNumbers(TreeNode *root) {\\n        return traverse(0, root);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 41578,
                "title": "simple-java-solution-accepted",
                "content": "    public class Solution {\\n        public int sumNumbers(TreeNode root) {\\n            return sumNumbersUtil(root, 0);\\n        }\\n        \\n        public int sumNumbersUtil(TreeNode root, int path) {\\n            if (root == null) {\\n                return 0;\\n            }\\n            \\n            path = path*10 + root.val;\\n    \\n            if (root.left == null && root.right == null) {\\n                return path;\\n            }\\n    \\n            return sumNumbersUtil(root.left, path) + sumNumbersUtil(root.right, path);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int sumNumbers(TreeNode root) {\\n            return sumNumbersUtil(root, 0);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3524388,
                "title": "java-beats-100-oms-recursion-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        return dfs(root, 0);\\n    }\\n    private int dfs(TreeNode root, int sum) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        sum = sum * 10 + root.val;\\n        if (root.left == null && root.right == null) {\\n            return sum;\\n        }\\n        return dfs(root.left, sum) + dfs(root.right, sum);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        return dfs(root, 0);\\n    }\\n    private int dfs(TreeNode root, int sum) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        sum = sum * 10 + root.val;\\n        if (root.left == null && root.right == null) {\\n            return sum;\\n        }\\n        return dfs(root.left, sum) + dfs(root.right, sum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298158,
                "title": "awesome-logic-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        def sumroot(root,s):\\n            if not root: return 0\\n            s=s*10+root.val\\n            if not root.left and not root.right: return s\\n            return sumroot(root.left,s) + sumroot(root.right,s)\\n        return sumroot(root,0)\\n    #please upvote me it would encourage me alot\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        def sumroot(root,s):\\n            if not root: return 0\\n            s=s*10+root.val\\n            if not root.left and not root.right: return s\\n            return sumroot(root.left,s) + sumroot(root.right,s)\\n        return sumroot(root,0)\\n    #please upvote me it would encourage me alot\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297822,
                "title": "php-beats-100-javascript-93-2-different-approaches",
                "content": "##### Here you can get acquainted with **2 different solutions**. Solutions implemented in **PHP** and **JavaScript**\\n\\n### SOLUTION #1\\nThe approach used in this solution is to traverse the tree using a breadth-first search, and for each node add the values of its children to the sum of its own value. We also use a queue to keep track of the nodes that need to be visited. We start with the root node, and for each node check if it is a leaf node (if it has no children). If it is, add the value of the node to the total sum. If it is not a leaf node, add its children to the queue, and add the node value to the children\\'s values. When the queue is empty, all the nodes have been visited and the sum is returned.\\n*Time complexity*: O(n), as we visit every node in the tree once.\\n*Space complexity*: O(n), as we use a queue to store up to n nodes at any given time.\\n\\n```PHP []\\nclass Solution\\n{\\n    /**\\n     * @param TreeNode $root\\n     * @return Integer\\n     */\\n    function sumNumbers(TreeNode $root): int {\\n        if ($root === null || $root->val === null) return 0;\\n        $totalSum = 0;\\n        $queue = [$root];\\n        while (count($queue) > 0) {\\n            $node = array_shift($queue);\\n            if ($node->left === null && $node->right === null) {\\n                $totalSum += $node->val;\\n            }\\n\\n            if ($node->left) {\\n                $node->left->val = $node->val * 10 + $node->left->val;\\n                $queue[] = $node->left;\\n            }\\n            if ($node->right) {\\n                $node->right->val = $node->val * 10 + $node->right->val;\\n                $queue[] = $node->right;\\n            }\\n        }\\n        return $totalSum;\\n    }\\n}\\n```\\n```javascript []\\nvar sumNumbers = function (root) {\\n    let totalSum = 0;\\n    if (root === null || root.val === undefined) return 0;\\n    if (root.left === undefined && root.right === undefined) return root.val;\\n    let queue = [root];\\n\\n    while (queue.length > 0) {\\n        node = queue.shift();\\n        if (node.left === null && node.right == null) {\\n            totalSum += node.val;\\n        }\\n        if (node.left && node.left.val !== undefined) {\\n            node.left.val = node.val * 10 + node.left.val;\\n            queue.push(node.left);\\n        }\\n        if (node.right && node.right.val !== undefined) {\\n            node.right.val = node.val * 10 + node.right.val;\\n            queue.push(node.right);\\n        }\\n    }\\n    return totalSum;\\n};\\n```\\n\\n\\n### SOLUTION #2\\nThis solution uses a Depth-First Search (DFS) approach to traverse the binary tree and calculate the sum of all root-to-leaf path numbers. The DFS function takes in a node and the sum of the existing path up to the node. If the node is null, then it returns 0. If the node is a leaf node, it returns the total sum of the path from the root to the leaf node. If the node has children, then it calls the same DFS function on both of the children, passing in the sum of the existing path up to that node. The sum of all the DFS calls is then returned.\\n*Time Complexity*: O(n) as we have to traverse each node in the binary tree once.\\n*Space Complexity*: O(n) as the maximum depth of the recursive stack can be n for a binary tree with n nodes.\\n\\n```PHP []\\nclass Solution\\n{\\n    /**\\n     * @param TreeNode $root\\n     * @return Integer\\n     */\\n    function sumNumbers(TreeNode $root): int\\n    {\\n        return $this->dfs($root, 0);\\n    }\\n\\n    private function dfs(?TreeNode $node, int $sum): int\\n    {\\n        if ($node === null) {\\n            return 0;\\n        }\\n        if ($node->left === null && $node->right == null) {\\n            return $sum * 10 + $node->val;\\n        }\\n        return $this->dfs($node->left, $sum * 10 + $node->val) +\\n            $this->dfs($node->right, $sum * 10 + $node->val);\\n    }\\n}\\n```\\n```javascript []\\nvar sumNumbers = function (root) {\\n    const dfs = function (node, sum) {\\n        if (node == null) {\\n            return 0;\\n        }\\n        if (node.left === null && node.right == null) {\\n            return sum * 10 + node.val;\\n        }\\n        return dfs(node.left, sum * 10 + node.val) +\\n               dfs(node.right, sum * 10 + node.val);\\n    }\\n    return dfs(root, 0);\\n}\\n```\\n\\n### If my work was useful for you, please upvote\\n\\uD83D\\uDC4D\\uD83D\\uDC4D\\uD83D\\uDC4D",
                "solutionTags": [
                    "JavaScript",
                    "PHP"
                ],
                "code": "```PHP []\\nclass Solution\\n{\\n    /**\\n     * @param TreeNode $root\\n     * @return Integer\\n     */\\n    function sumNumbers(TreeNode $root): int {\\n        if ($root === null || $root->val === null) return 0;\\n        $totalSum = 0;\\n        $queue = [$root];\\n        while (count($queue) > 0) {\\n            $node = array_shift($queue);\\n            if ($node->left === null && $node->right === null) {\\n                $totalSum += $node->val;\\n            }\\n\\n            if ($node->left) {\\n                $node->left->val = $node->val * 10 + $node->left->val;\\n                $queue[] = $node->left;\\n            }\\n            if ($node->right) {\\n                $node->right->val = $node->val * 10 + $node->right->val;\\n                $queue[] = $node->right;\\n            }\\n        }\\n        return $totalSum;\\n    }\\n}\\n```\n```javascript []\\nvar sumNumbers = function (root) {\\n    let totalSum = 0;\\n    if (root === null || root.val === undefined) return 0;\\n    if (root.left === undefined && root.right === undefined) return root.val;\\n    let queue = [root];\\n\\n    while (queue.length > 0) {\\n        node = queue.shift();\\n        if (node.left === null && node.right == null) {\\n            totalSum += node.val;\\n        }\\n        if (node.left && node.left.val !== undefined) {\\n            node.left.val = node.val * 10 + node.left.val;\\n            queue.push(node.left);\\n        }\\n        if (node.right && node.right.val !== undefined) {\\n            node.right.val = node.val * 10 + node.right.val;\\n            queue.push(node.right);\\n        }\\n    }\\n    return totalSum;\\n};\\n```\n```PHP []\\nclass Solution\\n{\\n    /**\\n     * @param TreeNode $root\\n     * @return Integer\\n     */\\n    function sumNumbers(TreeNode $root): int\\n    {\\n        return $this->dfs($root, 0);\\n    }\\n\\n    private function dfs(?TreeNode $node, int $sum): int\\n    {\\n        if ($node === null) {\\n            return 0;\\n        }\\n        if ($node->left === null && $node->right == null) {\\n            return $sum * 10 + $node->val;\\n        }\\n        return $this->dfs($node->left, $sum * 10 + $node->val) +\\n            $this->dfs($node->right, $sum * 10 + $node->val);\\n    }\\n}\\n```\n```javascript []\\nvar sumNumbers = function (root) {\\n    const dfs = function (node, sum) {\\n        if (node == null) {\\n            return 0;\\n        }\\n        if (node.left === null && node.right == null) {\\n            return sum * 10 + node.val;\\n        }\\n        return dfs(node.left, sum * 10 + node.val) +\\n               dfs(node.right, sum * 10 + node.val);\\n    }\\n    return dfs(root, 0);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297440,
                "title": "simple-java-solution-using-recursion-100-faster",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        // takes root and initial sum (which is 0 at the start)\\n        return inorder(root, 0);\\n    }\\n    private int inorder(TreeNode root, int num) {\\n        // we reached to root of tree\\n        if (root.left == null && root.right == null) return num * 10 + root.val;\\n        \\n        num = num * 10 + root.val;\\n        int left = 0;\\n        int right = 0;\\n        // computing left sub tree\\n        if (root.left != null) {\\n            left += inorder(root.left, num);\\n        }\\n        // computing right sub tree\\n        if (root.right != null) {\\n            right += inorder(root.right, num);\\n        }\\n        // adding values of both sub trees\\n        return left + right;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        // takes root and initial sum (which is 0 at the start)\\n        return inorder(root, 0);\\n    }\\n    private int inorder(TreeNode root, int num) {\\n        // we reached to root of tree\\n        if (root.left == null && root.right == null) return num * 10 + root.val;\\n        \\n        num = num * 10 + root.val;\\n        int left = 0;\\n        int right = 0;\\n        // computing left sub tree\\n        if (root.left != null) {\\n            left += inorder(root.left, num);\\n        }\\n        // computing right sub tree\\n        if (root.right != null) {\\n            right += inorder(root.right, num);\\n        }\\n        // adding values of both sub trees\\n        return left + right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296503,
                "title": "simple-c-solution-using-path-sum-i",
                "content": "# Intuition\\nPath Sum I\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,string &s,int &ans){\\n        if(root && !root->left && !root->right)\\n        {\\n            s+=to_string(root->val);\\n            ans+=stoi(s);\\n            s.pop_back();\\n        }\\n        if(root){\\n            s+=to_string(root->val);\\n            solve(root->left,s,ans);\\n            solve(root->right,s,ans);\\n            s.pop_back();\\n        }\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        string s=\"\";\\n        int ans=0;\\n        solve(root,s,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,string &s,int &ans){\\n        if(root && !root->left && !root->right)\\n        {\\n            s+=to_string(root->val);\\n            ans+=stoi(s);\\n            s.pop_back();\\n        }\\n        if(root){\\n            s+=to_string(root->val);\\n            solve(root->left,s,ans);\\n            solve(root->right,s,ans);\\n            s.pop_back();\\n        }\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        string s=\"\";\\n        int ans=0;\\n        solve(root,s,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296139,
                "title": "python3-simple-dfs-27-ms-faster-than-92-24",
                "content": "https://leetcode.com/submissions/detail/914997379/\\nRuntime: **27 ms, faster than 92.24%** of Python3 online submissions for Sum Root to Leaf Numbers.  \\nMemory Usage: 13.8 MB, less than 95.89% of Python3 online submissions for Sum Root to Leaf Numbers.  \\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        nsum = 0\\n        if not root: return nsum\\n        l = [(str(root.val), root)]\\n        while l: ## dfs\\n            s, n = l.pop() ## string, node\\n            if not n.left and not n.right:\\n                nsum += int(s); continue\\n            if n.right:\\n                l.append((s+str(n.right.val), n.right))\\n            if n.left:\\n                l.append((s+str(n.left.val), n.left))\\n        return nsum\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        nsum = 0\\n        if not root: return nsum\\n        l = [(str(root.val), root)]\\n        while l: ## dfs\\n            s, n = l.pop() ## string, node\\n            if not n.left and not n.right:\\n                nsum += int(s); continue\\n            if n.right:\\n                l.append((s+str(n.right.val), n.right))\\n            if n.left:\\n                l.append((s+str(n.left.val), n.left))\\n        return nsum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296020,
                "title": "very-simple-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing Recursion\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. First traverse left subtree using node.left, node.right\\n2. On each rucursive call add left node value to existing value multiplying by 10. (On each level - value goes to new point 1->10->100)\\n3. Traverse right subtree.\\n4. Add value to result if left and right subtree is null means it is a leaf node.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(h), where h is the height of the tree.\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int result = 0;\\n    \\n\\tpublic int sumNumbers(TreeNode root) {\\n\\t\\tif(root == null) return 0;\\n        sumNumbersHelper(root.left, root.right, root.val);\\n\\t\\treturn result;\\n    }\\n\\t\\n\\tpublic void sumNumbersHelper(TreeNode l, TreeNode r, int val) {\\n\\t\\tif(l==null && r == null) {\\n\\t\\t\\tresult += val;\\n\\t\\t}\\n\\t\\t\\n\\t\\tif(l!= null) {\\n\\t\\t\\tsumNumbersHelper(l.left, l.right, val*10 + l.val);\\n\\t\\t}\\n\\t\\t\\n\\t\\tif(r != null) {\\n\\t\\t\\tsumNumbersHelper(r.left, r.right, val*10 + r.val);\\n\\t\\t}\\n\\t}\\n\\t\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int result = 0;\\n    \\n\\tpublic int sumNumbers(TreeNode root) {\\n\\t\\tif(root == null) return 0;\\n        sumNumbersHelper(root.left, root.right, root.val);\\n\\t\\treturn result;\\n    }\\n\\t\\n\\tpublic void sumNumbersHelper(TreeNode l, TreeNode r, int val) {\\n\\t\\tif(l==null && r == null) {\\n\\t\\t\\tresult += val;\\n\\t\\t}\\n\\t\\t\\n\\t\\tif(l!= null) {\\n\\t\\t\\tsumNumbersHelper(l.left, l.right, val*10 + l.val);\\n\\t\\t}\\n\\t\\t\\n\\t\\tif(r != null) {\\n\\t\\t\\tsumNumbersHelper(r.left, r.right, val*10 + r.val);\\n\\t\\t}\\n\\t}\\n\\t\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3295776,
                "title": "easy-o-n-c-solution",
                "content": "# Approach\\nAdding to total sum only when reaching leaf node\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int totalsum=0;\\n    int sumNumbers(TreeNode* root,int sum=0) {\\n        if(root){\\n            int sum1 = sum;\\n            sum1 = sum1*10+root->val;\\n            sumNumbers(root->left,sum1);\\n            sumNumbers(root->right,sum1);\\n            if(!root->left && !root->right){\\n                totalsum+=sum1;\\n            }\\n            return totalsum;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int totalsum=0;\\n    int sumNumbers(TreeNode* root,int sum=0) {\\n        if(root){\\n            int sum1 = sum;\\n            sum1 = sum1*10+root->val;\\n            sumNumbers(root->left,sum1);\\n            sumNumbers(root->right,sum1);\\n            if(!root->left && !root->right){\\n                totalsum+=sum1;\\n            }\\n            return totalsum;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3295408,
                "title": "python-elegant-short-dsf-generators-97-5-faster",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n)\\n    Memory: O(h)\\n    \"\"\"\\n\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        return sum(self._get_paths(root, path=0))\\n\\n    @classmethod\\n    def _get_paths(cls, root: Optional[TreeNode], path: int) -> Iterable[int]:\\n        if root is None:\\n            return\\n\\n        path = path * 10 + root.val\\n        if root.left is None and root.right is None:\\n            yield path\\n        else:\\n            yield from cls._get_paths(root.left, path)\\n            yield from cls._get_paths(root.right, path)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n)\\n    Memory: O(h)\\n    \"\"\"\\n\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        return sum(self._get_paths(root, path=0))\\n\\n    @classmethod\\n    def _get_paths(cls, root: Optional[TreeNode], path: int) -> Iterable[int]:\\n        if root is None:\\n            return\\n\\n        path = path * 10 + root.val\\n        if root.left is None and root.right is None:\\n            yield path\\n        else:\\n            yield from cls._get_paths(root.left, path)\\n            yield from cls._get_paths(root.right, path)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3295189,
                "title": "javascript-rust-go-short-recursive-solution",
                "content": "## JavaScript Solution\\n\\n```\\nconst sumNumbers = function (root, num = 0) {\\n  if (!root) return 0;\\n  num = num * 10 + root.val;\\n  if (!root.left && !root.right) return num;\\n\\n  return sumNumbers(root.left, num) + sumNumbers(root.right, num);\\n};\\n\\n```\\n\\n## Rust Solution\\n```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn sum_numbers(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        Solution::sum_nodes(root, 0)\\n    }\\n\\n    pub fn sum_nodes(node: Option<Rc<RefCell<TreeNode>>>, num: i32) -> i32 {\\n        if node.is_none() { return 0; }\\n        let node = node.unwrap();\\n        let node = node.borrow();\\n        let num = num * 10 + node.val;\\n\\n        if node.left.is_none() && node.right.is_none() { return num; }\\n\\n        Solution::sum_nodes(node.left.clone(), num.clone()) \\n            + Solution::sum_nodes(node.right.clone(), num.clone())\\n    }\\n}\\n```\\n\\n## Go Solution\\n\\n```go\\nfunc sumNumbers(root *TreeNode) int {\\n\\treturn sumNodes(root, 0)\\n}\\n\\nfunc sumNodes(node *TreeNode, num int) int {\\n\\tif node == nil { return 0 }\\n\\n\\tnum = num * 10 + node.Val\\n\\n\\tif node.Left == nil && node.Right == nil {\\n\\t\\treturn num\\n\\t}\\n\\n\\treturn sumNodes(node.Left, num) + sumNodes(node.Right, num)\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Go",
                    "Rust",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nconst sumNumbers = function (root, num = 0) {\\n  if (!root) return 0;\\n  num = num * 10 + root.val;\\n  if (!root.left && !root.right) return num;\\n\\n  return sumNumbers(root.left, num) + sumNumbers(root.right, num);\\n};\\n\\n```\n```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn sum_numbers(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        Solution::sum_nodes(root, 0)\\n    }\\n\\n    pub fn sum_nodes(node: Option<Rc<RefCell<TreeNode>>>, num: i32) -> i32 {\\n        if node.is_none() { return 0; }\\n        let node = node.unwrap();\\n        let node = node.borrow();\\n        let num = num * 10 + node.val;\\n\\n        if node.left.is_none() && node.right.is_none() { return num; }\\n\\n        Solution::sum_nodes(node.left.clone(), num.clone()) \\n            + Solution::sum_nodes(node.right.clone(), num.clone())\\n    }\\n}\\n```\n```go\\nfunc sumNumbers(root *TreeNode) int {\\n\\treturn sumNodes(root, 0)\\n}\\n\\nfunc sumNodes(node *TreeNode, num int) int {\\n\\tif node == nil { return 0 }\\n\\n\\tnum = num * 10 + node.Val\\n\\n\\tif node.Left == nil && node.Right == nil {\\n\\t\\treturn num\\n\\t}\\n\\n\\treturn sumNodes(node.Left, num) + sumNodes(node.Right, num)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3295157,
                "title": "easy-to-understand-c-solution-using-dfs-and-string",
                "content": "# Intuition\\nFor finding the paths we have to traverse the tree and store path into appropriate data structure and add those at the leaf node\\n\\n# Approach\\nWe need paths from root to leaf, so we will take a string which will keep the record of values from root to leaf and when we reach the leaf node then we will convert the string value to integer value and add it to our ans variable this is the number obtained from path one. Now remove the last inserted value as we have to traverse the right subtree and follow the same process for second path\\n\\n# Complexity\\n- Time complexity:\\nO(n) As we have visited ever node only once\\n\\n- Space complexity:\\nO(1) Ignoring the recursion stack space and auxillary space\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    string s=\"\";\\n    long long int ans=0;\\n    void in(TreeNode* node){\\n\\n        if(node==NULL) return; \\n        s+=(to_string(node->val));\\n\\n        in(node->left);\\n        in(node->right);\\n        \\n        if(node->left==NULL && node->right==NULL) ans+=stoi(s);\\n        \\n        s.pop_back();\\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n        in(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    string s=\"\";\\n    long long int ans=0;\\n    void in(TreeNode* node){\\n\\n        if(node==NULL) return; \\n        s+=(to_string(node->val));\\n\\n        in(node->left);\\n        in(node->right);\\n        \\n        if(node->left==NULL && node->right==NULL) ans+=stoi(s);\\n        \\n        s.pop_back();\\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n        in(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294792,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n\\n    void help(TreeNode* root, long long tempSum, int& totalSum)\\n    {\\n        if(root==NULL) return;\\n      \\n        if(root->left==NULL && root->right==NULL)\\n       \\n        {\\n           tempSum = tempSum*10+root->val;\\n            totalSum+=tempSum;\\n        }\\n        tempSum = tempSum*10+root->val;\\n\\n        help(root->left, tempSum, totalSum);\\n\\n        help(root->right, tempSum, totalSum);\\n    }\\npublic:\\n    int sumNumbers(TreeNode* root)\\n     {\\n        int ans=0;\\n        help(root, 0, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n\\n    void help(TreeNode* root, long long tempSum, int& totalSum)\\n    {\\n        if(root==NULL) return;\\n      \\n        if(root->left==NULL && root->right==NULL)\\n       \\n        {\\n           tempSum = tempSum*10+root->val;\\n            totalSum+=tempSum;\\n        }\\n        tempSum = tempSum*10+root->val;\\n\\n        help(root->left, tempSum, totalSum);\\n\\n        help(root->right, tempSum, totalSum);\\n    }\\npublic:\\n    int sumNumbers(TreeNode* root)\\n     {\\n        int ans=0;\\n        help(root, 0, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294204,
                "title": "java-dfs-no-strings-beats-100-7-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ on the stack\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  private int dfs(TreeNode node, int val) {\\n    var a = val * 10 + node.val;\\n    if (node.left == null && node.right == null) return a;\\n\\n    var sum = 0;\\n    if (node.left != null) sum += dfs(node.left, a);\\n    if (node.right != null) sum += dfs(node.right, a);\\n\\n    return sum;\\n  }\\n\\n  public int sumNumbers(TreeNode root) {\\n    return dfs(root, 0);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n  private int dfs(TreeNode node, int val) {\\n    var a = val * 10 + node.val;\\n    if (node.left == null && node.right == null) return a;\\n\\n    var sum = 0;\\n    if (node.left != null) sum += dfs(node.left, a);\\n    if (node.right != null) sum += dfs(node.right, a);\\n\\n    return sum;\\n  }\\n\\n  public int sumNumbers(TreeNode root) {\\n    return dfs(root, 0);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294182,
                "title": "c-4-lines-recursive-100-faster",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* r, int prev = 0) {\\n        if (!r) return 0;\\n        auto val = prev + r->val;\\n        if (!r->left && !r->right) return val;\\n        return sumNumbers(r->left, val * 10) + sumNumbers(r->right, val * 10);\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* r, int prev = 0) {\\n        if (!r) return 0;\\n        auto val = prev + r->val;\\n        if (!r->left && !r->right) return val;\\n        return sumNumbers(r->left, val * 10) + sumNumbers(r->right, val * 10);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294065,
                "title": "daily-leetcode-solution-easy-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,int num,int& ans){\\n        if(!root) return;\\n        if(root->left==NULL and root->right==NULL){\\n            num*=10;\\n            num+=root->val;\\n            ans+=num;\\n            return;\\n        }\\n        num*=10;\\n        num+=root->val;\\n        solve(root->left,num,ans);\\n        solve(root->right,num,ans);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        int ans=0;\\n        solve(root,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,int num,int& ans){\\n        if(!root) return;\\n        if(root->left==NULL and root->right==NULL){\\n            num*=10;\\n            num+=root->val;\\n            ans+=num;\\n            return;\\n        }\\n        num*=10;\\n        num+=root->val;\\n        solve(root->left,num,ans);\\n        solve(root->right,num,ans);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        int ans=0;\\n        solve(root,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293992,
                "title": "beats-100-c-simple-recursion",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(LOGN)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void add(TreeNode* root,int numtillnow)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        numtillnow*=10;\\n        numtillnow+=root->val;\\n        if(root->left==NULL && root->right==NULL)\\n        {\\n            ans+=numtillnow;\\n            return;\\n        }\\n        add(root->left,numtillnow);\\n        add(root->right,numtillnow);\\n        return;\\n    }\\n    int sumNumbers(TreeNode* root) \\n    {\\n        add(root,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void add(TreeNode* root,int numtillnow)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        numtillnow*=10;\\n        numtillnow+=root->val;\\n        if(root->left==NULL && root->right==NULL)\\n        {\\n            ans+=numtillnow;\\n            return;\\n        }\\n        add(root->left,numtillnow);\\n        add(root->right,numtillnow);\\n        return;\\n    }\\n    int sumNumbers(TreeNode* root) \\n    {\\n        add(root,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293925,
                "title": "dfs-with-a-minor-change-standard-path-problem",
                "content": "# Intuition\\nTraversing from root to leaf node along every path will give a number. The sum of all those numbers has to be returned. \\nWe can follow a standard pre-order traversal, keeping track of the number we have tracked so far along our path, and once we arrive at a leaf node, add it to our result.\\n\\n# Approach\\nIn a standard pre-order traversal code, maintain a variable- $$currNum$$ which will represent the number we have built by following a path.\\n$$currNum$$ will be calculated by the formula:\\n```\\ncurrNum = Number made before reaching current Node*10 + Node.val\\n```\\nEx:\\n![image.png](https://assets.leetcode.com/users/images/eff9dd3c-6ca0-4f8b-81c3-9620a84906a4_1678753155.4871728.png)\\n\\nThe above image represents the value of $$currNum$$ for nodes $$4$$ and $$9$$. All we have to do is add the $$currNum$$ values whenever we reach a leaf node.\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(h)$$\\n$$h$$ -> height of tree\\n\\n# Code\\n```Java []\\nclass Solution {\\n    int sum=0; \\n    public int sumNumbers(TreeNode root) {\\n        f(root,0);\\n        return sum;\\n    }\\n    public void f(TreeNode root,int currNum){\\n        if(root==null ) return ; \\n        if(root.left==null && root.right==null ) {\\n            //adding currNum values\\n            sum+=(currNum*10+root.val);\\n            return;\\n        }\\n        f(root.left,currNum*10+root.val);\\n        f(root.right,currNum*10+root.val);\\n// currNum*10+root.val passes the value of 49(4*10+9) to the node\\n//with value 5 in the picture. \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    int sumNumbers(TreeNode* root) {\\n        f(root,0);\\n        return sum;\\n    }\\n    \\n    void f(TreeNode* root, int currNum) {\\n        if (root == NULL) return;\\n        if (root->left == NULL && root->right == NULL) {\\n            sum += (currNum*10 + root->val);\\n            return;\\n        }\\n        f(root->left, currNum*10 + root->val);\\n        f(root->right, currNum*10 + root->val);\\n    }\\n};\\n\\n```\\n```python3 []\\nclass Solution:\\n    def __init__(self):\\n        self.sum = 0\\n        \\n    def sumNumbers(self, root: TreeNode) -> int:\\n        self.f(root, 0)\\n        return self.sum\\n    \\n    def f(self, root: TreeNode, currNum: int) -> None:\\n        if not root: return\\n        if not root.left and not root.right:\\n            self.sum += (currNum*10 + root.val)\\n            return\\n        self.f(root.left, currNum*10 + root.val)\\n        self.f(root.right, currNum*10 + root.val)\\n\\n```\\n\\n---\\n\\nWe can do without the global variable by a simplification:\\n```\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        return f(root,0);\\n    }\\n    public int f(TreeNode root,int currNum){\\n        if(root==null ) return 0; \\n        if(root.left==null && root.right==null ) {\\n            return (currNum*10+root.val);\\n            \\n        }\\n        return f(root.left,currNum*10+root.val)+ f(root.right,currNum*10+root.val);\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\ncurrNum = Number made before reaching current Node*10 + Node.val\\n```\n```Java []\\nclass Solution {\\n    int sum=0; \\n    public int sumNumbers(TreeNode root) {\\n        f(root,0);\\n        return sum;\\n    }\\n    public void f(TreeNode root,int currNum){\\n        if(root==null ) return ; \\n        if(root.left==null && root.right==null ) {\\n            //adding currNum values\\n            sum+=(currNum*10+root.val);\\n            return;\\n        }\\n        f(root.left,currNum*10+root.val);\\n        f(root.right,currNum*10+root.val);\\n// currNum*10+root.val passes the value of 49(4*10+9) to the node\\n//with value 5 in the picture. \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    int sumNumbers(TreeNode* root) {\\n        f(root,0);\\n        return sum;\\n    }\\n    \\n    void f(TreeNode* root, int currNum) {\\n        if (root == NULL) return;\\n        if (root->left == NULL && root->right == NULL) {\\n            sum += (currNum*10 + root->val);\\n            return;\\n        }\\n        f(root->left, currNum*10 + root->val);\\n        f(root->right, currNum*10 + root->val);\\n    }\\n};\\n\\n```\n```python3 []\\nclass Solution:\\n    def __init__(self):\\n        self.sum = 0\\n        \\n    def sumNumbers(self, root: TreeNode) -> int:\\n        self.f(root, 0)\\n        return self.sum\\n    \\n    def f(self, root: TreeNode, currNum: int) -> None:\\n        if not root: return\\n        if not root.left and not root.right:\\n            self.sum += (currNum*10 + root.val)\\n            return\\n        self.f(root.left, currNum*10 + root.val)\\n        self.f(root.right, currNum*10 + root.val)\\n\\n```\n```\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        return f(root,0);\\n    }\\n    public int f(TreeNode root,int currNum){\\n        if(root==null ) return 0; \\n        if(root.left==null && root.right==null ) {\\n            return (currNum*10+root.val);\\n            \\n        }\\n        return f(root.left,currNum*10+root.val)+ f(root.right,currNum*10+root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228396,
                "title": "c-solution-dfs",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    private int sum  = 0;\\n\\n    public int SumNumbers(TreeNode root) {\\n        DFS(root, 0);\\n        return sum;\\n    }\\n\\n    private void DFS(TreeNode root, int currentNumber){\\n        if(root == null){\\n            return;\\n        }\\n\\n        currentNumber = currentNumber*10 + root.val;\\n\\n        if(root.left == null && root.right == null){\\n            sum += currentNumber;\\n            return;\\n        }\\n\\n        DFS(root.left, currentNumber);\\n        DFS(root.right, currentNumber);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    private int sum  = 0;\\n\\n    public int SumNumbers(TreeNode root) {\\n        DFS(root, 0);\\n        return sum;\\n    }\\n\\n    private void DFS(TreeNode root, int currentNumber){\\n        if(root == null){\\n            return;\\n        }\\n\\n        currentNumber = currentNumber*10 + root.val;\\n\\n        if(root.left == null && root.right == null){\\n            sum += currentNumber;\\n            return;\\n        }\\n\\n        DFS(root.left, currentNumber);\\n        DFS(root.right, currentNumber);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132830,
                "title": "python3-3-solutions",
                "content": "# Intuition\\n    please upvote if its useful\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode] , val = 0) -> int:\\n        if not root:\\n            return 0\\n        q = [root]\\n        sum = 0\\n        while(q):\\n            node  = q.pop()\\n            if not node.left and not node.right:\\n                sum+=node.val\\n            \\n            if node.left:\\n                node.left.val += node.val*10\\n                q.append(node.left)\\n            if node.right:\\n                node.right.val += node.val*10\\n                q.append(node.right)\\n        return sum\\n\\n\\n\\n\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode] , val = 0) -> int:\\n        if not root:\\n            return 0\\n        q = [(root , str(root.val))]\\n        sum = 0\\n        while(q):\\n            node ,val = q.pop()\\n            if not node.left and not node.right:\\n                sum+=int(val)\\n            if node.left:\\n                q.append((node.left , val + str(node.left.val)))\\n            if node.right:\\n                q.append((node.right , val + str(node.right.val)))\\n        return sum\\n\\n\\n\\n\\n\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode] , val = 0) -> int:\\n        if not root:\\n            return 0\\n        val = 10 * val + root.val\\n        if not root.left and not root.right:\\n            return val\\n\\n        return self.sumNumbers(root.left , val) + self.sumNumbers(root.right , val)",
                "solutionTags": [
                    "Python3",
                    "Stack",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "# Intuition\\n    please upvote if its useful\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode] , val = 0) -> int:\\n        if not root:\\n            return 0\\n        q = [root]\\n        sum = 0\\n        while(q):\\n            node  = q.pop()\\n            if not node.left and not node.right:\\n                sum+=node.val\\n            \\n            if node.left:\\n                node.left.val += node.val*10\\n                q.append(node.left)\\n            if node.right:\\n                node.right.val += node.val*10\\n                q.append(node.right)\\n        return sum\\n\\n\\n\\n\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode] , val = 0) -> int:\\n        if not root:\\n            return 0\\n        q = [(root , str(root.val))]\\n        sum = 0\\n        while(q):\\n            node ,val = q.pop()\\n            if not node.left and not node.right:\\n                sum+=int(val)\\n            if node.left:\\n                q.append((node.left , val + str(node.left.val)))\\n            if node.right:\\n                q.append((node.right , val + str(node.right.val)))\\n        return sum\\n\\n\\n\\n\\n\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode] , val = 0) -> int:\\n        if not root:\\n            return 0\\n        val = 10 * val + root.val\\n        if not root.left and not root.right:\\n            return val\\n\\n        return self.sumNumbers(root.left , val) + self.sumNumbers(root.right , val)",
                "codeTag": "Java"
            },
            {
                "id": 3069161,
                "title": "simple-recursive-solution",
                "content": "# Complexity\\n- *Time complexity:*\\n**O(N)** #Where N is number of Nodes\\n\\n- *Space complexity:*\\n**O(h)** #where h is height of Tree\\n\\n# Code\\n```\\nclass Solution(object):\\n    def sumNumbers(self, root):\\n        self.ans = 0\\n        def dfs(root, sum_):\\n            if not root: return\\n            if not root.left and not root.right:\\n                self.ans += (sum_ * 10) + root.val\\n            dfs(root.left, (sum_ * 10) + root.val)\\n            dfs(root.right, (sum_ * 10) + root.val)\\n        dfs(root, 0)\\n        return self.ans\\n```\\nIf you have any *doubt* ask me in comment & **UpVote**, if you like it **:)**",
                "solutionTags": [
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def sumNumbers(self, root):\\n        self.ans = 0\\n        def dfs(root, sum_):\\n            if not root: return\\n            if not root.left and not root.right:\\n                self.ans += (sum_ * 10) + root.val\\n            dfs(root.left, (sum_ * 10) + root.val)\\n            dfs(root.right, (sum_ * 10) + root.val)\\n        dfs(root, 0)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2917583,
                "title": "simplest-c-code",
                "content": "# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        int x=countnodes(root,0);\\n        return x;\\n    }\\n    int countnodes(TreeNode*root,int sum){\\n        if(root==NULL)\\n        return 0;\\n        if(root->left==NULL&& root->right==NULL){ \\n        return sum*10+root->val;\\n        }\\n        else\\n         return countnodes(root->left,sum*10+root->val)+countnodes(root->right,sum*10+root->val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        int x=countnodes(root,0);\\n        return x;\\n    }\\n    int countnodes(TreeNode*root,int sum){\\n        if(root==NULL)\\n        return 0;\\n        if(root->left==NULL&& root->right==NULL){ \\n        return sum*10+root->val;\\n        }\\n        else\\n         return countnodes(root->left,sum*10+root->val)+countnodes(root->right,sum*10+root->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658995,
                "title": "easy-implementation-with-explanation-java",
                "content": "```\\n\\n\\nclass Solution {\\n\\tpublic int sumNumbers(TreeNode root) {\\n\\t\\treturn helper(root, 0);\\n\\t}\\n\\n\\tpublic static int helper(TreeNode root, int num) {\\n\\t\\tif (root == null)\\n\\t\\t\\treturn 0;\\n\\t\\tif (root.left == null && root.right == null) {\\n\\t\\t\\tnum = (num * 10) + root.val;        // num = (1*10) + 1; => num = 12;\\n\\t\\t\\treturn num;\\n\\t\\t}\\n\\t\\tnum = (num * 10) + root.val;  // num = (0 * 10)+ 1; => num = 1\\n\\t\\tint a = helper(root.left, num); // a = num (12)\\n\\t\\tint b = helper(root.right, num); // Similarly, b = num(13)\\n        return (a+b);\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nclass Solution {\\n\\tpublic int sumNumbers(TreeNode root) {\\n\\t\\treturn helper(root, 0);\\n\\t}\\n\\n\\tpublic static int helper(TreeNode root, int num) {\\n\\t\\tif (root == null)\\n\\t\\t\\treturn 0;\\n\\t\\tif (root.left == null && root.right == null) {\\n\\t\\t\\tnum = (num * 10) + root.val;        // num = (1*10) + 1; => num = 12;\\n\\t\\t\\treturn num;\\n\\t\\t}\\n\\t\\tnum = (num * 10) + root.val;  // num = (0 * 10)+ 1; => num = 1\\n\\t\\tint a = helper(root.left, num); // a = num (12)\\n\\t\\tint b = helper(root.right, num); // Similarly, b = num(13)\\n        return (a+b);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2657840,
                "title": "simple-o-n-recursive-solution-explained",
                "content": "**O(N) Recursive Solution**\\n```\\ndef sumNumbers(self, root: Optional[TreeNode]) -> int:\\n\\tself.ans = 0 #answer\\n\\n\\tdef dfs(node,amt): #depth-first search helper method\\n\\t\\tif node: #we only care if there is a node\\n\\t\\t\\tamt = amt*10+node.val #update the corresponding amount for this root-to-leaf path\\n\\t\\t\\tif not node.left and not node.right: #if it is a leaf\\n\\t\\t\\t\\tself.ans += amt #then add the path to our answer\\n\\t\\t\\telse: #if it isn\\'t a leaf\\n\\t\\t\\t\\tdfs(node.left,amt) #search to the left\\n\\t\\t\\t\\tdfs(node.right,amt) #search to the right\\n\\n\\tdfs(root,0) #perform dfs on the root\\n\\n\\treturn self.ans #return answer\\n```\\n\\nIn this solution, we search through the tree using depth-first search. We keep track of the ```node``` we are looking at and the value of the root-to-node path up to that point using ```amt```. We update ```amt``` by multiplying it by 10 and adding the value of the current node we are looking at. If the node is a leaf, then we add the value of its root-to-leaf path to our answer. Otherwise, we continue searching to the left and to the right to find more leaves.\\n\\n**Thanks for Reading!**\\nIf this post has been helpful, please consider upvoting! Also, if I made any mistakes or there are other optimizations, methods I didn\\'t consider, etc. please let me know!",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ndef sumNumbers(self, root: Optional[TreeNode]) -> int:\\n\\tself.ans = 0 #answer\\n\\n\\tdef dfs(node,amt): #depth-first search helper method\\n\\t\\tif node: #we only care if there is a node\\n\\t\\t\\tamt = amt*10+node.val #update the corresponding amount for this root-to-leaf path\\n\\t\\t\\tif not node.left and not node.right: #if it is a leaf\\n\\t\\t\\t\\tself.ans += amt #then add the path to our answer\\n\\t\\t\\telse: #if it isn\\'t a leaf\\n\\t\\t\\t\\tdfs(node.left,amt) #search to the left\\n\\t\\t\\t\\tdfs(node.right,amt) #search to the right\\n\\n\\tdfs(root,0) #perform dfs on the root\\n\\n\\treturn self.ans #return answer\\n```\n```node```\n```amt```\n```amt```",
                "codeTag": "Python3"
            },
            {
                "id": 2631147,
                "title": "c-recursion-without-storing-numbers",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void rec(int no,TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        no = no*10 + root->val;\\n        if(root->left==NULL&&root->right==NULL)\\n        {\\n            ans+=no;\\n            return;\\n        }\\n        rec(no,root->left);\\n        rec(no,root->right);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        ans = 0;\\n        rec(0,root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void rec(int no,TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        no = no*10 + root->val;\\n        if(root->left==NULL&&root->right==NULL)\\n        {\\n            ans+=no;\\n            return;\\n        }\\n        rec(no,root->left);\\n        rec(no,root->right);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        ans = 0;\\n        rec(0,root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440960,
                "title": "concept-of-path-to-leaf-node-c-easy-and-naive",
                "content": "Here, We have used the PATH TO LEAF NODE approach to solve it.\\nAt first we will find the path for each leaf node and store in any data structure ( vector )\\nAt last we will add the values of vector;\\n\\n///\\n\\nclass Solution {\\npublic:\\n\\n\\n    void helper(TreeNode* root, vector<int> &ans,string asf)\\n    {\\n        if(!root)\\n            return;\\n        \\n        if(!root->left && !root->right)\\n        {\\n            ans.push_back(stoi(asf)); // converting string path to integer number\\n            return;\\n        }\\n        \\n        if(root->left)\\n            helper(root->left,ans,asf + to_string(root->left->val));\\n        if(root->right)\\n            helper(root->right,ans,asf + to_string(root->right->val));\\n    }\\n    \\n    \\n    int sumNumbers(TreeNode* root) {\\n        vector<int> ans;\\n        helper(root,ans,to_string(root->val));\\n        \\n        int sum = 0;\\n        for(auto it : ans)\\n            sum += it;\\n        return sum;\\n    }\\n};\\n\\nHOPE YOU GET IT",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n\\n\\n    void helper(TreeNode* root, vector<int> &ans,string asf)\\n    {\\n        if(!root)\\n            return;\\n        \\n        if(!root->left && !root->right)\\n        {\\n            ans.push_back(stoi(asf)); // converting string path to integer number\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2108407,
                "title": "c-dfs-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,int& sum,int temp){\\n      if(!root)return;\\n      \\n      if(!root->left && !root->right){\\n        temp = 10* temp + root->val;\\n        sum+=temp;\\n        temp=0;\\n      }\\n      \\n      temp = 10* temp + root->val;\\n      \\n      solve(root->left,sum,temp);\\n      solve(root->right,sum,temp);\\n      \\n      return;\\n    }\\n    int sumNumbers(TreeNode* root) {\\n      int sum=0;\\n      int temp=0;\\n      solve(root,sum,temp);\\n      return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,int& sum,int temp){\\n      if(!root)return;\\n      \\n      if(!root->left && !root->right){\\n        temp = 10* temp + root->val;\\n        sum+=temp;\\n        temp=0;\\n      }\\n      \\n      temp = 10* temp + root->val;\\n      \\n      solve(root->left,sum,temp);\\n      solve(root->right,sum,temp);\\n      \\n      return;\\n    }\\n    int sumNumbers(TreeNode* root) {\\n      int sum=0;\\n      int temp=0;\\n      solve(root,sum,temp);\\n      return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557822,
                "title": "recursive-solution-simple-and-effective",
                "content": "`# All numbers are added to the array by recursion, and finally the array amount is returned (in the main function)`\\nimport numpy as np\\n\\n\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        res = 0\\n        array_number = np.array(self.rec(root, [], \"\"))\\n        for number in array_number:\\n            res += int(number)\\n        return res\\n\\n    def rec(self, root: Optional[TreeNode], string_number, my_string):\\n        if root is None:\\n            return []\\n        if root.left is None and root.right is None:\\n            return string_number + [my_string + str(root.val)]\\n        if root.left is None:\\n            my_string += str(root.val)\\n            return self.rec(root.right, string_number, my_string)\\n        if root.right is None:\\n            my_string += str(root.val)\\n            return self.rec(root.left, string_number, my_string)\\n        my_string += str(root.val)\\n        return self.rec(root.right, string_number, my_string) + self.rec(root.left, string_number, my_string)\\n\\n",
                "solutionTags": [],
                "code": "`# All numbers are added to the array by recursion, and finally the array amount is returned (in the main function)`\\nimport numpy as np\\n\\n\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        res = 0\\n        array_number = np.array(self.rec(root, [], \"\"))\\n        for number in array_number:\\n            res += int(number)\\n        return res\\n\\n    def rec(self, root: Optional[TreeNode], string_number, my_string):\\n        if root is None:\\n            return []\\n        if root.left is None and root.right is None:\\n            return string_number + [my_string + str(root.val)]\\n        if root.left is None:\\n            my_string += str(root.val)\\n            return self.rec(root.right, string_number, my_string)\\n        if root.right is None:\\n            my_string += str(root.val)\\n            return self.rec(root.left, string_number, my_string)\\n        my_string += str(root.val)\\n        return self.rec(root.right, string_number, my_string) + self.rec(root.left, string_number, my_string)\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1557815,
                "title": "c-simple-solution-recursive",
                "content": "```\\n\\nint f(struct TreeNode* r,int x){\\n    \\n    if(!r)\\n        return 0;\\n    \\n    if(!r->right&&!r->left)\\n        return (x*10)+r->val;\\n    \\n    return f(r->right,(x*10)+r->val)+f(r->left,(x*10)+r->val);\\n\\n}\\n\\nint sumNumbers(struct TreeNode* root){\\n    \\n    return f(root,0);\\n\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n\\nint f(struct TreeNode* r,int x){\\n    \\n    if(!r)\\n        return 0;\\n    \\n    if(!r->right&&!r->left)\\n        return (x*10)+r->val;\\n    \\n    return f(r->right,(x*10)+r->val)+f(r->left,(x*10)+r->val);\\n\\n}\\n\\nint sumNumbers(struct TreeNode* root){\\n    \\n    return f(root,0);\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1557659,
                "title": "c-simple-depth-first-search-solution-0-ms",
                "content": "Algorithm:\\n\\t1. From a root, we add the root->val to the end of a string, which records the numbers we have gone from.\\n\\t2. We repeat step 1. on the left child of the root then the right one. (note: you do not have to go to the left before the right, that is a personal preference. You can go to the right before the left.)\\n\\t3. If the root has no children, we stop and add the number we got to a total sum.\\n\\nWikipedia:\\n\"Depth-first search (DFS) is **an algorithm for traversing or searching tree or graph data structures.** The algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a graph) and explores as far as possible along each branch before backtracking.\"\\n```\\n/*\\nSecond example:\\n\\t\\t\\t\\t\\t\\t 4\\n\\t\\t\\t\\t\\t\\t/ \\\\\\n\\t\\t\\t\\t\\t  9    0\\n\\t\\t\\t\\t\\t/  \\\\\\n\\t\\t\\t\\t   5    1\\n\\nOur code will take the path:\\n\\t4 --> 9 --> 5\\n\\t\\t\\t\\t\\t\\tno non-null children so stops\\n\\t\\t\\t\\t\\t\\tadds 495 to the sum\\n\\t\\t\\t --> 1\\n\\t\\t\\t\\t\\t\\tno non-null children so stops\\n\\t\\t\\t\\t\\t\\tadds 491 to the sum\\n\\t  --> 0\\n\\t\\t\\t no non-null children so stops\\n\\t\\t\\t adds 40 to the sum\\n*/\\n```\\n\\nImplementation\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        // LeetCode annoying and likes to add these testcases\\n        if(root == nullptr){\\n            return 0;\\n        }\\n        \\n        // dfs the root and an empty string\\n        dfs(root, \"\");\\n        \\n        return sum;\\n    }\\n    \\nprivate:\\n    int sum = 0;\\n    \\n    void dfs(TreeNode*& root, string s){\\n        // add root->val to the end of the string\\n        // + \\'0\\', this turns a digit to its ASCII value\\n        s += root->val + \\'0\\';\\n        \\n        if(root->left == nullptr && root->right == nullptr){\\n            // convert a string to integer\\n            sum += stoi(s);\\n            \\n            // this node has no children, so we stop\\n            return;\\n        }\\n        \\n        if(root->left != nullptr){\\n            dfs(root->left,s);\\n        }\\n        \\n        if(root->right != nullptr){\\n            dfs(root->right,s);\\n        }\\n    }\\n};\\n```\\nHope you liked this solution. Please like :))",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n/*\\nSecond example:\\n\\t\\t\\t\\t\\t\\t 4\\n\\t\\t\\t\\t\\t\\t/ \\\\\\n\\t\\t\\t\\t\\t  9    0\\n\\t\\t\\t\\t\\t/  \\\\\\n\\t\\t\\t\\t   5    1\\n\\nOur code will take the path:\\n\\t4 --> 9 --> 5\\n\\t\\t\\t\\t\\t\\tno non-null children so stops\\n\\t\\t\\t\\t\\t\\tadds 495 to the sum\\n\\t\\t\\t --> 1\\n\\t\\t\\t\\t\\t\\tno non-null children so stops\\n\\t\\t\\t\\t\\t\\tadds 491 to the sum\\n\\t  --> 0\\n\\t\\t\\t no non-null children so stops\\n\\t\\t\\t adds 40 to the sum\\n*/\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        // LeetCode annoying and likes to add these testcases\\n        if(root == nullptr){\\n            return 0;\\n        }\\n        \\n        // dfs the root and an empty string\\n        dfs(root, \"\");\\n        \\n        return sum;\\n    }\\n    \\nprivate:\\n    int sum = 0;\\n    \\n    void dfs(TreeNode*& root, string s){\\n        // add root->val to the end of the string\\n        // + \\'0\\', this turns a digit to its ASCII value\\n        s += root->val + \\'0\\';\\n        \\n        if(root->left == nullptr && root->right == nullptr){\\n            // convert a string to integer\\n            sum += stoi(s);\\n            \\n            // this node has no children, so we stop\\n            return;\\n        }\\n        \\n        if(root->left != nullptr){\\n            dfs(root->left,s);\\n        }\\n        \\n        if(root->right != nullptr){\\n            dfs(root->right,s);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557547,
                "title": "javascript-100-super-simple-multiple-solutions",
                "content": "![image](https://assets.leetcode.com/users/images/1e97f12a-6a43-475e-9da0-8a75bc47f4b6_1636010606.2161295.png)\\n\\n\\n\\nNov 3rd LC Challenge.\\n\\nEDIT:  (Upon further testing and working with the problem, I have decided I like this solution best - The top one.  \\n\\nImportant note - Top solution below uses strings as an argument for curPath.  In that version, we just add root.val and then send the variable away in the recursive calls.  After that, we add what is returned to the sum, then return that sum.  This works great because strings in JS are assign-by-value.  If we send one string to a recursive call, it only effects that call and lower recursive calls - not higher ones.  Alternatively, below that solution we have curPath stored as an array.  In those functions, you\\'ll notice a .push() at the very start, and then a .pop() after the recursive calls.  This is because arrays are assign-by-reference.  When you pass an array (or anything else assign-by-reference), it effects all recursive calls in which it is involved - All can change it on their recursive levels, and it will be reflected in higher recursive levels.  Hence, we need the .pop() as clean up after we have explored that node.  Both assign-by-value and assign-by-reference have their advantages and disadvantages in recursive functions.  You\\'ll also notice we use sum = [0] in some of the other functions.  This is because arrays are pass by reference.  Hence, in lower recursive calls, we can do sum[0] += curPath.join(\\'\\') - 0, and it changes the value with the sum array on All recursive levels and we can just return it at the top level.  In the non-assign-by-reference code examples, you\\'ll notice we have to do sum += \\'whatever we return from recursive call\\' because that call can\\'t change the sum itself.  Hence, if you change the code to sum = 0 within the arguments, and change the logic within the function to match an integer, you\\'ll find it no longer works - This is because integers are assign-by-value.  If you knew all of this already, I apologize for the tangeant.  It\\'s a subject that I struggled with in my coding for a while, so I wanted to add a short aside to address it and maybe help others.\\n\\nTL:DR; You have to code a bit differently in recursive calls when using assign-by-reference vs assign-by-value arguments.  In the below assign-by-reference versions - We add to the variable (curPath), run our recursive calls with it as an argument, and then we remove what we added afterwards (I.E. - Recursion has reached the basecase and popped back up.  In the case of the example in the description - Initial function call pushes 1 to curPath, recursion runs on root.left.  We push 2 to curPath.  We have reached the base case since 2 has no .left or .right.  12 is added to the sum ([1,2].join(\\'\\') - 0 OR +[1,2].join(\\'\\') - both are ways to coerce strings to numbers where possible in JS).  The two is popped off.  We return to the initial function call level.  Function again called on root.right.  On this level, our curPath is again back to [1].  3 is pushed to curPath.  Base case is reached.  [1,3] joined to form 13 and added to sum.  On initial level, we pop the one from curPath.  curPath = [] at the end.  But sum has been changed by lower recursive calls.  We return sum[0].)  In the assign-by-value versions, we add to the variable, send it away in the recursive calls, Do Something With What Is Returned (Add to a total, hashmap, etc), and return the effected variable.)\\n\\n\\ncurPath and sum both assign-by-value:\\n```\\nconst sumNumbers = (root, curPath = \\'\\', sum = 0) => {\\n  curPath += root.val;\\n  if (!root.left && !root.right) sum += +curPath;\\n  root.left && (sum += sumNumbers(root.left, curPath));\\n  root.right && (sum += sumNumbers(root.right, curPath));\\n  return sum;\\n};\\n```\\n\\ncurPath and sum both assign-by-reference:\\n```\\nconst sumNumbers = (root, curPath = [], sum = [0]) => {\\n  curPath.push(root.val);\\n  if (!root.left && !root.right) sum[0] += curPath.join(\\'\\') - 0;\\n  root.left && sumNumbers(root.left, curPath, sum);\\n  root.right && sumNumbers(root.right, curPath, sum);\\n  curPath.pop();\\n  return sum[0];\\n};\\n```\\n\\n\\nAlternate version with helper function instead of all-recursion (This one\\'s likely easier for most to write on the spot in an interview.  Tracking variables through assign-by-reference data structures is sometimes tough without practice.  This is the \\'play it safe\\' and get it right the first time version.  This version is easiest imo because within the recursive function, we only really have to worry about reaching our base case and then changing sum accordingly - We don\\'t have to worry about what we return from the recursive function at all.  Our function itself changes the sum in the parent scope for us and we don\\'t have to worry about passing sum down, what happens on each level, etc...  Only how sum changes when base case is reached.):\\n\\nsum within initial function scope, traverse has access to this function scope and can change it accordingly.  This lets us use sum as an integer (assign-by-value), but still only change it when the base case is reached.\\n```\\nconst sumNumbers = root => {\\n  let sum = 0;\\n  const traverse = (node, curPath = []) => {\\n    curPath.push(node.val);\\n    if (!node.left && !node.right) sum += curPath.join(\\'\\') - 0;\\n    node.left && traverse(node.left, curPath);\\n    node.right && traverse(node.right, curPath);\\n    curPath.pop();\\n  }\\n  traverse(root);\\n  return sum;\\n}\\n```\\n\\n\\nFinal version.  This one works the same as the second, but does not use array to track total using assign-by-reference.\\n\\nHybrid: curPath is assign-by-reference, sum is assign-by-value:\\n```\\nconst sumNumbers = (root, curPath = [], sum = 0) => {\\n  curPath.push(root.val);\\n  if (!root.left && !root.right) sum += curPath.join(\\'\\') - 0;\\n  root.left && (sum += sumNumbers(root.left, curPath));\\n  root.right && (sum += sumNumbers(root.right, curPath));\\n  curPath.pop();\\n  return sum;\\n};\\n```\\n\\n\\nI lied!  Last version showing objects are assign-by-reference as well.  We track curPath as a string (We add on every level, but don\\'t worry about clean-up because adding on a lower level doesn\\'t effect higher levels.)  We track sum as an object.  I.E. - We can change the value within the object at All recursive levels when base case is reached and the top level will be reflected appropriately - Only reaching our base case changes the total that is returned in assign-by-reference versions.  In assign-by-value, what is returned from function changes our total, and is then returned.).\\n\\nHybrid: curPath is assign-by-value and sum is assign-by-reference.  This one is particularly cool because we can add to curPath on each level without having to worry about clean up, we can also effect the answer only when the base case is reached, and we also don\\'t have to worry about what we return from any call other than the initial one.  This combination of factors leads me to use assign-by-value and assign-by-reference in this fashion as often as possible, because I find it the easiest to code personally.  Using an object here is somewhat pointless though. lol... I just did it to show it\\'s also assign-by-reference.  Normally I\\'d use an array, both work though. (arrays are just objects in js anyway) \\n```\\nconst sumNumbers = (root, curPath = \\'\\', sum = { answer: 0 }) => {\\n  curPath += root.val;\\n  if (!root.left && !root.right) return sum.answer += +curPath;\\n  root.left && sumNumbers(root.left, curPath, sum);\\n  root.right && sumNumbers(root.right, curPath, sum);\\n  return sum.answer;\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst sumNumbers = (root, curPath = \\'\\', sum = 0) => {\\n  curPath += root.val;\\n  if (!root.left && !root.right) sum += +curPath;\\n  root.left && (sum += sumNumbers(root.left, curPath));\\n  root.right && (sum += sumNumbers(root.right, curPath));\\n  return sum;\\n};\\n```\n```\\nconst sumNumbers = (root, curPath = [], sum = [0]) => {\\n  curPath.push(root.val);\\n  if (!root.left && !root.right) sum[0] += curPath.join(\\'\\') - 0;\\n  root.left && sumNumbers(root.left, curPath, sum);\\n  root.right && sumNumbers(root.right, curPath, sum);\\n  curPath.pop();\\n  return sum[0];\\n};\\n```\n```\\nconst sumNumbers = root => {\\n  let sum = 0;\\n  const traverse = (node, curPath = []) => {\\n    curPath.push(node.val);\\n    if (!node.left && !node.right) sum += curPath.join(\\'\\') - 0;\\n    node.left && traverse(node.left, curPath);\\n    node.right && traverse(node.right, curPath);\\n    curPath.pop();\\n  }\\n  traverse(root);\\n  return sum;\\n}\\n```\n```\\nconst sumNumbers = (root, curPath = [], sum = 0) => {\\n  curPath.push(root.val);\\n  if (!root.left && !root.right) sum += curPath.join(\\'\\') - 0;\\n  root.left && (sum += sumNumbers(root.left, curPath));\\n  root.right && (sum += sumNumbers(root.right, curPath));\\n  curPath.pop();\\n  return sum;\\n};\\n```\n```\\nconst sumNumbers = (root, curPath = \\'\\', sum = { answer: 0 }) => {\\n  curPath += root.val;\\n  if (!root.left && !root.right) return sum.answer += +curPath;\\n  root.left && sumNumbers(root.left, curPath, sum);\\n  root.right && sumNumbers(root.right, curPath, sum);\\n  return sum.answer;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1556855,
                "title": "c-0ms-optimal-solution-using-simple-recursion",
                "content": "\\n**Optimal Solution** *(Runtime : 0ms and Memory : 91.89%)*\\n```\\nclass Solution {\\npublic:\\n    int res=0;//variable to have sum\\n    \\n    int sumNumbers(TreeNode* root) {\\n        \\n        sum(root,0); //calling sum with initial num as 0\\n        \\n        return res; // return result;\\n    }\\n    \\n    void sum(TreeNode*root, int num){\\n        \\n        if(!root)return;\\n        \\n        int temp = num*10+root->val; //when we tranveral down a tree, num has to mul by 10 and current node val becomes its ones digit position \\n               \\n        if(!root->left&&!root->right){//leaf root -> add temp value to res\\n            \\n            sum += temp;\\n            return;\\n        }\\n        //recursive for its children nodes\\n        sum(root->left,temp);\\n        sum(root->right,temp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int res=0;//variable to have sum\\n    \\n    int sumNumbers(TreeNode* root) {\\n        \\n        sum(root,0); //calling sum with initial num as 0\\n        \\n        return res; // return result;\\n    }\\n    \\n    void sum(TreeNode*root, int num){\\n        \\n        if(!root)return;\\n        \\n        int temp = num*10+root->val; //when we tranveral down a tree, num has to mul by 10 and current node val becomes its ones digit position \\n               \\n        if(!root->left&&!root->right){//leaf root -> add temp value to res\\n            \\n            sum += temp;\\n            return;\\n        }\\n        //recursive for its children nodes\\n        sum(root->left,temp);\\n        sum(root->right,temp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1556202,
                "title": "python-96-99-faster-24-ms-with-a-diagram",
                "content": "```\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        if root is None: return 0\\n        \\n        def rec(node=root, prev=0):\\n            if node.left is None and node.right is None:\\n                return prev + node.val            \\n            \\n            prev = (prev + node.val)*10\\n            \\n            left = right = 0\\n            if node.left:\\n                left = rec(node.left, prev)\\n            if node.right:\\n                right = rec(node.right, prev)\\n            \\n            return left + right\\n        \\n        return rec()\\n```\\n\\n![image](https://assets.leetcode.com/users/images/ebf72c68-d3e6-460a-acfe-5a817d2be31b_1635912885.932716.png)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        if root is None: return 0\\n        \\n        def rec(node=root, prev=0):\\n            if node.left is None and node.right is None:\\n                return prev + node.val            \\n            \\n            prev = (prev + node.val)*10\\n            \\n            left = right = 0\\n            if node.left:\\n                left = rec(node.left, prev)\\n            if node.right:\\n                right = rec(node.right, prev)\\n            \\n            return left + right\\n        \\n        return rec()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1555994,
                "title": "idea-explained-faster-than-100-simple-clean-c-solution",
                "content": "**Intuition:**\\n\\n* Idea is keep adding digits to our path value. \\n* And when we reach the leaf node, add this path value to overall `pathSum`\\n\\n\\t\\tEx:          4 \\n                   /   \\\\   \\n\\t\\t\\t\\t    9     0 \\n\\t\\t\\t\\t  /   \\\\\\n\\t\\t\\t\\t 5     1\\n\\t\\t\\t\\t \\n\\t\\t\\tSo, here we start from root -> 4. We recursively move down exploring all possible paths.\\n\\t\\t\\tLet\\'s see how each paths will look , initially pathSum = 0: \\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\ta. 4 -> \\n\\t\\t\\t\\t\\t 9 -> \\n\\t\\t\\t\\t\\t\\t  5 -| : Path Value = 495 , Path Sum = 495\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t 9 -> \\n\\t\\t\\t\\t\\t\\t  1 -| : Path Value = 491 , Path Sum = 495 + 491 = 986\\n\\t\\t\\t\\n\\t\\t\\tb. 4 -> \\n\\t\\t\\t\\t\\t 0 -| : Path Value = 40 , Path Sum = 986 + 50 = 1026\\n# Code: \\n```\\nclass Solution {\\npublic:\\n    int pathSum = 0;\\n    \\n    void solve(TreeNode* root, int val)\\n    {\\n        if(!root->left && !root->right)\\n        {\\n            pathSum += (10*val + root->val);\\n            return;\\n        }\\n        \\n        val = (10*val + root->val);\\n        \\n        if(root->left) solve(root->left, val);\\n        if(root->right) solve(root->right, val);\\n    }\\n    \\n    int sumNumbers(TreeNode* root) {\\n        \\n        solve(root, 0);\\n        return pathSum;\\n    }\\n};\\n```\\n\\n**Complexity Analysis :** \\n\\n* Time : `O(n)`, we visit all nodes in preorder traversal.\\n* Space : `O(1)` and if we take recursion call stack into account, then `O(logn)`.\\n\\n\\n***If you find this solution helpful, do give it a like :)***",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pathSum = 0;\\n    \\n    void solve(TreeNode* root, int val)\\n    {\\n        if(!root->left && !root->right)\\n        {\\n            pathSum += (10*val + root->val);\\n            return;\\n        }\\n        \\n        val = (10*val + root->val);\\n        \\n        if(root->left) solve(root->left, val);\\n        if(root->right) solve(root->right, val);\\n    }\\n    \\n    int sumNumbers(TreeNode* root) {\\n        \\n        solve(root, 0);\\n        return pathSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1393923,
                "title": "easy-to-understand-beginners",
                "content": "```\\nclass Solution {\\npublic:\\n    void treeHelper(TreeNode*root, int &sum, int num)\\n    {\\n        if(root==NULL)\\n            return;\\n        num=num*10+root->val;\\n        if(root->left==0 && root->right==0)\\n            sum+=num;\\n        treeHelper(root->left,sum,num);\\n        treeHelper(root->right,sum,num);\\n        \\n    }\\n    int sumNumbers(TreeNode* root) \\n    {\\n        int sum=0,num=0;\\n        treeHelper(root, sum,num);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void treeHelper(TreeNode*root, int &sum, int num)\\n    {\\n        if(root==NULL)\\n            return;\\n        num=num*10+root->val;\\n        if(root->left==0 && root->right==0)\\n            sum+=num;\\n        treeHelper(root->left,sum,num);\\n        treeHelper(root->right,sum,num);\\n        \\n    }\\n    int sumNumbers(TreeNode* root) \\n    {\\n        int sum=0,num=0;\\n        treeHelper(root, sum,num);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1301027,
                "title": "clean-recursive-solution-0ms-java",
                "content": "```\\nclass Solution {\\n    \\n    int number = 0;\\n    \\n    public int sumNumbers(TreeNode root) {\\n        \\n        number = number*10 + root.val;\\n        \\n        int ans = 0;\\n        \\n        if (root.left != null)\\n            ans += sumNumbers(root.left);\\n        \\n        if (root.right != null)\\n            ans += sumNumbers(root.right);\\n        \\n        if (root.left == null && root.right == null)\\n            ans = number;\\n        \\n        number /= 10;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int number = 0;\\n    \\n    public int sumNumbers(TreeNode root) {\\n        \\n        number = number*10 + root.val;\\n        \\n        int ans = 0;\\n        \\n        if (root.left != null)\\n            ans += sumNumbers(root.left);\\n        \\n        if (root.right != null)\\n            ans += sumNumbers(root.right);\\n        \\n        if (root.left == null && root.right == null)\\n            ans = number;\\n        \\n        number /= 10;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198403,
                "title": "c-dfs-pre-order-stack-iterative-beats-100",
                "content": "Feel Free to ask if you have any question and if you liked it click on **UPVOTE** icon.\\n```\\n int sum = 0;\\n    void calculateScore (stack<int> s){ // calculating the score of the values in the stack\\n        int i=0;\\n       while(!s.empty()){\\n           sum = sum + s.top() * pow(10, i);\\n            s.pop(); i++;\\n        }\\n    }\\n    int traverseTree(TreeNode* root , stack<int> q){\\n        if(root == NULL) return 0;\\n        q.push(root -> val);\\n        if(!root -> left  && !root -> right){\\n            calculateScore(q);\\n            q.pop();\\n        }\\n        if(root -> left != NULL)\\n            traverseTree(root -> left , q);\\n        if(root -> right != NULL)\\n            traverseTree(root -> right , q);\\n        q.pop();\\n        return sum;\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        stack<int> q;\\n        if(root == NULL) return 0;\\n        traverseTree(root , q);\\n        return sum;\\n    }",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Depth-First Search"
                ],
                "code": "Feel Free to ask if you have any question and if you liked it click on **UPVOTE** icon.\\n```\\n int sum = 0;\\n    void calculateScore (stack<int> s){ // calculating the score of the values in the stack\\n        int i=0;\\n       while(!s.empty()){\\n           sum = sum + s.top() * pow(10, i);\\n            s.pop(); i++;\\n        }\\n    }\\n    int traverseTree(TreeNode* root , stack<int> q){\\n        if(root == NULL) return 0;\\n        q.push(root -> val);\\n        if(!root -> left  && !root -> right){\\n            calculateScore(q);\\n            q.pop();\\n        }\\n        if(root -> left != NULL)\\n            traverseTree(root -> left , q);\\n        if(root -> right != NULL)\\n            traverseTree(root -> right , q);\\n        q.pop();\\n        return sum;\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        stack<int> q;\\n        if(root == NULL) return 0;\\n        traverseTree(root , q);\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1122658,
                "title": "100-faster-short-n-easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root,int mysum=0) {\\n        mysum = mysum*10 + root->val;\\n        if(!root->left && !root->right) return mysum;\\n        if(!root->left) return sumNumbers(root->right,mysum);\\n        if(!root->right) return sumNumbers(root->left,mysum);\\n        return sumNumbers(root->left, mysum) + sumNumbers(root->right,mysum);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root,int mysum=0) {\\n        mysum = mysum*10 + root->val;\\n        if(!root->left && !root->right) return mysum;\\n        if(!root->left) return sumNumbers(root->right,mysum);\\n        if(!root->right) return sumNumbers(root->left,mysum);\\n        return sumNumbers(root->left, mysum) + sumNumbers(root->right,mysum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984555,
                "title": "go-solution",
                "content": "```go\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc sumNumbers(root *TreeNode) int {\\n    sum := 0\\n    \\n    var s func(*TreeNode, int)\\n    \\n    s = func(root *TreeNode, total int) {\\n        if root == nil {return}\\n        \\n        if root.Left == nil && root.Right == nil {\\n            sum += (total * 10) + root.Val       \\n            return\\n        }\\n        \\n        total = ((total * 10) + root.Val)\\n        \\n        s(root.Left, total)\\n        s(root.Right, total)        \\n    }\\n    \\n    s(root, 0)\\n    \\n    return sum\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc sumNumbers(root *TreeNode) int {\\n    sum := 0\\n    \\n    var s func(*TreeNode, int)\\n    \\n    s = func(root *TreeNode, total int) {\\n        if root == nil {return}\\n        \\n        if root.Left == nil && root.Right == nil {\\n            sum += (total * 10) + root.Val       \\n            return\\n        }\\n        \\n        total = ((total * 10) + root.Val)\\n        \\n        s(root.Left, total)\\n        s(root.Right, total)        \\n    }\\n    \\n    s(root, 0)\\n    \\n    return sum\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 703693,
                "title": "python3-iterative-recursive-dfs",
                "content": "\\n\\n```\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        ans = 0 \\n        stack = [(root, 0)]\\n        while stack: \\n            node, val = stack.pop()\\n            val = 10*val + node.val \\n            if not node.left and not node.right: ans += val \\n            if node.left: stack.append((node.left, val))\\n            if node.right: stack.append((node.right, val))\\n        return ans \\n```\\n\\n```\\nclass Solution:\\n    def sumNumbers(self, root: TreeNode) -> int:\\n        \\n        def fn(node, val):\\n            \"\"\"Return sum of node-to-leaf numbers\"\"\"\\n            if not node: return 0\\n            val = 10*val + node.val\\n            if not node.left and not node.right: return val \\n            return fn(node.left, val) + fn(node.right, val)\\n            \\n        return fn(root, 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        ans = 0 \\n        stack = [(root, 0)]\\n        while stack: \\n            node, val = stack.pop()\\n            val = 10*val + node.val \\n            if not node.left and not node.right: ans += val \\n            if node.left: stack.append((node.left, val))\\n            if node.right: stack.append((node.right, val))\\n        return ans \\n```\n```\\nclass Solution:\\n    def sumNumbers(self, root: TreeNode) -> int:\\n        \\n        def fn(node, val):\\n            \"\"\"Return sum of node-to-leaf numbers\"\"\"\\n            if not node: return 0\\n            val = 10*val + node.val\\n            if not node.left and not node.right: return val \\n            return fn(node.left, val) + fn(node.right, val)\\n            \\n        return fn(root, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589655,
                "title": "0ms-morris-preorder-traversal-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        int root2leaf = 0, number = 0, steps=0;\\n        TreeNode predecessor;\\n        if(root == null){\\n            return 0;\\n        }\\n        while(root!=null){\\n            if(root.left!=null){\\n                predecessor = root.left;\\n                steps = 1;\\n                while(predecessor.right != null && predecessor.right != root){\\n                    predecessor = predecessor.right;\\n                    steps++;\\n                }\\n                if(predecessor.right == null){\\n                    predecessor.right = root;\\n                    //explore left subtree\\n                    number = number*10 + root.val;\\n                    root =root.left;\\n                }else{\\n                    predecessor.right = null;\\n                    if (predecessor.left == null) {\\n                        root2leaf += number;\\n                    }\\n                    for(int i = 0; i < steps; ++i) {\\n                        number /= 10;\\n                    }\\n                    root = root.right;\\n                }\\n                \\n            }else{\\n                //no left child\\n                number = number*10 + root.val;\\n                if(root.right == null){\\n                    root2leaf += number;\\n                }\\n                root = root.right;\\n            }\\n        }\\n        \\n        return root2leaf;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        int root2leaf = 0, number = 0, steps=0;\\n        TreeNode predecessor;\\n        if(root == null){\\n            return 0;\\n        }\\n        while(root!=null){\\n            if(root.left!=null){\\n                predecessor = root.left;\\n                steps = 1;\\n                while(predecessor.right != null && predecessor.right != root){\\n                    predecessor = predecessor.right;\\n                    steps++;\\n                }\\n                if(predecessor.right == null){\\n                    predecessor.right = root;\\n                    //explore left subtree\\n                    number = number*10 + root.val;\\n                    root =root.left;\\n                }else{\\n                    predecessor.right = null;\\n                    if (predecessor.left == null) {\\n                        root2leaf += number;\\n                    }\\n                    for(int i = 0; i < steps; ++i) {\\n                        number /= 10;\\n                    }\\n                    root = root.right;\\n                }\\n                \\n            }else{\\n                //no left child\\n                number = number*10 + root.val;\\n                if(root.right == null){\\n                    root2leaf += number;\\n                }\\n                root = root.right;\\n            }\\n        }\\n        \\n        return root2leaf;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 313638,
                "title": "smple-java-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int sum2=0;\\n    public int sumNumbers(TreeNode root) {\\n        mySolve(root,0);\\n        return sum2;\\n    }\\n    public void mySolve(TreeNode root,int sum )\\n    {\\n        if(root == null) return;\\n        if(root.left == null && root.right==null) {\\n            sum2+=sum*10+root.val;\\n            return;\\n        }\\n        mySolve(root.left,sum*10+root.val);\\n        mySolve(root.right,sum*10+root.val);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int sum2=0;\\n    public int sumNumbers(TreeNode root) {\\n        mySolve(root,0);\\n        return sum2;\\n    }\\n    public void mySolve(TreeNode root,int sum )\\n    {\\n        if(root == null) return;\\n        if(root.left == null && root.right==null) {\\n            sum2+=sum*10+root.val;\\n            return;\\n        }\\n        mySolve(root.left,sum*10+root.val);\\n        mySolve(root.right,sum*10+root.val);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 287264,
                "title": "c-dfs",
                "content": "```\\npublic class Solution {\\n    public int SumNumbers(TreeNode root) {\\n        return DFS(root, 0);\\n    }\\n\\n    private int DFS(TreeNode root, int num) {\\n        if (root == null) return 0;\\n\\n        var curResult = num * 10 + root.val;\\n        if (root.left == null && root.right == null) return curResult;\\n\\n        return DFS(root.left, curResult) + DFS(root.right, curResult);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int SumNumbers(TreeNode root) {\\n        return DFS(root, 0);\\n    }\\n\\n    private int DFS(TreeNode root, int num) {\\n        if (root == null) return 0;\\n\\n        var curResult = num * 10 + root.val;\\n        if (root.left == null && root.right == null) return curResult;\\n\\n        return DFS(root.left, curResult) + DFS(root.right, curResult);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41484,
                "title": "even-neater-and-easy-to-understand-java-solution",
                "content": "    int totalSum = 0;\\n    \\n    public int sumNumbers(TreeNode root) {\\n        sum(root, 0);\\n        return totalSum;\\n    }\\n    \\n    public void sum(TreeNode root, int sum) {\\n        if (root == null) return;\\n        \\n        sum = sum * 10 + root.val;\\n        \\n        if (root.left == null && root.right == null) {\\n            totalSum += sum;\\n            return;\\n        }\\n        \\n        sum(root.left, sum);\\n        sum(root.right, sum);\\n    }",
                "solutionTags": [],
                "code": "    int totalSum = 0;\\n    \\n    public int sumNumbers(TreeNode root) {\\n        sum(root, 0);\\n        return totalSum;\\n    }\\n    \\n    public void sum(TreeNode root, int sum) {\\n        if (root == null) return;\\n        \\n        sum = sum * 10 + root.val;\\n        \\n        if (root.left == null && root.right == null) {\\n            totalSum += sum;\\n            return;\\n        }\\n        \\n        sum(root.left, sum);\\n        sum(root.right, sum);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 41521,
                "title": "short-python-solution",
                "content": "    class Solution(object):\\n    def sumNumbers(self, root):\\n        if not root: return 0\\n        self.res=0\\n        self.cal(root, '')\\n        return self.res\\n    \\n    def cal(self, root, temp):\\n        if not root: return\\n        if not root.left and not root.right: self.res+=int(temp+str(root.val))\\n        for node in [root.left, root.right]: self.cal(node, temp+str(root.val))",
                "solutionTags": [],
                "code": "    class Solution(object):\\n    def sumNumbers(self, root):\\n        if not root: return 0\\n        self.res=0\\n        self.cal(root, '')\\n        return self.res\\n    \\n    def cal(self, root, temp):\\n        if not root: return\\n        if not root.left and not root.right: self.res+=int(temp+str(root.val))\\n        for node in [root.left, root.right]: self.cal(node, temp+str(root.val))",
                "codeTag": "Java"
            },
            {
                "id": 41522,
                "title": "solution-with-iterative-preorder-traversal",
                "content": "During a previous interview, they don\\'t like my answer to a tree problem with a recursive solution. Stack overflow is a common problem in the real work environment. So I think we should prefer iterative solution to recursive ones. Or we should at least practice both. \\n\\n    public class Solution {        \\n        public int sumNumbers(TreeNode root) {\\n            int sum = 0, val = 0;\\n            if(root == null) {\\n                return 0;\\n            }\\n            \\n            Stack<TreeNode> stack = new Stack<TreeNode>();\\n            Stack<Integer> valStack = new Stack<Integer>();\\n            stack.push(root);\\n            valStack.push(root.val);\\n            while(!stack.isEmpty()){\\n                TreeNode node = stack.pop();\\n                val = valStack.pop();\\n                if(node.right == null && node.left == null){\\n                    sum += val;\\n                }\\n                if(node.right != null){\\n                    stack.push(node.right);\\n                    valStack.push(val*10+node.right.val);\\n                }\\n                if(node.left != null){\\n                    stack.push(node.left);\\n                    valStack.push(val*10+node.left.val);\\n                }\\n            }\\n            \\n            return sum;\\n        }\\n    }",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "class Solution {        \\n        public int sumNumbers(TreeNode root) {\\n            int sum = 0, val = 0;\\n            if(root == null) {\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 41552,
                "title": "my-c-solution-2-ms",
                "content": "    int dfs(struct TreeNode* root, int num) {\\n        if (root == NULL) return 0; // if only one child node is NULL, do not count it\\n        if (root->left == NULL && root->right == NULL) return num * 10 + root->val; // if the node is leaf node, return the sum value\\n        return dfs(root->left, num * 10 + root->val) + dfs(root->right, num * 10 + root->val);\\n    }\\n    \\n    int sumNumbers(struct TreeNode* root) {\\n        return dfs(root, 0);\\n    }",
                "solutionTags": [],
                "code": "    int dfs(struct TreeNode* root, int num) {\\n        if (root == NULL) return 0; // if only one child node is NULL, do not count it\\n        if (root->left == NULL && root->right == NULL) return num * 10 + root->val; // if the node is leaf node, return the sum value\\n        return dfs(root->left, num * 10 + root->val) + dfs(root->right, num * 10 + root->val);\\n    }\\n    \\n    int sumNumbers(struct TreeNode* root) {\\n        return dfs(root, 0);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 41565,
                "title": "share-my-neat-java-solution",
                "content": "    public class Solution {\\n        private int sum;\\n        \\n        public Solution() {\\n            sum = 0;\\n        }\\n        public void sumNumbersHelper(TreeNode root, int current) {\\n            if (root == null) return;\\n            current = current * 10 + root.val;\\n            if (root.left == null && root.right == null) {\\n                sum += current;\\n            } else {\\n                sumNumbersHelper(root.left, current);\\n                sumNumbersHelper(root.right, current);\\n            }\\n        }\\n        \\n        public int sumNumbers(TreeNode root) {\\n            if (root == null) return sum;\\n            int current = 0;\\n            sumNumbersHelper(root, current);\\n            return sum;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        private int sum;\\n        \\n        public Solution() {\\n            sum = 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3908640,
                "title": "easy-to-understrand-java-solution-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    int sum = 0; // Initialize a global variable to store the sum of root-to-leaf numbers.\\n    \\n    public int sumNumbers(TreeNode root) {\\n        number(root, 0); // Call the helper function with the root and initial sum as 0.\\n        return sum; // Return the calculated sum.\\n    }\\n    \\n    public void number(TreeNode root, int data) {\\n        if (root == null) {\\n            return; // Base case: if the node is null, return.\\n        }\\n        data = data * 10 + root.val; // Calculate the new value by appending the current node\\'s value.\\n        \\n        if (root.left == null && root.right == null) {\\n            sum += data; // If it\\'s a leaf node, add the value to the sum.\\n        }\\n        \\n        number(root.left, data); // Recurse on the left subtree with the updated value.\\n        number(root.right, data); // Recurse on the right subtree with the updated value.\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int sum = 0; // Initialize a global variable to store the sum of root-to-leaf numbers.\\n    \\n    public int sumNumbers(TreeNode root) {\\n        number(root, 0); // Call the helper function with the root and initial sum as 0.\\n        return sum; // Return the calculated sum.\\n    }\\n    \\n    public void number(TreeNode root, int data) {\\n        if (root == null) {\\n            return; // Base case: if the node is null, return.\\n        }\\n        data = data * 10 + root.val; // Calculate the new value by appending the current node\\'s value.\\n        \\n        if (root.left == null && root.right == null) {\\n            sum += data; // If it\\'s a leaf node, add the value to the sum.\\n        }\\n        \\n        number(root.left, data); // Recurse on the left subtree with the updated value.\\n        number(root.right, data); // Recurse on the right subtree with the updated value.\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767834,
                "title": "java-100-fast-solution-using-recursion",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n     return sum(root, 0);   \\n    }\\n    public int sum(TreeNode n, int s) {\\n        if(n == null) return 0;\\n        if(n.right == null && n.left == null) return s * 10 + n.val;\\n        return sum(n.left, s * 10 + n.val) + sum(n.right, s * 10 + n.val);\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n     return sum(root, 0);   \\n    }\\n    public int sum(TreeNode n, int s) {\\n        if(n == null) return 0;\\n        if(n.right == null && n.left == null) return s * 10 + n.val;\\n        return sum(n.left, s * 10 + n.val) + sum(n.right, s * 10 + n.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688079,
                "title": "c-beats-100-t-c",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void helper(TreeNode* root, vector<int>& res, int sum){\\n        if(root->left==NULL && root->right==NULL){\\n            sum = sum*10 + root->val;\\n            res.push_back(sum);\\n            return;\\n        }\\n        if(root->left!=NULL && root->right ==NULL){\\n            sum = sum*10 + root->val;\\n            helper(root->left, res, sum);\\n            return; \\n        }\\n        if(root->right!=NULL && root->left ==NULL){\\n            sum = sum*10 + root->val;\\n            helper(root->right, res, sum);\\n            return; \\n        }\\n        sum = sum*10 + root->val;\\n        helper(root->right, res, sum);\\n        helper(root->left, res, sum);\\n        return; \\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n        vector<int> res;\\n        helper(root, res, 0);\\n        int sum =0;\\n        for(int i=0; i<res.size(); i++){\\n            sum+= res[i];\\n        }\\n        return sum;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void helper(TreeNode* root, vector<int>& res, int sum){\\n        if(root->left==NULL && root->right==NULL){\\n            sum = sum*10 + root->val;\\n            res.push_back(sum);\\n            return;\\n        }\\n        if(root->left!=NULL && root->right ==NULL){\\n            sum = sum*10 + root->val;\\n            helper(root->left, res, sum);\\n            return; \\n        }\\n        if(root->right!=NULL && root->left ==NULL){\\n            sum = sum*10 + root->val;\\n            helper(root->right, res, sum);\\n            return; \\n        }\\n        sum = sum*10 + root->val;\\n        helper(root->right, res, sum);\\n        helper(root->left, res, sum);\\n        return; \\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n        vector<int> res;\\n        helper(root, res, 0);\\n        int sum =0;\\n        for(int i=0; i<res.size(); i++){\\n            sum+= res[i];\\n        }\\n        return sum;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685494,
                "title": "java-ultimate-solution-beats-100",
                "content": "# Intuition\\n\\nAt each step just make a new path until you encounter a leaf node.\\n\\n# Approach\\n\\nExample Tree -  \\n\\n           6                               \\n         /   \\\\                          \\n        3     5                      \\n      /   \\\\     \\\\\\n     2    5      4             \\n        /  \\\\                        \\n       7    4  \\n\\n    0*10 + 6 = 6\\n    6*10 + 3 = 63\\n    63*10 + 2 = 632\\n\\n    -- this makes one of the path ( from root  6 to leaf = 2)\\n\\n\\n    similarly make the left and right call to achieve all paths\\n    and calculate\\n\\n# Complexity\\n- Time complexity:  O(N) \\n\\n- Space complexity: O(Height of Tree)\\n  \\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        \\n\\n        return helper(root , 0);\\n    }\\n\\n    static int helper(TreeNode root , int currentSum){\\n\\n\\n        if(root == null) return 0;\\n\\n        int newSum = currentSum * 10 + root.val;\\n\\n\\n        if(root.left == null && root.right == null) return newSum;\\n\\n\\n\\n\\n        int leftSum = helper(root.left , newSum);\\n        int rightSum = helper(root.right , newSum);\\n\\n        return leftSum +  rightSum;\\n\\n\\n        \\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        \\n\\n        return helper(root , 0);\\n    }\\n\\n    static int helper(TreeNode root , int currentSum){\\n\\n\\n        if(root == null) return 0;\\n\\n        int newSum = currentSum * 10 + root.val;\\n\\n\\n        if(root.left == null && root.right == null) return newSum;\\n\\n\\n\\n\\n        int leftSum = helper(root.left , newSum);\\n        int rightSum = helper(root.right , newSum);\\n\\n        return leftSum +  rightSum;\\n\\n\\n        \\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654837,
                "title": "simple-c-solution-using-dfs",
                "content": "Please upvote if you liked it!\\n\\n```\\n    int dfs(TreeNode* root,int sum){\\n        if(!root){return 0;}\\n        sum*=10;\\n        sum+=root->val;\\n        if(!root->left && !root->right){return sum;}\\n        return dfs(root->left,sum) + dfs(root->right,sum);\\n    }\\n    \\n    int sumNumbers(TreeNode* root) {\\n        return dfs(root,0);\\n    }\\n\\t\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "Please upvote if you liked it!\\n\\n```\\n    int dfs(TreeNode* root,int sum){\\n        if(!root){return 0;}\\n        sum*=10;\\n        sum+=root->val;\\n        if(!root->left && !root->right){return sum;}\\n        return dfs(root->left,sum) + dfs(root->right,sum);\\n    }\\n    \\n    int sumNumbers(TreeNode* root) {\\n        return dfs(root,0);\\n    }\\n\\t\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3644689,
                "title": "100-fast-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // preorder traversal\\n    void solve(TreeNode* root, int &sum, int num){\\n        if(!root)  return;\\n         if(!root->left && !root->right){\\n             sum+=num*10+root->val;\\n         }\\n         solve(root->left,sum,num*10+root->val);\\n         solve(root->right,sum,num*10+root->val);\\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n        int sum=0,num=0;\\n        solve(root,sum,num);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // preorder traversal\\n    void solve(TreeNode* root, int &sum, int num){\\n        if(!root)  return;\\n         if(!root->left && !root->right){\\n             sum+=num*10+root->val;\\n         }\\n         solve(root->left,sum,num*10+root->val);\\n         solve(root->right,sum,num*10+root->val);\\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n        int sum=0,num=0;\\n        solve(root,sum,num);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643563,
                "title": "c-efficient",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n#define PB push_back\\nclass Solution {\\npublic:\\n    vector<int> nums;\\n    int sumNumbers(TreeNode* root) {\\n        int ans(0);\\n        int sum(0);\\n        dfs(root, sum);\\n        for(auto it:nums){\\n            cout<<it<<\" \";\\n            ans += it;\\n        }\\n        return ans;\\n    }\\n    void dfs(TreeNode* root, int &sum){\\n        if(root == NULL){\\n            return;\\n        }\\n        sum = sum*10 + root->val;\\n        if(isLeaf(root))\\n            nums.PB(sum);\\n        dfs(root->left,sum);\\n        dfs(root->right,sum);\\n        sum = (sum - root->val)/10;\\n    }\\n    bool isLeaf(TreeNode* root){\\n        if(!root->left && !root->right)\\n            return true;\\n        return false;\\n    }\\n};\\n```\\n\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n#define PB push_back\\nclass Solution {\\npublic:\\n    vector<int> nums;\\n    int sumNumbers(TreeNode* root) {\\n        int ans(0);\\n        int sum(0);\\n        dfs(root, sum);\\n        for(auto it:nums){\\n            cout<<it<<\" \";\\n            ans += it;\\n        }\\n        return ans;\\n    }\\n    void dfs(TreeNode* root, int &sum){\\n        if(root == NULL){\\n            return;\\n        }\\n        sum = sum*10 + root->val;\\n        if(isLeaf(root))\\n            nums.PB(sum);\\n        dfs(root->left,sum);\\n        dfs(root->right,sum);\\n        sum = (sum - root->val)/10;\\n    }\\n    bool isLeaf(TreeNode* root){\\n        if(!root->left && !root->right)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3509242,
                "title": "easy-c-code-beginner-friendly-with-100-beats",
                "content": "# Intuition\\nEasyPeasy C++ code\\n\\n# Approach\\nRecursion\\n\\n# Complexity\\n- Time complexity:O(1)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void sumNumberHelper(TreeNode* root,int val,int &ans){\\n        int curr=val*10 + root->val;\\n        if(root->left == NULL && root->right == NULL){\\n            ans += curr;\\n        }\\n        if(root->left){\\n            sumNumberHelper(root->left,curr,ans);\\n        }\\n        if(root->right) {\\n            sumNumberHelper(root->right,curr,ans);\\n        }\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        int ans = 0;\\n        sumNumberHelper(root,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void sumNumberHelper(TreeNode* root,int val,int &ans){\\n        int curr=val*10 + root->val;\\n        if(root->left == NULL && root->right == NULL){\\n            ans += curr;\\n        }\\n        if(root->left){\\n            sumNumberHelper(root->left,curr,ans);\\n        }\\n        if(root->right) {\\n            sumNumberHelper(root->right,curr,ans);\\n        }\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        int ans = 0;\\n        sumNumberHelper(root,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486171,
                "title": "beats-100-recursive-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int total=0;\\n    public int sumNumbers(TreeNode root) {\\n        helper(root,0);\\n        return total;\\n    }\\n\\n    void helper(TreeNode root,int sum)\\n    {\\n        if(root==null)\\n            return;\\n        sum=sum*10+root.val;\\n\\n        if(root.left==null && root.right==null)\\n        {\\n            total+=sum;\\n            return;\\n        }\\n\\n        helper(root.left,sum);\\n        helper(root.right,sum);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int total=0;\\n    public int sumNumbers(TreeNode root) {\\n        helper(root,0);\\n        return total;\\n    }\\n\\n    void helper(TreeNode root,int sum)\\n    {\\n        if(root==null)\\n            return;\\n        sum=sum*10+root.val;\\n\\n        if(root.left==null && root.right==null)\\n        {\\n            total+=sum;\\n            return;\\n        }\\n\\n        helper(root.left,sum);\\n        helper(root.right,sum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300947,
                "title": "preorder-dfs-java-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nDFS - PreOrder\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        return dfs(root, 0);\\n    }\\n\\n    int dfs(TreeNode root, int sum)\\n    {\\n        if(root == null)\\n            return 0;\\n\\n        sum = (sum * 10) + root.val;\\n\\n        int left = dfs(root.left, sum);\\n        int right = dfs(root.right, sum);\\n\\n        return (left+right) == 0 ? sum : left+right;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        return dfs(root, 0);\\n    }\\n\\n    int dfs(TreeNode root, int sum)\\n    {\\n        if(root == null)\\n            return 0;\\n\\n        sum = (sum * 10) + root.val;\\n\\n        int left = dfs(root.left, sum);\\n        int right = dfs(root.right, sum);\\n\\n        return (left+right) == 0 ? sum : left+right;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297738,
                "title": "simplest-python-solution-using-preorder-traversal",
                "content": "\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        def dfs(cur,num):\\n            if not cur:\\n                return 0\\n            num=num*10+cur.val\\n            if not cur.left and not cur.right:\\n                return num\\n            else:\\n                return dfs(cur.left,num) + dfs(cur.right,num)\\n        return dfs(root,0)\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        def dfs(cur,num):\\n            if not cur:\\n                return 0\\n            num=num*10+cur.val\\n            if not cur.left and not cur.right:\\n                return num\\n            else:\\n                return dfs(cur.left,num) + dfs(cur.right,num)\\n        return dfs(root,0)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297560,
                "title": "0-ms-beats-100-simple-and-concise-recursive-solution",
                "content": "# Intuition\\n0-> Return the total sum of all root-to-leaf numbers.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n0-> use a recursive approach to traverse the tree.\\n\\n1->  We start with the root node and a current number of 0.\\n\\n2-> At each node, we multiply the current number by 10 and add the node\\'s value to get the new current number.\\n\\n3-> If the current node is a leaf node, we add the current number to our running sum. \\n\\n4-> we recursively traverse the left and right subtrees, passing the new current number to each.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(height of Tree)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    private int sumNumbersHelper(TreeNode root, int curr){\\n        if(root == null) return 0;\\n\\n        curr = curr * 10 + root.val;\\n\\n        if(root.left == null && root.right == null) return curr;\\n\\n        int leftSum = sumNumbersHelper(root.left, curr);\\n        int rightSum = sumNumbersHelper(root.right, curr);\\n\\n        return leftSum + rightSum;\\n    }\\n    public int sumNumbers(TreeNode root) {\\n        return sumNumbersHelper(root, 0);\\n    }\\n}\\n```\\n\\n\\n![Upvote Dis.jpeg](https://assets.leetcode.com/users/images/32c2a3e0-b7bb-4f05-a80d-75e0b33f88e7_1678818862.3224769.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    private int sumNumbersHelper(TreeNode root, int curr){\\n        if(root == null) return 0;\\n\\n        curr = curr * 10 + root.val;\\n\\n        if(root.left == null && root.right == null) return curr;\\n\\n        int leftSum = sumNumbersHelper(root.left, curr);\\n        int rightSum = sumNumbersHelper(root.right, curr);\\n\\n        return leftSum + rightSum;\\n    }\\n    public int sumNumbers(TreeNode root) {\\n        return sumNumbersHelper(root, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564972,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sum-root-to-leaf-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Very good question which can be solved in many approaches. Great suggestion, LeetCode!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yesterday's daily (symmetric tree, rated easy) was at least as hard as this one imho"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@mint_](/mint_) No need for string conversion. Just do sum * 10 to shift it over by 1 place "
                    },
                    {
                        "username": "knotri",
                        "content": "[@mint_](/mint_) u dont need to do string to int conversion, just sum =* 10"
                    },
                    {
                        "username": "mint_",
                        "content": "💀\n\nhonestly yesterday's \"easy\" was harder than this IMO, this is just basic DFS (with a little string to int conversion in the end if you want to make it easier)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**so i guess this week topic is BINARY TREE**"
                    },
                    {
                        "username": "Msey",
                        "content": "[@aeroabrar_31](/aeroabrar_31) we used std::ceil :)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "No, only 3 days."
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "This task should be considered as an easy one, not a medium one because of the simplicity of the solution"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "March 12th is Arbor Day, so i guess this is a week for tree!"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "great 2 see new random question in daily challenge\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Basic DFS..."
                    },
                    {
                        "username": "zah7131",
                        "content": "but the challenge is not there for solving it not only DFS. it requires some more attention if it is asked to solve in o(1) space."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "mint_",
                        "content": "some of them probably solved this question before (I solved this one a while back for other prep)"
                    },
                    {
                        "username": "imprayas12",
                        "content": "It's been a while since I saw a randomly new question on daily challenge."
                    }
                ]
            },
            {
                "id": 1831719,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sum-root-to-leaf-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Very good question which can be solved in many approaches. Great suggestion, LeetCode!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yesterday's daily (symmetric tree, rated easy) was at least as hard as this one imho"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@mint_](/mint_) No need for string conversion. Just do sum * 10 to shift it over by 1 place "
                    },
                    {
                        "username": "knotri",
                        "content": "[@mint_](/mint_) u dont need to do string to int conversion, just sum =* 10"
                    },
                    {
                        "username": "mint_",
                        "content": "💀\n\nhonestly yesterday's \"easy\" was harder than this IMO, this is just basic DFS (with a little string to int conversion in the end if you want to make it easier)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**so i guess this week topic is BINARY TREE**"
                    },
                    {
                        "username": "Msey",
                        "content": "[@aeroabrar_31](/aeroabrar_31) we used std::ceil :)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "No, only 3 days."
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "This task should be considered as an easy one, not a medium one because of the simplicity of the solution"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "March 12th is Arbor Day, so i guess this is a week for tree!"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "great 2 see new random question in daily challenge\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Basic DFS..."
                    },
                    {
                        "username": "zah7131",
                        "content": "but the challenge is not there for solving it not only DFS. it requires some more attention if it is asked to solve in o(1) space."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "mint_",
                        "content": "some of them probably solved this question before (I solved this one a while back for other prep)"
                    },
                    {
                        "username": "imprayas12",
                        "content": "It's been a while since I saw a randomly new question on daily challenge."
                    }
                ]
            },
            {
                "id": 1831899,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sum-root-to-leaf-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Very good question which can be solved in many approaches. Great suggestion, LeetCode!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yesterday's daily (symmetric tree, rated easy) was at least as hard as this one imho"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@mint_](/mint_) No need for string conversion. Just do sum * 10 to shift it over by 1 place "
                    },
                    {
                        "username": "knotri",
                        "content": "[@mint_](/mint_) u dont need to do string to int conversion, just sum =* 10"
                    },
                    {
                        "username": "mint_",
                        "content": "💀\n\nhonestly yesterday's \"easy\" was harder than this IMO, this is just basic DFS (with a little string to int conversion in the end if you want to make it easier)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**so i guess this week topic is BINARY TREE**"
                    },
                    {
                        "username": "Msey",
                        "content": "[@aeroabrar_31](/aeroabrar_31) we used std::ceil :)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "No, only 3 days."
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "This task should be considered as an easy one, not a medium one because of the simplicity of the solution"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "March 12th is Arbor Day, so i guess this is a week for tree!"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "great 2 see new random question in daily challenge\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Basic DFS..."
                    },
                    {
                        "username": "zah7131",
                        "content": "but the challenge is not there for solving it not only DFS. it requires some more attention if it is asked to solve in o(1) space."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "mint_",
                        "content": "some of them probably solved this question before (I solved this one a while back for other prep)"
                    },
                    {
                        "username": "imprayas12",
                        "content": "It's been a while since I saw a randomly new question on daily challenge."
                    }
                ]
            },
            {
                "id": 1831810,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sum-root-to-leaf-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Very good question which can be solved in many approaches. Great suggestion, LeetCode!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yesterday's daily (symmetric tree, rated easy) was at least as hard as this one imho"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@mint_](/mint_) No need for string conversion. Just do sum * 10 to shift it over by 1 place "
                    },
                    {
                        "username": "knotri",
                        "content": "[@mint_](/mint_) u dont need to do string to int conversion, just sum =* 10"
                    },
                    {
                        "username": "mint_",
                        "content": "💀\n\nhonestly yesterday's \"easy\" was harder than this IMO, this is just basic DFS (with a little string to int conversion in the end if you want to make it easier)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**so i guess this week topic is BINARY TREE**"
                    },
                    {
                        "username": "Msey",
                        "content": "[@aeroabrar_31](/aeroabrar_31) we used std::ceil :)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "No, only 3 days."
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "This task should be considered as an easy one, not a medium one because of the simplicity of the solution"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "March 12th is Arbor Day, so i guess this is a week for tree!"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "great 2 see new random question in daily challenge\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Basic DFS..."
                    },
                    {
                        "username": "zah7131",
                        "content": "but the challenge is not there for solving it not only DFS. it requires some more attention if it is asked to solve in o(1) space."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "mint_",
                        "content": "some of them probably solved this question before (I solved this one a while back for other prep)"
                    },
                    {
                        "username": "imprayas12",
                        "content": "It's been a while since I saw a randomly new question on daily challenge."
                    }
                ]
            },
            {
                "id": 1832010,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sum-root-to-leaf-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Very good question which can be solved in many approaches. Great suggestion, LeetCode!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yesterday's daily (symmetric tree, rated easy) was at least as hard as this one imho"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@mint_](/mint_) No need for string conversion. Just do sum * 10 to shift it over by 1 place "
                    },
                    {
                        "username": "knotri",
                        "content": "[@mint_](/mint_) u dont need to do string to int conversion, just sum =* 10"
                    },
                    {
                        "username": "mint_",
                        "content": "💀\n\nhonestly yesterday's \"easy\" was harder than this IMO, this is just basic DFS (with a little string to int conversion in the end if you want to make it easier)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**so i guess this week topic is BINARY TREE**"
                    },
                    {
                        "username": "Msey",
                        "content": "[@aeroabrar_31](/aeroabrar_31) we used std::ceil :)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "No, only 3 days."
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "This task should be considered as an easy one, not a medium one because of the simplicity of the solution"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "March 12th is Arbor Day, so i guess this is a week for tree!"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "great 2 see new random question in daily challenge\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Basic DFS..."
                    },
                    {
                        "username": "zah7131",
                        "content": "but the challenge is not there for solving it not only DFS. it requires some more attention if it is asked to solve in o(1) space."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "mint_",
                        "content": "some of them probably solved this question before (I solved this one a while back for other prep)"
                    },
                    {
                        "username": "imprayas12",
                        "content": "It's been a while since I saw a randomly new question on daily challenge."
                    }
                ]
            },
            {
                "id": 1831954,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sum-root-to-leaf-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Very good question which can be solved in many approaches. Great suggestion, LeetCode!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yesterday's daily (symmetric tree, rated easy) was at least as hard as this one imho"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@mint_](/mint_) No need for string conversion. Just do sum * 10 to shift it over by 1 place "
                    },
                    {
                        "username": "knotri",
                        "content": "[@mint_](/mint_) u dont need to do string to int conversion, just sum =* 10"
                    },
                    {
                        "username": "mint_",
                        "content": "💀\n\nhonestly yesterday's \"easy\" was harder than this IMO, this is just basic DFS (with a little string to int conversion in the end if you want to make it easier)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**so i guess this week topic is BINARY TREE**"
                    },
                    {
                        "username": "Msey",
                        "content": "[@aeroabrar_31](/aeroabrar_31) we used std::ceil :)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "No, only 3 days."
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "This task should be considered as an easy one, not a medium one because of the simplicity of the solution"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "March 12th is Arbor Day, so i guess this is a week for tree!"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "great 2 see new random question in daily challenge\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Basic DFS..."
                    },
                    {
                        "username": "zah7131",
                        "content": "but the challenge is not there for solving it not only DFS. it requires some more attention if it is asked to solve in o(1) space."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "mint_",
                        "content": "some of them probably solved this question before (I solved this one a while back for other prep)"
                    },
                    {
                        "username": "imprayas12",
                        "content": "It's been a while since I saw a randomly new question on daily challenge."
                    }
                ]
            },
            {
                "id": 1832215,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sum-root-to-leaf-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Very good question which can be solved in many approaches. Great suggestion, LeetCode!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yesterday's daily (symmetric tree, rated easy) was at least as hard as this one imho"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@mint_](/mint_) No need for string conversion. Just do sum * 10 to shift it over by 1 place "
                    },
                    {
                        "username": "knotri",
                        "content": "[@mint_](/mint_) u dont need to do string to int conversion, just sum =* 10"
                    },
                    {
                        "username": "mint_",
                        "content": "💀\n\nhonestly yesterday's \"easy\" was harder than this IMO, this is just basic DFS (with a little string to int conversion in the end if you want to make it easier)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**so i guess this week topic is BINARY TREE**"
                    },
                    {
                        "username": "Msey",
                        "content": "[@aeroabrar_31](/aeroabrar_31) we used std::ceil :)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "No, only 3 days."
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "This task should be considered as an easy one, not a medium one because of the simplicity of the solution"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "March 12th is Arbor Day, so i guess this is a week for tree!"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "great 2 see new random question in daily challenge\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Basic DFS..."
                    },
                    {
                        "username": "zah7131",
                        "content": "but the challenge is not there for solving it not only DFS. it requires some more attention if it is asked to solve in o(1) space."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "mint_",
                        "content": "some of them probably solved this question before (I solved this one a while back for other prep)"
                    },
                    {
                        "username": "imprayas12",
                        "content": "It's been a while since I saw a randomly new question on daily challenge."
                    }
                ]
            },
            {
                "id": 1831834,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sum-root-to-leaf-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Very good question which can be solved in many approaches. Great suggestion, LeetCode!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yesterday's daily (symmetric tree, rated easy) was at least as hard as this one imho"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@mint_](/mint_) No need for string conversion. Just do sum * 10 to shift it over by 1 place "
                    },
                    {
                        "username": "knotri",
                        "content": "[@mint_](/mint_) u dont need to do string to int conversion, just sum =* 10"
                    },
                    {
                        "username": "mint_",
                        "content": "💀\n\nhonestly yesterday's \"easy\" was harder than this IMO, this is just basic DFS (with a little string to int conversion in the end if you want to make it easier)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**so i guess this week topic is BINARY TREE**"
                    },
                    {
                        "username": "Msey",
                        "content": "[@aeroabrar_31](/aeroabrar_31) we used std::ceil :)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "No, only 3 days."
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "This task should be considered as an easy one, not a medium one because of the simplicity of the solution"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "March 12th is Arbor Day, so i guess this is a week for tree!"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "great 2 see new random question in daily challenge\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Basic DFS..."
                    },
                    {
                        "username": "zah7131",
                        "content": "but the challenge is not there for solving it not only DFS. it requires some more attention if it is asked to solve in o(1) space."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "mint_",
                        "content": "some of them probably solved this question before (I solved this one a while back for other prep)"
                    },
                    {
                        "username": "imprayas12",
                        "content": "It's been a while since I saw a randomly new question on daily challenge."
                    }
                ]
            },
            {
                "id": 1831813,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sum-root-to-leaf-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Very good question which can be solved in many approaches. Great suggestion, LeetCode!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yesterday's daily (symmetric tree, rated easy) was at least as hard as this one imho"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@mint_](/mint_) No need for string conversion. Just do sum * 10 to shift it over by 1 place "
                    },
                    {
                        "username": "knotri",
                        "content": "[@mint_](/mint_) u dont need to do string to int conversion, just sum =* 10"
                    },
                    {
                        "username": "mint_",
                        "content": "💀\n\nhonestly yesterday's \"easy\" was harder than this IMO, this is just basic DFS (with a little string to int conversion in the end if you want to make it easier)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**so i guess this week topic is BINARY TREE**"
                    },
                    {
                        "username": "Msey",
                        "content": "[@aeroabrar_31](/aeroabrar_31) we used std::ceil :)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "No, only 3 days."
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "This task should be considered as an easy one, not a medium one because of the simplicity of the solution"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "March 12th is Arbor Day, so i guess this is a week for tree!"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "great 2 see new random question in daily challenge\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Basic DFS..."
                    },
                    {
                        "username": "zah7131",
                        "content": "but the challenge is not there for solving it not only DFS. it requires some more attention if it is asked to solve in o(1) space."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "mint_",
                        "content": "some of them probably solved this question before (I solved this one a while back for other prep)"
                    },
                    {
                        "username": "imprayas12",
                        "content": "It's been a while since I saw a randomly new question on daily challenge."
                    }
                ]
            },
            {
                "id": 1831804,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sum-root-to-leaf-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Very good question which can be solved in many approaches. Great suggestion, LeetCode!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yesterday's daily (symmetric tree, rated easy) was at least as hard as this one imho"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@mint_](/mint_) No need for string conversion. Just do sum * 10 to shift it over by 1 place "
                    },
                    {
                        "username": "knotri",
                        "content": "[@mint_](/mint_) u dont need to do string to int conversion, just sum =* 10"
                    },
                    {
                        "username": "mint_",
                        "content": "💀\n\nhonestly yesterday's \"easy\" was harder than this IMO, this is just basic DFS (with a little string to int conversion in the end if you want to make it easier)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**so i guess this week topic is BINARY TREE**"
                    },
                    {
                        "username": "Msey",
                        "content": "[@aeroabrar_31](/aeroabrar_31) we used std::ceil :)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "No, only 3 days."
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "This task should be considered as an easy one, not a medium one because of the simplicity of the solution"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "March 12th is Arbor Day, so i guess this is a week for tree!"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "great 2 see new random question in daily challenge\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Basic DFS..."
                    },
                    {
                        "username": "zah7131",
                        "content": "but the challenge is not there for solving it not only DFS. it requires some more attention if it is asked to solve in o(1) space."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "mint_",
                        "content": "some of them probably solved this question before (I solved this one a while back for other prep)"
                    },
                    {
                        "username": "imprayas12",
                        "content": "It's been a while since I saw a randomly new question on daily challenge."
                    }
                ]
            },
            {
                "id": 1564972,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sum-root-to-leaf-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Very good question which can be solved in many approaches. Great suggestion, LeetCode!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yesterday's daily (symmetric tree, rated easy) was at least as hard as this one imho"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@mint_](/mint_) No need for string conversion. Just do sum * 10 to shift it over by 1 place "
                    },
                    {
                        "username": "knotri",
                        "content": "[@mint_](/mint_) u dont need to do string to int conversion, just sum =* 10"
                    },
                    {
                        "username": "mint_",
                        "content": "💀\n\nhonestly yesterday's \"easy\" was harder than this IMO, this is just basic DFS (with a little string to int conversion in the end if you want to make it easier)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**so i guess this week topic is BINARY TREE**"
                    },
                    {
                        "username": "Msey",
                        "content": "[@aeroabrar_31](/aeroabrar_31) we used std::ceil :)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "No, only 3 days."
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "This task should be considered as an easy one, not a medium one because of the simplicity of the solution"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "March 12th is Arbor Day, so i guess this is a week for tree!"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "great 2 see new random question in daily challenge\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Basic DFS..."
                    },
                    {
                        "username": "zah7131",
                        "content": "but the challenge is not there for solving it not only DFS. it requires some more attention if it is asked to solve in o(1) space."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "mint_",
                        "content": "some of them probably solved this question before (I solved this one a while back for other prep)"
                    },
                    {
                        "username": "imprayas12",
                        "content": "It's been a while since I saw a randomly new question on daily challenge."
                    }
                ]
            },
            {
                "id": 1831719,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sum-root-to-leaf-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Very good question which can be solved in many approaches. Great suggestion, LeetCode!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yesterday's daily (symmetric tree, rated easy) was at least as hard as this one imho"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@mint_](/mint_) No need for string conversion. Just do sum * 10 to shift it over by 1 place "
                    },
                    {
                        "username": "knotri",
                        "content": "[@mint_](/mint_) u dont need to do string to int conversion, just sum =* 10"
                    },
                    {
                        "username": "mint_",
                        "content": "💀\n\nhonestly yesterday's \"easy\" was harder than this IMO, this is just basic DFS (with a little string to int conversion in the end if you want to make it easier)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**so i guess this week topic is BINARY TREE**"
                    },
                    {
                        "username": "Msey",
                        "content": "[@aeroabrar_31](/aeroabrar_31) we used std::ceil :)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "No, only 3 days."
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "This task should be considered as an easy one, not a medium one because of the simplicity of the solution"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "March 12th is Arbor Day, so i guess this is a week for tree!"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "great 2 see new random question in daily challenge\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Basic DFS..."
                    },
                    {
                        "username": "zah7131",
                        "content": "but the challenge is not there for solving it not only DFS. it requires some more attention if it is asked to solve in o(1) space."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "mint_",
                        "content": "some of them probably solved this question before (I solved this one a while back for other prep)"
                    },
                    {
                        "username": "imprayas12",
                        "content": "It's been a while since I saw a randomly new question on daily challenge."
                    }
                ]
            },
            {
                "id": 1831899,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sum-root-to-leaf-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Very good question which can be solved in many approaches. Great suggestion, LeetCode!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yesterday's daily (symmetric tree, rated easy) was at least as hard as this one imho"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@mint_](/mint_) No need for string conversion. Just do sum * 10 to shift it over by 1 place "
                    },
                    {
                        "username": "knotri",
                        "content": "[@mint_](/mint_) u dont need to do string to int conversion, just sum =* 10"
                    },
                    {
                        "username": "mint_",
                        "content": "💀\n\nhonestly yesterday's \"easy\" was harder than this IMO, this is just basic DFS (with a little string to int conversion in the end if you want to make it easier)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**so i guess this week topic is BINARY TREE**"
                    },
                    {
                        "username": "Msey",
                        "content": "[@aeroabrar_31](/aeroabrar_31) we used std::ceil :)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "No, only 3 days."
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "This task should be considered as an easy one, not a medium one because of the simplicity of the solution"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "March 12th is Arbor Day, so i guess this is a week for tree!"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "great 2 see new random question in daily challenge\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Basic DFS..."
                    },
                    {
                        "username": "zah7131",
                        "content": "but the challenge is not there for solving it not only DFS. it requires some more attention if it is asked to solve in o(1) space."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "mint_",
                        "content": "some of them probably solved this question before (I solved this one a while back for other prep)"
                    },
                    {
                        "username": "imprayas12",
                        "content": "It's been a while since I saw a randomly new question on daily challenge."
                    }
                ]
            },
            {
                "id": 1831810,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sum-root-to-leaf-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Very good question which can be solved in many approaches. Great suggestion, LeetCode!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yesterday's daily (symmetric tree, rated easy) was at least as hard as this one imho"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@mint_](/mint_) No need for string conversion. Just do sum * 10 to shift it over by 1 place "
                    },
                    {
                        "username": "knotri",
                        "content": "[@mint_](/mint_) u dont need to do string to int conversion, just sum =* 10"
                    },
                    {
                        "username": "mint_",
                        "content": "💀\n\nhonestly yesterday's \"easy\" was harder than this IMO, this is just basic DFS (with a little string to int conversion in the end if you want to make it easier)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**so i guess this week topic is BINARY TREE**"
                    },
                    {
                        "username": "Msey",
                        "content": "[@aeroabrar_31](/aeroabrar_31) we used std::ceil :)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "No, only 3 days."
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "This task should be considered as an easy one, not a medium one because of the simplicity of the solution"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "March 12th is Arbor Day, so i guess this is a week for tree!"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "great 2 see new random question in daily challenge\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Basic DFS..."
                    },
                    {
                        "username": "zah7131",
                        "content": "but the challenge is not there for solving it not only DFS. it requires some more attention if it is asked to solve in o(1) space."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "mint_",
                        "content": "some of them probably solved this question before (I solved this one a while back for other prep)"
                    },
                    {
                        "username": "imprayas12",
                        "content": "It's been a while since I saw a randomly new question on daily challenge."
                    }
                ]
            },
            {
                "id": 1832010,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sum-root-to-leaf-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Very good question which can be solved in many approaches. Great suggestion, LeetCode!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yesterday's daily (symmetric tree, rated easy) was at least as hard as this one imho"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@mint_](/mint_) No need for string conversion. Just do sum * 10 to shift it over by 1 place "
                    },
                    {
                        "username": "knotri",
                        "content": "[@mint_](/mint_) u dont need to do string to int conversion, just sum =* 10"
                    },
                    {
                        "username": "mint_",
                        "content": "💀\n\nhonestly yesterday's \"easy\" was harder than this IMO, this is just basic DFS (with a little string to int conversion in the end if you want to make it easier)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**so i guess this week topic is BINARY TREE**"
                    },
                    {
                        "username": "Msey",
                        "content": "[@aeroabrar_31](/aeroabrar_31) we used std::ceil :)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "No, only 3 days."
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "This task should be considered as an easy one, not a medium one because of the simplicity of the solution"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "March 12th is Arbor Day, so i guess this is a week for tree!"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "great 2 see new random question in daily challenge\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Basic DFS..."
                    },
                    {
                        "username": "zah7131",
                        "content": "but the challenge is not there for solving it not only DFS. it requires some more attention if it is asked to solve in o(1) space."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "mint_",
                        "content": "some of them probably solved this question before (I solved this one a while back for other prep)"
                    },
                    {
                        "username": "imprayas12",
                        "content": "It's been a while since I saw a randomly new question on daily challenge."
                    }
                ]
            },
            {
                "id": 1831954,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sum-root-to-leaf-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Very good question which can be solved in many approaches. Great suggestion, LeetCode!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yesterday's daily (symmetric tree, rated easy) was at least as hard as this one imho"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@mint_](/mint_) No need for string conversion. Just do sum * 10 to shift it over by 1 place "
                    },
                    {
                        "username": "knotri",
                        "content": "[@mint_](/mint_) u dont need to do string to int conversion, just sum =* 10"
                    },
                    {
                        "username": "mint_",
                        "content": "💀\n\nhonestly yesterday's \"easy\" was harder than this IMO, this is just basic DFS (with a little string to int conversion in the end if you want to make it easier)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**so i guess this week topic is BINARY TREE**"
                    },
                    {
                        "username": "Msey",
                        "content": "[@aeroabrar_31](/aeroabrar_31) we used std::ceil :)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "No, only 3 days."
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "This task should be considered as an easy one, not a medium one because of the simplicity of the solution"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "March 12th is Arbor Day, so i guess this is a week for tree!"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "great 2 see new random question in daily challenge\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Basic DFS..."
                    },
                    {
                        "username": "zah7131",
                        "content": "but the challenge is not there for solving it not only DFS. it requires some more attention if it is asked to solve in o(1) space."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "mint_",
                        "content": "some of them probably solved this question before (I solved this one a while back for other prep)"
                    },
                    {
                        "username": "imprayas12",
                        "content": "It's been a while since I saw a randomly new question on daily challenge."
                    }
                ]
            },
            {
                "id": 1832215,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sum-root-to-leaf-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Very good question which can be solved in many approaches. Great suggestion, LeetCode!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yesterday's daily (symmetric tree, rated easy) was at least as hard as this one imho"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@mint_](/mint_) No need for string conversion. Just do sum * 10 to shift it over by 1 place "
                    },
                    {
                        "username": "knotri",
                        "content": "[@mint_](/mint_) u dont need to do string to int conversion, just sum =* 10"
                    },
                    {
                        "username": "mint_",
                        "content": "💀\n\nhonestly yesterday's \"easy\" was harder than this IMO, this is just basic DFS (with a little string to int conversion in the end if you want to make it easier)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**so i guess this week topic is BINARY TREE**"
                    },
                    {
                        "username": "Msey",
                        "content": "[@aeroabrar_31](/aeroabrar_31) we used std::ceil :)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "No, only 3 days."
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "This task should be considered as an easy one, not a medium one because of the simplicity of the solution"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "March 12th is Arbor Day, so i guess this is a week for tree!"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "great 2 see new random question in daily challenge\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Basic DFS..."
                    },
                    {
                        "username": "zah7131",
                        "content": "but the challenge is not there for solving it not only DFS. it requires some more attention if it is asked to solve in o(1) space."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "mint_",
                        "content": "some of them probably solved this question before (I solved this one a while back for other prep)"
                    },
                    {
                        "username": "imprayas12",
                        "content": "It's been a while since I saw a randomly new question on daily challenge."
                    }
                ]
            },
            {
                "id": 1831834,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sum-root-to-leaf-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Very good question which can be solved in many approaches. Great suggestion, LeetCode!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yesterday's daily (symmetric tree, rated easy) was at least as hard as this one imho"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@mint_](/mint_) No need for string conversion. Just do sum * 10 to shift it over by 1 place "
                    },
                    {
                        "username": "knotri",
                        "content": "[@mint_](/mint_) u dont need to do string to int conversion, just sum =* 10"
                    },
                    {
                        "username": "mint_",
                        "content": "💀\n\nhonestly yesterday's \"easy\" was harder than this IMO, this is just basic DFS (with a little string to int conversion in the end if you want to make it easier)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**so i guess this week topic is BINARY TREE**"
                    },
                    {
                        "username": "Msey",
                        "content": "[@aeroabrar_31](/aeroabrar_31) we used std::ceil :)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "No, only 3 days."
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "This task should be considered as an easy one, not a medium one because of the simplicity of the solution"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "March 12th is Arbor Day, so i guess this is a week for tree!"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "great 2 see new random question in daily challenge\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Basic DFS..."
                    },
                    {
                        "username": "zah7131",
                        "content": "but the challenge is not there for solving it not only DFS. it requires some more attention if it is asked to solve in o(1) space."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "mint_",
                        "content": "some of them probably solved this question before (I solved this one a while back for other prep)"
                    },
                    {
                        "username": "imprayas12",
                        "content": "It's been a while since I saw a randomly new question on daily challenge."
                    }
                ]
            },
            {
                "id": 1831813,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sum-root-to-leaf-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Very good question which can be solved in many approaches. Great suggestion, LeetCode!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yesterday's daily (symmetric tree, rated easy) was at least as hard as this one imho"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@mint_](/mint_) No need for string conversion. Just do sum * 10 to shift it over by 1 place "
                    },
                    {
                        "username": "knotri",
                        "content": "[@mint_](/mint_) u dont need to do string to int conversion, just sum =* 10"
                    },
                    {
                        "username": "mint_",
                        "content": "💀\n\nhonestly yesterday's \"easy\" was harder than this IMO, this is just basic DFS (with a little string to int conversion in the end if you want to make it easier)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**so i guess this week topic is BINARY TREE**"
                    },
                    {
                        "username": "Msey",
                        "content": "[@aeroabrar_31](/aeroabrar_31) we used std::ceil :)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "No, only 3 days."
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "This task should be considered as an easy one, not a medium one because of the simplicity of the solution"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "March 12th is Arbor Day, so i guess this is a week for tree!"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "great 2 see new random question in daily challenge\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Basic DFS..."
                    },
                    {
                        "username": "zah7131",
                        "content": "but the challenge is not there for solving it not only DFS. it requires some more attention if it is asked to solve in o(1) space."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "mint_",
                        "content": "some of them probably solved this question before (I solved this one a while back for other prep)"
                    },
                    {
                        "username": "imprayas12",
                        "content": "It's been a while since I saw a randomly new question on daily challenge."
                    }
                ]
            },
            {
                "id": 1831804,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sum-root-to-leaf-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Very good question which can be solved in many approaches. Great suggestion, LeetCode!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yesterday's daily (symmetric tree, rated easy) was at least as hard as this one imho"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@mint_](/mint_) No need for string conversion. Just do sum * 10 to shift it over by 1 place "
                    },
                    {
                        "username": "knotri",
                        "content": "[@mint_](/mint_) u dont need to do string to int conversion, just sum =* 10"
                    },
                    {
                        "username": "mint_",
                        "content": "💀\n\nhonestly yesterday's \"easy\" was harder than this IMO, this is just basic DFS (with a little string to int conversion in the end if you want to make it easier)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**so i guess this week topic is BINARY TREE**"
                    },
                    {
                        "username": "Msey",
                        "content": "[@aeroabrar_31](/aeroabrar_31) we used std::ceil :)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "No, only 3 days."
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "This task should be considered as an easy one, not a medium one because of the simplicity of the solution"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "March 12th is Arbor Day, so i guess this is a week for tree!"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "great 2 see new random question in daily challenge\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Basic DFS..."
                    },
                    {
                        "username": "zah7131",
                        "content": "but the challenge is not there for solving it not only DFS. it requires some more attention if it is asked to solve in o(1) space."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "mint_",
                        "content": "some of them probably solved this question before (I solved this one a while back for other prep)"
                    },
                    {
                        "username": "imprayas12",
                        "content": "It's been a while since I saw a randomly new question on daily challenge."
                    }
                ]
            },
            {
                "id": 1831789,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Should be marked as easy, joke question"
                    },
                    {
                        "username": "BryanBoCao",
                        "content": "In terms of [#129. Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/)\\nMy output for running the same code was different to that on the submit solution, which was \"1\" and \"10\" respectively, why?\\n![0_1467851352336_Screenshot from 2016-07-06 18:27:39.png](/uploads/files/1467851353053-screenshot-from-2016-07-06-18-27-39.png) \\n\\n[My submission](https://leetcode.com/submissions/detail/66362641/)"
                    },
                    {
                        "username": "wjeevika",
                        "content": "This is a good question."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@wjeevika](/wjeevika) lmao why u reply to urself"
                    },
                    {
                        "username": "wjeevika",
                        "content": "I like it. "
                    },
                    {
                        "username": "ben_huang",
                        "content": "![image](https://assets.leetcode.com/users/ben_huang/image_1552672771.png)\\n"
                    },
                    {
                        "username": "sweetiemelody",
                        "content": "who can explain the 0-ms solution? Thank you a lot."
                    },
                    {
                        "username": "bboczeng",
                        "content": "What does this mean in terms of a binary tree?"
                    },
                    {
                        "username": "manodupont",
                        "content": "Why is this working correctly in VSCode, but not in here ?\n**Use Case**\nroot =\n[4,9,0,5,1]\n\n**Code**\n```\nlet sum = 0\nfunction dfs(node, path) {\n    if (node !== null) {\n        path += `${node.val}`\n\n        if (node.left == null && node.right == null) {// Its a leaf\n            console.log(path)\n            sum += parseInt(path)\n        }\n\n        dfs(node.left, path)\n        dfs(node.right, path)\n    }\n}\n\nfunction sumNumbers(root) {\n    dfs(root, '')\n    return sum\n};\n```\n"
                    },
                    {
                        "username": "garvit_17",
                        "content": "terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\n"
                    },
                    {
                        "username": "souravishere1996",
                        "content": "What to say about this easy approach??\\n\\nclass Solution {\\npublic:\\n\\n    int func(TreeNode* root,int sum)\\n    {\\n        if(!root){\\n          //  sum=sum*10+root->val;\\n            return 0;\\n        }\\n        if(!root->left && !root->right)\\n        {\\n            sum=sum*10+root->val;\\n            return sum;\\n        }\\n\\n        sum=sum*10+root->val;\\n        return func(root->left,sum) + func(root->right,sum);\\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n\\n        int sum=0;\\n        return func(root,sum);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "I would say - lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I like this question. Its similar to path sum I and II, so if you solved those then this should be easy too \\n\\nI found other \"easy\" tree questions to be harder than this one "
                    }
                ]
            },
            {
                "id": 1571276,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Should be marked as easy, joke question"
                    },
                    {
                        "username": "BryanBoCao",
                        "content": "In terms of [#129. Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/)\\nMy output for running the same code was different to that on the submit solution, which was \"1\" and \"10\" respectively, why?\\n![0_1467851352336_Screenshot from 2016-07-06 18:27:39.png](/uploads/files/1467851353053-screenshot-from-2016-07-06-18-27-39.png) \\n\\n[My submission](https://leetcode.com/submissions/detail/66362641/)"
                    },
                    {
                        "username": "wjeevika",
                        "content": "This is a good question."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@wjeevika](/wjeevika) lmao why u reply to urself"
                    },
                    {
                        "username": "wjeevika",
                        "content": "I like it. "
                    },
                    {
                        "username": "ben_huang",
                        "content": "![image](https://assets.leetcode.com/users/ben_huang/image_1552672771.png)\\n"
                    },
                    {
                        "username": "sweetiemelody",
                        "content": "who can explain the 0-ms solution? Thank you a lot."
                    },
                    {
                        "username": "bboczeng",
                        "content": "What does this mean in terms of a binary tree?"
                    },
                    {
                        "username": "manodupont",
                        "content": "Why is this working correctly in VSCode, but not in here ?\n**Use Case**\nroot =\n[4,9,0,5,1]\n\n**Code**\n```\nlet sum = 0\nfunction dfs(node, path) {\n    if (node !== null) {\n        path += `${node.val}`\n\n        if (node.left == null && node.right == null) {// Its a leaf\n            console.log(path)\n            sum += parseInt(path)\n        }\n\n        dfs(node.left, path)\n        dfs(node.right, path)\n    }\n}\n\nfunction sumNumbers(root) {\n    dfs(root, '')\n    return sum\n};\n```\n"
                    },
                    {
                        "username": "garvit_17",
                        "content": "terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\n"
                    },
                    {
                        "username": "souravishere1996",
                        "content": "What to say about this easy approach??\\n\\nclass Solution {\\npublic:\\n\\n    int func(TreeNode* root,int sum)\\n    {\\n        if(!root){\\n          //  sum=sum*10+root->val;\\n            return 0;\\n        }\\n        if(!root->left && !root->right)\\n        {\\n            sum=sum*10+root->val;\\n            return sum;\\n        }\\n\\n        sum=sum*10+root->val;\\n        return func(root->left,sum) + func(root->right,sum);\\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n\\n        int sum=0;\\n        return func(root,sum);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "I would say - lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I like this question. Its similar to path sum I and II, so if you solved those then this should be easy too \\n\\nI found other \"easy\" tree questions to be harder than this one "
                    }
                ]
            },
            {
                "id": 1679672,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Should be marked as easy, joke question"
                    },
                    {
                        "username": "BryanBoCao",
                        "content": "In terms of [#129. Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/)\\nMy output for running the same code was different to that on the submit solution, which was \"1\" and \"10\" respectively, why?\\n![0_1467851352336_Screenshot from 2016-07-06 18:27:39.png](/uploads/files/1467851353053-screenshot-from-2016-07-06-18-27-39.png) \\n\\n[My submission](https://leetcode.com/submissions/detail/66362641/)"
                    },
                    {
                        "username": "wjeevika",
                        "content": "This is a good question."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@wjeevika](/wjeevika) lmao why u reply to urself"
                    },
                    {
                        "username": "wjeevika",
                        "content": "I like it. "
                    },
                    {
                        "username": "ben_huang",
                        "content": "![image](https://assets.leetcode.com/users/ben_huang/image_1552672771.png)\\n"
                    },
                    {
                        "username": "sweetiemelody",
                        "content": "who can explain the 0-ms solution? Thank you a lot."
                    },
                    {
                        "username": "bboczeng",
                        "content": "What does this mean in terms of a binary tree?"
                    },
                    {
                        "username": "manodupont",
                        "content": "Why is this working correctly in VSCode, but not in here ?\n**Use Case**\nroot =\n[4,9,0,5,1]\n\n**Code**\n```\nlet sum = 0\nfunction dfs(node, path) {\n    if (node !== null) {\n        path += `${node.val}`\n\n        if (node.left == null && node.right == null) {// Its a leaf\n            console.log(path)\n            sum += parseInt(path)\n        }\n\n        dfs(node.left, path)\n        dfs(node.right, path)\n    }\n}\n\nfunction sumNumbers(root) {\n    dfs(root, '')\n    return sum\n};\n```\n"
                    },
                    {
                        "username": "garvit_17",
                        "content": "terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\n"
                    },
                    {
                        "username": "souravishere1996",
                        "content": "What to say about this easy approach??\\n\\nclass Solution {\\npublic:\\n\\n    int func(TreeNode* root,int sum)\\n    {\\n        if(!root){\\n          //  sum=sum*10+root->val;\\n            return 0;\\n        }\\n        if(!root->left && !root->right)\\n        {\\n            sum=sum*10+root->val;\\n            return sum;\\n        }\\n\\n        sum=sum*10+root->val;\\n        return func(root->left,sum) + func(root->right,sum);\\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n\\n        int sum=0;\\n        return func(root,sum);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "I would say - lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I like this question. Its similar to path sum I and II, so if you solved those then this should be easy too \\n\\nI found other \"easy\" tree questions to be harder than this one "
                    }
                ]
            },
            {
                "id": 1572527,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Should be marked as easy, joke question"
                    },
                    {
                        "username": "BryanBoCao",
                        "content": "In terms of [#129. Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/)\\nMy output for running the same code was different to that on the submit solution, which was \"1\" and \"10\" respectively, why?\\n![0_1467851352336_Screenshot from 2016-07-06 18:27:39.png](/uploads/files/1467851353053-screenshot-from-2016-07-06-18-27-39.png) \\n\\n[My submission](https://leetcode.com/submissions/detail/66362641/)"
                    },
                    {
                        "username": "wjeevika",
                        "content": "This is a good question."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@wjeevika](/wjeevika) lmao why u reply to urself"
                    },
                    {
                        "username": "wjeevika",
                        "content": "I like it. "
                    },
                    {
                        "username": "ben_huang",
                        "content": "![image](https://assets.leetcode.com/users/ben_huang/image_1552672771.png)\\n"
                    },
                    {
                        "username": "sweetiemelody",
                        "content": "who can explain the 0-ms solution? Thank you a lot."
                    },
                    {
                        "username": "bboczeng",
                        "content": "What does this mean in terms of a binary tree?"
                    },
                    {
                        "username": "manodupont",
                        "content": "Why is this working correctly in VSCode, but not in here ?\n**Use Case**\nroot =\n[4,9,0,5,1]\n\n**Code**\n```\nlet sum = 0\nfunction dfs(node, path) {\n    if (node !== null) {\n        path += `${node.val}`\n\n        if (node.left == null && node.right == null) {// Its a leaf\n            console.log(path)\n            sum += parseInt(path)\n        }\n\n        dfs(node.left, path)\n        dfs(node.right, path)\n    }\n}\n\nfunction sumNumbers(root) {\n    dfs(root, '')\n    return sum\n};\n```\n"
                    },
                    {
                        "username": "garvit_17",
                        "content": "terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\n"
                    },
                    {
                        "username": "souravishere1996",
                        "content": "What to say about this easy approach??\\n\\nclass Solution {\\npublic:\\n\\n    int func(TreeNode* root,int sum)\\n    {\\n        if(!root){\\n          //  sum=sum*10+root->val;\\n            return 0;\\n        }\\n        if(!root->left && !root->right)\\n        {\\n            sum=sum*10+root->val;\\n            return sum;\\n        }\\n\\n        sum=sum*10+root->val;\\n        return func(root->left,sum) + func(root->right,sum);\\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n\\n        int sum=0;\\n        return func(root,sum);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "I would say - lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I like this question. Its similar to path sum I and II, so if you solved those then this should be easy too \\n\\nI found other \"easy\" tree questions to be harder than this one "
                    }
                ]
            },
            {
                "id": 1571277,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Should be marked as easy, joke question"
                    },
                    {
                        "username": "BryanBoCao",
                        "content": "In terms of [#129. Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/)\\nMy output for running the same code was different to that on the submit solution, which was \"1\" and \"10\" respectively, why?\\n![0_1467851352336_Screenshot from 2016-07-06 18:27:39.png](/uploads/files/1467851353053-screenshot-from-2016-07-06-18-27-39.png) \\n\\n[My submission](https://leetcode.com/submissions/detail/66362641/)"
                    },
                    {
                        "username": "wjeevika",
                        "content": "This is a good question."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@wjeevika](/wjeevika) lmao why u reply to urself"
                    },
                    {
                        "username": "wjeevika",
                        "content": "I like it. "
                    },
                    {
                        "username": "ben_huang",
                        "content": "![image](https://assets.leetcode.com/users/ben_huang/image_1552672771.png)\\n"
                    },
                    {
                        "username": "sweetiemelody",
                        "content": "who can explain the 0-ms solution? Thank you a lot."
                    },
                    {
                        "username": "bboczeng",
                        "content": "What does this mean in terms of a binary tree?"
                    },
                    {
                        "username": "manodupont",
                        "content": "Why is this working correctly in VSCode, but not in here ?\n**Use Case**\nroot =\n[4,9,0,5,1]\n\n**Code**\n```\nlet sum = 0\nfunction dfs(node, path) {\n    if (node !== null) {\n        path += `${node.val}`\n\n        if (node.left == null && node.right == null) {// Its a leaf\n            console.log(path)\n            sum += parseInt(path)\n        }\n\n        dfs(node.left, path)\n        dfs(node.right, path)\n    }\n}\n\nfunction sumNumbers(root) {\n    dfs(root, '')\n    return sum\n};\n```\n"
                    },
                    {
                        "username": "garvit_17",
                        "content": "terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\n"
                    },
                    {
                        "username": "souravishere1996",
                        "content": "What to say about this easy approach??\\n\\nclass Solution {\\npublic:\\n\\n    int func(TreeNode* root,int sum)\\n    {\\n        if(!root){\\n          //  sum=sum*10+root->val;\\n            return 0;\\n        }\\n        if(!root->left && !root->right)\\n        {\\n            sum=sum*10+root->val;\\n            return sum;\\n        }\\n\\n        sum=sum*10+root->val;\\n        return func(root->left,sum) + func(root->right,sum);\\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n\\n        int sum=0;\\n        return func(root,sum);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "I would say - lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I like this question. Its similar to path sum I and II, so if you solved those then this should be easy too \\n\\nI found other \"easy\" tree questions to be harder than this one "
                    }
                ]
            },
            {
                "id": 1571278,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Should be marked as easy, joke question"
                    },
                    {
                        "username": "BryanBoCao",
                        "content": "In terms of [#129. Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/)\\nMy output for running the same code was different to that on the submit solution, which was \"1\" and \"10\" respectively, why?\\n![0_1467851352336_Screenshot from 2016-07-06 18:27:39.png](/uploads/files/1467851353053-screenshot-from-2016-07-06-18-27-39.png) \\n\\n[My submission](https://leetcode.com/submissions/detail/66362641/)"
                    },
                    {
                        "username": "wjeevika",
                        "content": "This is a good question."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@wjeevika](/wjeevika) lmao why u reply to urself"
                    },
                    {
                        "username": "wjeevika",
                        "content": "I like it. "
                    },
                    {
                        "username": "ben_huang",
                        "content": "![image](https://assets.leetcode.com/users/ben_huang/image_1552672771.png)\\n"
                    },
                    {
                        "username": "sweetiemelody",
                        "content": "who can explain the 0-ms solution? Thank you a lot."
                    },
                    {
                        "username": "bboczeng",
                        "content": "What does this mean in terms of a binary tree?"
                    },
                    {
                        "username": "manodupont",
                        "content": "Why is this working correctly in VSCode, but not in here ?\n**Use Case**\nroot =\n[4,9,0,5,1]\n\n**Code**\n```\nlet sum = 0\nfunction dfs(node, path) {\n    if (node !== null) {\n        path += `${node.val}`\n\n        if (node.left == null && node.right == null) {// Its a leaf\n            console.log(path)\n            sum += parseInt(path)\n        }\n\n        dfs(node.left, path)\n        dfs(node.right, path)\n    }\n}\n\nfunction sumNumbers(root) {\n    dfs(root, '')\n    return sum\n};\n```\n"
                    },
                    {
                        "username": "garvit_17",
                        "content": "terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\n"
                    },
                    {
                        "username": "souravishere1996",
                        "content": "What to say about this easy approach??\\n\\nclass Solution {\\npublic:\\n\\n    int func(TreeNode* root,int sum)\\n    {\\n        if(!root){\\n          //  sum=sum*10+root->val;\\n            return 0;\\n        }\\n        if(!root->left && !root->right)\\n        {\\n            sum=sum*10+root->val;\\n            return sum;\\n        }\\n\\n        sum=sum*10+root->val;\\n        return func(root->left,sum) + func(root->right,sum);\\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n\\n        int sum=0;\\n        return func(root,sum);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "I would say - lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I like this question. Its similar to path sum I and II, so if you solved those then this should be easy too \\n\\nI found other \"easy\" tree questions to be harder than this one "
                    }
                ]
            },
            {
                "id": 2058609,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Should be marked as easy, joke question"
                    },
                    {
                        "username": "BryanBoCao",
                        "content": "In terms of [#129. Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/)\\nMy output for running the same code was different to that on the submit solution, which was \"1\" and \"10\" respectively, why?\\n![0_1467851352336_Screenshot from 2016-07-06 18:27:39.png](/uploads/files/1467851353053-screenshot-from-2016-07-06-18-27-39.png) \\n\\n[My submission](https://leetcode.com/submissions/detail/66362641/)"
                    },
                    {
                        "username": "wjeevika",
                        "content": "This is a good question."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@wjeevika](/wjeevika) lmao why u reply to urself"
                    },
                    {
                        "username": "wjeevika",
                        "content": "I like it. "
                    },
                    {
                        "username": "ben_huang",
                        "content": "![image](https://assets.leetcode.com/users/ben_huang/image_1552672771.png)\\n"
                    },
                    {
                        "username": "sweetiemelody",
                        "content": "who can explain the 0-ms solution? Thank you a lot."
                    },
                    {
                        "username": "bboczeng",
                        "content": "What does this mean in terms of a binary tree?"
                    },
                    {
                        "username": "manodupont",
                        "content": "Why is this working correctly in VSCode, but not in here ?\n**Use Case**\nroot =\n[4,9,0,5,1]\n\n**Code**\n```\nlet sum = 0\nfunction dfs(node, path) {\n    if (node !== null) {\n        path += `${node.val}`\n\n        if (node.left == null && node.right == null) {// Its a leaf\n            console.log(path)\n            sum += parseInt(path)\n        }\n\n        dfs(node.left, path)\n        dfs(node.right, path)\n    }\n}\n\nfunction sumNumbers(root) {\n    dfs(root, '')\n    return sum\n};\n```\n"
                    },
                    {
                        "username": "garvit_17",
                        "content": "terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\n"
                    },
                    {
                        "username": "souravishere1996",
                        "content": "What to say about this easy approach??\\n\\nclass Solution {\\npublic:\\n\\n    int func(TreeNode* root,int sum)\\n    {\\n        if(!root){\\n          //  sum=sum*10+root->val;\\n            return 0;\\n        }\\n        if(!root->left && !root->right)\\n        {\\n            sum=sum*10+root->val;\\n            return sum;\\n        }\\n\\n        sum=sum*10+root->val;\\n        return func(root->left,sum) + func(root->right,sum);\\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n\\n        int sum=0;\\n        return func(root,sum);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "I would say - lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I like this question. Its similar to path sum I and II, so if you solved those then this should be easy too \\n\\nI found other \"easy\" tree questions to be harder than this one "
                    }
                ]
            },
            {
                "id": 2003736,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Should be marked as easy, joke question"
                    },
                    {
                        "username": "BryanBoCao",
                        "content": "In terms of [#129. Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/)\\nMy output for running the same code was different to that on the submit solution, which was \"1\" and \"10\" respectively, why?\\n![0_1467851352336_Screenshot from 2016-07-06 18:27:39.png](/uploads/files/1467851353053-screenshot-from-2016-07-06-18-27-39.png) \\n\\n[My submission](https://leetcode.com/submissions/detail/66362641/)"
                    },
                    {
                        "username": "wjeevika",
                        "content": "This is a good question."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@wjeevika](/wjeevika) lmao why u reply to urself"
                    },
                    {
                        "username": "wjeevika",
                        "content": "I like it. "
                    },
                    {
                        "username": "ben_huang",
                        "content": "![image](https://assets.leetcode.com/users/ben_huang/image_1552672771.png)\\n"
                    },
                    {
                        "username": "sweetiemelody",
                        "content": "who can explain the 0-ms solution? Thank you a lot."
                    },
                    {
                        "username": "bboczeng",
                        "content": "What does this mean in terms of a binary tree?"
                    },
                    {
                        "username": "manodupont",
                        "content": "Why is this working correctly in VSCode, but not in here ?\n**Use Case**\nroot =\n[4,9,0,5,1]\n\n**Code**\n```\nlet sum = 0\nfunction dfs(node, path) {\n    if (node !== null) {\n        path += `${node.val}`\n\n        if (node.left == null && node.right == null) {// Its a leaf\n            console.log(path)\n            sum += parseInt(path)\n        }\n\n        dfs(node.left, path)\n        dfs(node.right, path)\n    }\n}\n\nfunction sumNumbers(root) {\n    dfs(root, '')\n    return sum\n};\n```\n"
                    },
                    {
                        "username": "garvit_17",
                        "content": "terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\n"
                    },
                    {
                        "username": "souravishere1996",
                        "content": "What to say about this easy approach??\\n\\nclass Solution {\\npublic:\\n\\n    int func(TreeNode* root,int sum)\\n    {\\n        if(!root){\\n          //  sum=sum*10+root->val;\\n            return 0;\\n        }\\n        if(!root->left && !root->right)\\n        {\\n            sum=sum*10+root->val;\\n            return sum;\\n        }\\n\\n        sum=sum*10+root->val;\\n        return func(root->left,sum) + func(root->right,sum);\\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n\\n        int sum=0;\\n        return func(root,sum);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "I would say - lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I like this question. Its similar to path sum I and II, so if you solved those then this should be easy too \\n\\nI found other \"easy\" tree questions to be harder than this one "
                    }
                ]
            },
            {
                "id": 1948682,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Should be marked as easy, joke question"
                    },
                    {
                        "username": "BryanBoCao",
                        "content": "In terms of [#129. Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/)\\nMy output for running the same code was different to that on the submit solution, which was \"1\" and \"10\" respectively, why?\\n![0_1467851352336_Screenshot from 2016-07-06 18:27:39.png](/uploads/files/1467851353053-screenshot-from-2016-07-06-18-27-39.png) \\n\\n[My submission](https://leetcode.com/submissions/detail/66362641/)"
                    },
                    {
                        "username": "wjeevika",
                        "content": "This is a good question."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@wjeevika](/wjeevika) lmao why u reply to urself"
                    },
                    {
                        "username": "wjeevika",
                        "content": "I like it. "
                    },
                    {
                        "username": "ben_huang",
                        "content": "![image](https://assets.leetcode.com/users/ben_huang/image_1552672771.png)\\n"
                    },
                    {
                        "username": "sweetiemelody",
                        "content": "who can explain the 0-ms solution? Thank you a lot."
                    },
                    {
                        "username": "bboczeng",
                        "content": "What does this mean in terms of a binary tree?"
                    },
                    {
                        "username": "manodupont",
                        "content": "Why is this working correctly in VSCode, but not in here ?\n**Use Case**\nroot =\n[4,9,0,5,1]\n\n**Code**\n```\nlet sum = 0\nfunction dfs(node, path) {\n    if (node !== null) {\n        path += `${node.val}`\n\n        if (node.left == null && node.right == null) {// Its a leaf\n            console.log(path)\n            sum += parseInt(path)\n        }\n\n        dfs(node.left, path)\n        dfs(node.right, path)\n    }\n}\n\nfunction sumNumbers(root) {\n    dfs(root, '')\n    return sum\n};\n```\n"
                    },
                    {
                        "username": "garvit_17",
                        "content": "terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\n"
                    },
                    {
                        "username": "souravishere1996",
                        "content": "What to say about this easy approach??\\n\\nclass Solution {\\npublic:\\n\\n    int func(TreeNode* root,int sum)\\n    {\\n        if(!root){\\n          //  sum=sum*10+root->val;\\n            return 0;\\n        }\\n        if(!root->left && !root->right)\\n        {\\n            sum=sum*10+root->val;\\n            return sum;\\n        }\\n\\n        sum=sum*10+root->val;\\n        return func(root->left,sum) + func(root->right,sum);\\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n\\n        int sum=0;\\n        return func(root,sum);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "I would say - lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I like this question. Its similar to path sum I and II, so if you solved those then this should be easy too \\n\\nI found other \"easy\" tree questions to be harder than this one "
                    }
                ]
            },
            {
                "id": 1933355,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Should be marked as easy, joke question"
                    },
                    {
                        "username": "BryanBoCao",
                        "content": "In terms of [#129. Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/)\\nMy output for running the same code was different to that on the submit solution, which was \"1\" and \"10\" respectively, why?\\n![0_1467851352336_Screenshot from 2016-07-06 18:27:39.png](/uploads/files/1467851353053-screenshot-from-2016-07-06-18-27-39.png) \\n\\n[My submission](https://leetcode.com/submissions/detail/66362641/)"
                    },
                    {
                        "username": "wjeevika",
                        "content": "This is a good question."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@wjeevika](/wjeevika) lmao why u reply to urself"
                    },
                    {
                        "username": "wjeevika",
                        "content": "I like it. "
                    },
                    {
                        "username": "ben_huang",
                        "content": "![image](https://assets.leetcode.com/users/ben_huang/image_1552672771.png)\\n"
                    },
                    {
                        "username": "sweetiemelody",
                        "content": "who can explain the 0-ms solution? Thank you a lot."
                    },
                    {
                        "username": "bboczeng",
                        "content": "What does this mean in terms of a binary tree?"
                    },
                    {
                        "username": "manodupont",
                        "content": "Why is this working correctly in VSCode, but not in here ?\n**Use Case**\nroot =\n[4,9,0,5,1]\n\n**Code**\n```\nlet sum = 0\nfunction dfs(node, path) {\n    if (node !== null) {\n        path += `${node.val}`\n\n        if (node.left == null && node.right == null) {// Its a leaf\n            console.log(path)\n            sum += parseInt(path)\n        }\n\n        dfs(node.left, path)\n        dfs(node.right, path)\n    }\n}\n\nfunction sumNumbers(root) {\n    dfs(root, '')\n    return sum\n};\n```\n"
                    },
                    {
                        "username": "garvit_17",
                        "content": "terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\n"
                    },
                    {
                        "username": "souravishere1996",
                        "content": "What to say about this easy approach??\\n\\nclass Solution {\\npublic:\\n\\n    int func(TreeNode* root,int sum)\\n    {\\n        if(!root){\\n          //  sum=sum*10+root->val;\\n            return 0;\\n        }\\n        if(!root->left && !root->right)\\n        {\\n            sum=sum*10+root->val;\\n            return sum;\\n        }\\n\\n        sum=sum*10+root->val;\\n        return func(root->left,sum) + func(root->right,sum);\\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n\\n        int sum=0;\\n        return func(root,sum);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "I would say - lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I like this question. Its similar to path sum I and II, so if you solved those then this should be easy too \\n\\nI found other \"easy\" tree questions to be harder than this one "
                    }
                ]
            },
            {
                "id": 1876676,
                "content": [
                    {
                        "username": "Aditya_Prajapati",
                        "content": "What are the other approaches other than recursion possible for this question ?"
                    },
                    {
                        "username": "Kinszs",
                        "content": "When I type my solution, I am having a error that I cant solve. \\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        enum State{Unvisited, Visited, Visiting; }\\n         boolean search(Graph grade, Node start, Node end){\\n             if(start == end) return true;\\n\\n             LinkedList<Node> queue = new LinkedList<Node>();\\n             for(Node u : grade.getNodes()){\\n                 u.state = State.Unvisited;\\n             }\\n             start.state = State.Visiting;\\n             queue.add(start);\\n             Node u;\\n             while(!queue.isEmpty()){\\n                 u = queue.removeFirst();\\n                 if(u != null){\\n                     for(Node v : u.getAdjacent()){\\n                         if(v.state == State.Unvisited){\\n                             if(v == end){\\n                                 return true;\\n                             }else{\\n                                 v.state = State.Visiting;\\n                                 queue.add(v);\\n                             }\\n                         }\\n                     }\\n                     u.state = State.Visited;\\n                 }\\n             }\\n         }\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Kinszs",
                        "content": "IMO the best approach to solving this would be to use DFS. What do you guys think?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem can be solved as DFS or BFS!"
                    },
                    {
                        "username": "theAchiever",
                        "content": "Can anyone please explain to me why this code won\\'t work?\\n\\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        else if(root.left==null&&root.right==null)\\n            return root.val;\\n        else{\\n            int sum1=root.val*10+sumNumbers(root.left);\\n            int sum2=root.val*10+sumNumbers(root.right);\\n            return sum1+sum2;\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "why is it that when I\\'m running my code on my vs code its giving the right output but here it somehow gives the wrong output ?"
                    },
                    {
                        "username": "Msey",
                        "content": "Tree week :)"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "We are given a binary tree and we need to traverse from root to leaf and then form a number.Likewise, repeat the path traversals and form all possible numbers from root to leaf.Finally, find the sum of all these numbers formed and return as answer.From the below code you can see how we can solve this problem using recursion or dfs (depth first search).\\nWe have declare ans as global variable to use it in both the method and store the final ans.\\n\\nCode : \\n\\nclass Solution {\\n    int ans = 0;\\n    public int sumNumbers(TreeNode root) {\\n        if(root==null) return 0;\\n        dfs(root,0);\\n        return ans;\\n    }\\n    public void dfs(TreeNode root, int val){\\n        if(root==null) return ;\\n        val*=10;\\n        val += root.val;\\n        if(root.left==null && root.right==null){\\n            ans+=val;\\n            return;\\n        }\\n        dfs(root.left,val);\\n        dfs(root.right,val);\\n    }\\n\\n}"
                    },
                    {
                        "username": "shaikirfan2349",
                        "content": "pls help me.....My code giving output as \\'0\\'\\n\\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        Pair<TreeNode,Integer> pair=new Pair(root,0);\\n        Queue<Pair<TreeNode,Integer>> q=new LinkedList();\\n        ArrayList<Integer> leaf = new ArrayList<Integer>();\\n\\n        q.add(pair);\\n        \\n        int totalSum=0;\\n        while(!q.isEmpty()){\\n            int currSum=0;\\n            Pair<TreeNode,Integer> p=q.remove();\\n            currSum=(currSum*10)+p.getKey().val;\\n            if(root.left==null && root.right==null){\\n                leaf.add(currSum);\\n                \\n            }\\n\\n            if(p.getKey().left!=null){\\n                q.add(new Pair(p.getKey().left,p.getValue()+currSum));\\n            }\\n            if(p.getKey().right!=null){\\n                q.add(new Pair(p.getKey().right,p.getValue()+currSum));\\n            }\\n        }\\n        for(int i:leaf){\\n            totalSum+=i;\\n        }\\n\\n        return totalSum;\\n    }\\n}"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is a Simple Approach (BFS):-\\n\\n1. Initialize a queue and add the root of the binary tree to it.\\n2. Initialize a variable to keep track of the sum of root-to-leaf numbers to 0.\\n3. While the queue is not empty, remove the first element from the queue and assign it to a node variable.\\n4. If the node is a leaf node (i.e., it has no left or right child), add its value to the sum variable.\\n5. If the node has a left child, update its value to be the value of the parent node multiplied by 10 and then added to its own value. Add the left child to the queue.\\n6. If the node has a right child, update its value in the same way and add the right child to the queue.\\n7. Repeat steps 3-6 until the queue is empty.\\n8. Return the sum variable."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "here is the code link for reference:-\\nhttps://leetcode.com/problems/sum-root-to-leaf-numbers/solutions/3296514/bfs-easy-to-understand-with-steps/"
                    }
                ]
            },
            {
                "id": 1840700,
                "content": [
                    {
                        "username": "Aditya_Prajapati",
                        "content": "What are the other approaches other than recursion possible for this question ?"
                    },
                    {
                        "username": "Kinszs",
                        "content": "When I type my solution, I am having a error that I cant solve. \\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        enum State{Unvisited, Visited, Visiting; }\\n         boolean search(Graph grade, Node start, Node end){\\n             if(start == end) return true;\\n\\n             LinkedList<Node> queue = new LinkedList<Node>();\\n             for(Node u : grade.getNodes()){\\n                 u.state = State.Unvisited;\\n             }\\n             start.state = State.Visiting;\\n             queue.add(start);\\n             Node u;\\n             while(!queue.isEmpty()){\\n                 u = queue.removeFirst();\\n                 if(u != null){\\n                     for(Node v : u.getAdjacent()){\\n                         if(v.state == State.Unvisited){\\n                             if(v == end){\\n                                 return true;\\n                             }else{\\n                                 v.state = State.Visiting;\\n                                 queue.add(v);\\n                             }\\n                         }\\n                     }\\n                     u.state = State.Visited;\\n                 }\\n             }\\n         }\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Kinszs",
                        "content": "IMO the best approach to solving this would be to use DFS. What do you guys think?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem can be solved as DFS or BFS!"
                    },
                    {
                        "username": "theAchiever",
                        "content": "Can anyone please explain to me why this code won\\'t work?\\n\\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        else if(root.left==null&&root.right==null)\\n            return root.val;\\n        else{\\n            int sum1=root.val*10+sumNumbers(root.left);\\n            int sum2=root.val*10+sumNumbers(root.right);\\n            return sum1+sum2;\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "why is it that when I\\'m running my code on my vs code its giving the right output but here it somehow gives the wrong output ?"
                    },
                    {
                        "username": "Msey",
                        "content": "Tree week :)"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "We are given a binary tree and we need to traverse from root to leaf and then form a number.Likewise, repeat the path traversals and form all possible numbers from root to leaf.Finally, find the sum of all these numbers formed and return as answer.From the below code you can see how we can solve this problem using recursion or dfs (depth first search).\\nWe have declare ans as global variable to use it in both the method and store the final ans.\\n\\nCode : \\n\\nclass Solution {\\n    int ans = 0;\\n    public int sumNumbers(TreeNode root) {\\n        if(root==null) return 0;\\n        dfs(root,0);\\n        return ans;\\n    }\\n    public void dfs(TreeNode root, int val){\\n        if(root==null) return ;\\n        val*=10;\\n        val += root.val;\\n        if(root.left==null && root.right==null){\\n            ans+=val;\\n            return;\\n        }\\n        dfs(root.left,val);\\n        dfs(root.right,val);\\n    }\\n\\n}"
                    },
                    {
                        "username": "shaikirfan2349",
                        "content": "pls help me.....My code giving output as \\'0\\'\\n\\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        Pair<TreeNode,Integer> pair=new Pair(root,0);\\n        Queue<Pair<TreeNode,Integer>> q=new LinkedList();\\n        ArrayList<Integer> leaf = new ArrayList<Integer>();\\n\\n        q.add(pair);\\n        \\n        int totalSum=0;\\n        while(!q.isEmpty()){\\n            int currSum=0;\\n            Pair<TreeNode,Integer> p=q.remove();\\n            currSum=(currSum*10)+p.getKey().val;\\n            if(root.left==null && root.right==null){\\n                leaf.add(currSum);\\n                \\n            }\\n\\n            if(p.getKey().left!=null){\\n                q.add(new Pair(p.getKey().left,p.getValue()+currSum));\\n            }\\n            if(p.getKey().right!=null){\\n                q.add(new Pair(p.getKey().right,p.getValue()+currSum));\\n            }\\n        }\\n        for(int i:leaf){\\n            totalSum+=i;\\n        }\\n\\n        return totalSum;\\n    }\\n}"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is a Simple Approach (BFS):-\\n\\n1. Initialize a queue and add the root of the binary tree to it.\\n2. Initialize a variable to keep track of the sum of root-to-leaf numbers to 0.\\n3. While the queue is not empty, remove the first element from the queue and assign it to a node variable.\\n4. If the node is a leaf node (i.e., it has no left or right child), add its value to the sum variable.\\n5. If the node has a left child, update its value to be the value of the parent node multiplied by 10 and then added to its own value. Add the left child to the queue.\\n6. If the node has a right child, update its value in the same way and add the right child to the queue.\\n7. Repeat steps 3-6 until the queue is empty.\\n8. Return the sum variable."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "here is the code link for reference:-\\nhttps://leetcode.com/problems/sum-root-to-leaf-numbers/solutions/3296514/bfs-easy-to-understand-with-steps/"
                    }
                ]
            },
            {
                "id": 1833310,
                "content": [
                    {
                        "username": "Aditya_Prajapati",
                        "content": "What are the other approaches other than recursion possible for this question ?"
                    },
                    {
                        "username": "Kinszs",
                        "content": "When I type my solution, I am having a error that I cant solve. \\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        enum State{Unvisited, Visited, Visiting; }\\n         boolean search(Graph grade, Node start, Node end){\\n             if(start == end) return true;\\n\\n             LinkedList<Node> queue = new LinkedList<Node>();\\n             for(Node u : grade.getNodes()){\\n                 u.state = State.Unvisited;\\n             }\\n             start.state = State.Visiting;\\n             queue.add(start);\\n             Node u;\\n             while(!queue.isEmpty()){\\n                 u = queue.removeFirst();\\n                 if(u != null){\\n                     for(Node v : u.getAdjacent()){\\n                         if(v.state == State.Unvisited){\\n                             if(v == end){\\n                                 return true;\\n                             }else{\\n                                 v.state = State.Visiting;\\n                                 queue.add(v);\\n                             }\\n                         }\\n                     }\\n                     u.state = State.Visited;\\n                 }\\n             }\\n         }\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Kinszs",
                        "content": "IMO the best approach to solving this would be to use DFS. What do you guys think?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem can be solved as DFS or BFS!"
                    },
                    {
                        "username": "theAchiever",
                        "content": "Can anyone please explain to me why this code won\\'t work?\\n\\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        else if(root.left==null&&root.right==null)\\n            return root.val;\\n        else{\\n            int sum1=root.val*10+sumNumbers(root.left);\\n            int sum2=root.val*10+sumNumbers(root.right);\\n            return sum1+sum2;\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "why is it that when I\\'m running my code on my vs code its giving the right output but here it somehow gives the wrong output ?"
                    },
                    {
                        "username": "Msey",
                        "content": "Tree week :)"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "We are given a binary tree and we need to traverse from root to leaf and then form a number.Likewise, repeat the path traversals and form all possible numbers from root to leaf.Finally, find the sum of all these numbers formed and return as answer.From the below code you can see how we can solve this problem using recursion or dfs (depth first search).\\nWe have declare ans as global variable to use it in both the method and store the final ans.\\n\\nCode : \\n\\nclass Solution {\\n    int ans = 0;\\n    public int sumNumbers(TreeNode root) {\\n        if(root==null) return 0;\\n        dfs(root,0);\\n        return ans;\\n    }\\n    public void dfs(TreeNode root, int val){\\n        if(root==null) return ;\\n        val*=10;\\n        val += root.val;\\n        if(root.left==null && root.right==null){\\n            ans+=val;\\n            return;\\n        }\\n        dfs(root.left,val);\\n        dfs(root.right,val);\\n    }\\n\\n}"
                    },
                    {
                        "username": "shaikirfan2349",
                        "content": "pls help me.....My code giving output as \\'0\\'\\n\\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        Pair<TreeNode,Integer> pair=new Pair(root,0);\\n        Queue<Pair<TreeNode,Integer>> q=new LinkedList();\\n        ArrayList<Integer> leaf = new ArrayList<Integer>();\\n\\n        q.add(pair);\\n        \\n        int totalSum=0;\\n        while(!q.isEmpty()){\\n            int currSum=0;\\n            Pair<TreeNode,Integer> p=q.remove();\\n            currSum=(currSum*10)+p.getKey().val;\\n            if(root.left==null && root.right==null){\\n                leaf.add(currSum);\\n                \\n            }\\n\\n            if(p.getKey().left!=null){\\n                q.add(new Pair(p.getKey().left,p.getValue()+currSum));\\n            }\\n            if(p.getKey().right!=null){\\n                q.add(new Pair(p.getKey().right,p.getValue()+currSum));\\n            }\\n        }\\n        for(int i:leaf){\\n            totalSum+=i;\\n        }\\n\\n        return totalSum;\\n    }\\n}"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is a Simple Approach (BFS):-\\n\\n1. Initialize a queue and add the root of the binary tree to it.\\n2. Initialize a variable to keep track of the sum of root-to-leaf numbers to 0.\\n3. While the queue is not empty, remove the first element from the queue and assign it to a node variable.\\n4. If the node is a leaf node (i.e., it has no left or right child), add its value to the sum variable.\\n5. If the node has a left child, update its value to be the value of the parent node multiplied by 10 and then added to its own value. Add the left child to the queue.\\n6. If the node has a right child, update its value in the same way and add the right child to the queue.\\n7. Repeat steps 3-6 until the queue is empty.\\n8. Return the sum variable."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "here is the code link for reference:-\\nhttps://leetcode.com/problems/sum-root-to-leaf-numbers/solutions/3296514/bfs-easy-to-understand-with-steps/"
                    }
                ]
            },
            {
                "id": 1832548,
                "content": [
                    {
                        "username": "Aditya_Prajapati",
                        "content": "What are the other approaches other than recursion possible for this question ?"
                    },
                    {
                        "username": "Kinszs",
                        "content": "When I type my solution, I am having a error that I cant solve. \\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        enum State{Unvisited, Visited, Visiting; }\\n         boolean search(Graph grade, Node start, Node end){\\n             if(start == end) return true;\\n\\n             LinkedList<Node> queue = new LinkedList<Node>();\\n             for(Node u : grade.getNodes()){\\n                 u.state = State.Unvisited;\\n             }\\n             start.state = State.Visiting;\\n             queue.add(start);\\n             Node u;\\n             while(!queue.isEmpty()){\\n                 u = queue.removeFirst();\\n                 if(u != null){\\n                     for(Node v : u.getAdjacent()){\\n                         if(v.state == State.Unvisited){\\n                             if(v == end){\\n                                 return true;\\n                             }else{\\n                                 v.state = State.Visiting;\\n                                 queue.add(v);\\n                             }\\n                         }\\n                     }\\n                     u.state = State.Visited;\\n                 }\\n             }\\n         }\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Kinszs",
                        "content": "IMO the best approach to solving this would be to use DFS. What do you guys think?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem can be solved as DFS or BFS!"
                    },
                    {
                        "username": "theAchiever",
                        "content": "Can anyone please explain to me why this code won\\'t work?\\n\\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        else if(root.left==null&&root.right==null)\\n            return root.val;\\n        else{\\n            int sum1=root.val*10+sumNumbers(root.left);\\n            int sum2=root.val*10+sumNumbers(root.right);\\n            return sum1+sum2;\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "why is it that when I\\'m running my code on my vs code its giving the right output but here it somehow gives the wrong output ?"
                    },
                    {
                        "username": "Msey",
                        "content": "Tree week :)"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "We are given a binary tree and we need to traverse from root to leaf and then form a number.Likewise, repeat the path traversals and form all possible numbers from root to leaf.Finally, find the sum of all these numbers formed and return as answer.From the below code you can see how we can solve this problem using recursion or dfs (depth first search).\\nWe have declare ans as global variable to use it in both the method and store the final ans.\\n\\nCode : \\n\\nclass Solution {\\n    int ans = 0;\\n    public int sumNumbers(TreeNode root) {\\n        if(root==null) return 0;\\n        dfs(root,0);\\n        return ans;\\n    }\\n    public void dfs(TreeNode root, int val){\\n        if(root==null) return ;\\n        val*=10;\\n        val += root.val;\\n        if(root.left==null && root.right==null){\\n            ans+=val;\\n            return;\\n        }\\n        dfs(root.left,val);\\n        dfs(root.right,val);\\n    }\\n\\n}"
                    },
                    {
                        "username": "shaikirfan2349",
                        "content": "pls help me.....My code giving output as \\'0\\'\\n\\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        Pair<TreeNode,Integer> pair=new Pair(root,0);\\n        Queue<Pair<TreeNode,Integer>> q=new LinkedList();\\n        ArrayList<Integer> leaf = new ArrayList<Integer>();\\n\\n        q.add(pair);\\n        \\n        int totalSum=0;\\n        while(!q.isEmpty()){\\n            int currSum=0;\\n            Pair<TreeNode,Integer> p=q.remove();\\n            currSum=(currSum*10)+p.getKey().val;\\n            if(root.left==null && root.right==null){\\n                leaf.add(currSum);\\n                \\n            }\\n\\n            if(p.getKey().left!=null){\\n                q.add(new Pair(p.getKey().left,p.getValue()+currSum));\\n            }\\n            if(p.getKey().right!=null){\\n                q.add(new Pair(p.getKey().right,p.getValue()+currSum));\\n            }\\n        }\\n        for(int i:leaf){\\n            totalSum+=i;\\n        }\\n\\n        return totalSum;\\n    }\\n}"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is a Simple Approach (BFS):-\\n\\n1. Initialize a queue and add the root of the binary tree to it.\\n2. Initialize a variable to keep track of the sum of root-to-leaf numbers to 0.\\n3. While the queue is not empty, remove the first element from the queue and assign it to a node variable.\\n4. If the node is a leaf node (i.e., it has no left or right child), add its value to the sum variable.\\n5. If the node has a left child, update its value to be the value of the parent node multiplied by 10 and then added to its own value. Add the left child to the queue.\\n6. If the node has a right child, update its value in the same way and add the right child to the queue.\\n7. Repeat steps 3-6 until the queue is empty.\\n8. Return the sum variable."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "here is the code link for reference:-\\nhttps://leetcode.com/problems/sum-root-to-leaf-numbers/solutions/3296514/bfs-easy-to-understand-with-steps/"
                    }
                ]
            },
            {
                "id": 1832524,
                "content": [
                    {
                        "username": "Aditya_Prajapati",
                        "content": "What are the other approaches other than recursion possible for this question ?"
                    },
                    {
                        "username": "Kinszs",
                        "content": "When I type my solution, I am having a error that I cant solve. \\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        enum State{Unvisited, Visited, Visiting; }\\n         boolean search(Graph grade, Node start, Node end){\\n             if(start == end) return true;\\n\\n             LinkedList<Node> queue = new LinkedList<Node>();\\n             for(Node u : grade.getNodes()){\\n                 u.state = State.Unvisited;\\n             }\\n             start.state = State.Visiting;\\n             queue.add(start);\\n             Node u;\\n             while(!queue.isEmpty()){\\n                 u = queue.removeFirst();\\n                 if(u != null){\\n                     for(Node v : u.getAdjacent()){\\n                         if(v.state == State.Unvisited){\\n                             if(v == end){\\n                                 return true;\\n                             }else{\\n                                 v.state = State.Visiting;\\n                                 queue.add(v);\\n                             }\\n                         }\\n                     }\\n                     u.state = State.Visited;\\n                 }\\n             }\\n         }\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Kinszs",
                        "content": "IMO the best approach to solving this would be to use DFS. What do you guys think?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem can be solved as DFS or BFS!"
                    },
                    {
                        "username": "theAchiever",
                        "content": "Can anyone please explain to me why this code won\\'t work?\\n\\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        else if(root.left==null&&root.right==null)\\n            return root.val;\\n        else{\\n            int sum1=root.val*10+sumNumbers(root.left);\\n            int sum2=root.val*10+sumNumbers(root.right);\\n            return sum1+sum2;\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "why is it that when I\\'m running my code on my vs code its giving the right output but here it somehow gives the wrong output ?"
                    },
                    {
                        "username": "Msey",
                        "content": "Tree week :)"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "We are given a binary tree and we need to traverse from root to leaf and then form a number.Likewise, repeat the path traversals and form all possible numbers from root to leaf.Finally, find the sum of all these numbers formed and return as answer.From the below code you can see how we can solve this problem using recursion or dfs (depth first search).\\nWe have declare ans as global variable to use it in both the method and store the final ans.\\n\\nCode : \\n\\nclass Solution {\\n    int ans = 0;\\n    public int sumNumbers(TreeNode root) {\\n        if(root==null) return 0;\\n        dfs(root,0);\\n        return ans;\\n    }\\n    public void dfs(TreeNode root, int val){\\n        if(root==null) return ;\\n        val*=10;\\n        val += root.val;\\n        if(root.left==null && root.right==null){\\n            ans+=val;\\n            return;\\n        }\\n        dfs(root.left,val);\\n        dfs(root.right,val);\\n    }\\n\\n}"
                    },
                    {
                        "username": "shaikirfan2349",
                        "content": "pls help me.....My code giving output as \\'0\\'\\n\\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        Pair<TreeNode,Integer> pair=new Pair(root,0);\\n        Queue<Pair<TreeNode,Integer>> q=new LinkedList();\\n        ArrayList<Integer> leaf = new ArrayList<Integer>();\\n\\n        q.add(pair);\\n        \\n        int totalSum=0;\\n        while(!q.isEmpty()){\\n            int currSum=0;\\n            Pair<TreeNode,Integer> p=q.remove();\\n            currSum=(currSum*10)+p.getKey().val;\\n            if(root.left==null && root.right==null){\\n                leaf.add(currSum);\\n                \\n            }\\n\\n            if(p.getKey().left!=null){\\n                q.add(new Pair(p.getKey().left,p.getValue()+currSum));\\n            }\\n            if(p.getKey().right!=null){\\n                q.add(new Pair(p.getKey().right,p.getValue()+currSum));\\n            }\\n        }\\n        for(int i:leaf){\\n            totalSum+=i;\\n        }\\n\\n        return totalSum;\\n    }\\n}"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is a Simple Approach (BFS):-\\n\\n1. Initialize a queue and add the root of the binary tree to it.\\n2. Initialize a variable to keep track of the sum of root-to-leaf numbers to 0.\\n3. While the queue is not empty, remove the first element from the queue and assign it to a node variable.\\n4. If the node is a leaf node (i.e., it has no left or right child), add its value to the sum variable.\\n5. If the node has a left child, update its value to be the value of the parent node multiplied by 10 and then added to its own value. Add the left child to the queue.\\n6. If the node has a right child, update its value in the same way and add the right child to the queue.\\n7. Repeat steps 3-6 until the queue is empty.\\n8. Return the sum variable."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "here is the code link for reference:-\\nhttps://leetcode.com/problems/sum-root-to-leaf-numbers/solutions/3296514/bfs-easy-to-understand-with-steps/"
                    }
                ]
            },
            {
                "id": 1832381,
                "content": [
                    {
                        "username": "Aditya_Prajapati",
                        "content": "What are the other approaches other than recursion possible for this question ?"
                    },
                    {
                        "username": "Kinszs",
                        "content": "When I type my solution, I am having a error that I cant solve. \\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        enum State{Unvisited, Visited, Visiting; }\\n         boolean search(Graph grade, Node start, Node end){\\n             if(start == end) return true;\\n\\n             LinkedList<Node> queue = new LinkedList<Node>();\\n             for(Node u : grade.getNodes()){\\n                 u.state = State.Unvisited;\\n             }\\n             start.state = State.Visiting;\\n             queue.add(start);\\n             Node u;\\n             while(!queue.isEmpty()){\\n                 u = queue.removeFirst();\\n                 if(u != null){\\n                     for(Node v : u.getAdjacent()){\\n                         if(v.state == State.Unvisited){\\n                             if(v == end){\\n                                 return true;\\n                             }else{\\n                                 v.state = State.Visiting;\\n                                 queue.add(v);\\n                             }\\n                         }\\n                     }\\n                     u.state = State.Visited;\\n                 }\\n             }\\n         }\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Kinszs",
                        "content": "IMO the best approach to solving this would be to use DFS. What do you guys think?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem can be solved as DFS or BFS!"
                    },
                    {
                        "username": "theAchiever",
                        "content": "Can anyone please explain to me why this code won\\'t work?\\n\\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        else if(root.left==null&&root.right==null)\\n            return root.val;\\n        else{\\n            int sum1=root.val*10+sumNumbers(root.left);\\n            int sum2=root.val*10+sumNumbers(root.right);\\n            return sum1+sum2;\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "why is it that when I\\'m running my code on my vs code its giving the right output but here it somehow gives the wrong output ?"
                    },
                    {
                        "username": "Msey",
                        "content": "Tree week :)"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "We are given a binary tree and we need to traverse from root to leaf and then form a number.Likewise, repeat the path traversals and form all possible numbers from root to leaf.Finally, find the sum of all these numbers formed and return as answer.From the below code you can see how we can solve this problem using recursion or dfs (depth first search).\\nWe have declare ans as global variable to use it in both the method and store the final ans.\\n\\nCode : \\n\\nclass Solution {\\n    int ans = 0;\\n    public int sumNumbers(TreeNode root) {\\n        if(root==null) return 0;\\n        dfs(root,0);\\n        return ans;\\n    }\\n    public void dfs(TreeNode root, int val){\\n        if(root==null) return ;\\n        val*=10;\\n        val += root.val;\\n        if(root.left==null && root.right==null){\\n            ans+=val;\\n            return;\\n        }\\n        dfs(root.left,val);\\n        dfs(root.right,val);\\n    }\\n\\n}"
                    },
                    {
                        "username": "shaikirfan2349",
                        "content": "pls help me.....My code giving output as \\'0\\'\\n\\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        Pair<TreeNode,Integer> pair=new Pair(root,0);\\n        Queue<Pair<TreeNode,Integer>> q=new LinkedList();\\n        ArrayList<Integer> leaf = new ArrayList<Integer>();\\n\\n        q.add(pair);\\n        \\n        int totalSum=0;\\n        while(!q.isEmpty()){\\n            int currSum=0;\\n            Pair<TreeNode,Integer> p=q.remove();\\n            currSum=(currSum*10)+p.getKey().val;\\n            if(root.left==null && root.right==null){\\n                leaf.add(currSum);\\n                \\n            }\\n\\n            if(p.getKey().left!=null){\\n                q.add(new Pair(p.getKey().left,p.getValue()+currSum));\\n            }\\n            if(p.getKey().right!=null){\\n                q.add(new Pair(p.getKey().right,p.getValue()+currSum));\\n            }\\n        }\\n        for(int i:leaf){\\n            totalSum+=i;\\n        }\\n\\n        return totalSum;\\n    }\\n}"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is a Simple Approach (BFS):-\\n\\n1. Initialize a queue and add the root of the binary tree to it.\\n2. Initialize a variable to keep track of the sum of root-to-leaf numbers to 0.\\n3. While the queue is not empty, remove the first element from the queue and assign it to a node variable.\\n4. If the node is a leaf node (i.e., it has no left or right child), add its value to the sum variable.\\n5. If the node has a left child, update its value to be the value of the parent node multiplied by 10 and then added to its own value. Add the left child to the queue.\\n6. If the node has a right child, update its value in the same way and add the right child to the queue.\\n7. Repeat steps 3-6 until the queue is empty.\\n8. Return the sum variable."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "here is the code link for reference:-\\nhttps://leetcode.com/problems/sum-root-to-leaf-numbers/solutions/3296514/bfs-easy-to-understand-with-steps/"
                    }
                ]
            },
            {
                "id": 1832375,
                "content": [
                    {
                        "username": "Aditya_Prajapati",
                        "content": "What are the other approaches other than recursion possible for this question ?"
                    },
                    {
                        "username": "Kinszs",
                        "content": "When I type my solution, I am having a error that I cant solve. \\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        enum State{Unvisited, Visited, Visiting; }\\n         boolean search(Graph grade, Node start, Node end){\\n             if(start == end) return true;\\n\\n             LinkedList<Node> queue = new LinkedList<Node>();\\n             for(Node u : grade.getNodes()){\\n                 u.state = State.Unvisited;\\n             }\\n             start.state = State.Visiting;\\n             queue.add(start);\\n             Node u;\\n             while(!queue.isEmpty()){\\n                 u = queue.removeFirst();\\n                 if(u != null){\\n                     for(Node v : u.getAdjacent()){\\n                         if(v.state == State.Unvisited){\\n                             if(v == end){\\n                                 return true;\\n                             }else{\\n                                 v.state = State.Visiting;\\n                                 queue.add(v);\\n                             }\\n                         }\\n                     }\\n                     u.state = State.Visited;\\n                 }\\n             }\\n         }\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Kinszs",
                        "content": "IMO the best approach to solving this would be to use DFS. What do you guys think?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem can be solved as DFS or BFS!"
                    },
                    {
                        "username": "theAchiever",
                        "content": "Can anyone please explain to me why this code won\\'t work?\\n\\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        else if(root.left==null&&root.right==null)\\n            return root.val;\\n        else{\\n            int sum1=root.val*10+sumNumbers(root.left);\\n            int sum2=root.val*10+sumNumbers(root.right);\\n            return sum1+sum2;\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "why is it that when I\\'m running my code on my vs code its giving the right output but here it somehow gives the wrong output ?"
                    },
                    {
                        "username": "Msey",
                        "content": "Tree week :)"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "We are given a binary tree and we need to traverse from root to leaf and then form a number.Likewise, repeat the path traversals and form all possible numbers from root to leaf.Finally, find the sum of all these numbers formed and return as answer.From the below code you can see how we can solve this problem using recursion or dfs (depth first search).\\nWe have declare ans as global variable to use it in both the method and store the final ans.\\n\\nCode : \\n\\nclass Solution {\\n    int ans = 0;\\n    public int sumNumbers(TreeNode root) {\\n        if(root==null) return 0;\\n        dfs(root,0);\\n        return ans;\\n    }\\n    public void dfs(TreeNode root, int val){\\n        if(root==null) return ;\\n        val*=10;\\n        val += root.val;\\n        if(root.left==null && root.right==null){\\n            ans+=val;\\n            return;\\n        }\\n        dfs(root.left,val);\\n        dfs(root.right,val);\\n    }\\n\\n}"
                    },
                    {
                        "username": "shaikirfan2349",
                        "content": "pls help me.....My code giving output as \\'0\\'\\n\\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        Pair<TreeNode,Integer> pair=new Pair(root,0);\\n        Queue<Pair<TreeNode,Integer>> q=new LinkedList();\\n        ArrayList<Integer> leaf = new ArrayList<Integer>();\\n\\n        q.add(pair);\\n        \\n        int totalSum=0;\\n        while(!q.isEmpty()){\\n            int currSum=0;\\n            Pair<TreeNode,Integer> p=q.remove();\\n            currSum=(currSum*10)+p.getKey().val;\\n            if(root.left==null && root.right==null){\\n                leaf.add(currSum);\\n                \\n            }\\n\\n            if(p.getKey().left!=null){\\n                q.add(new Pair(p.getKey().left,p.getValue()+currSum));\\n            }\\n            if(p.getKey().right!=null){\\n                q.add(new Pair(p.getKey().right,p.getValue()+currSum));\\n            }\\n        }\\n        for(int i:leaf){\\n            totalSum+=i;\\n        }\\n\\n        return totalSum;\\n    }\\n}"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is a Simple Approach (BFS):-\\n\\n1. Initialize a queue and add the root of the binary tree to it.\\n2. Initialize a variable to keep track of the sum of root-to-leaf numbers to 0.\\n3. While the queue is not empty, remove the first element from the queue and assign it to a node variable.\\n4. If the node is a leaf node (i.e., it has no left or right child), add its value to the sum variable.\\n5. If the node has a left child, update its value to be the value of the parent node multiplied by 10 and then added to its own value. Add the left child to the queue.\\n6. If the node has a right child, update its value in the same way and add the right child to the queue.\\n7. Repeat steps 3-6 until the queue is empty.\\n8. Return the sum variable."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "here is the code link for reference:-\\nhttps://leetcode.com/problems/sum-root-to-leaf-numbers/solutions/3296514/bfs-easy-to-understand-with-steps/"
                    }
                ]
            },
            {
                "id": 1832357,
                "content": [
                    {
                        "username": "Aditya_Prajapati",
                        "content": "What are the other approaches other than recursion possible for this question ?"
                    },
                    {
                        "username": "Kinszs",
                        "content": "When I type my solution, I am having a error that I cant solve. \\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        enum State{Unvisited, Visited, Visiting; }\\n         boolean search(Graph grade, Node start, Node end){\\n             if(start == end) return true;\\n\\n             LinkedList<Node> queue = new LinkedList<Node>();\\n             for(Node u : grade.getNodes()){\\n                 u.state = State.Unvisited;\\n             }\\n             start.state = State.Visiting;\\n             queue.add(start);\\n             Node u;\\n             while(!queue.isEmpty()){\\n                 u = queue.removeFirst();\\n                 if(u != null){\\n                     for(Node v : u.getAdjacent()){\\n                         if(v.state == State.Unvisited){\\n                             if(v == end){\\n                                 return true;\\n                             }else{\\n                                 v.state = State.Visiting;\\n                                 queue.add(v);\\n                             }\\n                         }\\n                     }\\n                     u.state = State.Visited;\\n                 }\\n             }\\n         }\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Kinszs",
                        "content": "IMO the best approach to solving this would be to use DFS. What do you guys think?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem can be solved as DFS or BFS!"
                    },
                    {
                        "username": "theAchiever",
                        "content": "Can anyone please explain to me why this code won\\'t work?\\n\\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        else if(root.left==null&&root.right==null)\\n            return root.val;\\n        else{\\n            int sum1=root.val*10+sumNumbers(root.left);\\n            int sum2=root.val*10+sumNumbers(root.right);\\n            return sum1+sum2;\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "why is it that when I\\'m running my code on my vs code its giving the right output but here it somehow gives the wrong output ?"
                    },
                    {
                        "username": "Msey",
                        "content": "Tree week :)"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "We are given a binary tree and we need to traverse from root to leaf and then form a number.Likewise, repeat the path traversals and form all possible numbers from root to leaf.Finally, find the sum of all these numbers formed and return as answer.From the below code you can see how we can solve this problem using recursion or dfs (depth first search).\\nWe have declare ans as global variable to use it in both the method and store the final ans.\\n\\nCode : \\n\\nclass Solution {\\n    int ans = 0;\\n    public int sumNumbers(TreeNode root) {\\n        if(root==null) return 0;\\n        dfs(root,0);\\n        return ans;\\n    }\\n    public void dfs(TreeNode root, int val){\\n        if(root==null) return ;\\n        val*=10;\\n        val += root.val;\\n        if(root.left==null && root.right==null){\\n            ans+=val;\\n            return;\\n        }\\n        dfs(root.left,val);\\n        dfs(root.right,val);\\n    }\\n\\n}"
                    },
                    {
                        "username": "shaikirfan2349",
                        "content": "pls help me.....My code giving output as \\'0\\'\\n\\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        Pair<TreeNode,Integer> pair=new Pair(root,0);\\n        Queue<Pair<TreeNode,Integer>> q=new LinkedList();\\n        ArrayList<Integer> leaf = new ArrayList<Integer>();\\n\\n        q.add(pair);\\n        \\n        int totalSum=0;\\n        while(!q.isEmpty()){\\n            int currSum=0;\\n            Pair<TreeNode,Integer> p=q.remove();\\n            currSum=(currSum*10)+p.getKey().val;\\n            if(root.left==null && root.right==null){\\n                leaf.add(currSum);\\n                \\n            }\\n\\n            if(p.getKey().left!=null){\\n                q.add(new Pair(p.getKey().left,p.getValue()+currSum));\\n            }\\n            if(p.getKey().right!=null){\\n                q.add(new Pair(p.getKey().right,p.getValue()+currSum));\\n            }\\n        }\\n        for(int i:leaf){\\n            totalSum+=i;\\n        }\\n\\n        return totalSum;\\n    }\\n}"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is a Simple Approach (BFS):-\\n\\n1. Initialize a queue and add the root of the binary tree to it.\\n2. Initialize a variable to keep track of the sum of root-to-leaf numbers to 0.\\n3. While the queue is not empty, remove the first element from the queue and assign it to a node variable.\\n4. If the node is a leaf node (i.e., it has no left or right child), add its value to the sum variable.\\n5. If the node has a left child, update its value to be the value of the parent node multiplied by 10 and then added to its own value. Add the left child to the queue.\\n6. If the node has a right child, update its value in the same way and add the right child to the queue.\\n7. Repeat steps 3-6 until the queue is empty.\\n8. Return the sum variable."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "here is the code link for reference:-\\nhttps://leetcode.com/problems/sum-root-to-leaf-numbers/solutions/3296514/bfs-easy-to-understand-with-steps/"
                    }
                ]
            },
            {
                "id": 1832243,
                "content": [
                    {
                        "username": "Aditya_Prajapati",
                        "content": "What are the other approaches other than recursion possible for this question ?"
                    },
                    {
                        "username": "Kinszs",
                        "content": "When I type my solution, I am having a error that I cant solve. \\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        enum State{Unvisited, Visited, Visiting; }\\n         boolean search(Graph grade, Node start, Node end){\\n             if(start == end) return true;\\n\\n             LinkedList<Node> queue = new LinkedList<Node>();\\n             for(Node u : grade.getNodes()){\\n                 u.state = State.Unvisited;\\n             }\\n             start.state = State.Visiting;\\n             queue.add(start);\\n             Node u;\\n             while(!queue.isEmpty()){\\n                 u = queue.removeFirst();\\n                 if(u != null){\\n                     for(Node v : u.getAdjacent()){\\n                         if(v.state == State.Unvisited){\\n                             if(v == end){\\n                                 return true;\\n                             }else{\\n                                 v.state = State.Visiting;\\n                                 queue.add(v);\\n                             }\\n                         }\\n                     }\\n                     u.state = State.Visited;\\n                 }\\n             }\\n         }\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Kinszs",
                        "content": "IMO the best approach to solving this would be to use DFS. What do you guys think?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem can be solved as DFS or BFS!"
                    },
                    {
                        "username": "theAchiever",
                        "content": "Can anyone please explain to me why this code won\\'t work?\\n\\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        else if(root.left==null&&root.right==null)\\n            return root.val;\\n        else{\\n            int sum1=root.val*10+sumNumbers(root.left);\\n            int sum2=root.val*10+sumNumbers(root.right);\\n            return sum1+sum2;\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "why is it that when I\\'m running my code on my vs code its giving the right output but here it somehow gives the wrong output ?"
                    },
                    {
                        "username": "Msey",
                        "content": "Tree week :)"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "We are given a binary tree and we need to traverse from root to leaf and then form a number.Likewise, repeat the path traversals and form all possible numbers from root to leaf.Finally, find the sum of all these numbers formed and return as answer.From the below code you can see how we can solve this problem using recursion or dfs (depth first search).\\nWe have declare ans as global variable to use it in both the method and store the final ans.\\n\\nCode : \\n\\nclass Solution {\\n    int ans = 0;\\n    public int sumNumbers(TreeNode root) {\\n        if(root==null) return 0;\\n        dfs(root,0);\\n        return ans;\\n    }\\n    public void dfs(TreeNode root, int val){\\n        if(root==null) return ;\\n        val*=10;\\n        val += root.val;\\n        if(root.left==null && root.right==null){\\n            ans+=val;\\n            return;\\n        }\\n        dfs(root.left,val);\\n        dfs(root.right,val);\\n    }\\n\\n}"
                    },
                    {
                        "username": "shaikirfan2349",
                        "content": "pls help me.....My code giving output as \\'0\\'\\n\\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        Pair<TreeNode,Integer> pair=new Pair(root,0);\\n        Queue<Pair<TreeNode,Integer>> q=new LinkedList();\\n        ArrayList<Integer> leaf = new ArrayList<Integer>();\\n\\n        q.add(pair);\\n        \\n        int totalSum=0;\\n        while(!q.isEmpty()){\\n            int currSum=0;\\n            Pair<TreeNode,Integer> p=q.remove();\\n            currSum=(currSum*10)+p.getKey().val;\\n            if(root.left==null && root.right==null){\\n                leaf.add(currSum);\\n                \\n            }\\n\\n            if(p.getKey().left!=null){\\n                q.add(new Pair(p.getKey().left,p.getValue()+currSum));\\n            }\\n            if(p.getKey().right!=null){\\n                q.add(new Pair(p.getKey().right,p.getValue()+currSum));\\n            }\\n        }\\n        for(int i:leaf){\\n            totalSum+=i;\\n        }\\n\\n        return totalSum;\\n    }\\n}"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is a Simple Approach (BFS):-\\n\\n1. Initialize a queue and add the root of the binary tree to it.\\n2. Initialize a variable to keep track of the sum of root-to-leaf numbers to 0.\\n3. While the queue is not empty, remove the first element from the queue and assign it to a node variable.\\n4. If the node is a leaf node (i.e., it has no left or right child), add its value to the sum variable.\\n5. If the node has a left child, update its value to be the value of the parent node multiplied by 10 and then added to its own value. Add the left child to the queue.\\n6. If the node has a right child, update its value in the same way and add the right child to the queue.\\n7. Repeat steps 3-6 until the queue is empty.\\n8. Return the sum variable."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "here is the code link for reference:-\\nhttps://leetcode.com/problems/sum-root-to-leaf-numbers/solutions/3296514/bfs-easy-to-understand-with-steps/"
                    }
                ]
            },
            {
                "id": 1832242,
                "content": [
                    {
                        "username": "Aditya_Prajapati",
                        "content": "What are the other approaches other than recursion possible for this question ?"
                    },
                    {
                        "username": "Kinszs",
                        "content": "When I type my solution, I am having a error that I cant solve. \\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        enum State{Unvisited, Visited, Visiting; }\\n         boolean search(Graph grade, Node start, Node end){\\n             if(start == end) return true;\\n\\n             LinkedList<Node> queue = new LinkedList<Node>();\\n             for(Node u : grade.getNodes()){\\n                 u.state = State.Unvisited;\\n             }\\n             start.state = State.Visiting;\\n             queue.add(start);\\n             Node u;\\n             while(!queue.isEmpty()){\\n                 u = queue.removeFirst();\\n                 if(u != null){\\n                     for(Node v : u.getAdjacent()){\\n                         if(v.state == State.Unvisited){\\n                             if(v == end){\\n                                 return true;\\n                             }else{\\n                                 v.state = State.Visiting;\\n                                 queue.add(v);\\n                             }\\n                         }\\n                     }\\n                     u.state = State.Visited;\\n                 }\\n             }\\n         }\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Kinszs",
                        "content": "IMO the best approach to solving this would be to use DFS. What do you guys think?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem can be solved as DFS or BFS!"
                    },
                    {
                        "username": "theAchiever",
                        "content": "Can anyone please explain to me why this code won\\'t work?\\n\\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        else if(root.left==null&&root.right==null)\\n            return root.val;\\n        else{\\n            int sum1=root.val*10+sumNumbers(root.left);\\n            int sum2=root.val*10+sumNumbers(root.right);\\n            return sum1+sum2;\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "why is it that when I\\'m running my code on my vs code its giving the right output but here it somehow gives the wrong output ?"
                    },
                    {
                        "username": "Msey",
                        "content": "Tree week :)"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "We are given a binary tree and we need to traverse from root to leaf and then form a number.Likewise, repeat the path traversals and form all possible numbers from root to leaf.Finally, find the sum of all these numbers formed and return as answer.From the below code you can see how we can solve this problem using recursion or dfs (depth first search).\\nWe have declare ans as global variable to use it in both the method and store the final ans.\\n\\nCode : \\n\\nclass Solution {\\n    int ans = 0;\\n    public int sumNumbers(TreeNode root) {\\n        if(root==null) return 0;\\n        dfs(root,0);\\n        return ans;\\n    }\\n    public void dfs(TreeNode root, int val){\\n        if(root==null) return ;\\n        val*=10;\\n        val += root.val;\\n        if(root.left==null && root.right==null){\\n            ans+=val;\\n            return;\\n        }\\n        dfs(root.left,val);\\n        dfs(root.right,val);\\n    }\\n\\n}"
                    },
                    {
                        "username": "shaikirfan2349",
                        "content": "pls help me.....My code giving output as \\'0\\'\\n\\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        Pair<TreeNode,Integer> pair=new Pair(root,0);\\n        Queue<Pair<TreeNode,Integer>> q=new LinkedList();\\n        ArrayList<Integer> leaf = new ArrayList<Integer>();\\n\\n        q.add(pair);\\n        \\n        int totalSum=0;\\n        while(!q.isEmpty()){\\n            int currSum=0;\\n            Pair<TreeNode,Integer> p=q.remove();\\n            currSum=(currSum*10)+p.getKey().val;\\n            if(root.left==null && root.right==null){\\n                leaf.add(currSum);\\n                \\n            }\\n\\n            if(p.getKey().left!=null){\\n                q.add(new Pair(p.getKey().left,p.getValue()+currSum));\\n            }\\n            if(p.getKey().right!=null){\\n                q.add(new Pair(p.getKey().right,p.getValue()+currSum));\\n            }\\n        }\\n        for(int i:leaf){\\n            totalSum+=i;\\n        }\\n\\n        return totalSum;\\n    }\\n}"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is a Simple Approach (BFS):-\\n\\n1. Initialize a queue and add the root of the binary tree to it.\\n2. Initialize a variable to keep track of the sum of root-to-leaf numbers to 0.\\n3. While the queue is not empty, remove the first element from the queue and assign it to a node variable.\\n4. If the node is a leaf node (i.e., it has no left or right child), add its value to the sum variable.\\n5. If the node has a left child, update its value to be the value of the parent node multiplied by 10 and then added to its own value. Add the left child to the queue.\\n6. If the node has a right child, update its value in the same way and add the right child to the queue.\\n7. Repeat steps 3-6 until the queue is empty.\\n8. Return the sum variable."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "here is the code link for reference:-\\nhttps://leetcode.com/problems/sum-root-to-leaf-numbers/solutions/3296514/bfs-easy-to-understand-with-steps/"
                    }
                ]
            },
            {
                "id": 1832078,
                "content": [
                    {
                        "username": "upscchap",
                        "content": "Hey, I tried to code the solution for this problem.\\nCould you please rate my approach to solving this problem?\\nhttps://youtu.be/0vSQRnU-PXo\\nThanks in advance!!"
                    },
                    {
                        "username": "zbr_98",
                        "content": "Started learning tree this week and the best thing is that getting daily questions of tree \\uD83C\\uDF34.\\nProbably the first medium question of tree I\\'ve done without taking any hint."
                    },
                    {
                        "username": "stutitiwari161",
                        "content": "Hey! Even I started Tree this week.....where are you learning from?"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just a normal dfs just additional parameter current sum when u reach at a leaf just add it into the res and at each node multiply running sum with and add current nodes value"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "is it just me or are we getting a lot of repeated daily challenge questions these days? Everyday I login and see that I have already submitted the solution"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using preorder traversal recursion can be done."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Here are, the different approaches we should keep in mind after understanding the problem......\\nApproach 1: Recursive Depth-First Search.\\nApproach 2: Iterative Depth-First Search.\\nApproach 3: Breadth-First Search."
                    },
                    {
                        "username": "meow_power",
                        "content": "Sometimes Leetcode tries us to motivate us,so that we won\\'t go into depression:) Thank You Leetcode!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Im confused on this sentence in the question:\n\n*For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.\n\n        1\n      /    \\\n   2         3\n\nFor the tree shown, that's not a valid path. What is the meaning of this sentence? \nThe rest of the examples show proper tree paths. Usually when discussing trees we assume they are directed, but they arent necessarily. It MIGHT be valid to claim there is a path from 1 to 3 like so:  1 -> 2 -> 1 -> 3, but that is very different from what they are claiming. What am I missing? \n\n\nEDIT: The path in the sentence is for a theoretical tree NOT depicted here. This is a pretty poor choice, given that almost immediately below this the first image corresponds with a similarly labeled tree. The sentance and image are unrelated. Reading comprehension isnt my strong suit I guess, but really they should just change the sentence to use different numbers \n\n(I dont need a hint on the solution, this one should probably be an easy, its a pretty trivial tree problem)"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The 1 -> 2 -> 3 example is not related to the tree below. It's just an explanation on how the root-to-path idea works. "
                    },
                    {
                        "username": "user8228j",
                        "content": "not the most efficient solution by far, but imo way easier to implement.\\nkeep track of the number as a string, and just convert to an int when at a leaf node."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "hint : try some sort of traversal with extra variables to store sum and sum till the root ."
                    }
                ]
            },
            {
                "id": 1831993,
                "content": [
                    {
                        "username": "upscchap",
                        "content": "Hey, I tried to code the solution for this problem.\\nCould you please rate my approach to solving this problem?\\nhttps://youtu.be/0vSQRnU-PXo\\nThanks in advance!!"
                    },
                    {
                        "username": "zbr_98",
                        "content": "Started learning tree this week and the best thing is that getting daily questions of tree \\uD83C\\uDF34.\\nProbably the first medium question of tree I\\'ve done without taking any hint."
                    },
                    {
                        "username": "stutitiwari161",
                        "content": "Hey! Even I started Tree this week.....where are you learning from?"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just a normal dfs just additional parameter current sum when u reach at a leaf just add it into the res and at each node multiply running sum with and add current nodes value"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "is it just me or are we getting a lot of repeated daily challenge questions these days? Everyday I login and see that I have already submitted the solution"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using preorder traversal recursion can be done."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Here are, the different approaches we should keep in mind after understanding the problem......\\nApproach 1: Recursive Depth-First Search.\\nApproach 2: Iterative Depth-First Search.\\nApproach 3: Breadth-First Search."
                    },
                    {
                        "username": "meow_power",
                        "content": "Sometimes Leetcode tries us to motivate us,so that we won\\'t go into depression:) Thank You Leetcode!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Im confused on this sentence in the question:\n\n*For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.\n\n        1\n      /    \\\n   2         3\n\nFor the tree shown, that's not a valid path. What is the meaning of this sentence? \nThe rest of the examples show proper tree paths. Usually when discussing trees we assume they are directed, but they arent necessarily. It MIGHT be valid to claim there is a path from 1 to 3 like so:  1 -> 2 -> 1 -> 3, but that is very different from what they are claiming. What am I missing? \n\n\nEDIT: The path in the sentence is for a theoretical tree NOT depicted here. This is a pretty poor choice, given that almost immediately below this the first image corresponds with a similarly labeled tree. The sentance and image are unrelated. Reading comprehension isnt my strong suit I guess, but really they should just change the sentence to use different numbers \n\n(I dont need a hint on the solution, this one should probably be an easy, its a pretty trivial tree problem)"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The 1 -> 2 -> 3 example is not related to the tree below. It's just an explanation on how the root-to-path idea works. "
                    },
                    {
                        "username": "user8228j",
                        "content": "not the most efficient solution by far, but imo way easier to implement.\\nkeep track of the number as a string, and just convert to an int when at a leaf node."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "hint : try some sort of traversal with extra variables to store sum and sum till the root ."
                    }
                ]
            },
            {
                "id": 1831918,
                "content": [
                    {
                        "username": "upscchap",
                        "content": "Hey, I tried to code the solution for this problem.\\nCould you please rate my approach to solving this problem?\\nhttps://youtu.be/0vSQRnU-PXo\\nThanks in advance!!"
                    },
                    {
                        "username": "zbr_98",
                        "content": "Started learning tree this week and the best thing is that getting daily questions of tree \\uD83C\\uDF34.\\nProbably the first medium question of tree I\\'ve done without taking any hint."
                    },
                    {
                        "username": "stutitiwari161",
                        "content": "Hey! Even I started Tree this week.....where are you learning from?"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just a normal dfs just additional parameter current sum when u reach at a leaf just add it into the res and at each node multiply running sum with and add current nodes value"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "is it just me or are we getting a lot of repeated daily challenge questions these days? Everyday I login and see that I have already submitted the solution"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using preorder traversal recursion can be done."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Here are, the different approaches we should keep in mind after understanding the problem......\\nApproach 1: Recursive Depth-First Search.\\nApproach 2: Iterative Depth-First Search.\\nApproach 3: Breadth-First Search."
                    },
                    {
                        "username": "meow_power",
                        "content": "Sometimes Leetcode tries us to motivate us,so that we won\\'t go into depression:) Thank You Leetcode!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Im confused on this sentence in the question:\n\n*For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.\n\n        1\n      /    \\\n   2         3\n\nFor the tree shown, that's not a valid path. What is the meaning of this sentence? \nThe rest of the examples show proper tree paths. Usually when discussing trees we assume they are directed, but they arent necessarily. It MIGHT be valid to claim there is a path from 1 to 3 like so:  1 -> 2 -> 1 -> 3, but that is very different from what they are claiming. What am I missing? \n\n\nEDIT: The path in the sentence is for a theoretical tree NOT depicted here. This is a pretty poor choice, given that almost immediately below this the first image corresponds with a similarly labeled tree. The sentance and image are unrelated. Reading comprehension isnt my strong suit I guess, but really they should just change the sentence to use different numbers \n\n(I dont need a hint on the solution, this one should probably be an easy, its a pretty trivial tree problem)"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The 1 -> 2 -> 3 example is not related to the tree below. It's just an explanation on how the root-to-path idea works. "
                    },
                    {
                        "username": "user8228j",
                        "content": "not the most efficient solution by far, but imo way easier to implement.\\nkeep track of the number as a string, and just convert to an int when at a leaf node."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "hint : try some sort of traversal with extra variables to store sum and sum till the root ."
                    }
                ]
            },
            {
                "id": 1831872,
                "content": [
                    {
                        "username": "upscchap",
                        "content": "Hey, I tried to code the solution for this problem.\\nCould you please rate my approach to solving this problem?\\nhttps://youtu.be/0vSQRnU-PXo\\nThanks in advance!!"
                    },
                    {
                        "username": "zbr_98",
                        "content": "Started learning tree this week and the best thing is that getting daily questions of tree \\uD83C\\uDF34.\\nProbably the first medium question of tree I\\'ve done without taking any hint."
                    },
                    {
                        "username": "stutitiwari161",
                        "content": "Hey! Even I started Tree this week.....where are you learning from?"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just a normal dfs just additional parameter current sum when u reach at a leaf just add it into the res and at each node multiply running sum with and add current nodes value"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "is it just me or are we getting a lot of repeated daily challenge questions these days? Everyday I login and see that I have already submitted the solution"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using preorder traversal recursion can be done."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Here are, the different approaches we should keep in mind after understanding the problem......\\nApproach 1: Recursive Depth-First Search.\\nApproach 2: Iterative Depth-First Search.\\nApproach 3: Breadth-First Search."
                    },
                    {
                        "username": "meow_power",
                        "content": "Sometimes Leetcode tries us to motivate us,so that we won\\'t go into depression:) Thank You Leetcode!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Im confused on this sentence in the question:\n\n*For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.\n\n        1\n      /    \\\n   2         3\n\nFor the tree shown, that's not a valid path. What is the meaning of this sentence? \nThe rest of the examples show proper tree paths. Usually when discussing trees we assume they are directed, but they arent necessarily. It MIGHT be valid to claim there is a path from 1 to 3 like so:  1 -> 2 -> 1 -> 3, but that is very different from what they are claiming. What am I missing? \n\n\nEDIT: The path in the sentence is for a theoretical tree NOT depicted here. This is a pretty poor choice, given that almost immediately below this the first image corresponds with a similarly labeled tree. The sentance and image are unrelated. Reading comprehension isnt my strong suit I guess, but really they should just change the sentence to use different numbers \n\n(I dont need a hint on the solution, this one should probably be an easy, its a pretty trivial tree problem)"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The 1 -> 2 -> 3 example is not related to the tree below. It's just an explanation on how the root-to-path idea works. "
                    },
                    {
                        "username": "user8228j",
                        "content": "not the most efficient solution by far, but imo way easier to implement.\\nkeep track of the number as a string, and just convert to an int when at a leaf node."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "hint : try some sort of traversal with extra variables to store sum and sum till the root ."
                    }
                ]
            },
            {
                "id": 1831794,
                "content": [
                    {
                        "username": "upscchap",
                        "content": "Hey, I tried to code the solution for this problem.\\nCould you please rate my approach to solving this problem?\\nhttps://youtu.be/0vSQRnU-PXo\\nThanks in advance!!"
                    },
                    {
                        "username": "zbr_98",
                        "content": "Started learning tree this week and the best thing is that getting daily questions of tree \\uD83C\\uDF34.\\nProbably the first medium question of tree I\\'ve done without taking any hint."
                    },
                    {
                        "username": "stutitiwari161",
                        "content": "Hey! Even I started Tree this week.....where are you learning from?"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just a normal dfs just additional parameter current sum when u reach at a leaf just add it into the res and at each node multiply running sum with and add current nodes value"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "is it just me or are we getting a lot of repeated daily challenge questions these days? Everyday I login and see that I have already submitted the solution"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using preorder traversal recursion can be done."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Here are, the different approaches we should keep in mind after understanding the problem......\\nApproach 1: Recursive Depth-First Search.\\nApproach 2: Iterative Depth-First Search.\\nApproach 3: Breadth-First Search."
                    },
                    {
                        "username": "meow_power",
                        "content": "Sometimes Leetcode tries us to motivate us,so that we won\\'t go into depression:) Thank You Leetcode!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Im confused on this sentence in the question:\n\n*For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.\n\n        1\n      /    \\\n   2         3\n\nFor the tree shown, that's not a valid path. What is the meaning of this sentence? \nThe rest of the examples show proper tree paths. Usually when discussing trees we assume they are directed, but they arent necessarily. It MIGHT be valid to claim there is a path from 1 to 3 like so:  1 -> 2 -> 1 -> 3, but that is very different from what they are claiming. What am I missing? \n\n\nEDIT: The path in the sentence is for a theoretical tree NOT depicted here. This is a pretty poor choice, given that almost immediately below this the first image corresponds with a similarly labeled tree. The sentance and image are unrelated. Reading comprehension isnt my strong suit I guess, but really they should just change the sentence to use different numbers \n\n(I dont need a hint on the solution, this one should probably be an easy, its a pretty trivial tree problem)"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The 1 -> 2 -> 3 example is not related to the tree below. It's just an explanation on how the root-to-path idea works. "
                    },
                    {
                        "username": "user8228j",
                        "content": "not the most efficient solution by far, but imo way easier to implement.\\nkeep track of the number as a string, and just convert to an int when at a leaf node."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "hint : try some sort of traversal with extra variables to store sum and sum till the root ."
                    }
                ]
            },
            {
                "id": 1831786,
                "content": [
                    {
                        "username": "upscchap",
                        "content": "Hey, I tried to code the solution for this problem.\\nCould you please rate my approach to solving this problem?\\nhttps://youtu.be/0vSQRnU-PXo\\nThanks in advance!!"
                    },
                    {
                        "username": "zbr_98",
                        "content": "Started learning tree this week and the best thing is that getting daily questions of tree \\uD83C\\uDF34.\\nProbably the first medium question of tree I\\'ve done without taking any hint."
                    },
                    {
                        "username": "stutitiwari161",
                        "content": "Hey! Even I started Tree this week.....where are you learning from?"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just a normal dfs just additional parameter current sum when u reach at a leaf just add it into the res and at each node multiply running sum with and add current nodes value"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "is it just me or are we getting a lot of repeated daily challenge questions these days? Everyday I login and see that I have already submitted the solution"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using preorder traversal recursion can be done."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Here are, the different approaches we should keep in mind after understanding the problem......\\nApproach 1: Recursive Depth-First Search.\\nApproach 2: Iterative Depth-First Search.\\nApproach 3: Breadth-First Search."
                    },
                    {
                        "username": "meow_power",
                        "content": "Sometimes Leetcode tries us to motivate us,so that we won\\'t go into depression:) Thank You Leetcode!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Im confused on this sentence in the question:\n\n*For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.\n\n        1\n      /    \\\n   2         3\n\nFor the tree shown, that's not a valid path. What is the meaning of this sentence? \nThe rest of the examples show proper tree paths. Usually when discussing trees we assume they are directed, but they arent necessarily. It MIGHT be valid to claim there is a path from 1 to 3 like so:  1 -> 2 -> 1 -> 3, but that is very different from what they are claiming. What am I missing? \n\n\nEDIT: The path in the sentence is for a theoretical tree NOT depicted here. This is a pretty poor choice, given that almost immediately below this the first image corresponds with a similarly labeled tree. The sentance and image are unrelated. Reading comprehension isnt my strong suit I guess, but really they should just change the sentence to use different numbers \n\n(I dont need a hint on the solution, this one should probably be an easy, its a pretty trivial tree problem)"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The 1 -> 2 -> 3 example is not related to the tree below. It's just an explanation on how the root-to-path idea works. "
                    },
                    {
                        "username": "user8228j",
                        "content": "not the most efficient solution by far, but imo way easier to implement.\\nkeep track of the number as a string, and just convert to an int when at a leaf node."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "hint : try some sort of traversal with extra variables to store sum and sum till the root ."
                    }
                ]
            },
            {
                "id": 1831777,
                "content": [
                    {
                        "username": "upscchap",
                        "content": "Hey, I tried to code the solution for this problem.\\nCould you please rate my approach to solving this problem?\\nhttps://youtu.be/0vSQRnU-PXo\\nThanks in advance!!"
                    },
                    {
                        "username": "zbr_98",
                        "content": "Started learning tree this week and the best thing is that getting daily questions of tree \\uD83C\\uDF34.\\nProbably the first medium question of tree I\\'ve done without taking any hint."
                    },
                    {
                        "username": "stutitiwari161",
                        "content": "Hey! Even I started Tree this week.....where are you learning from?"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just a normal dfs just additional parameter current sum when u reach at a leaf just add it into the res and at each node multiply running sum with and add current nodes value"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "is it just me or are we getting a lot of repeated daily challenge questions these days? Everyday I login and see that I have already submitted the solution"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using preorder traversal recursion can be done."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Here are, the different approaches we should keep in mind after understanding the problem......\\nApproach 1: Recursive Depth-First Search.\\nApproach 2: Iterative Depth-First Search.\\nApproach 3: Breadth-First Search."
                    },
                    {
                        "username": "meow_power",
                        "content": "Sometimes Leetcode tries us to motivate us,so that we won\\'t go into depression:) Thank You Leetcode!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Im confused on this sentence in the question:\n\n*For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.\n\n        1\n      /    \\\n   2         3\n\nFor the tree shown, that's not a valid path. What is the meaning of this sentence? \nThe rest of the examples show proper tree paths. Usually when discussing trees we assume they are directed, but they arent necessarily. It MIGHT be valid to claim there is a path from 1 to 3 like so:  1 -> 2 -> 1 -> 3, but that is very different from what they are claiming. What am I missing? \n\n\nEDIT: The path in the sentence is for a theoretical tree NOT depicted here. This is a pretty poor choice, given that almost immediately below this the first image corresponds with a similarly labeled tree. The sentance and image are unrelated. Reading comprehension isnt my strong suit I guess, but really they should just change the sentence to use different numbers \n\n(I dont need a hint on the solution, this one should probably be an easy, its a pretty trivial tree problem)"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The 1 -> 2 -> 3 example is not related to the tree below. It's just an explanation on how the root-to-path idea works. "
                    },
                    {
                        "username": "user8228j",
                        "content": "not the most efficient solution by far, but imo way easier to implement.\\nkeep track of the number as a string, and just convert to an int when at a leaf node."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "hint : try some sort of traversal with extra variables to store sum and sum till the root ."
                    }
                ]
            },
            {
                "id": 1831733,
                "content": [
                    {
                        "username": "upscchap",
                        "content": "Hey, I tried to code the solution for this problem.\\nCould you please rate my approach to solving this problem?\\nhttps://youtu.be/0vSQRnU-PXo\\nThanks in advance!!"
                    },
                    {
                        "username": "zbr_98",
                        "content": "Started learning tree this week and the best thing is that getting daily questions of tree \\uD83C\\uDF34.\\nProbably the first medium question of tree I\\'ve done without taking any hint."
                    },
                    {
                        "username": "stutitiwari161",
                        "content": "Hey! Even I started Tree this week.....where are you learning from?"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just a normal dfs just additional parameter current sum when u reach at a leaf just add it into the res and at each node multiply running sum with and add current nodes value"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "is it just me or are we getting a lot of repeated daily challenge questions these days? Everyday I login and see that I have already submitted the solution"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using preorder traversal recursion can be done."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Here are, the different approaches we should keep in mind after understanding the problem......\\nApproach 1: Recursive Depth-First Search.\\nApproach 2: Iterative Depth-First Search.\\nApproach 3: Breadth-First Search."
                    },
                    {
                        "username": "meow_power",
                        "content": "Sometimes Leetcode tries us to motivate us,so that we won\\'t go into depression:) Thank You Leetcode!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Im confused on this sentence in the question:\n\n*For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.\n\n        1\n      /    \\\n   2         3\n\nFor the tree shown, that's not a valid path. What is the meaning of this sentence? \nThe rest of the examples show proper tree paths. Usually when discussing trees we assume they are directed, but they arent necessarily. It MIGHT be valid to claim there is a path from 1 to 3 like so:  1 -> 2 -> 1 -> 3, but that is very different from what they are claiming. What am I missing? \n\n\nEDIT: The path in the sentence is for a theoretical tree NOT depicted here. This is a pretty poor choice, given that almost immediately below this the first image corresponds with a similarly labeled tree. The sentance and image are unrelated. Reading comprehension isnt my strong suit I guess, but really they should just change the sentence to use different numbers \n\n(I dont need a hint on the solution, this one should probably be an easy, its a pretty trivial tree problem)"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The 1 -> 2 -> 3 example is not related to the tree below. It's just an explanation on how the root-to-path idea works. "
                    },
                    {
                        "username": "user8228j",
                        "content": "not the most efficient solution by far, but imo way easier to implement.\\nkeep track of the number as a string, and just convert to an int when at a leaf node."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "hint : try some sort of traversal with extra variables to store sum and sum till the root ."
                    }
                ]
            },
            {
                "id": 1831720,
                "content": [
                    {
                        "username": "upscchap",
                        "content": "Hey, I tried to code the solution for this problem.\\nCould you please rate my approach to solving this problem?\\nhttps://youtu.be/0vSQRnU-PXo\\nThanks in advance!!"
                    },
                    {
                        "username": "zbr_98",
                        "content": "Started learning tree this week and the best thing is that getting daily questions of tree \\uD83C\\uDF34.\\nProbably the first medium question of tree I\\'ve done without taking any hint."
                    },
                    {
                        "username": "stutitiwari161",
                        "content": "Hey! Even I started Tree this week.....where are you learning from?"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just a normal dfs just additional parameter current sum when u reach at a leaf just add it into the res and at each node multiply running sum with and add current nodes value"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "is it just me or are we getting a lot of repeated daily challenge questions these days? Everyday I login and see that I have already submitted the solution"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using preorder traversal recursion can be done."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Here are, the different approaches we should keep in mind after understanding the problem......\\nApproach 1: Recursive Depth-First Search.\\nApproach 2: Iterative Depth-First Search.\\nApproach 3: Breadth-First Search."
                    },
                    {
                        "username": "meow_power",
                        "content": "Sometimes Leetcode tries us to motivate us,so that we won\\'t go into depression:) Thank You Leetcode!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Im confused on this sentence in the question:\n\n*For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.\n\n        1\n      /    \\\n   2         3\n\nFor the tree shown, that's not a valid path. What is the meaning of this sentence? \nThe rest of the examples show proper tree paths. Usually when discussing trees we assume they are directed, but they arent necessarily. It MIGHT be valid to claim there is a path from 1 to 3 like so:  1 -> 2 -> 1 -> 3, but that is very different from what they are claiming. What am I missing? \n\n\nEDIT: The path in the sentence is for a theoretical tree NOT depicted here. This is a pretty poor choice, given that almost immediately below this the first image corresponds with a similarly labeled tree. The sentance and image are unrelated. Reading comprehension isnt my strong suit I guess, but really they should just change the sentence to use different numbers \n\n(I dont need a hint on the solution, this one should probably be an easy, its a pretty trivial tree problem)"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The 1 -> 2 -> 3 example is not related to the tree below. It's just an explanation on how the root-to-path idea works. "
                    },
                    {
                        "username": "user8228j",
                        "content": "not the most efficient solution by far, but imo way easier to implement.\\nkeep track of the number as a string, and just convert to an int when at a leaf node."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "hint : try some sort of traversal with extra variables to store sum and sum till the root ."
                    }
                ]
            },
            {
                "id": 1635469,
                "content": [
                    {
                        "username": "upscchap",
                        "content": "Hey, I tried to code the solution for this problem.\\nCould you please rate my approach to solving this problem?\\nhttps://youtu.be/0vSQRnU-PXo\\nThanks in advance!!"
                    },
                    {
                        "username": "zbr_98",
                        "content": "Started learning tree this week and the best thing is that getting daily questions of tree \\uD83C\\uDF34.\\nProbably the first medium question of tree I\\'ve done without taking any hint."
                    },
                    {
                        "username": "stutitiwari161",
                        "content": "Hey! Even I started Tree this week.....where are you learning from?"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just a normal dfs just additional parameter current sum when u reach at a leaf just add it into the res and at each node multiply running sum with and add current nodes value"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "is it just me or are we getting a lot of repeated daily challenge questions these days? Everyday I login and see that I have already submitted the solution"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using preorder traversal recursion can be done."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Here are, the different approaches we should keep in mind after understanding the problem......\\nApproach 1: Recursive Depth-First Search.\\nApproach 2: Iterative Depth-First Search.\\nApproach 3: Breadth-First Search."
                    },
                    {
                        "username": "meow_power",
                        "content": "Sometimes Leetcode tries us to motivate us,so that we won\\'t go into depression:) Thank You Leetcode!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Im confused on this sentence in the question:\n\n*For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.\n\n        1\n      /    \\\n   2         3\n\nFor the tree shown, that's not a valid path. What is the meaning of this sentence? \nThe rest of the examples show proper tree paths. Usually when discussing trees we assume they are directed, but they arent necessarily. It MIGHT be valid to claim there is a path from 1 to 3 like so:  1 -> 2 -> 1 -> 3, but that is very different from what they are claiming. What am I missing? \n\n\nEDIT: The path in the sentence is for a theoretical tree NOT depicted here. This is a pretty poor choice, given that almost immediately below this the first image corresponds with a similarly labeled tree. The sentance and image are unrelated. Reading comprehension isnt my strong suit I guess, but really they should just change the sentence to use different numbers \n\n(I dont need a hint on the solution, this one should probably be an easy, its a pretty trivial tree problem)"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The 1 -> 2 -> 3 example is not related to the tree below. It's just an explanation on how the root-to-path idea works. "
                    },
                    {
                        "username": "user8228j",
                        "content": "not the most efficient solution by far, but imo way easier to implement.\\nkeep track of the number as a string, and just convert to an int when at a leaf node."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "hint : try some sort of traversal with extra variables to store sum and sum till the root ."
                    }
                ]
            }
        ]
    },
    {
        "title": "Majority Element II",
        "question_content": "<p>Given an integer array of size <code>n</code>, find all elements that appear more than <code>&lfloor; n/3 &rfloor;</code> times.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,3]\n<strong>Output:</strong> [3]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1]\n<strong>Output:</strong> [1]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2]\n<strong>Output:</strong> [1,2]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you solve the problem in linear time and in <code>O(1)</code> space?</p>\n",
        "solutions": [
            {
                "id": 63520,
                "title": "boyer-moore-majority-vote-algorithm-and-my-elaboration",
                "content": "For those who aren't familiar with Boyer-Moore Majority Vote algorithm, \\nI found a great article (http://goo.gl/64Nams) that helps me to understand this fantastic algorithm!!\\nPlease check it out!\\n\\nThe essential concepts is you keep a counter for the majority number **X**. If you find a number **Y** that is not **X**, the current counter should deduce 1. The reason is that if there is 5 **X** and 4 **Y**, there would be one (5-4) more **X** than **Y**. This could be explained as \"4 **X** being paired out by 4 **Y**\".\\n\\nAnd since the requirement is finding the majority for more than ceiling of [n/3], the answer would be less than or equal to two numbers. \\nSo we can modify the algorithm to maintain two counters for two majorities.\\n\\nFollowings are my sample Python code:\\n\\n    class Solution:\\n    # @param {integer[]} nums\\n    # @return {integer[]}\\n    def majorityElement(self, nums):\\n        if not nums:\\n            return []\\n        count1, count2, candidate1, candidate2 = 0, 0, 0, 1\\n        for n in nums:\\n            if n == candidate1:\\n                count1 += 1\\n            elif n == candidate2:\\n                count2 += 1\\n            elif count1 == 0:\\n                candidate1, count1 = n, 1\\n            elif count2 == 0:\\n                candidate2, count2 = n, 1\\n            else:\\n                count1, count2 = count1 - 1, count2 - 1\\n        return [n for n in (candidate1, candidate2)\\n                        if nums.count(n) > len(nums) // 3]",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 543672,
                "title": "boyer-moore-majority-vote-algorithm-explained",
                "content": "**Solution: Boyer\\u2013Moore majority vote algorithm `O(N), O(1)`**\\n\\nI\\'ve read a few explanations of this algorithm, but I feel a need for a more detailed talk. Here\\'s my take on this algorithm, hope it will help somebody.\\n```\\nclass Solution {\\npublic:\\n  vector<int> majorityElement(vector<int> &a) \\n  {\\n\\t  int y(-1), z(-1), cy(0), cz(0);\\n    \\n\\t  for (const auto & x: a) \\n\\t  {\\n\\t\\t  if (x == y) cy++;\\n\\t\\t  else if (x == z) cz++;\\n\\t\\t  else if (! cy) y = x, cy = 1;\\n\\t\\t  else if (! cz) z = x, cz = 1;\\n\\t\\t  else cy--, cz--;\\n     }\\n      \\n     cy = cz = 0;\\n     for (const auto & x: a)\\n\\t\\t if (x == y) cy++;\\n\\t\\t\\t else if (x == z) cz++;\\n  \\n\\t  vector<int> r;\\n\\t  if (cy > size(a)/3) r.push_back(y);\\n\\t  if (cz > size(a)/3) r.push_back(z);\\n\\t  return r;\\n  }\\n};\\n```\\nThis is a two-pass algorithm: the first pass chooses two candidates, the second pass either confirms or rejects each of them.\\n\\n## Explanation: Forming triples\\n\\n\\u261D Before we start you may want to get a feeling of Boyer\\u2013Moore `\\u230A n/2 \\u230B` majority vote algorithm (explanation [here](https://leetcode.com/problems/majority-element/discuss/543431/Majority-vote-algorithm-EXPLAINED-(with-pictures))).\\n\\nThe main point of this algorithm is to form triples of **different** numbers like these `(1,2,3)`, `(1,3,4)`: the leftovers after this triple-forming procedure will be our majority candidates. Two different triples may coinside (e.g. `(1,2,3)`, `(1,2,3)`). These triples are formed under the hood and never articulated, so it\\'s a bit hard to see them at first. These triples are produced when the two counters are decreased (in the ultimate `else` section where `--` occur). Let me elaborate on how this is done exactly and then I\\'ll explain what do we need those triples for.\\n\\n##### How to form triples of different elements\\n\\nIf our vector consisted of different elements triples production would be easy: we would traverse the array and form triples out of 3 consecutive elements.\\n![image](https://assets.leetcode.com/users/andriy111/image_1584570461.png)\\n\\n\\nWhen we have duplicates we have an excess of some elements and we can\\'t use them unless we encounter some fresh elements.\\nIn order to remember what elements we had an excess of we can use a stack (two stacks in fact.). I hope these two pictures will clarify the process.\\n\\n![image](https://assets.leetcode.com/users/andriy111/image_1584569678.png)\\n\\n\\n\\nNote that we should put into stack the elements of only one kind. The triple is formed when we simultaniously pop two different elements from our staches and take current element from the array. If current element equals elements in one of the stacks we can\\'t form a proper triple and push current element into the respective stack.\\n\\nThe next observation is that we don\\'t need all these stacks as they contain identical elements and we can substitute them with two variables `y` and `z` and their counters `cy ` and `cz`.\\nLet\\'s take a look how triples are formed in this process\\n![image](https://assets.leetcode.com/users/andriy111/image_1584562040.png)\\n\\nHere the following triples are formed: `(1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 4, 3) `.  Note that \"`-`\"\\'s occur simultanuosly for the two counters but \"`+`\"\\'s occur to only one of them. Also every step leads to either \"`+`\" or \"`-`\". \"`+`\" means that we were unable to form a triple because we didn\\'t have enough different elements at our disposal when the current element matched with one of the two types of stashed elements and we need to stash this element as well for the future.\\n\\n##### Why do we need triples ?\\nWhy do we partition the elements into triples with different elements in each triple? It\\'s because the leftovers after this procedure are the candidates for the majority elements. There will be elements of only two types in the leftovers (otherwise we could make a triple of them). Note that triples contain only different elements and there could be no more than   `\\u230A n/3 \\u230B` of them. So even if majority element would appear in every one of `\\u230A n/3 \\u230B` triples there will be leftover of it. That\\'s why majority elements (if present) are guaranted to be among the leftovers.\\n\\nUPD. Thanks for all the nice words in the comments :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<int> majorityElement(vector<int> &a) \\n  {\\n\\t  int y(-1), z(-1), cy(0), cz(0);\\n    \\n\\t  for (const auto & x: a) \\n\\t  {\\n\\t\\t  if (x == y) cy++;\\n\\t\\t  else if (x == z) cz++;\\n\\t\\t  else if (! cy) y = x, cy = 1;\\n\\t\\t  else if (! cz) z = x, cz = 1;\\n\\t\\t  else cy--, cz--;\\n     }\\n      \\n     cy = cz = 0;\\n     for (const auto & x: a)\\n\\t\\t if (x == y) cy++;\\n\\t\\t\\t else if (x == z) cz++;\\n  \\n\\t  vector<int> r;\\n\\t  if (cy > size(a)/3) r.push_back(y);\\n\\t  if (cz > size(a)/3) r.push_back(z);\\n\\t  return r;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 63537,
                "title": "my-understanding-of-boyer-moore-majority-vote",
                "content": "This problem is an extension to [169. Majority Element](https://leetcode.com/problems/majority-element/), which needs Boyer-Moore Majority Vote Algorithm to find the element, whose count is over `n/2`.\\n\\nWhen I was learning about Boyer-Moore, I was always thinking about **the pair**. I drew a picture to get myself understandable.\\n\\nSuppose there are nine elements in array **A**, and the round one is the majority.\\n\\n![0_1477537808895_upload-f2ddd14f-9954-4025-b77a-40137c5abf06](/uploads/files/1477537810177-upload-f2ddd14f-9954-4025-b77a-40137c5abf06.png) \\n\\nNo matter in what order we select element from the array, we can only get two results\\n\\n![0_1477537956098_upload-e3d23d8b-0d43-4f8f-ace1-065bd0928493](/uploads/files/1477537957428-upload-e3d23d8b-0d43-4f8f-ace1-065bd0928493.png) \\n\\nCompared to fully pairing, it is a little wasting of the partially pairing as there are some round ones are not paired (definitely it would be left). So, under the condition that the majority element exists, we could only think about **the fully pairing situation**. (It's useful when dealing with `n/3` situation)\\n\\nWe can consider either column as the candidate, and it's intuitive for me to get understand that the code means found a pair.\\n\\n```\\nif candidate != element\\n  count -= 1\\nend\\n```\\n\\n![0_1477539703014_upload-2186f2ff-dc3d-4324-a3ce-5f7ade11a2da](/uploads/files/1477539704324-upload-2186f2ff-dc3d-4324-a3ce-5f7ade11a2da.png) \\n\\nSo here comes the `n/3` problem, we would only think about the fully pairing situation. If the over one third majority exists, it should be left after pairing. \\n\\n![0_1477539890642_upload-1c838025-3ff3-4fa9-ae23-abd8b7e10be9](/uploads/files/1477539893194-upload-1c838025-3ff3-4fa9-ae23-abd8b7e10be9.png)\\nWhy would we use three elements as a pair? Because it makes sure that in fully pairing the count of majority element equals `n/3`.\\n\\nThat's my understanding about Boyer-Moore. Maybe it's not so clear, but it helps me think about it.\\n\\n*Code*\\n\\n```ruby\\n# Modified Boyer-Moore Majority Voting Algorithm\\ndef majority_element(nums)\\n  candidate1, candidate2 = 0, 0\\n  count1, count2 = 0, 0\\n\\n  # first round to find candidates\\n  nums.each do |num|\\n    if candidate1 == num\\n      count1 += 1\\n\\n    elsif candidate2 == num\\n      count2 += 1\\n\\n    elsif count1 == 0\\n      candidate1 = num\\n      count1 += 1\\n\\n    elsif count2 == 0\\n      candidate2 = num\\n      count2 += 1\\n\\n    else\\n      # This condition is important, which means a pair out,\\n      # filtering a set of three elements out\\n\\n      count1 -= 1\\n      count2 -= 1\\n    end\\n  end\\n\\n  # second round to confirm\\n  result = []\\n  [candidate1, candidate2].uniq.each do |candidate|\\n    result << candidate if nums.count(candidate) > (nums.count/3)\\n  end\\n\\n  result\\nend\\n```\\n\\n*Reference*\\n\\n+ [Boyer-Moore Majority Vote algorithm and my elaboration](https://discuss.leetcode.com/topic/17564/boyer-moore-majority-vote-algorithm-and-my-elaboration) by [orbuluh](https://discuss.leetcode.com/user/orbuluh)\\n+ [Majority Voting Algorithm - Blog of Greg Grothaus](https://gregable.com/2013/10/majority-vote-algorithm-find-majority.html)\\n+ [Boyer-Moore Majority Vote Algorithm](http://www.cs.rug.nl/~wim/pub/whh348.pdf)",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\nif candidate != element\\n  count -= 1\\nend\\n```\n```ruby\\n# Modified Boyer-Moore Majority Voting Algorithm\\ndef majority_element(nums)\\n  candidate1, candidate2 = 0, 0\\n  count1, count2 = 0, 0\\n\\n  # first round to find candidates\\n  nums.each do |num|\\n    if candidate1 == num\\n      count1 += 1\\n\\n    elsif candidate2 == num\\n      count2 += 1\\n\\n    elsif count1 == 0\\n      candidate1 = num\\n      count1 += 1\\n\\n    elsif count2 == 0\\n      candidate2 = num\\n      count2 += 1\\n\\n    else\\n      # This condition is important, which means a pair out,\\n      # filtering a set of three elements out\\n\\n      count1 -= 1\\n      count2 -= 1\\n    end\\n  end\\n\\n  # second round to confirm\\n  result = []\\n  [candidate1, candidate2].uniq.each do |candidate|\\n    result << candidate if nums.count(candidate) > (nums.count/3)\\n  end\\n\\n  result\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 63502,
                "title": "6-lines-general-case-o-n-time-and-o-k-space",
                "content": "**Solution**\\n\\nI keep up to two candidates in my counter, so this fulfills the O(N) time and O(1) space requirements.\\n\\n    def majorityElement(self, nums):\\n        ctr = collections.Counter()\\n        for n in nums:\\n            ctr[n] += 1\\n            if len(ctr) == 3:\\n                ctr -= collections.Counter(set(ctr))\\n        return [n for n in ctr if nums.count(n) > len(nums)/3]\\n\\n---\\n\\n**Explanation**\\n\\nThink of it this way: Find three different votes and hide them. Repeat until there aren't three different votes left. A number that originally had more than one third of the votes now still has at least one vote, because to hide *all* of its votes you would've had to hide more than three times one third of the votes - more votes than there were. You can easily have false positives, though, so in the end check whether the remaining up to two candidates actually had more than one third of the votes.\\n\\nMy code does just that: Collect (count) the votes for every number, but remove triples of three different votes on the fly, as soon as we have such a triple.\\n\\n---\\n\\n**Generalization to \\u230aN/k\\u230b, still O(N) time but O(k) space**\\n\\nFor the general problem, looking for elements appearing more than \\u230aN/k\\u230b times for some positive integer k, I just have to change my `3` to `k`. Then it already works and takes takes O(k) space and O(kN) time.\\n\\nThe O(kN) time does **not** come from the main loop, though. Yes, each `ctr -= ...` does cost k, but I only have to do it at most N/k times. To put it in terms of the above explanation, I can't hide a vote more than once.\\n\\nNo, the culprit is my last line, counting each remaining candidate separately. If I count them at the same time, I get O(N) again. Here's the full generalized code:\\n\\n    def majorityElement(self, nums, k):\\n        ctr = collections.Counter()\\n        for n in nums:\\n            ctr[n] += 1\\n            if len(ctr) == k:\\n                ctr -= collections.Counter(set(ctr))\\n        ctr = collections.Counter(n for n in nums if n in ctr)\\n        return [n for n in ctr if ctr[n] > len(nums)/k]",
                "solutionTags": [
                    "Python"
                ],
                "code": "**Solution**\\n\\nI keep up to two candidates in my counter, so this fulfills the O(N) time and O(1) space requirements.\\n\\n    def majorityElement(self, nums):\\n        ctr = collections.Counter()\\n        for n in nums:\\n            ctr[n] += 1\\n            if len(ctr) == 3:\\n                ctr -= collections.Counter(set(ctr))\\n        return [n for n in ctr if nums.count(n) > len(nums)/3]\\n\\n---\\n\\n**Explanation**\\n\\nThink of it this way: Find three different votes and hide them. Repeat until there aren't three different votes left. A number that originally had more than one third of the votes now still has at least one vote, because to hide *all* of its votes you would've had to hide more than three times one third of the votes - more votes than there were. You can easily have false positives, though, so in the end check whether the remaining up to two candidates actually had more than one third of the votes.\\n\\nMy code does just that: Collect (count) the votes for every number, but remove triples of three different votes on the fly, as soon as we have such a triple.\\n\\n---\\n\\n**Generalization to \\u230aN/k\\u230b, still O(N) time but O(k) space**\\n\\nFor the general problem, looking for elements appearing more than \\u230aN/k\\u230b times for some positive integer k, I just have to change my `3` to `k`. Then it already works and takes takes O(k) space and O(kN) time.\\n\\nThe O(kN) time does **not** come from the main loop, though. Yes, each `ctr -= ...` does cost k, but I only have to do it at most N/k times. To put it in terms of the above explanation, I can't hide a vote more than once.\\n\\nNo, the culprit is my last line, counting each remaining candidate separately. If I count them at the same time, I get O(N) again. Here's the full generalized code:\\n\\n    def majorityElement(self, nums, k):\\n        ctr = collections.Counter()\\n        for n in nums:\\n            ctr[n] += 1\\n            if len(ctr) == k:\\n                ctr -= collections.Counter(set(ctr))\\n        ctr = collections.Counter(n for n in nums if n in ctr)\\n        return [n for n in ctr if ctr[n] > len(nums)/k]",
                "codeTag": "Python3"
            },
            {
                "id": 63500,
                "title": "java-easy-version-to-understand",
                "content": "    \\tpublic List<Integer> majorityElement(int[] nums) {\\n\\t\\tif (nums == null || nums.length == 0)\\n\\t\\t\\treturn new ArrayList<Integer>();\\n\\t\\tList<Integer> result = new ArrayList<Integer>();\\n\\t\\tint number1 = nums[0], number2 = nums[0], count1 = 0, count2 = 0, len = nums.length;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (nums[i] == number1)\\n\\t\\t\\t\\tcount1++;\\n\\t\\t\\telse if (nums[i] == number2)\\n\\t\\t\\t\\tcount2++;\\n\\t\\t\\telse if (count1 == 0) {\\n\\t\\t\\t\\tnumber1 = nums[i];\\n\\t\\t\\t\\tcount1 = 1;\\n\\t\\t\\t} else if (count2 == 0) {\\n\\t\\t\\t\\tnumber2 = nums[i];\\n\\t\\t\\t\\tcount2 = 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcount1--;\\n\\t\\t\\t\\tcount2--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcount1 = 0;\\n\\t\\tcount2 = 0;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (nums[i] == number1)\\n\\t\\t\\t\\tcount1++;\\n\\t\\t\\telse if (nums[i] == number2)\\n\\t\\t\\t\\tcount2++;\\n\\t\\t}\\n\\t\\tif (count1 > len / 3)\\n\\t\\t\\tresult.add(number1);\\n\\t\\tif (count2 > len / 3)\\n\\t\\t\\tresult.add(number2);\\n\\t\\treturn result;\\n\\t}",
                "solutionTags": [],
                "code": "    \\tpublic List<Integer> majorityElement(int[] nums) {\\n\\t\\tif (nums == null || nums.length == 0)\\n\\t\\t\\treturn new ArrayList<Integer>();\\n\\t\\tList<Integer> result = new ArrayList<Integer>();\\n\\t\\tint number1 = nums[0], number2 = nums[0], count1 = 0, count2 = 0, len = nums.length;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (nums[i] == number1)\\n\\t\\t\\t\\tcount1++;\\n\\t\\t\\telse if (nums[i] == number2)\\n\\t\\t\\t\\tcount2++;\\n\\t\\t\\telse if (count1 == 0) {\\n\\t\\t\\t\\tnumber1 = nums[i];\\n\\t\\t\\t\\tcount1 = 1;\\n\\t\\t\\t} else if (count2 == 0) {\\n\\t\\t\\t\\tnumber2 = nums[i];\\n\\t\\t\\t\\tcount2 = 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcount1--;\\n\\t\\t\\t\\tcount2--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcount1 = 0;\\n\\t\\tcount2 = 0;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (nums[i] == number1)\\n\\t\\t\\t\\tcount1++;\\n\\t\\t\\telse if (nums[i] == number2)\\n\\t\\t\\t\\tcount2++;\\n\\t\\t}\\n\\t\\tif (count1 > len / 3)\\n\\t\\t\\tresult.add(number1);\\n\\t\\tif (count2 > len / 3)\\n\\t\\t\\tresult.add(number2);\\n\\t\\treturn result;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3177394,
                "title": "best-c-4-solutions-boyer-moore-voting-algorithm-hash-table-sorting-one-stop-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Multiple Approaches. (Here I have explained all the possible solutions of this problem).\\n\\n1. Solved using Array + Hash Table(Unordered set). Brute Force Approach.\\n2. Solved using Array + Hash Table(Unordered map).\\n3. Solved using Array + Sorting + Hash Table(Unordered set).\\n4. Solved using Boyer-Moore Voting Algorithm. Optimize Approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N^2), The brute force algorithm contains two nested for loops that each run for N\\n    iterations, adding up to quadratic time complexity. Where N is the size of the Array(nums). Where N is the\\n    size of the Array(nums).\\n\\n    Space Complexity : O(1), Constant Space. Because unordered_set(set) and Array(output) will maximum store 2\\n    element not more than that.\\n\\n    Solved using Array + Hash Table(Unordered set). Brute Force.\\n\\n    Note : This Approach is giving TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int countMajority = nums.size()/3;\\n        unordered_set<int> set;\\n        vector<int> output;\\n        for(auto num : nums){\\n            int count = 0;\\n            for(auto element : nums){\\n                if(element == num){\\n                    count++;\\n                }\\n            }\\n            if(count > countMajority){\\n                set.insert(num);\\n            }\\n        }\\n        for(auto it = set.begin(); it != set.end(); it++){\\n            output.push_back(*it);\\n        }\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), We iterate over Array(nums) once and make a constant time HashMap(Unordered map)\\n    insertion on each iteration. Therefore, the algorithm runs in O(N) time. Where N is the size of the Array\\n    (nums).\\n\\n    Space Complexity : O(N), Unordered map space. \\n\\n    Solved using Array + Hash Table(Unordered map).\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int countMajority = nums.size()/3;\\n        unordered_map<int, int> map;\\n        vector<int> output;\\n        for(auto num : nums){\\n            map[num]++;\\n        }\\n        for(auto num : map){\\n            if(num.second > countMajority){\\n                output.push_back(num.first);\\n            }\\n        }\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(NlogN), Sorting the array(nums) costs O(NlogN). Where N is the size of the Array(nums).\\n\\n    Space Complexity : O(1), Constant Space. Because unordered_set(set) and Array(output) will maximum store 2\\n    element not more than that.\\n\\n    Solved using Array + Sorting + Hash Table(Unordered set).\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        if(nums.size() == 1){\\n            return {nums[0]};\\n        }\\n        if(nums.size() == 2 && nums[0] != nums[1]){\\n            return {nums[0], nums[1]};\\n        }\\n        sort(nums.begin(), nums.end());\\n        int countMajority = nums.size()/3;\\n        unordered_set<int> set;\\n        vector<int> output;\\n        int count = 1;\\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i-1] == nums[i]){\\n                count++;\\n                if(count > countMajority){\\n                    set.insert(nums[i]);\\n                }\\n            }\\n            else{\\n                count = 1;\\n            }\\n        }\\n        for(int it : set){\\n            output.push_back(it);\\n        }\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Boyer-Moore performs constant work exactly N times, so the algorithm runs in\\n    linear time. Where N is the size of the Array(nums).\\n\\n    Space Complexity : O(1), Constant Space. Because we are creating Array(output) as per the demand of\\n    program so it doesnot count as auxilary space also Array(output) will maximum store 2 element not more than\\n    that which is a constant. \\n\\n    Solved using Boyer-Moore Voting Algorithm.\\n\\n*/\\n\\n\\n/***************************************** Approach 4 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int num1 = INT_MIN, num2 = INT_MIN;\\n        int count1 = 0, count2 = 0;\\n        for(auto element : nums){\\n            if(num1 == element){\\n                count1++;\\n            }\\n            else if(num2 == element){\\n                count2++;\\n            }\\n            else if(count1 == 0){\\n                num1 = element;\\n                count1 = 1;\\n            }\\n            else if(count2 == 0){\\n                num2 = element;\\n                count2 = 1;\\n            }\\n            else{\\n                count1--;\\n                count2--;\\n            }\\n        }\\n        vector<int> output;\\n        int countMajority = nums.size()/3;\\n        count1 = 0, count2 = 0;\\n        for(auto element : nums){\\n            if(num1 == element){\\n                count1++;\\n            }\\n            if(num2 == element){\\n                count2++;\\n            }\\n        }\\n        if(count1 > countMajority){\\n            output.push_back(num1);\\n        }\\n        if(count2 > countMajority){\\n            output.push_back(num2);\\n        }\\n        return output;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sorting",
                    "Counting"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N^2), The brute force algorithm contains two nested for loops that each run for N\\n    iterations, adding up to quadratic time complexity. Where N is the size of the Array(nums). Where N is the\\n    size of the Array(nums).\\n\\n    Space Complexity : O(1), Constant Space. Because unordered_set(set) and Array(output) will maximum store 2\\n    element not more than that.\\n\\n    Solved using Array + Hash Table(Unordered set). Brute Force.\\n\\n    Note : This Approach is giving TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int countMajority = nums.size()/3;\\n        unordered_set<int> set;\\n        vector<int> output;\\n        for(auto num : nums){\\n            int count = 0;\\n            for(auto element : nums){\\n                if(element == num){\\n                    count++;\\n                }\\n            }\\n            if(count > countMajority){\\n                set.insert(num);\\n            }\\n        }\\n        for(auto it = set.begin(); it != set.end(); it++){\\n            output.push_back(*it);\\n        }\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), We iterate over Array(nums) once and make a constant time HashMap(Unordered map)\\n    insertion on each iteration. Therefore, the algorithm runs in O(N) time. Where N is the size of the Array\\n    (nums).\\n\\n    Space Complexity : O(N), Unordered map space. \\n\\n    Solved using Array + Hash Table(Unordered map).\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int countMajority = nums.size()/3;\\n        unordered_map<int, int> map;\\n        vector<int> output;\\n        for(auto num : nums){\\n            map[num]++;\\n        }\\n        for(auto num : map){\\n            if(num.second > countMajority){\\n                output.push_back(num.first);\\n            }\\n        }\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(NlogN), Sorting the array(nums) costs O(NlogN). Where N is the size of the Array(nums).\\n\\n    Space Complexity : O(1), Constant Space. Because unordered_set(set) and Array(output) will maximum store 2\\n    element not more than that.\\n\\n    Solved using Array + Sorting + Hash Table(Unordered set).\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        if(nums.size() == 1){\\n            return {nums[0]};\\n        }\\n        if(nums.size() == 2 && nums[0] != nums[1]){\\n            return {nums[0], nums[1]};\\n        }\\n        sort(nums.begin(), nums.end());\\n        int countMajority = nums.size()/3;\\n        unordered_set<int> set;\\n        vector<int> output;\\n        int count = 1;\\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i-1] == nums[i]){\\n                count++;\\n                if(count > countMajority){\\n                    set.insert(nums[i]);\\n                }\\n            }\\n            else{\\n                count = 1;\\n            }\\n        }\\n        for(int it : set){\\n            output.push_back(it);\\n        }\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Boyer-Moore performs constant work exactly N times, so the algorithm runs in\\n    linear time. Where N is the size of the Array(nums).\\n\\n    Space Complexity : O(1), Constant Space. Because we are creating Array(output) as per the demand of\\n    program so it doesnot count as auxilary space also Array(output) will maximum store 2 element not more than\\n    that which is a constant. \\n\\n    Solved using Boyer-Moore Voting Algorithm.\\n\\n*/\\n\\n\\n/***************************************** Approach 4 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int num1 = INT_MIN, num2 = INT_MIN;\\n        int count1 = 0, count2 = 0;\\n        for(auto element : nums){\\n            if(num1 == element){\\n                count1++;\\n            }\\n            else if(num2 == element){\\n                count2++;\\n            }\\n            else if(count1 == 0){\\n                num1 = element;\\n                count1 = 1;\\n            }\\n            else if(count2 == 0){\\n                num2 = element;\\n                count2 = 1;\\n            }\\n            else{\\n                count1--;\\n                count2--;\\n            }\\n        }\\n        vector<int> output;\\n        int countMajority = nums.size()/3;\\n        count1 = 0, count2 = 0;\\n        for(auto element : nums){\\n            if(num1 == element){\\n                count1++;\\n            }\\n            if(num2 == element){\\n                count2++;\\n            }\\n        }\\n        if(count1 > countMajority){\\n            output.push_back(num1);\\n        }\\n        if(count2 > countMajority){\\n            output.push_back(num2);\\n        }\\n        return output;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1098995,
                "title": "explanation-about-boyer-moore-vote",
                "content": "There can be at most ```k - 1``` major element in an array if the major element appears more than ```\\u230An / k\\u230B``` times.\\n\\nIn the begining, we assume there are ```k - 1``` candidates: \\n1. These candidates can take **any** value;\\n2. The vote of these candidates **must** be 0\\n\\nThen we traverse the array:\\n1. If current element equals to the value of any candidate, the candidate get a vote; (one voter can only vote for one candidate)\\n2. If the vote of any candidate is 0, then current element is set as a new candidate and he can get a vote immediately; (A voter can also be elected)\\n3. Otherwise, current element vote against all candidates and all candidates lose a vote. \\n\\nAssume you\\'re voting for the president. If you want to select Trump or Biden. Ok, just vote for them (case 1). If Trump is impeached or Biden is dead, now you can run for the president (case 2). If you want to vote for Lebron James, of course both Biden or Trump won\\'t get your vote (case 3).\\n\\nAfter election, we need to count the vote of each candidate to see whether they are qualified for the position, i.e., the vote is larger than ```\\u230An / k\\u230B```.\\n\\n```\\npublic List<Integer> majorityElement(int[] nums) {\\n\\tList<Integer> result = new ArrayList<Integer>();\\n\\tif (nums.length == 0)\\n\\t\\treturn result;\\n\\t// In the begining, both Trump and Biden don\\'t get a vote\\n\\tint firstMajor = Integer.MAX_VALUE, firstSum = 0, secondMajor = Integer.MIN_VALUE, secondSum = 0;\\n\\t\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t// case 1: I want to vote for Biden or Trump\\n\\t\\tif (nums[i] == firstMajor)\\n\\t\\t\\tfirstSum++;\\n\\t\\telse if (nums[i] == secondMajor)\\n\\t\\t\\tsecondSum++;\\n\\t\\t// case 2: I want to run for the president\\n\\t\\telse if (firstSum == 0) {\\n\\t\\t\\tfirstMajor = nums[i];\\n\\t\\t\\tfirstSum = 1;\\n\\t\\t}\\n\\t\\telse if (secondSum == 0) {\\n\\t\\t\\tsecondMajor = nums[i];\\n\\t\\t\\tsecondSum = 1;\\n\\t\\t}\\n\\t\\t// case 3: fuck sleepy Joe and crazy Trump, let James be the president\\n\\t\\telse {\\n\\t\\t\\tfirstSum--;\\n\\t\\t\\tsecondSum--;\\n\\t\\t}\\n\\t}\\n\\t// After election, we need to count the vote again.\\n\\tfirstSum = 0;\\n\\tsecondSum = 0;\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\tif (nums[i] == firstMajor)\\n\\t\\t\\tfirstSum++;    \\n\\t\\telse if (nums[i] == secondMajor)\\n\\t\\t\\tsecondSum++;\\n\\t}\\n\\tif (firstSum > nums.length / 3)\\n\\t\\tresult.add(firstMajor);\\n\\tif (secondSum > nums.length / 3)\\n\\t\\tresult.add(secondMajor);\\n\\treturn result;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```k - 1```\n```\\u230An / k\\u230B```\n```k - 1```\n```\\u230An / k\\u230B```\n```\\npublic List<Integer> majorityElement(int[] nums) {\\n\\tList<Integer> result = new ArrayList<Integer>();\\n\\tif (nums.length == 0)\\n\\t\\treturn result;\\n\\t// In the begining, both Trump and Biden don\\'t get a vote\\n\\tint firstMajor = Integer.MAX_VALUE, firstSum = 0, secondMajor = Integer.MIN_VALUE, secondSum = 0;\\n\\t\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t// case 1: I want to vote for Biden or Trump\\n\\t\\tif (nums[i] == firstMajor)\\n\\t\\t\\tfirstSum++;\\n\\t\\telse if (nums[i] == secondMajor)\\n\\t\\t\\tsecondSum++;\\n\\t\\t// case 2: I want to run for the president\\n\\t\\telse if (firstSum == 0) {\\n\\t\\t\\tfirstMajor = nums[i];\\n\\t\\t\\tfirstSum = 1;\\n\\t\\t}\\n\\t\\telse if (secondSum == 0) {\\n\\t\\t\\tsecondMajor = nums[i];\\n\\t\\t\\tsecondSum = 1;\\n\\t\\t}\\n\\t\\t// case 3: fuck sleepy Joe and crazy Trump, let James be the president\\n\\t\\telse {\\n\\t\\t\\tfirstSum--;\\n\\t\\t\\tsecondSum--;\\n\\t\\t}\\n\\t}\\n\\t// After election, we need to count the vote again.\\n\\tfirstSum = 0;\\n\\tsecondSum = 0;\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\tif (nums[i] == firstMajor)\\n\\t\\t\\tfirstSum++;    \\n\\t\\telse if (nums[i] == secondMajor)\\n\\t\\t\\tsecondSum++;\\n\\t}\\n\\tif (firstSum > nums.length / 3)\\n\\t\\tresult.add(firstMajor);\\n\\tif (secondSum > nums.length / 3)\\n\\t\\tresult.add(secondMajor);\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 613810,
                "title": "c-solution-with-easy-to-understand-explaination",
                "content": "I first solved it using map but I was getting too much time so I headed over to discuss and found people have solved it using a modified Boyer-Moore Majority Voting for n/3 elements. I spent a lot of time understanding the solution to this problem and I think I finally got it, I\\'ll try to explain it in as easy terms as possible.\\n\\nFirst let\\'s have a look at the standard n/2 problem.\\n```\\nint count = 0, ans;\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            if (count == 0)\\n                ans = nums[i];\\n            count += nums[i] == ans ? 1 : -1;\\n        }\\n        return ans;\\n```\\nHere what we are essentially doing is making pairs with majority element, fix a majority element increment the count till you find a different one and decrease the count for different elements. Here *decreasing the count simply means, making a pair of majority and non-majority element and removing them from the array*. Once the count reaches zero, make a new majority element because the deleted pairs had an equal count of **majority** and **non-majority** element. When we reach the end we will have the majority element selected due to the process we followed and since it was mentioned in the question that \"You may assume that the array is non-empty and the majority element always exist in the array\" we do not verify the solution. You can do if you want to in a single pass.\\n\\nSo, taking the idea from the basic problem we can extend it to find majority elements that appear more than **n/3** times.\\nIn this case, first we nneed to understand that there will be atmost 2 majority elements. This is pretty self explainatory if you read the question carefully.\\n\\nOkay, so just like we did in the simpler version of the problem, we take two elements as the majority element and maintain their frequency counts and once we find an element that differs from the two, we decrement both the elements\\' counts.  In this case we have to look for **triplets** instead of pairs. This essentially means that we form a triplet out of 2 majority and one non-majority element and remove them from the array. We repeat the process till we consider all array elements and simply verify if the elements we found are correct or not, which can be done in a single pass. \\n\\nPlease refer the code below and try to understand it with the explaination I provided above.\\n**Time Complexity: O(n)\\nSpace Complexity: O(1)**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) \\n    {\\n        int sz = nums.size();\\n        int num1 = -1, num2 = -1, count1 = 0, count2 = 0, i;\\n        for (i = 0; i < sz; i++)\\n        {\\n            if (nums[i] == num1)\\n                count1++;\\n            else if (nums[i] == num2)\\n                count2++;\\n            else if (count1 == 0)\\n            {\\n                num1 = nums[i];\\n                count1 = 1;\\n            }    \\n            else if (count2 == 0)\\n            {\\n                num2 = nums[i];\\n                count2 = 1;\\n            }\\n            else\\n            {\\n                count1--;\\n                count2--;\\n            }\\n        }\\n        vector<int> ans;\\n        count1 = count2 = 0;\\n        for (i = 0; i < sz; i++)\\n        {\\n            if (nums[i] == num1)\\n                count1++;\\n            else if (nums[i] == num2)\\n                count2++;\\n        }\\n        if (count1 > sz/3)\\n            ans.push_back(num1);\\n        if (count2 > sz/3)\\n            ans.push_back(num2);\\n        return ans;\\n    }\\n};\\n```\\n\\nNow once we understand this we can extend this approcah to find all elements that appear more than  n/k  times.\\nI\\'ll leave this task upto the readers.\\nIn this version, time complexity will remain **O(n)** only but space complexity will be **O(k)**.\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint count = 0, ans;\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            if (count == 0)\\n                ans = nums[i];\\n            count += nums[i] == ans ? 1 : -1;\\n        }\\n        return ans;\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) \\n    {\\n        int sz = nums.size();\\n        int num1 = -1, num2 = -1, count1 = 0, count2 = 0, i;\\n        for (i = 0; i < sz; i++)\\n        {\\n            if (nums[i] == num1)\\n                count1++;\\n            else if (nums[i] == num2)\\n                count2++;\\n            else if (count1 == 0)\\n            {\\n                num1 = nums[i];\\n                count1 = 1;\\n            }    \\n            else if (count2 == 0)\\n            {\\n                num2 = nums[i];\\n                count2 = 1;\\n            }\\n            else\\n            {\\n                count1--;\\n                count2--;\\n            }\\n        }\\n        vector<int> ans;\\n        count1 = count2 = 0;\\n        for (i = 0; i < sz; i++)\\n        {\\n            if (nums[i] == num1)\\n                count1++;\\n            else if (nums[i] == num2)\\n                count2++;\\n        }\\n        if (count1 > sz/3)\\n            ans.push_back(num1);\\n        if (count2 > sz/3)\\n            ans.push_back(num2);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 63571,
                "title": "my-c-solution",
                "content": "   \\n    vector<int> majorityElement(vector<int>& nums) {\\n        int cnt1 = 0, cnt2 = 0, a=0, b=1;\\n        \\n        for(auto n: nums){\\n            if (a==n){\\n                cnt1++;\\n            }\\n            else if (b==n){\\n                cnt2++;\\n            }\\n            else if (cnt1==0){\\n                a = n;\\n                cnt1 = 1;\\n            }\\n            else if (cnt2 == 0){\\n                b = n;\\n                cnt2 = 1;\\n            }\\n            else{\\n                cnt1--;\\n                cnt2--;\\n            }\\n        }\\n        \\n        cnt1 = cnt2 = 0;\\n        for(auto n: nums){\\n            if (n==a)   cnt1++;\\n            else if (n==b)  cnt2++;\\n        }\\n        \\n        vector<int> res;\\n        if (cnt1 > nums.size()/3)   res.push_back(a);\\n        if (cnt2 > nums.size()/3)   res.push_back(b);\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "   \\n    vector<int> majorityElement(vector<int>& nums) {\\n        int cnt1 = 0, cnt2 = 0, a=0, b=1;\\n        \\n        for(auto n: nums){\\n            if (a==n){\\n                cnt1++;\\n            }\\n            else if (b==n){\\n                cnt2++;\\n            }\\n            else if (cnt1==0){\\n                a = n;\\n                cnt1 = 1;\\n            }\\n            else if (cnt2 == 0){\\n                b = n;\\n                cnt2 = 1;\\n            }\\n            else{\\n                cnt1--;\\n                cnt2--;\\n            }\\n        }\\n        \\n        cnt1 = cnt2 = 0;\\n        for(auto n: nums){\\n            if (n==a)   cnt1++;\\n            else if (n==b)  cnt2++;\\n        }\\n        \\n        vector<int> res;\\n        if (cnt1 > nums.size()/3)   res.push_back(a);\\n        if (cnt2 > nums.size()/3)   res.push_back(b);\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 63522,
                "title": "boyer-moore-majority-vote-algorithm-generalization",
                "content": "Boyer-Moore Majority Vote algorithm generalization to elements appear more than floor(n/k) times\\n\\n    class Solution {\\n    public:\\n      vector<int> majorityElement(vector<int> &a) {\\n        int y = 0, z = 1, cy = 0, cz = 0;\\n        for (auto x: a) {\\n          if (x == y) cy++;\\n          else if (x == z) cz++;\\n          else if (! cy) y = x, cy = 1;\\n          else if (! cz) z = x, cz = 1;\\n          else cy--, cz--;\\n        }\\n        cy = cz = 0;\\n        for (auto x: a)\\n          if (x == y) cy++;\\n          else if (x == z) cz++;\\n        vector<int> r;\\n        if (cy > a.size()/3) r.push_back(y);\\n        if (cz > a.size()/3) r.push_back(z);\\n        return r;\\n      }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n      vector<int> majorityElement(vector<int> &a) {\\n        int y = 0, z = 1, cy = 0, cz = 0;\\n        for (auto x: a) {\\n          if (x == y) cy++;\\n          else if (x == z) cz++;\\n          else if (! cy) y = x, cy = 1;\\n          else if (! cz) z = x, cz = 1;\\n          else cy--, cz--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 858872,
                "title": "python-voting-o-n-solution-explained",
                "content": "Let us iterate through our data and at each moment of time keep at most `2` candidates with the highest score, let us consider example `1 2 3 3 3 2 2 2 4 2`.\\n\\n1. On first step we add `1` to our candidates, frequency `1`, so we have `1: 1`\\n2. Now we add `2` to our candidates, frequency `1`, so we have `1:1, 2:1`.\\n3. Now we add `3` to our candidates and we have `1:1, 2:1, 3:1`. Now we subtract `1` from all frequencies, because it will not change anything.\\n4. Now we add `3`, so we have `3:1`.\\n5. Now we add `3`, so we have `3:2`.\\n6. Now we add `2`, so we have `3:2, 2:1`.\\n7. Now we add `2`, so we have `3:2, 2:2`.\\n8. Now we add `2`, so we have `3:2, 2:3`.\\n9. Now we add `4`, so we have `3:2, 2:3, 4:1`, subtract `1` from all, and we have `3:1, 2:2`.\\n10. Finally we add `2`, so we have `3:1, 2:3`.\\n\\nFirst stage of our algorithm is finished, we have no more than two candidates. Now we need to make sure, that these candidates indeed has frequence more than `[n/3]`. So we iterate through our data once again and count them. In our case `2` is true candidate and `3` need to be removed, its frequency is not big enough.\\n\\n**Complexity**: Time complexity is `O(n)`, because we traverse our `nums` twice: on first run we process each number at most twice: when we add it to counter and when remove. Second run, where we evaluate frequencies of candidates is also linear. Space complexity is `O(1)`, because our counter always have no more than `3` elements.\\n\\n```\\nclass Solution:\\n    def majorityElement(self, nums):\\n        count = Counter()\\n        for num in nums:\\n            count[num] += 1\\n            if len(count) == 3:\\n                new_count = Counter()\\n                for elem, freq in count.items(): \\n                    if freq != 1: new_count[elem] = freq - 1\\n                count = new_count\\n                    \\n        cands = Counter(num for num in nums if num in count)      \\n        return [num for num in cands if cands[num] > len(nums)/3]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def majorityElement(self, nums):\\n        count = Counter()\\n        for num in nums:\\n            count[num] += 1\\n            if len(count) == 3:\\n                new_count = Counter()\\n                for elem, freq in count.items(): \\n                    if freq != 1: new_count[elem] = freq - 1\\n                count = new_count\\n                    \\n        cands = Counter(num for num in nums if num in count)      \\n        return [num for num in cands if cands[num] > len(nums)/3]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 63592,
                "title": "my-o-n-time-solution-20ms",
                "content": "My idea comes from Majority Vote algroithm,[http://www.cs.utexas.edu/~moore/best-ideas/mjrty/index.html][1].Now we vote two numbers simultaneously. if the next number is differents from them both.then the two numbers' votes minus one. If some number's vote comes zero,then vote the next number.Every time vote minus,it is the same that we remove the three numbers from the array.And the majority elemnts of original still are the majority elements  in the end. So check t1 and t2 are the majority elements of original array at last.\\n\\n    vector<int> majorityElement(vector<int>& nums) {\\n            int t1,t2,n1=0,n2=0;  //numbers t1 and t2,votes' numbers n1,and n2.\\n            for(int i=0;i<nums.size();++i)\\n            {\\n                if(n1!=0&&t1==nums[i]){++n1;continue;} \\n                if(n2!=0&&t2==nums[i]){++n2;continue;}\\n                if(n1==0){ t1=nums[i];++n1;continue;}\\n                if(n2==0){ t2=nums[i];++n2;continue;}\\n                --n1;--n2;\\n            }\\n            int z1=0,z2=0;\\n            for(int i=0;i<nums.size();++i)\\n            {\\n                if(n1>0){ if(nums[i]==t1) ++z1;}\\n                if(n2>0) {if(nums[i]==t2) ++z2;}\\n            }\\n            vector<int> ret;\\n             //check t1 and t2.\\n            if(z1>nums.size()/3) ret.push_back(t1);\\n            if(z2>nums.size()/3) ret.push_back(t2);\\n            return ret;\\n        }\\n\\n\\n  [1]: http://www.cs.utexas.edu/~moore/best-ideas/mjrty/index.html",
                "solutionTags": [
                    "C++"
                ],
                "code": "My idea comes from Majority Vote algroithm,[http://www.cs.utexas.edu/~moore/best-ideas/mjrty/index.html][1].Now we vote two numbers simultaneously. if the next number is differents from them both.then the two numbers' votes minus one. If some number's vote comes zero,then vote the next number.Every time vote minus,it is the same that we remove the three numbers from the array.And the majority elemnts of original still are the majority elements  in the end. So check t1 and t2 are the majority elements of original array at last.\\n\\n    vector<int> majorityElement(vector<int>& nums) {\\n            int t1,t2,n1=0,n2=0;  //numbers t1 and t2,votes' numbers n1,and n2.\\n            for(int i=0;i<nums.size();++i)\\n            {\\n                if(n1!=0&&t1==nums[i]){++n1;continue;} \\n                if(n2!=0&&t2==nums[i]){++n2;continue;}\\n                if(n1==0){ t1=nums[i];++n1;continue;}\\n                if(n2==0){ t2=nums[i];++n2;continue;}\\n                --n1;--n2;\\n            }\\n            int z1=0,z2=0;\\n            for(int i=0;i<nums.size();++i)\\n            {\\n                if(n1>0){ if(nums[i]==t1) ++z1;}\\n                if(n2>0) {if(nums[i]==t2) ++z2;}\\n            }\\n            vector<int> ret;\\n             //check t1 and t2.\\n            if(z1>nums.size()/3) ret.push_back(t1);\\n            if(z2>nums.size()/3) ret.push_back(t2);\\n            return ret;\\n        }\\n\\n\\n  [1]: http://www.cs.utexas.edu/~moore/best-ideas/mjrty/index.html",
                "codeTag": "Unknown"
            },
            {
                "id": 63584,
                "title": "concise-java-solution-based-on-moore-s-voting-algorithm",
                "content": "**Explanation**\\n\\nThe basic idea is based on Moore's Voting Algorithm, we need two candidates with top 2 frequency. If meeting different number from the candidate, then decrease 1 from its count, or increase 1 on the opposite condition. Once count equals 0, then switch the candidate to the current number. The trick is that we need to count again for the two candidates after the first loop.  Finally, output the numbers appearing more than n/3 times.\\n\\nThanks for [yanggao][1]'s smart advice!\\n\\n\\n    public List<Integer> majorityElement(int[] nums) {\\n    \\t  \\tArrayList<Integer> res = new ArrayList<Integer>();\\n            if (nums.length==0) return res;\\n            \\n            int count[] = new int[2];        \\n            int x[] = new int[2];       \\n       \\n            x[0] = 0; x[1] = 1;        \\n            for (int i = 0; i < nums.length; i++) {\\n            \\tif (x[0] == nums[i])\\n            \\t\\tcount[0]++;\\n            \\telse if (x[1] == nums[i])\\n            \\t\\tcount[1]++;\\n            \\telse if (count[0] == 0) {\\n            \\t\\tx[0] = nums[i];\\n            \\t\\tcount[0] = 1;\\n            \\t} else if (count[1] == 0) {\\n            \\t\\tx[1] = nums[i];\\n            \\t\\tcount[1] = 1;\\n            \\t} else {\\n            \\t\\tcount[0]--;\\n            \\t\\tcount[1]--;        \\t\\t\\n            \\t}\\n            }\\n            \\n            Arrays.fill(count, 0);\\n            for (int i : nums) {// Count again for x1, x2\\n        \\tif (i == x[0]) count[0]++;\\n        \\telse if (i == x[1]) count[1]++;\\n        }\\n        for (int j = 0; j < 2; j++) {\\n        \\tif (count[j] > nums.length/3 && !res.contains(x[j])) res.add(x[j]);\\n        }        \\n        return res;\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/user/yanggao",
                "solutionTags": [],
                "code": "**Explanation**\\n\\nThe basic idea is based on Moore's Voting Algorithm, we need two candidates with top 2 frequency. If meeting different number from the candidate, then decrease 1 from its count, or increase 1 on the opposite condition. Once count equals 0, then switch the candidate to the current number. The trick is that we need to count again for the two candidates after the first loop.  Finally, output the numbers appearing more than n/3 times.\\n\\nThanks for [yanggao][1]'s smart advice!\\n\\n\\n    public List<Integer> majorityElement(int[] nums) {\\n    \\t  \\tArrayList<Integer> res = new ArrayList<Integer>();\\n            if (nums.length==0) return res;\\n            \\n            int count[] = new int[2];        \\n            int x[] = new int[2];       \\n       \\n            x[0] = 0; x[1] = 1;        \\n            for (int i = 0; i < nums.length; i++) {\\n            \\tif (x[0] == nums[i])\\n            \\t\\tcount[0]++;\\n            \\telse if (x[1] == nums[i])\\n            \\t\\tcount[1]++;\\n            \\telse if (count[0] == 0) {\\n            \\t\\tx[0] = nums[i];\\n            \\t\\tcount[0] = 1;\\n            \\t} else if (count[1] == 0) {\\n            \\t\\tx[1] = nums[i];\\n            \\t\\tcount[1] = 1;\\n            \\t} else {\\n            \\t\\tcount[0]--;\\n            \\t\\tcount[1]--;        \\t\\t\\n            \\t}\\n            }\\n            \\n            Arrays.fill(count, 0);\\n            for (int i : nums) {// Count again for x1, x2\\n        \\tif (i == x[0]) count[0]++;\\n        \\telse if (i == x[1]) count[1]++;\\n        }\\n        for (int j = 0; j < 2; j++) {\\n        \\tif (count[j] > nums.length/3 && !res.contains(x[j])) res.add(x[j]);\\n        }        \\n        return res;\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/user/yanggao",
                "codeTag": "Unknown"
            },
            {
                "id": 63599,
                "title": "boyer-moore-method-java-implementation",
                "content": "    public class Solution{\\n    \\tpublic List<Integer> majorityElement(int[] nums){\\n    \\t\\tList<Integer> rst = new ArrayList<Integer>();\\n    \\t\\tif(nums == null || nums.length == 0) return rst;\\n    \\t\\tint count1 = 0, count2 = 0, candidate1 = 0, candidate2 = 1;\\n    \\t\\tfor(int num : nums){\\n    \\t\\t\\tif(num == candidate1) count1++;\\n    \\t\\t\\telse if(num == candidate2) count2++;\\n    \\t\\t\\telse if(count1 == 0){\\n    \\t\\t\\t\\tcandidate1 = num;\\n    \\t\\t\\t\\tcount1 = 1;\\n    \\t\\t\\t}\\n    \\t\\t\\telse if(count2 == 0){\\n    \\t\\t\\t\\tcandidate2 = num;\\n    \\t\\t\\t\\tcount2 = 1;\\n    \\t\\t\\t}\\n    \\t\\t\\telse{\\n    \\t\\t\\t\\tcount1--;\\n    \\t\\t\\t\\tcount2--;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tcount1 = 0; count2 = 0;\\n    \\t\\tfor(int num : nums){\\n    \\t\\t\\tif(num == candidate1) count1+=2;\\n    \\t\\t\\telse count1--;\\n    \\t\\t\\tif(num == candidate2) count2 += 2;\\n    \\t\\t\\telse count2--;\\n    \\t\\t}\\n    \\t\\tif(count1 > 0) rst.add(candidate1);\\n    \\t\\tif(count2 > 0) rst.add(candidate2);\\n    \\t\\treturn rst;\\n    \\t}\\n    }",
                "solutionTags": [],
                "code": "class Solution{\\n    \\tpublic List<Integer> majorityElement(int[] nums){\\n    \\t\\tList<Integer> rst = new ArrayList<Integer>();\\n    \\t\\tif(nums == null || nums.length == 0) return rst;\\n    \\t\\tint count1 = 0, count2 = 0, candidate1 = 0, candidate2 = 1;\\n    \\t\\tfor(int num : nums){\\n    \\t\\t\\tif(num == candidate1) count1++;\\n    \\t\\t\\telse if(num == candidate2) count2++;\\n    \\t\\t\\telse if(count1 == 0){\\n    \\t\\t\\t\\tcandidate1 = num;\\n    \\t\\t\\t\\tcount1 = 1;\\n    \\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 858925,
                "title": "c-boyer-moore-algorithm-based-solution-explained-100-time-50-space",
                "content": "For more info on the algorithm used here, [click](https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm).\\n\\nIn our code we start first of all declaring a few support variables:\\n* `cand1` and `cand2` that will store our currently most frequent elements;\\n* `vote1` and `vote2` that will somehow store their frequency relatively to other numbers (still, they do not measure frequency per se at the first pass, see below more about it);\\n* `lmt` which is the threshold every candidate has to pass in order to qualify.\\n\\nAfter that, we do a first linear run through `nums` and we can have a few cases:\\n* `n == cand1`, so we increment `vote1`;\\n* `n == cand2`, so we increment `vote2`;\\n* `vote1` is `0`, so we assign `cand1 = n`;\\n* `vote2` is `0`, so we assign `cand2 = n`;\\n* In all the other cases (meaning both `vote1 > 0` and `vote2 > 0` and `n != cand1` and `n != cand2`), we decrease both `vote1` and `vote2`.\\n\\nYou might note that the order of the conditionals matters a lot (you might alter it, but then you would need extra conditionals) and that we will never end with both `vote1 == 0` and `vote2 == 0` at the same time.\\n\\nNow, as we mentioned before, both votes do not really equate to the actual frequency, since we basically decrease them everytime we encounter another number. Think of a base case like `{1, 1, 1, 3, 3, 2, 2, 2}` and if you execture it step by step, you will see that, for example, `cand1 == 1` and also `vote1 == 1`, so definitely not its frequency.\\n\\nTo obviate to this and get the actual frequency, we can reset both votes to `0` and then loop again through `nums` increasing these 2 counter variables acccordingly.\\n\\nFinally, time to return: you might just create an empty vector and add each candidate that passed the `> lmt` requirement, but I found it boring, so I opted to first of all make sure that `vote1 >= vote2`, always and then went for a nested ternary operator; alternatively you might have a more complex logic in the ternary operator if you do not check and potentially swap the values - up to your taste, really!\\n\\nWhatever you choose to do, the last step is pretty straightforward once you have 2 candidates and their actual frequency, so just return all the candidates that fit and you are done :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        // support variables\\n        int cand1, vote1 = 0, cand2, vote2 = 0, lmt = nums.size() / 3;\\n        // looking for the 2 most frequent items\\n        for (int n: nums) {\\n            if (n == cand1) vote1++;\\n            else if (n == cand2) vote2++;\\n            else if (!vote1) {\\n                cand1 = n;\\n                vote1++;\\n            }\\n            else if (!vote2) {\\n                cand2 = n;\\n                vote2++;\\n            }\\n            else {\\n                vote1--;\\n                vote2--;\\n            }\\n        }\\n        // checking the actual frequency of the 2 most common items\\n        vote1 = 0;\\n        vote2 = 0;\\n        for (int n: nums) {\\n            if (n == cand1) vote1++;\\n            if (n == cand2) vote2++;\\n        }\\n        // making sure cand1 has more votes\\n        if (vote1 < vote2) {\\n            swap(cand1, cand2);\\n            swap(vote1, vote2);\\n        }\\n        return vote1 <= lmt ? vector<int>{} : vote2 <=lmt ? vector<int>{cand1} : vector<int>{cand1, cand2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        // support variables\\n        int cand1, vote1 = 0, cand2, vote2 = 0, lmt = nums.size() / 3;\\n        // looking for the 2 most frequent items\\n        for (int n: nums) {\\n            if (n == cand1) vote1++;\\n            else if (n == cand2) vote2++;\\n            else if (!vote1) {\\n                cand1 = n;\\n                vote1++;\\n            }\\n            else if (!vote2) {\\n                cand2 = n;\\n                vote2++;\\n            }\\n            else {\\n                vote1--;\\n                vote2--;\\n            }\\n        }\\n        // checking the actual frequency of the 2 most common items\\n        vote1 = 0;\\n        vote2 = 0;\\n        for (int n: nums) {\\n            if (n == cand1) vote1++;\\n            if (n == cand2) vote2++;\\n        }\\n        // making sure cand1 has more votes\\n        if (vote1 < vote2) {\\n            swap(cand1, cand2);\\n            swap(vote1, vote2);\\n        }\\n        return vote1 <= lmt ? vector<int>{} : vote2 <=lmt ? vector<int>{cand1} : vector<int>{cand1, cand2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 63654,
                "title": "o-n-time-o-1-space",
                "content": "    public class Solution {\\n        public List<Integer> majorityElement(int[] nums) {\\n            List<Integer> rst = new ArrayList<Integer>();\\n            if (nums == null) {\\n                return rst;\\n            }\\n            int n1 = 0, n2 = 0;\\n            int c1 = 0, c2 = 0;\\n            for (int i = 0; i < nums.length; ++i) {\\n                int n3 = nums[i];\\n                if (c1 > 0 && c2 > 0) {\\n                    if (n3 != n1 && n3 != n2) {\\n                        c1--;\\n                        c2--;\\n                    } else if (n3 == n1) {\\n                        c1++;\\n                    } else {\\n                        c2++;\\n                    }\\n                } else if (c1 > 0) {\\n                    if (n3 == n1) {\\n                        c1++;\\n                    } else {\\n                        n2 = n3;\\n                        c2++;\\n                    }\\n                } else if (c2 > 0) {\\n                    if (n3 == n2) {\\n                        c2++;\\n                    } else {\\n                        n1 = n3;\\n                        c1++;\\n                    }\\n                } else {\\n                    n1 = n3;\\n                    c1++;\\n                }\\n            }\\n            c1 = c2 = 0;\\n            for (int i = 0; i < nums.length; ++i) { // n1, n2 are only candidates!!! need to count again!!!\\n                if (nums[i] == n1) {\\n                    c1 ++;\\n                } else if (nums[i] == n2) { //no worry if n1==n2 in some cases, because we only count once.\\n                    c2 ++;\\n                }\\n            }\\n            if (c1 > nums.length/3) {\\n                rst.add(n1);\\n            }\\n            if (c2 > nums.length/3) {\\n                rst.add(n2);\\n            }\\n            return rst;\\n        }\\n    }\\n\\nn1, n2 are 2 distinct numbers. c1, c2 are the count of the 2 numbers.\\nWhenever encounter 3 different numbers, cancel them by decreasing the count. And the remaining 2 numbers (or 1 or 0) are candidates. Scan the array one more time to determine the result.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<Integer> majorityElement(int[] nums) {\\n            List<Integer> rst = new ArrayList<Integer>();\\n            if (nums == null) {\\n                return rst;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 617643,
                "title": "python-scalable-general-no-math-o-n-time-o-1-space-90-faster",
                "content": "**This solution aimes to be general and without mathematical calculations yet in  O(1) Space, O(n) Time**\\n\\nAccording to a mathematical proof \\nthe (n/3) will give us 2 majority votes, \\nbut what happens if you faced n/2,n/4, n/5, n/6...n/k, don\\'t know the mathematical proof of the number of candidates you will need exactly and yet you want to implement it in constant space O(constant)?\\n\\nMy solution is to use the denominater in (n/k) which is the k and set it as constant space to save k candidates and apply the same algorithm of Moore Majority Vote in the easy problem https://leetcode.com/problems/majority-element/\\n\\n* if element is found in our map of candidates, we +1 its value (count)\\n* if there is room to add a new candidate (candidates number <  k ), we add it\\n* if our space is full and no room to add any new candidate we -1 all candidates\\n* we want to remove the candidates that have reached zero and keep only the candidates who are >= 1, therefore we create a temp_dict and then we make the old dict (candidates) = temp_dict\\n* At the end in linear time we go through the original array to count the number of times our suggest candidates appeared and check if they are > n//3\\n\\n\\n\\t\\tclass Solution:\\n\\t\\t\\tdef majorityElement(self, nums: List[int]) -> List[int]:\\n\\t\\t\\t\\tcandidates = {}\\n\\t\\t\\t\\tk = 3\\n\\t\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\t\\tif num in candidates:\\n\\t\\t\\t\\t\\t\\tcandidates[num] += 1\\n\\t\\t\\t\\t\\telif len(candidates) < k:\\n\\t\\t\\t\\t\\t\\tcandidates[num] = 1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\ttemp={}\\n\\t\\t\\t\\t\\t\\tfor c in candidates:\\n\\t\\t\\t\\t\\t\\t\\tcandidates[c]-=1\\n\\t\\t\\t\\t\\t\\t\\tif candidates[c] >= 1:\\n\\t\\t\\t\\t\\t\\t\\t\\ttemp[c] = candidates[c]\\n\\t\\t\\t\\t\\t\\tcandidates = temp\\n\\t\\t\\t\\tout = [k for k in candidates if nums.count(k) > len(nums) // 3]          \\n\\t\\t\\t\\treturn out",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n\\t\\t\\tdef majorityElement(self, nums: List[int]) -> List[int]:\\n\\t\\t\\t\\tcandidates = {}",
                "codeTag": "Java"
            },
            {
                "id": 2029057,
                "title": "c-using-boyer-moore-voting-algorithm",
                "content": "```\\nApproach 1: Boyer-Moore Voting Algorithm\\nIntuition\\n\\nTo figure out a O(1) space requirement, we would need to get this simple intuition first. For an array of length n:\\n\\t\\tThere can be at most one majority element which is more than \\u230An/2\\u230B times.\\n\\t\\tThere can be at most two majority elements which are more than \\u230An/3\\u230B times.\\n\\t\\tThere can be at most three majority elements which are more than \\u230An/4\\u230B times.\\n\\t\\tand so on.\\n```\\n```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int candidate1 = -1, candidate2 = -1;\\n        int count1 = 0, count2 = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(candidate1 == nums[i]){\\n                count1++;\\n            }\\n            else if(candidate2 == nums[i]){\\n                count2++;\\n            }\\n            else if(count1 == 0){\\n                candidate1 = nums[i];\\n                count1++;\\n            }\\n            else if(count2 == 0){\\n                candidate2 = nums[i];\\n                count2++;\\n            }\\n            //if it is not equal to any of these then simply reduce the both count.\\n            else{\\n                count1--;\\n                count2--;\\n            }\\n            \\n        }\\n        //check whether these potential candidate are really in majority or not.\\n        vector<int> ans;\\n        count1 = 0;\\n        count2 = 0;\\n        for(auto x : nums){\\n            if(candidate1 == x) count1++;\\n            else if(candidate2 == x) count2++;\\n        }\\n        if(count1 > nums.size()/3) ans.push_back(candidate1);\\n        if(count2 > nums.size()/3) ans.push_back(candidate2);\\n        return ans;\\n        \\n    }\\n};\\n```\\n**Guys please if you like the solution then give an upvote for me. thanks for reading**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nApproach 1: Boyer-Moore Voting Algorithm\\nIntuition\\n\\nTo figure out a O(1) space requirement, we would need to get this simple intuition first. For an array of length n:\\n\\t\\tThere can be at most one majority element which is more than \\u230An/2\\u230B times.\\n\\t\\tThere can be at most two majority elements which are more than \\u230An/3\\u230B times.\\n\\t\\tThere can be at most three majority elements which are more than \\u230An/4\\u230B times.\\n\\t\\tand so on.\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int candidate1 = -1, candidate2 = -1;\\n        int count1 = 0, count2 = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(candidate1 == nums[i]){\\n                count1++;\\n            }\\n            else if(candidate2 == nums[i]){\\n                count2++;\\n            }\\n            else if(count1 == 0){\\n                candidate1 = nums[i];\\n                count1++;\\n            }\\n            else if(count2 == 0){\\n                candidate2 = nums[i];\\n                count2++;\\n            }\\n            //if it is not equal to any of these then simply reduce the both count.\\n            else{\\n                count1--;\\n                count2--;\\n            }\\n            \\n        }\\n        //check whether these potential candidate are really in majority or not.\\n        vector<int> ans;\\n        count1 = 0;\\n        count2 = 0;\\n        for(auto x : nums){\\n            if(candidate1 == x) count1++;\\n            else if(candidate2 == x) count2++;\\n        }\\n        if(count1 > nums.size()/3) ans.push_back(candidate1);\\n        if(count2 > nums.size()/3) ans.push_back(candidate2);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 63615,
                "title": "ac-clean-java-solution",
                "content": "    public List<Integer> majorityElement(int[] a) {\\n      // we can only have maximum 2 majority elements\\n      int n = a.length;\\n      int c1 = 0, c2 = 0;\\n      Integer m1 = null, m2 = null;\\n      \\n      // step 1. find out those 2 majority elements\\n      // using Moore majority voting algorithm\\n      for (int i = 0; i < n; i++) {\\n        if (m1 != null && a[i] == m1)      { c1++; } \\n        else if (m2 != null && a[i] == m2) { c2++; }\\n        else if (c1 == 0)                  { m1 = a[i]; c1 = 1; }\\n        else if (c2 == 0)                  { m2 = a[i]; c2 = 1; } \\n        else                               { c1--; c2--; }\\n      }\\n      \\n      // step 2. double check\\n      c1 = 0; c2 = 0;\\n      \\n      for (int i = 0; i < n; i++) {\\n        if (m1 != null && a[i] == m1) c1++;\\n        if (m2 != null && a[i] == m2) c2++;\\n      }\\n      \\n      List<Integer> res = new ArrayList<Integer>();\\n      \\n      if (c1 > n / 3) res.add(m1);\\n      if (c2 > n / 3) res.add(m2);\\n      \\n      return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<Integer> majorityElement(int[] a) {\\n      // we can only have maximum 2 majority elements\\n      int n = a.length;\\n      int c1 = 0, c2 = 0;\\n      Integer m1 = null, m2 = null;\\n      \\n      // step 1. find out those 2 majority elements\\n      // using Moore majority voting algorithm\\n      for (int i = 0; i < n; i++) {\\n        if (m1 != null && a[i] == m1)      { c1++; } \\n        else if (m2 != null && a[i] == m2) { c2++; }\\n        else if (c1 == 0)                  { m1 = a[i]; c1 = 1; }\\n        else if (c2 == 0)                  { m2 = a[i]; c2 = 1; } \\n        else                               { c1--; c2--; }\\n      }\\n      \\n      // step 2. double check\\n      c1 = 0; c2 = 0;\\n      \\n      for (int i = 0; i < n; i++) {\\n        if (m1 != null && a[i] == m1) c1++;\\n        if (m2 != null && a[i] == m2) c2++;\\n      }\\n      \\n      List<Integer> res = new ArrayList<Integer>();\\n      \\n      if (c1 > n / 3) res.add(m1);\\n      if (c2 > n / 3) res.add(m2);\\n      \\n      return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1221568,
                "title": "o-n-time-o-1-space-solution-easy-to-understand",
                "content": "//  Basic idea is to use Boyer Moore Voting Algo\\n//  there can be atmost 2 elements in the array which can become maximum element because \\n// 3*(n/3) = n it is possible that only 3 elements can occir exactly n/3 times in the array\\n// if any element is appearing more than n/3 times atmost 2 elements can be the maximun element...\\n\\n\\n// now we will maintain two variables num1 , num 2 to store the value of frequently appearing elements using extended boyer moore algo\\n\\n\\n\\t\\t\\t\\t\\tclass Solution {\\n\\t\\t\\t\\t\\t\\tpublic List<Integer> majorityElement(int[] nums) {\\n\\t\\t\\t\\t\\t\\t   List<Integer> list = new ArrayList<>();\\n\\t\\t\\t\\t\\t\\t\\t if(nums == null) return list;\\n\\t\\t\\t\\t\\t\\t\\tint num1=0;\\n\\t\\t\\t\\t\\t\\t\\tint num2=0;\\n\\t\\t\\t\\t\\t\\t\\tint count1=0;\\n\\t\\t\\t\\t\\t\\t\\tint count2=0;\\n\\t\\t\\t\\t\\t\\t\\tfor(int i=0;i<nums.length;i++){\\n\\t\\t\\t\\t\\t\\t\\t\\tint num3 = nums[i];\\n\\t\\t\\t\\t\\t\\t\\t\\tif(count1>0 && count2>0){\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(num3 == num1){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tcount1++;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}else if(num3 ==num2){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tcount2++;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tcount1--;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tcount2--;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}else if(count1 >0){\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(num3 == num1){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tcount1++;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnum2 = num3;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tcount2++;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}else if(count2>0){\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(num3 == num2){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tcount2++;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnum1 = num3;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tcount1++;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tnum1 = num3;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcount1++;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t//         now we have the values that appears frequently in the array but it doesnot means that they both are maximum elements .........\\n\\t\\t\\t\\t\\t//         so we have to iterate again over the array to cehck for maximum element out of both .......\\n\\n\\t\\t\\t\\t\\t\\t\\tcount1=0;\\n\\t\\t\\t\\t\\t\\t\\tcount2=0;\\n\\n\\t\\t\\t\\t\\t\\t\\tfor(int i=0;i<nums.length;i++){\\n\\t\\t\\t\\t\\t\\t\\t\\tif(nums[i] == num1){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcount1++;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\telse if(nums[i] ==num2){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcount2++;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tif(count1>nums.length/3){\\n\\t\\t\\t\\t\\t\\t\\t\\tlist.add(num1);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tif(count2>nums.length/3){\\n\\t\\t\\t\\t\\t\\t\\t\\tlist.add(num2);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\treturn list;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t// if you have any doubt let me know in the comments........\\n\\t\\t\\t\\t// if the solution is helpful please UpVote \\n\\n",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "class Solution {\\n\\t\\t\\t\\t\\t\\tpublic List<Integer> majorityElement(int[] nums) {\\n\\t\\t\\t\\t\\t\\t   List<Integer> list = new ArrayList<>();\\n\\t\\t\\t\\t\\t\\t\\t if(nums == null) return list;\\n\\t\\t\\t\\t\\t\\t\\tint num1=0;\\n\\t\\t\\t\\t\\t\\t\\tint num2=0;\\n\\t\\t\\t\\t\\t\\t\\tint count1=0;\\n\\t\\t\\t\\t\\t\\t\\tint count2=0;\\n\\t\\t\\t\\t\\t\\t\\tfor(int i=0;i<nums.length;i++){\\n\\t\\t\\t\\t\\t\\t\\t\\tint num3 = nums[i];\\n\\t\\t\\t\\t\\t\\t\\t\\tif(count1>0 && count2>0){\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(num3 == num1){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tcount1++;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 835696,
                "title": "2-methods-1-hashmap-2-without-hashmap-c-easy-understanding",
                "content": "```\\n1. TC:O(n) SC:O(n)\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int k=nums.size()/3;\\n        vector<int> vec;\\n        unordered_map<int,int> map;\\n        for(int i=0;i<nums.size();i++) map[nums[i]]++;\\n        for(auto i: map) if(i.second>k) vec.push_back(i.first);\\n        return vec;\\n    }\\n};\\'\\n\\n2. TC:O(n) SC:O(1)\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int count1=0,count2=0,num1=-1,num2=-1;\\n        for(int i=0;i<nums.size();i++){\\n            //If the current element is equal to one of the potential candidate, the count for that candidate is increased while leaving the count of the other candidate as it is.\\n            if(nums[i]==num1) count1++;\\n            else if(nums[i]==num2) count2++;\\n            //If the counter reaches zero, the candidate associated with that counter will be replaced with the next element if the next element is not equal to the other candidate as well.\\n            else if(count1==0) num1=nums[i],count1++;\\n            else if(count2==0) num2=nums[i],count2++;\\n            //Both counters are decremented only when the current element is different from both candidates.\\n            else count1--,count2--;\\n        }\\n        count1=0,count2=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==num1) count1++;\\n            else if(nums[i]==num2) count2++;\\n        }\\n        vector<int> ans;\\n        if(count1>(nums.size()/3)) ans.push_back(num1);\\n        if(count2>(nums.size()/3)) ans.push_back(num2);\\n        return ans;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case,**please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n1. TC:O(n) SC:O(n)\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int k=nums.size()/3;\\n        vector<int> vec;\\n        unordered_map<int,int> map;\\n        for(int i=0;i<nums.size();i++) map[nums[i]]++;\\n        for(auto i: map) if(i.second>k) vec.push_back(i.first);\\n        return vec;\\n    }\\n};\\'\\n\\n2. TC:O(n) SC:O(1)\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int count1=0,count2=0,num1=-1,num2=-1;\\n        for(int i=0;i<nums.size();i++){\\n            //If the current element is equal to one of the potential candidate, the count for that candidate is increased while leaving the count of the other candidate as it is.\\n            if(nums[i]==num1) count1++;\\n            else if(nums[i]==num2) count2++;\\n            //If the counter reaches zero, the candidate associated with that counter will be replaced with the next element if the next element is not equal to the other candidate as well.\\n            else if(count1==0) num1=nums[i],count1++;\\n            else if(count2==0) num2=nums[i],count2++;\\n            //Both counters are decremented only when the current element is different from both candidates.\\n            else count1--,count2--;\\n        }\\n        count1=0,count2=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==num1) count1++;\\n            else if(nums[i]==num2) count2++;\\n        }\\n        vector<int> ans;\\n        if(count1>(nums.size()/3)) ans.push_back(num1);\\n        if(count2>(nums.size()/3)) ans.push_back(num2);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 63542,
                "title": "quick-select-c-solution",
                "content": "The idea is to split the array into three parts according to the selected pivot:  left, middle and right. \\n\\nLet's say we have two indices m and n, so that all elements in [0 ... m-1] are less than the pivot, elements in [m...n] are equal to the pivot (two ends inclusive), [n+1 ... end] contains elements greater than the pivot.  Then there are some facts: \\n\\n - if n - m + 1 >= 1 + nums.size()/3, nums[m] must be added to the\\n   results.\\n - If m - 1 < 1 + nums.size()/3, we can simply abandon the left part, otherwise we have to consider it.\\n - if nums.size()-n < 1+nums.size()/3, the right part can be dropped, otherwise it has to be checked.\\n\\nIdeally, we can drop about 1/3 of the array each time, so the running time is something like: 1 + 2/3 + (2/3)*(2/3) + ... = (1-(2/3)^k)/(1-2/3), O(n).\\n\\nA big advantage of this algorithm is that we can simply apply it to 1/4,1/5 ...\\n\\n    class Solution {\\n    private:\\n        void split( vector<int>& nums, int left, int right, int len, vector<int>& ans ) {\\n            if( left >= right ) return;\\n            int idx = (left + right)/2, val = nums[idx], i = left+1, j=left, k=left;\\n            swap(nums[idx],nums[left]);\\n            while( i < nums.size() ) {\\n                if( nums[i] < val ) {\\n                    swap( nums[k++], nums[i]);\\n                    swap( nums[++j], nums[i++]);\\n                } else if( nums[i] == val ) {\\n                    swap( nums[i++], nums[++j] );\\n                } else i++;\\n            }\\n            if( j - k + 1 >= len ) ans.push_back(nums[k]);\\n            if( k - left >= len ) split(nums, left, k, len, ans );\\n            if( right - j >= len ) split(nums, j+1, right, len, ans );\\n        }\\n    public:\\n        vector<int> majorityElement(vector<int>& nums) {\\n            vector<int> ans;\\n            if( nums.empty()) return ans;\\n            split( nums, 0, nums.size(), 1 + nums.size()/3, ans);\\n            return ans;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    private:\\n        void split( vector<int>& nums, int left, int right, int len, vector<int>& ans ) {\\n            if( left >= right ) return;\\n            int idx = (left + right)/2, val = nums[idx], i = left+1, j=left, k=left;\\n            swap(nums[idx],nums[left]);\\n            while( i < nums.size() ) {\\n                if( nums[i] < val ) {\\n                    swap( nums[k++], nums[i]);\\n                    swap( nums[++j], nums[i++]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 63590,
                "title": "a-general-solution-for-searching-elements-that-appear-more-n-k-times",
                "content": "It's based on Moore Voting Algorithm. For the question majorityElement ( finding an element that appears > n/2), return  (_majorityElementOfK(nums, 3))[0];\\n\\n    class Solution {\\n    public:\\n        vector<int> majorityElement(vector<int>& nums) {\\n           \\n            if (nums.empty()) return {};\\n            return _majorityElementOfK(nums, 3); \\n        }\\n        \\n        vector<int> _majorityElementOfK(const vector<int>& nums, int k){\\n            if (nums.empty()) return { };\\n            \\n            int helperSize = k - 1;\\n            vector<int> counters(helperSize,0);\\n            vector<int> elements(helperSize,0);\\n            \\n            int found = false;\\n          \\n            // find the possible elements that is greater than n/k, \\n            for (int num: nums){\\n                found = false;\\n                \\n                for (int i = 0; i < helperSize; ++i){\\n                    if (!counters[i] || num == elements[i]){\\n                        ++counters[i];\\n                        elements[i] = num;\\n                        found = true;\\n                        break;\\n                    }\\n                }\\n                \\n                if (!found){\\n                   for (int i = 0; i < helperSize; ++i){\\n                        --counters[i];\\n                    }\\n                }\\n            }\\n                \\n            // clear the counters and re-cal to get the correct frequencies\\n            for (int i = 0; i < helperSize; ++i){\\n                 counters[i] = 0;\\n            }\\n            \\n            for (int i = 0; i < nums.size(); ++i){\\n                for (int j = 0; j < helperSize; ++j){\\n                    if (elements[j] == nums[i]){\\n                        ++counters[j];\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            // push numbers to the result if it is more than n/k\\n            vector<int> result;\\n            for (int i = 0; i < helperSize; ++i){\\n                if (counters[i] > nums.size()/k) result.push_back(elements[i]);\\n            }\\n            \\n            return result;\\n            \\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> majorityElement(vector<int>& nums) {\\n           \\n            if (nums.empty()) return {}",
                "codeTag": "Java"
            },
            {
                "id": 63634,
                "title": "c-solution-with-explanation-o-n-time-and-o-1-space",
                "content": "\\n\\nWe can apply the same idea as easy version of majority element. If we remove three elements with different value at the same time, finally we should filter out the majority elements. So in the first pass, we search for possible majority elements (the number of majority element <3), and then for each candidate, we scan the array again to confirm wether it's majority or not.\\n\\n***Updated***\\n Some guys are confused by the first branch, i.e.\\n       \\n\\n     if(nums[i] == candidate1) count1 ++;\\n\\nHere we don't need to verify the value of count1. Why? Because if count1 is 0, and nums[i] = candidate1, \\nwe can still just add one to count1. It's logically safe.\\n\\n\\n----------\\n\\n\\n    class Solution {\\n    public:\\n        vector<int> majorityElement(vector<int>& nums) {\\n            int array_size = nums.size();\\n            int candidate1, candidate2;\\n            int count1 = 0;\\n            int count2 = 0;\\n            for(int i = 0; i < array_size; i ++){\\n                if(nums[i] == candidate1) count1 ++;\\n                else if(nums[i] == candidate2) count2 ++;\\n                else{\\n                    if(count1 && count2) {count1 --; count2 --;}\\n                    else if (count1){candidate2 = nums[i]; count2 = 1;}\\n                    else {candidate1 = nums[i]; count1 = 1;}\\n                }\\n            }\\n            vector<int> candidate;\\n            if(count1 > 0) candidate.push_back(candidate1);\\n            if(count2 > 0) candidate.push_back(candidate2);\\n            vector<int> result;\\n            for(int i = 0; i < candidate.size(); i ++){\\n                int count = 0;\\n                for(int j = 0; j < array_size; j ++){\\n                    if(nums[j] == candidate[i]) count ++;\\n                }\\n                if(count > array_size/3) result.push_back(candidate[i]);\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> majorityElement(vector<int>& nums) {\\n            int array_size = nums.size();\\n            int candidate1, candidate2;\\n            int count1 = 0;\\n            int count2 = 0;\\n            for(int i = 0; i < array_size; i ++){\\n                if(nums[i] == candidate1) count1 ++;\\n                else if(nums[i] == candidate2) count2 ++;\\n                else{\\n                    if(count1 && count2) {count1 --; count2 --;}",
                "codeTag": "Java"
            },
            {
                "id": 1787710,
                "title": "c-simplest-solution-moores-voting-algo",
                "content": "There can only be a maximum of ```2``` elements with a frequency greater than ```n/3```.\\n\\n**Moores Voting ALgorithm :**\\n* Set any two random candidates outside the range of elements in the array.\\n* If the element is equal to either of the candidates, increment its counter.\\n* If the counter of one candidate is equal to at any point, we set the current element as the candidate if this current element is not the other candidate.\\n* We decrease the counters of both candidates if the current element is not equal to either of the candidates.\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int n = nums.size(), me1 = INT_MIN, me2 = INT_MIN, cnt1 = 0, cnt2 = 0;\\n        for(auto x : nums){\\n            if(x == me1) cnt1++;\\n            else if(x == me2) cnt2++;\\n            else if(cnt1 == 0) me1 = x, cnt1++;\\n            else if(cnt2 == 0) me2 = x, cnt2++;\\n            else cnt1--, cnt2--;\\n        }\\n        \\n        cnt1 = 0; cnt2 = 0;\\n        for(auto x : nums){\\n            if(x == me1) cnt1++;\\n            else if(x == me2) cnt2++;\\n        }\\n        vector<int> ans;\\n        if(cnt1 > n/3) ans.push_back(me1);\\n        if(cnt2 > n/3) ans.push_back(me2);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Do upvote my post if you\\'ve found it useful :)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```2```\n```n/3```\n```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int n = nums.size(), me1 = INT_MIN, me2 = INT_MIN, cnt1 = 0, cnt2 = 0;\\n        for(auto x : nums){\\n            if(x == me1) cnt1++;\\n            else if(x == me2) cnt2++;\\n            else if(cnt1 == 0) me1 = x, cnt1++;\\n            else if(cnt2 == 0) me2 = x, cnt2++;\\n            else cnt1--, cnt2--;\\n        }\\n        \\n        cnt1 = 0; cnt2 = 0;\\n        for(auto x : nums){\\n            if(x == me1) cnt1++;\\n            else if(x == me2) cnt2++;\\n        }\\n        vector<int> ans;\\n        if(cnt1 > n/3) ans.push_back(me1);\\n        if(cnt2 > n/3) ans.push_back(me2);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1011894,
                "title": "generalised-boyer-moore-voting-majority-element-problem-floor-n-k-frequency-majority-element",
                "content": "Hey guys,\\n\\nThis is my point of view to approach the Majority Voting Algorithm in a generalised fashion.\\n\\nLet\\'s actually approach this problem from Voting\\'s point of view.\\n\\nIn every case I want you to visualise that you are part of a New Organisation of N people. You all decide to allot positions to some people for better functioning of the organisation for which Voting is best.\\n\\n**Case 1: Voting for President = Freq(Majority Element) > Floor(N/2)**\\n\\nIf N = 10 => Freq(ME) > 10/2 = 5\\nIn this case we can only have ONE person (President of the Organisation) getting majority votes. That person can either get 6,7,8,9,10 votes to be called President.\\n\\nRealise that in a set of N people, if you say that person who gets more than N/2 will be alloted a position, basically you mean to say there can either be *0 position(Like everyone gets one vote, or some gets 2) or 1 position(One guy/girl gets Majority votes).* This point is important.\\n\\nSome observations\\ni. If N = 10 and Freq(ME) = 6 => Rest votes = 4.\\nPresident won with a difference of 6-4 = 2.\\nii. If N = 10 and Freq(ME) = 5 => Rest votes = 5.\\nPresident won with a difference of 5-5 = 0. This statement is wrong. We want president to win by a difference of at least 1 hence his/her vote > Floor(N/2). This is the logical explanation to why we are stating that ME is the element with votes > Floor(N/2).\\niii. If N = 10 and Freq(ME) = 7 => Rest votes = 3.\\nPresident won with a difference of 7-3 = 4.\\n\\nExample: 7 7 5 7 5 1 5 7 5 5 7 7 5 5 5 5\\nN = 16. Freq(ME) > 16/2 = 8\\n\\nI want you to visualise the question properly. The elements like 7,5,1 are actually Names of people. The array is actually like a Box containing names of people. Person whos name appears more than N/2 times Wins President position.\\n\\nSo now we maintain a count variable that gets updated +1 when equal to ME and when not equal to ME updated to -1. When this count hits 0 what does that signify?\\nIt means that The prefix, the point before count = 0, exhausted majority elements with minority elements. \\nExample\\narr: 7 7 5 7 5 1 5 7 5 5 7 7 5 5 5 5\\ncnt: 1 2 1 2 1 0\\nHere 7 is our majority element for now, it exhausted all the minority votes which is votes by people 5 and 1. 7 will now say that in this prefix I won with a difference of 0 which is actually not winning.\\n7 7 5 7 5 1 5 7 5 5 7 7 5 5 5 5\\n1 2 1 2 1 0 1 0\\nHere again 5 is ME(as when count == 0, majority and minority exhausted so next new element is made as ME) exhausted by 7.\\n\\nAlso, realise that, does the above two prefix have any contribution to answer? No. That\\'s what I am trying to explain. To become President or Majority Element you basically need to win with a difference.\\n\\n7 7 5 7 5 1 5 7 5 5 7 7 5 5 5 5\\n1 2 1 2 1 0 1 0 1 2 1 0 1 2 3 4\\n\\nFianlly 5 is the ME. \\n\\nThis was a lot of analysis but believe me your mind will just pop open for any general N/k case after going through the full article.\\n\\n\\n**Case 2: Voting for President and Vice President = Freq(Majority Element) > Floor(N/3)**\\n\\nIf N = 15 => Freq(ME) > 15/3 = 5\\nIn this case realise that we can 3 cases.\\ni. 0 people winning: everyone gets unique votes or some gets 2 etc\\nii. 1 person winning: President who gets vote like 6 and rest all get less than 6.\\n    Example: 1 1 1 1 1 1 2 2 3 3 4 4 5 5 6\\n    President = 1 with 6 votes.\\niii. 2 people winning: President and Vice President both get equal to 6 or one of them gets more than 6.\\n    Example: 1 1 1 1 1 1 1 2 2 2 2 2 2 8 8\\n    President = 1 with 7 votes.\\n    Vice President = 2 with 6 votes.\\n    Rest = 2 votes.\\n    \\nI just want you to visualise Boyer Moore Voting algorithm with one statement.\\n    \\nWhat will President and Vice President say?\\nPresident will say that \\u201CI won with a difference of 5\\u201D.\\n    Vice President will say that \\u201CI won with a difference of 4\\u201D.\\n    \\nTill this point I want you to realise that Vote of Majority Element is only affected by Minority elements. By people who are not winning. \\n\\nHence in this case we have to maintain two independent counters keeping track of ME1 and ME2. \\nThe only thing to note here is that when you reach a Minority element, that minority element will affect both President and Vice President\\'s vote. \\nThat\\'s why when we hit a minority element we reduce count for both the Majority Elements as it is affecting winning difference of both the winning Candidates.\\n\\nNow we will go through one example and that must develop a good intuition.\\n\\nExample\\nindex:0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\\narr:  1 2 3 1 1 1 7 7 1 1 7 5 7 7 7\\ncnt1: 1  \\ncnt2:   1\\n\\nCount1 is for ME1 and Count2 is for ME2 both initialised by 0.\\nAt i = 0 We get first candidate.\\nAt i = 1 This is not equal to our first candidate so new counter initialised by 1.\\n\\nindex:0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\\narr:....1 2 3 1 1 1 7 7 1 1 7 5 7 7 7\\ncnt1:.1   0\\ncnt2:....1 0\\n\\nAt i = 2, Candidate 3 is neither ME1 nor ME2. This vote is a loss for both the candidates BUT not in the long run. That\\'s what we are trying to do. We want our counters to be greater than 1 for that candidate to win.\\n\\nindex:0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\\narr:....1 2 3 1 1 1 7 7 1 1 7 5 7 7 7\\ncnt1: 1....0 1 2 3........4 5....4\\ncnt2:....1.0..........1 2........3 2 3 4 5\\n\\nMake sure to update new ME1 and ME2 when counters == 0.\\nMake sure to check whether these really are Majority Elements because this algorithm will give you ME1 and ME2 in any case.\\n\\n**Case 3: Voting for President, Sr. Vice President and Vice President = Freq(Majority Element) > Floor(N/4)**\\n\\nIf N = 20 => Freq(ME) > 20/4 = 5\\nIn this case realise that we can have 4 cases. 0,1,2 or 3 positions. Must have realised it till now.\\n\\nAnd that is why we need to maintain 3 counters. We choose 3 candidates and for each one of them if a new vote is equal to any ME we increment counter and if a new vote is not equal to any ME, that particular vote is a loss for all the 3 winning candidates hence we decrement counters for all 3.\\n\\nTake an example with 20 elements and dry run it.\\n\\nMajor Takeaways\\n\\n1. Visualise from voting point of view and how a winning candidate actually wins becuase his/her votes difference from Minority Elements(not winning candidates) is greater than 1.\\n2. Till now you must have realised for a question where Freq(ME) > N/k we need k - 1 counters. OR For Example if Freq(ME) > N/4 we need 3 counters as there is battle for max 3 positions.\\n3. When you arrive at an element which neither matches any of the candidates i.e (Majority Elements) that particular element or vote is a equal loss to every winning candidate, hence all the counters must be decremented by 1. \\n\\nFINALLY!!! Time for some code.\\n\\n**Freq(ME) > N/3**\\n\\n```\\nvector<int> majorityElement(vector<int>& arr) {\\n   int n = arr.size();\\n\\n   int cnt1 = 0;\\n   int cnt2 = 0;\\n\\n   int me1 = -1;\\n   int me2 = -1;\\n\\n   //Find candidates\\n   for (auto element : arr) {\\n      if (element == me1)++cnt1;\\n      else if (element == me2)++cnt2;\\n      else if (cnt1 == 0) {\\n         me1 = element;\\n         ++cnt1;\\n      }\\n      else if (cnt2 == 0) {\\n         me2 = element;\\n         ++cnt2;\\n      }\\n      else {\\n         --cnt1;\\n         --cnt2;\\n      }\\n   }\\n\\n   int validFreq = floor(n / 3);\\n\\n   vector<int> result = {};\\n   int vc1 = 0, vc2 = 0;\\n   for (int i = 0; i < n; i++)\\n      if (arr[i] == me1)\\n         ++vc1;\\n      else if (arr[i] == me2)\\n         ++vc2;\\n\\n   if (vc1 > validFreq)\\n      result.push_back(me1);\\n\\n   if (vc2 > validFreq)\\n      result.push_back(me2);\\n\\n   return result;\\n}\\n```\\n\\n**Generalised Freq(ME) > N/k**\\n**Please relate the below Generalised code with above code for k = 3**\\n\\nAfter visualising the below code with N = 3, you can easily visualise it for any value of k.\\nYou can also try running the below code for k = 3 in this LeetCode question https://leetcode.com/problems/majority-element-ii/\\n\\nI referred https://coldfunction.com/mgen/p/3n but using just 1 map instead of two.\\n\\n```\\n// // Freq(ME) > floor(n/k)\\nvector<int> majorityElementGeneralised(vector<int> arr, int k) {\\n   int n = arr.size();\\n\\n   // Map of Majority Element(ME), Count\\n   // Count is not Frequency in array.\\n   // For checking Freq(ME) > floor(n/k) we run another loop\\n   // on counters.first element or on ME\\'s\\n   map<int, int> counters;\\n\\n   for (auto element : arr) {\\n      // If element present in map counters,\\n      // Increment that counter value\\n      if (counters.count(element))\\n         ++counters[element];\\n\\n      // If element NOT present in map counters\\n      // Add it in counters\\n      // Which means that we created a new counter for that candidate\\n      // ONLY if counters.size() < k - 1.\\n      // Which means that if N = 4 we can only have 3 counters. Explained above in detail.\\n      else if (counters.size() < k - 1)\\n         ++counters[element];\\n\\n      // This means that we have max number of candidates\\n      // OR\\n      // Max number of counters and we have a new element\\n      // Simply decrement all counters by 1 (Explained above)\\n      // BUT\\n      // If a counter == 0. Not required cause if later that element becomes Majority we can always initialise it by 1.\\n      // So remove from map counters.\\n      else {\\n         //Iterate over all counters and decrement by 1\\n         //If counter is 0 for an element in Map Counter\\n         //It is not required as instead of that element,\\n         //we will add a new element\\n         auto it = counters.begin();\\n         while (it != counters.end()) {\\n            int key = it->first;\\n            if (it->second == 1) {\\n               it = counters.erase(it);\\n            }\\n            else {\\n               --counters[key];\\n               ++it;\\n            }\\n         }\\n      }\\n   }\\n\\n   int validFreq = floor(n / k);\\n\\n   vector<int> result = {};\\n\\n   // Use map counters as a frequency map by initialising counter.first or Majority element frequency to 0.\\n   for (auto element : arr) {\\n      if (counters.count(element))\\n         counters[element] = 0;\\n   }\\n\\n   // If found in array update frequency\\n   for (auto element : arr) {\\n      if (counters.count(element))\\n         ++counters[element];\\n   }\\n\\n   // Check is valid Majority Element\\n   for (auto me : counters)\\n      if (me.second > validFreq)\\n         result.push_back(me.first);\\n\\n   return result;\\n}\\n\\nvector<int> majorityElement(vector<int>& nums) {\\n   return majorityElementGeneralised(nums, 3);\\n}\\n```\\n\\n\\nThank you. Hope it helps. Comments appreciated.\\n\\nMy references\\n1. https://leetcode.com/problems/majority-element-ii/discuss/63520/Boyer-Moore-Majority-Vote-algorithm-and-my-elaboration\\n2. Generalize the Boyer\\u2013Moore majority vote algorithm: https://coldfunction.com/mgen/p/3n\\n3. https://leetcode.com/problems/majority-element-ii/discuss/63537/my-understanding-of-boyer-moore-majority-vote\\n4. Majority Voting Algorithm - Blog of Greg Grothaus: https://gregable.com/2013/10/majority-vote-algorithm-find-majority.html\\n5. (take U forward, Majority Element II | GOOGLE Interview Question | Brute-Better-Optimal\\n) https://www.youtube.com/watch?v=yDbkQd9t2ig&t=340s&ab_channel=takeUforward",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nvector<int> majorityElement(vector<int>& arr) {\\n   int n = arr.size();\\n\\n   int cnt1 = 0;\\n   int cnt2 = 0;\\n\\n   int me1 = -1;\\n   int me2 = -1;\\n\\n   //Find candidates\\n   for (auto element : arr) {\\n      if (element == me1)++cnt1;\\n      else if (element == me2)++cnt2;\\n      else if (cnt1 == 0) {\\n         me1 = element;\\n         ++cnt1;\\n      }\\n      else if (cnt2 == 0) {\\n         me2 = element;\\n         ++cnt2;\\n      }\\n      else {\\n         --cnt1;\\n         --cnt2;\\n      }\\n   }\\n\\n   int validFreq = floor(n / 3);\\n\\n   vector<int> result = {};\\n   int vc1 = 0, vc2 = 0;\\n   for (int i = 0; i < n; i++)\\n      if (arr[i] == me1)\\n         ++vc1;\\n      else if (arr[i] == me2)\\n         ++vc2;\\n\\n   if (vc1 > validFreq)\\n      result.push_back(me1);\\n\\n   if (vc2 > validFreq)\\n      result.push_back(me2);\\n\\n   return result;\\n}\\n```\n```\\n// // Freq(ME) > floor(n/k)\\nvector<int> majorityElementGeneralised(vector<int> arr, int k) {\\n   int n = arr.size();\\n\\n   // Map of Majority Element(ME), Count\\n   // Count is not Frequency in array.\\n   // For checking Freq(ME) > floor(n/k) we run another loop\\n   // on counters.first element or on ME\\'s\\n   map<int, int> counters;\\n\\n   for (auto element : arr) {\\n      // If element present in map counters,\\n      // Increment that counter value\\n      if (counters.count(element))\\n         ++counters[element];\\n\\n      // If element NOT present in map counters\\n      // Add it in counters\\n      // Which means that we created a new counter for that candidate\\n      // ONLY if counters.size() < k - 1.\\n      // Which means that if N = 4 we can only have 3 counters. Explained above in detail.\\n      else if (counters.size() < k - 1)\\n         ++counters[element];\\n\\n      // This means that we have max number of candidates\\n      // OR\\n      // Max number of counters and we have a new element\\n      // Simply decrement all counters by 1 (Explained above)\\n      // BUT\\n      // If a counter == 0. Not required cause if later that element becomes Majority we can always initialise it by 1.\\n      // So remove from map counters.\\n      else {\\n         //Iterate over all counters and decrement by 1\\n         //If counter is 0 for an element in Map Counter\\n         //It is not required as instead of that element,\\n         //we will add a new element\\n         auto it = counters.begin();\\n         while (it != counters.end()) {\\n            int key = it->first;\\n            if (it->second == 1) {\\n               it = counters.erase(it);\\n            }\\n            else {\\n               --counters[key];\\n               ++it;\\n            }\\n         }\\n      }\\n   }\\n\\n   int validFreq = floor(n / k);\\n\\n   vector<int> result = {};\\n\\n   // Use map counters as a frequency map by initialising counter.first or Majority element frequency to 0.\\n   for (auto element : arr) {\\n      if (counters.count(element))\\n         counters[element] = 0;\\n   }\\n\\n   // If found in array update frequency\\n   for (auto element : arr) {\\n      if (counters.count(element))\\n         ++counters[element];\\n   }\\n\\n   // Check is valid Majority Element\\n   for (auto me : counters)\\n      if (me.second > validFreq)\\n         result.push_back(me.first);\\n\\n   return result;\\n}\\n\\nvector<int> majorityElement(vector<int>& nums) {\\n   return majorityElementGeneralised(nums, 3);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 466876,
                "title": "python-o-n-time-o-1-space-explanation-in-comments",
                "content": "```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        # there can be at most two majority elements\\n        # think of 3 segments: m, n, l\\n        # m & n is some candidate number\\n        # l is anything else\\n        # if l is longer than m, m stops being majority (majority becomes n and l)\\n        # elif l is longer than n, n stops being majority (majority becomes m and l)\\n        # elif l is same length as m & n, there\\'s no majority\\n        \\n        # a number isn\\'t necessarily a majority just because it survives the pair off \\n        # but if a number doesn\\'t survive pair off, it definitely can\\'t be a majority\\n\\t\\t\\n\\t\\t# if a number is a majority, it will always survive the pair off or come back later\\n        \\n        # key idea is that if a number is over n/3, the ratio of it versus the rest is at least 1:2 and it always comes back as a candidate\\n        \\n        m, m_count, n, n_count = 0, 0, 1, 0\\n        for num in nums: \\n            # adds to lead of m\\n            if num == m:\\n                m_count += 1\\n            # adds to lead of n\\n            elif num == n:\\n                n_count += 1\\n            \\n            # l is the same length as m\\n            elif m_count == 0:\\n                # set a new candidate (previous candidate can always come back)\\n                m = num\\n                m_count = 1\\n                \\n            # l is the same length as n\\n            elif n_count == 0:\\n                # set a new candidate\\n                n = num\\n                n_count = 1\\n                \\n            # close the gap between l and m/n\\n            else:\\n                m_count -= 1\\n                n_count -= 1\\n        third = len(nums)/3\\n        res = []\\n        \\n        if m_count > 0:\\n            if nums.count(m) > third:\\n                res.append(m)\\n        if n_count > 0:\\n            if nums.count(n) > third:\\n                res.append(n)\\n        return res\\n            \\n                \\n                \\n        \\n        \\n        \\n        \\n                \\n        \\n        \\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        # there can be at most two majority elements\\n        # think of 3 segments: m, n, l\\n        # m & n is some candidate number\\n        # l is anything else\\n        # if l is longer than m, m stops being majority (majority becomes n and l)\\n        # elif l is longer than n, n stops being majority (majority becomes m and l)\\n        # elif l is same length as m & n, there\\'s no majority\\n        \\n        # a number isn\\'t necessarily a majority just because it survives the pair off \\n        # but if a number doesn\\'t survive pair off, it definitely can\\'t be a majority\\n\\t\\t\\n\\t\\t# if a number is a majority, it will always survive the pair off or come back later\\n        \\n        # key idea is that if a number is over n/3, the ratio of it versus the rest is at least 1:2 and it always comes back as a candidate\\n        \\n        m, m_count, n, n_count = 0, 0, 1, 0\\n        for num in nums: \\n            # adds to lead of m\\n            if num == m:\\n                m_count += 1\\n            # adds to lead of n\\n            elif num == n:\\n                n_count += 1\\n            \\n            # l is the same length as m\\n            elif m_count == 0:\\n                # set a new candidate (previous candidate can always come back)\\n                m = num\\n                m_count = 1\\n                \\n            # l is the same length as n\\n            elif n_count == 0:\\n                # set a new candidate\\n                n = num\\n                n_count = 1\\n                \\n            # close the gap between l and m/n\\n            else:\\n                m_count -= 1\\n                n_count -= 1\\n        third = len(nums)/3\\n        res = []\\n        \\n        if m_count > 0:\\n            if nums.count(m) > third:\\n                res.append(m)\\n        if n_count > 0:\\n            if nums.count(n) > third:\\n                res.append(n)\\n        return res\\n            \\n                \\n                \\n        \\n        \\n        \\n        \\n                \\n        \\n        \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 320238,
                "title": "very-easy-to-understand-based-on-count-min-sketch-o-n-time-o-1-space",
                "content": "This is just an illustration of how count-min-sketch works. Check https://www.youtube.com/watch?v=ibxXO-b14j4 for count-min-sketch explanation.\\n\\nThis passed all the test cases as of 06/25/19. If more test cases are added and if it fails for other test cases add more maps and hashes.\\n\\nThis is definitely O(1) space because we have defined the hash functions. In this case, n%10 can take 10 values, n%19 can take 19 values. So the total number of entries in the maps put together will only be a maximum of 29.\\n\\n```\\nclass Solution {\\n    Map<Integer, Integer> map1 = new HashMap<Integer, Integer>();\\n    Map<Integer, Integer> map2 = new HashMap<Integer, Integer>();\\n    \\n    int val1 = 10;\\n    int val2 = 19;\\n    \\n    public List<Integer> majorityElement(int[] nums) {\\n        Set<Integer> res = new HashSet<Integer>();\\n        for(int i=0; i<nums.length; i++) {\\n            put(nums[i]);\\n        }\\n        \\n        for(int i=0; i<nums.length; i++) {\\n            if(get(nums[i]) > nums.length/3) {\\n                res.add(nums[i]);\\n            }\\n        }\\n        \\n        return new ArrayList<Integer>(res);\\n    }\\n    \\n    private void put(int num) {\\n        map1.put(num%val1, map1.getOrDefault(num%val1, 0)+1);\\n        map2.put(num%val2, map2.getOrDefault(num%val2, 0)+1);\\n    }\\n    \\n    private int get(int num) {\\n        return Math.min(map1.get(num%val1), map2.get(num%val2));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer, Integer> map1 = new HashMap<Integer, Integer>();\\n    Map<Integer, Integer> map2 = new HashMap<Integer, Integer>();\\n    \\n    int val1 = 10;\\n    int val2 = 19;\\n    \\n    public List<Integer> majorityElement(int[] nums) {\\n        Set<Integer> res = new HashSet<Integer>();\\n        for(int i=0; i<nums.length; i++) {\\n            put(nums[i]);\\n        }\\n        \\n        for(int i=0; i<nums.length; i++) {\\n            if(get(nums[i]) > nums.length/3) {\\n                res.add(nums[i]);\\n            }\\n        }\\n        \\n        return new ArrayList<Integer>(res);\\n    }\\n    \\n    private void put(int num) {\\n        map1.put(num%val1, map1.getOrDefault(num%val1, 0)+1);\\n        map2.put(num%val2, map2.getOrDefault(num%val2, 0)+1);\\n    }\\n    \\n    private int get(int num) {\\n        return Math.min(map1.get(num%val1), map2.get(num%val2));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 63614,
                "title": "c-solution-for-elements-appear-more-than-floor-n-k-times",
                "content": "      vector<int> majorityElement(vector<int>& nums) {\\n       return majorityElement(nums, 3);\\n    }\\n    vector<int> majorityElement(vector<int>& nums, const int k) {\\n        const int size_n = nums.size();\\n        vector<int> result;\\n        unordered_map<int, int> cand;\\n        for (int i = 0; i < size_n; i++) {\\n            cand[nums[i]]++;\\n            if (cand.size() == k) {\\n                for (auto it = cand.begin(); it != cand.end(); ) {\\n                    if (--(it->second) == 0) it = cand.erase(it);\\n                    else it++;\\n                }\\n            }\\n        }\\n        for (auto& item : cand) item.second = 0;\\n        for (auto& item : nums) {\\n            if (cand.count(item) > 0) cand[item]++;\\n        }\\n        for (auto& item : cand) {\\n            if (item.second > size_n / k) result.emplace_back(item.first);\\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "      vector<int> majorityElement(vector<int>& nums) {\\n       return majorityElement(nums, 3);\\n    }\\n    vector<int> majorityElement(vector<int>& nums, const int k) {\\n        const int size_n = nums.size();\\n        vector<int> result;\\n        unordered_map<int, int> cand;\\n        for (int i = 0; i < size_n; i++) {\\n            cand[nums[i]]++;\\n            if (cand.size() == k) {\\n                for (auto it = cand.begin(); it != cand.end(); ) {\\n                    if (--(it->second) == 0) it = cand.erase(it);\\n                    else it++;\\n                }\\n            }\\n        }\\n        for (auto& item : cand) item.second = 0;\\n        for (auto& item : nums) {\\n            if (cand.count(item) > 0) cand[item]++;\\n        }\\n        for (auto& item : cand) {\\n            if (item.second > size_n / k) result.emplace_back(item.first);\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3166489,
                "title": "using-hashmap-hashset-arraylist-in-java",
                "content": "\\n\\n# Approach\\nThe approach used is to keep track of the count of each element in the array using a HashMap, then check which elements have a count greater than n/3, where n is the length of the array. The elements that have a count greater than n/3 are added to a HashSet to eliminate duplicates. Finally, the elements in the HashSet are added to a result ArrayList.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is **O(n)**, where n is the length of the array. This is because in the worst case, each element in the array will be processed once in both the first loop and the second loop.\\n\\n\\n- Space complexity:\\nThe space complexity of this solution is **O(n)**, where n is the length of the array. This is because the space used by the HashMap and HashSet will be proportional to the number of unique elements in the array. In the worst case, each element in the array is unique, so the space used will be O(n).\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        HashSet<Integer> set = new HashSet<>();\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(map.get(nums[i])>nums.length/3){\\n                set.add(nums[i]);\\n            }\\n        }\\n        for(Integer val : set){\\n            list.add(val);\\n        }\\n        return list;\\n    }\\n}\\n```\\n![upvote.jpeg](https://assets.leetcode.com/users/images/85e0c26e-be34-4885-897f-67d974994cad_1676002974.3226.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        HashSet<Integer> set = new HashSet<>();\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(map.get(nums[i])>nums.length/3){\\n                set.add(nums[i]);\\n            }\\n        }\\n        for(Integer val : set){\\n            list.add(val);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 859530,
                "title": "intuition-for-2-counters-in-boyer-moore-majority-vote-algorithm",
                "content": "There are a lot of excellent and well explained answers in the discussion forum. But none of them explains why 2 majority counters were taken for **Boyer-Moore Majority Vote algorithm**. All of them just assume it intuitively. As a newbie student of Discrete Mathematics, I decided to dig in. Here are my 2 cents:\\nLet\\'s say we have ```n``` objects and ```b``` placeholders. Considering even distribution, all ```b``` placeholders will have atleast ```floor(n/b)``` objects. This leaves us with ```n%b``` objects remaining. Representing this mathematically:\\n**```n = b*floor(n/b) + (n%b)```**\\nConsider it Analogous to:\\n**```dividend = divisor*quotient + remainder```**\\nBasic knowledge of mathematics tells us that ```n%b``` can take values in the interval ```[0, b-1]```. Thus the maximum value possible will be ```b-1```. \\nApplying this to the mathematical equation above, we can say that **at most** ```b-1```  placeholders can have have a value ```> floor(n/b)```.\\nFor the sake of this problem, ```b=3```, thus we can have **at most** ```2``` required elements. \\n\\nAfter this simple  **Boyer-Moore Majority Vote algorithm** can be followed with 2 majority counters:\\n```class Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        vector<int> res;\\n        if(nums.size() == 0)\\n            return res;\\n            \\n        int num1 = nums[0]; int num2 = nums[0]; int count1 = 1; int count2 = 0 ;\\n        \\n        for (int val : nums) {\\n            if(val == num1)\\n                count1++;\\n            else if (val == num2)\\n                count2++;\\n            else if (count1 == 0) {\\n                num1 = val;\\n                count1++;\\n                }\\n            else if (count2 == 0) {\\n                num2 = val;\\n                count2++;\\n            }\\n            else {\\n                count1--;\\n                count2--;\\n            }\\n        }\\n        count1 = 0;\\n        count2 = 0;\\n        for(int val : nums) {\\n            if(val == num1)\\n                count1++;\\n            else if(val == num2)\\n                count2++;\\n        }\\n        if(count1 > nums.size()/3)\\n            res.push_back(num1);\\n        if(count2 > nums.size()/3)\\n            res.push_back(num2);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```n```\n```b```\n```b```\n```floor(n/b)```\n```n%b```\n```n = b*floor(n/b) + (n%b)```\n```dividend = divisor*quotient + remainder```\n```n%b```\n```[0, b-1]```\n```b-1```\n```b-1```\n```> floor(n/b)```\n```b=3```\n```2```\n```class Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        vector<int> res;\\n        if(nums.size() == 0)\\n            return res;\\n            \\n        int num1 = nums[0]; int num2 = nums[0]; int count1 = 1; int count2 = 0 ;\\n        \\n        for (int val : nums) {\\n            if(val == num1)\\n                count1++;\\n            else if (val == num2)\\n                count2++;\\n            else if (count1 == 0) {\\n                num1 = val;\\n                count1++;\\n                }\\n            else if (count2 == 0) {\\n                num2 = val;\\n                count2++;\\n            }\\n            else {\\n                count1--;\\n                count2--;\\n            }\\n        }\\n        count1 = 0;\\n        count2 = 0;\\n        for(int val : nums) {\\n            if(val == num1)\\n                count1++;\\n            else if(val == num2)\\n                count2++;\\n        }\\n        if(count1 > nums.size()/3)\\n            res.push_back(num1);\\n        if(count2 > nums.size()/3)\\n            res.push_back(num2);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 403029,
                "title": "easy-boyer-moore-voting-algorithm-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        if(nums.size()==0) return {};\\n        \\n        int count1=0, count2=0, candidate1= -1, candidate2= -1;\\n        vector<int> result;\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            if(candidate1==nums[i])\\n                count1++;\\n                \\n            else if(candidate2==nums[i])\\n                count2++;\\n            \\n            else if(count1==0){\\n                candidate1=nums[i];\\n                count1++;\\n            }\\n                \\n            else if(count2==0){\\n                candidate2=nums[i];\\n                count2++;\\n                }\\n           \\n            else{\\n                count1--;\\n                count2--;\\n            }\\n        }\\n        \\n        count1=0;\\n        count2=0;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==candidate1) count1++;\\n            if(nums[i]==candidate2) count2++;\\n        }\\n        \\n        if(count1>(nums.size()/3))\\n            result.push_back(candidate1);\\n        \\n        if(count2>(nums.size()/3))\\n            result.push_back(candidate2);\\n        \\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        if(nums.size()==0) return {}",
                "codeTag": "Java"
            },
            {
                "id": 389030,
                "title": "javascript-boyer-moore-solution",
                "content": "```\\nvar majorityElement = function(nums) {\\n    const n = nums.length\\n    if (n < 1) return []\\n    if (n < 2) return nums\\n    \\n    let count1 = 0, count2 = 0, candidate1 = 0, candidate2 = 1\\n    \\n    for (let i = 0; i < n; i++) {\\n        if (nums[i] == candidate1) count1++\\n        else if (nums[i] == candidate2) count2++\\n        else if (count1 == 0) {\\n            candidate1 = nums[i]\\n            count1 = 1\\n        } \\n        else if (count2 == 0) {\\n            candidate2 = nums[i]\\n            count2 = 1\\n        } else {\\n            count1--\\n            count2--\\n        }\\n    }\\n    \\n    let x = []\\n    if (nums.count(candidate1) > n / 3) x.push(candidate1)\\n    if (nums.count(candidate2) > n / 3) x.push(candidate2)\\n        \\n    return x\\n};\\nArray.prototype.count = function(num) {\\n    let count = 0\\n    for (let i = 0; i < this.length; i++)\\n        if (this[i] == num) count++\\n    \\n    return count\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar majorityElement = function(nums) {\\n    const n = nums.length\\n    if (n < 1) return []\\n    if (n < 2) return nums\\n    \\n    let count1 = 0, count2 = 0, candidate1 = 0, candidate2 = 1\\n    \\n    for (let i = 0; i < n; i++) {\\n        if (nums[i] == candidate1) count1++\\n        else if (nums[i] == candidate2) count2++\\n        else if (count1 == 0) {\\n            candidate1 = nums[i]\\n            count1 = 1\\n        } \\n        else if (count2 == 0) {\\n            candidate2 = nums[i]\\n            count2 = 1\\n        } else {\\n            count1--\\n            count2--\\n        }\\n    }\\n    \\n    let x = []\\n    if (nums.count(candidate1) > n / 3) x.push(candidate1)\\n    if (nums.count(candidate2) > n / 3) x.push(candidate2)\\n        \\n    return x\\n};\\nArray.prototype.count = function(num) {\\n    let count = 0\\n    for (let i = 0; i < this.length; i++)\\n        if (this[i] == num) count++\\n    \\n    return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 63518,
                "title": "can-anybody-tell-me-if-this-c-solution-is-o-1-space-complexity",
                "content": "The idea here is to select n/3-th element and 2n/3-th element as candidates. And then check if they appear more than n/3 times;\\nThis solution does work, but the problem is I am not sure if it meets the O(1) space requirement.\\n```\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int s=nums.size();\\n        if(!s)\\n            return {};\\n        vector<int> res;\\n        int count=0, candidate1=0, candidate2=0;\\n        \\n        // reference here http://www.cplusplus.com/reference/algorithm/nth_element/\\n        nth_element(nums.begin(), nums.begin() + s / 3, nums.end());  \\n        \\n        candidate1=nums[s/3]\\n        for(auto num:nums)\\n            num==candidate1 ? count++ : count;\\n        if(count>s/3)\\n            res.push_back(candidate1);\\n        \\n        nth_element(nums.begin(), nums.begin() + 2 * s / 3, nums.end());   \\n        \\n        count=0, candidate2=nums[2*s/3];\\n        for(auto num:nums)\\n            num==candidate2 ? count++ : count;\\n        if(count>s/3 && candidate1 != candidate2)\\n            res.push_back(candidate2);    \\n        \\n        return res;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "The idea here is to select n/3-th element and 2n/3-th element as candidates. And then check if they appear more than n/3 times;\\nThis solution does work, but the problem is I am not sure if it meets the O(1) space requirement.\\n```\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int s=nums.size();\\n        if(!s)\\n            return {};\\n        vector<int> res;\\n        int count=0, candidate1=0, candidate2=0;\\n        \\n        // reference here http://www.cplusplus.com/reference/algorithm/nth_element/\\n        nth_element(nums.begin(), nums.begin() + s / 3, nums.end());  \\n        \\n        candidate1=nums[s/3]\\n        for(auto num:nums)\\n            num==candidate1 ? count++ : count;\\n        if(count>s/3)\\n            res.push_back(candidate1);\\n        \\n        nth_element(nums.begin(), nums.begin() + 2 * s / 3, nums.end());   \\n        \\n        count=0, candidate2=nums[2*s/3];\\n        for(auto num:nums)\\n            num==candidate2 ? count++ : count;\\n        if(count>s/3 && candidate1 != candidate2)\\n            res.push_back(candidate2);    \\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 63524,
                "title": "java-solution-for-generalized-n-k-case",
                "content": "    public class Solution {\\n        public List<Integer> majorityElement(int[] nums) {\\n            return helper(nums, 3);\\n        }\\n        \\n        public List<Integer> helper(int[] nums, int k) {\\n            List<Integer> ret = new ArrayList<>();\\n            Map<Integer, Integer> map = new HashMap<>();\\n            if (nums.length == 0) return ret;\\n            for (int n : nums) {\\n                if (map.containsKey(n)) map.put(n, map.get(n) + 1);\\n                else if (map.keySet().size() < k - 1) map.put(n, 1);\\n                else {\\n                        boolean flag = false;\\n                        for (Integer i : map.keySet()) {\\n                            if (map.get(i) == 0) {\\n                                map.remove(i);\\n                                map.put(n, 1);\\n                                flag = true;\\n                                break;\\n                            }\\n                        }\\n                        if (flag == false) {\\n                            for (Integer i : map.keySet()) {\\n                                map.put(i, map.get(i) - 1);\\n                            }\\n                        }\\n                     }\\n            }\\n            for (Integer i : map.keySet()) {\\n            \\tmap.put(i, 0);\\n            }\\n            for (int n : nums) {\\n               if (map.containsKey(n)) map.put(n, map.get(n) + 1); \\n            }\\n            for (Integer i : map.keySet()) {\\n                if (map.get(i) > nums.length / k) ret.add(i);\\n            }\\n            return ret;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> majorityElement(int[] nums) {\\n            return helper(nums, 3);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 63613,
                "title": "java-random-number-solution",
                "content": "1. Randomly pick a number between 0 and n-1, loop over the array to see if this number appears more than n / 3 times. - O (n)\\n2. repeat 1 for 100 times.\\n\\nTherefore the time complexity is O(100n), which is essentially still O(n).\\n\\nSuppose we have 2/3 chance to miss a desired number in one pick, the possibility of missing this number in 100 picks would be (2/3)^100, which is 10E-18. This possibility is so low, maybe even lower than the possibility of leetcode server crash in the next second.\\n\\nSo I guess this solution is sufficiently reliable. If not, we could repeat step 1 for 1000 times, to make sure finding out the two numbers.\\n\\nMoreover, this solution could be generated to solve questions like \"find all elements that appear more than n/m times.\"\\n \\n\\n       public class Solution {\\n            public List<Integer> majorityElement(int[] nums) {\\n                List<Integer> output = new ArrayList<>();\\n                for (int i = 0; i < 100; i += 1) {\\n                    int count = 0;\\n                    int index = (int)(nums.length * Math.random());\\n                    for (int j = 0; j < nums.length; j += 1)\\n                        if (nums[index] == nums[j])\\n                            count += 1;\\n                    if (count > nums.length / 3 && !output.contains(nums[index]))\\n                        output.add(nums[index]);\\n                }\\n                return output;\\n            }\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n            public List<Integer> majorityElement(int[] nums) {\\n                List<Integer> output = new ArrayList<>();\\n                for (int i = 0; i < 100; i += 1) {\\n                    int count = 0;\\n                    int index = (int)(nums.length * Math.random());\\n                    for (int j = 0; j < nums.length; j += 1)\\n                        if (nums[index] == nums[j])\\n                            count += 1;\\n                    if (count > nums.length / 3 && !output.contains(nums[index]))\\n                        output.add(nums[index]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3230065,
                "title": "229-time-96-40-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe first idea that comes to mind is to use a hash map to store the count of each number in the array. However, the problem constraints state that we need to solve the problem in O(1) space complexity.\\n\\nWe can use the Boyer-Moore Voting Algorithm to solve this problem in linear time and O(1) space complexity. The algorithm is as follows:\\n\\n1. Initialize two variables, num1 and num2, to None and two variables, count1 and count2, to 0.\\n2. Iterate through the array and perform the following steps for each element:\\na. If the element is equal to num1, increment count1 by 1.\\nb. Else if the element is equal to num2, increment count2 by 1.\\nc. Else if count1 is 0, set num1 to the element and count1 to 1.\\nd. Else if count2 is 0, set num2 to the element and count2 to 1.\\ne. Else decrement count1 and count2 by 1.\\n3. Reset count1 and count2 to 0 and iterate through the array again to count the occurrences of num1 and num2.\\n4. If the count of num1 is greater than n/3, add it to the result list.\\n5. If the count of num2 is greater than n/3 and num2 is not equal to num1, add it to the result list.\\n6. Return the result list.\\n\\nThe time complexity of this algorithm is O(n) and the space complexity is O(1).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        num1, num2 = None, None\\n        count1, count2 = 0, 0\\n\\n        # Step 2\\n        for num in nums:\\n            if num == num1:\\n                count1 += 1\\n            elif num == num2:\\n                count2 += 1\\n            elif count1 == 0:\\n                num1 = num\\n                count1 = 1\\n            elif count2 == 0:\\n                num2 = num\\n                count2 = 1\\n            else:\\n                count1 -= 1\\n                count2 -= 1\\n\\n        # Step 3\\n        count1, count2 = 0, 0\\n        for num in nums:\\n            if num == num1:\\n                count1 += 1\\n            elif num == num2:\\n                count2 += 1\\n\\n        # Step 4 and 5\\n        n = len(nums)\\n        res = []\\n        if count1 > n // 3:\\n            res.append(num1)\\n        if count2 > n // 3 and num2 != num1:\\n            res.append(num2)\\n\\n        # Step 6\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        num1, num2 = None, None\\n        count1, count2 = 0, 0\\n\\n        # Step 2\\n        for num in nums:\\n            if num == num1:\\n                count1 += 1\\n            elif num == num2:\\n                count2 += 1\\n            elif count1 == 0:\\n                num1 = num\\n                count1 = 1\\n            elif count2 == 0:\\n                num2 = num\\n                count2 = 1\\n            else:\\n                count1 -= 1\\n                count2 -= 1\\n\\n        # Step 3\\n        count1, count2 = 0, 0\\n        for num in nums:\\n            if num == num1:\\n                count1 += 1\\n            elif num == num2:\\n                count2 += 1\\n\\n        # Step 4 and 5\\n        n = len(nums)\\n        res = []\\n        if count1 > n // 3:\\n            res.append(num1)\\n        if count2 > n // 3 and num2 != num1:\\n            res.append(num2)\\n\\n        # Step 6\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 787595,
                "title": "voting-algorithm-with-explanation-and-intuition-for-k-3-and-generalization",
                "content": "For given problem we need to find elements which occur more than `\\u230A n/3 \\u230B` times.\\n\\nIf we form triplets of **distinct** elements from a given array, the majority element is guaranteed to be there in each triplet.\\n\\neg1: `[1,1,2,3,2,1,3]` where 1 is the answer:\\nDistinct triplets can be => `[1,2,3]`,`[2,1,3]`   & `[1]` (putting remaining elements in last set)\\n\\neg2: `[1,1,1,2,3,4,3,3]` where 1 and 3 is the answer\\nDistinct triplets can be => `[1,2,3]`,`[1,4,3]` & `[1,3]` (putting remaining elements in last set)\\n\\neg2: `[1,1,1,1,1,3]` where 1 is the answer\\nDistinct triplets can be => no distinct triplet can be formed so putting all in last set `[1,1,1,1,1,3]`\\n\\nSo the idea is, if we keep removing 3 distict elements, in the end we will be left with the possible answer array.\\n\\nNow let\\'s use Boyer-Moore Majority Vote also to remove 3 distinct elements:\\n\\n```\\n        int count1 = 0;\\n        int count2 = 0;\\n        int a = nums[0];\\n        int b = nums[0];\\n\\t\\t\\n\\t\\tfor (int i=0; i<size; i++)\\n        {\\n            if (a == nums[i])\\n            {\\n                count1++;\\n            }\\n            else if (b == nums[i])\\n            {\\n                count2++;\\n            }\\n            else if (count1 == 0)\\n            {\\n                a = nums[i];\\n                count1++;\\n            }\\n            else if (count2 == 0)\\n            {\\n                b = nums[i];\\n                count2++;\\n            }\\n            else\\n            {\\n                count1--;\\n                count2--;\\n            }\\n        }\\n```\\n\\nHere a and b are the two distinct elements. (we find a and b if corresponding count is 0)\\nand when we find 3rd element which is not equal to a or b (let\\'s say c) that means we found the distict triplet.\\n\\nAt that time we decrement count of a and b and don\\'t do anything with c.\\nMeaning we removed (a,b,c).\\n\\nAt the end we will be left with a and b which are possible answers and we calculate their actual count to check if they are indeed the answers.\\n\\n```\\n        vector<int> ans;\\n        count1 = 0;\\n        count2 = 0;\\n        \\n        for (int i=0; i<size; i++)\\n        {\\n            if (a == nums[i])\\n            {\\n                count1++;\\n            }\\n        }\\n        \\n        if (a != b)\\n        {\\n            for (int i=0; i<size; i++)\\n            {\\n                if (b == nums[i])\\n                {\\n                    count2++;\\n                }\\n            }\\n        }\\n        \\n        \\n        if (count1 > (size/3))\\n        {\\n            ans.push_back(a);\\n        }\\n        \\n        if (count2 > (size/3))\\n        {\\n            ans.push_back(b);\\n        }\\n```\\n\\nWe can extend this solution for any k.\\nThe idea is to keep removing k distict elements untill we are left with the answer.\\n\\n",
                "solutionTags": [],
                "code": "```\\n        int count1 = 0;\\n        int count2 = 0;\\n        int a = nums[0];\\n        int b = nums[0];\\n\\t\\t\\n\\t\\tfor (int i=0; i<size; i++)\\n        {\\n            if (a == nums[i])\\n            {\\n                count1++;\\n            }\\n            else if (b == nums[i])\\n            {\\n                count2++;\\n            }\\n            else if (count1 == 0)\\n            {\\n                a = nums[i];\\n                count1++;\\n            }\\n            else if (count2 == 0)\\n            {\\n                b = nums[i];\\n                count2++;\\n            }\\n            else\\n            {\\n                count1--;\\n                count2--;\\n            }\\n        }\\n```\n```\\n        vector<int> ans;\\n        count1 = 0;\\n        count2 = 0;\\n        \\n        for (int i=0; i<size; i++)\\n        {\\n            if (a == nums[i])\\n            {\\n                count1++;\\n            }\\n        }\\n        \\n        if (a != b)\\n        {\\n            for (int i=0; i<size; i++)\\n            {\\n                if (b == nums[i])\\n                {\\n                    count2++;\\n                }\\n            }\\n        }\\n        \\n        \\n        if (count1 > (size/3))\\n        {\\n            ans.push_back(a);\\n        }\\n        \\n        if (count2 > (size/3))\\n        {\\n            ans.push_back(b);\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 858861,
                "title": "majority-element-ii-java-o-n-solution-moore-voting-algorithm",
                "content": "```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        List<Integer> ans = new ArrayList<>();\\n        \\n        int me1 = 0, me2 = 0, c1 = 0, c2 = 0, ocreq = (nums.length/3);\\n        \\n        for(int num : nums){\\n            if(num == me1) c1++;\\n            else if(num == me2) c2++;\\n            else if(c1 == 0){\\n                me1 = num;\\n                c1 = 1;\\n            }else if(c2 == 0){\\n                me2 = num;\\n                c2 = 1;\\n            }else{\\n                c1--;\\n                c2--;\\n            }\\n        }\\n        \\n        c1=0;\\n        c2=0;\\n        \\n        for(int num: nums){\\n            if(num == me1) c1++;\\n            else if(num == me2) c2++;\\n        }\\n        \\n        if(c1 > ocreq) ans.add(me1);\\n        if(c2 > ocreq) ans.add(me2);\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        List<Integer> ans = new ArrayList<>();\\n        \\n        int me1 = 0, me2 = 0, c1 = 0, c2 = 0, ocreq = (nums.length/3);\\n        \\n        for(int num : nums){\\n            if(num == me1) c1++;\\n            else if(num == me2) c2++;\\n            else if(c1 == 0){\\n                me1 = num;\\n                c1 = 1;\\n            }else if(c2 == 0){\\n                me2 = num;\\n                c2 = 1;\\n            }else{\\n                c1--;\\n                c2--;\\n            }\\n        }\\n        \\n        c1=0;\\n        c2=0;\\n        \\n        for(int num: nums){\\n            if(num == me1) c1++;\\n            else if(num == me2) c2++;\\n        }\\n        \\n        if(c1 > ocreq) ans.add(me1);\\n        if(c2 > ocreq) ans.add(me2);\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 305059,
                "title": "c-boyer-moore-algorithm-with-explanataion",
                "content": "So, basically if we have to find the majority algorithm we can have at most 3 elements in the vector which have frequency equal to n / 3, so for elements having frequency more than n / 3 we\\'ll have two majority candidates.\\n\\nThe code is Moore\\'s voting algorithm with a little modification, we have checked for two candidates and we have taken the case when both candidates hold the same value (since when we don\\'t deal with this it fails a test case)\\n```\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        vector<int> res;\\n        int a,b;\\n        int ca = 0;\\n        int cb = 0;\\n         \\n        for (int i=0;i<nums.size();i++){\\n            if (nums[i] == a || ca == 0 && nums[i] != b){\\n                a = nums[i];\\n                ca += 1;\\n            }else if(nums[i] == b  || cb == 0){\\n                b = nums[i];\\n                cb += 1;\\n            }else{\\n                ca --;\\n                cb --;\\n            }\\n        }\\n         \\n        ca = 0;\\n        cb = 0;\\n        for (int i=0;i<nums.size();i++){\\n            if (nums[i] == a){ ++ca; }\\n            else if (nums[i] == b){ ++cb; }\\n        }\\n         \\n        if (ca > floor(nums.size()/3) ){ res.push_back(a);}\\n        if (cb > floor(nums.size()/3)){ res.push_back(b);}\\n         \\n        return res;\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "So, basically if we have to find the majority algorithm we can have at most 3 elements in the vector which have frequency equal to n / 3, so for elements having frequency more than n / 3 we\\'ll have two majority candidates.\\n\\nThe code is Moore\\'s voting algorithm with a little modification, we have checked for two candidates and we have taken the case when both candidates hold the same value (since when we don\\'t deal with this it fails a test case)\\n```\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        vector<int> res;\\n        int a,b;\\n        int ca = 0;\\n        int cb = 0;\\n         \\n        for (int i=0;i<nums.size();i++){\\n            if (nums[i] == a || ca == 0 && nums[i] != b){\\n                a = nums[i];\\n                ca += 1;\\n            }else if(nums[i] == b  || cb == 0){\\n                b = nums[i];\\n                cb += 1;\\n            }else{\\n                ca --;\\n                cb --;\\n            }\\n        }\\n         \\n        ca = 0;\\n        cb = 0;\\n        for (int i=0;i<nums.size();i++){\\n            if (nums[i] == a){ ++ca; }\\n            else if (nums[i] == b){ ++cb; }\\n        }\\n         \\n        if (ca > floor(nums.size()/3) ){ res.push_back(a);}\\n        if (cb > floor(nums.size()/3)){ res.push_back(b);}\\n         \\n        return res;\\n    }\\n};\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 251442,
                "title": "java-generalized-for-k",
                "content": "```\\n    public List<Integer> majorityElement(int[] nums) {\\n        int K = 3;\\n        Map<Integer, Integer> candidates = new HashMap<>();\\n        //get all candidates\\n        for(int a: nums){\\n            candidates.put(a, candidates.getOrDefault(a, 0) + 1);\\n            if(candidates.size() == K){\\n                Iterator<Map.Entry<Integer, Integer>> it = candidates.entrySet().iterator();\\n                while (it.hasNext()){\\n                      Map.Entry<Integer, Integer> item = it.next();\\n                      if(item.getValue() == 1) it.remove();\\n                      else item.setValue(item.getValue() - 1);\\n                }\\n            }\\n        }\\n        //check correctness of candidates\\n        List<Integer> ans = new ArrayList<>();\\n        Iterator<Map.Entry<Integer, Integer>> it = candidates.entrySet().iterator();\\n        while (it.hasNext()){\\n            int key = it.next().getKey();\\n            int count = 0;\\n            for(int a: nums){\\n                if(a == key) count++;\\n                if(count > nums.length/K){\\n                    ans.add(key);\\n                    break;\\n                }\\n            }                \\n        }        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<Integer> majorityElement(int[] nums) {\\n        int K = 3;\\n        Map<Integer, Integer> candidates = new HashMap<>();\\n        //get all candidates\\n        for(int a: nums){\\n            candidates.put(a, candidates.getOrDefault(a, 0) + 1);\\n            if(candidates.size() == K){\\n                Iterator<Map.Entry<Integer, Integer>> it = candidates.entrySet().iterator();\\n                while (it.hasNext()){\\n                      Map.Entry<Integer, Integer> item = it.next();\\n                      if(item.getValue() == 1) it.remove();\\n                      else item.setValue(item.getValue() - 1);\\n                }\\n            }\\n        }\\n        //check correctness of candidates\\n        List<Integer> ans = new ArrayList<>();\\n        Iterator<Map.Entry<Integer, Integer>> it = candidates.entrySet().iterator();\\n        while (it.hasNext()){\\n            int key = it.next().getKey();\\n            int count = 0;\\n            for(int a: nums){\\n                if(a == key) count++;\\n                if(count > nums.length/K){\\n                    ans.add(key);\\n                    break;\\n                }\\n            }                \\n        }        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 63575,
                "title": "share-my-c-solution-for-generalized-major-element-with-count-n-k",
                "content": "This problem can be generalized as find the majority element with appearance greater than n / k.\\nIt can be solved by just finding k - 1 candidates and update their count.\\nFollowing is the solution:\\n\\n----------\\n\\n    class Solution {\\n        public:\\n            vector<int> majorityElement(vector<int>& nums) {\\n                return majorKEle(nums, 3);\\n            }\\n        private:\\n            vector<int> majorKEle(vector<int>& nums, int k) {\\n                if (k < 2 || nums.empty()) {\\n                    return vector<int> ();\\n                }\\n                vector<int> candidate(k - 1, nums[0]);\\n                vector<int> count(k - 1, 0);\\n                count[0] = 1;\\n                for (auto i = 1; i < nums.size(); ++i) {\\n                    auto pos = std::find(candidate.begin(), candidate.end(), nums[i]);\\n                    if (pos != candidate.end()) {\\n                        count[pos - candidate.begin()] += 1;\\n                    } else {\\n                        bool replace_sign = false;\\n                        for (auto j = 0; j < count.size(); ++j) {\\n                            if (count[j] == 0) {\\n                                count[j] = 1;\\n                                replace_sign = true;\\n                                candidate[j] = nums[i];\\n                                break;\\n                            }\\n                        }\\n                        if (replace_sign == false) {\\n                            for (auto j = 0; j < count.size(); ++j) {\\n                                count[j] -= 1;\\n                            }\\n                        }\\n                    }\\n                }\\n                int require = nums.size() / k;\\n                vector<int> result;\\n                for (auto i = 0; i < count.size(); ++i) {\\n                    if (count[i] && std::count(nums.begin(), nums.end(), candidate[i]) > require) {\\n                        result.push_back(candidate[i]); \\n                    }\\n                }\\n                return result;\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            vector<int> majorityElement(vector<int>& nums) {\\n                return majorKEle(nums, 3);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 63609,
                "title": "clear-o-n-solution-in-python-no-data-structure-or-sort",
                "content": "class Solution:\\n        # @param {integer[]} nums\\n        # @return {integer[]}\\n        def majorityElement(self, nums):\\n            a, b, ca, cb = 0, 1, 0, 0\\n            for num in nums:\\n                if a == num:\\n                    ca += 1\\n                elif b == num:\\n                    cb += 1\\n                elif ca == 0:\\n                    a, ca = num, 1\\n                elif cb == 0:\\n                    b, cb = num, 1\\n                else:\\n                    ca -= 1\\n                    cb -= 1\\n            ca = len([0 for num in nums if num == a])\\n            cb = len([0 for num in nums if num == b])\\n            res = []\\n            if ca > len(nums) / 3:\\n                res.append(a)\\n            if cb > len(nums) / 3:\\n                res.append(b)\\n            return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 3086115,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int n1=-1, n2=-1, c1=0, c2=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(n1==nums[i])\\n                c1++;\\n            else if(n2==nums[i])\\n                c2++;\\n            else if(c1==0)\\n            {\\n                c1++;\\n                n1=nums[i];\\n            }\\n            else if(c2==0)\\n            {\\n                c2++;\\n                n2=nums[i];\\n            }\\n            else {\\n                c1--;\\n                c2--;\\n            }\\n        }\\n        int a=0, b=0;\\n        for(int i:nums)\\n        {\\n            if(i==n1)\\n            a++;\\n            if(i==n2)\\n                b++;\\n        }\\n        vector<int> v;\\n        if(a>nums.size()/3)\\n            v.push_back(n1);\\n        if(b>nums.size()/3 && n1!=n2)\\n            v.push_back(n2);\\n        return v;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int n1=-1, n2=-1, c1=0, c2=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(n1==nums[i])\\n                c1++;\\n            else if(n2==nums[i])\\n                c2++;\\n            else if(c1==0)\\n            {\\n                c1++;\\n                n1=nums[i];\\n            }\\n            else if(c2==0)\\n            {\\n                c2++;\\n                n2=nums[i];\\n            }\\n            else {\\n                c1--;\\n                c2--;\\n            }\\n        }\\n        int a=0, b=0;\\n        for(int i:nums)\\n        {\\n            if(i==n1)\\n            a++;\\n            if(i==n2)\\n                b++;\\n        }\\n        vector<int> v;\\n        if(a>nums.size()/3)\\n            v.push_back(n1);\\n        if(b>nums.size()/3 && n1!=n2)\\n            v.push_back(n2);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1708941,
                "title": "using-boyer-moore-voting-algo-o-n-time-o-1-space-with-comments-c",
                "content": "Implementation\\n\\n**Using Boyer-Moore Voting Algorithm\\nIn this que max 2 cadidate can be a majority element\\nTime Complexity = O(N),\\nSpace Complexity = O(1)**\\n```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        // putting INT_MIN, to handle the base case, i.e = [0,0,0] and [-1,-1,-1]\\n        int cadidate1 = INT_MIN, cadidate2 = INT_MIN, count1 = 0, count2 = 0;\\n        \\n        for(auto a : nums){\\n            if(cadidate1 == a){    // if candidate1 is already present, then just increase its frequency\\n                count1++;\\n            }\\n            else if(cadidate2 == a){    // if candidate2 is already present, then just increase its frequency\\n                count2++;\\n            }\\n            else if(count1 == 0){    // if the count1 is 0, then put the first candidate, and increase count1 by 1\\n                cadidate1 = a;\\n                count1 = 1;\\n            }\\n            else if(count2 == 0){   // if the count2 is 0, then put the second candidate, and increase count2 by 1\\n                cadidate2 = a;\\n                count2 = 1;\\n            }\\n            else{   // if new candidate is coming, then decrease both already existing cadidate frequency by 1\\n                count1--;\\n                count2--;\\n            }\\n        }\\n        \\n        // once we get the cadidate\\'s for two majority element we will again count the total occurence of both cadidate\\'s into an array\\n        count1 = 0, count2 = 0;\\n        for(auto a : nums){\\n            if(a == cadidate1) count1++;\\n            if(a == cadidate2) count2++;\\n        }\\n        \\n        // any count is more than n/3, then we will add that candidate into res\\n        vector<int> res;\\n        if(count1 > nums.size()/3) res.push_back(cadidate1);\\n        if(count2 > nums.size()/3) res.push_back(cadidate2);\\n        \\n        return res;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        // putting INT_MIN, to handle the base case, i.e = [0,0,0] and [-1,-1,-1]\\n        int cadidate1 = INT_MIN, cadidate2 = INT_MIN, count1 = 0, count2 = 0;\\n        \\n        for(auto a : nums){\\n            if(cadidate1 == a){    // if candidate1 is already present, then just increase its frequency\\n                count1++;\\n            }\\n            else if(cadidate2 == a){    // if candidate2 is already present, then just increase its frequency\\n                count2++;\\n            }\\n            else if(count1 == 0){    // if the count1 is 0, then put the first candidate, and increase count1 by 1\\n                cadidate1 = a;\\n                count1 = 1;\\n            }\\n            else if(count2 == 0){   // if the count2 is 0, then put the second candidate, and increase count2 by 1\\n                cadidate2 = a;\\n                count2 = 1;\\n            }\\n            else{   // if new candidate is coming, then decrease both already existing cadidate frequency by 1\\n                count1--;\\n                count2--;\\n            }\\n        }\\n        \\n        // once we get the cadidate\\'s for two majority element we will again count the total occurence of both cadidate\\'s into an array\\n        count1 = 0, count2 = 0;\\n        for(auto a : nums){\\n            if(a == cadidate1) count1++;\\n            if(a == cadidate2) count2++;\\n        }\\n        \\n        // any count is more than n/3, then we will add that candidate into res\\n        vector<int> res;\\n        if(count1 > nums.size()/3) res.push_back(cadidate1);\\n        if(count2 > nums.size()/3) res.push_back(cadidate2);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819626,
                "title": "python-easy-simple-solution-time-o-n-spaceo-1",
                "content": "```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        element1, element2, cnt1, cnt2 = 0, 0, 0, 0\\n        for e in nums:\\n            if element1 == e:\\n                cnt1 += 1\\n            elif element2 == e:\\n                cnt2 += 1\\n            elif cnt1 == 0:\\n                element1, cnt1 = e, 1\\n            elif cnt2 == 0:\\n                element2, cnt2 = e, 1\\n            else:\\n                cnt1 -= 1\\n                cnt2 -= 1\\n\\n        cnt1 = cnt2 = 0\\n        for e in nums:\\n            if element1 == e:\\n                cnt1 += 1\\n            elif element2 == e:\\n                cnt2 += 1\\n\\n        ans = []\\n        if cnt1 > len(nums) // 3:\\n            ans += [element1]\\n        if cnt2 > len(nums) // 3:\\n            ans += [element2]\\n\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        element1, element2, cnt1, cnt2 = 0, 0, 0, 0\\n        for e in nums:\\n            if element1 == e:\\n                cnt1 += 1\\n            elif element2 == e:\\n                cnt2 += 1\\n            elif cnt1 == 0:\\n                element1, cnt1 = e, 1\\n            elif cnt2 == 0:\\n                element2, cnt2 = e, 1\\n            else:\\n                cnt1 -= 1\\n                cnt2 -= 1\\n\\n        cnt1 = cnt2 = 0\\n        for e in nums:\\n            if element1 == e:\\n                cnt1 += 1\\n            elif element2 == e:\\n                cnt2 += 1\\n\\n        ans = []\\n        if cnt1 > len(nums) // 3:\\n            ans += [element1]\\n        if cnt2 > len(nums) // 3:\\n            ans += [element2]\\n\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 617150,
                "title": "java-o-n-time-and-o-1-space-complexity",
                "content": "Idea behind the issue is that there can only be 2 element which fullfill the criteria. (n/3 + n/3) = 2n/3. 2 elements which have sum greater than 2n/3. Which leaves rest of the elements with sum less than n/3.\\n\\n\\n\\tpublic List<Integer> majorityElement(int[] nums) {\\n        List res = new ArrayList<>();\\n        \\n        Integer first = null;\\n        Integer second = null;\\n        \\n        int count1 = 0;\\n        int count2 = 0;\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            if(first == null || first == nums[i]) {\\n                first = nums[i];\\n                count1++;\\n            }else if(second == null || second == nums[i]) {\\n                second = nums[i];\\n                count2++;\\n            }else if(count1 == 0){\\n                first = nums[i];\\n                count1++;\\n            }else if(count2 == 0){\\n                second = nums[i];\\n                count2++;\\n            }else{\\n                count1--;\\n                count2--;\\n            }\\n        }\\n        \\n        count1 = 0;\\n        count2 = 0;\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            if(first != null && nums[i] == first ) count1++;\\n            if(second != null && nums[i] == second) count2++;\\n        }\\n        \\n        int n = nums.length;\\n        if(count1 > n/3) res.add(first);\\n        if(count2 > n/3) res.add(second);\\n        \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "Idea behind the issue is that there can only be 2 element which fullfill the criteria. (n/3 + n/3) = 2n/3. 2 elements which have sum greater than 2n/3. Which leaves rest of the elements with sum less than n/3.\\n\\n\\n\\tpublic List<Integer> majorityElement(int[] nums) {\\n        List res = new ArrayList<>();\\n        \\n        Integer first = null;\\n        Integer second = null;\\n        \\n        int count1 = 0;\\n        int count2 = 0;\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            if(first == null || first == nums[i]) {\\n                first = nums[i];\\n                count1++;\\n            }else if(second == null || second == nums[i]) {\\n                second = nums[i];\\n                count2++;\\n            }else if(count1 == 0){\\n                first = nums[i];\\n                count1++;\\n            }else if(count2 == 0){\\n                second = nums[i];\\n                count2++;\\n            }else{\\n                count1--;\\n                count2--;\\n            }\\n        }\\n        \\n        count1 = 0;\\n        count2 = 0;\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            if(first != null && nums[i] == first ) count1++;\\n            if(second != null && nums[i] == second) count2++;\\n        }\\n        \\n        int n = nums.length;\\n        if(count1 > n/3) res.add(first);\\n        if(count2 > n/3) res.add(second);\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 341152,
                "title": "c-based-on-moore-s-voting-algorithm-beats-99-28-with-explaination",
                "content": "Based on Moore\\'s voting algorithm to find majority element.\\n> There can be max two elements with count > n/3 ( n/3 + n/3 + n/3 = n ).\\n\\nInitialize two majority elements with votes 0.\\nLoop through the array and\\n- Increase thier vote if it matches majority elements.\\n- Decrease otherwise.\\n- Reset the vote and majority element if the vote reaches zero.\\n\\nAt the end verify weather the majority elements indeed have count > n/3. If so then return it.\\n\\n```C++\\nclass Solution {\\npublic:\\n    vector<int> majorityElement( vector<int>& nums ) {\\n        // since we are looking for majority with more than n/3 votes\\n        // we can have only two majority element at max.\\n        \\n        // use moore\\'s voting algorithm to get suspected majority1 and majority2\\n        int majority1 = INT_MAX, majority2 = INT_MAX;\\n        int votes1 = 0, votes2 = 0;\\n        for( auto num : nums ) {\\n            if( num == majority1 ) {\\n                votes1++;\\n            } else if ( num == majority2 ) {\\n                votes2++;\\n            } else if( votes1 == 0 ) {\\n                majority1 = num;\\n                votes1 = 1;\\n            } else if( votes2 == 0 ) {\\n                majority2 = num;\\n                votes2 = 1;\\n            } else {\\n                votes1--;\\n                votes2--;\\n            }\\n        }\\n        \\n        // get the actual count of majority1 and majority2\\n        votes1 = 0, votes2 = 0;\\n        for( auto num : nums ) {\\n            if( num == majority1 )  { \\n                votes1++; \\n                \\n            } else if( num == majority2 ) {\\n                votes2++;\\n            }\\n        }\\n\\n        // verify count\\n        vector<int> res;\\n        if( votes1 > nums.size()/3.0 ) res.push_back( majority1 );\\n        if( votes2 > nums.size()/3.0 ) res.push_back( majority2 );\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    vector<int> majorityElement( vector<int>& nums ) {\\n        // since we are looking for majority with more than n/3 votes\\n        // we can have only two majority element at max.\\n        \\n        // use moore\\'s voting algorithm to get suspected majority1 and majority2\\n        int majority1 = INT_MAX, majority2 = INT_MAX;\\n        int votes1 = 0, votes2 = 0;\\n        for( auto num : nums ) {\\n            if( num == majority1 ) {\\n                votes1++;\\n            } else if ( num == majority2 ) {\\n                votes2++;\\n            } else if( votes1 == 0 ) {\\n                majority1 = num;\\n                votes1 = 1;\\n            } else if( votes2 == 0 ) {\\n                majority2 = num;\\n                votes2 = 1;\\n            } else {\\n                votes1--;\\n                votes2--;\\n            }\\n        }\\n        \\n        // get the actual count of majority1 and majority2\\n        votes1 = 0, votes2 = 0;\\n        for( auto num : nums ) {\\n            if( num == majority1 )  { \\n                votes1++; \\n                \\n            } else if( num == majority2 ) {\\n                votes2++;\\n            }\\n        }\\n\\n        // verify count\\n        vector<int> res;\\n        if( votes1 > nums.size()/3.0 ) res.push_back( majority1 );\\n        if( votes2 > nums.size()/3.0 ) res.push_back( majority2 );\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 63530,
                "title": "a-binary-search-solution-assuming-the-input-array-is-sorted-beats-99",
                "content": "everyone is posting moore's voting solution which is very nice. but if the input array is sorted we can do it in O(lgn) time. sometimes the interviewer may expect this solution rather than moore's voting.\\n\\n```\\npublic class Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        if(nums.length == 0) return new LinkedList<>();\\n        List<Integer> ans = new LinkedList<>();\\n        Arrays.sort(nums);\\n        int cand1 = nums[nums.length/3];\\n        int cand2 = nums[2*nums.length/3];\\n        if(cand1 == cand2){\\n            ans.add(cand1);\\n            return ans;\\n        }\\n        int len1 = binarySearch(nums, false, cand1) - binarySearch(nums, true, cand1)+1;\\n        if(len1 > nums.length/3) ans.add(cand1);\\n        int len2 = binarySearch(nums, false, cand2) - binarySearch(nums, true, cand2)+1;\\n        if(len2 > nums.length/3) ans.add(cand2);\\n        return ans;\\n    }\\n    \\n    int binarySearch(int[] nums, boolean op, int target){\\n        int ans = 0;\\n        int left = 0, right = nums.length-1;\\n        while(left <= right){\\n            int mid = left + (right-left)/2;\\n            if(nums[mid] == target){\\n                ans = mid;\\n                if(op){\\n                    right = mid-1;\\n                }else{\\n                    left = mid+1;\\n                }\\n            }else if(nums[mid] < target){\\n                left = mid+1;\\n            }else{\\n                right = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        if(nums.length == 0) return new LinkedList<>();\\n        List<Integer> ans = new LinkedList<>();\\n        Arrays.sort(nums);\\n        int cand1 = nums[nums.length/3];\\n        int cand2 = nums[2*nums.length/3];\\n        if(cand1 == cand2){\\n            ans.add(cand1);\\n            return ans;\\n        }\\n        int len1 = binarySearch(nums, false, cand1) - binarySearch(nums, true, cand1)+1;\\n        if(len1 > nums.length/3) ans.add(cand1);\\n        int len2 = binarySearch(nums, false, cand2) - binarySearch(nums, true, cand2)+1;\\n        if(len2 > nums.length/3) ans.add(cand2);\\n        return ans;\\n    }\\n    \\n    int binarySearch(int[] nums, boolean op, int target){\\n        int ans = 0;\\n        int left = 0, right = nums.length-1;\\n        while(left <= right){\\n            int mid = left + (right-left)/2;\\n            if(nums[mid] == target){\\n                ans = mid;\\n                if(op){\\n                    right = mid-1;\\n                }else{\\n                    left = mid+1;\\n                }\\n            }else if(nums[mid] < target){\\n                left = mid+1;\\n            }else{\\n                right = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717265,
                "title": "hashtable-and-count-method",
                "content": "# Hashtable Method:TC-->O(N)\\n```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        dic=Counter(nums)\\n        n,list1=len(nums),[]\\n        for i,v in dic.items():\\n            if v>n//3:\\n                list1.append(i)\\n        return list1\\n```\\n# Count Method--->(N^2)\\n```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        n,count=len(nums),[]\\n        num=set(nums)\\n        for i in num:\\n            if nums.count(i)>n/3:\\n                count.append(i)\\n        return count\\n```\\n# without using inbuild Functions\\n```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        dic={}\\n        for i in nums:\\n            if i not in dic:\\n                dic[i]=1\\n            else:\\n                dic[i]+=1\\n        n,list1=len(nums),[]\\n        for i,v in dic.items():\\n            if v>n//3:\\n                list1.append(i)\\n        return list1\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        dic=Counter(nums)\\n        n,list1=len(nums),[]\\n        for i,v in dic.items():\\n            if v>n//3:\\n                list1.append(i)\\n        return list1\\n```\n```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        n,count=len(nums),[]\\n        num=set(nums)\\n        for i in num:\\n            if nums.count(i)>n/3:\\n                count.append(i)\\n        return count\\n```\n```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        dic={}\\n        for i in nums:\\n            if i not in dic:\\n                dic[i]=1\\n            else:\\n                dic[i]+=1\\n        n,list1=len(nums),[]\\n        for i,v in dic.items():\\n            if v>n//3:\\n                list1.append(i)\\n        return list1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653093,
                "title": "most-optimal-solution-using-moore-s-vooty-algorithm",
                "content": "\\n\\n# Approach\\nThe key idea behind this algorithm is that in an array of size n, there can be at most two elements that appear more than \\u230A n/3 \\u230B times. By eliminating pairs of different elements, the algorithm identifies the potential majority elements, and then it verifies their actual frequencies to ensure they meet the threshold.\\n\\n# Complexity\\n- Time complexity:\\nO(2n) = O(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int cnt1 = 0, cnt2 = 0;\\n        int el1 = INT_MIN;\\n        int el2 = INT_MIN;\\n        int n = nums.size();\\n        for(int i = 0; i< n; i++){\\n            if(cnt1 == 0 && nums[i] != el2){\\n                cnt1 = 1;\\n                el1 = nums[i];\\n            }\\n            else if(cnt2 == 0 && nums[i] != el1){\\n                cnt2 = 1;\\n                el2 = nums[i];\\n            }\\n            else if(el1 == nums[i]) cnt1++;\\n            else if(el2 == nums[i]) cnt2++;\\n            else{\\n                cnt1--;\\n                cnt2--;\\n            }\\n        }\\n        vector<int> ans;\\n        cnt1 = 0, cnt2 = 0;\\n        for(int i = 0; i< n; i++){\\n            if(el1 == nums[i]) cnt1++;\\n            if(el2 == nums[i]) cnt2++;\\n        }\\n        int mini = (int)(n/3)+1;\\n        if(cnt1 >= mini) ans.push_back(el1);\\n        if(cnt2 >= mini) ans.push_back(el2);\\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Sorting",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int cnt1 = 0, cnt2 = 0;\\n        int el1 = INT_MIN;\\n        int el2 = INT_MIN;\\n        int n = nums.size();\\n        for(int i = 0; i< n; i++){\\n            if(cnt1 == 0 && nums[i] != el2){\\n                cnt1 = 1;\\n                el1 = nums[i];\\n            }\\n            else if(cnt2 == 0 && nums[i] != el1){\\n                cnt2 = 1;\\n                el2 = nums[i];\\n            }\\n            else if(el1 == nums[i]) cnt1++;\\n            else if(el2 == nums[i]) cnt2++;\\n            else{\\n                cnt1--;\\n                cnt2--;\\n            }\\n        }\\n        vector<int> ans;\\n        cnt1 = 0, cnt2 = 0;\\n        for(int i = 0; i< n; i++){\\n            if(el1 == nums[i]) cnt1++;\\n            if(el2 == nums[i]) cnt2++;\\n        }\\n        int mini = (int)(n/3)+1;\\n        if(cnt1 >= mini) ans.push_back(el1);\\n        if(cnt2 >= mini) ans.push_back(el2);\\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561798,
                "title": "best-o-n-solution",
                "content": "# Approach\\nExtended Boyer Moore\\u2019s Voting Algorithm\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int n = nums.size();\\n        vector <int> ans;\\n        int cnt1 = 0, ele1 = INT_MIN;\\n        int cnt2 = 0, ele2 = INT_MIN;\\n        for (int i = 0; i < n; i++) {\\n            if (cnt1 == 0 && nums[i] != ele2) {\\n                ele1 = nums[i];\\n                cnt1 = 1;\\n            } else if (cnt2 == 0 && nums[i] != ele1) {\\n                ele2 = nums[i];\\n                cnt2 = 1;\\n            } else if (nums[i] == ele1) {\\n                cnt1++;\\n            } else if (nums[i] == ele2) {\\n                cnt2++;\\n            } else {\\n                cnt1--;\\n                cnt2--;\\n            }\\n        }\\n        int count1 = 0, count2 = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == ele1) {\\n                count1++;\\n            }\\n            if (nums[i] == ele2) {\\n                count2++;\\n            }\\n        }\\n        if (count1 > n/3) {\\n            ans.push_back(ele1);\\n        }\\n        if (count2 > n/3) {\\n            ans.push_back(ele2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int n = nums.size();\\n        vector <int> ans;\\n        int cnt1 = 0, ele1 = INT_MIN;\\n        int cnt2 = 0, ele2 = INT_MIN;\\n        for (int i = 0; i < n; i++) {\\n            if (cnt1 == 0 && nums[i] != ele2) {\\n                ele1 = nums[i];\\n                cnt1 = 1;\\n            } else if (cnt2 == 0 && nums[i] != ele1) {\\n                ele2 = nums[i];\\n                cnt2 = 1;\\n            } else if (nums[i] == ele1) {\\n                cnt1++;\\n            } else if (nums[i] == ele2) {\\n                cnt2++;\\n            } else {\\n                cnt1--;\\n                cnt2--;\\n            }\\n        }\\n        int count1 = 0, count2 = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == ele1) {\\n                count1++;\\n            }\\n            if (nums[i] == ele2) {\\n                count2++;\\n            }\\n        }\\n        if (count1 > n/3) {\\n            ans.push_back(ele1);\\n        }\\n        if (count2 > n/3) {\\n            ans.push_back(ele2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1423573,
                "title": "c-boyer-moore-s-voting-algo-t-c-o-n-s-c-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checker(vector<int>& nums, long long val){\\n        int count=0,n=nums.size();\\n        for(int i=0;i<n;++i){\\n            if(nums[i]==val) count++;\\n        }\\n        return count>floor(n/3) ? true : false;\\n    }\\n    \\n    vector<int> majorityElement(vector<int>& nums) {\\n        long long val1=nums[0],count1=1,val2=LLONG_MIN,count2=0,i=1;\\n        \\n        while(i<nums.size()){\\n            if(nums[i]==val1){\\n                count1++;\\n            }else if(nums[i]==val2){\\n                count2++;\\n            }else{\\n                if(count1==0){\\n                    val1=nums[i];\\n                    count1++;\\n                }else if(count2==0){\\n                    val2=nums[i];\\n                    count2++;\\n                }else{\\n                    count1--;\\n                    count2--;\\n                }\\n            }\\n            i++;\\n        }\\n        \\n        vector<int> ans;\\n        if(checker(nums,val1)) ans.push_back(val1);\\n        if(checker(nums,val2)) ans.push_back(val2);\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checker(vector<int>& nums, long long val){\\n        int count=0,n=nums.size();\\n        for(int i=0;i<n;++i){\\n            if(nums[i]==val) count++;\\n        }\\n        return count>floor(n/3) ? true : false;\\n    }\\n    \\n    vector<int> majorityElement(vector<int>& nums) {\\n        long long val1=nums[0],count1=1,val2=LLONG_MIN,count2=0,i=1;\\n        \\n        while(i<nums.size()){\\n            if(nums[i]==val1){\\n                count1++;\\n            }else if(nums[i]==val2){\\n                count2++;\\n            }else{\\n                if(count1==0){\\n                    val1=nums[i];\\n                    count1++;\\n                }else if(count2==0){\\n                    val2=nums[i];\\n                    count2++;\\n                }else{\\n                    count1--;\\n                    count2--;\\n                }\\n            }\\n            i++;\\n        }\\n        \\n        vector<int> ans;\\n        if(checker(nums,val1)) ans.push_back(val1);\\n        if(checker(nums,val2)) ans.push_back(val2);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339763,
                "title": "c-2-method-moore-s-voting-algorithm-map-based",
                "content": "**Boyer Moore\\'s wating algorithm based (Two Pass Solution)**\\n**Time : O(n)**\\n**Space : O(1)**\\n```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>&a) {\\n        vector<int> ans;\\n        int n = a.size();\\n        \\n        int num1 = INT_MIN;        \\n        int num2 = INT_MIN;\\n        int count1 = 0;        \\n        int count2 = 0;\\n\\t\\t\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]==num1) count1++;\\n            else if(a[i]==num2) count2++;\\n            else if(count1 == 0)\\n            {\\n                num1 = a[i];\\n                count1 = 1;\\n            }\\n            else if(count2 == 0)\\n            {\\n                num2 = a[i];\\n                count2 = 1;\\n            }\\n            else\\n            {\\n                count1--;\\n                count2--;\\n            }\\n        }\\n        count1 = 0;\\n        count2 = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]==num1) count1++;\\n            else if(a[i]==num2) count2++;\\n        }\\n        if(count1>(n/3)) ans.push_back(num1);\\n        if(count2>(n/3)) ans.push_back(num2);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Map Based Solution**\\n**Time : O(n)**\\n**Space : O(n)**\\n```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>&a) {\\n        vector<int> ans;\\n        int n = a.size();\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++)\\n        {\\n            m[a[i]]++;\\n        }\\n        for(auto i:m)\\n        {\\n            if(i.second>(n/3))\\n            {\\n                ans.push_back(i.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n*If find helpful please upvote it* **:)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>&a) {\\n        vector<int> ans;\\n        int n = a.size();\\n        \\n        int num1 = INT_MIN;        \\n        int num2 = INT_MIN;\\n        int count1 = 0;        \\n        int count2 = 0;\\n\\t\\t\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]==num1) count1++;\\n            else if(a[i]==num2) count2++;\\n            else if(count1 == 0)\\n            {\\n                num1 = a[i];\\n                count1 = 1;\\n            }\\n            else if(count2 == 0)\\n            {\\n                num2 = a[i];\\n                count2 = 1;\\n            }\\n            else\\n            {\\n                count1--;\\n                count2--;\\n            }\\n        }\\n        count1 = 0;\\n        count2 = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]==num1) count1++;\\n            else if(a[i]==num2) count2++;\\n        }\\n        if(count1>(n/3)) ans.push_back(num1);\\n        if(count2>(n/3)) ans.push_back(num2);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>&a) {\\n        vector<int> ans;\\n        int n = a.size();\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++)\\n        {\\n            m[a[i]]++;\\n        }\\n        for(auto i:m)\\n        {\\n            if(i.second>(n/3))\\n            {\\n                ans.push_back(i.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 852233,
                "title": "java-soln-faster-than-100",
                "content": "```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        int n=nums.length;\\n        List<Integer> list=new ArrayList<>();\\n        if(n==0)return list;\\n        int temp1=0,temp2=0,ctr1=0,ctr2=0;\\n        for(int i:nums)\\n        {\\n            if(i==temp1)\\n                ctr1++;\\n            else if(i==temp2)\\n                ctr2++;\\n            else if(ctr1==0)\\n            {\\n                ctr1=1;\\n                temp1=i;\\n            }\\n            else if(ctr2==0)\\n            {\\n                ctr2=1;\\n                temp2=i;\\n            }\\n            else\\n            {\\n                ctr1--;\\n                ctr2--;\\n            }\\n        }\\n        ctr1=0;\\n        ctr2=0;\\n        for(int i : nums)\\n        {\\n            if(i==temp1)\\n                ctr1++;\\n            else if(i==temp2)\\n                ctr2++;\\n        }\\n        if(ctr1>n/3)list.add(temp1);\\n        if(ctr2>n/3)list.add(temp2);\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        int n=nums.length;\\n        List<Integer> list=new ArrayList<>();\\n        if(n==0)return list;\\n        int temp1=0,temp2=0,ctr1=0,ctr2=0;\\n        for(int i:nums)\\n        {\\n            if(i==temp1)\\n                ctr1++;\\n            else if(i==temp2)\\n                ctr2++;\\n            else if(ctr1==0)\\n            {\\n                ctr1=1;\\n                temp1=i;\\n            }\\n            else if(ctr2==0)\\n            {\\n                ctr2=1;\\n                temp2=i;\\n            }\\n            else\\n            {\\n                ctr1--;\\n                ctr2--;\\n            }\\n        }\\n        ctr1=0;\\n        ctr2=0;\\n        for(int i : nums)\\n        {\\n            if(i==temp1)\\n                ctr1++;\\n            else if(i==temp2)\\n                ctr2++;\\n        }\\n        if(ctr1>n/3)list.add(temp1);\\n        if(ctr2>n/3)list.add(temp2);\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 457203,
                "title": "go-golang-runtime-o-n-memory-o-1-real-no-dictionary-boyer-moore-majority-vote-algorithm",
                "content": "```go\\nfunc majorityElement(nums []int) []int {\\n    count1, count2, n1, n2 := 0, 0, 0, 0\\n    \\n\\t// 1. Calcualting counters and finding candidates n1 and n2\\n    for _, a := range nums {\\n        if a == n1 {\\n            count1++\\n        } else if a == n2 {\\n            count2++\\n        } else if count1 == 0 {\\n            n1 = a\\n            count1 = 1\\n        } else if count2 == 0 {\\n            n2 = a\\n            count2 = 1\\n        } else {\\n            count1--\\n            count2--\\n        }\\n    }\\n    \\n\\t// 2. Checking counters and forming output array\\n    var out []int\\n    count1 = len(nums)/3\\n    count2 = len(nums)/3\\n    for _, a := range nums {\\n        if a == n1 {\\n            count1--\\n        } else if a == n2 {\\n            count2--\\n        }   \\n    }\\n        \\n    if count1 < 0 {\\n        out = append(out, n1)\\n    }\\n        \\n    if count2 < 0 {\\n        out = append(out, n2)\\n    }\\n    \\n    return out\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc majorityElement(nums []int) []int {\\n    count1, count2, n1, n2 := 0, 0, 0, 0\\n    \\n\\t// 1. Calcualting counters and finding candidates n1 and n2\\n    for _, a := range nums {\\n        if a == n1 {\\n            count1++\\n        } else if a == n2 {\\n            count2++\\n        } else if count1 == 0 {\\n            n1 = a\\n            count1 = 1\\n        } else if count2 == 0 {\\n            n2 = a\\n            count2 = 1\\n        } else {\\n            count1--\\n            count2--\\n        }\\n    }\\n    \\n\\t// 2. Checking counters and forming output array\\n    var out []int\\n    count1 = len(nums)/3\\n    count2 = len(nums)/3\\n    for _, a := range nums {\\n        if a == n1 {\\n            count1--\\n        } else if a == n2 {\\n            count2--\\n        }   \\n    }\\n        \\n    if count1 < 0 {\\n        out = append(out, n1)\\n    }\\n        \\n    if count2 < 0 {\\n        out = append(out, n2)\\n    }\\n    \\n    return out\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 63549,
                "title": "java-o-n-solution",
                "content": "```\\npublic List<Integer> majorityElement(int[] nums) {\\n        int max1 = 0;\\n        int max2 = 1; //make sure these two numbers are different. \\n        int count1 = 0;\\n        int count2 = 0;\\n        \\n        for (int num:nums) {\\n            if (num == max1) {\\n                count1++;\\n            }\\n            else if (num == max2) {\\n                count2++;\\n            }\\n            else if (count1 == 0) {\\n                max1 = num;\\n                count1 = 1;\\n            }\\n            else if (count2 == 0) {\\n                max2 = num;\\n                count2 = 1;\\n            }\\n            else {\\n                count1--;\\n                count2--;\\n            }\\n        }\\n        count1 = 0;\\n        count2 = 0;\\n        List<Integer> result = new ArrayList<Integer>();\\n        for (int num: nums){\\n            if (num == max1) {\\n                count1++;\\n            }\\n            else if (num == max2) {\\n                count2++;\\n            }\\n        }\\n        if (count1 > nums.length/3) {\\n            result.add(max1);\\n        }\\n        if (count2 > nums.length/3) {\\n            result.add(max2);\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> majorityElement(int[] nums) {\\n        int max1 = 0;\\n        int max2 = 1; //make sure these two numbers are different. \\n        int count1 = 0;\\n        int count2 = 0;\\n        \\n        for (int num:nums) {\\n            if (num == max1) {\\n                count1++;\\n            }\\n            else if (num == max2) {\\n                count2++;\\n            }\\n            else if (count1 == 0) {\\n                max1 = num;\\n                count1 = 1;\\n            }\\n            else if (count2 == 0) {\\n                max2 = num;\\n                count2 = 1;\\n            }\\n            else {\\n                count1--;\\n                count2--;\\n            }\\n        }\\n        count1 = 0;\\n        count2 = 0;\\n        List<Integer> result = new ArrayList<Integer>();\\n        for (int num: nums){\\n            if (num == max1) {\\n                count1++;\\n            }\\n            else if (num == max2) {\\n                count2++;\\n            }\\n        }\\n        if (count1 > nums.length/3) {\\n            result.add(max1);\\n        }\\n        if (count2 > nums.length/3) {\\n            result.add(max2);\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3482440,
                "title": "moore-s-algorithm-best-possible-explanation-ever",
                "content": "# Intuition\\nIf the array contains the majority of elements, their occurrence must be greater than the floor(N/3). Now, we can say that the count of minority elements and majority elements is equal up to a certain point in the array. So when we traverse through the array we try to keep track of the counts of elements and the elements themselves for which we are tracking the counts. \\n\\nAfter traversing the whole array, we will check the elements stored in the variables. Then we need to check if the stored elements are the majority elements or not by manually checking their counts.\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize 4 variables:\\ncnt1 & cnt2 \\u2013  for tracking the counts of elements\\nel1 & el2 \\u2013 for storing the majority of elements.\\n2. Traverse through the given array.\\nIf cnt1 is 0 and the current element is not el2 then store the current element of the array as el1 along with increasing the cnt1 value by 1.\\nIf cnt2 is 0 and the current element is not el1 then store the current element of the array as el2 along with increasing the cnt2 value by 1.\\nIf the current element and el1 are the same increase the cnt1 by 1.\\nIf the current element and el2 are the same increase the cnt2 by 1.\\nOther than all the above cases: decrease cnt1 and cnt2 by 1.\\n3. The integers present in el1 & el2 should be the result we are expecting. So, using another loop, we will manually check their counts if they are greater than the floor(N/3).\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N) + O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic static List<Integer> majorityElement(int []v) {\\n        int n = v.length; //size of the array\\n\\n        int cnt1 = 0, cnt2 = 0; // counts\\n        int el1 = Integer.MIN_VALUE; // element 1\\n        int el2 = Integer.MIN_VALUE; // element 2\\n\\n        // applying the Extended Boyer Moore\\'s Voting Algorithm:\\n        for (int i = 0; i < n; i++) {\\n            if (cnt1 == 0 && el2 != v[i]) {\\n                cnt1 = 1;\\n                el1 = v[i];\\n            } else if (cnt2 == 0 && el1 != v[i]) {\\n                cnt2 = 1;\\n                el2 = v[i];\\n            } else if (v[i] == el1) cnt1++;\\n            else if (v[i] == el2) cnt2++;\\n            else {\\n                cnt1--; cnt2--;\\n            }\\n        }\\n\\n        List<Integer> ls = new ArrayList<>(); // list of answers\\n\\n        // Manually check if the stored elements in\\n        // el1 and el2 are the majority elements:\\n        cnt1 = 0; cnt2 = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (v[i] == el1) cnt1++;\\n            if (v[i] == el2) cnt2++;\\n        }\\n\\n        int mini = (int)(n / 3) + 1;\\n        if (cnt1 >= mini) ls.add(el1);\\n        if (cnt2 >= mini) ls.add(el2);\\n\\n        // Uncomment the following line\\n        // if it is told to sort the answer array:\\n        //Collections.sort(ls); //TC --> O(2*log2) ~ O(1);\\n\\n        return ls;\\n    }\\n        \\n    }\\n\\n\\n```\\nPLEASE CONSIDER UPVOTING IF U LIKE THE SOLUTION.MO",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic static List<Integer> majorityElement(int []v) {\\n        int n = v.length; //size of the array\\n\\n        int cnt1 = 0, cnt2 = 0; // counts\\n        int el1 = Integer.MIN_VALUE; // element 1\\n        int el2 = Integer.MIN_VALUE; // element 2\\n\\n        // applying the Extended Boyer Moore\\'s Voting Algorithm:\\n        for (int i = 0; i < n; i++) {\\n            if (cnt1 == 0 && el2 != v[i]) {\\n                cnt1 = 1;\\n                el1 = v[i];\\n            } else if (cnt2 == 0 && el1 != v[i]) {\\n                cnt2 = 1;\\n                el2 = v[i];\\n            } else if (v[i] == el1) cnt1++;\\n            else if (v[i] == el2) cnt2++;\\n            else {\\n                cnt1--; cnt2--;\\n            }\\n        }\\n\\n        List<Integer> ls = new ArrayList<>(); // list of answers\\n\\n        // Manually check if the stored elements in\\n        // el1 and el2 are the majority elements:\\n        cnt1 = 0; cnt2 = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (v[i] == el1) cnt1++;\\n            if (v[i] == el2) cnt2++;\\n        }\\n\\n        int mini = (int)(n / 3) + 1;\\n        if (cnt1 >= mini) ls.add(el1);\\n        if (cnt2 >= mini) ls.add(el2);\\n\\n        // Uncomment the following line\\n        // if it is told to sort the answer array:\\n        //Collections.sort(ls); //TC --> O(2*log2) ~ O(1);\\n\\n        return ls;\\n    }\\n        \\n    }\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3077925,
                "title": "easy-to-understand-c-solution-using-map-tc-o-n-sc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nI used the map to store the frequency.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        map <int,int> mp;\\n        vector <int> v;\\n        for(int i:nums) mp[i]++;\\n        for(auto &it:mp){\\n            if((it.second)>(nums.size()/3))\\n                v.push_back(it.first);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        map <int,int> mp;\\n        vector <int> v;\\n        for(int i:nums) mp[i]++;\\n        for(auto &it:mp){\\n            if((it.second)>(nums.size()/3))\\n                v.push_back(it.first);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829289,
                "title": "c-easy-solution-in-o-1-space-and-o-n-time-complexity-100-fast",
                "content": "(1)....An array of fixed size or whose size does not depends on the size of the inputs is considered as O(1) extra space only. If it depended on the number of inputs \\'n\\' then it will consume O(n) extra space. But here we took an array of size 50001 whhich is fixed for any input so it will consume O(1) extra space only.\\n \\n (2)....We can\\'t blindly allocate the size of malloced array equal to the \\'numsSize\\' or else when a huge number of inputs are given it will consume too much of heap memory. So, for that we can see that we need to find out elements that occur more than n/3 times so for n inputs we require max to max (n/3)+1 space. But now comes the exception for n=2 we require 2 space as floor(n/3)=0 and both the elements occur more than 0 times. So, for being in the safe side i took the size of malloced array as (n/3)+2.\\n \\n(3) To deal with negative numbers in count sort type technique we can simply find minimum element and than use a[nums[i]-min]++ for eg. [-1,-1,8,5,4] we have min=-1 so, num[0]-(-1)=0 i.e, it will use 0th index. It will work for case in which their are no negative elements also.\\n\\n```\\nint* majorityElement(int* nums, int numsSize, int* returnSize){\\n    int a[50001]={0};  //an array with whom we\\'ll be able to solve our problem.....(1)\\n    int min=INT_MAX;  //variable for finding minimum element in our array\\n    int max=INT_MIN;  //variable for finding maximum element in our array\\n    for(int i=0;i<numsSize;i++)\\n    {\\n        min=min>nums[i]?nums[i]:min;\\n        max=max>nums[i]?max:nums[i];\\n    }\\n    int* ans=malloc(((numsSize/3)+2)*sizeof(int));  //dynamically allocating our array....(2)\\n    for(int i=0;i<numsSize;i++) a[nums[i]-min]++;  //.....(3)\\n    int j=0;\\n    for(int i=0;i<=max-min;i++)\\n    {\\n        if(a[i]>numsSize/3) ans[j++]=i+min;\\n    }\\n    *(returnSize)=j;\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint* majorityElement(int* nums, int numsSize, int* returnSize){\\n    int a[50001]={0};  //an array with whom we\\'ll be able to solve our problem.....(1)\\n    int min=INT_MAX;  //variable for finding minimum element in our array\\n    int max=INT_MIN;  //variable for finding maximum element in our array\\n    for(int i=0;i<numsSize;i++)\\n    {\\n        min=min>nums[i]?nums[i]:min;\\n        max=max>nums[i]?max:nums[i];\\n    }\\n    int* ans=malloc(((numsSize/3)+2)*sizeof(int));  //dynamically allocating our array....(2)\\n    for(int i=0;i<numsSize;i++) a[nums[i]-min]++;  //.....(3)\\n    int j=0;\\n    for(int i=0;i<=max-min;i++)\\n    {\\n        if(a[i]>numsSize/3) ans[j++]=i+min;\\n    }\\n    *(returnSize)=j;\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2613363,
                "title": "c-optimised-solution",
                "content": "\\t  \\n\\t  \\n\\t  vector<int> majorityElement(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        int num1=-1,num2= -1, count1=0, count2=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i] == num1)\\n            {\\n                count1++;\\n            }\\n            else if(nums[i]==num2)\\n            {\\n                count2++;\\n            }\\n            else if(count1==0)\\n            {\\n                num1 = nums[i];\\n                count1 =1;\\n            }\\n            else if(count2==0)\\n            {\\n                if(nums[i] != num1)\\n                {\\n                num2 = nums[i];\\n                count2 = 1;\\n                }\\n            }\\n            else\\n            {\\n                count1--;\\n                count2--;\\n            }\\n        }\\n        vector<int> ans;\\n        count1 = count2 =0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(num1 == nums[i])\\n            {\\n                count1++;\\n            }\\n            if(num2 == nums[i])\\n            {\\n                count2++;\\n            }\\n        }\\n        \\n        if(num1 == num2)\\n        {\\n            ans.push_back(num1);\\n            return ans;\\n        }\\n        \\n        if(count1 >n/3)\\n        {\\n            ans.push_back(num1);\\n        }\\n        if(count2 >n/3)\\n        {\\n            ans.push_back(num2);\\n        }\\n\\n        return ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\t  \\n\\t  \\n\\t  vector<int> majorityElement(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        int num1=-1,num2= -1, count1=0, count2=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i] == num1)\\n            {\\n                count1++;\\n            }\\n            else if(nums[i]==num2)\\n            {\\n                count2++;\\n            }\\n            else if(count1==0)\\n            {\\n                num1 = nums[i];\\n                count1 =1;\\n            }\\n            else if(count2==0)\\n            {\\n                if(nums[i] != num1)\\n                {\\n                num2 = nums[i];\\n                count2 = 1;\\n                }\\n            }\\n            else\\n            {\\n                count1--;\\n                count2--;\\n            }\\n        }\\n        vector<int> ans;\\n        count1 = count2 =0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(num1 == nums[i])\\n            {\\n                count1++;\\n            }\\n            if(num2 == nums[i])\\n            {\\n                count2++;\\n            }\\n        }\\n        \\n        if(num1 == num2)\\n        {\\n            ans.push_back(num1);\\n            return ans;\\n        }\\n        \\n        if(count1 >n/3)\\n        {\\n            ans.push_back(num1);\\n        }\\n        if(count2 >n/3)\\n        {\\n            ans.push_back(num2);\\n        }\\n\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2101625,
                "title": "c-extended-boyer-moore-voting-algorithm-t-o-n-s-o-1",
                "content": "```\\nvector<int> majorityElement(vector<int>& nums) {\\n        int m1=INT_MIN,m2=INT_MIN;\\n        int c1=0,c2=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==m1)c1++;\\n            else if(nums[i]==m2)c2++;\\n            else if(c1==0){m1=nums[i]; c1++;}\\n            else if(c2==0){m2=nums[i]; c2++;}\\n            else{\\n                c1--;c2--;\\n            }\\n        }\\n        \\n        c1=0;c2=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==m1)c1++;\\n            else if(nums[i]==m2)c2++;\\n        }\\n        if(c1>n/3&&c2>n/3)return {m1,m2};\\n        if(c1>n/3)return {m1};\\n        if(c2>n/3)return {m2};\\n        return {};\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> majorityElement(vector<int>& nums) {\\n        int m1=INT_MIN,m2=INT_MIN;\\n        int c1=0,c2=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==m1)c1++;\\n            else if(nums[i]==m2)c2++;\\n            else if(c1==0){m1=nums[i]; c1++;}\\n            else if(c2==0){m2=nums[i]; c2++;}\\n            else{\\n                c1--;c2--;\\n            }\\n        }\\n        \\n        c1=0;c2=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==m1)c1++;\\n            else if(nums[i]==m2)c2++;\\n        }\\n        if(c1>n/3&&c2>n/3)return {m1,m2};\\n        if(c1>n/3)return {m1};\\n        if(c2>n/3)return {m2};\\n        return {};\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1977076,
                "title": "explained-java-linear-time-with-o-1-space-solution",
                "content": "There can only exist 2 numbers which are present more than {n/3} times in an array of size {n}.\\n\\n**For example**\\nn = 10\\nn/3 = 10/3 = 3\\nSo if two number exist more than 3 times, than they must have to be present in the array atleast 4 times.\\nAnd therefore 10 - (2*4) = 2, so only 2 numbers left.\\nThis is valid for all array sizes.\\n        \\nThe most optimal way to find this two numbers is using **Boyer Moore\\'s Voting Algo**.\\n        \\nTime Complexity = O(n) to find the two numbers + O(n) to check if the numbers actually exist more than {n/3} times. = O(2n) = **O(n)**\\n        \\nSpace Complexity = **O(1)**\\n\\n```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        int num1 = 0, count1 = 0, num2 = 0, count2 = 0;\\n        \\n        // Find the numbers which exist in the array most\\n        for(int num : nums) {\\n            \\n            if( num == num1 ) {\\n                ++count1;\\n            } else if( num == num2 ) {\\n                ++count2;\\n            } else if( count1 == 0 ) {\\n                num1 = num;\\n                count1 = 1;\\n            } else if( count2 == 0 ) {\\n                num2 = num;\\n                count2 = 1;\\n            } else {\\n                --count1;\\n                --count2;\\n            }\\n        }\\n        \\n        // Find the total number of times {num1} and {nums2} are present in the array\\n        count1 = 0;\\n        count2 = 0;\\n        \\n        for(int num : nums) {\\n            if( num == num1 ) {\\n                ++count1;\\n            } else if( num == num2 ) {\\n                ++count2;\\n            }\\n        }\\n        \\n        // n/3 of array size (no need to Math.floor as the operations are performed on integers)\\n        int required = nums.length / 3;\\n        \\n        List<Integer> result = new ArrayList<Integer>();\\n        \\n        // Add the numbers to the result if they exist more than {n/3} times.\\n        if( count1 > required ) {\\n            result.add( num1 );\\n        }\\n        \\n        if( count2 > required ) {\\n            result.add( num2 );\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\\t\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        int num1 = 0, count1 = 0, num2 = 0, count2 = 0;\\n        \\n        // Find the numbers which exist in the array most\\n        for(int num : nums) {\\n            \\n            if( num == num1 ) {\\n                ++count1;\\n            } else if( num == num2 ) {\\n                ++count2;\\n            } else if( count1 == 0 ) {\\n                num1 = num;\\n                count1 = 1;\\n            } else if( count2 == 0 ) {\\n                num2 = num;\\n                count2 = 1;\\n            } else {\\n                --count1;\\n                --count2;\\n            }\\n        }\\n        \\n        // Find the total number of times {num1} and {nums2} are present in the array\\n        count1 = 0;\\n        count2 = 0;\\n        \\n        for(int num : nums) {\\n            if( num == num1 ) {\\n                ++count1;\\n            } else if( num == num2 ) {\\n                ++count2;\\n            }\\n        }\\n        \\n        // n/3 of array size (no need to Math.floor as the operations are performed on integers)\\n        int required = nums.length / 3;\\n        \\n        List<Integer> result = new ArrayList<Integer>();\\n        \\n        // Add the numbers to the result if they exist more than {n/3} times.\\n        if( count1 > required ) {\\n            result.add( num1 );\\n        }\\n        \\n        if( count2 > required ) {\\n            result.add( num2 );\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806475,
                "title": "two-methods-using-map-moore-s-voting-algorithm",
                "content": "## \\t\\tMethod-1 : Using Map\\n\\t\\tint n = nums.size();\\n        vector<int> myvec;\\n        unordered_map<int,int> mymap;\\n        for(auto it : nums) mymap[it]++;\\n        for(auto it : mymap)\\n            if(it.second > n/3) myvec.push_back(it.first);\\n        \\n        return myvec;\\n\\t\\t\\n## \\t\\tMethod-2 : Using Moore\\'s Voting Algorithm\\n        \\n        int n = nums.size();\\n        vector<int> myvec;\\n        int ele1 = -1 , ele2 = -1, count1 = 0 , count2 = 0;\\n\\t\\t\\n        for(auto it : nums){\\n            \\n            if(ele1 == it) count1++;\\n            else if(ele2 == it) count2++;\\n            \\n            else if(count1 == 0) {\\n                ele1 = it;\\n                count1 = 1;\\n            }\\n            else if(count2 == 0) {\\n                ele2 = it;\\n                count2 = 1;\\n            }\\n            \\n            else {\\n                count1--;\\n                count2--;\\n            }\\n        }\\n        \\n        count1 =0;\\n        count2 = 0;\\n        for(auto it : nums){\\n            if(it == ele1) count1++;\\n            else if(it == ele2) count2++;\\n        }\\n        if(count1 > n/3) myvec.push_back(ele1);\\n        if(count2 > n/3) myvec.push_back(ele2);\\n        return myvec;\\n## \\t\\tIf(solution == helpfull ) upvote \\uD83E\\uDD17 . . .",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "## \\t\\tMethod-1 : Using Map\\n\\t\\tint n = nums.size();\\n        vector<int> myvec;\\n        unordered_map<int,int> mymap;\\n        for(auto it : nums) mymap[it]++;\\n        for(auto it : mymap)\\n            if(it.second > n/3) myvec.push_back(it.first);\\n        \\n        return myvec;\\n\\t\\t\\n## \\t\\tMethod-2 : Using Moore\\'s Voting Algorithm\\n        \\n        int n = nums.size();\\n        vector<int> myvec;\\n        int ele1 = -1 , ele2 = -1, count1 = 0 , count2 = 0;\\n\\t\\t\\n        for(auto it : nums){\\n            \\n            if(ele1 == it) count1++;\\n            else if(ele2 == it) count2++;\\n            \\n            else if(count1 == 0) {\\n                ele1 = it;\\n                count1 = 1;\\n            }\\n            else if(count2 == 0) {\\n                ele2 = it;\\n                count2 = 1;\\n            }\\n            \\n            else {\\n                count1--;\\n                count2--;\\n            }\\n        }\\n        \\n        count1 =0;\\n        count2 = 0;\\n        for(auto it : nums){\\n            if(it == ele1) count1++;\\n            else if(it == ele2) count2++;\\n        }\\n        if(count1 > n/3) myvec.push_back(ele1);\\n        if(count2 > n/3) myvec.push_back(ele2);\\n        return myvec;\\n## \\t\\tIf(solution == helpfull ) upvote \\uD83E\\uDD17 . . .",
                "codeTag": "Unknown"
            },
            {
                "id": 1787778,
                "title": "cpp-soltuion-o-1-space-94-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums)\\n    {\\n        sort(nums.begin(),nums.end());\\n        vector<int>ans;\\n         int current=1;\\n        int n=nums.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]==nums[i-1])\\n            {\\n               current++;\\n            }\\n         else  if(nums[i]!=nums[i-1])\\n            {\\n                if(current>n/3)\\n                    ans.push_back(nums[i-1]);\\n             current=1;\\n            }\\n        }\\n        if(current>n/3)\\n            ans.push_back(nums[n-1]);\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums)\\n    {\\n        sort(nums.begin(),nums.end());\\n        vector<int>ans;\\n         int current=1;\\n        int n=nums.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]==nums[i-1])\\n            {\\n               current++;\\n            }\\n         else  if(nums[i]!=nums[i-1])\\n            {\\n                if(current>n/3)\\n                    ans.push_back(nums[i-1]);\\n             current=1;\\n            }\\n        }\\n        if(current>n/3)\\n            ans.push_back(nums[n-1]);\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1670573,
                "title": "3-solutions-from-brute-to-best",
                "content": "\\nSolution 1: Brute-Force\\n\\nApproach: Simply count the no. of appearance for each element using nested loops and whenever you find the count of an element greater than N/3 times, that element will be your answer.\\n\\nCode:\\n```\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\nvector < int > majorityElement(int arr[], int n) {\\n  vector < int > ans;\\n  for (int i = 0; i < n; i++) {\\n    int cnt = 1;\\n    for (int j = i + 1; j < n; j++) {\\n      if (arr[j] == arr[i])\\n        cnt++;\\n    }\\n\\n    if (cnt > (n / 3)) \\n      ans.push_back(arr[i]);\\n  }\\n\\n  return ans;\\n}\\n\\nint main() {\\n  int arr[] = {1,2,2,3,2};\\n  vector<int> majority;\\n  majority = majorityElement(arr, 5);\\n  cout << \"The majority element is\" << endl;\\n  set < int > s(majority.begin(), majority.end());\\n  for (auto it: s) {\\n    cout << it << \" \";\\n  }\\n}\\n```\\nOutput:\\n\\nThe majority element is 2\\n\\nTime Complexity: O(n^2)\\n\\nSpace Complexity: O(1)\\n\\nSolution 2: Better Solution\\n\\nApproach: Traverse the whole array and store the count of every element in a map. After that traverse through the map and whenever you find the count of an element greater than N/3 times, store that element in your answer.\\n\\nDry Run: Lets take the example of arr[] = {10,20,40,40,40}, n=5.\\n\\nFirst, we create an unordered map to store the count of each element.\\n\\nNow traverse through the array \\n\\nFound 10 at  index 0, increase the value of key 10 in  the map by 1.\\nFound 20 at  index 1, increase the value of key 20 in  the map by 1.\\nFound 40 at  index 2, increase the value of key 40 in  the map by 1.\\nFound 40 at index 3, increase the value of key 40 in  the map by 1.\\nFound 40 at  index 4, increase the value of key 40 in the map by 1.\\nNow, Our map will look like this: \\n\\n10 -> 1 \\n\\n20 ->1\\n\\n40 ->3\\n\\nNow traverse through the map, \\n\\nWe found that the value of key 40 is greater than 2 (N/3). So, 40 is the answer.\\n\\nCode:\\n```\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\nvector < int > majorityElement(int arr[], int n) {\\n  unordered_map < int, int > mp;\\n  vector < int > ans;\\n\\n  for (int i = 0; i < n; i++) {\\n    mp[arr[i]]++;\\n  }\\n\\n  for (auto x: mp) {\\n    if (x.second > (n / 3))\\n      ans.push_back(x.first);\\n  }\\n\\n  return ans;\\n}\\n\\nint main() {\\n  int arr[] = {1,2,2,3,2};\\n  vector < int > majority;\\n  majority = majorityElement(arr, 5);\\n  cout << \"The majority element is \" << ;\\n\\n  for (auto it: majority) {\\n    cout << it << \" \";\\n  }\\n}\\n```\\nOutput: The majority element is: 2\\n\\nTime Complexity: O(n)\\n\\nSpace Complexity: O(n)\\n\\nSolution 3: Optimal Solution (Extended Boyer Moore\\u2019s Voting Algorithm)\\n\\nApproach + Intuition: In our code, we start with declaring a few variables:\\n\\nnum1 and num2 will store our currently most frequent and second most frequent element.\\nc1 and c2 will store their frequency relatively to other numbers.\\nWe are sure that there will be a max of 2 elements which occurs > N/3 times because there cannot be if you do a simple math addition.\\nLet, ele be the element present in the array at any index. \\n\\nif ele == num1, so we increment c1.\\nif ele == num2, so we increment c2.\\nif c1 is 0, so we assign num1 = ele.\\nif c2 is 0, so we assign num2 = ele.\\nIn all the other cases we decrease both c1 and c2.\\nIn the last step, we will run a loop to check if num1 or nums2 are the majority elements or not by running a for loop check.\\n\\nIntuition: Since it\\u2019s guaranteed that a number can be a majority element, hence it will always be present at the last block, hence, in turn, will be on nums1 and nums2. For a more detailed explanation, please watch the video below.\\n\\nCode:\\n```\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\nvector < int > majorityElement(int nums[], int n) {\\n  int sz = n;\\n  int num1 = -1, num2 = -1, count1 = 0, count2 = 0, i;\\n  for (i = 0; i < sz; i++) {\\n    if (nums[i] == num1)\\n      count1++;\\n    else if (nums[i] == num2)\\n      count2++;\\n    else if (count1 == 0) {\\n      num1 = nums[i];\\n      count1 = 1;\\n    } else if (count2 == 0) {\\n      num2 = nums[i];\\n      count2 = 1;\\n    } else {\\n      count1--;\\n      count2--;\\n    }\\n  }\\n  vector < int > ans;\\n  count1 = count2 = 0;\\n  for (i = 0; i < sz; i++) {\\n    if (nums[i] == num1)\\n      count1++;\\n    else if (nums[i] == num2)\\n      count2++;\\n  }\\n  if (count1 > sz / 3)\\n    ans.push_back(num1);\\n  if (count2 > sz / 3)\\n    ans.push_back(num2);\\n  return ans;\\n}\\n\\nint main() {\\n  int arr[] = {1,2,2,3,2};\\n  vector < int > majority;\\n  majority = majorityElement(arr, 5);\\n  cout << \"The majority element is \";\\n\\n  for (auto it: majority) {\\n    cout << it << \" \";\\n  }\\n}\\n```\\nOutput:\\n\\nThe majority element is 2\\n\\nTime Complexity: O(n)\\n\\nSpace Complexity: O(1)\\n\\nSpecial thanks to Utkarsh Shrivastava for contributing to this article on takeUforward. \\nall credit goes to take u forward , im just want to share this article to needy",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\nvector < int > majorityElement(int arr[], int n) {\\n  vector < int > ans;\\n  for (int i = 0; i < n; i++) {\\n    int cnt = 1;\\n    for (int j = i + 1; j < n; j++) {\\n      if (arr[j] == arr[i])\\n        cnt++;\\n    }\\n\\n    if (cnt > (n / 3)) \\n      ans.push_back(arr[i]);\\n  }\\n\\n  return ans;\\n}\\n\\nint main() {\\n  int arr[] = {1,2,2,3,2};\\n  vector<int> majority;\\n  majority = majorityElement(arr, 5);\\n  cout << \"The majority element is\" << endl;\\n  set < int > s(majority.begin(), majority.end());\\n  for (auto it: s) {\\n    cout << it << \" \";\\n  }\\n}\\n```\n```\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\nvector < int > majorityElement(int arr[], int n) {\\n  unordered_map < int, int > mp;\\n  vector < int > ans;\\n\\n  for (int i = 0; i < n; i++) {\\n    mp[arr[i]]++;\\n  }\\n\\n  for (auto x: mp) {\\n    if (x.second > (n / 3))\\n      ans.push_back(x.first);\\n  }\\n\\n  return ans;\\n}\\n\\nint main() {\\n  int arr[] = {1,2,2,3,2};\\n  vector < int > majority;\\n  majority = majorityElement(arr, 5);\\n  cout << \"The majority element is \" << ;\\n\\n  for (auto it: majority) {\\n    cout << it << \" \";\\n  }\\n}\\n```\n```\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\nvector < int > majorityElement(int nums[], int n) {\\n  int sz = n;\\n  int num1 = -1, num2 = -1, count1 = 0, count2 = 0, i;\\n  for (i = 0; i < sz; i++) {\\n    if (nums[i] == num1)\\n      count1++;\\n    else if (nums[i] == num2)\\n      count2++;\\n    else if (count1 == 0) {\\n      num1 = nums[i];\\n      count1 = 1;\\n    } else if (count2 == 0) {\\n      num2 = nums[i];\\n      count2 = 1;\\n    } else {\\n      count1--;\\n      count2--;\\n    }\\n  }\\n  vector < int > ans;\\n  count1 = count2 = 0;\\n  for (i = 0; i < sz; i++) {\\n    if (nums[i] == num1)\\n      count1++;\\n    else if (nums[i] == num2)\\n      count2++;\\n  }\\n  if (count1 > sz / 3)\\n    ans.push_back(num1);\\n  if (count2 > sz / 3)\\n    ans.push_back(num2);\\n  return ans;\\n}\\n\\nint main() {\\n  int arr[] = {1,2,2,3,2};\\n  vector < int > majority;\\n  majority = majorityElement(arr, 5);\\n  cout << \"The majority element is \";\\n\\n  for (auto it: majority) {\\n    cout << it << \" \";\\n  }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1542304,
                "title": "java-easy-solution-using-hashmap",
                "content": "class Solution {\\n\\n\\n    public List<Integer> majorityElement(int[] nums) {\\n        ArrayList<Integer> list =new ArrayList<>();\\n        HashMap<Integer,Integer>hm=new HashMap<>();\\n        for(int val:nums){\\n            if(hm.containsKey(val)){\\n                int freq=hm.get(val);\\n                freq++;\\n                hm.put(val,freq);\\n            }\\n            else{\\n                hm.put(val,1);\\n            }\\n        }\\n      \\n         for(Integer i:hm.keySet()){\\n            if((nums.length/3)<hm.get(i)){\\n                list.add(i);\\n            }\\n        }\\n        return list;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n\\n    public List<Integer> majorityElement(int[] nums) {\\n        ArrayList<Integer> list =new ArrayList<>();\\n        HashMap<Integer,Integer>hm=new HashMap<>();\\n        for(int val:nums){\\n            if(hm.containsKey(val)){\\n                int freq=hm.get(val);\\n                freq++;\\n                hm.put(val,freq);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1427917,
                "title": "c-easy-0ms-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int e1 =-1, e2=-1, cnt1=0, cnt2=0;\\n        int n = nums.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(e1 == nums[i])\\n                cnt1++;\\n            else if (e2 == nums[i])\\n                cnt2++;\\n            else if(cnt1==0)\\n            {\\n                e1 =nums[i];\\n                cnt1=1;\\n            }\\n            else if(cnt2==0)\\n            {\\n                e2 = nums[i];\\n                cnt2=1;\\n            }\\n            else\\n            {\\n                cnt1--;\\n                cnt2--;\\n            }\\n        }\\n        \\n        vector <int> ans();\\n        int c1=0 , c2=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i] == e1)\\n                c1++;\\n            else if(nums[i] == e2)\\n                c2++;\\n        }\\n        \\n        if(c1 > (n/3))\\n            ans.push_back(e1);\\n        if(c2 > (n/3))\\n            ans.push_back(e2);\\n        return ans;\\n        \\n        \\n    }\\n};\\n```\\n\\nThis is Using the Boyer Moore Voting Algorithm.\\nThere can be at Max only 2 majority element when the condition is n/3.\\nSo this Algorithm Keeps track of 2 Elements at Max and will also return a null vector when there isn\\'t any Majority Element",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int e1 =-1, e2=-1, cnt1=0, cnt2=0;\\n        int n = nums.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(e1 == nums[i])\\n                cnt1++;\\n            else if (e2 == nums[i])\\n                cnt2++;\\n            else if(cnt1==0)\\n            {\\n                e1 =nums[i];\\n                cnt1=1;\\n            }\\n            else if(cnt2==0)\\n            {\\n                e2 = nums[i];\\n                cnt2=1;\\n            }\\n            else\\n            {\\n                cnt1--;\\n                cnt2--;\\n            }\\n        }\\n        \\n        vector <int> ans();\\n        int c1=0 , c2=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i] == e1)\\n                c1++;\\n            else if(nums[i] == e2)\\n                c2++;\\n        }\\n        \\n        if(c1 > (n/3))\\n            ans.push_back(e1);\\n        if(c2 > (n/3))\\n            ans.push_back(e2);\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1384303,
                "title": "java-hashmap-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        List<Integer> result=new ArrayList<>();\\n        \\n        if(nums.length==1)\\n        {\\n            result.add(nums[0]);\\n            return result;\\n        }\\n            \\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            \\n            if(map.containsKey(nums[i]))\\n            {\\n                map.replace(nums[i],map.get(nums[i])+1);\\n            }\\n            else\\n            {\\n                map.put(nums[i],1);\\n            }\\n        }\\n        for (Integer i : map.keySet())\\n        {\\n            if(map.get(i)>nums.length/3)\\n                result.add(i);\\n        }\\n        \\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        List<Integer> result=new ArrayList<>();\\n        \\n        if(nums.length==1)\\n        {\\n            result.add(nums[0]);\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1376105,
                "title": "generalized-boyer-moore-for-n-k",
                "content": "```\\nclass Solution {\\n    /** \\n    Using modified Boyer-moore Algorithm\\n    For n/k, array can have atmost k-1 majority elements.  So using map instead of two variables to generalize solution.\\n    There are only 2 possibilities:\\n    case 1: if new element is already in candidates then increase the count of the candidate.\\n    case 2: if not then \\n        2a: if any candidate has 0 votes then remove that candidate and make curr a new candidate.\\n        2b: Otherwise reduce the votes of all candidates by 1;\\n    **/\\n    public List<Integer> majorityElement(int[] nums) {\\n        int length = nums.length, k=3, minFrequency = (length/k)+1;\\n        List<Integer> result = new ArrayList<>();\\n        \\n        // This map stores candidates and their votes.\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i=0;i<length;i++){\\n            int curr = nums[i];\\n            \\n            if(map.containsKey(curr)){\\n                map.put(curr, map.get(curr)+1);\\n            } else{\\n                if(map.size()<=k-1)   map.put(curr,1);\\n                else{\\n                    // if any candidate has 0 votes?\\n                    int candidateKey=-1;\\n                    for(Integer candidate : map.keySet()){\\n                        int votes = map.get(candidate);\\n                        if(votes==0){\\n                            candidateKey = candidate;\\n                            break;\\n                        }\\n                    }\\n                    // if there\\'s a candidate with 0 votes then remove that candidate and add curr as a new candidate;\\n                    if(candidateKey!=-1){\\n                        map.remove(candidateKey);\\n                        map.put(curr,1);\\n                    } else{ //no candidate with 0 votes so reduce votes of all candidates by 1, since the curr is not voting anyone.\\n                        for(Integer candidate : map.keySet()){\\n                            int votes = map.get(candidate);\\n                            map.put(candidate, votes-1);\\n                        } \\n                    }\\n                }\\n            }\\n        } \\n        // Now check if any of the candidates have majority votes, if so add to the result.\\n        for(Integer candidate : map.keySet()){\\n            int votes = map.get(candidate);\\n            if(votes>0){\\n                votes =0;\\n                for(int i=0;i<length;i++){\\n                    if(nums[i]==candidate)  votes++;\\n                }\\n            }\\n            if(votes>=minFrequency) result.add(candidate);\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    /** \\n    Using modified Boyer-moore Algorithm\\n    For n/k, array can have atmost k-1 majority elements.  So using map instead of two variables to generalize solution.\\n    There are only 2 possibilities:\\n    case 1: if new element is already in candidates then increase the count of the candidate.\\n    case 2: if not then \\n        2a: if any candidate has 0 votes then remove that candidate and make curr a new candidate.\\n        2b: Otherwise reduce the votes of all candidates by 1;\\n    **/\\n    public List<Integer> majorityElement(int[] nums) {\\n        int length = nums.length, k=3, minFrequency = (length/k)+1;\\n        List<Integer> result = new ArrayList<>();\\n        \\n        // This map stores candidates and their votes.\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i=0;i<length;i++){\\n            int curr = nums[i];\\n            \\n            if(map.containsKey(curr)){\\n                map.put(curr, map.get(curr)+1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1270746,
                "title": "c-boyer-moore-algorithm-easy",
                "content": "```\\n vector<int> majorityElement(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        int count1 = 0, count2 = 0;\\n        int first = INT_MAX, second = INT_MAX;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(first == nums[i])\\n                count1++;\\n            else if(second == nums[i])\\n                count2++;\\n            else if(count1 == 0)\\n            {\\n                first = nums[i];\\n                count1++;\\n            }\\n            else if(count2 == 0)\\n            {\\n                second = nums[i];\\n                count2++;\\n            }\\n            else\\n            {\\n                count1--;\\n                count2--;\\n            }\\n        }\\n        \\n        count1 = 0, count2 = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] == first)\\n                count1++;\\n            else if(nums[i] == second)\\n                count2++;\\n        }\\n        \\n        \\n        vector<int> res;\\n        if(count1 > n/3)\\n            res.push_back(first);\\n        if(count2 > n/3)\\n            res.push_back(second);\\n        \\n        return res;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n vector<int> majorityElement(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        int count1 = 0, count2 = 0;\\n        int first = INT_MAX, second = INT_MAX;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(first == nums[i])\\n                count1++;\\n            else if(second == nums[i])\\n                count2++;\\n            else if(count1 == 0)\\n            {\\n                first = nums[i];\\n                count1++;\\n            }\\n            else if(count2 == 0)\\n            {\\n                second = nums[i];\\n                count2++;\\n            }\\n            else\\n            {\\n                count1--;\\n                count2--;\\n            }\\n        }\\n        \\n        count1 = 0, count2 = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] == first)\\n                count1++;\\n            else if(nums[i] == second)\\n                count2++;\\n        }\\n        \\n        \\n        vector<int> res;\\n        if(count1 > n/3)\\n            res.push_back(first);\\n        if(count2 > n/3)\\n            res.push_back(second);\\n        \\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1184192,
                "title": "easy-to-understand-cpp-solution-tc-o-n-sc-o-1",
                "content": "```\\n#define pb push_back\\n\\nclass Solution {\\npublic:\\n\\tvector<int> majorityElement(vector<int>& nums) {\\n\\t\\tint n = nums.size();\\n\\t\\tlong long elem1=1e10, elem2=1e10;\\n\\t\\tint cnt1 = 0, cnt2 = 0;\\n\\t\\tfor (auto x : nums) {\\n\\t\\t\\tif (elem1 == x)\\n\\t\\t\\t\\tcnt1++;\\n\\t\\t\\telse if (elem2 == x)\\n\\t\\t\\t\\tcnt2++;\\n\\t\\t\\telse if (cnt1 == 0)\\n\\t\\t\\t\\telem1 = x, cnt1 = 1;\\n\\t\\t\\telse if (cnt2 == 0)\\n\\t\\t\\t\\telem2 = x, cnt2 = 1;\\n\\t\\t\\telse\\n\\t\\t\\t\\tcnt1--, cnt2--;\\n\\t\\t}\\n\\t\\tvector <int> ans;\\n\\t\\tint cnt_elem1 = 0, cnt_elem2 = 0;\\n\\t\\tfor (auto x : nums) {\\n\\t\\t\\tif (x == elem1)\\n\\t\\t\\t\\tcnt_elem1++;\\n\\t\\t\\tif (x == elem2)\\n\\t\\t\\t\\tcnt_elem2++;\\n\\t\\t}\\n\\t\\tif (cnt_elem1 > n / 3)\\n\\t\\t\\tans.pb(elem1);\\n\\t\\tif (cnt_elem2 > n / 3)\\n\\t\\t\\tans.pb(elem2);\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define pb push_back\\n\\nclass Solution {\\npublic:\\n\\tvector<int> majorityElement(vector<int>& nums) {\\n\\t\\tint n = nums.size();\\n\\t\\tlong long elem1=1e10, elem2=1e10;\\n\\t\\tint cnt1 = 0, cnt2 = 0;\\n\\t\\tfor (auto x : nums) {\\n\\t\\t\\tif (elem1 == x)\\n\\t\\t\\t\\tcnt1++;\\n\\t\\t\\telse if (elem2 == x)\\n\\t\\t\\t\\tcnt2++;\\n\\t\\t\\telse if (cnt1 == 0)\\n\\t\\t\\t\\telem1 = x, cnt1 = 1;\\n\\t\\t\\telse if (cnt2 == 0)\\n\\t\\t\\t\\telem2 = x, cnt2 = 1;\\n\\t\\t\\telse\\n\\t\\t\\t\\tcnt1--, cnt2--;\\n\\t\\t}\\n\\t\\tvector <int> ans;\\n\\t\\tint cnt_elem1 = 0, cnt_elem2 = 0;\\n\\t\\tfor (auto x : nums) {\\n\\t\\t\\tif (x == elem1)\\n\\t\\t\\t\\tcnt_elem1++;\\n\\t\\t\\tif (x == elem2)\\n\\t\\t\\t\\tcnt_elem2++;\\n\\t\\t}\\n\\t\\tif (cnt_elem1 > n / 3)\\n\\t\\t\\tans.pb(elem1);\\n\\t\\tif (cnt_elem2 > n / 3)\\n\\t\\t\\tans.pb(elem2);\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1073253,
                "title": "majority-element-ii-in-javascript-97",
                "content": "```\\nvar majorityElement2 = function(nums) {\\n    const memo = {}\\n    for (let i = 0; i < nums.length; i++) {\\n      if (!memo[nums[i]]) memo[nums[i]] = 0\\n      memo[nums[i]]++\\n    }\\n    const ret = []\\n    for (const m in memo) {\\n      if (memo[m] > nums.length / 3) ret.push(parseInt(m))\\n    }\\n    return ret\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar majorityElement2 = function(nums) {\\n    const memo = {}\\n    for (let i = 0; i < nums.length; i++) {\\n      if (!memo[nums[i]]) memo[nums[i]] = 0\\n      memo[nums[i]]++\\n    }\\n    const ret = []\\n    for (const m in memo) {\\n      if (memo[m] > nums.length / 3) ret.push(parseInt(m))\\n    }\\n    return ret\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 916791,
                "title": "python3-moore-s-voting-o-n",
                "content": "```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        cand1 = None\\n        cand2 = None\\n        count1 = 0\\n        count2 = 0\\n        for num in nums:\\n            if num == cand1:\\n                count1 += 1\\n            elif num == cand2:\\n                count2 += 1\\n            elif count1 == 0:\\n                cand1 = num\\n                count1 += 1\\n            elif count2 == 0:\\n                cand2 = num\\n                count2 += 1\\n            else:\\n                count1 -= 1\\n                count2 -= 1\\n        count1 = 0\\n        count2 = 0\\n        for num in nums:\\n            if num == cand1:\\n                count1 += 1\\n            elif num == cand2:\\n                count2 += 1\\n        ans = []\\n        if count1 > len(nums)/3:\\n            ans.append(cand1)\\n        if count2 > len(nums)/3:\\n            ans.append(cand2)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        cand1 = None\\n        cand2 = None\\n        count1 = 0\\n        count2 = 0\\n        for num in nums:\\n            if num == cand1:\\n                count1 += 1\\n            elif num == cand2:\\n                count2 += 1\\n            elif count1 == 0:\\n                cand1 = num\\n                count1 += 1\\n            elif count2 == 0:\\n                cand2 = num\\n                count2 += 1\\n            else:\\n                count1 -= 1\\n                count2 -= 1\\n        count1 = 0\\n        count2 = 0\\n        for num in nums:\\n            if num == cand1:\\n                count1 += 1\\n            elif num == cand2:\\n                count2 += 1\\n        ans = []\\n        if count1 > len(nums)/3:\\n            ans.append(cand1)\\n        if count2 > len(nums)/3:\\n            ans.append(cand2)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 865129,
                "title": "using-moore-s-voting-o-n",
                "content": "```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        int cand1 = 0, cand2 = 0, count1 = 0, count2 = 0;\\n        for(int x : nums){\\n            if(x == cand1){\\n                count1++;\\n            }\\n            else if(x == cand2){\\n                count2++;\\n            }\\n            else if(count1 == 0){\\n                cand1 = x;\\n                count1++;\\n            }\\n            else if(count2 == 0){\\n                cand2 = x;\\n                count2++;\\n            }\\n            else{\\n                count1--;\\n                count2--;\\n            }\\n        }\\n        \\n        int k = nums.length/3;\\n        int c1 = 0, c2 = 0;\\n        for(int x : nums){\\n            if(x == cand1) c1++;\\n            else if(x == cand2) c2++;\\n        }\\n        List<Integer> list = new ArrayList<>();\\n        if(c1 > k) list.add(cand1);\\n        if(c2 > k) list.add(cand2);\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        int cand1 = 0, cand2 = 0, count1 = 0, count2 = 0;\\n        for(int x : nums){\\n            if(x == cand1){\\n                count1++;\\n            }\\n            else if(x == cand2){\\n                count2++;\\n            }\\n            else if(count1 == 0){\\n                cand1 = x;\\n                count1++;\\n            }\\n            else if(count2 == 0){\\n                cand2 = x;\\n                count2++;\\n            }\\n            else{\\n                count1--;\\n                count2--;\\n            }\\n        }\\n        \\n        int k = nums.length/3;\\n        int c1 = 0, c2 = 0;\\n        for(int x : nums){\\n            if(x == cand1) c1++;\\n            else if(x == cand2) c2++;\\n        }\\n        List<Integer> list = new ArrayList<>();\\n        if(c1 > k) list.add(cand1);\\n        if(c2 > k) list.add(cand2);\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 744696,
                "title": "java-easy-boyer-moore-voting-algorithm",
                "content": "```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        \\n        int N = nums.length;\\n        \\n        int count1 = 0,count2 = 0, cand1 = -1, cand2 =-1;\\n        \\n        for(int i : nums){\\n            \\n            if(cand1 == i){\\n                count1++;\\n            }else if(cand2 == i){\\n                count2++;\\n            }else if(count1 == 0){\\n                cand1 = i;\\n                count1 = 1;\\n            }else if(count2 == 0){\\n                cand2 = i;\\n                count2 = 1;\\n            }else{\\n                count1--;\\n                count2--;\\n            }\\n        \\n        }\\n        \\n        count1 = count2 = 0;\\n        \\n        for(int i : nums){\\n            if(cand1 == i)count1++;\\n            if(cand2 == i)count2++;\\n        }\\n      \\n        if(count1 > N/3){\\n            ans.add(cand1);\\n        }\\n        if(count2 > N/3){\\n            ans.add(cand2);\\n        }\\n        \\n      return ans;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        \\n        int N = nums.length;\\n        \\n        int count1 = 0,count2 = 0, cand1 = -1, cand2 =-1;\\n        \\n        for(int i : nums){\\n            \\n            if(cand1 == i){\\n                count1++;\\n            }else if(cand2 == i){\\n                count2++;\\n            }else if(count1 == 0){\\n                cand1 = i;\\n                count1 = 1;\\n            }else if(count2 == 0){\\n                cand2 = i;\\n                count2 = 1;\\n            }else{\\n                count1--;\\n                count2--;\\n            }\\n        \\n        }\\n        \\n        count1 = count2 = 0;\\n        \\n        for(int i : nums){\\n            if(cand1 == i)count1++;\\n            if(cand2 == i)count2++;\\n        }\\n      \\n        if(count1 > N/3){\\n            ans.add(cand1);\\n        }\\n        if(count2 > N/3){\\n            ans.add(cand2);\\n        }\\n        \\n      return ans;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688965,
                "title": "java-o-1-space-and-o-n-time-solution-with-comments",
                "content": "To solve this in linear time and O(1) we will have to use Boyer Moore Voting algorithm. We will modify the algorithm to find two candidates. Since it is not possible to have more than 2 candidate elements that appear (n/3 + 1) times (because for 3 such elements 3*(n/3 + 1) = n + 3) we will have two variables to track our candidates.\\n\\nValidation is required because in case where there are no such elements the algorithm can return any random element.\\n```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        // https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\\n        // Since there can be at max two elements with atleast n/3 + 1 appearence\\n        // we will use Bayer Moore Voting algo to track two elements and verify them\\n        // at the end with a second pass\\n        \\n        \\n        int candidate1 = 0;\\n        int candidate2 = 0;\\n        int count1 = 0;\\n        int count2 = 0;\\n        \\n        for(int num : nums){\\n            if(num == candidate1){ // if our current candidate1 is found again then increase it\\'s count\\n                count1++;\\n            }else if(num == candidate2){ // if our current candidate2 is found again then increase it\\'s count\\n                count2++;\\n            }else if(count1 == 0){ // if our count1 is 0 it means we do not have a candidate1 so we start agains with current element\\n                candidate1 = num;\\n                count1++;\\n            }else if(count2 == 0){ // if our count2 is 0 it means we do not have a candidate2 so we start agains with current element\\n                candidate2 = num;\\n                count2++;\\n            }else{ // if our count1 and count2 is not 0 and the current element is neither equal to candidate1 or candidate2 we decrease counter of both candidates\\n                count1--;\\n                count2--;\\n            }\\n        }\\n        // If a solution does not exist then it is possible that Boyer Moore algo\\n        // returned just a random element so we have to verify our candidates\\n        // Now let\\'s verify the two candidates are found atleast n/3 + 1 times\\n        count1 = 0;\\n        count2 = 0;\\n        for(int num : nums){\\n            if(num == candidate1){\\n                count1++;\\n            }else if(num == candidate2){\\n                count2++;\\n            }\\n        }\\n        \\n        List<Integer> result = new ArrayList<>();\\n        if(count1 > nums.length/3){\\n            result.add(candidate1);\\n        }\\n        \\n        if(count2 > nums.length/3){\\n            result.add(candidate2);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        // https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\\n        // Since there can be at max two elements with atleast n/3 + 1 appearence\\n        // we will use Bayer Moore Voting algo to track two elements and verify them\\n        // at the end with a second pass\\n        \\n        \\n        int candidate1 = 0;\\n        int candidate2 = 0;\\n        int count1 = 0;\\n        int count2 = 0;\\n        \\n        for(int num : nums){\\n            if(num == candidate1){ // if our current candidate1 is found again then increase it\\'s count\\n                count1++;\\n            }else if(num == candidate2){ // if our current candidate2 is found again then increase it\\'s count\\n                count2++;\\n            }else if(count1 == 0){ // if our count1 is 0 it means we do not have a candidate1 so we start agains with current element\\n                candidate1 = num;\\n                count1++;\\n            }else if(count2 == 0){ // if our count2 is 0 it means we do not have a candidate2 so we start agains with current element\\n                candidate2 = num;\\n                count2++;\\n            }else{ // if our count1 and count2 is not 0 and the current element is neither equal to candidate1 or candidate2 we decrease counter of both candidates\\n                count1--;\\n                count2--;\\n            }\\n        }\\n        // If a solution does not exist then it is possible that Boyer Moore algo\\n        // returned just a random element so we have to verify our candidates\\n        // Now let\\'s verify the two candidates are found atleast n/3 + 1 times\\n        count1 = 0;\\n        count2 = 0;\\n        for(int num : nums){\\n            if(num == candidate1){\\n                count1++;\\n            }else if(num == candidate2){\\n                count2++;\\n            }\\n        }\\n        \\n        List<Integer> result = new ArrayList<>();\\n        if(count1 > nums.length/3){\\n            result.add(candidate1);\\n        }\\n        \\n        if(count2 > nums.length/3){\\n            result.add(candidate2);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354184,
                "title": "python3-o-n-space-and-o-n-time",
                "content": "**Method 1: Count**\\n```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        count = collections.Counter(nums)\\n        res = []\\n        for i,f in count.items():\\n            if f > len(nums)/3:\\n                res.append(i)\\n        return res\\n```\\n*Complexity analysis*\\n* Time complexity: O(n)\\n\\twhere n is the length of the input nums.\\n* Space complexity:O(n)\\n\\twhere n is the length of the input nums. The algorithm needs a dictionary to store the numbers as key and the frequency of the number as value. In the worst case, it will require a dictionary which it\\'s length is n.\\n\\t\\n**Method 2: Majority vote**\\n* \\tthere is at most two element in an array A[] of size n that appears more than n/3 times",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        count = collections.Counter(nums)\\n        res = []\\n        for i,f in count.items():\\n            if f > len(nums)/3:\\n                res.append(i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 353938,
                "title": "majority-vote-python-o-1-space-o-n-time",
                "content": "The idea is first to loop over `nums` to identify the most populart two elements using O(N) time, and then loop over the array again to check if the majority element is the right one we are looking for with condition of `count>len(nums)/3`.\\n```\\ndef majorityElement(self, nums: List[int]) -> List[int]:\\n        \\n        # majority voting \\n        ele1, ele2 = 0, 0\\n        cnt1, cnt2 = 0, 0 \\n        n = len(nums)\\n        # using majority vote to find two most popular elements \\n        for num in nums:\\n            if ele1 == num:\\n                cnt1 +=1\\n            elif ele2==num:\\n                cnt2 +=1\\n            elif cnt1==0:\\n                ele1 = num\\n                cnt1=1\\n            elif cnt2 ==0:\\n                ele2 =num\\n                cnt2=1\\n            else:\\n                cnt1-=1\\n                cnt2-=1\\n        \\n        cnt1, cnt2 = 0, 0\\n        for num in nums:\\n            if num==ele1:\\n                cnt1+=1\\n            elif num==ele2:\\n                cnt2+=1\\n                \\n        out = []\\n        if cnt1>n//3:\\n            out.append(ele1)\\n        if cnt2>n//3:\\n            out.append(ele2)\\n        return out \\n```",
                "solutionTags": [],
                "code": "```\\ndef majorityElement(self, nums: List[int]) -> List[int]:\\n        \\n        # majority voting \\n        ele1, ele2 = 0, 0\\n        cnt1, cnt2 = 0, 0 \\n        n = len(nums)\\n        # using majority vote to find two most popular elements \\n        for num in nums:\\n            if ele1 == num:\\n                cnt1 +=1\\n            elif ele2==num:\\n                cnt2 +=1\\n            elif cnt1==0:\\n                ele1 = num\\n                cnt1=1\\n            elif cnt2 ==0:\\n                ele2 =num\\n                cnt2=1\\n            else:\\n                cnt1-=1\\n                cnt2-=1\\n        \\n        cnt1, cnt2 = 0, 0\\n        for num in nums:\\n            if num==ele1:\\n                cnt1+=1\\n            elif num==ele2:\\n                cnt2+=1\\n                \\n        out = []\\n        if cnt1>n//3:\\n            out.append(ele1)\\n        if cnt2>n//3:\\n            out.append(ele2)\\n        return out \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 347471,
                "title": "boyer-moore-generalization-mathematical-explanation-and-c-implementation",
                "content": "This is meant to help understand the generalization of the Boyer-Moore majority vote algorithm that many have come up with and used for this problem. Boyer-Moore generalization is much like the original algorithm, except we keep **k - 1** counts instead of 1 (**k** = 3 for this particular problem).\\n\\nEssentially, we are tracking up to **k** - 1 numbers, keeping their value and count. For each element in the array, we do the following:\\n\\n1. If the element matches one of the tracked numbers, increase the corresponding count.\\n2.  If it doesn\\'t match any of the numbers, but we are still tracking less than **k** - 1 numbers, start tracking the number (giving it a count of 1).\\n3.  If it doesn\\'t match any of the numbers and we are already tracking **k** - 1 numbers, substract 1 from the count of each tracked number. If a count reaches 0, we stop tracking the corresponding number.\\n\\nOnce we are done, any number **N** that exists more than \\u230A**n** / **k**\\u230B times in the array is **guaranteed** to be in the tracked numbers. Why? Let\\'s try a mathematical explanation. First, some definitions:\\n\\n- **Nfc**: final count of **N** (if **N** is not tracked, consider it to be zero).\\n- **Ni**: number of times the counter for **N** is increased (cases 1 and 2).\\n- **Nd**: number of times encountering **N** decreases the other counters (case 3).\\n- **Oi**: number of times any other number increases its counter (cases 1 and 2).\\n- **Od**: number of times any other number decreases all counters (case 3).\\n\\nWe would like to guarantee **Nfc** > 0. First, consider that:\\n\\n1. **Nfc** \\u2265 **Ni** - **Od**, since any decreases to **N** are counted by **Od** (although not all decreases counted by **Od** affect **N**)\\n2. **Ni** + **Nd** + **Oi** + **Od** = **n**, because **n** is the total amount of elements in the array.\\n3. **Ni** + **Oi** - (**k** - 1) \\\\* **Nd** - (**k** - 1) \\\\* **Od** \\u2265 0, because the left hand side of that equation will be sum of all counts at the end, and the counts can never fall below zero.\\n4. **Ni** + **Nd** > \\u230A**n** / **k**\\u230B, the initial assumption. \\n\\nIntuitively, we know there can only be so many decreases, since there must be **k - 1** increases for every decrease (this is partly described by equation 3). Combining equations 2 and 3 results in **n** / **k** \\u2265 **Nd** + **Od**. Because **Nd** and **Od** are integer values, this is equivalent to \\u230A**n** / **k**\\u230B \\u2265 **Nd** + **Od**.\\n\\nSo, we\\'ve got:\\n\\n5. **Ni** + **Nd** > \\u230A**n** / **k**\\u230B \\u2265 **Nd** + **Od**. From here, it\\'s straightforward to get that...\\n6. (**Ni** + **Nd**) - (**Nd** + **Od**) > 0, and so...\\n7.  **Ni** - **Od** > 0, which, considering equation 1, means that...\\n8.  **Nfc** > 0\\n\\nAnd that\\'s how we prove that **N** must have a positive count and therefore must end up being tracked by the algorithm.\\n\\nThis does **not** imply the inverse, that *all* numbers that end up being tracked exist more than \\u230A**n** / **k**\\u230B times in the array. Therefore, we then need to see which of the tracked numbers really *are* \"majorities\" by counting their occurrences in the array.\\n\\nHere\\'s a generalized C++ implementation for the problem:\\n\\n```cpp\\nconst int k = 3;\\n\\nvector<int> majorityElement(vector<int>& nums) {\\n    \\n    // Map of number value to count.\\n    // For k = 3, it can be easier and faster to make separate variables for\\n    // each tracked number.\\n    unordered_map<int, int> tracked;\\n    \\n    for (int num : nums) {\\n        // If it is already being tracked, increase the count.\\n        auto tracked_it = tracked.find(num);\\n        if (tracked_it != tracked.end()) {\\n            ++tracked_it->second;\\n        }\\n        // If it is not being tracked, and we are tracking less than k - 1\\n        // numbers, start tracking it.\\n        else if (tracked.size() < k - 1) {\\n            tracked[num] = 1;\\n        }\\n        // If it is not being tracked, and we are tracking all k - 1\\n        // numbers, decrease the count for each number and stop tracking\\n        // those that reach a count of zero.\\n        else {\\n            tracked_it = tracked.begin();\\n            while (tracked_it != tracked.end()) {\\n                if (--tracked_it->second == 0) tracked.erase(tracked_it++);\\n                else ++tracked_it;\\n            }\\n        }\\n    }\\n    \\n    vector<int> majorities;\\n    // For each tracked number, check whether it is really a majority.\\n    for (auto t : tracked) {\\n        // Count the total occurrences in the array.\\n        int count = 0;\\n        for (int num : nums) {\\n            if (num == t.first) ++count;\\n        }\\n        // Is there enough to make it a majority?\\n        if (count > nums.size() / k) majorities.push_back(t.first);\\n    }\\n    return majorities;\\n}\\n```\\n\\nThe time complexity for this implementation is O(**n** \\\\* **k**), and the space complexity is O(**k**).",
                "solutionTags": [],
                "code": "```cpp\\nconst int k = 3;\\n\\nvector<int> majorityElement(vector<int>& nums) {\\n    \\n    // Map of number value to count.\\n    // For k = 3, it can be easier and faster to make separate variables for\\n    // each tracked number.\\n    unordered_map<int, int> tracked;\\n    \\n    for (int num : nums) {\\n        // If it is already being tracked, increase the count.\\n        auto tracked_it = tracked.find(num);\\n        if (tracked_it != tracked.end()) {\\n            ++tracked_it->second;\\n        }\\n        // If it is not being tracked, and we are tracking less than k - 1\\n        // numbers, start tracking it.\\n        else if (tracked.size() < k - 1) {\\n            tracked[num] = 1;\\n        }\\n        // If it is not being tracked, and we are tracking all k - 1\\n        // numbers, decrease the count for each number and stop tracking\\n        // those that reach a count of zero.\\n        else {\\n            tracked_it = tracked.begin();\\n            while (tracked_it != tracked.end()) {\\n                if (--tracked_it->second == 0) tracked.erase(tracked_it++);\\n                else ++tracked_it;\\n            }\\n        }\\n    }\\n    \\n    vector<int> majorities;\\n    // For each tracked number, check whether it is really a majority.\\n    for (auto t : tracked) {\\n        // Count the total occurrences in the array.\\n        int count = 0;\\n        for (int num : nums) {\\n            if (num == t.first) ++count;\\n        }\\n        // Is there enough to make it a majority?\\n        if (count > nums.size() / k) majorities.push_back(t.first);\\n    }\\n    return majorities;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 319155,
                "title": "java-2-ms-t-s-o-n-o-1-boyer-moore-majority-vote-algorithm",
                "content": "https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\\n```\\npublic List<Integer> majorityElement(int[] nums) {\\n\\tint x = 0;\\n\\tint y = 0;\\n\\tint freqX = 0;\\n\\tint freqY = 0;\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\tif (freqX <= 0 && nums[i] != y) \\n\\t\\t\\tx = nums[i];\\n\\t\\tif (freqY <= 0 && nums[i] != x) \\n\\t\\t\\ty = nums[i];\\n\\t\\tfreqX += (nums[i] == x) ? 2 : -1;\\n\\t\\tfreqY += (nums[i] == y) ? 2 : -1;\\n\\t}\\n\\n\\tfreqX = 0;\\n\\tfreqY = 0;\\n\\tfor (int n : nums)\\n\\t\\tif (n == x)\\n\\t\\t\\tfreqX++;\\n\\t\\telse if (n == y)\\n\\t\\t\\tfreqY++;\\n\\n\\tList<Integer> ans = new ArrayList<>();\\n\\tint third = Math.floorDiv(nums.length, 3);\\n\\tif (freqX > third)\\n\\t\\tans.add(x);\\n\\tif (freqY > third)\\n\\t\\tans.add(y);\\n\\treturn ans; \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<Integer> majorityElement(int[] nums) {\\n\\tint x = 0;\\n\\tint y = 0;\\n\\tint freqX = 0;\\n\\tint freqY = 0;\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\tif (freqX <= 0 && nums[i] != y) \\n\\t\\t\\tx = nums[i];\\n\\t\\tif (freqY <= 0 && nums[i] != x) \\n\\t\\t\\ty = nums[i];\\n\\t\\tfreqX += (nums[i] == x) ? 2 : -1;\\n\\t\\tfreqY += (nums[i] == y) ? 2 : -1;\\n\\t}\\n\\n\\tfreqX = 0;\\n\\tfreqY = 0;\\n\\tfor (int n : nums)\\n\\t\\tif (n == x)\\n\\t\\t\\tfreqX++;\\n\\t\\telse if (n == y)\\n\\t\\t\\tfreqY++;\\n\\n\\tList<Integer> ans = new ArrayList<>();\\n\\tint third = Math.floorDiv(nums.length, 3);\\n\\tif (freqX > third)\\n\\t\\tans.add(x);\\n\\tif (freqY > third)\\n\\t\\tans.add(y);\\n\\treturn ans; \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 256299,
                "title": "java-1ms-beating-100",
                "content": "```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        List<Integer> results=new ArrayList<>();\\n        int len=nums.length;\\n        int first=0,second=1;\\n        int count1=0,count2=0;//now we have two candidates(any integer can be chosed as),and their votes are zero.\\n        for(int i=0;i<len;i++){\\n            int temp=nums[i];\\n            if(temp==first)count1++;\\n            else if(temp==second)count2++;//if the number is the one of the candidates,increase the votes.\\n            else if(count1==0){first=temp;count1++;}\\n            else if(count2==0){second=temp;count2++;} otherwise,if one of the vote is zero,that\\'s meaning that \\n\\t\\t\\t//we only have  or even don\\'t have a candidate.So we set the number to the candidate.\\n            else {count1--;count2--;}// where we have two candidates whose votes bigger than zero,\\n\\t\\t\\t//but the current number is not one of them.Votes decrease by 1 and \\n\\t\\t\\t//the current number complete its \"mission\" and  is skipped at the same time.\\n\\t\\t\\t//once the cycle finished,the target is left after all the counteraction,as its count is bigger than n/3.\\n        }\\n        count1=0;\\n        count2=0;\\n        for(int i=0;i<len;i++){//check both of them is bigger than n/3.Becasue we may have only one satisfying the demand.\\n            int temp=nums[i];\\n            if(temp==first)count1++;\\n            if(temp==second)count2++;\\n        }\\n        if(count1>len/3)results.add(first);\\n        if(count2>len/3 )results.add(second);\\n        return results;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        List<Integer> results=new ArrayList<>();\\n        int len=nums.length;\\n        int first=0,second=1;\\n        int count1=0,count2=0;//now we have two candidates(any integer can be chosed as),and their votes are zero.\\n        for(int i=0;i<len;i++){\\n            int temp=nums[i];\\n            if(temp==first)count1++;\\n            else if(temp==second)count2++;//if the number is the one of the candidates,increase the votes.\\n            else if(count1==0){first=temp;count1++;}\\n            else if(count2==0){second=temp;count2++;} otherwise,if one of the vote is zero,that\\'s meaning that \\n\\t\\t\\t//we only have  or even don\\'t have a candidate.So we set the number to the candidate.\\n            else {count1--;count2--;}// where we have two candidates whose votes bigger than zero,\\n\\t\\t\\t//but the current number is not one of them.Votes decrease by 1 and \\n\\t\\t\\t//the current number complete its \"mission\" and  is skipped at the same time.\\n\\t\\t\\t//once the cycle finished,the target is left after all the counteraction,as its count is bigger than n/3.\\n        }\\n        count1=0;\\n        count2=0;\\n        for(int i=0;i<len;i++){//check both of them is bigger than n/3.Becasue we may have only one satisfying the demand.\\n            int temp=nums[i];\\n            if(temp==first)count1++;\\n            if(temp==second)count2++;\\n        }\\n        if(count1>len/3)results.add(first);\\n        if(count2>len/3 )results.add(second);\\n        return results;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 185783,
                "title": "c-solution-in-14-lines-using-nth-element-beats-99",
                "content": "First idea I had was to sort the array, then the elements at n/3 and 2n/3 positions are possible candidates. But it would be O(nlogn). Then I thought I don\\'t really need it to be sorted, partitioning using nth_element() is good enough. It reduces the average complexity to O(n).\\n```\\n    vector<int> majorityElement(vector<int>& nums) {\\n        if (nums.empty()) return vector<int>();\\n        int n = nums.size();\\n\\t\\t\\t\\t// sort(nums.begin(), nums.end());\\n        nth_element(nums.begin(), nums.begin()+n/3, nums.end());\\n        nth_element(nums.begin(), nums.begin()+2*n/3, nums.end());\\n        int cand1 = nums[n/3], cand2 = nums[2*n/3];\\n        int cnt1 = 0, cnt2 = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == cand1) cnt1++;\\n            else if (nums[i] == cand2) cnt2++;\\n        }\\n        vector<int> ans;\\n        if (cnt1 > n/3) ans.push_back(cand1);\\n        if (cnt2 > n/3) ans.push_back(cand2);\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<int> majorityElement(vector<int>& nums) {\\n        if (nums.empty()) return vector<int>();\\n        int n = nums.size();\\n\\t\\t\\t\\t// sort(nums.begin(), nums.end());\\n        nth_element(nums.begin(), nums.begin()+n/3, nums.end());\\n        nth_element(nums.begin(), nums.begin()+2*n/3, nums.end());\\n        int cand1 = nums[n/3], cand2 = nums[2*n/3];\\n        int cnt1 = 0, cnt2 = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == cand1) cnt1++;\\n            else if (nums[i] == cand2) cnt2++;\\n        }\\n        vector<int> ans;\\n        if (cnt1 > n/3) ans.push_back(cand1);\\n        if (cnt2 > n/3) ans.push_back(cand2);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 63540,
                "title": "a-proof-for-the-boyer-moore-majority-vote-algorithm",
                "content": "I wrote the proof for myself. Hope you also find it useful. You might want to read the code first before reading the proof below.\\n\\nSince we scan the array again at the end to count the actual appearances of `candidate1` and `candidate2`, what we need to prove is that if a value is one of the majority values, it must equal either `candidate1` or `candidate2` at the end of the first for loop.\\n\\nLet's take a look at the \"else\" clause of the first for loop. We can consider this step generating a triplet {x, y, z}, where x is the current element of the array that we are processing, y is one of the element with value `candidate1` and z is one of the element with value `candidate2`. Note that we can prove that the values of x, y and z must be different from each other. When the first for loop is completed, it is obvious that every element of the input array is in exactly one of the triplet, except for `count1` of the elements with value `candidate1` and `count2` of the elements with `candidate2`.  These `count1 + count2` elements are not in any triplets.\\n\\nLet's assume that m is a majority value and m equals neither `candidate1` nor `candidate2` when the loop is completed. Let's say value m appears k times in the input array. Thus, k > floor(n/3) by definition, where n is the size of the input array.  Since the three elements of a triplet must have different values, there must be exactly k triplets generated in the above-mentioned \"else\" clause each of which contains an element with value m. Obviously, these m triplets contain totally 3k > n different elements, which contradicts the fact that the input array has only n elements.  Therefore, m must equal `candidate1` or `candidate2` when the loop is completed.\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int candidate1 = 0, count1 = 0;\\n        int candidate2 = 1, count2 = 0;\\n        // First scan.\\n        for (const auto &x : nums) {\\n            if (candidate1 == x)\\n                ++count1;\\n            else if (candidate2 == x)\\n                ++count2;\\n            else if (count1 == 0)\\n            {\\n                candidate1 = x;\\n                count1 = 1;\\n            }\\n            else if (count2 == 0)\\n            {\\n                candidate2 = x;\\n                count2 = 1;\\n            }\\n            else\\n            {\\n                // Generate a \"triplet\".\\n                --count1;\\n                --count2;\\n            }\\n        }\\n\\n        vector<int> rv;\\n        count1 = 0;\\n        count2 = 0;\\n        // Second scan.\\n        for (const auto &x : nums) {\\n            if (x == candidate1)\\n                ++count1;\\n            else if (x == candidate2)\\n                ++count2;\\n        }\\n\\n        if (count1 > int(nums.size() / 3))\\n            rv.push_back(candidate1);\\n        if (count2 > int(nums.size() / 3))\\n            rv.push_back(candidate2);\\n        return rv;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int candidate1 = 0, count1 = 0;\\n        int candidate2 = 1, count2 = 0;\\n        // First scan.\\n        for (const auto &x : nums) {\\n            if (candidate1 == x)\\n                ++count1;\\n            else if (candidate2 == x)\\n                ++count2;\\n            else if (count1 == 0)\\n            {\\n                candidate1 = x;\\n                count1 = 1;\\n            }\\n            else if (count2 == 0)\\n            {\\n                candidate2 = x;\\n                count2 = 1;\\n            }\\n            else\\n            {\\n                // Generate a \"triplet\".\\n                --count1;\\n                --count2;\\n            }\\n        }\\n\\n        vector<int> rv;\\n        count1 = 0;\\n        count2 = 0;\\n        // Second scan.\\n        for (const auto &x : nums) {\\n            if (x == candidate1)\\n                ++count1;\\n            else if (x == candidate2)\\n                ++count2;\\n        }\\n\\n        if (count1 > int(nums.size() / 3))\\n            rv.push_back(candidate1);\\n        if (count2 > int(nums.size() / 3))\\n            rv.push_back(candidate2);\\n        return rv;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4100524,
                "title": "c-3-best-approaches-explained",
                "content": "# *PLEASE UPVOTE IF IT HELPED*\\n\\n---\\n\\n\\n# Approach\\n***(Also explained in the code)***\\n\\n***Approach 1: Using  Hash Maps***\\n1. The code uses a `map (mp)` to count the frequencies of each element in the `nums` array.\\n\\n1. n is calculated as `nums.size() / 3`, which represents the minimum count required for an element to be considered a majority element.\\n\\n1. The code iterates through the `map` and checks if the count of each element (`a.second`) is greater than `n`. If it is, the element is added to the `ans` vector as it is considered a majority element.\\n\\n\\n***Approach 2: Using Hash Maps and Sorting***\\n\\n1. The code first handles special cases where the input array has a size of 1 or 2.\\n\\n1. It then sorts the input array to group identical elements together.\\n\\n1. `countMajority` is calculated as `nums.size() / 3`, which represents the minimum count required for an element to be considered a majority element.\\n\\n1. The code iterates through the sorted array, counting the frequency of each element. If an element\\'s count exceeds `countMajority`, it is added to the `set` as a majority element.\\n\\n1. Finally, the code converts the `set` into a vector (`output`) and returns it as the result.\\n\\n\\n\\n***approach 3: Moore\\'s Voting Algorithm*** (*best Approach*)\\n\\n1. The code aims to find elements in the `nums` vector that occur more than `n/3` times, where `n` is the size of the vector.\\n\\n1. It initializes `cnt1` and `cnt2` to keep counts of two potential majority elements and `el1` and `el2` to store those elements.\\n\\n1. It iterates through the `nums` vector, and for each element:\\n\\n    - If `cnt1` is zero and the element is different from `el2`, it sets `el1` to the current element and initializes `cnt1` to 1.\\n   - If `cnt2` is zero and the element is different from `el1`, it sets `el2` to the current element and initializes `cnt2` to 1.\\n   - If the element matches `el1`, it increments `cnt1`. If it matches `el2`, it increments `cnt2`.\\n   - If none of the above conditions match, it decrements both `cnt1` and `cnt2`.\\n4. After the initial counting, it resets `cnt1` and `cnt2` to zero and reiterates through `nums` to count the occurrences of `el1` and `el2`.\\n\\n1. If the count of `el1` is greater than `n/3`, it adds `el1` to the `ans` vector.\\n\\n1. If the count of `el2` is greater than `n/3`, it adds `el2` to the `ans` vector.\\n\\n1. The `ans` vector contains the elements that occur more than `n/3` times in the `nums` vector and is returned as the result.\\n\\n\\n# Complexity\\n- **Time complexity:**\\n1. $$O(n)$$\\n2. $$O(nlogn)$$\\n3. $$O(n)$$\\n\\n- **Space complexity:**\\n1. $$O(n)$$\\n2. $$O(n)$$\\n3. $$O(1)$$\\n\\n# Code\\n```\\n\\n         ------Approach 1-------\\n\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        map<int,int> mp;    // Create a map to store element frequencies.\\n        vector<int> ans;    // Create a vector to store the majority elements.\\n        int n = nums.size() / 3;  // The minimum count required for an element to be a majority element.\\n\\n        // Count the frequencies of elements in the input array.\\n        for (auto a : nums) {\\n            mp[a]++;\\n        }\\n\\n        // Iterate through the map to find majority elements.\\n        for (auto a : mp) {\\n            if (a.second > n) {\\n                ans.push_back(a.first); // If an element has a count greater than n, it\\'s a majority element.\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n         ------Approach 2-------\\n\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        if(nums.size() == 1){\\n            return {nums[0]};\\n        }\\n        if(nums.size() == 2 && nums[0] != nums[1]){\\n            return {nums[0], nums[1]};\\n        }\\n        sort(nums.begin(), nums.end()); // Sort the input array.\\n\\n        int countMajority = nums.size() / 3; // Determine the minimum count required for an element to be a majority element.\\n\\n        unordered_set<int> set; // Use an unordered_set to store unique majority elements.\\n        vector<int> output; // Create a vector to store the final output.\\n        int count = 1; // Initialize a count variable to track element frequencies.\\n\\n        for(int i = 1; i < nums.size(); i++){\\n            if(nums[i - 1] == nums[i]){\\n                count++;\\n                if(count > countMajority){\\n                    set.insert(nums[i]); // Add the element to the set if it\\'s a majority element.\\n                }\\n            }\\n            else{\\n                count = 1; // Reset the count when encountering a different element.\\n            }\\n        }\\n\\n        for(int it : set){\\n            output.push_back(it); // Convert the set to a vector for the final output.\\n        }\\n\\n        return output;\\n    }\\n};\\n\\n         ------Approach 3-------\\n\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int cnt1 = 0, cnt2 = 0; // Initialize counters for two potential majority elements.\\n        int el1 = 0, el2 = 0; // Initialize variables to store the two potential majority elements.\\n\\n        // First pass to find potential majority elements.\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (cnt1 == 0 && nums[i] != el2) {\\n                cnt1 = 1;\\n                el1 = nums[i];\\n            } else if (cnt2 == 0 && nums[i] != el1) {\\n                cnt2 = 1;\\n                el2 = nums[i];\\n            } else if (el1 == nums[i]) {\\n                cnt1++;\\n            } else if (el2 == nums[i]) {\\n                cnt2++;\\n            } else {\\n                cnt1--;\\n                cnt2--;\\n            }\\n        }\\n\\n        vector<int> ans;\\n        int n = nums.size() / 3;\\n        cnt1 = 0, cnt2 = 0;\\n\\n        // Second pass to count occurrences of the potential majority elements.\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (el1 == nums[i]) {\\n                cnt1++;\\n            } else if (el2 == nums[i]) {\\n                cnt2++;\\n            }\\n        }\\n\\n        // Check if the counts of potential majority elements are greater than n/3 and add them to the result.\\n        if (cnt1 > n) {\\n            ans.push_back(el1);\\n        }\\n        if (cnt2 > n) {\\n            ans.push_back(el2);\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\n```\\n# *PLEASE UPVOTE IF IT HELPED*\\n\\n---\\n\\n---\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sorting",
                    "Counting"
                ],
                "code": "```\\n\\n         ------Approach 1-------\\n\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        map<int,int> mp;    // Create a map to store element frequencies.\\n        vector<int> ans;    // Create a vector to store the majority elements.\\n        int n = nums.size() / 3;  // The minimum count required for an element to be a majority element.\\n\\n        // Count the frequencies of elements in the input array.\\n        for (auto a : nums) {\\n            mp[a]++;\\n        }\\n\\n        // Iterate through the map to find majority elements.\\n        for (auto a : mp) {\\n            if (a.second > n) {\\n                ans.push_back(a.first); // If an element has a count greater than n, it\\'s a majority element.\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n         ------Approach 2-------\\n\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        if(nums.size() == 1){\\n            return {nums[0]};\\n        }\\n        if(nums.size() == 2 && nums[0] != nums[1]){\\n            return {nums[0], nums[1]};\\n        }\\n        sort(nums.begin(), nums.end()); // Sort the input array.\\n\\n        int countMajority = nums.size() / 3; // Determine the minimum count required for an element to be a majority element.\\n\\n        unordered_set<int> set; // Use an unordered_set to store unique majority elements.\\n        vector<int> output; // Create a vector to store the final output.\\n        int count = 1; // Initialize a count variable to track element frequencies.\\n\\n        for(int i = 1; i < nums.size(); i++){\\n            if(nums[i - 1] == nums[i]){\\n                count++;\\n                if(count > countMajority){\\n                    set.insert(nums[i]); // Add the element to the set if it\\'s a majority element.\\n                }\\n            }\\n            else{\\n                count = 1; // Reset the count when encountering a different element.\\n            }\\n        }\\n\\n        for(int it : set){\\n            output.push_back(it); // Convert the set to a vector for the final output.\\n        }\\n\\n        return output;\\n    }\\n};\\n\\n         ------Approach 3-------\\n\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int cnt1 = 0, cnt2 = 0; // Initialize counters for two potential majority elements.\\n        int el1 = 0, el2 = 0; // Initialize variables to store the two potential majority elements.\\n\\n        // First pass to find potential majority elements.\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (cnt1 == 0 && nums[i] != el2) {\\n                cnt1 = 1;\\n                el1 = nums[i];\\n            } else if (cnt2 == 0 && nums[i] != el1) {\\n                cnt2 = 1;\\n                el2 = nums[i];\\n            } else if (el1 == nums[i]) {\\n                cnt1++;\\n            } else if (el2 == nums[i]) {\\n                cnt2++;\\n            } else {\\n                cnt1--;\\n                cnt2--;\\n            }\\n        }\\n\\n        vector<int> ans;\\n        int n = nums.size() / 3;\\n        cnt1 = 0, cnt2 = 0;\\n\\n        // Second pass to count occurrences of the potential majority elements.\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (el1 == nums[i]) {\\n                cnt1++;\\n            } else if (el2 == nums[i]) {\\n                cnt2++;\\n            }\\n        }\\n\\n        // Check if the counts of potential majority elements are greater than n/3 and add them to the result.\\n        if (cnt1 > n) {\\n            ans.push_back(el1);\\n        }\\n        if (cnt2 > n) {\\n            ans.push_back(el2);\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903960,
                "title": "boyer-moore-algorithm-with-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf the array contains the majority of elements, their occurrence must be greater than the floor(N/3). Now, we can say that the count of minority elements and majority elements is equal up to a certain point in the array. So when we traverse through the array we try to keep track of the counts of elements and the elements themselves for which we are tracking the counts. \\n\\nAfter traversing the whole array, we will check the elements stored in the variables. Then we need to check if the stored elements are the majority elements or not by manually checking their counts.\\n\\nNote: This intuition is simply the logic of cancellation i.e. a variation of Moore\\u2019s Voting Algorithm that we used in the problem Majority Element (> N/2).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize 4 variables:\\n    1. cnt1 & cnt2 \\u2013  for tracking the counts of elements\\n    2. el1 & el2 \\u2013 for storing the majority of elements.\\n2. Traverse through the given array.\\n    1. If cnt1 is 0 and the current element is not el2 then store the current element of the array as el1 along with increasing the cnt1 value by 1.\\n    2. If cnt2 is 0 and the current element is not el1 then store the current element of the array as el2 along with increasing the cnt2 value by 1.\\n    3. If the current element and el1 are the same increase the cnt1 by 1.\\n    4. If the current element and el2 are the same increase the cnt2 by 1.\\n    5. Other than all the above cases: decrease cnt1 and cnt2 by 1.\\n3. The integers present in el1 & el2 should be the result we are expecting. So, using another loop, we will manually check their counts if they are greater than the floor(N/3).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        int cnt1 = 0,cnt2 = 0;\\n        int el1 = -1,el2 = -1;\\n\\n        for(int i=0;i<n;i++) {\\n            if(cnt1 == 0 && nums[i] != el2) {\\n                cnt1++;\\n                el1 = nums[i];\\n            }\\n\\n            else if(cnt2 == 0 && nums[i] != el1) {\\n                cnt2++;\\n                el2 = nums[i];\\n            }\\n\\n            else if(el1 == nums[i]) cnt1++;\\n\\n            else if(el2 == nums[i]) cnt2++;\\n\\n            else {\\n                cnt1--;\\n                cnt2--;\\n            }\\n        }        \\n\\n\\n        //Now we simply check if el1 and el2 are majority or not\\n        cnt1 = 0;\\n        cnt2 = 0;\\n        for(int i=0;i<n;i++) {\\n            if(nums[i] == el1)\\n                cnt1++;\\n\\n            else if(nums[i] == el2)\\n                cnt2++;\\n        }\\n\\n        vector<int> ans;\\n        int mini = (int)(n/3) + 1;\\n\\n        if(cnt1 >= mini)\\n            ans.push_back(el1);\\n\\n        if(cnt2 >= mini)\\n            ans.push_back(el2);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        int cnt1 = 0,cnt2 = 0;\\n        int el1 = -1,el2 = -1;\\n\\n        for(int i=0;i<n;i++) {\\n            if(cnt1 == 0 && nums[i] != el2) {\\n                cnt1++;\\n                el1 = nums[i];\\n            }\\n\\n            else if(cnt2 == 0 && nums[i] != el1) {\\n                cnt2++;\\n                el2 = nums[i];\\n            }\\n\\n            else if(el1 == nums[i]) cnt1++;\\n\\n            else if(el2 == nums[i]) cnt2++;\\n\\n            else {\\n                cnt1--;\\n                cnt2--;\\n            }\\n        }        \\n\\n\\n        //Now we simply check if el1 and el2 are majority or not\\n        cnt1 = 0;\\n        cnt2 = 0;\\n        for(int i=0;i<n;i++) {\\n            if(nums[i] == el1)\\n                cnt1++;\\n\\n            else if(nums[i] == el2)\\n                cnt2++;\\n        }\\n\\n        vector<int> ans;\\n        int mini = (int)(n/3) + 1;\\n\\n        if(cnt1 >= mini)\\n            ans.push_back(el1);\\n\\n        if(cnt2 >= mini)\\n            ans.push_back(el2);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872466,
                "title": "easy-to-understand-3-approaches-c",
                "content": "# Intuition\\n1. Brute force \\n2. Hashing \\n3. Extended Boyer Moore\\u2019s voting algorithm\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n# Brute force \\n- We need to know how many numbers exist in the array where the freq of an element can be > floor(n/3) where n i the size of the array. A small observation here is consider array of size=8\\n\\n - n/3= 2 so freq must be >2 i.e 3 or more if we consider the min freq needed i.e 3 then 3+3+2 makes up 8 which gives us max 2 elements which can occur in majority. So now we know that our ans vector can only be of size \\u22642(using this in our approach).\\n\\n- Traverse element one by one and if the ans vector is empty or it contains 1 element then this means we have to perform search so the inner loop will run only if this condition is satisfied where either the ans vector is empty or it does not contain and element which is already counted in our answer .\\n// TC = O(N^2)\\n// SC = O(1)\\n\\n\\n# Hashing \\n - Hashing and finding out where freq \\u2265n/3 and including to ans\\n TC = O(N)\\n SC - O(N)\\n\\n\\n # Boyer Moore\\u2019s voting algorithm\\n- As we know we will have at max only two elements in our ans we make use of moore\\u2019s voting algo and keep track using 4 variables cnt1,cnt2, ekem1,elem2.\\n\\n- Projection of majority element 1 problem :\\n\\n- cnt1 counts 1st majority element and cnt2 counts 2nd we use if else if so that only one condition if satisfied every time. We pick up one element and check whether cnt1 is 0 if yes then it will be set to 1 and elem1 will contain this element after this the loop moves for next iteration making sure that only one either of cnt1 or cnt2 is set but there is a problem when one of the cnt is zero and other is not and the current element is the one that is already store in one of the elem var say 1\\n\\n- Now current elements being processed is 1 so when he cnt2==0 condition is satisfied cnt2 is set to 1 and elem2 now contains 1. Now both elem 1 and elem2 contains 1 and there freq values will be garbled so to avoid this case we also include a cond when either of ct is zero we check that arr[i] should not be equal to elem variables of either contrary cnt variable( cnt1 and elem2 condition is checked) .\\n\\nTC = O(N)\\nSC = O(1)\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//brute force \\n// TC = O(N^2)\\n// SC = O(1)\\n\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int> &arr){\\n\\n    vector<int> ans;\\n    int cnt=1;\\n    for(int i=0;i<arr.size();i++){\\n        cnt=1;\\n        if(ans.empty() || ans.back()!=arr[i]){\\n\\n            for(int j=i+1;j<arr.size();j++){\\n                if(arr[j]==arr[i])\\n                    cnt++;\\n            }\\n            if(cnt>arr.size()/3)\\n                ans.push_back(arr[i]);\\n        }\\n    }\\n    return ans;\\n    }\\n};\\n```\\n```\\n//hashing \\n//TC = O(N)\\n//SC - O(N)\\n\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int countMajority = nums.size()/3;\\n        unordered_map<int, int> map;\\n        vector<int>ans;\\n        \\n        for(auto it : nums){\\n            map[it]++;\\n        }\\n        for(auto it : map){\\n            if(it.second > countMajority){\\n                ans.push_back(it.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n```\\n// Boyer Moore\\u2019s voting algorithm\\n//TC = O(N)\\n//SC = O(1)\\n\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n\\n        //optimised solution\\n        int n = nums.size();\\n        int cnt1 = 0, cnt2 = 0;\\n        int el1 = INT_MIN;\\n        int el2 = INT_MIN;\\n\\n        for(int i = 0;i<n;i++){\\n            if(cnt1 == 0 && el2 != nums[i]){\\n                cnt1 = 1;\\n                el1 = nums[i];\\n            }\\n            else if(cnt2 == 0 && el1 != nums[i]){\\n                cnt2 = 1;\\n                el2 = nums[i];\\n            }\\n            else if(nums[i] == el1){\\n                cnt1++;\\n            }\\n            else if(nums[i] == el2){\\n                cnt2++;\\n            }\\n            else{\\n                cnt1--;\\n                cnt2--;\\n            }\\n        }\\n\\n        vector<int> ans;\\n        cnt1 = 0, cnt2 = 0;\\n\\n        for(int i = 0;i<n;i++){\\n            if(el1 == nums[i]){\\n                cnt1++;\\n            }\\n            if(el2 == nums[i]){\\n                cnt2++;\\n            }\\n        }\\n\\n        if(cnt1 > (n/3)){\\n            ans.push_back(el1);\\n        }\\n        if(cnt2 > (n/3)){\\n            ans.push_back(el2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sorting",
                    "Counting"
                ],
                "code": "```\\n//brute force \\n// TC = O(N^2)\\n// SC = O(1)\\n\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int> &arr){\\n\\n    vector<int> ans;\\n    int cnt=1;\\n    for(int i=0;i<arr.size();i++){\\n        cnt=1;\\n        if(ans.empty() || ans.back()!=arr[i]){\\n\\n            for(int j=i+1;j<arr.size();j++){\\n                if(arr[j]==arr[i])\\n                    cnt++;\\n            }\\n            if(cnt>arr.size()/3)\\n                ans.push_back(arr[i]);\\n        }\\n    }\\n    return ans;\\n    }\\n};\\n```\n```\\n//hashing \\n//TC = O(N)\\n//SC - O(N)\\n\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int countMajority = nums.size()/3;\\n        unordered_map<int, int> map;\\n        vector<int>ans;\\n        \\n        for(auto it : nums){\\n            map[it]++;\\n        }\\n        for(auto it : map){\\n            if(it.second > countMajority){\\n                ans.push_back(it.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```\\n// Boyer Moore\\u2019s voting algorithm\\n//TC = O(N)\\n//SC = O(1)\\n\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n\\n        //optimised solution\\n        int n = nums.size();\\n        int cnt1 = 0, cnt2 = 0;\\n        int el1 = INT_MIN;\\n        int el2 = INT_MIN;\\n\\n        for(int i = 0;i<n;i++){\\n            if(cnt1 == 0 && el2 != nums[i]){\\n                cnt1 = 1;\\n                el1 = nums[i];\\n            }\\n            else if(cnt2 == 0 && el1 != nums[i]){\\n                cnt2 = 1;\\n                el2 = nums[i];\\n            }\\n            else if(nums[i] == el1){\\n                cnt1++;\\n            }\\n            else if(nums[i] == el2){\\n                cnt2++;\\n            }\\n            else{\\n                cnt1--;\\n                cnt2--;\\n            }\\n        }\\n\\n        vector<int> ans;\\n        cnt1 = 0, cnt2 = 0;\\n\\n        for(int i = 0;i<n;i++){\\n            if(el1 == nums[i]){\\n                cnt1++;\\n            }\\n            if(el2 == nums[i]){\\n                cnt2++;\\n            }\\n        }\\n\\n        if(cnt1 > (n/3)){\\n            ans.push_back(el1);\\n        }\\n        if(cnt2 > (n/3)){\\n            ans.push_back(el2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694368,
                "title": "easily-understandable-solution-most-optimised",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhttps://takeuforward.org/data-structure/majority-elementsn-3-times-find-the-elements-that-appears-more-than-n-3-times-in-the-array/\\n\\n\\n# Complexity\\n- Time complexity:O(N) + O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n           int counter1=0, ele1=INT_MIN;\\n           int counter2=0, ele2=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n\\n            if(counter1==0 && ele2!=nums[i]){ele1=nums[i];     counter1=1; } \\n            else if(counter2==0 && ele1!= nums[i]) {ele2=nums[i];     counter2=1;}\\n              else if(ele1==nums[i]) counter1++; \\n              else if(ele2==nums[i]) counter2++; \\n                else{\\n                  counter1--; counter2--;  \\n                } \\n        }\\n        vector<int> ans;\\n        counter1=0;counter2=0;\\n        int mini=nums.size()/3;\\n          for(int i=0;i<nums.size();i++){\\n            if(nums[i]==ele1)counter1++;\\n            if(nums[i]==ele2)counter2++;\\n          }\\n          if(counter1>mini)ans.push_back(ele1);\\n          if(counter2>mini)ans.push_back(ele2);\\n          return ans;\\n    }\\n};\\n``````PLEASE UPVOTE TO MOTIVATE ME WRITE MORE SOLUTION\\n",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n           int counter1=0, ele1=INT_MIN;\\n           int counter2=0, ele2=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n\\n            if(counter1==0 && ele2!=nums[i]){ele1=nums[i];     counter1=1; } \\n            else if(counter2==0 && ele1!= nums[i]) {ele2=nums[i];     counter2=1;}\\n              else if(ele1==nums[i]) counter1++; \\n              else if(ele2==nums[i]) counter2++; \\n                else{\\n                  counter1--; counter2--;  \\n                } \\n        }\\n        vector<int> ans;\\n        counter1=0;counter2=0;\\n        int mini=nums.size()/3;\\n          for(int i=0;i<nums.size();i++){\\n            if(nums[i]==ele1)counter1++;\\n            if(nums[i]==ele2)counter2++;\\n          }\\n          if(counter1>mini)ans.push_back(ele1);\\n          if(counter2>mini)ans.push_back(ele2);\\n          return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641299,
                "title": "c-solution-using-hash-table-o-n",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        vector<int> ans;\\n        for(int i=0; i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n\\n       for(auto it:mp){\\n           if(it.second>(nums.size())/3){\\n               ans.push_back(it.first);\\n           }\\n       }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        vector<int> ans;\\n        for(int i=0; i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n\\n       for(auto it:mp){\\n           if(it.second>(nums.size())/3){\\n               ans.push_back(it.first);\\n           }\\n       }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636228,
                "title": "java-hashmap-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We will use **HashMap** to store value(Key) and its frequency.\\n- Create a **List** to store ans.\\n- Check **condition** (freq>n/3) if statisfy add to ans\\n- In the end return **ans**.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$ O(N) $$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i])){\\n                map.put(nums[i],map.get(nums[i])+1);\\n            }else{\\n                map.put(nums[i],1);\\n            }\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        for(int k: map.keySet()){\\n            if(map.get(k)>nums.length/3){\\n                ans.add(k);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i])){\\n                map.put(nums[i],map.get(nums[i])+1);\\n            }else{\\n                map.put(nums[i],1);\\n            }\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        for(int k: map.keySet()){\\n            if(map.get(k)>nums.length/3){\\n                ans.add(k);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511006,
                "title": "java-solution-for-majority-element-ii-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to use a HashMap to count the occurrences of each element in the array. By iterating through the array and updating the counts in the HashMap, we can identify the elements that appear more than \\u230An/3\\u230B times.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The code initializes a HashMap map to store the element-count pairs.\\n2. It iterates through the array nums, and for each element i:\\n- If i is already present in the HashMap, it increments the count for i by 1.\\n- If i is not present in the HashMap, it adds i as a key with an initial count of 1.\\n3. After counting the occurrences of each element, the code initializes an empty ArrayList result to store the majority elements.\\n4. It iterates through the entries of the HashMap using map.entrySet() and checks if the count for a particular element is greater than nums.length/3.\\n- If the count is greater, it adds the element to the result list.\\n5. Finally, it returns the result list containing all the majority elements.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the code is O(n), where n is the length of the input array. This is because the code iterates through the array once to count the occurrences of each element and iterates through the entries of the HashMap to identify the majority elements. Both iterations are linear with respect to the input size.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the code is O(n) in the worst case. This occurs when all the elements in the input array are unique, resulting in the HashMap storing all n elements. Additionally, the space used by the result list is proportional to the number of majority elements, which can be at most 2 (if they exist). Therefore, the overall space complexity is dominated by the HashMap and is linear with respect to the input size.\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n        for(int i: nums)\\n        {\\n            if(map.containsKey(i))\\n            {\\n                map.put(i, map.get(i)+1);\\n            }\\n            else\\n            {\\n                map.put(i, 1);\\n            }\\n        }\\n        List<Integer> result = new ArrayList<Integer>();\\n        for(Map.Entry<Integer, Integer> entry: map.entrySet())\\n        {\\n            if(entry.getValue() > nums.length/3)\\n            {\\n                result.add(entry.getKey());\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n        for(int i: nums)\\n        {\\n            if(map.containsKey(i))\\n            {\\n                map.put(i, map.get(i)+1);\\n            }\\n            else\\n            {\\n                map.put(i, 1);\\n            }\\n        }\\n        List<Integer> result = new ArrayList<Integer>();\\n        for(Map.Entry<Integer, Integer> entry: map.entrySet())\\n        {\\n            if(entry.getValue() > nums.length/3)\\n            {\\n                result.add(entry.getKey());\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458272,
                "title": "optimal-solution-c-code",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n# Moore\\'s Voting Algorithm used\\uD83D\\uDC47\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n- Vector \\'ans\\' will store at most 2 elements which is as good as constant space\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>ans;\\n        int el1=INT_MIN,el2=INT_MIN;\\n        int cnt1=0,cnt2=0;\\n        for(int i=0;i<n;i++){\\n            if(cnt1==0 && el2!=nums[i]){\\n                el1=nums[i];\\n                cnt1++;\\n            }else if(cnt2==0 && el1!=nums[i]){\\n                el2=nums[i];\\n                cnt2++;\\n            }else if(el1==nums[i]){\\n                cnt1++;\\n            }else if(el2==nums[i]){\\n                cnt2++;\\n            }else{\\n                cnt1--;\\n                cnt2--;\\n            }\\n        }\\n        cnt1=0,cnt2=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==el1){\\n                cnt1++;\\n                if(cnt1==n/3+1){\\n                    ans.push_back(el1);\\n                }\\n            }else if(nums[i]==el2){\\n                cnt2++;\\n                if(cnt2==n/3+1){\\n                    ans.push_back(el2);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Please Upvote if it was helpful\\u2B06\\uFE0F",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>ans;\\n        int el1=INT_MIN,el2=INT_MIN;\\n        int cnt1=0,cnt2=0;\\n        for(int i=0;i<n;i++){\\n            if(cnt1==0 && el2!=nums[i]){\\n                el1=nums[i];\\n                cnt1++;\\n            }else if(cnt2==0 && el1!=nums[i]){\\n                el2=nums[i];\\n                cnt2++;\\n            }else if(el1==nums[i]){\\n                cnt1++;\\n            }else if(el2==nums[i]){\\n                cnt2++;\\n            }else{\\n                cnt1--;\\n                cnt2--;\\n            }\\n        }\\n        cnt1=0,cnt2=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==el1){\\n                cnt1++;\\n                if(cnt1==n/3+1){\\n                    ans.push_back(el1);\\n                }\\n            }else if(nums[i]==el2){\\n                cnt2++;\\n                if(cnt2==n/3+1){\\n                    ans.push_back(el2);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3410953,
                "title": "easy-python-solution-for-the-follow-up-part",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        l,num1,num2,c1,c2=len(nums),0,0,0,0\\n        for i in nums:\\n            if i==num1:\\n                c1+=1\\n            elif i==num2:\\n                c2+=1\\n            elif c1==0:\\n                num1=i\\n                c1=1\\n            elif c2==0:\\n                num2=i\\n                c2=1\\n            else:\\n                c1-=1\\n                c2-=1\\n        ans = []\\n        count1 = count2 = 0\\n        for i in range(l):\\n            if nums[i] == num1:\\n                count1 += 1\\n            elif nums[i] == num2:\\n                count2 += 1\\n        if count1 > l // 3:\\n            ans.append(num1)\\n        if count2 > l // 3:\\n            ans.append(num2)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        l,num1,num2,c1,c2=len(nums),0,0,0,0\\n        for i in nums:\\n            if i==num1:\\n                c1+=1\\n            elif i==num2:\\n                c2+=1\\n            elif c1==0:\\n                num1=i\\n                c1=1\\n            elif c2==0:\\n                num2=i\\n                c2=1\\n            else:\\n                c1-=1\\n                c2-=1\\n        ans = []\\n        count1 = count2 = 0\\n        for i in range(l):\\n            if nums[i] == num1:\\n                count1 += 1\\n            elif nums[i] == num2:\\n                count2 += 1\\n        if count1 > l // 3:\\n            ans.append(num1)\\n        if count2 > l // 3:\\n            ans.append(num2)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3220988,
                "title": "java-very-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        // List<Integer>a=new ArrayList<>();\\n        // HashMap<Integer,Integer>map=new HashMap<>();\\n        // for(int i=0;i<nums.length;i++){\\n        //     if(map.containsKey(nums[i])){\\n        //         map.put(nums[i],map.get(nums[i])+1);\\n        //     }\\n        //     else{\\n        //         map.put(nums[i],1);\\n        //     }\\n        // }\\n        // for(Map.Entry<Integer,Integer>entry:map.entrySet()){\\n        //     if(entry.getValue()>nums.length/3){\\n        //         a.add(entry.getKey());\\n        //     }\\n        // }\\n        // return a;\\n\\n        //Boyer Moore\\u2019s Voting Algorithm\\n        int nums1=-1;\\n        int nums2=-2;\\n        int n=nums.length;\\n        int ct1=0;\\n        int ct2=0;\\n        for(int i=0;i<n;i++){\\n\\n            if(nums[i]==nums1) ct1++;\\n            else if(nums[i]==nums2) ct2++;\\n\\n            else if(ct1==0){\\n                nums1=nums[i];\\n                ct1=1;\\n            }\\n            else if(ct2==0){\\n                nums2=nums[i];\\n                ct2=1;\\n            }\\n            else{\\n                ct1--;\\n                ct2--;\\n            }\\n        }\\n\\n        List<Integer>ans=new ArrayList<>();\\n        ct1=0;\\n        ct2=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==nums1){\\n                ct1++;\\n            }\\n            if(nums[i]==nums2){\\n                ct2++;\\n            }\\n        }\\n        if(ct1>n/3) ans.add(nums1);\\n        if(ct2>n/3) ans.add(nums2);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        // List<Integer>a=new ArrayList<>();\\n        // HashMap<Integer,Integer>map=new HashMap<>();\\n        // for(int i=0;i<nums.length;i++){\\n        //     if(map.containsKey(nums[i])){\\n        //         map.put(nums[i],map.get(nums[i])+1);\\n        //     }\\n        //     else{\\n        //         map.put(nums[i],1);\\n        //     }\\n        // }\\n        // for(Map.Entry<Integer,Integer>entry:map.entrySet()){\\n        //     if(entry.getValue()>nums.length/3){\\n        //         a.add(entry.getKey());\\n        //     }\\n        // }\\n        // return a;\\n\\n        //Boyer Moore\\u2019s Voting Algorithm\\n        int nums1=-1;\\n        int nums2=-2;\\n        int n=nums.length;\\n        int ct1=0;\\n        int ct2=0;\\n        for(int i=0;i<n;i++){\\n\\n            if(nums[i]==nums1) ct1++;\\n            else if(nums[i]==nums2) ct2++;\\n\\n            else if(ct1==0){\\n                nums1=nums[i];\\n                ct1=1;\\n            }\\n            else if(ct2==0){\\n                nums2=nums[i];\\n                ct2=1;\\n            }\\n            else{\\n                ct1--;\\n                ct2--;\\n            }\\n        }\\n\\n        List<Integer>ans=new ArrayList<>();\\n        ct1=0;\\n        ct2=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==nums1){\\n                ct1++;\\n            }\\n            if(nums[i]==nums2){\\n                ct2++;\\n            }\\n        }\\n        if(ct1>n/3) ans.add(nums1);\\n        if(ct2>n/3) ans.add(nums2);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993442,
                "title": "easily-understandable-java-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBoyer Moore Algo\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        int num1=-1,num2=-1,C1=0,C2=0;\\n        int len = nums.length;\\n        for(int i=0;i<len;i++){\\n            if(nums[i]==num1) C1++;\\n            else if(nums[i]==num2) C2++;\\n            else if(C1==0){\\n            num1 = nums[i];\\n            C1=1;}\\n            else if(C2==0){\\n            num2 = nums[i];\\n            C2=1;}\\n            else{\\n            C1--;\\n            C2--;}\\n        }\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        int count1=0;\\n        int count2=0;\\n        for(int i=0;i<len;i++){\\n            if(nums[i]==num1)\\n            count1++;\\n            else if(nums[i]==num2)\\n            count2++;\\n        }\\n        if(count1>len/3)\\n        ans.add(num1);\\n        if(count2>len/3)\\n        ans.add(num2);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        int num1=-1,num2=-1,C1=0,C2=0;\\n        int len = nums.length;\\n        for(int i=0;i<len;i++){\\n            if(nums[i]==num1) C1++;\\n            else if(nums[i]==num2) C2++;\\n            else if(C1==0){\\n            num1 = nums[i];\\n            C1=1;}\\n            else if(C2==0){\\n            num2 = nums[i];\\n            C2=1;}\\n            else{\\n            C1--;\\n            C2--;}\\n        }\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        int count1=0;\\n        int count2=0;\\n        for(int i=0;i<len;i++){\\n            if(nums[i]==num1)\\n            count1++;\\n            else if(nums[i]==num2)\\n            count2++;\\n        }\\n        if(count1>len/3)\\n        ans.add(num1);\\n        if(count2>len/3)\\n        ans.add(num2);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827995,
                "title": "in-n-time-complexity-usind-defaultdict",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        dc=defaultdict(lambda:0)\\n        n=len(nums)//3\\n        for a in nums:\\n            dc[a]+=1\\n        ans=[]\\n        for a in dc:\\n            if(dc[a]>n):\\n                ans.append(a)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        dc=defaultdict(lambda:0)\\n        n=len(nums)//3\\n        for a in nums:\\n            dc[a]+=1\\n        ans=[]\\n        for a in dc:\\n            if(dc[a]>n):\\n                ans.append(a)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2806160,
                "title": "beats-94-45-of-all-the-c-submissions",
                "content": "# Approach\\nThe very basic intuition I used here is Hashing and find \\nthe frequency of all the elements of the vector nums and compare\\nthe frequency of each element with size(vector)/3 (as stated in the problem). If the frequency of the nums vector element is greater \\nthan size(vector)/3 push back the respective element into new \\ndeclared vector ans , and after all relevant insertion return \\nthe vector ans , and its done ! \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n\\n     // declared a vector ans\\n     vector<int> ans;\\n     \\n    // declared a variable temp and assigned it the value size/3 \\n     int temp=nums.size()/3;\\n\\n    // using hashing found out the frequency of all the elements \\n     unordered_map<int,int> mp;\\n     for(int i=0;i<nums.size();++i){\\n         mp[nums[i]]++;\\n     }   \\n\\n     for(auto i:mp){\\n         /* if frequency > size/3 then push back the element into     vector ans */ \\n         if(i.second>temp){\\n             ans.push_back(i.first);\\n         }\\n     }\\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n\\n     // declared a vector ans\\n     vector<int> ans;\\n     \\n    // declared a variable temp and assigned it the value size/3 \\n     int temp=nums.size()/3;\\n\\n    // using hashing found out the frequency of all the elements \\n     unordered_map<int,int> mp;\\n     for(int i=0;i<nums.size();++i){\\n         mp[nums[i]]++;\\n     }   \\n\\n     for(auto i:mp){\\n         /* if frequency > size/3 then push back the element into     vector ans */ \\n         if(i.second>temp){\\n             ans.push_back(i.first);\\n         }\\n     }\\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777887,
                "title": "cpp-boyer-moore-majority-voting-algorithm",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums)\\n    {\\n        int num1 = -1;\\n        int num2 = -1;\\n        int ct1 = 0;\\n        int ct2 = 0;\\n        int n = nums.size();\\n        vector<int > res;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i] == num1)\\n                ct1++;\\n            \\n            else if(nums[i] == num2)\\n                ct2++;\\n            \\n            else if(ct1 == 0)\\n            {\\n                num1 = nums[i];\\n                ct1 = 1;\\n            }\\n            \\n            else if(ct2 == 0)\\n            {\\n                num2 = nums[i];\\n                ct2 = 1;\\n            }\\n            \\n            else \\n            {\\n                ct1--;\\n                ct2--;\\n            }\\n            \\n        }\\n        \\n        ct1 = ct2 = 0;\\n        \\n        for(auto it : nums)\\n        {\\n            if(it == num1)\\n                ct1++;\\n            \\n            else if(it == num2)\\n                ct2++;\\n        }\\n        \\n        \\n        if(ct1 > n/3)\\n            res.push_back(num1);\\n        \\n        if(ct2 > n/3)\\n            res.push_back(num2);\\n        \\n        return res;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums)\\n    {\\n        int num1 = -1;\\n        int num2 = -1;\\n        int ct1 = 0;\\n        int ct2 = 0;\\n        int n = nums.size();\\n        vector<int > res;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i] == num1)\\n                ct1++;\\n            \\n            else if(nums[i] == num2)\\n                ct2++;\\n            \\n            else if(ct1 == 0)\\n            {\\n                num1 = nums[i];\\n                ct1 = 1;\\n            }\\n            \\n            else if(ct2 == 0)\\n            {\\n                num2 = nums[i];\\n                ct2 = 1;\\n            }\\n            \\n            else \\n            {\\n                ct1--;\\n                ct2--;\\n            }\\n            \\n        }\\n        \\n        ct1 = ct2 = 0;\\n        \\n        for(auto it : nums)\\n        {\\n            if(it == num1)\\n                ct1++;\\n            \\n            else if(it == num2)\\n                ct2++;\\n        }\\n        \\n        \\n        if(ct1 > n/3)\\n            res.push_back(num1);\\n        \\n        if(ct2 > n/3)\\n            res.push_back(num2);\\n        \\n        return res;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2751224,
                "title": "python3-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        d=dict()\\n        k=len(nums)//3\\n        a=[]\\n        for i in nums:\\n            if i in d:\\n                d[i]+=1\\n            else:\\n                d[i]=1\\n        for i in nums:\\n            if d[i]>k and i not in a:\\n                a.append(i)\\n        return a\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        d=dict()\\n        k=len(nums)//3\\n        a=[]\\n        for i in nums:\\n            if i in d:\\n                d[i]+=1\\n            else:\\n                d[i]=1\\n        for i in nums:\\n            if d[i]>k and i not in a:\\n                a.append(i)\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739673,
                "title": "java-solution-two-approaches-follow-up",
                "content": "**using extra space**\\n ```\\npublic List<Integer> majorityElement1(int[] nums) {\\n\\n\\tMap<Integer, Integer> map = new HashMap<>();\\n\\n\\tfor (int n : nums) {\\n\\t\\t\\tif (!map.containsKey(n)) \\n\\t\\t\\t\\tmap.put(n, 1);\\n\\t\\t\\telse {\\n\\t\\t\\t\\tmap.put(n, map.get(n) + 1);\\n\\t\\t\\t}\\n\\t}\\n\\n\\tList<Integer> majority = new ArrayList<>();\\n\\n\\tfor (Map.Entry<Integer, Integer> entries : map.entrySet()) {\\n\\t\\t\\tif (entries.getValue() > Math.floor(nums.length / 3)) {\\n\\t\\t\\t\\tmajority.add(entries.getKey());\\n\\t\\t\\t}\\n\\t}\\n\\n\\treturn majority;\\n}\\n ```\\n \\n **using moore\\'s voting algorithm**\\n\\n```\\t\\npublic List<Integer> majorityElement(int[] nums) {\\n\\n\\tint num1 = Integer.MAX_VALUE, num2 = Integer.MAX_VALUE, count1 = 0, count2 = 0, len = nums.length;\\n\\n\\t// collecting votes\\n\\tfor (int n : nums) {\\n\\n\\t\\tif (n == num1) count1++;\\n\\n\\t\\telse if (n == num2) count2++;\\n\\n\\t\\telse if (count1 == 0) {\\n\\t\\t\\tnum1 = n;\\n\\t\\t\\tcount1 = 1;\\n\\n\\t\\t} else if (count2 == 0) {\\n\\t\\t\\tnum2 = n;\\n\\t\\t\\tcount2 = 1;\\n\\n\\t\\t} else {\\n\\t\\t\\tcount1--;\\n\\t\\t\\tcount2--;\\n\\t\\t}\\n\\t}\\n\\n\\t// now checking if num1 and num2 occurs more than n/3 times i.e validating vote count\\n\\tcount1 = 0;\\n\\tcount2 = 0;\\n\\tfor (int n : nums) {\\n\\t\\tif (n == num1) count1++;\\n\\t\\tif (n == num2) count2++;\\n\\t}\\n\\n\\tList<Integer> result = new ArrayList<>();\\n\\n\\tif (count1 > len / 3)\\n\\t\\tresult.add(num1);\\n\\tif (count2 > len / 3)\\n\\t\\tresult.add(num2);\\n\\n\\treturn result;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<Integer> majorityElement1(int[] nums) {\\n\\n\\tMap<Integer, Integer> map = new HashMap<>();\\n\\n\\tfor (int n : nums) {\\n\\t\\t\\tif (!map.containsKey(n)) \\n\\t\\t\\t\\tmap.put(n, 1);\\n\\t\\t\\telse {\\n\\t\\t\\t\\tmap.put(n, map.get(n) + 1);\\n\\t\\t\\t}\\n\\t}\\n\\n\\tList<Integer> majority = new ArrayList<>();\\n\\n\\tfor (Map.Entry<Integer, Integer> entries : map.entrySet()) {\\n\\t\\t\\tif (entries.getValue() > Math.floor(nums.length / 3)) {\\n\\t\\t\\t\\tmajority.add(entries.getKey());\\n\\t\\t\\t}\\n\\t}\\n\\n\\treturn majority;\\n}\\n ```\n```\\t\\npublic List<Integer> majorityElement(int[] nums) {\\n\\n\\tint num1 = Integer.MAX_VALUE, num2 = Integer.MAX_VALUE, count1 = 0, count2 = 0, len = nums.length;\\n\\n\\t// collecting votes\\n\\tfor (int n : nums) {\\n\\n\\t\\tif (n == num1) count1++;\\n\\n\\t\\telse if (n == num2) count2++;\\n\\n\\t\\telse if (count1 == 0) {\\n\\t\\t\\tnum1 = n;\\n\\t\\t\\tcount1 = 1;\\n\\n\\t\\t} else if (count2 == 0) {\\n\\t\\t\\tnum2 = n;\\n\\t\\t\\tcount2 = 1;\\n\\n\\t\\t} else {\\n\\t\\t\\tcount1--;\\n\\t\\t\\tcount2--;\\n\\t\\t}\\n\\t}\\n\\n\\t// now checking if num1 and num2 occurs more than n/3 times i.e validating vote count\\n\\tcount1 = 0;\\n\\tcount2 = 0;\\n\\tfor (int n : nums) {\\n\\t\\tif (n == num1) count1++;\\n\\t\\tif (n == num2) count2++;\\n\\t}\\n\\n\\tList<Integer> result = new ArrayList<>();\\n\\n\\tif (count1 > len / 3)\\n\\t\\tresult.add(num1);\\n\\tif (count2 > len / 3)\\n\\t\\tresult.add(num2);\\n\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2519393,
                "title": "python-easy-solution-using-dictionary-hashmaps",
                "content": "```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        res=[]\\n        num=Counter(nums)\\n        for i in num.keys():\\n            if(num[i]>len(nums)/3):\\n                res.append(i)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        res=[]\\n        num=Counter(nums)\\n        for i in num.keys():\\n            if(num[i]>len(nums)/3):\\n                res.append(i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2508393,
                "title": "java-boyer-moore-hashmaps-1ms-t-o-n-s-o-1",
                "content": "**Code:**\\n###### Hash map\\n\\t\\tHashMap<Integer,Integer> cntMap = new HashMap<>();\\n        int n = arr.length;\\n        for(int i = 0;i<n;i++)\\n            cntMap.put(arr[i],cntMap.getOrDefault(arr[i],0)+1);\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        for(Map.Entry<Integer,Integer> e:cntMap.entrySet())\\n            if(e.getValue()> n/3)\\n                ans.add(e.getKey());\\n        return ans;\\n\\t\\t\\n######       Boyer Moore Voting Algorithm\\n\\t  int ans1 = -1, ans2 =-1, cnt1 = 0,cnt2 = 0;\\n        for(int e:arr){\\n            if(ans1 == e) cnt1++;\\n            else if(ans2== e) cnt2++;\\n            else if(cnt1 == 0){\\n                ans1 = e;\\n                cnt1= 1;\\n            }\\n            else if(cnt2 == 0){\\n                ans2 = e;\\n                cnt2 = 1;\\n            }\\n            else{\\n                cnt1--;\\n                cnt2--;\\n            }\\n        }\\n        cnt1 = 0;\\n        cnt2 = 0;\\n        for(int e:arr){\\n            if(e== ans1) cnt1++;\\n            else if(e == ans2) cnt2++;\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        if(cnt1 >arr.length/3) ans.add(ans1);\\n        if(cnt2 > arr.length/3) ans.add(ans2);\\n        return ans;",
                "solutionTags": [
                    "Java"
                ],
                "code": "**Code:**\\n###### Hash map\\n\\t\\tHashMap<Integer,Integer> cntMap = new HashMap<>();\\n        int n = arr.length;\\n        for(int i = 0;i<n;i++)\\n            cntMap.put(arr[i],cntMap.getOrDefault(arr[i],0)+1);\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        for(Map.Entry<Integer,Integer> e:cntMap.entrySet())\\n            if(e.getValue()> n/3)\\n                ans.add(e.getKey());\\n        return ans;\\n\\t\\t\\n######       Boyer Moore Voting Algorithm\\n\\t  int ans1 = -1, ans2 =-1, cnt1 = 0,cnt2 = 0;\\n        for(int e:arr){\\n            if(ans1 == e) cnt1++;\\n            else if(ans2== e) cnt2++;\\n            else if(cnt1 == 0){\\n                ans1 = e;\\n                cnt1= 1;\\n            }\\n            else if(cnt2 == 0){\\n                ans2 = e;\\n                cnt2 = 1;\\n            }\\n            else{\\n                cnt1--;\\n                cnt2--;\\n            }\\n        }\\n        cnt1 = 0;\\n        cnt2 = 0;\\n        for(int e:arr){\\n            if(e== ans1) cnt1++;\\n            else if(e == ans2) cnt2++;\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        if(cnt1 >arr.length/3) ans.add(ans1);\\n        if(cnt2 > arr.length/3) ans.add(ans2);\\n        return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 2393012,
                "title": "c-accepted-extended-boyer-moore-s-voting-algorithm-best-approach-with-steps-explanation",
                "content": "**Approach 1: Using Map**\\n**Approach:** Traverse the whole array and store the count of every element in a map. After that traverse through the map and whenever you find the count of an element greater than N/3 times, store that element in your answer.\\n\\n**Time Complexity: O(n)\\nSpace Complexity: O(n)**\\n\\n**C++ Code**\\n```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(auto it: nums){\\n            mp[it]++;\\n        }\\n        for(auto it: mp){\\n            if(it.second>nums.size()/3){\\n                ans.push_back(it.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Approach 2: Optimal Solution (Extended Boyer Moore\\u2019s Voting Algorithm)** \\nIn our code, we start with declaring a few variables:\\n* num1 and num2 will store our currently most frequent and second most frequent element.\\n* c1 and c2 will store their frequency relatively to other numbers.\\n* We are sure that there will be a max of 2 elements which occurs > N/3 times because there cannot be if you do a simple math addition.\\n\\nLet, ele be the element present in the array at any index.\\n* if ele == num1, so we increment c1.\\n* if ele == num2, so we increment c2.\\n* if c1 is 0, so we assign num1 = ele.\\n* if c2 is 0, so we assign num2 = ele.\\n* In all the other cases we decrease both c1 and c2.\\n\\nIn the last step, we will run a loop to check if num1 or nums2 are the majority elements or not by running a for loop check.\\n\\n**Intuition:** Since it\\u2019s guaranteed that a number can be a majority element, hence it will always be present at the last block, hence, in turn, will be on nums1 and nums2.\\n\\n**Time Complexity: O(n)\\nSpace Complexity: O(1)**\\n\\n```\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        //Initiali\\n        vector<int> ans;\\n        int num1=-1;\\n        int num2=-2;\\n        \\n        int c1=0;\\n        int c2=0;\\n        \\n        for(auto el: nums){\\n            if(el==num1) c1++;\\n            else if(el==num2) c2++;\\n            else if(c1==0){\\n                num1=el;\\n                c1++;\\n            }else if(c2==0){\\n                num2=el;\\n                c2++;\\n            }else{\\n                c1--;\\n                c2--;\\n            }\\n        }\\n        \\n        c1=c2=0;\\n        for(auto el: nums){\\n            if(num1==el) c1++;\\n            if(num2==el) c2++;\\n        }\\n        if(c1>nums.size()/3)\\n            ans.push_back(num1);\\n        if(c2>nums.size()/3)\\n            ans.push_back(num2);\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(auto it: nums){\\n            mp[it]++;\\n        }\\n        for(auto it: mp){\\n            if(it.second>nums.size()/3){\\n                ans.push_back(it.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        //Initiali\\n        vector<int> ans;\\n        int num1=-1;\\n        int num2=-2;\\n        \\n        int c1=0;\\n        int c2=0;\\n        \\n        for(auto el: nums){\\n            if(el==num1) c1++;\\n            else if(el==num2) c2++;\\n            else if(c1==0){\\n                num1=el;\\n                c1++;\\n            }else if(c2==0){\\n                num2=el;\\n                c2++;\\n            }else{\\n                c1--;\\n                c2--;\\n            }\\n        }\\n        \\n        c1=c2=0;\\n        for(auto el: nums){\\n            if(num1==el) c1++;\\n            if(num2==el) c2++;\\n        }\\n        if(c1>nums.size()/3)\\n            ans.push_back(num1);\\n        if(c2>nums.size()/3)\\n            ans.push_back(num2);\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2376822,
                "title": "c-solution-using-extended-boyer-moore-s-voting-algorithm-o-1-space",
                "content": "num1 and num2 will store our currently most frequent and second most frequent element.\\nc1 and c2 will store their frequency relatively to other numbers.\\nWe are sure that there will be a max of 2 elements which occurs > N/3 times because there cannot be if you do a simple math addition.\\n\\nif ele == num1, so we increment c1.\\nif ele == num2, so we increment c2.\\nif c1 is 0, so we assign num1 = ele.\\nif c2 is 0, so we assign num2 = ele.\\nIn all the other cases we decrease both c1 and c2.\\n\\nIn the last step, we will run a loop to check if num1 or nums2 are the majority elements or not by running a for loop check.\\n\\n\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        int num1 = 0, num2 = 0, cnt1 = 0, cnt2 = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(num1 == nums[i]){\\n                cnt1++;\\n            }\\n            else if(num2 == nums[i]){\\n                cnt2++;\\n            }\\n            else if(cnt1 == 0){\\n                num1 = nums[i];\\n                cnt1 = 1;\\n            }\\n            else if(cnt2 == 0){\\n                num2 = nums[i];\\n                cnt2 = 1;\\n            }\\n            else{\\n                cnt1--;\\n                cnt2--;\\n            }\\n        }\\n        \\n        cnt1 = 0;\\n        cnt2 = 0;\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            if(nums[i] == num1){\\n                cnt1++;\\n            }\\n            if(nums[i] == num2){\\n                cnt2++;\\n            }\\n            \\n        }\\n        if(cnt1 > n/3 ){\\n            ans.push_back(num1);\\n        }\\n        if(num1!=num2 and cnt2 > n/3){\\n            ans.push_back(num2);\\n        }\\n        \\n        return ans;\\n    }\\n\\t\\n### upvote if it\\'s helpp you HAPPY CODING :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "num1 and num2 will store our currently most frequent and second most frequent element.\\nc1 and c2 will store their frequency relatively to other numbers.\\nWe are sure that there will be a max of 2 elements which occurs > N/3 times because there cannot be if you do a simple math addition.\\n\\nif ele == num1, so we increment c1.\\nif ele == num2, so we increment c2.\\nif c1 is 0, so we assign num1 = ele.\\nif c2 is 0, so we assign num2 = ele.\\nIn all the other cases we decrease both c1 and c2.\\n\\nIn the last step, we will run a loop to check if num1 or nums2 are the majority elements or not by running a for loop check.\\n\\n\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        int num1 = 0, num2 = 0, cnt1 = 0, cnt2 = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(num1 == nums[i]){\\n                cnt1++;\\n            }\\n            else if(num2 == nums[i]){\\n                cnt2++;\\n            }\\n            else if(cnt1 == 0){\\n                num1 = nums[i];\\n                cnt1 = 1;\\n            }\\n            else if(cnt2 == 0){\\n                num2 = nums[i];\\n                cnt2 = 1;\\n            }\\n            else{\\n                cnt1--;\\n                cnt2--;\\n            }\\n        }\\n        \\n        cnt1 = 0;\\n        cnt2 = 0;\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            if(nums[i] == num1){\\n                cnt1++;\\n            }\\n            if(nums[i] == num2){\\n                cnt2++;\\n            }\\n            \\n        }\\n        if(cnt1 > n/3 ){\\n            ans.push_back(num1);\\n        }\\n        if(num1!=num2 and cnt2 > n/3){\\n            ans.push_back(num2);\\n        }\\n        \\n        return ans;\\n    }\\n\\t\\n### upvote if it\\'s helpp you HAPPY CODING :)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2340656,
                "title": "c-bruteforce-better-optimal",
                "content": "# Method-1 [BruteForce]\\n![image](https://assets.leetcode.com/users/images/8d48971d-d6aa-43a6-9970-a20562ba6ae5_1658932972.4202774.png)\\n\\n**TLE at 81st Test Case**\\n**T->O(n * n) && S->O(n)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> majorityElement(vector<int>& nums) {\\n\\t\\t\\tvector<int>ans;\\n\\t\\t\\tunordered_set<int>s;\\n\\t\\t\\tfor(int i=0;i<nums.size();i++){\\n\\t\\t\\t\\tint count=0;\\n\\t\\t\\t\\tfor(int j=0;j<nums.size();j++){\\n\\t\\t\\t\\t\\tif(nums[i]==nums[j])count++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(count>nums.size()/3)s.insert(nums[i]);\\n\\t\\t\\t}\\n\\t\\t\\tfor(auto i:s)ans.push_back(i);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\n\\n\\n# Method-2[Optimal]\\n![image](https://assets.leetcode.com/users/images/907f331c-3603-45e4-bbc7-74e95cee464f_1658918914.8409193.png)\\n\\n**T->O(n) && S->O(n)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> majorityElement(vector<int>& nums) {\\n\\t\\t\\tvector<int>ans;\\n\\t\\t\\tunordered_map<int,int>mp;\\n\\t\\t\\tfor(auto i:nums)mp[i]++;\\n\\t\\t\\tfor(auto i:mp){\\n\\t\\t\\t\\tif(i.second>nums.size()/3)ans.push_back(i.first);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> majorityElement(vector<int>& nums) {\\n\\t\\t\\tvector<int>ans;\\n\\t\\t\\tunordered_set<int>s;\\n\\t\\t\\tfor(int i=0;i<nums.size();i++){\\n\\t\\t\\t\\tint count=0;\\n\\t\\t\\t\\tfor(int j=0;j<nums.size();j++){\\n\\t\\t\\t\\t\\tif(nums[i]==nums[j])count++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1935337,
                "title": "c-boyer-moore-explained",
                "content": "```\\n/////////////////////////////////////////////////////////////////////////////////////\\n// Boyer-Moore voting algorithm\\n// [Explanation] \\n// The key of this prolem is understanding that [n/3] times eppearances,\\n// which means to find the majority for more than ceiling of [n/3], the answer would \\n// be less than or equal to two numbers.\\n//\\n// The algorithm uses O(1) extra space and O(N) time. It requires exactly 2 passes \\n// over the input list. It\\'s also quite simple to implement, though a little trickier \\n// to understand how it works.\\n// In the first pass, we generate 2 candidates\\' values which are the majority values \\n// if there is a majority. The second pass simply counts the frequency of that values to \\n// confirm. The first pass is the interesting part.\\n// In the first pass, we need 2 values:\\n//      (1) 2 candidates\\' value, initially set to any value.\\n//      (2) 2 counters, initially set to 0.\\n// For each element in our input list, we first examine the count value. If the count \\n// is equal to 0, we set the candidate to the value at the current element. Next, first \\n// compare the element\\'s value to the current candidate value. If they are the same, we \\n// increment count by 1. If they are different, we decrement count by 1.\\n/////////////////////////////////////////////////////////////////////////////////////\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int count1 = 0, count2 = 0, candidate1 = nums[0], candidate2 = nums[0];\\n        \\n        // first iteration to find the candidates\\n        for (auto num : nums) {\\n            if (candidate1 == num) count1++;            // check the canididate before calculating the counter.\\n            else if (candidate2 == num) count2++;\\n            else if (count1 == 0) { candidate1 = num; count1 = 1; }\\n            else if (count2 == 0) { candidate2 = num; count2 = 1; }\\n            else { count1--; count2--; }\\n        }\\n        \\n        // second iteration to count the frequency of the candidates\\n        count1 = count2 = 0;\\n        for (auto num : nums) {\\n            if (candidate1 == num) count1++;\\n            // if (candidate2 != candidate1 && candidate2 == num) count2++;\\n            else if (candidate2 == num) count2++;\\n        }\\n\\n        vector<int> result;\\n        if (count1 > nums.size() / 3) result.push_back(candidate1);\\n        if (count2 > nums.size() / 3) result.push_back(candidate2);      \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/////////////////////////////////////////////////////////////////////////////////////\\n// Boyer-Moore voting algorithm\\n// [Explanation] \\n// The key of this prolem is understanding that [n/3] times eppearances,\\n// which means to find the majority for more than ceiling of [n/3], the answer would \\n// be less than or equal to two numbers.\\n//\\n// The algorithm uses O(1) extra space and O(N) time. It requires exactly 2 passes \\n// over the input list. It\\'s also quite simple to implement, though a little trickier \\n// to understand how it works.\\n// In the first pass, we generate 2 candidates\\' values which are the majority values \\n// if there is a majority. The second pass simply counts the frequency of that values to \\n// confirm. The first pass is the interesting part.\\n// In the first pass, we need 2 values:\\n//      (1) 2 candidates\\' value, initially set to any value.\\n//      (2) 2 counters, initially set to 0.\\n// For each element in our input list, we first examine the count value. If the count \\n// is equal to 0, we set the candidate to the value at the current element. Next, first \\n// compare the element\\'s value to the current candidate value. If they are the same, we \\n// increment count by 1. If they are different, we decrement count by 1.\\n/////////////////////////////////////////////////////////////////////////////////////\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int count1 = 0, count2 = 0, candidate1 = nums[0], candidate2 = nums[0];\\n        \\n        // first iteration to find the candidates\\n        for (auto num : nums) {\\n            if (candidate1 == num) count1++;            // check the canididate before calculating the counter.\\n            else if (candidate2 == num) count2++;\\n            else if (count1 == 0) { candidate1 = num; count1 = 1; }\\n            else if (count2 == 0) { candidate2 = num; count2 = 1; }\\n            else { count1--; count2--; }\\n        }\\n        \\n        // second iteration to count the frequency of the candidates\\n        count1 = count2 = 0;\\n        for (auto num : nums) {\\n            if (candidate1 == num) count1++;\\n            // if (candidate2 != candidate1 && candidate2 == num) count2++;\\n            else if (candidate2 == num) count2++;\\n        }\\n\\n        vector<int> result;\\n        if (count1 > nums.size() / 3) result.push_back(candidate1);\\n        if (count2 > nums.size() / 3) result.push_back(candidate2);      \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1801237,
                "title": "boyer-moore-majority-vote-algorithm-two-pass-easy-understanding",
                "content": "```\\n// Boyer\\u2013Moore majority vote algorithm\\n// This is two-pass algo.\\n// pass1:  Evey voter can vote to one candidate. And choose two winner\\n// pass2:  Evey voter vote to those two candiate or vote null. And check if those pass 1/3 threshold or not.\\n// Time/Space complexity: O(N), O(1)\\n// Have a good day.\\nvector<int> majorityElement(vector<int>& nums) {\\n        \\n        vector<int> res;\\n        int len = nums.size();\\n        int m1 = -1, m2 = -1;\\n        int vote1 = 0, vote2 = 0;\\n        \\n        for(auto &c:nums){                //pass1\\n            if(m1 == c) vote1++;\\n            else if(m2 == c) vote2++;\\n            \\n            else if(vote1 == 0){\\n                m1 = c;\\n                vote1++;\\n            }\\n            else if(vote2 == 0){\\n                m2 = c;\\n                vote2++;\\n            }\\n            else{\\n                vote1--;\\n                vote2--;\\n            }\\n        }\\n        \\n        vote1 = 0;\\n        vote2 = 0;\\n        \\n        for(auto &c:nums){                         //pass2\\n            if(m1 == c) vote1++;\\n            else if(m2 == c) vote2++;\\n        }\\n        \\n        if(vote1 > (len/3)) res.push_back(m1);\\n        if(vote2 > (len/3)) res.push_back(m2);\\n        \\n        return res;\\n\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// Boyer\\u2013Moore majority vote algorithm\\n// This is two-pass algo.\\n// pass1:  Evey voter can vote to one candidate. And choose two winner\\n// pass2:  Evey voter vote to those two candiate or vote null. And check if those pass 1/3 threshold or not.\\n// Time/Space complexity: O(N), O(1)\\n// Have a good day.\\nvector<int> majorityElement(vector<int>& nums) {\\n        \\n        vector<int> res;\\n        int len = nums.size();\\n        int m1 = -1, m2 = -1;\\n        int vote1 = 0, vote2 = 0;\\n        \\n        for(auto &c:nums){                //pass1\\n            if(m1 == c) vote1++;\\n            else if(m2 == c) vote2++;\\n            \\n            else if(vote1 == 0){\\n                m1 = c;\\n                vote1++;\\n            }\\n            else if(vote2 == 0){\\n                m2 = c;\\n                vote2++;\\n            }\\n            else{\\n                vote1--;\\n                vote2--;\\n            }\\n        }\\n        \\n        vote1 = 0;\\n        vote2 = 0;\\n        \\n        for(auto &c:nums){                         //pass2\\n            if(m1 == c) vote1++;\\n            else if(m2 == c) vote2++;\\n        }\\n        \\n        if(vote1 > (len/3)) res.push_back(m1);\\n        if(vote2 > (len/3)) res.push_back(m2);\\n        \\n        return res;\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1678500,
                "title": "c-2-solutions-boyer-moore-algo-map",
                "content": "```\\n// Boyer Moore\\'s voting algorithm based (Two Pass Solution)\\n// Time : O(n)\\n// Space : O(1)\\n\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>&a) {\\n        vector<int> ans;\\n        int n = a.size();\\n        \\n        int num1 = INT_MIN;        \\n        int num2 = INT_MIN;\\n        int count1 = 0;        \\n        int count2 = 0;\\n\\t\\t\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]==num1) count1++;\\n            else if(a[i]==num2) count2++;\\n            else if(count1 == 0)\\n            {\\n                num1 = a[i];\\n                count1 = 1;\\n            }\\n            else if(count2 == 0)\\n            {\\n                num2 = a[i];\\n                count2 = 1;\\n            }\\n            else\\n            {\\n                count1--;\\n                count2--;\\n            }\\n        }\\n        count1 = 0;\\n        count2 = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]==num1) count1++;\\n            else if(a[i]==num2) count2++;\\n        }\\n        if(count1>(n/3)) ans.push_back(num1);\\n        if(count2>(n/3)) ans.push_back(num2);\\n        return ans;\\n    }\\n};\\n// Map Based Solution\\n// Time : O(n)\\n// Space : O(n)\\n\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>&nums) {     \\n        int n = nums.size()/3;\\n        vector<int> v;\\n        unordered_map<int, int> a;\\n        int c = 0;\\n        for(int x : nums){\\n            a[x]++;\\n        }\\n        for(auto d : a)\\n            if(d.second > n){\\n                c = d.first;\\n                v.push_back(c);\\n            };\\n        return v;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// Boyer Moore\\'s voting algorithm based (Two Pass Solution)\\n// Time : O(n)\\n// Space : O(1)\\n\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>&a) {\\n        vector<int> ans;\\n        int n = a.size();\\n        \\n        int num1 = INT_MIN;        \\n        int num2 = INT_MIN;\\n        int count1 = 0;        \\n        int count2 = 0;\\n\\t\\t\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]==num1) count1++;\\n            else if(a[i]==num2) count2++;\\n            else if(count1 == 0)\\n            {\\n                num1 = a[i];\\n                count1 = 1;\\n            }\\n            else if(count2 == 0)\\n            {\\n                num2 = a[i];\\n                count2 = 1;\\n            }\\n            else\\n            {\\n                count1--;\\n                count2--;\\n            }\\n        }\\n        count1 = 0;\\n        count2 = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]==num1) count1++;\\n            else if(a[i]==num2) count2++;\\n        }\\n        if(count1>(n/3)) ans.push_back(num1);\\n        if(count2>(n/3)) ans.push_back(num2);\\n        return ans;\\n    }\\n};\\n// Map Based Solution\\n// Time : O(n)\\n// Space : O(n)\\n\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>&nums) {     \\n        int n = nums.size()/3;\\n        vector<int> v;\\n        unordered_map<int, int> a;\\n        int c = 0;\\n        for(int x : nums){\\n            a[x]++;\\n        }\\n        for(auto d : a)\\n            if(d.second > n){\\n                c = d.first;\\n                v.push_back(c);\\n            };\\n        return v;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1607579,
                "title": "o-n-time-o-1-space",
                "content": "class Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n           \\n        int num1 = -1;\\n        int num2 = -1;\\n        int c1 = 0;\\n        int c2 = 0;\\n        \\n        for(int val : nums){\\n            if(val == num1){\\n                c1++;\\n            } else if(val == num2){\\n                c2++;\\n            } else if(c1 == 0){\\n                num1 = val;\\n                c1 = 1;\\n            } else if(c2  == 0){\\n                num2 =  val;\\n                c2 = 1;\\n            } else {\\n                c1--;\\n                c2--;\\n            }\\n        }\\n        \\n        c1 = 0; c2 = 0;\\n        \\n        List<Integer> result = new ArrayList<>();  \\n        for(int i = 0  ; i < nums.length ; i++){\\n            if(nums[i] == num1){\\n                c1++;\\n            } else if(nums[i] == num2){\\n                c2++;\\n            }\\n        }\\n        \\n        if(c1 >  nums.length / 3){\\n            result.add(num1);\\n        }\\n        if( c2  >  nums.length / 3){\\n            result.add(num2);\\n        }\\n        \\n        return result;\\n    }\\n   \\n}",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "class Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n           \\n        int num1 = -1;\\n        int num2 = -1;\\n        int c1 = 0;\\n        int c2 = 0;\\n        \\n        for(int val : nums){\\n            if(val == num1){\\n                c1++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1534712,
                "title": "java-easy-solution-with-explanation-moore-s-voting-algorithm",
                "content": "### Moore\\'s voting algorithm for finding all majority elements\\n\\nTime complexiy - O(n)\\nspace complexity - O(1)\\n\\n**Code**\\n```java\\npublic static List<Integer> majorityElement(int[] nums) {\\n\\tList<Integer> list = new ArrayList<>();\\n\\n\\tInteger num1 = null, num2 = null;\\n\\tint c1 = 0, c2 = 0;\\n\\n\\tfor (int el : nums) {\\n\\t\\tif (num1 != null && el == num1)\\n\\t\\t\\tc1++;\\n\\t\\telse if (num2 != null && el == num2)\\n\\t\\t\\tc2++;\\n\\t\\telse if (c1 == 0) {\\n\\t\\t\\tnum1 = el;\\n\\t\\t\\tc1 = 1;\\n\\t\\t} else if (c2 == 0) {\\n\\t\\t\\tnum2 = el;\\n\\t\\t\\tc2 = 1;\\n\\t\\t} else {\\n\\t\\t\\tc1--;\\n\\t\\t\\tc2--;\\n\\t\\t}\\n\\t}\\n\\n\\tint count = 0;\\n\\tfor (int el : nums) {\\n\\t\\tif (num1 != null && el == num1)\\n\\t\\t\\tcount++;\\n\\t}\\n\\tif (count > nums.length / 3)\\n\\t\\tlist.add(num1);\\n\\n\\tcount = 0;\\n\\tfor (int el : nums) {\\n\\t\\tif (num2 != null && el == num2)\\n\\t\\t\\tcount++;\\n\\t}\\n\\tif (count > nums.length / 3)\\n\\t\\tlist.add(num2);\\n\\treturn list;\\n}\\n```\\n\\n**Explanation**\\n\\nThe algorithm given above is based on some important details in the question, as in this question we are required to find all the elements that occur more than n/3 number of times, there can be only two majority elements.\\n\\nso once we understand that there are only two majority elements, we initialise two integers of `Integer` class because the input also has negative numbers. Also initialise two count variables c1 and c2.\\n\\nnow iterate in the array and use the following logic:-\\n- if `num1 == el` then increment c1\\n- else if `num2 == el` then increment c2\\n- else if `c1==0` set a new value for num1 and increment the count of c1 to 1.\\n- else if `c2 == 0` set a new value for num1 and increment the count of c2 to 1.\\n- else if none of the above holds then decrement both c1 and c2.\\n\\n![image](https://assets.leetcode.com/users/images/28271ada-63e5-4522-a371-27a81d0cacdb_1634901317.6390538.png)\\n\\nthe values that we get at the end of one traversal do not ensure correct values, for that we need to iterate twice again in the array to check the count of both. \\nIt is assured that the majority element would be out of these two if it is present in the array.\\n\\nHope it helps\\nDo like if it helps.\\nThank you\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic static List<Integer> majorityElement(int[] nums) {\\n\\tList<Integer> list = new ArrayList<>();\\n\\n\\tInteger num1 = null, num2 = null;\\n\\tint c1 = 0, c2 = 0;\\n\\n\\tfor (int el : nums) {\\n\\t\\tif (num1 != null && el == num1)\\n\\t\\t\\tc1++;\\n\\t\\telse if (num2 != null && el == num2)\\n\\t\\t\\tc2++;\\n\\t\\telse if (c1 == 0) {\\n\\t\\t\\tnum1 = el;\\n\\t\\t\\tc1 = 1;\\n\\t\\t} else if (c2 == 0) {\\n\\t\\t\\tnum2 = el;\\n\\t\\t\\tc2 = 1;\\n\\t\\t} else {\\n\\t\\t\\tc1--;\\n\\t\\t\\tc2--;\\n\\t\\t}\\n\\t}\\n\\n\\tint count = 0;\\n\\tfor (int el : nums) {\\n\\t\\tif (num1 != null && el == num1)\\n\\t\\t\\tcount++;\\n\\t}\\n\\tif (count > nums.length / 3)\\n\\t\\tlist.add(num1);\\n\\n\\tcount = 0;\\n\\tfor (int el : nums) {\\n\\t\\tif (num2 != null && el == num2)\\n\\t\\t\\tcount++;\\n\\t}\\n\\tif (count > nums.length / 3)\\n\\t\\tlist.add(num2);\\n\\treturn list;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1523553,
                "title": "java-generic-solution-for-n-k",
                "content": "```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        int k=3;\\n        List<Integer> result = new ArrayList<>();\\n        \\n        if(nums.length <= k-1){\\n            Set<Integer> set = new HashSet<>(k);\\n            for(int n : nums){\\n                set.add(n);\\n            }\\n            return new ArrayList<>(set);\\n        }\\n        \\n        Integer[] counts = new Integer[k-1];\\n        Arrays.fill(counts,0);\\n        Integer[] candidates = new Integer[k-1];\\n        \\n        for(int n : nums){\\n            populateCandidate(counts,candidates,n,k-1);\\n        }\\n        \\n        Arrays.fill(counts,0);\\n        for(int n : nums){\\n            updateCount(counts,candidates,n,k-1);\\n        }\\n        \\n        int threshold = nums.length/k;\\n        for(int i=0;i<k-1;i++){\\n            if(counts[i] > threshold){\\n                result.add(candidates[i]);\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private boolean updateCount(Integer[] counts,Integer[] candidates,int n,int k){\\n        for(int i=0;i<k;i++){\\n            if(candidates[i] != null && candidates[i] == n){\\n                counts[i]++;\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private void populateCandidate(Integer[] counts,Integer[] candidates,int n,int k){\\n        \\n        if(updateCount(counts,candidates,n,k)){\\n            return;\\n        }\\n        \\n        for(int i=0;i<k;i++){\\n            if(counts[i] == 0){\\n                candidates[i] = n;\\n                counts[i]++;\\n                return;\\n            }\\n        }\\n        for(int i=0;i<k;i++){\\n            counts[i]--;\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        int k=3;\\n        List<Integer> result = new ArrayList<>();\\n        \\n        if(nums.length <= k-1){\\n            Set<Integer> set = new HashSet<>(k);\\n            for(int n : nums){\\n                set.add(n);\\n            }\\n            return new ArrayList<>(set);\\n        }\\n        \\n        Integer[] counts = new Integer[k-1];\\n        Arrays.fill(counts,0);\\n        Integer[] candidates = new Integer[k-1];\\n        \\n        for(int n : nums){\\n            populateCandidate(counts,candidates,n,k-1);\\n        }\\n        \\n        Arrays.fill(counts,0);\\n        for(int n : nums){\\n            updateCount(counts,candidates,n,k-1);\\n        }\\n        \\n        int threshold = nums.length/k;\\n        for(int i=0;i<k-1;i++){\\n            if(counts[i] > threshold){\\n                result.add(candidates[i]);\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private boolean updateCount(Integer[] counts,Integer[] candidates,int n,int k){\\n        for(int i=0;i<k;i++){\\n            if(candidates[i] != null && candidates[i] == n){\\n                counts[i]++;\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private void populateCandidate(Integer[] counts,Integer[] candidates,int n,int k){\\n        \\n        if(updateCount(counts,candidates,n,k)){\\n            return;\\n        }\\n        \\n        for(int i=0;i<k;i++){\\n            if(counts[i] == 0){\\n                candidates[i] = n;\\n                counts[i]++;\\n                return;\\n            }\\n        }\\n        for(int i=0;i<k;i++){\\n            counts[i]--;\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1483430,
                "title": "python-95-faster-in-speed",
                "content": "```python\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        return [x for x in set(nums) if nums.count(x) > len(nums)/3]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        return [x for x in set(nums) if nums.count(x) > len(nums)/3]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1455496,
                "title": "easy-c-solution-using-moore-voting-algorithm-in-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        //moore voting algorithm\\n        vector<int>v;\\n        int num1=-1,num2=-1,c1=0,c2=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==num1){\\n                c1++;\\n            }\\n            else if(nums[i]==num2){\\n                c2++;\\n            }\\n            else if(c1==0){\\n                num1=nums[i]; \\n                c1=1;\\n            }\\n            else if(c2==0){\\n                num2=nums[i];\\n                c2=1;\\n            }\\n            else{\\n                c1--;\\n                c2--;\\n            }\\n        \\n        int r=0,r1=0;\\n         for(int i=0;i<nums.size();i++){\\n             if(nums[i]==num1){\\n                 r++;\\n             }\\n             else if(nums[i]==num2){\\n                 r1++;\\n             }\\n         }\\n        if(r>nums.size()/3){\\n            v.push_back(num1);\\n        }\\n        if(r1>nums.size()/3){\\n            v.push_back(num2);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        //moore voting algorithm\\n        vector<int>v;\\n        int num1=-1,num2=-1,c1=0,c2=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==num1){\\n                c1++;\\n            }\\n            else if(nums[i]==num2){\\n                c2++;\\n            }\\n            else if(c1==0){\\n                num1=nums[i]; \\n                c1=1;\\n            }\\n            else if(c2==0){\\n                num2=nums[i];\\n                c2=1;\\n            }\\n            else{\\n                c1--;\\n                c2--;\\n            }\\n        \\n        int r=0,r1=0;\\n         for(int i=0;i<nums.size();i++){\\n             if(nums[i]==num1){\\n                 r++;\\n             }\\n             else if(nums[i]==num2){\\n                 r1++;\\n             }\\n         }\\n        if(r>nums.size()/3){\\n            v.push_back(num1);\\n        }\\n        if(r1>nums.size()/3){\\n            v.push_back(num2);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1378469,
                "title": "c-o-n-time-moore-voting-algorithm",
                "content": "```\\nvector<int> majorityElement(vector<int>& nums) \\n    {\\n       int num1 =INT_MIN, num2 =INT_MIN;\\n       int cnt1=0,cnt2=0;\\n        \\n       int n=nums.size();\\n        \\n       for(int i=0;i<n;i++)\\n       {\\n           if(nums[i]==num1)\\n               cnt1++;\\n           else if(nums[i]==num2)\\n               cnt2++;\\n           else if(cnt1==0)\\n           {\\n               num1=nums[i];\\n               cnt1=1;\\n           }\\n           else if(cnt2==0)\\n           {\\n               num2=nums[i];\\n               cnt2=1;\\n           }\\n           else\\n           {\\n               cnt1--;\\n               cnt2--;\\n           }\\n       }\\n        cnt1=0;cnt2=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(num1==nums[i]) cnt1++;\\n            else if(num2==nums[i]) cnt2++;\\n        }\\n        vector<int>ans;\\n        if(cnt1>n/3) ans.push_back(num1);\\n        if(cnt2>n/3) ans.push_back(num2);\\n        \\n        return ans;\\n    }\\nIf you got any help from this please upvote :)\\t",
                "solutionTags": [],
                "code": "```\\nvector<int> majorityElement(vector<int>& nums) \\n    {\\n       int num1 =INT_MIN, num2 =INT_MIN;\\n       int cnt1=0,cnt2=0;\\n        \\n       int n=nums.size();\\n        \\n       for(int i=0;i<n;i++)\\n       {\\n           if(nums[i]==num1)\\n               cnt1++;\\n           else if(nums[i]==num2)\\n               cnt2++;\\n           else if(cnt1==0)\\n           {\\n               num1=nums[i];\\n               cnt1=1;\\n           }\\n           else if(cnt2==0)\\n           {\\n               num2=nums[i];\\n               cnt2=1;\\n           }\\n           else\\n           {\\n               cnt1--;\\n               cnt2--;\\n           }\\n       }\\n        cnt1=0;cnt2=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(num1==nums[i]) cnt1++;\\n            else if(num2==nums[i]) cnt2++;\\n        }\\n        vector<int>ans;\\n        if(cnt1>n/3) ans.push_back(num1);\\n        if(cnt2>n/3) ans.push_back(num2);\\n        \\n        return ans;\\n    }\\nIf you got any help from this please upvote :)\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1371862,
                "title": "c-o-1-space-boyer-moore-voting-algorithm",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int nums1=-1,nums2=-1,c1=0,c2=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==nums1)\\n                c1++;\\n            else if(nums[i]==nums2)\\n                c2++;\\n            else if(c1==0){\\n                nums1=nums[i];\\n                c1=1;\\n            }else if(c2==0){\\n                nums2=nums[i];\\n                c2=1;\\n            }else{\\n                c1--;\\n                c2--;\\n            }\\n        }\\n        int ch1=0,ch2=0;\\n        for(auto n:nums){\\n            if(n==nums1)\\n                ch1++;\\n            else if(n==nums2)\\n                ch2++;\\n        }\\n        int a1=0,a2=0;\\n        cout<<nums.size()/3<<endl;\\n        if(ch1>(int)nums.size()/3)\\n            a1=1;\\n        if(ch2>(int)nums.size()/3)\\n            a2=1;\\n        cout<<ch1<<\" \"<<ch2<<endl;\\n        vector<int> ans;\\n        if(a1)\\n            ans.push_back(nums1);\\n        if(a2)\\n            ans.push_back(nums2);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int nums1=-1,nums2=-1,c1=0,c2=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==nums1)\\n                c1++;\\n            else if(nums[i]==nums2)\\n                c2++;\\n            else if(c1==0){\\n                nums1=nums[i];\\n                c1=1;\\n            }else if(c2==0){\\n                nums2=nums[i];\\n                c2=1;\\n            }else{\\n                c1--;\\n                c2--;\\n            }\\n        }\\n        int ch1=0,ch2=0;\\n        for(auto n:nums){\\n            if(n==nums1)\\n                ch1++;\\n            else if(n==nums2)\\n                ch2++;\\n        }\\n        int a1=0,a2=0;\\n        cout<<nums.size()/3<<endl;\\n        if(ch1>(int)nums.size()/3)\\n            a1=1;\\n        if(ch2>(int)nums.size()/3)\\n            a2=1;\\n        cout<<ch1<<\" \"<<ch2<<endl;\\n        vector<int> ans;\\n        if(a1)\\n            ans.push_back(nums1);\\n        if(a2)\\n            ans.push_back(nums2);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1198522,
                "title": "problem-229-two-c-solutions-with-clear-explanations",
                "content": "### Solution 1: Map\\n\\nI solved this problem in linear time but not constant space with a very straightforward approach. We use a map to count the number of occurrences of each element. Then we go through the map and find any elements with more than floor(n/3) occurrences. This works and is very simple. Here\\'s the code:\\n\\n```cpp\\nvector<int> majorityElement(vector<int>& nums) {\\n  vector<int> ans;\\n  int threshold = nums.size() / 3;\\n  map<int, int> counts;\\n  for (int n : nums) counts[n]++;\\n\\n  for (auto[k, v] : counts) {\\n    if (v > threshold) ans.push_back(k);\\n  }\\n\\n  return ans;\\n}\\n```\\n\\n### Solution 2: Boyer-Moore\\n\\nI thought for a few minutes about how to do it in linear time and constant space and I couldn\\'t figure it out. One idea was to sort the list because then repeated elements would be grouped, but that wouldn\\'t be linear time. So I looked at the solution and learned about the Boyer-Moore voting algorithm, which is very interesting.\\n\\nSuppose we\\'re looking for elements with more than floor(n/2) occurrences. The idea is that we take the first element of the list as our first candidate and we keep a count starting at 1. Then we go through the list and if we see our candidate, we increment our count, otherwise we decrement it. Then if the count reaches 0, we update the candidate on the next iteration. If there is a majority element, it will be our final candidate because a majority element would have more increments than decrements.\\n\\nNow how do we extend this to find elements with more than floor(n/3) occurrences? First notice that there could be at most 2 such elements. We do basically the same thing but with 2 candidates at a time instead of 1. If there is an element with the desired property, it will be one of the candidates at the end because it\\'ll increment at least floor(n/3) times so to be neither of the candidates, it would need to be decremented more than floor(n/3) times by at least 2 different elements, but that\\'s not possible because that would require more than n elements.\\n\\nThis approach is interesting but in real life, I would stick with the first idea.\\n\\n```cpp\\nvector<int> majorityElement(vector<int>& nums) {\\n  if (nums.size() == 1) return nums;\\n\\n  int cand1 = INT_MIN, cand2 = INT_MIN;\\n  int count1 = 0, count2 = 0;\\n  for (int i = 0; i < nums.size(); i++) {\\n    if (nums[i] == cand1)\\n      count1++;\\n    else if (nums[i] == cand2)\\n      count2++;\\n    else if (count1 == 0) {\\n      cand1 = nums[i];\\n      count1++;\\n    } else if (count2 == 0) {\\n      cand2 = nums[i];\\n      count2++;\\n    } else {\\n      count1--;\\n      count2--;\\n    }\\n  }\\n\\n  count1 = 0;\\n  count2 = 0;\\n  for (int n : nums) {\\n    if (n == cand1)\\n      count1++;\\n    else if (n == cand2)\\n      count2++;\\n  }\\n  int threshold = nums.size() / 3;\\n  vector<int> ans;\\n  if (count1 > threshold) ans.push_back(cand1);\\n  if (count2 > threshold) ans.push_back(cand2);\\n\\n  return ans;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nvector<int> majorityElement(vector<int>& nums) {\\n  vector<int> ans;\\n  int threshold = nums.size() / 3;\\n  map<int, int> counts;\\n  for (int n : nums) counts[n]++;\\n\\n  for (auto[k, v] : counts) {\\n    if (v > threshold) ans.push_back(k);\\n  }\\n\\n  return ans;\\n}\\n```\n```cpp\\nvector<int> majorityElement(vector<int>& nums) {\\n  if (nums.size() == 1) return nums;\\n\\n  int cand1 = INT_MIN, cand2 = INT_MIN;\\n  int count1 = 0, count2 = 0;\\n  for (int i = 0; i < nums.size(); i++) {\\n    if (nums[i] == cand1)\\n      count1++;\\n    else if (nums[i] == cand2)\\n      count2++;\\n    else if (count1 == 0) {\\n      cand1 = nums[i];\\n      count1++;\\n    } else if (count2 == 0) {\\n      cand2 = nums[i];\\n      count2++;\\n    } else {\\n      count1--;\\n      count2--;\\n    }\\n  }\\n\\n  count1 = 0;\\n  count2 = 0;\\n  for (int n : nums) {\\n    if (n == cand1)\\n      count1++;\\n    else if (n == cand2)\\n      count2++;\\n  }\\n  int threshold = nums.size() / 3;\\n  vector<int> ans;\\n  if (count1 > threshold) ans.push_back(cand1);\\n  if (count2 > threshold) ans.push_back(cand2);\\n\\n  return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1141614,
                "title": "java-time-1ms-and-constant-space-boyer-moore-majority-vote-algorithm",
                "content": "I found a great article (http://goo.gl/64Nams) that helps me to understand this fantastic algorithm!!\\n\\n```\\npublic List<Integer> majorityElement(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        int s = nums.length;\\n        int candidate1 = 0, count1 = 0;\\n        int candidate2 = 0, count2 = 0;\\n\\t\\t\\n        for(int num: nums){\\n            if(num == candidate1){\\n                count1++;\\n            }\\n            else if(num == candidate2){\\n                count2++;\\n            }\\n            else if(count1==0){\\n                candidate1 = num;\\n                count1++;\\n            }\\n            else if(count2 == 0){\\n                candidate2 = num;\\n                count2++;\\n            }\\n            else{\\n                count1--;\\n                count2--;\\n            }\\n        }\\n        count1 = 0; count2 = 0;\\n        \\n        //Verfy both candidate1 and candidate2\\n        for(int num: nums){\\n            if(num == candidate1) count1++;\\n            else if(num== candidate2) count2++;\\n        }\\n        if(count1>s/3) res.add(candidate1);\\n        if(count2>s/3) res.add(candidate2);\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> majorityElement(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        int s = nums.length;\\n        int candidate1 = 0, count1 = 0;\\n        int candidate2 = 0, count2 = 0;\\n\\t\\t\\n        for(int num: nums){\\n            if(num == candidate1){\\n                count1++;\\n            }\\n            else if(num == candidate2){\\n                count2++;\\n            }\\n            else if(count1==0){\\n                candidate1 = num;\\n                count1++;\\n            }\\n            else if(count2 == 0){\\n                candidate2 = num;\\n                count2++;\\n            }\\n            else{\\n                count1--;\\n                count2--;\\n            }\\n        }\\n        count1 = 0; count2 = 0;\\n        \\n        //Verfy both candidate1 and candidate2\\n        for(int num: nums){\\n            if(num == candidate1) count1++;\\n            else if(num== candidate2) count2++;\\n        }\\n        if(count1>s/3) res.add(candidate1);\\n        if(count2>s/3) res.add(candidate2);\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1070836,
                "title": "c-99-faster-solution-boyer-moore-voting-algorithm",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int ele1=0,ele2=0,c1=0,c2=0;\\n        int me = nums.size()/3;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(ele1 == nums[i])\\n                c1++;\\n            else if(ele2 == nums[i])\\n                c2++;\\n            else if(c1 == 0)\\n            {\\n                ele1=nums[i];\\n                c1=1;\\n            }\\n            else if(c2 == 0)\\n            {\\n                ele2=nums[i];\\n                c2=1;\\n            }\\n            else\\n            {\\n                c1--;\\n                c2--;\\n            }\\n        }\\n        vector<int> ans;\\n        c1=0,c2=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i] == ele1)\\n                c1++;\\n            else if(nums[i] == ele2)\\n                c2++;\\n        }\\n        if(c1 > me)\\n            ans.push_back(ele1);\\n        if(c2 > me)\\n            ans.push_back(ele2);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int ele1=0,ele2=0,c1=0,c2=0;\\n        int me = nums.size()/3;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(ele1 == nums[i])\\n                c1++;\\n            else if(ele2 == nums[i])\\n                c2++;\\n            else if(c1 == 0)\\n            {\\n                ele1=nums[i];\\n                c1=1;\\n            }\\n            else if(c2 == 0)\\n            {\\n                ele2=nums[i];\\n                c2=1;\\n            }\\n            else\\n            {\\n                c1--;\\n                c2--;\\n            }\\n        }\\n        vector<int> ans;\\n        c1=0,c2=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i] == ele1)\\n                c1++;\\n            else if(nums[i] == ele2)\\n                c2++;\\n        }\\n        if(c1 > me)\\n            ans.push_back(ele1);\\n        if(c2 > me)\\n            ans.push_back(ele2);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1012765,
                "title": "java-version-boyer-moore-majority-vote-algorithm",
                "content": "```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        List<Integer> res = new ArrayList<> ();\\n        if (nums == null || nums.length == 0) return res;\\n        int cnt1 = 0, candidate1 = nums[0], cnt2 = 0, candidate2 = nums[0];\\n        for (int n : nums) {\\n            if (n == candidate1) {\\n                cnt1++;\\n            } else if (n == candidate2) {\\n                cnt2++;\\n            } else if (cnt1 == 0) {\\n                candidate1 = n;\\n                cnt1 = 1;\\n            } else if (cnt2 == 0) {\\n                candidate2 = n;\\n                cnt2 = 1;\\n            } else {\\n                cnt1--;\\n                cnt2--;\\n            }\\n        }\\n\\n        cnt1 = 0; \\n        cnt2 = 0;\\n        for (int n : nums) {\\n            if (n == candidate1) {\\n                cnt1++;\\n            } else if (n == candidate2) {\\n                cnt2++;\\n            }\\n        }\\n        if (cnt1 > nums.length / 3) {\\n            res.add(candidate1);\\n        }\\n        if (cnt2 > nums.length / 3) {\\n            res.add(candidate2);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        List<Integer> res = new ArrayList<> ();\\n        if (nums == null || nums.length == 0) return res;\\n        int cnt1 = 0, candidate1 = nums[0], cnt2 = 0, candidate2 = nums[0];\\n        for (int n : nums) {\\n            if (n == candidate1) {\\n                cnt1++;\\n            } else if (n == candidate2) {\\n                cnt2++;\\n            } else if (cnt1 == 0) {\\n                candidate1 = n;\\n                cnt1 = 1;\\n            } else if (cnt2 == 0) {\\n                candidate2 = n;\\n                cnt2 = 1;\\n            } else {\\n                cnt1--;\\n                cnt2--;\\n            }\\n        }\\n\\n        cnt1 = 0; \\n        cnt2 = 0;\\n        for (int n : nums) {\\n            if (n == candidate1) {\\n                cnt1++;\\n            } else if (n == candidate2) {\\n                cnt2++;\\n            }\\n        }\\n        if (cnt1 > nums.length / 3) {\\n            res.add(candidate1);\\n        }\\n        if (cnt2 > nums.length / 3) {\\n            res.add(candidate2);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 862750,
                "title": "java-solution-using-hashmap",
                "content": "Algorithm:\\n1. Store the count of each integer in a hashmap.\\n2. Get the key where value is greater than n/3.\\n```\\npublic List<Integer> majorityElement(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i: nums)\\n            map.put(i, map.getOrDefault(i, 0) + 1);\\n        \\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            int key = entry.getKey();\\n            int value = entry.getValue();\\n            if(value > (nums.length/3))\\n                list.add(key);\\n        }\\n        return list;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> majorityElement(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i: nums)\\n            map.put(i, map.getOrDefault(i, 0) + 1);\\n        \\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            int key = entry.getKey();\\n            int value = entry.getValue();\\n            if(value > (nums.length/3))\\n                list.add(key);\\n        }\\n        return list;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 858881,
                "title": "python-simple-and-clear-solution-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        my_dict = defaultdict(int)\\n        for n in nums:\\n            my_dict[n]+=1\\n\\t\\t\\t# it isO(1) space because when it becomes more than 2 we remove one, so it stays 2 all the time\\n            if len(my_dict) == 3:\\n                dic = defaultdict(int)\\n                for key, val in my_dict.items():\\n                    if val > 1:\\n                        dic[key] = val-1\\n                \\n                my_dict = dic\\n        # double check - we can get wrong results\\n        return [n for n in my_dict.keys() if nums.count(n) > len(nums)/3]\\n                \\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        my_dict = defaultdict(int)\\n        for n in nums:\\n            my_dict[n]+=1\\n\\t\\t\\t# it isO(1) space because when it becomes more than 2 we remove one, so it stays 2 all the time\\n            if len(my_dict) == 3:\\n                dic = defaultdict(int)\\n                for key, val in my_dict.items():\\n                    if val > 1:\\n                        dic[key] = val-1\\n                \\n                my_dict = dic\\n        # double check - we can get wrong results\\n        return [n for n in my_dict.keys() if nums.count(n) > len(nums)/3]\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 753977,
                "title": "generalized-majority-voting-algo-with-detailed-graphic-explanation-o-n-time-o-1-space",
                "content": "I read many solutions here but none explained in detail why it works, it took me asking people and thinking about it a long time to understand the algorithm. So I wanted to share how I understood the algorithm. Hope this is helpful to visual thinkers like myself.\\n\\nLets take this array: [2,3,3,1,1,3,2] and think of it like we are putting votes down ballot boxes, with each number into its own ballot. For example, we put 2 votes down box 1, because there are 2 occurrences of 1, and so forth.\\n```\\n 1 2 3\\n| | |*|\\n|*|*|*|\\n|*|*|*|\\n```\\nWe notice that 3 quite literally comes out on top of other columns, and thats how we can tell it is a 1/3 majority. Notice that the bottom two rows of vote \"cancel each other out\", and the column with extra votes is the \"winner\". \\n\\nNow, this array coincidentally has 3 elements, and each element gets its own column, how do we do it when we have more than 3 unique elements?\\n\\nConsider this array: [2,3,3,1,3,2,4]\\n\\nI just swapped one of the 1s out with a 4. In which ballot box should we put the 4? (remember, our goal is to be able to identify the 1/3 majority(s)) \\n```\\n 1 2 3\\n| | |*|\\n| |*|*|\\n|*|*|*|\\n```\\n\\nWe see that since \"1\" only have one vote, and so does \"4\". Assuming that this is that last vote to count, we can put them together into a generic ballot box because neither would be 1/3 majority anyways. (I know this sounds mean but this is just an example, not real life!)\\n\\nSo we have put the \"4\" into the column where \"1\" is in and renamed the column to \"others\" or \"O\"\\n\\n```\\n\"O\"2 3\\n| | |*|\\n|*|*|*|\\n|*|*|*|\\n```\\n\\nYou might ask, but what if there is a lot of 1\\'s in the back and 1 turns out to be a majority? We will revisit that in a moment, but what is important now is that **at this point in time all of the 1/3 majority elements(within the visited part of the array) are in a identifiable column,** that is, a column that is not \"others\". (also note that we only care about the already visited part of the array)\\n\\nNow, let\\'s revisit what if 1 turns out to be a 1/3 majority element. Our original array was [2,3,3,1,3,2,4], let\\'s extend it to [2,3,3,1,3,2,4,1,1,1]. Now it is not only **a** 1/3 majority, it is also **the only** 1/3 majority. Right now, we can either put the next 1 in \"other\" column or kick out one of the defending champions.\\n\\n```\\n\"O\"2 3\\n| | |*|\\n|*|*|*|\\n|*|*|*|\\n```\\nFirst, let\\'s try putting it in the \"other\" column.\\n```\\n\"O\"2 3\\n|*| |*|\\n|*|*|*|\\n|*|*|*|\\n```\\nWe can see that \"other\" column now exceeds one of the named columns. What this means is that at this point in time (1) 2 is *definitely* not a 1/3 majority and (2) \"other\" column *might* all be the same number and is in fact, a 1/3 majority. We know what the elements are and that they are not all the same, but the algorithm does not \"remember\" what the elements in \"other\" are(because it is generic), so to satisfy our invariant that **all** of the **possible** 1/3 majority elements should be in a named column, we need to give this new \"1\" the benefit of the doubt and swap 2\\'s ballot box with the \"others\" ballot box, and now 2\\'s ballot box becomes generic and the former generic ballot box gets 1\\'s name on it(I know, not how an election should work). In the future,  if 2 becomes a 1/3 majority, it will climb its way back into a named column using this same mechanism.\\n\\nThen we can add our remaining 2 votes for candidate 1 into 1\\'s ballot box. The algorithm ends with 1 and 3 in the identifiable columns--the invariant holds. \\n\\n```\\n\"O\"1 3\\n| |*| |\\n| |*| |\\n| |*|*|\\n|*|*|*|\\n|*|*|*|\\n```\\n\\nRemember that although we guaranteed all of the 1/3 majority elements end up in an identifiable column, we didn\\'t guarantee that all named column elements are 1/3 majority. So we need to go through the array again to get the counts of these two candidates, and actually check for majority status this time. (the election is fair after all :) )\\n\\nHere is an algorithm to implement the above logic:\\n```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        \\n        # 3 column tetris: candidate A, candidate B, and others\\n        # we know that if any candidate is going to be > 1/3 it has to \\n        # \"survive\" the tetris game and come out on top\\n        candA, countA = 0,0\\n        candB, countB = 0,0\\n        others = 0\\n        \\n        for n in nums:\\n            # if there is a hit, increment that candidate\\n            if candA == n:\\n                countA += 1\\n            elif candB == n:\\n                countB += 1\\n            else:\\n                # if there is no match, increment the \"other\" column\\n                others += 1\\n            # if the \"other\" column surpasses either of the two candidates, that candidate is no longer a 1/3 majority, then we make the \"other\" column the new candidate A\\n            if others > countA:\\n                others, countA = countA, others\\n                candA = n\\n            elif others > countB:\\n                others, countB = countB, others\\n                candB = n\\n        \\n        # the remaining candidates might not be 1/3 but any 1/3 majority has to be in the remaining candidates\\n        countA = countB = 0\\n        for n in nums:\\n            if candA == n:\\n                countA += 1\\n            elif candB == n:\\n                countB += 1\\n        \\n        res = []\\n        if countA > len(nums) // 3:\\n            res.append(candA)\\n        if countB > len(nums) // 3:\\n            res.append(candB)\\n            \\n        return res\\n            \\n```\\n\\nA simple optimization is that instead of keeping a \"others\" column, you can simply reduce candidate A and candidate B\\'s votes by one when you get a \"other\" vote, think of it as cancelling them out. And when one of the candidates hit \"0\", it means that the \"other\" column has caught on and its time to give the new candidate benefit of the doubt--a dedicated ballot box.\\n\\n```\\n...\\n        for n in nums:\\n            # if there is a hit, increment that candidate\\n            if candA == n:\\n                countA += 1\\n            elif candB == n:\\n                countB += 1\\n\\t\\t\\telif countA == 0:\\n\\t\\t\\t\\t# \"other\" column surpasses candidate A, replace candidate A\\n\\t\\t\\t\\tcandA = n\\n\\t\\t\\t\\tcountA = 1\\n\\t\\t\\telif countB == 0:\\n\\t\\t\\t\\t# \"other\" column surpasses candidate B, replace candidate B\\n\\t\\t\\t\\tcandB = n\\n\\t\\t\\t\\tcountB = 1\\n            else:\\n                # if there is no match, cancel out the two candidates votes\\n                countA -= 1\\n\\t\\t\\t\\tcountB -= 1\\n...\\n```",
                "solutionTags": [],
                "code": "```\\n 1 2 3\\n| | |*|\\n|*|*|*|\\n|*|*|*|\\n```\n```\\n 1 2 3\\n| | |*|\\n| |*|*|\\n|*|*|*|\\n```\n```\\n\"O\"2 3\\n| | |*|\\n|*|*|*|\\n|*|*|*|\\n```\n```\\n\"O\"2 3\\n| | |*|\\n|*|*|*|\\n|*|*|*|\\n```\n```\\n\"O\"2 3\\n|*| |*|\\n|*|*|*|\\n|*|*|*|\\n```\n```\\n\"O\"1 3\\n| |*| |\\n| |*| |\\n| |*|*|\\n|*|*|*|\\n|*|*|*|\\n```\n```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        \\n        # 3 column tetris: candidate A, candidate B, and others\\n        # we know that if any candidate is going to be > 1/3 it has to \\n        # \"survive\" the tetris game and come out on top\\n        candA, countA = 0,0\\n        candB, countB = 0,0\\n        others = 0\\n        \\n        for n in nums:\\n            # if there is a hit, increment that candidate\\n            if candA == n:\\n                countA += 1\\n            elif candB == n:\\n                countB += 1\\n            else:\\n                # if there is no match, increment the \"other\" column\\n                others += 1\\n            # if the \"other\" column surpasses either of the two candidates, that candidate is no longer a 1/3 majority, then we make the \"other\" column the new candidate A\\n            if others > countA:\\n                others, countA = countA, others\\n                candA = n\\n            elif others > countB:\\n                others, countB = countB, others\\n                candB = n\\n        \\n        # the remaining candidates might not be 1/3 but any 1/3 majority has to be in the remaining candidates\\n        countA = countB = 0\\n        for n in nums:\\n            if candA == n:\\n                countA += 1\\n            elif candB == n:\\n                countB += 1\\n        \\n        res = []\\n        if countA > len(nums) // 3:\\n            res.append(candA)\\n        if countB > len(nums) // 3:\\n            res.append(candB)\\n            \\n        return res\\n            \\n```\n```\\n...\\n        for n in nums:\\n            # if there is a hit, increment that candidate\\n            if candA == n:\\n                countA += 1\\n            elif candB == n:\\n                countB += 1\\n\\t\\t\\telif countA == 0:\\n\\t\\t\\t\\t# \"other\" column surpasses candidate A, replace candidate A\\n\\t\\t\\t\\tcandA = n\\n\\t\\t\\t\\tcountA = 1\\n\\t\\t\\telif countB == 0:\\n\\t\\t\\t\\t# \"other\" column surpasses candidate B, replace candidate B\\n\\t\\t\\t\\tcandB = n\\n\\t\\t\\t\\tcountB = 1\\n            else:\\n                # if there is no match, cancel out the two candidates votes\\n                countA -= 1\\n\\t\\t\\t\\tcountB -= 1\\n...\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720764,
                "title": "easy-cpp-sol-in-o-n-time-and-constant-space-using-moore-s-algo",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        vector<int>ans;\\n        int count1=0,count2=0,first=INT_MAX,second=INT_MAX;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==first){\\n                count1++;\\n            }else if(nums[i]==second){\\n                count2++;\\n            }else if(count1==0){\\n                count1++;\\n                first=nums[i];\\n            }else if(count2==0){\\n                count2++;\\n                second=nums[i];\\n            }else{\\n                count1--;\\n                count2--;\\n            }\\n        }\\n        count1=0;\\n        count2=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==first){\\n                count1++;\\n            }else if(nums[i]==second){\\n                count2++;\\n            }\\n        }\\n        if(count1>n/3){\\n            ans.push_back(first);\\n        }\\n        if(count2>n/3){\\n            ans.push_back(second);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 613135,
                "title": "c-o-n-boyer-moore-majority-vote-algorithm",
                "content": "```\\npublic class Solution {\\n    public IList<int> MajorityElement(int[] nums) {\\n        List<int> list = new List<int>();\\n        int limit = nums.Length / 3;\\n        int[] votes = new int[2];\\n        int[] candidates = new int[2];\\n        foreach (int n in nums) {\\n            if (n == candidates[0]) {\\n                votes[0]++;\\n            }\\n            else if (n == candidates[1]) {\\n                votes[1]++;\\n            }\\n            else if (votes[0] == 0) {\\n                candidates[0] = n;\\n                votes[0] = 1;\\n            }\\n            else if (votes[1] == 0) {\\n                candidates[1] = n;\\n                votes[1] = 1;\\n            }\\n            else {\\n                votes[0]--;\\n                votes[1]--;\\n            }\\n        }\\n        \\n        votes = new int[2];\\n        foreach (int n in nums) {\\n            if (n == candidates[0])\\n                votes[0]++;\\n            else if (n == candidates[1])\\n                votes[1]++;\\n        }\\n\\n        if (votes[0] > limit)\\n            list.Add(candidates[0]);\\n        if (votes[1] > limit)\\n            list.Add(candidates[1]);\\n        \\n        return list;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<int> MajorityElement(int[] nums) {\\n        List<int> list = new List<int>();\\n        int limit = nums.Length / 3;\\n        int[] votes = new int[2];\\n        int[] candidates = new int[2];\\n        foreach (int n in nums) {\\n            if (n == candidates[0]) {\\n                votes[0]++;\\n            }\\n            else if (n == candidates[1]) {\\n                votes[1]++;\\n            }\\n            else if (votes[0] == 0) {\\n                candidates[0] = n;\\n                votes[0] = 1;\\n            }\\n            else if (votes[1] == 0) {\\n                candidates[1] = n;\\n                votes[1] = 1;\\n            }\\n            else {\\n                votes[0]--;\\n                votes[1]--;\\n            }\\n        }\\n        \\n        votes = new int[2];\\n        foreach (int n in nums) {\\n            if (n == candidates[0])\\n                votes[0]++;\\n            else if (n == candidates[1])\\n                votes[1]++;\\n        }\\n\\n        if (votes[0] > limit)\\n            list.Add(candidates[0]);\\n        if (votes[1] > limit)\\n            list.Add(candidates[1]);\\n        \\n        return list;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 590453,
                "title": "java-1ms-99-91-time-moore-s-voting-algorithm-used-6-times",
                "content": "```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        int N = nums.length;\\n        \\n        List<Integer> majority = new ArrayList<Integer>(2);\\n        if(N == 1){\\n            majority.add(nums[0]);\\n        }else if(N == 2){\\n            if(nums[0] != nums[1]){\\n                majority.add(nums[0]);\\n                majority.add(nums[1]);\\n            }else\\n                majority.add(nums[0]);\\n        }else if(N > 2){\\n            int x = getMajority(nums, 0, N/3);\\n            int y = getMajority(nums, (N/3), (2*N)/3);\\n            int z = getMajority(nums, ((2*N)/3), N);\\n        \\n            if(isOneThirdMajority(nums, N, x))\\n                majority.add(x);\\n        \\n            if(!majority.contains(y)){\\n                if(isOneThirdMajority(nums, N, y))\\n                    majority.add(y);\\n            }\\n        \\n            if(!majority.contains(z)){\\n                if(isOneThirdMajority(nums, N, z))\\n                    majority.add(z);\\n            }\\n            \\n            x = getMajorityReverse(nums, 0, N/3);\\n            y = getMajorityReverse(nums, (N/3), (2*N)/3);\\n            z = getMajorityReverse(nums, ((2*N)/3), N);\\n            \\n            if(!majority.contains(x)){\\n                if(isOneThirdMajority(nums, N, x))\\n                    majority.add(x);\\n            }\\n            \\n            if(!majority.contains(y)){\\n                if(isOneThirdMajority(nums, N, y))\\n                    majority.add(y);\\n            }\\n        \\n            if(!majority.contains(z)){\\n                if(isOneThirdMajority(nums, N, z))\\n                    majority.add(z);\\n            }\\n        }\\n        \\n        return majority;\\n    }\\n    \\n    private boolean isOneThirdMajority(int[] nums, int N, int x){\\n        int count = 0;\\n        for(int i = 0; i < N; i++){\\n            if(nums[i] == x)\\n                ++count;\\n        }\\n        \\n        return (count > (N/3));\\n    }\\n    \\n    private int getMajority(int[] nums, int start, int end){\\n        int x = nums[start];\\n        int votes = 0;\\n        \\n        for(int i = start; i < end; i++){\\n            if(votes == 0)\\n                x = nums[i];\\n            \\n            if(nums[i] == x)\\n                ++votes;\\n            else\\n                --votes;\\n        }\\n        \\n        return x;\\n    }\\n    \\n    private int getMajorityReverse(int[] nums, int start, int end){\\n        int x = nums[start];\\n        int votes = 0;\\n        \\n        for(int i = end - 1; i >= start; i--){\\n            if(votes == 0)\\n                x = nums[i];\\n            \\n            if(nums[i] == x)\\n                ++votes;\\n            else\\n                --votes;\\n        }\\n        \\n        return x;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        int N = nums.length;\\n        \\n        List<Integer> majority = new ArrayList<Integer>(2);\\n        if(N == 1){\\n            majority.add(nums[0]);\\n        }else if(N == 2){\\n            if(nums[0] != nums[1]){\\n                majority.add(nums[0]);\\n                majority.add(nums[1]);\\n            }else\\n                majority.add(nums[0]);\\n        }else if(N > 2){\\n            int x = getMajority(nums, 0, N/3);\\n            int y = getMajority(nums, (N/3), (2*N)/3);\\n            int z = getMajority(nums, ((2*N)/3), N);\\n        \\n            if(isOneThirdMajority(nums, N, x))\\n                majority.add(x);\\n        \\n            if(!majority.contains(y)){\\n                if(isOneThirdMajority(nums, N, y))\\n                    majority.add(y);\\n            }\\n        \\n            if(!majority.contains(z)){\\n                if(isOneThirdMajority(nums, N, z))\\n                    majority.add(z);\\n            }\\n            \\n            x = getMajorityReverse(nums, 0, N/3);\\n            y = getMajorityReverse(nums, (N/3), (2*N)/3);\\n            z = getMajorityReverse(nums, ((2*N)/3), N);\\n            \\n            if(!majority.contains(x)){\\n                if(isOneThirdMajority(nums, N, x))\\n                    majority.add(x);\\n            }\\n            \\n            if(!majority.contains(y)){\\n                if(isOneThirdMajority(nums, N, y))\\n                    majority.add(y);\\n            }\\n        \\n            if(!majority.contains(z)){\\n                if(isOneThirdMajority(nums, N, z))\\n                    majority.add(z);\\n            }\\n        }\\n        \\n        return majority;\\n    }\\n    \\n    private boolean isOneThirdMajority(int[] nums, int N, int x){\\n        int count = 0;\\n        for(int i = 0; i < N; i++){\\n            if(nums[i] == x)\\n                ++count;\\n        }\\n        \\n        return (count > (N/3));\\n    }\\n    \\n    private int getMajority(int[] nums, int start, int end){\\n        int x = nums[start];\\n        int votes = 0;\\n        \\n        for(int i = start; i < end; i++){\\n            if(votes == 0)\\n                x = nums[i];\\n            \\n            if(nums[i] == x)\\n                ++votes;\\n            else\\n                --votes;\\n        }\\n        \\n        return x;\\n    }\\n    \\n    private int getMajorityReverse(int[] nums, int start, int end){\\n        int x = nums[start];\\n        int votes = 0;\\n        \\n        for(int i = end - 1; i >= start; i--){\\n            if(votes == 0)\\n                x = nums[i];\\n            \\n            if(nums[i] == x)\\n                ++votes;\\n            else\\n                --votes;\\n        }\\n        \\n        return x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 536368,
                "title": "c-90-06-faster-100-less-memory-boyer-moore-s-approach",
                "content": "In this approach, we work on the array in a way such that we virtually make 3 groups in the array:\\n1. First group is of one element present **more than** n / 3 times.\\n2. Second group is of the other element which might be present **more than** n / 3 times.\\n3. Third group is of all the other elements that are left and they must be present **less than** n / 3 times.\\n\\nThe algorithm works by selecting one element from each group and making a triplet. This way the elements which are in the third group (less than n / 3 times) will get exhausted first and we will be left with the majority element(s).\\n```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        if (nums.empty()) return {};\\n        \\n\\t\\t/* \\'element1\\' and \\'element2\\' variables are the two elements from each group and they look for any different element to make a triplet.\\n\\t\\t   \\'count1\\' and \\'count2\\' are used to keep the track of number of element1 and element2 available for making triplets. \\n\\t\\t*/\\n        int element1 = nums[0], count1 = 1, element2 = nums[0], count2 = 0;\\n        \\n        for (int i = 1; i < nums.size(); i++) {\\n\\t\\t\\t// if a different element is encountered, make triplet\\n            if (nums[i] != element1 && nums[i] != element2 && count1 != 0 && count2 != 0) {\\n                count1--;\\n                count2--;\\n            }\\n            \\n            else if (nums[i] == element1) count1++;\\n            \\n            else if (nums[i] == element2) count2++;\\n            \\n\\t\\t\\t// if a particular element from a group is not available for making a triplet, make the current element available\\n            else { \\n                if (count1 == 0) {\\n                    element1 = nums[i];\\n                    count1++;\\n                }\\n            \\n                if (count2 == 0) {\\n                    element2 = nums[i];\\n                    count2++;\\n                }\\n            }\\n        }\\n        \\n        count1 = 0, count2 = 0;\\n        \\n\\t\\t// count the frequencies\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] == element1) count1++;\\n            else if (nums[i] == element2) count2++;\\n        }\\n        \\n        vector<int> result;\\n        \\n\\t\\t// check if the frequency of an element is actually more than n / 3 times\\n        if (count1 > nums.size() / 3) result.push_back(element1);\\n        if (count2 > nums.size() / 3) result.push_back(element2);\\n\\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        if (nums.empty()) return {}",
                "codeTag": "Java"
            },
            {
                "id": 520887,
                "title": "beats-100-1ms-boyer-moore-based-java-implementation",
                "content": "For the detail of the implementation, Google the name \"Boyer-Moore Majority Vote Algorithm\" or refer to [this article](https://gregable.com/2013/10/majority-vote-algorithm-find-majority.html).\\n```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        if (nums == null || nums.length == 0) {\\n            return new ArrayList<>();\\n        }\\n       \\n        int len = nums.length;\\n        int first = 0;\\n        int firstCount = 0;\\n        int second = 1; // any number other than first is good\\n        int secondCount = 0;\\n        \\n        // Boyer-Moore Majority Vote Algorithm\\n        for (int n : nums) {\\n            if (n == first) {\\n                firstCount++;\\n            } else if (n == second) {\\n                secondCount++;\\n            } else if (firstCount == 0) { // this \"if\" and next one can not be put in front, for [2, 2] case\\n                first = n;\\n                firstCount++;\\n            } else if (secondCount == 0) {\\n                second = n;\\n                secondCount++;\\n            } else {\\n                firstCount--;\\n                secondCount--;\\n            }\\n        }\\n        \\n        firstCount = 0;\\n        secondCount = 0;\\n        for (int n : nums) {\\n            if (n == first) {\\n                firstCount++;\\n            } else if (n == second) {\\n                secondCount++;\\n            }\\n        }\\n\\n        List<Integer> res = new ArrayList<>();\\n        if (firstCount > len / 3) {\\n            res.add(first);\\n        }\\n        if (secondCount > len / 3) {\\n            res.add(second);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        if (nums == null || nums.length == 0) {\\n            return new ArrayList<>();\\n        }\\n       \\n        int len = nums.length;\\n        int first = 0;\\n        int firstCount = 0;\\n        int second = 1; // any number other than first is good\\n        int secondCount = 0;\\n        \\n        // Boyer-Moore Majority Vote Algorithm\\n        for (int n : nums) {\\n            if (n == first) {\\n                firstCount++;\\n            } else if (n == second) {\\n                secondCount++;\\n            } else if (firstCount == 0) { // this \"if\" and next one can not be put in front, for [2, 2] case\\n                first = n;\\n                firstCount++;\\n            } else if (secondCount == 0) {\\n                second = n;\\n                secondCount++;\\n            } else {\\n                firstCount--;\\n                secondCount--;\\n            }\\n        }\\n        \\n        firstCount = 0;\\n        secondCount = 0;\\n        for (int n : nums) {\\n            if (n == first) {\\n                firstCount++;\\n            } else if (n == second) {\\n                secondCount++;\\n            }\\n        }\\n\\n        List<Integer> res = new ArrayList<>();\\n        if (firstCount > len / 3) {\\n            res.add(first);\\n        }\\n        if (secondCount > len / 3) {\\n            res.add(second);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 513833,
                "title": "python-o-1-aux-space-sol-by-bm-vote-algorithm-with-explanation",
                "content": "Python O(1) aux space sol. by BM vote algorithm.\\n\\n---\\n\\nHint:\\n\\n#1.\\nThink of [Leetcode #169 Majority Element ](https://leetcode.com/problems/majority-element/) and [Boyer\\u2013Moore majority vote algorithm](https://en.wikipedia.org/wiki/Boyer\\u2013Moore_majority_vote_algorithm)\\n\\n#2.\\nThere are **at most two majority elements** in array, **with threshold = floor( n / 3 )**\\n\\nThis can be proved by contradiction method:\\nAssume k majority elements, where k \\u2267 3, \\nthen array size n > k * ( n / 3) \\u2267 3 * ( n / 3) = n. ( conflict by n > n )\\n\\n---\\n\\nAlgorithm:\\n\\nImplement Boyer\\u2013Moore majority vote algorithm with threshold = floor( n / 3 )\\n\\n---\\n\\n```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        \\n        # a list of majority elements\\n        majority = []\\n        \\n        # threshold for majority validation and verification\\n        threshold = len(nums) // 3\\n        \\n        # Record for possible majority candidates, at most two majority elements is allowed by math-proof.\\n        candidate = [0, 0]\\n        \\n        # Voting for majority candidates\\n        voting = [0, 0]\\n        \\n        ## Step_#1:\\n        # Find possible majority candidates\\n        for number in nums:\\n            \\n            if number == candidate[0]:\\n                # up vote to first candidate\\n                voting[0] += 1\\n                \\n            elif number == candidate[1]:\\n                # up vote to second candidate\\n                voting[1] += 1\\n            \\n            elif not voting[0]:\\n                # set first candidate\\n                candidate[0] = number\\n                voting[0] = 1\\n                \\n            elif not voting[1]:\\n                # set second candidate\\n                candidate[1] = number\\n                voting[1] = 1\\n                \\n            else:\\n                # down vote if mis-match\\n                voting[0] -= 1\\n                voting[1] -= 1\\n        \\n        \\n        ## Step_#2:\\n        # Validation:\\n        voting = [0, 0]\\n        \\n        for number in nums:\\n            \\n            if number == candidate[0]:\\n                # update up vote for first candidate\\n                voting[0] += 1\\n                \\n            elif number == candidate[1]:\\n                # update up vote for second candidate\\n                voting[1] += 1\\n        \\n        \\n        for i, vote in enumerate(voting):\\n            \\n            # Verify majority by threshold\\n            if vote > threshold:\\n                majority.append( candidate[i] )\\n            \\n            \\n        return majority\\n        \\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #169 Majority Element ](https://leetcode.com/problems/majority-element/)\\n\\n---\\n\\nReference:\\n[1] [Boyer\\u2013Moore majority vote algorithm](https://en.wikipedia.org/wiki/Boyer\\u2013Moore_majority_vote_algorithm)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        \\n        # a list of majority elements\\n        majority = []\\n        \\n        # threshold for majority validation and verification\\n        threshold = len(nums) // 3\\n        \\n        # Record for possible majority candidates, at most two majority elements is allowed by math-proof.\\n        candidate = [0, 0]\\n        \\n        # Voting for majority candidates\\n        voting = [0, 0]\\n        \\n        ## Step_#1:\\n        # Find possible majority candidates\\n        for number in nums:\\n            \\n            if number == candidate[0]:\\n                # up vote to first candidate\\n                voting[0] += 1\\n                \\n            elif number == candidate[1]:\\n                # up vote to second candidate\\n                voting[1] += 1\\n            \\n            elif not voting[0]:\\n                # set first candidate\\n                candidate[0] = number\\n                voting[0] = 1\\n                \\n            elif not voting[1]:\\n                # set second candidate\\n                candidate[1] = number\\n                voting[1] = 1\\n                \\n            else:\\n                # down vote if mis-match\\n                voting[0] -= 1\\n                voting[1] -= 1\\n        \\n        \\n        ## Step_#2:\\n        # Validation:\\n        voting = [0, 0]\\n        \\n        for number in nums:\\n            \\n            if number == candidate[0]:\\n                # update up vote for first candidate\\n                voting[0] += 1\\n                \\n            elif number == candidate[1]:\\n                # update up vote for second candidate\\n                voting[1] += 1\\n        \\n        \\n        for i, vote in enumerate(voting):\\n            \\n            # Verify majority by threshold\\n            if vote > threshold:\\n                majority.append( candidate[i] )\\n            \\n            \\n        return majority\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 467781,
                "title": "misra-gries-summary-algorithm-and-proof",
                "content": "This problem is known as the Heavy Hitters/frequent elements problem. \\n\\nBoyer-Moore is only defined to obtain a single majority element. But Misra-Gries is very similar and allows us to generalise this problem for an arbitrary number of elements.\\n\\nIt doesn\\'t seem like any of the current answers mention this, which hinders understanding/searchability.\\n\\nhttps://www.sciencedirect.com/science/article/pii/0167642382900120\\n\\n```csharp\\npublic IList<int> MajorityElement(int[] nums) {\\n\\tint k = 3;\\n\\tint n = nums.Length;\\n\\tvar A = new Dictionary<int, int>();\\n\\tforeach(var num in nums)\\n\\t{\\n\\t\\tif(A.ContainsKey(num)){\\n\\t\\t\\tA[num]++;\\n\\t\\t}\\n\\t\\telse if(A.Count < k - 1)\\n\\t\\t{\\n\\t\\t\\tA[num] = 1;\\n\\t\\t} \\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tforeach(var key in A.Keys.ToList())\\n\\t\\t\\t{\\n\\t\\t\\t\\tA[key]--;\\n\\t\\t\\t\\tif(A[key] == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tA.Remove(key);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t//\"A\" now contains all elements with frequency >= n/k, along with additional elements.\\n\\n\\t//Pass 2 - filter to the majority elements and obtain a count.\\n\\treturn nums.Where(A.ContainsKey).ToLookup(x => x).Where(x => x.Count() > Math.Floor((double)n/3d)).Select(x => x.Key).ToList();\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic IList<int> MajorityElement(int[] nums) {\\n\\tint k = 3;\\n\\tint n = nums.Length;\\n\\tvar A = new Dictionary<int, int>();\\n\\tforeach(var num in nums)\\n\\t{\\n\\t\\tif(A.ContainsKey(num)){\\n\\t\\t\\tA[num]++;\\n\\t\\t}\\n\\t\\telse if(A.Count < k - 1)\\n\\t\\t{\\n\\t\\t\\tA[num] = 1;\\n\\t\\t} \\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tforeach(var key in A.Keys.ToList())\\n\\t\\t\\t{\\n\\t\\t\\t\\tA[key]--;\\n\\t\\t\\t\\tif(A[key] == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tA.Remove(key);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t//\"A\" now contains all elements with frequency >= n/k, along with additional elements.\\n\\n\\t//Pass 2 - filter to the majority elements and obtain a count.\\n\\treturn nums.Where(A.ContainsKey).ToLookup(x => x).Where(x => x.Count() > Math.Floor((double)n/3d)).Select(x => x.Key).ToList();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 403004,
                "title": "share-my-python3-solution-easy-to-understand",
                "content": "O(1) space:\\n```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        if not nums:\\n            return []\\n\\n        res = []\\n        candidate1, candidate2 = nums[0], nums[0]\\n        candidate1_counter, candidate2_counter = 0, 0\\n\\n        for num in nums:\\n            if num == candidate1:\\n                candidate1_counter += 1\\n            elif num == candidate2:\\n                candidate2_counter += 1\\n            elif candidate1_counter == 0:\\n                candidate1 = num\\n                candidate1_counter = 1\\n            elif candidate2_counter == 0:\\n                candidate2 = num\\n                candidate2_counter = 1\\n            else:\\n                candidate1_counter -= 1\\n                candidate2_counter -= 1\\n\\n        cnt1, cnt2 = 0, 0\\n        for num in nums:\\n            if candidate1 == num:\\n                cnt1 += 1\\n            elif candidate2 == num:\\n                cnt2 += 1\\n\\n        if cnt1 > (len(nums) // 3):\\n            res.append(candidate1)\\n        if cnt2 > (len(nums) // 3):\\n            res.append(candidate2)\\n        return res\\n```\\n\\nO(n) space:\\n```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        if not nums:\\n            return []\\n        \\n        limit = len(nums) // 3\\n        res = []\\n        counter = collections.Counter(nums)\\n\\n        for k, v in counter.items():\\n            if v > limit:\\n                res.append(k)\\n\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        if not nums:\\n            return []\\n\\n        res = []\\n        candidate1, candidate2 = nums[0], nums[0]\\n        candidate1_counter, candidate2_counter = 0, 0\\n\\n        for num in nums:\\n            if num == candidate1:\\n                candidate1_counter += 1\\n            elif num == candidate2:\\n                candidate2_counter += 1\\n            elif candidate1_counter == 0:\\n                candidate1 = num\\n                candidate1_counter = 1\\n            elif candidate2_counter == 0:\\n                candidate2 = num\\n                candidate2_counter = 1\\n            else:\\n                candidate1_counter -= 1\\n                candidate2_counter -= 1\\n\\n        cnt1, cnt2 = 0, 0\\n        for num in nums:\\n            if candidate1 == num:\\n                cnt1 += 1\\n            elif candidate2 == num:\\n                cnt2 += 1\\n\\n        if cnt1 > (len(nums) // 3):\\n            res.append(candidate1)\\n        if cnt2 > (len(nums) // 3):\\n            res.append(candidate2)\\n        return res\\n```\n```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        if not nums:\\n            return []\\n        \\n        limit = len(nums) // 3\\n        res = []\\n        counter = collections.Counter(nums)\\n\\n        for k, v in counter.items():\\n            if v > limit:\\n                res.append(k)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 383431,
                "title": "c-solution-very-simple-to-read",
                "content": "I am a fresh learner, so i just use basic words to show the solution\\n```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        vector<int> res;\\n        int counter1=0,counter2=0;\\n        int number1=INT_MAX, number2=INT_MAX;\\n        for(int i=0;i<nums.size();++i){\\n            if(nums[i]==number1){\\n                counter1++;\\n            }\\n            else if(nums[i]==number2){\\n                counter2++;\\n            }\\n            else if(counter1==0){\\n                number1=nums[i];\\n                counter1++;\\n            }\\n            else if(counter2==0){\\n                number2=nums[i];\\n                counter2++;\\n            }\\n            else{\\n                counter1--;\\n                counter2--;\\n            }\\n            \\n        }\\n        \\n        \\n        counter1=0;\\n        counter2=0;\\n        for(int i=0;i<nums.size();++i){\\n            if(nums[i]==number1){\\n                counter1++;\\n            }\\n            else if(nums[i]==number2){\\n                counter2++;\\n            }\\n        }\\n        \\n        if(counter1>nums.size()/3){\\n            res.push_back(number1);\\n        }\\n        if(counter2>nums.size()/3){\\n            res.push_back(number2);\\n        }\\n        return res;\\n    }\\n};\\n```\\nit works well, beat over 90%",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        vector<int> res;\\n        int counter1=0,counter2=0;\\n        int number1=INT_MAX, number2=INT_MAX;\\n        for(int i=0;i<nums.size();++i){\\n            if(nums[i]==number1){\\n                counter1++;\\n            }\\n            else if(nums[i]==number2){\\n                counter2++;\\n            }\\n            else if(counter1==0){\\n                number1=nums[i];\\n                counter1++;\\n            }\\n            else if(counter2==0){\\n                number2=nums[i];\\n                counter2++;\\n            }\\n            else{\\n                counter1--;\\n                counter2--;\\n            }\\n            \\n        }\\n        \\n        \\n        counter1=0;\\n        counter2=0;\\n        for(int i=0;i<nums.size();++i){\\n            if(nums[i]==number1){\\n                counter1++;\\n            }\\n            else if(nums[i]==number2){\\n                counter2++;\\n            }\\n        }\\n        \\n        if(counter1>nums.size()/3){\\n            res.push_back(number1);\\n        }\\n        if(counter2>nums.size()/3){\\n            res.push_back(number2);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 236528,
                "title": "java-solution",
                "content": "**Solution 1: Boyer\\u2013Moore majority vote algorithm**\\n\\nTime complexity: `O(n)`\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution \\n{\\n    public List<Integer> majorityElement(int[] A)\\n    {\\n        List<Integer> list = new ArrayList<>();\\n        int major1 = 0, major2 = 0, count1 = 0, count2 = 0;\\n        \\n        for(int n : A)\\n        {\\n            if(major1 == n)\\n            {\\n                count1++;\\n            }\\n            else if(major2 == n)\\n            {\\n                count2++;\\n            }\\n            else if(count1 == 0)\\n            {\\n                major1 = n;\\n                count1 = 1;\\n            }\\n            else if(count2 == 0)\\n            {\\n                major2 = n;\\n                count2 = 1;\\n            }\\n            else\\n            {\\n                count1--;\\n                count2--;\\n            }    \\n        }\\n        count1 = 0;\\n        count2 = 0;\\n        \\n        for(int n : A)\\n        {\\n            if(n == major1)\\n                count1++;\\n            else if(n == major2)\\n                count2++;\\n        }\\n        if(count1 > A.length / 3) list.add(major1); \\n        if(count2 > A.length / 3) list.add(major2);\\n        \\n        return list;\\n    }\\n}\\n```\\n\\n**Solution 2: Using Hash-Table**\\n\\nTime complexity: `O(n)`\\nSpace complexity: `O(n)`\\n\\n```\\nclass Solution \\n{\\n    public List<Integer> majorityElement(int[] A)\\n    {\\n        List<Integer> list = new ArrayList<>();\\n        Map<Integer, Integer> map = new HashMap<>();\\n        Set<Integer> set = new HashSet<>();\\n        \\n        for(int n : A)\\n        {\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n        }\\n        \\n        for(int n : A)\\n        {\\n            if(map.get(n) > A.length / 3)\\n                set.add(n);\\n        }\\n        list.addAll(set);\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public List<Integer> majorityElement(int[] A)\\n    {\\n        List<Integer> list = new ArrayList<>();\\n        int major1 = 0, major2 = 0, count1 = 0, count2 = 0;\\n        \\n        for(int n : A)\\n        {\\n            if(major1 == n)\\n            {\\n                count1++;\\n            }\\n            else if(major2 == n)\\n            {\\n                count2++;\\n            }\\n            else if(count1 == 0)\\n            {\\n                major1 = n;\\n                count1 = 1;\\n            }\\n            else if(count2 == 0)\\n            {\\n                major2 = n;\\n                count2 = 1;\\n            }\\n            else\\n            {\\n                count1--;\\n                count2--;\\n            }    \\n        }\\n        count1 = 0;\\n        count2 = 0;\\n        \\n        for(int n : A)\\n        {\\n            if(n == major1)\\n                count1++;\\n            else if(n == major2)\\n                count2++;\\n        }\\n        if(count1 > A.length / 3) list.add(major1); \\n        if(count2 > A.length / 3) list.add(major2);\\n        \\n        return list;\\n    }\\n}\\n```\n```\\nclass Solution \\n{\\n    public List<Integer> majorityElement(int[] A)\\n    {\\n        List<Integer> list = new ArrayList<>();\\n        Map<Integer, Integer> map = new HashMap<>();\\n        Set<Integer> set = new HashSet<>();\\n        \\n        for(int n : A)\\n        {\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n        }\\n        \\n        for(int n : A)\\n        {\\n            if(map.get(n) > A.length / 3)\\n                set.add(n);\\n        }\\n        list.addAll(set);\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 175641,
                "title": "javascript-boyer-moore-majority-vote-algorithm",
                "content": "Since the elements in the answer should appear more than `n/3` times, then there are at maximum 2 elements.\\n```\\nfunction majorityElement(nums) {\\n    const length = nums.length;\\n    const candidates = getCandidates(nums, length);\\n    return validateCanditate(nums, candidates, length);\\n};\\n\\nfunction getCandidates(nums, length) {\\n    let c1 = -1;\\n    let c2 = -1;\\n    let count1 = 0;\\n    let count2 = 0;\\n    \\n    for(let i = 0; i < length; i++) {\\n        if(nums[i] === c1){\\n            count1++;\\n        }else if(nums[i] === c2) {\\n            count2++;\\n        }else if(count1 === 0) {\\n            c1 =nums[i];\\n            count1++;\\n        }else if(count2 === 0) {\\n            c2 =nums[i];\\n            count2++;\\n        }else{\\n            count1--;\\n            count2--;\\n        }\\n    }\\n    return [c1,c2];\\n}\\n\\nfunction validateCanditate(nums, candidates, length) {\\n    const amounts = [0,0];\\n    const final = [];\\n\\n    for(let i = 0; i < length; i++) { \\n        for(let j = 0; j < 2; j++) {\\n            if(nums[i] === candidates[j]) {\\n                amounts[j]++\\n            }\\n        }\\n    }    \\n    for(let i = 0; i< 2; i++){\\n        if(amounts[i] > Math.floor(length/3)){\\n           final.push(candidates[i]);\\n        }    \\n    }\\n\\n    return final;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nfunction majorityElement(nums) {\\n    const length = nums.length;\\n    const candidates = getCandidates(nums, length);\\n    return validateCanditate(nums, candidates, length);\\n};\\n\\nfunction getCandidates(nums, length) {\\n    let c1 = -1;\\n    let c2 = -1;\\n    let count1 = 0;\\n    let count2 = 0;\\n    \\n    for(let i = 0; i < length; i++) {\\n        if(nums[i] === c1){\\n            count1++;\\n        }else if(nums[i] === c2) {\\n            count2++;\\n        }else if(count1 === 0) {\\n            c1 =nums[i];\\n            count1++;\\n        }else if(count2 === 0) {\\n            c2 =nums[i];\\n            count2++;\\n        }else{\\n            count1--;\\n            count2--;\\n        }\\n    }\\n    return [c1,c2];\\n}\\n\\nfunction validateCanditate(nums, candidates, length) {\\n    const amounts = [0,0];\\n    const final = [];\\n\\n    for(let i = 0; i < length; i++) { \\n        for(let j = 0; j < 2; j++) {\\n            if(nums[i] === candidates[j]) {\\n                amounts[j]++\\n            }\\n        }\\n    }    \\n    for(let i = 0; i< 2; i++){\\n        if(amounts[i] > Math.floor(length/3)){\\n           final.push(candidates[i]);\\n        }    \\n    }\\n\\n    return final;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 63620,
                "title": "c-solution-with-o-n-time-and-o-1-space-via-improved-quick-sort",
                "content": "Because the majority elements can only occur in certain indices. So find them as candidates by improved quick sort. Then get the counts of candidates to decide if it's majority or not.\\n\\n    using System.Collections.Generic;\\n    using System.Linq;\\n    \\n    public class Solution {\\n        public IList<int> MajorityElement(int[] nums) {\\n            if (nums.Length == 0) return new int[0];\\n            var targetIndices = new [] { nums.Length / 3, nums.Length - nums.Length / 3 - 1 }.Distinct().ToList();\\n            var candidates = Sort(nums, 0, nums.Length - 1, targetIndices).Distinct();\\n            return candidates.Where(c => nums.Count(n => n == c) > nums.Length / 3).ToList();\\n        }\\n    \\n        private IList<int> Sort(int[] nums, int left, int right, IList<int> targetIndices)\\n        {\\n            if (left == right) return new [] { nums[left] };\\n            var mid = nums[(left + right) / 2];\\n            var i = left;\\n            var j = right;\\n            while (i <= j)\\n            {\\n                while (nums[i] < mid) ++i;\\n                while (nums[j] > mid) --j;\\n                if (i <= j)\\n                {\\n                    var temp = nums[i];\\n                    nums[i] = nums[j];\\n                    nums[j] = temp;\\n                    ++i;\\n                    --j;\\n                }\\n            }\\n            var result = new List<int>();\\n            var leftTargetIndices = new List<int>();\\n            var rightTargetIndecies = new List<int>();\\n            foreach (var targetIndex in targetIndices)\\n            {\\n                if (targetIndex <= j) leftTargetIndices.Add(targetIndex);\\n                else if (targetIndex >= i) rightTargetIndecies.Add(targetIndex);\\n                else result.Add(mid);\\n            }\\n            if (leftTargetIndices.Count > 0) result.AddRange(Sort(nums, left, j, leftTargetIndices));\\n            if (rightTargetIndecies.Count > 0) result.AddRange(Sort(nums, i, right, rightTargetIndecies));\\n            return result;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public IList<int> MajorityElement(int[] nums) {\\n            if (nums.Length == 0) return new int[0];\\n            var targetIndices = new [] { nums.Length / 3, nums.Length - nums.Length / 3 - 1 }",
                "codeTag": "Java"
            },
            {
                "id": 63622,
                "title": "2-lines-and-fast",
                "content": "**Yes, I know, this isn't linear time. But it's actually faster here.** And I think it's interesting enough to post.\\n\\n    def majorityElement(self, nums):\\n        t = len(nums) / 3\\n        return [n for n in set(sorted(nums)[t::max(t,1)]) if nums.count(n) > t]\\n\\nIt got accepted in 44 ms (after a few attempts, as the OJ is inconsistent), faster than any other recent Python submission. The current statistic of recent Python times (extracted from the submission detail page) begins like this:\\n\\n    48 ms:  0.2169%\\n    52 ms:  1.3015%\\n    53 ms:  0.2169%\\n    56 ms:  6.5076%\\n    60 ms:  7.5922%\\n    64 ms: 12.7983%\\n    ...\\n\\nWhy is it fast, despite the sorting in general being O(n log n)? I don't fully know, but:\\n\\n- I do very little myself in Python. Almost all of the work is done by the highly optimized `sort` and `count` functions written in C.\\n- The test cases don't seem to be very random, and Python's sort function [Timsort](https://en.wikipedia.org/wiki/Timsort) can take advantage of already sorted parts, in the best case even achieve O(n).\\n- If there's one very dominant majority element, then my candidate set might be just that one element and I won't count two candidates like the usual Misra-Gries solution (often called Boyer-Moore).\\n\\nOk, now an explanation in case it isn't obvious :-). What I do is I sort the array, and then I use every \\u230an/3\\u230b-th element as a candidate. An element appearing more than \\u230an/3\\u230b times will of course be among those candidates (since it will appear more than \\u230an/3\\u230b times in a row in the sorted array). All that's left is to do an exact count of each candidate to find out whether they're actually a majority element.",
                "solutionTags": [],
                "code": "**Yes, I know, this isn't linear time. But it's actually faster here.** And I think it's interesting enough to post.\\n\\n    def majorityElement(self, nums):\\n        t = len(nums) / 3\\n        return [n for n in set(sorted(nums)[t::max(t,1)]) if nums.count(n) > t]\\n\\nIt got accepted in 44 ms (after a few attempts, as the OJ is inconsistent), faster than any other recent Python submission. The current statistic of recent Python times (extracted from the submission detail page) begins like this:\\n\\n    48 ms:  0.2169%\\n    52 ms:  1.3015%\\n    53 ms:  0.2169%\\n    56 ms:  6.5076%\\n    60 ms:  7.5922%\\n    64 ms: 12.7983%\\n    ...\\n\\nWhy is it fast, despite the sorting in general being O(n log n)? I don't fully know, but:\\n\\n- I do very little myself in Python. Almost all of the work is done by the highly optimized `sort` and `count` functions written in C.\\n- The test cases don't seem to be very random, and Python's sort function [Timsort](https://en.wikipedia.org/wiki/Timsort) can take advantage of already sorted parts, in the best case even achieve O(n).\\n- If there's one very dominant majority element, then my candidate set might be just that one element and I won't count two candidates like the usual Misra-Gries solution (often called Boyer-Moore).\\n\\nOk, now an explanation in case it isn't obvious :-). What I do is I sort the array, and then I use every \\u230an/3\\u230b-th element as a candidate. An element appearing more than \\u230an/3\\u230b times will of course be among those candidates (since it will appear more than \\u230an/3\\u230b times in a row in the sorted array). All that's left is to do an exact count of each candidate to find out whether they're actually a majority element.",
                "codeTag": "Python3"
            },
            {
                "id": 63555,
                "title": "a-solving-function-finding-k-majority-elements-may-be-helpful-for-future-problems-o-k-n-time-and-o-k-space",
                "content": "Only post the function. It returns all elements occur more than (n/k) times. In this problem, k=3.\\nThe time complexity is O(k*n), and O(k) space. Also work for 'Majority Element'. And any future following problems. \\n\\nUsage in this problem:  return solver(nums, 3);\\n \\n\\n    private List<Integer> solver(int[] nums, int k) {\\n            List<Integer> ret = new LinkedList<Integer>();\\n            int[] buffer = new int[k-1];\\n            int[] count = new int[k-1];\\n            Arrays.fill(count, 0);\\n            Arrays.fill(buffer, Integer.MIN_VALUE);\\n            for(int i=0;i<nums.length;i++) {\\n                boolean find = false;\\n                for(int j=0;j<k-1;j++) {\\n                    if(nums[i]==buffer[j]) {\\n                        count[j]++;\\n                        find=true;\\n                        break;\\n                    } \\n                    else if(count[j]==0) {\\n                        buffer[j]=nums[i];\\n                        count[j]=1;\\n                        find=true;\\n                        break;\\n                    }\\n                }\\n                if(!find) {\\n                    for(int j=0;j<k-1;j++) {\\n                        count[j]--;\\n                    }\\n                }\\n            }\\n            Arrays.fill(count, 0);\\n            for(int i=0;i<nums.length;i++) {\\n                for(int j=0;j<k-1;j++) {\\n                    if(nums[i]==buffer[j]) {\\n                        count[j]++;\\n                        if(count[j]>(nums.length/k)) {\\n                            ret.add(nums[i]);\\n                            count[j]=Integer.MIN_VALUE;\\n                        }\\n                        break;\\n                    }\\n                }\\n            }\\n            return ret;\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Only post the function. It returns all elements occur more than (n/k) times. In this problem, k=3.\\nThe time complexity is O(k*n), and O(k) space. Also work for 'Majority Element'. And any future following problems. \\n\\nUsage in this problem:  return solver(nums, 3);\\n \\n\\n    private List<Integer> solver(int[] nums, int k) {\\n            List<Integer> ret = new LinkedList<Integer>();\\n            int[] buffer = new int[k-1];\\n            int[] count = new int[k-1];\\n            Arrays.fill(count, 0);\\n            Arrays.fill(buffer, Integer.MIN_VALUE);\\n            for(int i=0;i<nums.length;i++) {\\n                boolean find = false;\\n                for(int j=0;j<k-1;j++) {\\n                    if(nums[i]==buffer[j]) {\\n                        count[j]++;\\n                        find=true;\\n                        break;\\n                    } \\n                    else if(count[j]==0) {\\n                        buffer[j]=nums[i];\\n                        count[j]=1;\\n                        find=true;\\n                        break;\\n                    }\\n                }\\n                if(!find) {\\n                    for(int j=0;j<k-1;j++) {\\n                        count[j]--;\\n                    }\\n                }\\n            }\\n            Arrays.fill(count, 0);\\n            for(int i=0;i<nums.length;i++) {\\n                for(int j=0;j<k-1;j++) {\\n                    if(nums[i]==buffer[j]) {\\n                        count[j]++;\\n                        if(count[j]>(nums.length/k)) {\\n                            ret.add(nums[i]);\\n                            count[j]=Integer.MIN_VALUE;\\n                        }\\n                        break;\\n                    }\\n                }\\n            }\\n            return ret;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 63651,
                "title": "straightforward-python-solution-o-n-time-o-1-space",
                "content": "Note that, there are most two candidates in the nums.\\n\\n    def majorityElement(self, nums):\\n        n = len(nums)\\n        candidate1, candidate2= -1,-1\\n        count1, count2 = 0, 0\\n        for i in range(n):\\n            if nums[i] == candidate1:\\n                count1 += 1\\n            elif nums[i] == candidate2:\\n                count2 += 1\\n            elif count1 == 0:\\n                candidate1 = nums[i]\\n                count1 = 1\\n            elif count2 == 0:\\n                candidate2 = nums[i]\\n                count2 = 1\\n            else:\\n                count1 -= 1\\n                count2 -= 1\\n        ans = []\\n        count1, count2 = 0,0\\n        for i in range(n) :  // check whether the candidate is the answer\\n            if nums[i] == candidate1:\\n                count1 += 1\\n            elif nums[i] == candidate2:\\n                count2 += 1\\n        if count1 > n/3:\\n            ans.append(candidate1)\\n        if count2 > n/3:\\n            ans.append(candidate2)\\n        return ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "Note that, there are most two candidates in the nums.\\n\\n    def majorityElement(self, nums):\\n        n = len(nums)\\n        candidate1, candidate2= -1,-1\\n        count1, count2 = 0, 0\\n        for i in range(n):\\n            if nums[i] == candidate1:\\n                count1 += 1\\n            elif nums[i] == candidate2:\\n                count2 += 1\\n            elif count1 == 0:\\n                candidate1 = nums[i]\\n                count1 = 1\\n            elif count2 == 0:\\n                candidate2 = nums[i]\\n                count2 = 1\\n            else:\\n                count1 -= 1\\n                count2 -= 1\\n        ans = []\\n        count1, count2 = 0,0\\n        for i in range(n) :  // check whether the candidate is the answer\\n            if nums[i] == candidate1:\\n                count1 += 1\\n            elif nums[i] == candidate2:\\n                count2 += 1\\n        if count1 > n/3:\\n            ans.append(candidate1)\\n        if count2 > n/3:\\n            ans.append(candidate2)\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 3842307,
                "title": "simple-c-solution-beats-99-user-and-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n\\n        //optimised solution\\n        int n = nums.size();\\n        int cnt1 = 0, cnt2 = 0;\\n        int el1 = INT_MIN;\\n        int el2 = INT_MIN;\\n        for(int i = 0;i<n;i++){\\n            if(cnt1 == 0 && el2 != nums[i]){\\n                cnt1 = 1;\\n                el1 = nums[i];\\n            }\\n            else if(cnt2 == 0 && el1 != nums[i]){\\n                cnt2 = 1;\\n                el2 = nums[i];\\n            }\\n            else if(nums[i] == el1){\\n                cnt1++;\\n            }\\n            else if(nums[i] == el2){\\n                cnt2++;\\n            }\\n            else{\\n                cnt1--,cnt2--;\\n            }\\n        }\\n\\n        vector<int> ans;\\n        cnt1 = 0, cnt2 = 0;\\n        for(int i = 0;i<n;i++){\\n            if(el1 == nums[i]){\\n                cnt1++;\\n            }\\n            if(el2 == nums[i]){\\n                cnt2++;\\n            }\\n        }\\n\\n        int mini = (int)(n/3) + 1;\\n        if(cnt1 >= mini){\\n            ans.push_back(el1);\\n        }\\n        if(cnt2 >= mini){\\n            ans.push_back(el2);\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n\\n        //optimised solution\\n        int n = nums.size();\\n        int cnt1 = 0, cnt2 = 0;\\n        int el1 = INT_MIN;\\n        int el2 = INT_MIN;\\n        for(int i = 0;i<n;i++){\\n            if(cnt1 == 0 && el2 != nums[i]){\\n                cnt1 = 1;\\n                el1 = nums[i];\\n            }\\n            else if(cnt2 == 0 && el1 != nums[i]){\\n                cnt2 = 1;\\n                el2 = nums[i];\\n            }\\n            else if(nums[i] == el1){\\n                cnt1++;\\n            }\\n            else if(nums[i] == el2){\\n                cnt2++;\\n            }\\n            else{\\n                cnt1--,cnt2--;\\n            }\\n        }\\n\\n        vector<int> ans;\\n        cnt1 = 0, cnt2 = 0;\\n        for(int i = 0;i<n;i++){\\n            if(el1 == nums[i]){\\n                cnt1++;\\n            }\\n            if(el2 == nums[i]){\\n                cnt2++;\\n            }\\n        }\\n\\n        int mini = (int)(n/3) + 1;\\n        if(cnt1 >= mini){\\n            ans.push_back(el1);\\n        }\\n        if(cnt2 >= mini){\\n            ans.push_back(el2);\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827681,
                "title": "too-easy-brute-force-approach",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSuppose the input vector `nums` is `{3, 2, 3, 3, 1, 2, 2}`.\\n\\n1. Create an empty unordered map `mp` to store the frequency count of each element.\\n2. Create an empty vector `ans` to store the elements that occur more than `n = nums.size() / 3` times, where `n` is the majority element threshold.\\n3. Begin the loop to traverse each element of `nums`:\\n   - First iteration (it = 3):\\n     - Increment the count of 3 in the `mp` map. Now `mp` contains `{3: 1}`.\\n   - Second iteration (it = 2):\\n     - Increment the count of 2 in the `mp` map. Now `mp` contains `{3: 1, 2: 1}`.\\n   - Third iteration (it = 3):\\n     - Increment the count of 3 in the `mp` map. Now `mp` contains `{3: 2, 2: 1}`.\\n   - Fourth iteration (it = 3):\\n     - Increment the count of 3 in the `mp` map. Now `mp` contains `{3: 3, 2: 1}`.\\n   - Fifth iteration (it = 1):\\n     - Increment the count of 1 in the `mp` map. Now `mp` contains `{3: 3, 2: 1, 1: 1}`.\\n   - Sixth iteration (it = 2):\\n     - Increment the count of 2 in the `mp` map. Now `mp` contains `{3: 3, 2: 2, 1: 1}`.\\n   - Seventh iteration (it = 2):\\n     - Increment the count of 2 in the `mp` map. Now `mp` contains `{3: 3, 2: 3, 1: 1}`.\\n\\n4. Calculate the majority element threshold `n` as `nums.size() / 3`. For our example, `n = 7 / 3 = 2`.\\n5. Begin the second loop to traverse the elements and their counts in the `mp` map:\\n   - First iteration (it = {3, 3}):\\n     - The count of 3 is greater than `n`, which is 2. So, add 3 to the `ans` vector. Now `ans` contains `{3}`.\\n   - Second iteration (it = {2, 3}):\\n     - The count of 2 is greater than `n`, which is 2. So, add 2 to the `ans` vector. Now `ans` contains `{3, 2}`.\\n   - Third iteration (it = {1, 1}):\\n     - The count of 1 is not greater than `n`, which is 2. So, skip this element.\\n\\n6. The second loop ends.\\n7. Return the `ans` vector, which contains the majority elements that appear more than `n = 2` times in the `nums` vector. In our example, the `ans` vector will be `{3, 2}`.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        vector<int> ans;\\n        for(auto it:nums){\\n            mp[it]++;\\n        }\\n        int n = nums.size() / 3;\\n        for(auto it:mp){\\n            if(it.second > n){\\n                ans.push_back(it.first);\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        vector<int> ans;\\n        for(auto it:nums){\\n            mp[it]++;\\n        }\\n        int n = nums.size() / 3;\\n        for(auto it:mp){\\n            if(it.second > n){\\n                ans.push_back(it.first);\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634079,
                "title": "c-easy-solution-100-working",
                "content": "# C++ code using basic map approach\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        map<int,int> mp;\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto i: mp){\\n            if(i.second>nums.size()/3) ans.push_back(i.first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        map<int,int> mp;\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto i: mp){\\n            if(i.second>nums.size()/3) ans.push_back(i.first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610574,
                "title": "3-approaches-beginner-friendly-c",
                "content": "### BRUTE FORCE :\\n\\nWe need to know how many numbers exist in the array where the freq of an element can be > floor(n/3) where n i the size of the array. A small observation here is consider array of size=8 \\n\\nn/3= 2 so freq must be >2 i.e 3 or more if we consider the min freq needed i.e 3 then 3+3+2 makes up 8 which gives us max 2 elements which can occur in majority. So now we know that our ans vector can only be of size \\u22642(using this in our approach).\\n\\nTraverse element one by one and if the ans vector is empty or it contains 1 element then this means we have to perform search so the inner loop will run only if this condition is satisfied where either the ans vector is empty or it does not contain and element which is already counted in our answer .\\n\\n```cpp\\n#include <bits/stdc++.h>\\n\\nvector<int> majorityElement(vector<int> &arr)\\n{\\n    // Write your code here.\\n    vector<int> ans;\\n    int cnt=1;\\n    for(int i=0;i<arr.size();i++)\\n    {\\n        cnt=1;\\n        if(ans.empty() || ans.back()!=arr[i])\\n        {\\n            for(int j=i+1;j<arr.size();j++)\\n            {\\n                if(arr[j]==arr[i])\\n                    cnt++;\\n            }\\n            if(cnt>arr.size()/3)\\n                ans.push_back(arr[i]);\\n        }\\n    }\\n    return ans;\\n}\\n```\\n\\n- Time Complexity : O(N^2)\\n- Space Complexity : O(1) as the vector size is \\u2264 2 in every case\\n\\n### Approach 2:\\n\\nHashing and finding out where freq \\u2265n/3 and including to ans.\\n\\n- Time complexity : O(NlogN) in case of ordered map, if unordered map is used it is O(N*1) but in worst case O(N) is used by unordered map so O(N^2) in worst case.\\n- Space Complexity : O(N) for map\\n\\n### Approach 3: Extended Boyer Moore\\u2019s voting algorithm\\n\\nAs we know we will have at max only two elements in our ans we make use of moore\\u2019s voting algo and keep track using 4 variables cnt1,cnt2, ekem1,elem2.\\n\\nProjection of majority element 1 problem :\\n\\ncnt1 counts 1st majority element and cnt2 counts 2nd we use if else if so that only one condition if satisfied every time. We pick up one element and check whether cnt1 is 0 if yes then it will be set to 1 and elem1 will contain this element after this the loop moves for next iteration making sure that only one either of cnt1 or cnt2 is set but there is a problem when one of the cnt is zero and other is not and the current element is the one that is already store in one of the elem var say 1\\n\\nEx: \\n\\ncnt1= 1, elem=1\\n\\ncnt2=0\\n\\nNow current elements being processed is 1 so when he cnt2==0 condition is satisfied cnt2 is set to 1 and elem2 now contains 1. Now both elem 1 and elem2 contains 1 and there freq values will be garbled so to avoid this case we also include a cond when either of ct is zero we check that arr[i] should not be equal to elem variables of either contrary cnt variable( cnt1 and elem2 condition is checked) .\\n\\n```cpp\\n#include <bits/stdc++.h>\\n\\nvector<int> majorityElement(vector<int> &arr)\\n{\\n    // Write your code here.\\n    int cnt1=0,cnt2=0,n=arr.size(),elem1,elem2;\\n    vector<int> ans;\\n    for(int i=0;i<n;i++)\\n    {\\n        if(cnt1==0 && arr[i]!=elem2)\\n        {\\n            cnt1=1;\\n            elem1=arr[i];\\n        }\\n        else if(cnt2==0 && arr[i]!=elem1)\\n        {\\n            cnt2=1;\\n            elem2=arr[i];\\n        }\\n        else if(arr[i]==elem1)\\n        {\\n            cnt1++;\\n        }\\n        else if(arr[i]==elem2)\\n        {\\n            cnt2++;\\n        }\\n        else{\\n            cnt1--;\\n            cnt2--;\\n        }\\n    }\\n    cnt1=0,cnt2=0;\\n    for(int i=0;i<n;i++)\\n    {\\n        if(arr[i]==elem1)\\n            cnt1++;\\n        else if(arr[i]==elem2)\\n        {\\n            cnt2++;\\n        }\\n    }\\n    if(cnt1>n/3)\\n        ans.push_back(elem1);\\n    if(cnt2>n/3)\\n        ans.push_back(elem2);\\n    return ans;\\n}\\n```\\n\\n- Time Complexity : O(n)+O(N)\\n- Space Complexity : O(1)\\n\\nUpvote if understood!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\n#include <bits/stdc++.h>\\n\\nvector<int> majorityElement(vector<int> &arr)\\n{\\n    // Write your code here.\\n    vector<int> ans;\\n    int cnt=1;\\n    for(int i=0;i<arr.size();i++)\\n    {\\n        cnt=1;\\n        if(ans.empty() || ans.back()!=arr[i])\\n        {\\n            for(int j=i+1;j<arr.size();j++)\\n            {\\n                if(arr[j]==arr[i])\\n                    cnt++;\\n            }\\n            if(cnt>arr.size()/3)\\n                ans.push_back(arr[i]);\\n        }\\n    }\\n    return ans;\\n}\\n```\n```cpp\\n#include <bits/stdc++.h>\\n\\nvector<int> majorityElement(vector<int> &arr)\\n{\\n    // Write your code here.\\n    int cnt1=0,cnt2=0,n=arr.size(),elem1,elem2;\\n    vector<int> ans;\\n    for(int i=0;i<n;i++)\\n    {\\n        if(cnt1==0 && arr[i]!=elem2)\\n        {\\n            cnt1=1;\\n            elem1=arr[i];\\n        }\\n        else if(cnt2==0 && arr[i]!=elem1)\\n        {\\n            cnt2=1;\\n            elem2=arr[i];\\n        }\\n        else if(arr[i]==elem1)\\n        {\\n            cnt1++;\\n        }\\n        else if(arr[i]==elem2)\\n        {\\n            cnt2++;\\n        }\\n        else{\\n            cnt1--;\\n            cnt2--;\\n        }\\n    }\\n    cnt1=0,cnt2=0;\\n    for(int i=0;i<n;i++)\\n    {\\n        if(arr[i]==elem1)\\n            cnt1++;\\n        else if(arr[i]==elem2)\\n        {\\n            cnt2++;\\n        }\\n    }\\n    if(cnt1>n/3)\\n        ans.push_back(elem1);\\n    if(cnt2>n/3)\\n        ans.push_back(elem2);\\n    return ans;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3598111,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int n = nums.size();\\n        map<int,int> m;\\n        for(int i = 0;i<nums.size();i++){\\n            m[nums[i]]++;\\n        }\\n        vector<int> v;\\n        for(auto it : m){\\n            if(it.second > n/3){\\n                v.push_back(it.first);\\n            } \\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int n = nums.size();\\n        map<int,int> m;\\n        for(int i = 0;i<nums.size();i++){\\n            m[nums[i]]++;\\n        }\\n        vector<int> v;\\n        for(auto it : m){\\n            if(it.second > n/3){\\n                v.push_back(it.first);\\n            } \\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504389,
                "title": "using-hashmap-majority-element-2",
                "content": "# Intuition\\nin this approach we take element as key \\nand the occurace as INTEGER\\n\\n nums = [3,2,3,3,4,5]\\nkey         value\\n2             1\\n3             3\\n4             1\\n5             1\\n\\n# Approach\\nafter creating the hash map \\nstep1 check the value whose occurance is greater then num.length(given array size)/3\\nstep2:- then store the value in a array list\\n# Complexity\\n- Time complexity:\\no(n)\\n- Space complexity:\\no(n)\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n\\n         Map<Integer,Integer> numOcuurance=new HashMap<>();\\n        for (int num : nums) {\\n\\n            if(numOcuurance.containsKey(num))\\n            {\\n                int count=numOcuurance.get(num);\\n                numOcuurance.put(num,count+1);\\n            }\\n            else {\\n                numOcuurance.put(num,1);\\n            }\\n        }\\n\\n        System.out.println(numOcuurance);\\n        System.out.println(numOcuurance.containsKey(2));\\n        List<Integer> l1 =new ArrayList<>();\\n        // Print the map\\n        for (Map.Entry<Integer, Integer> entry : numOcuurance.entrySet()) {\\n            int key = entry.getKey();\\n            int value = entry.getValue();\\n\\n            if(value> nums.length/3)\\n            {\\n                l1.add(key);\\n            }\\n        }\\n        return l1;\\n        \\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "class Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n\\n         Map<Integer,Integer> numOcuurance=new HashMap<>();\\n        for (int num : nums) {\\n\\n            if(numOcuurance.containsKey(num))\\n            {\\n                int count=numOcuurance.get(num);\\n                numOcuurance.put(num,count+1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3469195,
                "title": "java-hashtable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n            if(map.get(nums[i])>(nums.length/3)){\\n                list.add(nums[i]);\\n                map.replace(nums[i],Integer.MIN_VALUE);\\n            }\\n        }\\n        return list;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n            if(map.get(nums[i])>(nums.length/3)){\\n                list.add(nums[i]);\\n                map.replace(nums[i],Integer.MIN_VALUE);\\n            }\\n        }\\n        return list;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444493,
                "title": "hashmap",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n            get frequency of each nums element\\n            check the value is > n/3 is or is not\\n            if it is then add to list \\n            \\n\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        HashMap<Integer, Integer> map= new HashMap<>();\\n\\n        for(int i: nums){\\n            // if Contains already then update the value else add it with freq with 1\\n            if(map.containsKey(i)){\\n                map.put(i, map.get(i)+1);\\n            }else map.put(i,1);\\n\\n        }\\n\\n        int n= nums.length;\\n        List<Integer> l= new ArrayList<>();\\n        for(int i: map.keySet()){\\n            if(map.get(i)>n/3){\\n                l.add(i);\\n            } \\n        }\\n        return l;\\n\\n        \\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        HashMap<Integer, Integer> map= new HashMap<>();\\n\\n        for(int i: nums){\\n            // if Contains already then update the value else add it with freq with 1\\n            if(map.containsKey(i)){\\n                map.put(i, map.get(i)+1);\\n            }else map.put(i,1);\\n\\n        }\\n\\n        int n= nums.length;\\n        List<Integer> l= new ArrayList<>();\\n        for(int i: map.keySet()){\\n            if(map.get(i)>n/3){\\n                l.add(i);\\n            } \\n        }\\n        return l;\\n\\n        \\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442714,
                "title": "solution-of-map-that-can-run-for-1-1-1-1-1-1-1-1-1-in-one-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncreate a map that can strore the counting \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nwhen counting is more that 2 reset the counting to int min so next time he never reach the n/3 \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N) // single loop\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n     int n=nums.size();\\n     vector<int>ans;\\n     unordered_map<int,int>mp;\\n     for(int i=0; i<n; i++){\\n         mp[nums[i]]++;\\n         if(mp[nums[i]]>n/3){\\n             ans.push_back(nums[i]);\\n             mp[nums[i]]=INT_MIN; // this is to avoid the retundancy \\n         }\\n     }  \\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n     int n=nums.size();\\n     vector<int>ans;\\n     unordered_map<int,int>mp;\\n     for(int i=0; i<n; i++){\\n         mp[nums[i]]++;\\n         if(mp[nums[i]]>n/3){\\n             ans.push_back(nums[i]);\\n             mp[nums[i]]=INT_MIN; // this is to avoid the retundancy \\n         }\\n     }  \\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394220,
                "title": "python3-alterative-counter-solution-one-liner-not-for-interview",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        a = []\\n        for i, j in Counter(nums).items():\\n            if j > len(nums) / 3:\\n                a.append(i)\\n        return a\\n```\\n\\n- One-Liner\\n\\n```\\nreturn [i for i,j in Counter(nums).items() if j > len(nums) / 3]\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Sorting",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        a = []\\n        for i, j in Counter(nums).items():\\n            if j > len(nums) / 3:\\n                a.append(i)\\n        return a\\n```\n```\\nreturn [i for i,j in Counter(nums).items() if j > len(nums) / 3]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354438,
                "title": "very-easy-python3-solution-using-counter",
                "content": "# Code\\n```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        res = []\\n        c = Counter(nums)\\n            \\n        for i in c.keys():\\n            if c[i] > len(nums)//3:\\n                res.append(i)\\n\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        res = []\\n        c = Counter(nums)\\n            \\n        for i in c.keys():\\n            if c[i] > len(nums)//3:\\n                res.append(i)\\n\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351940,
                "title": "very-simple-easy-to-understand-java-solution",
                "content": "\\n# Approach\\n1. If length of array is one, return the list containing the only number.\\n2. If length of array is two, add the first element to the list and check if the second number is equal or not. If it is not equal to the previous, add second element also to the list. Return the list.\\n3. Sort the Array\\n4. Initiaze an empty result list.\\n5. Iterate through the array (from second index to the length)\\n\\n5.1 if the element is equal to the previous one, increase the    current count of the element. \\n\\n5.2 if the current count is greater than length/3, then add the list, and mark the current element as already added.\\n\\n5.3 else(element is not equal to the previous one) -> prev will be initialized to the current element , and count to 1, and added will be false.\\n\\n6. Return the result;\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ (assuming it used counting sort)\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        List<Integer> result = new ArrayList<Integer>();\\n        result.clear();\\n\\n        Arrays.sort(nums);\\n        int prev = nums[0];\\n        int n = nums.length;\\n        int count = 1;\\n        boolean added = false;\\n        if(n == 1){\\n            result.add(prev);\\n            return result;\\n        }\\n        if(n==2){\\n            result.add(prev);\\n            if(prev != nums[1]) {\\n            result.add(nums[1]);\\n                \\n            }\\n            return result;\\n        }\\n        for (int i=1; i<n; i++) {\\n            if (prev == nums[i]) {\\n                count++;\\n\\n                if(count > n/3 && !added) {\\n                    result.add(prev);\\n                    added = true;\\n                }\\n               \\n            } else {\\n                prev = nums[i];\\n                count = 1;\\n                added = false;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        List<Integer> result = new ArrayList<Integer>();\\n        result.clear();\\n\\n        Arrays.sort(nums);\\n        int prev = nums[0];\\n        int n = nums.length;\\n        int count = 1;\\n        boolean added = false;\\n        if(n == 1){\\n            result.add(prev);\\n            return result;\\n        }\\n        if(n==2){\\n            result.add(prev);\\n            if(prev != nums[1]) {\\n            result.add(nums[1]);\\n                \\n            }\\n            return result;\\n        }\\n        for (int i=1; i<n; i++) {\\n            if (prev == nums[i]) {\\n                count++;\\n\\n                if(count > n/3 && !added) {\\n                    result.add(prev);\\n                    added = true;\\n                }\\n               \\n            } else {\\n                prev = nums[i];\\n                count = 1;\\n                added = false;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324577,
                "title": "java-hashmap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        for(int i:nums)\\n        hm.put(i, hm.getOrDefault(i, 0)+1);\\n\\n        List<Integer> li = new ArrayList<>();\\n        int n = nums.length/3;\\n        for(Map.Entry<Integer, Integer> entry: hm.entrySet())\\n        if(entry.getValue()>n)\\n        li.add(entry.getKey());\\n        return li;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        for(int i:nums)\\n        hm.put(i, hm.getOrDefault(i, 0)+1);\\n\\n        List<Integer> li = new ArrayList<>();\\n        int n = nums.length/3;\\n        for(Map.Entry<Integer, Integer> entry: hm.entrySet())\\n        if(entry.getValue()>n)\\n        li.add(entry.getKey());\\n        return li;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566876,
                "content": [
                    {
                        "username": "alanmiller",
                        "content": "This article is for those who are familiar with how Moore\\'s voting algorithm is implemented, but don\\'t understand why it works, or seeks for a rigorous proof of its correctness.\\n\\nIntuitive idea:\\nLet\\'s start with the basic case: [169. Majority Element](https://leetcode.com/problems/majority-element/)\\nOne can think of the algorithm as a battle process, whenever two different elements encountered, the battle occurs, and they both vanishes. The candidate is whoever that survives this battle process. The point here is that whenever a majority element vanishes (no matter it is the current candidate or not), there is at least (exactly) one other element dies with it. Hence, the majority element survives, since there are at least n/2 of them.\\n\\nNow for this problem, the only difference is that there are two candidates, corresponding to two survivors that we pick. And whenever an element vanishes in a battle, there are at least (exactly) 2 other elements die with it. Hence, whenever an element with occurences > n/3 dies (no matter it is a current candidate or not), there are at least 2 other elements die with it. So it survives.\\n\\nRigorous proof this problem:\\nThe above intuitive idea can easily be turned into a rigorous proof.\\nLet\\'s prove by contradiction, suppose an element with occurences > n/3 is not a candidate after the algorithm finishes. Then, they must be all cancelled out at a certain point (either got counted down as a candidate element, or as a non-candidate to cause two candidates counted down), this corresponds to all of them vanishes in the battle. But whenever a cancellation occurs, three elements are recorded (two candidates counted down, and one non-candidate got passed), this corresponds to whenever an element dies, two others die with it. So in total, there are > 3*(n/3) elements recorded, but there are only n elements. Contradiction.\\n\\nGeneralization:\\nAs one can see, the point is whenever an element dies, 2 others die with it. For general k,  just choose k candidates, and there will be (k-1) elements die with it. The proof is almost verbatim.\\n"
                    },
                    {
                        "username": "malkaraj",
                        "content": "able to solve this problem thanks"
                    },
                    {
                        "username": "ashu_kr",
                        "content": "[@Amarjeet Kumar](/getbusylivingOrgetbusydying) because only two candidate greater than two is only possible\\nlet the 2 candidate be greater than n/3 and the remaining will be x\\n(>n/3)+(>n/3)+x=n     \\ntherefore,x<n/3;// so the 3rd element will occur less than n/3 times\\nthat\\'s why we are taking 2 candidate"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "why taking two candidate here??\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro I can\\'t thank you enough for this explanation. People underestimate how much intuition understanding of a problem is necessary."
                    },
                    {
                        "username": "shivanshx365",
                        "content": "Nice Explanation \\uD83D\\uDC4D"
                    },
                    {
                        "username": "prtyhr",
                        "content": "the battle analogy was great, thanks!"
                    },
                    {
                        "username": "tekmark",
                        "content": "i am so dumb."
                    },
                    {
                        "username": "pramoth-kj",
                        "content": "Same as me\\n"
                    },
                    {
                        "username": "workspace9801",
                        "content": ":-<\\n"
                    },
                    {
                        "username": "justine-135",
                        "content": "LMAO sorry i\\'m so u"
                    },
                    {
                        "username": "munenndragaur",
                        "content": "[@ajinkode](/ajinkode) yeah he is correct make use of brain and pen and paper \\nyou will baap of these qustions "
                    },
                    {
                        "username": "ajinkode",
                        "content": "You are not dumb. You just haven\\'t practiced enough problems yet  :)"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i\\'m also "
                    },
                    {
                        "username": "irshadcc135",
                        "content": "Hint explanation\n\nLet n denote total number of elements. \n\n\nIf an element \"a\" occurs more than n/3 times, then number of elements excluding \"a\" is \n\nn - ((n/3)+1)  = (2n-3)/3 \n\nIf an element \"b\" occurs more than n/3 times, then number of element excluding \"a\" and \"b\" is \n\n((2n-3)/3) - ((n/3) +1) = (n-6)/3 \n\nNow we have only left (n-6)/3 elements, and no elements can occur more than (n/3) times, since (n-6)/3 is less than (n/3)\n\nWe only have to look for 2 elements using O(n) algorithm. I hope the hint make sense now. \n"
                    },
                    {
                        "username": "lgylym",
                        "content": "And it\\'ll absurd if the interviewer is looking for that.\\n\\nVery interesting algorithm though."
                    },
                    {
                        "username": "Daciuk",
                        "content": "Did leetcode just not give us test cases that show the strength of O(1) space?  Does that make sense to anyone?"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "nah, not at all"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Freaking mind-blowing problem!"
                    },
                    {
                        "username": "ankush920",
                        "content": "I CRACK THE ACTUAL CONCEPT MOLDING FOR ALL N/NUM|| MUST ONE TIME WATCH || )(N) || 0(1)\\nankush920\\n0\\nin a few seconds\\nC++\\nIntuition\\nhello community , i appricate your presence and belive me try to conveny my thought process with my best .( sorry if my language is not so strong )\\n\\nprocess\\n-> we have to find the element have freq more than ( not equal ) n/i ( 2<i<n)\\n\\npointer and counter\\nfor n/i we have to take i-1 pointer and i-1 ;\\nwhy?\\n-> because in n size array only maximum i-1 element is present who is more than freq of n/i\\nbecause they are more then n/i time (not equal more than )\\n\\nlook => n-(i-1)((n/i)+1) > n/i (put value and can check it )\\npointer store\\nbecause each pointer show one possible majority element so, each pointer store unique value or number or candidate\\n\\nmanually check\\nwe have to verify our pointer value( number store in pointer )\\nis actually a majority element or not by checking it occurence\\n\\n-> do iteration and count their frq == n/i+1 if yes then push to ans vector if no leave it\\n\\nwhy we do manually check ?\\nbecause while traversing through array we put some value in pointer which may or may not be our answer ( look one time code you understand my point :) )\\n\\nsupport my hard by your love -> upvote\\nApproach\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        \\n        int cnt1 = 0 ,  cnt2= 0 ; \\n         int x = INT_MAX , y= INT_MAX;\\n         vector<int>ans;\\n\\n         for( auto it : nums )\\n         {\\n            if( cnt1 ==0 && y!=it ) {  x = it ; cnt1 =1; }\\n\\n            else if(cnt2 ==0 && x!= it ) { y =it ; cnt2=1 ;}\\n            \\n         else if( x==it) { cnt1 ++; }\\n\\n         else if( y==it ){ cnt2++; }\\n\\n         else {cnt1--; cnt2--;}\\n\\n         }\\n         cnt1 =0 ;cnt2 =0;\\n      \\n      int val = (nums.size()/3)+1; \\n\\n\\n      for(auto it :nums)\\n      {\\n          if( x==it) { cnt1 ++ ; }\\n\\n          if( y ==it ) { cnt2++ ; }\\n\\n           if( cnt1 ==val) { ans.push_back(it); cnt1 = 0; x = INT_MAX;}\\n           \\n           if( cnt2 ==val) { ans.push_back(it); cnt2 = 0;  y =INT_MAX ;}\\n      }\\n         \\n         return ans ;\\n    \\n    }\\n};"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The follow up in O(1) space is hard, and the original question is easy, neither of them are medium. \n\nAnything that I can solve in under 5 minutes with a one-liner can't be a medium. Anything that requires you to come up with an algorithm which bears not one but two names of famous dudes probably can't be medium either"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This! I don\\'t why people think ask problems like these which are very easy after knowing the trick/algo and are super hard if you don\\'t."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Very Intersting algorithm"
                    },
                    {
                        "username": "asthakul17",
                        "content": "it should be marked easy"
                    },
                    {
                        "username": "zcore",
                        "content": "The space constraint is O(1), read the follow up, that is what makes it a medium problem."
                    }
                ]
            },
            {
                "id": 1567923,
                "content": [
                    {
                        "username": "alanmiller",
                        "content": "This article is for those who are familiar with how Moore\\'s voting algorithm is implemented, but don\\'t understand why it works, or seeks for a rigorous proof of its correctness.\\n\\nIntuitive idea:\\nLet\\'s start with the basic case: [169. Majority Element](https://leetcode.com/problems/majority-element/)\\nOne can think of the algorithm as a battle process, whenever two different elements encountered, the battle occurs, and they both vanishes. The candidate is whoever that survives this battle process. The point here is that whenever a majority element vanishes (no matter it is the current candidate or not), there is at least (exactly) one other element dies with it. Hence, the majority element survives, since there are at least n/2 of them.\\n\\nNow for this problem, the only difference is that there are two candidates, corresponding to two survivors that we pick. And whenever an element vanishes in a battle, there are at least (exactly) 2 other elements die with it. Hence, whenever an element with occurences > n/3 dies (no matter it is a current candidate or not), there are at least 2 other elements die with it. So it survives.\\n\\nRigorous proof this problem:\\nThe above intuitive idea can easily be turned into a rigorous proof.\\nLet\\'s prove by contradiction, suppose an element with occurences > n/3 is not a candidate after the algorithm finishes. Then, they must be all cancelled out at a certain point (either got counted down as a candidate element, or as a non-candidate to cause two candidates counted down), this corresponds to all of them vanishes in the battle. But whenever a cancellation occurs, three elements are recorded (two candidates counted down, and one non-candidate got passed), this corresponds to whenever an element dies, two others die with it. So in total, there are > 3*(n/3) elements recorded, but there are only n elements. Contradiction.\\n\\nGeneralization:\\nAs one can see, the point is whenever an element dies, 2 others die with it. For general k,  just choose k candidates, and there will be (k-1) elements die with it. The proof is almost verbatim.\\n"
                    },
                    {
                        "username": "malkaraj",
                        "content": "able to solve this problem thanks"
                    },
                    {
                        "username": "ashu_kr",
                        "content": "[@Amarjeet Kumar](/getbusylivingOrgetbusydying) because only two candidate greater than two is only possible\\nlet the 2 candidate be greater than n/3 and the remaining will be x\\n(>n/3)+(>n/3)+x=n     \\ntherefore,x<n/3;// so the 3rd element will occur less than n/3 times\\nthat\\'s why we are taking 2 candidate"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "why taking two candidate here??\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro I can\\'t thank you enough for this explanation. People underestimate how much intuition understanding of a problem is necessary."
                    },
                    {
                        "username": "shivanshx365",
                        "content": "Nice Explanation \\uD83D\\uDC4D"
                    },
                    {
                        "username": "prtyhr",
                        "content": "the battle analogy was great, thanks!"
                    },
                    {
                        "username": "tekmark",
                        "content": "i am so dumb."
                    },
                    {
                        "username": "pramoth-kj",
                        "content": "Same as me\\n"
                    },
                    {
                        "username": "workspace9801",
                        "content": ":-<\\n"
                    },
                    {
                        "username": "justine-135",
                        "content": "LMAO sorry i\\'m so u"
                    },
                    {
                        "username": "munenndragaur",
                        "content": "[@ajinkode](/ajinkode) yeah he is correct make use of brain and pen and paper \\nyou will baap of these qustions "
                    },
                    {
                        "username": "ajinkode",
                        "content": "You are not dumb. You just haven\\'t practiced enough problems yet  :)"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i\\'m also "
                    },
                    {
                        "username": "irshadcc135",
                        "content": "Hint explanation\n\nLet n denote total number of elements. \n\n\nIf an element \"a\" occurs more than n/3 times, then number of elements excluding \"a\" is \n\nn - ((n/3)+1)  = (2n-3)/3 \n\nIf an element \"b\" occurs more than n/3 times, then number of element excluding \"a\" and \"b\" is \n\n((2n-3)/3) - ((n/3) +1) = (n-6)/3 \n\nNow we have only left (n-6)/3 elements, and no elements can occur more than (n/3) times, since (n-6)/3 is less than (n/3)\n\nWe only have to look for 2 elements using O(n) algorithm. I hope the hint make sense now. \n"
                    },
                    {
                        "username": "lgylym",
                        "content": "And it\\'ll absurd if the interviewer is looking for that.\\n\\nVery interesting algorithm though."
                    },
                    {
                        "username": "Daciuk",
                        "content": "Did leetcode just not give us test cases that show the strength of O(1) space?  Does that make sense to anyone?"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "nah, not at all"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Freaking mind-blowing problem!"
                    },
                    {
                        "username": "ankush920",
                        "content": "I CRACK THE ACTUAL CONCEPT MOLDING FOR ALL N/NUM|| MUST ONE TIME WATCH || )(N) || 0(1)\\nankush920\\n0\\nin a few seconds\\nC++\\nIntuition\\nhello community , i appricate your presence and belive me try to conveny my thought process with my best .( sorry if my language is not so strong )\\n\\nprocess\\n-> we have to find the element have freq more than ( not equal ) n/i ( 2<i<n)\\n\\npointer and counter\\nfor n/i we have to take i-1 pointer and i-1 ;\\nwhy?\\n-> because in n size array only maximum i-1 element is present who is more than freq of n/i\\nbecause they are more then n/i time (not equal more than )\\n\\nlook => n-(i-1)((n/i)+1) > n/i (put value and can check it )\\npointer store\\nbecause each pointer show one possible majority element so, each pointer store unique value or number or candidate\\n\\nmanually check\\nwe have to verify our pointer value( number store in pointer )\\nis actually a majority element or not by checking it occurence\\n\\n-> do iteration and count their frq == n/i+1 if yes then push to ans vector if no leave it\\n\\nwhy we do manually check ?\\nbecause while traversing through array we put some value in pointer which may or may not be our answer ( look one time code you understand my point :) )\\n\\nsupport my hard by your love -> upvote\\nApproach\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        \\n        int cnt1 = 0 ,  cnt2= 0 ; \\n         int x = INT_MAX , y= INT_MAX;\\n         vector<int>ans;\\n\\n         for( auto it : nums )\\n         {\\n            if( cnt1 ==0 && y!=it ) {  x = it ; cnt1 =1; }\\n\\n            else if(cnt2 ==0 && x!= it ) { y =it ; cnt2=1 ;}\\n            \\n         else if( x==it) { cnt1 ++; }\\n\\n         else if( y==it ){ cnt2++; }\\n\\n         else {cnt1--; cnt2--;}\\n\\n         }\\n         cnt1 =0 ;cnt2 =0;\\n      \\n      int val = (nums.size()/3)+1; \\n\\n\\n      for(auto it :nums)\\n      {\\n          if( x==it) { cnt1 ++ ; }\\n\\n          if( y ==it ) { cnt2++ ; }\\n\\n           if( cnt1 ==val) { ans.push_back(it); cnt1 = 0; x = INT_MAX;}\\n           \\n           if( cnt2 ==val) { ans.push_back(it); cnt2 = 0;  y =INT_MAX ;}\\n      }\\n         \\n         return ans ;\\n    \\n    }\\n};"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The follow up in O(1) space is hard, and the original question is easy, neither of them are medium. \n\nAnything that I can solve in under 5 minutes with a one-liner can't be a medium. Anything that requires you to come up with an algorithm which bears not one but two names of famous dudes probably can't be medium either"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This! I don\\'t why people think ask problems like these which are very easy after knowing the trick/algo and are super hard if you don\\'t."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Very Intersting algorithm"
                    },
                    {
                        "username": "asthakul17",
                        "content": "it should be marked easy"
                    },
                    {
                        "username": "zcore",
                        "content": "The space constraint is O(1), read the follow up, that is what makes it a medium problem."
                    }
                ]
            },
            {
                "id": 1782535,
                "content": [
                    {
                        "username": "alanmiller",
                        "content": "This article is for those who are familiar with how Moore\\'s voting algorithm is implemented, but don\\'t understand why it works, or seeks for a rigorous proof of its correctness.\\n\\nIntuitive idea:\\nLet\\'s start with the basic case: [169. Majority Element](https://leetcode.com/problems/majority-element/)\\nOne can think of the algorithm as a battle process, whenever two different elements encountered, the battle occurs, and they both vanishes. The candidate is whoever that survives this battle process. The point here is that whenever a majority element vanishes (no matter it is the current candidate or not), there is at least (exactly) one other element dies with it. Hence, the majority element survives, since there are at least n/2 of them.\\n\\nNow for this problem, the only difference is that there are two candidates, corresponding to two survivors that we pick. And whenever an element vanishes in a battle, there are at least (exactly) 2 other elements die with it. Hence, whenever an element with occurences > n/3 dies (no matter it is a current candidate or not), there are at least 2 other elements die with it. So it survives.\\n\\nRigorous proof this problem:\\nThe above intuitive idea can easily be turned into a rigorous proof.\\nLet\\'s prove by contradiction, suppose an element with occurences > n/3 is not a candidate after the algorithm finishes. Then, they must be all cancelled out at a certain point (either got counted down as a candidate element, or as a non-candidate to cause two candidates counted down), this corresponds to all of them vanishes in the battle. But whenever a cancellation occurs, three elements are recorded (two candidates counted down, and one non-candidate got passed), this corresponds to whenever an element dies, two others die with it. So in total, there are > 3*(n/3) elements recorded, but there are only n elements. Contradiction.\\n\\nGeneralization:\\nAs one can see, the point is whenever an element dies, 2 others die with it. For general k,  just choose k candidates, and there will be (k-1) elements die with it. The proof is almost verbatim.\\n"
                    },
                    {
                        "username": "malkaraj",
                        "content": "able to solve this problem thanks"
                    },
                    {
                        "username": "ashu_kr",
                        "content": "[@Amarjeet Kumar](/getbusylivingOrgetbusydying) because only two candidate greater than two is only possible\\nlet the 2 candidate be greater than n/3 and the remaining will be x\\n(>n/3)+(>n/3)+x=n     \\ntherefore,x<n/3;// so the 3rd element will occur less than n/3 times\\nthat\\'s why we are taking 2 candidate"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "why taking two candidate here??\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro I can\\'t thank you enough for this explanation. People underestimate how much intuition understanding of a problem is necessary."
                    },
                    {
                        "username": "shivanshx365",
                        "content": "Nice Explanation \\uD83D\\uDC4D"
                    },
                    {
                        "username": "prtyhr",
                        "content": "the battle analogy was great, thanks!"
                    },
                    {
                        "username": "tekmark",
                        "content": "i am so dumb."
                    },
                    {
                        "username": "pramoth-kj",
                        "content": "Same as me\\n"
                    },
                    {
                        "username": "workspace9801",
                        "content": ":-<\\n"
                    },
                    {
                        "username": "justine-135",
                        "content": "LMAO sorry i\\'m so u"
                    },
                    {
                        "username": "munenndragaur",
                        "content": "[@ajinkode](/ajinkode) yeah he is correct make use of brain and pen and paper \\nyou will baap of these qustions "
                    },
                    {
                        "username": "ajinkode",
                        "content": "You are not dumb. You just haven\\'t practiced enough problems yet  :)"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i\\'m also "
                    },
                    {
                        "username": "irshadcc135",
                        "content": "Hint explanation\n\nLet n denote total number of elements. \n\n\nIf an element \"a\" occurs more than n/3 times, then number of elements excluding \"a\" is \n\nn - ((n/3)+1)  = (2n-3)/3 \n\nIf an element \"b\" occurs more than n/3 times, then number of element excluding \"a\" and \"b\" is \n\n((2n-3)/3) - ((n/3) +1) = (n-6)/3 \n\nNow we have only left (n-6)/3 elements, and no elements can occur more than (n/3) times, since (n-6)/3 is less than (n/3)\n\nWe only have to look for 2 elements using O(n) algorithm. I hope the hint make sense now. \n"
                    },
                    {
                        "username": "lgylym",
                        "content": "And it\\'ll absurd if the interviewer is looking for that.\\n\\nVery interesting algorithm though."
                    },
                    {
                        "username": "Daciuk",
                        "content": "Did leetcode just not give us test cases that show the strength of O(1) space?  Does that make sense to anyone?"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "nah, not at all"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Freaking mind-blowing problem!"
                    },
                    {
                        "username": "ankush920",
                        "content": "I CRACK THE ACTUAL CONCEPT MOLDING FOR ALL N/NUM|| MUST ONE TIME WATCH || )(N) || 0(1)\\nankush920\\n0\\nin a few seconds\\nC++\\nIntuition\\nhello community , i appricate your presence and belive me try to conveny my thought process with my best .( sorry if my language is not so strong )\\n\\nprocess\\n-> we have to find the element have freq more than ( not equal ) n/i ( 2<i<n)\\n\\npointer and counter\\nfor n/i we have to take i-1 pointer and i-1 ;\\nwhy?\\n-> because in n size array only maximum i-1 element is present who is more than freq of n/i\\nbecause they are more then n/i time (not equal more than )\\n\\nlook => n-(i-1)((n/i)+1) > n/i (put value and can check it )\\npointer store\\nbecause each pointer show one possible majority element so, each pointer store unique value or number or candidate\\n\\nmanually check\\nwe have to verify our pointer value( number store in pointer )\\nis actually a majority element or not by checking it occurence\\n\\n-> do iteration and count their frq == n/i+1 if yes then push to ans vector if no leave it\\n\\nwhy we do manually check ?\\nbecause while traversing through array we put some value in pointer which may or may not be our answer ( look one time code you understand my point :) )\\n\\nsupport my hard by your love -> upvote\\nApproach\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        \\n        int cnt1 = 0 ,  cnt2= 0 ; \\n         int x = INT_MAX , y= INT_MAX;\\n         vector<int>ans;\\n\\n         for( auto it : nums )\\n         {\\n            if( cnt1 ==0 && y!=it ) {  x = it ; cnt1 =1; }\\n\\n            else if(cnt2 ==0 && x!= it ) { y =it ; cnt2=1 ;}\\n            \\n         else if( x==it) { cnt1 ++; }\\n\\n         else if( y==it ){ cnt2++; }\\n\\n         else {cnt1--; cnt2--;}\\n\\n         }\\n         cnt1 =0 ;cnt2 =0;\\n      \\n      int val = (nums.size()/3)+1; \\n\\n\\n      for(auto it :nums)\\n      {\\n          if( x==it) { cnt1 ++ ; }\\n\\n          if( y ==it ) { cnt2++ ; }\\n\\n           if( cnt1 ==val) { ans.push_back(it); cnt1 = 0; x = INT_MAX;}\\n           \\n           if( cnt2 ==val) { ans.push_back(it); cnt2 = 0;  y =INT_MAX ;}\\n      }\\n         \\n         return ans ;\\n    \\n    }\\n};"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The follow up in O(1) space is hard, and the original question is easy, neither of them are medium. \n\nAnything that I can solve in under 5 minutes with a one-liner can't be a medium. Anything that requires you to come up with an algorithm which bears not one but two names of famous dudes probably can't be medium either"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This! I don\\'t why people think ask problems like these which are very easy after knowing the trick/algo and are super hard if you don\\'t."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Very Intersting algorithm"
                    },
                    {
                        "username": "asthakul17",
                        "content": "it should be marked easy"
                    },
                    {
                        "username": "zcore",
                        "content": "The space constraint is O(1), read the follow up, that is what makes it a medium problem."
                    }
                ]
            },
            {
                "id": 1567298,
                "content": [
                    {
                        "username": "alanmiller",
                        "content": "This article is for those who are familiar with how Moore\\'s voting algorithm is implemented, but don\\'t understand why it works, or seeks for a rigorous proof of its correctness.\\n\\nIntuitive idea:\\nLet\\'s start with the basic case: [169. Majority Element](https://leetcode.com/problems/majority-element/)\\nOne can think of the algorithm as a battle process, whenever two different elements encountered, the battle occurs, and they both vanishes. The candidate is whoever that survives this battle process. The point here is that whenever a majority element vanishes (no matter it is the current candidate or not), there is at least (exactly) one other element dies with it. Hence, the majority element survives, since there are at least n/2 of them.\\n\\nNow for this problem, the only difference is that there are two candidates, corresponding to two survivors that we pick. And whenever an element vanishes in a battle, there are at least (exactly) 2 other elements die with it. Hence, whenever an element with occurences > n/3 dies (no matter it is a current candidate or not), there are at least 2 other elements die with it. So it survives.\\n\\nRigorous proof this problem:\\nThe above intuitive idea can easily be turned into a rigorous proof.\\nLet\\'s prove by contradiction, suppose an element with occurences > n/3 is not a candidate after the algorithm finishes. Then, they must be all cancelled out at a certain point (either got counted down as a candidate element, or as a non-candidate to cause two candidates counted down), this corresponds to all of them vanishes in the battle. But whenever a cancellation occurs, three elements are recorded (two candidates counted down, and one non-candidate got passed), this corresponds to whenever an element dies, two others die with it. So in total, there are > 3*(n/3) elements recorded, but there are only n elements. Contradiction.\\n\\nGeneralization:\\nAs one can see, the point is whenever an element dies, 2 others die with it. For general k,  just choose k candidates, and there will be (k-1) elements die with it. The proof is almost verbatim.\\n"
                    },
                    {
                        "username": "malkaraj",
                        "content": "able to solve this problem thanks"
                    },
                    {
                        "username": "ashu_kr",
                        "content": "[@Amarjeet Kumar](/getbusylivingOrgetbusydying) because only two candidate greater than two is only possible\\nlet the 2 candidate be greater than n/3 and the remaining will be x\\n(>n/3)+(>n/3)+x=n     \\ntherefore,x<n/3;// so the 3rd element will occur less than n/3 times\\nthat\\'s why we are taking 2 candidate"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "why taking two candidate here??\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro I can\\'t thank you enough for this explanation. People underestimate how much intuition understanding of a problem is necessary."
                    },
                    {
                        "username": "shivanshx365",
                        "content": "Nice Explanation \\uD83D\\uDC4D"
                    },
                    {
                        "username": "prtyhr",
                        "content": "the battle analogy was great, thanks!"
                    },
                    {
                        "username": "tekmark",
                        "content": "i am so dumb."
                    },
                    {
                        "username": "pramoth-kj",
                        "content": "Same as me\\n"
                    },
                    {
                        "username": "workspace9801",
                        "content": ":-<\\n"
                    },
                    {
                        "username": "justine-135",
                        "content": "LMAO sorry i\\'m so u"
                    },
                    {
                        "username": "munenndragaur",
                        "content": "[@ajinkode](/ajinkode) yeah he is correct make use of brain and pen and paper \\nyou will baap of these qustions "
                    },
                    {
                        "username": "ajinkode",
                        "content": "You are not dumb. You just haven\\'t practiced enough problems yet  :)"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i\\'m also "
                    },
                    {
                        "username": "irshadcc135",
                        "content": "Hint explanation\n\nLet n denote total number of elements. \n\n\nIf an element \"a\" occurs more than n/3 times, then number of elements excluding \"a\" is \n\nn - ((n/3)+1)  = (2n-3)/3 \n\nIf an element \"b\" occurs more than n/3 times, then number of element excluding \"a\" and \"b\" is \n\n((2n-3)/3) - ((n/3) +1) = (n-6)/3 \n\nNow we have only left (n-6)/3 elements, and no elements can occur more than (n/3) times, since (n-6)/3 is less than (n/3)\n\nWe only have to look for 2 elements using O(n) algorithm. I hope the hint make sense now. \n"
                    },
                    {
                        "username": "lgylym",
                        "content": "And it\\'ll absurd if the interviewer is looking for that.\\n\\nVery interesting algorithm though."
                    },
                    {
                        "username": "Daciuk",
                        "content": "Did leetcode just not give us test cases that show the strength of O(1) space?  Does that make sense to anyone?"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "nah, not at all"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Freaking mind-blowing problem!"
                    },
                    {
                        "username": "ankush920",
                        "content": "I CRACK THE ACTUAL CONCEPT MOLDING FOR ALL N/NUM|| MUST ONE TIME WATCH || )(N) || 0(1)\\nankush920\\n0\\nin a few seconds\\nC++\\nIntuition\\nhello community , i appricate your presence and belive me try to conveny my thought process with my best .( sorry if my language is not so strong )\\n\\nprocess\\n-> we have to find the element have freq more than ( not equal ) n/i ( 2<i<n)\\n\\npointer and counter\\nfor n/i we have to take i-1 pointer and i-1 ;\\nwhy?\\n-> because in n size array only maximum i-1 element is present who is more than freq of n/i\\nbecause they are more then n/i time (not equal more than )\\n\\nlook => n-(i-1)((n/i)+1) > n/i (put value and can check it )\\npointer store\\nbecause each pointer show one possible majority element so, each pointer store unique value or number or candidate\\n\\nmanually check\\nwe have to verify our pointer value( number store in pointer )\\nis actually a majority element or not by checking it occurence\\n\\n-> do iteration and count their frq == n/i+1 if yes then push to ans vector if no leave it\\n\\nwhy we do manually check ?\\nbecause while traversing through array we put some value in pointer which may or may not be our answer ( look one time code you understand my point :) )\\n\\nsupport my hard by your love -> upvote\\nApproach\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        \\n        int cnt1 = 0 ,  cnt2= 0 ; \\n         int x = INT_MAX , y= INT_MAX;\\n         vector<int>ans;\\n\\n         for( auto it : nums )\\n         {\\n            if( cnt1 ==0 && y!=it ) {  x = it ; cnt1 =1; }\\n\\n            else if(cnt2 ==0 && x!= it ) { y =it ; cnt2=1 ;}\\n            \\n         else if( x==it) { cnt1 ++; }\\n\\n         else if( y==it ){ cnt2++; }\\n\\n         else {cnt1--; cnt2--;}\\n\\n         }\\n         cnt1 =0 ;cnt2 =0;\\n      \\n      int val = (nums.size()/3)+1; \\n\\n\\n      for(auto it :nums)\\n      {\\n          if( x==it) { cnt1 ++ ; }\\n\\n          if( y ==it ) { cnt2++ ; }\\n\\n           if( cnt1 ==val) { ans.push_back(it); cnt1 = 0; x = INT_MAX;}\\n           \\n           if( cnt2 ==val) { ans.push_back(it); cnt2 = 0;  y =INT_MAX ;}\\n      }\\n         \\n         return ans ;\\n    \\n    }\\n};"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The follow up in O(1) space is hard, and the original question is easy, neither of them are medium. \n\nAnything that I can solve in under 5 minutes with a one-liner can't be a medium. Anything that requires you to come up with an algorithm which bears not one but two names of famous dudes probably can't be medium either"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This! I don\\'t why people think ask problems like these which are very easy after knowing the trick/algo and are super hard if you don\\'t."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Very Intersting algorithm"
                    },
                    {
                        "username": "asthakul17",
                        "content": "it should be marked easy"
                    },
                    {
                        "username": "zcore",
                        "content": "The space constraint is O(1), read the follow up, that is what makes it a medium problem."
                    }
                ]
            },
            {
                "id": 1569972,
                "content": [
                    {
                        "username": "alanmiller",
                        "content": "This article is for those who are familiar with how Moore\\'s voting algorithm is implemented, but don\\'t understand why it works, or seeks for a rigorous proof of its correctness.\\n\\nIntuitive idea:\\nLet\\'s start with the basic case: [169. Majority Element](https://leetcode.com/problems/majority-element/)\\nOne can think of the algorithm as a battle process, whenever two different elements encountered, the battle occurs, and they both vanishes. The candidate is whoever that survives this battle process. The point here is that whenever a majority element vanishes (no matter it is the current candidate or not), there is at least (exactly) one other element dies with it. Hence, the majority element survives, since there are at least n/2 of them.\\n\\nNow for this problem, the only difference is that there are two candidates, corresponding to two survivors that we pick. And whenever an element vanishes in a battle, there are at least (exactly) 2 other elements die with it. Hence, whenever an element with occurences > n/3 dies (no matter it is a current candidate or not), there are at least 2 other elements die with it. So it survives.\\n\\nRigorous proof this problem:\\nThe above intuitive idea can easily be turned into a rigorous proof.\\nLet\\'s prove by contradiction, suppose an element with occurences > n/3 is not a candidate after the algorithm finishes. Then, they must be all cancelled out at a certain point (either got counted down as a candidate element, or as a non-candidate to cause two candidates counted down), this corresponds to all of them vanishes in the battle. But whenever a cancellation occurs, three elements are recorded (two candidates counted down, and one non-candidate got passed), this corresponds to whenever an element dies, two others die with it. So in total, there are > 3*(n/3) elements recorded, but there are only n elements. Contradiction.\\n\\nGeneralization:\\nAs one can see, the point is whenever an element dies, 2 others die with it. For general k,  just choose k candidates, and there will be (k-1) elements die with it. The proof is almost verbatim.\\n"
                    },
                    {
                        "username": "malkaraj",
                        "content": "able to solve this problem thanks"
                    },
                    {
                        "username": "ashu_kr",
                        "content": "[@Amarjeet Kumar](/getbusylivingOrgetbusydying) because only two candidate greater than two is only possible\\nlet the 2 candidate be greater than n/3 and the remaining will be x\\n(>n/3)+(>n/3)+x=n     \\ntherefore,x<n/3;// so the 3rd element will occur less than n/3 times\\nthat\\'s why we are taking 2 candidate"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "why taking two candidate here??\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro I can\\'t thank you enough for this explanation. People underestimate how much intuition understanding of a problem is necessary."
                    },
                    {
                        "username": "shivanshx365",
                        "content": "Nice Explanation \\uD83D\\uDC4D"
                    },
                    {
                        "username": "prtyhr",
                        "content": "the battle analogy was great, thanks!"
                    },
                    {
                        "username": "tekmark",
                        "content": "i am so dumb."
                    },
                    {
                        "username": "pramoth-kj",
                        "content": "Same as me\\n"
                    },
                    {
                        "username": "workspace9801",
                        "content": ":-<\\n"
                    },
                    {
                        "username": "justine-135",
                        "content": "LMAO sorry i\\'m so u"
                    },
                    {
                        "username": "munenndragaur",
                        "content": "[@ajinkode](/ajinkode) yeah he is correct make use of brain and pen and paper \\nyou will baap of these qustions "
                    },
                    {
                        "username": "ajinkode",
                        "content": "You are not dumb. You just haven\\'t practiced enough problems yet  :)"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i\\'m also "
                    },
                    {
                        "username": "irshadcc135",
                        "content": "Hint explanation\n\nLet n denote total number of elements. \n\n\nIf an element \"a\" occurs more than n/3 times, then number of elements excluding \"a\" is \n\nn - ((n/3)+1)  = (2n-3)/3 \n\nIf an element \"b\" occurs more than n/3 times, then number of element excluding \"a\" and \"b\" is \n\n((2n-3)/3) - ((n/3) +1) = (n-6)/3 \n\nNow we have only left (n-6)/3 elements, and no elements can occur more than (n/3) times, since (n-6)/3 is less than (n/3)\n\nWe only have to look for 2 elements using O(n) algorithm. I hope the hint make sense now. \n"
                    },
                    {
                        "username": "lgylym",
                        "content": "And it\\'ll absurd if the interviewer is looking for that.\\n\\nVery interesting algorithm though."
                    },
                    {
                        "username": "Daciuk",
                        "content": "Did leetcode just not give us test cases that show the strength of O(1) space?  Does that make sense to anyone?"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "nah, not at all"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Freaking mind-blowing problem!"
                    },
                    {
                        "username": "ankush920",
                        "content": "I CRACK THE ACTUAL CONCEPT MOLDING FOR ALL N/NUM|| MUST ONE TIME WATCH || )(N) || 0(1)\\nankush920\\n0\\nin a few seconds\\nC++\\nIntuition\\nhello community , i appricate your presence and belive me try to conveny my thought process with my best .( sorry if my language is not so strong )\\n\\nprocess\\n-> we have to find the element have freq more than ( not equal ) n/i ( 2<i<n)\\n\\npointer and counter\\nfor n/i we have to take i-1 pointer and i-1 ;\\nwhy?\\n-> because in n size array only maximum i-1 element is present who is more than freq of n/i\\nbecause they are more then n/i time (not equal more than )\\n\\nlook => n-(i-1)((n/i)+1) > n/i (put value and can check it )\\npointer store\\nbecause each pointer show one possible majority element so, each pointer store unique value or number or candidate\\n\\nmanually check\\nwe have to verify our pointer value( number store in pointer )\\nis actually a majority element or not by checking it occurence\\n\\n-> do iteration and count their frq == n/i+1 if yes then push to ans vector if no leave it\\n\\nwhy we do manually check ?\\nbecause while traversing through array we put some value in pointer which may or may not be our answer ( look one time code you understand my point :) )\\n\\nsupport my hard by your love -> upvote\\nApproach\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        \\n        int cnt1 = 0 ,  cnt2= 0 ; \\n         int x = INT_MAX , y= INT_MAX;\\n         vector<int>ans;\\n\\n         for( auto it : nums )\\n         {\\n            if( cnt1 ==0 && y!=it ) {  x = it ; cnt1 =1; }\\n\\n            else if(cnt2 ==0 && x!= it ) { y =it ; cnt2=1 ;}\\n            \\n         else if( x==it) { cnt1 ++; }\\n\\n         else if( y==it ){ cnt2++; }\\n\\n         else {cnt1--; cnt2--;}\\n\\n         }\\n         cnt1 =0 ;cnt2 =0;\\n      \\n      int val = (nums.size()/3)+1; \\n\\n\\n      for(auto it :nums)\\n      {\\n          if( x==it) { cnt1 ++ ; }\\n\\n          if( y ==it ) { cnt2++ ; }\\n\\n           if( cnt1 ==val) { ans.push_back(it); cnt1 = 0; x = INT_MAX;}\\n           \\n           if( cnt2 ==val) { ans.push_back(it); cnt2 = 0;  y =INT_MAX ;}\\n      }\\n         \\n         return ans ;\\n    \\n    }\\n};"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The follow up in O(1) space is hard, and the original question is easy, neither of them are medium. \n\nAnything that I can solve in under 5 minutes with a one-liner can't be a medium. Anything that requires you to come up with an algorithm which bears not one but two names of famous dudes probably can't be medium either"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This! I don\\'t why people think ask problems like these which are very easy after knowing the trick/algo and are super hard if you don\\'t."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Very Intersting algorithm"
                    },
                    {
                        "username": "asthakul17",
                        "content": "it should be marked easy"
                    },
                    {
                        "username": "zcore",
                        "content": "The space constraint is O(1), read the follow up, that is what makes it a medium problem."
                    }
                ]
            },
            {
                "id": 1730445,
                "content": [
                    {
                        "username": "alanmiller",
                        "content": "This article is for those who are familiar with how Moore\\'s voting algorithm is implemented, but don\\'t understand why it works, or seeks for a rigorous proof of its correctness.\\n\\nIntuitive idea:\\nLet\\'s start with the basic case: [169. Majority Element](https://leetcode.com/problems/majority-element/)\\nOne can think of the algorithm as a battle process, whenever two different elements encountered, the battle occurs, and they both vanishes. The candidate is whoever that survives this battle process. The point here is that whenever a majority element vanishes (no matter it is the current candidate or not), there is at least (exactly) one other element dies with it. Hence, the majority element survives, since there are at least n/2 of them.\\n\\nNow for this problem, the only difference is that there are two candidates, corresponding to two survivors that we pick. And whenever an element vanishes in a battle, there are at least (exactly) 2 other elements die with it. Hence, whenever an element with occurences > n/3 dies (no matter it is a current candidate or not), there are at least 2 other elements die with it. So it survives.\\n\\nRigorous proof this problem:\\nThe above intuitive idea can easily be turned into a rigorous proof.\\nLet\\'s prove by contradiction, suppose an element with occurences > n/3 is not a candidate after the algorithm finishes. Then, they must be all cancelled out at a certain point (either got counted down as a candidate element, or as a non-candidate to cause two candidates counted down), this corresponds to all of them vanishes in the battle. But whenever a cancellation occurs, three elements are recorded (two candidates counted down, and one non-candidate got passed), this corresponds to whenever an element dies, two others die with it. So in total, there are > 3*(n/3) elements recorded, but there are only n elements. Contradiction.\\n\\nGeneralization:\\nAs one can see, the point is whenever an element dies, 2 others die with it. For general k,  just choose k candidates, and there will be (k-1) elements die with it. The proof is almost verbatim.\\n"
                    },
                    {
                        "username": "malkaraj",
                        "content": "able to solve this problem thanks"
                    },
                    {
                        "username": "ashu_kr",
                        "content": "[@Amarjeet Kumar](/getbusylivingOrgetbusydying) because only two candidate greater than two is only possible\\nlet the 2 candidate be greater than n/3 and the remaining will be x\\n(>n/3)+(>n/3)+x=n     \\ntherefore,x<n/3;// so the 3rd element will occur less than n/3 times\\nthat\\'s why we are taking 2 candidate"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "why taking two candidate here??\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro I can\\'t thank you enough for this explanation. People underestimate how much intuition understanding of a problem is necessary."
                    },
                    {
                        "username": "shivanshx365",
                        "content": "Nice Explanation \\uD83D\\uDC4D"
                    },
                    {
                        "username": "prtyhr",
                        "content": "the battle analogy was great, thanks!"
                    },
                    {
                        "username": "tekmark",
                        "content": "i am so dumb."
                    },
                    {
                        "username": "pramoth-kj",
                        "content": "Same as me\\n"
                    },
                    {
                        "username": "workspace9801",
                        "content": ":-<\\n"
                    },
                    {
                        "username": "justine-135",
                        "content": "LMAO sorry i\\'m so u"
                    },
                    {
                        "username": "munenndragaur",
                        "content": "[@ajinkode](/ajinkode) yeah he is correct make use of brain and pen and paper \\nyou will baap of these qustions "
                    },
                    {
                        "username": "ajinkode",
                        "content": "You are not dumb. You just haven\\'t practiced enough problems yet  :)"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i\\'m also "
                    },
                    {
                        "username": "irshadcc135",
                        "content": "Hint explanation\n\nLet n denote total number of elements. \n\n\nIf an element \"a\" occurs more than n/3 times, then number of elements excluding \"a\" is \n\nn - ((n/3)+1)  = (2n-3)/3 \n\nIf an element \"b\" occurs more than n/3 times, then number of element excluding \"a\" and \"b\" is \n\n((2n-3)/3) - ((n/3) +1) = (n-6)/3 \n\nNow we have only left (n-6)/3 elements, and no elements can occur more than (n/3) times, since (n-6)/3 is less than (n/3)\n\nWe only have to look for 2 elements using O(n) algorithm. I hope the hint make sense now. \n"
                    },
                    {
                        "username": "lgylym",
                        "content": "And it\\'ll absurd if the interviewer is looking for that.\\n\\nVery interesting algorithm though."
                    },
                    {
                        "username": "Daciuk",
                        "content": "Did leetcode just not give us test cases that show the strength of O(1) space?  Does that make sense to anyone?"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "nah, not at all"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Freaking mind-blowing problem!"
                    },
                    {
                        "username": "ankush920",
                        "content": "I CRACK THE ACTUAL CONCEPT MOLDING FOR ALL N/NUM|| MUST ONE TIME WATCH || )(N) || 0(1)\\nankush920\\n0\\nin a few seconds\\nC++\\nIntuition\\nhello community , i appricate your presence and belive me try to conveny my thought process with my best .( sorry if my language is not so strong )\\n\\nprocess\\n-> we have to find the element have freq more than ( not equal ) n/i ( 2<i<n)\\n\\npointer and counter\\nfor n/i we have to take i-1 pointer and i-1 ;\\nwhy?\\n-> because in n size array only maximum i-1 element is present who is more than freq of n/i\\nbecause they are more then n/i time (not equal more than )\\n\\nlook => n-(i-1)((n/i)+1) > n/i (put value and can check it )\\npointer store\\nbecause each pointer show one possible majority element so, each pointer store unique value or number or candidate\\n\\nmanually check\\nwe have to verify our pointer value( number store in pointer )\\nis actually a majority element or not by checking it occurence\\n\\n-> do iteration and count their frq == n/i+1 if yes then push to ans vector if no leave it\\n\\nwhy we do manually check ?\\nbecause while traversing through array we put some value in pointer which may or may not be our answer ( look one time code you understand my point :) )\\n\\nsupport my hard by your love -> upvote\\nApproach\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        \\n        int cnt1 = 0 ,  cnt2= 0 ; \\n         int x = INT_MAX , y= INT_MAX;\\n         vector<int>ans;\\n\\n         for( auto it : nums )\\n         {\\n            if( cnt1 ==0 && y!=it ) {  x = it ; cnt1 =1; }\\n\\n            else if(cnt2 ==0 && x!= it ) { y =it ; cnt2=1 ;}\\n            \\n         else if( x==it) { cnt1 ++; }\\n\\n         else if( y==it ){ cnt2++; }\\n\\n         else {cnt1--; cnt2--;}\\n\\n         }\\n         cnt1 =0 ;cnt2 =0;\\n      \\n      int val = (nums.size()/3)+1; \\n\\n\\n      for(auto it :nums)\\n      {\\n          if( x==it) { cnt1 ++ ; }\\n\\n          if( y ==it ) { cnt2++ ; }\\n\\n           if( cnt1 ==val) { ans.push_back(it); cnt1 = 0; x = INT_MAX;}\\n           \\n           if( cnt2 ==val) { ans.push_back(it); cnt2 = 0;  y =INT_MAX ;}\\n      }\\n         \\n         return ans ;\\n    \\n    }\\n};"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The follow up in O(1) space is hard, and the original question is easy, neither of them are medium. \n\nAnything that I can solve in under 5 minutes with a one-liner can't be a medium. Anything that requires you to come up with an algorithm which bears not one but two names of famous dudes probably can't be medium either"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This! I don\\'t why people think ask problems like these which are very easy after knowing the trick/algo and are super hard if you don\\'t."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Very Intersting algorithm"
                    },
                    {
                        "username": "asthakul17",
                        "content": "it should be marked easy"
                    },
                    {
                        "username": "zcore",
                        "content": "The space constraint is O(1), read the follow up, that is what makes it a medium problem."
                    }
                ]
            },
            {
                "id": 1902185,
                "content": [
                    {
                        "username": "alanmiller",
                        "content": "This article is for those who are familiar with how Moore\\'s voting algorithm is implemented, but don\\'t understand why it works, or seeks for a rigorous proof of its correctness.\\n\\nIntuitive idea:\\nLet\\'s start with the basic case: [169. Majority Element](https://leetcode.com/problems/majority-element/)\\nOne can think of the algorithm as a battle process, whenever two different elements encountered, the battle occurs, and they both vanishes. The candidate is whoever that survives this battle process. The point here is that whenever a majority element vanishes (no matter it is the current candidate or not), there is at least (exactly) one other element dies with it. Hence, the majority element survives, since there are at least n/2 of them.\\n\\nNow for this problem, the only difference is that there are two candidates, corresponding to two survivors that we pick. And whenever an element vanishes in a battle, there are at least (exactly) 2 other elements die with it. Hence, whenever an element with occurences > n/3 dies (no matter it is a current candidate or not), there are at least 2 other elements die with it. So it survives.\\n\\nRigorous proof this problem:\\nThe above intuitive idea can easily be turned into a rigorous proof.\\nLet\\'s prove by contradiction, suppose an element with occurences > n/3 is not a candidate after the algorithm finishes. Then, they must be all cancelled out at a certain point (either got counted down as a candidate element, or as a non-candidate to cause two candidates counted down), this corresponds to all of them vanishes in the battle. But whenever a cancellation occurs, three elements are recorded (two candidates counted down, and one non-candidate got passed), this corresponds to whenever an element dies, two others die with it. So in total, there are > 3*(n/3) elements recorded, but there are only n elements. Contradiction.\\n\\nGeneralization:\\nAs one can see, the point is whenever an element dies, 2 others die with it. For general k,  just choose k candidates, and there will be (k-1) elements die with it. The proof is almost verbatim.\\n"
                    },
                    {
                        "username": "malkaraj",
                        "content": "able to solve this problem thanks"
                    },
                    {
                        "username": "ashu_kr",
                        "content": "[@Amarjeet Kumar](/getbusylivingOrgetbusydying) because only two candidate greater than two is only possible\\nlet the 2 candidate be greater than n/3 and the remaining will be x\\n(>n/3)+(>n/3)+x=n     \\ntherefore,x<n/3;// so the 3rd element will occur less than n/3 times\\nthat\\'s why we are taking 2 candidate"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "why taking two candidate here??\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro I can\\'t thank you enough for this explanation. People underestimate how much intuition understanding of a problem is necessary."
                    },
                    {
                        "username": "shivanshx365",
                        "content": "Nice Explanation \\uD83D\\uDC4D"
                    },
                    {
                        "username": "prtyhr",
                        "content": "the battle analogy was great, thanks!"
                    },
                    {
                        "username": "tekmark",
                        "content": "i am so dumb."
                    },
                    {
                        "username": "pramoth-kj",
                        "content": "Same as me\\n"
                    },
                    {
                        "username": "workspace9801",
                        "content": ":-<\\n"
                    },
                    {
                        "username": "justine-135",
                        "content": "LMAO sorry i\\'m so u"
                    },
                    {
                        "username": "munenndragaur",
                        "content": "[@ajinkode](/ajinkode) yeah he is correct make use of brain and pen and paper \\nyou will baap of these qustions "
                    },
                    {
                        "username": "ajinkode",
                        "content": "You are not dumb. You just haven\\'t practiced enough problems yet  :)"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i\\'m also "
                    },
                    {
                        "username": "irshadcc135",
                        "content": "Hint explanation\n\nLet n denote total number of elements. \n\n\nIf an element \"a\" occurs more than n/3 times, then number of elements excluding \"a\" is \n\nn - ((n/3)+1)  = (2n-3)/3 \n\nIf an element \"b\" occurs more than n/3 times, then number of element excluding \"a\" and \"b\" is \n\n((2n-3)/3) - ((n/3) +1) = (n-6)/3 \n\nNow we have only left (n-6)/3 elements, and no elements can occur more than (n/3) times, since (n-6)/3 is less than (n/3)\n\nWe only have to look for 2 elements using O(n) algorithm. I hope the hint make sense now. \n"
                    },
                    {
                        "username": "lgylym",
                        "content": "And it\\'ll absurd if the interviewer is looking for that.\\n\\nVery interesting algorithm though."
                    },
                    {
                        "username": "Daciuk",
                        "content": "Did leetcode just not give us test cases that show the strength of O(1) space?  Does that make sense to anyone?"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "nah, not at all"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Freaking mind-blowing problem!"
                    },
                    {
                        "username": "ankush920",
                        "content": "I CRACK THE ACTUAL CONCEPT MOLDING FOR ALL N/NUM|| MUST ONE TIME WATCH || )(N) || 0(1)\\nankush920\\n0\\nin a few seconds\\nC++\\nIntuition\\nhello community , i appricate your presence and belive me try to conveny my thought process with my best .( sorry if my language is not so strong )\\n\\nprocess\\n-> we have to find the element have freq more than ( not equal ) n/i ( 2<i<n)\\n\\npointer and counter\\nfor n/i we have to take i-1 pointer and i-1 ;\\nwhy?\\n-> because in n size array only maximum i-1 element is present who is more than freq of n/i\\nbecause they are more then n/i time (not equal more than )\\n\\nlook => n-(i-1)((n/i)+1) > n/i (put value and can check it )\\npointer store\\nbecause each pointer show one possible majority element so, each pointer store unique value or number or candidate\\n\\nmanually check\\nwe have to verify our pointer value( number store in pointer )\\nis actually a majority element or not by checking it occurence\\n\\n-> do iteration and count their frq == n/i+1 if yes then push to ans vector if no leave it\\n\\nwhy we do manually check ?\\nbecause while traversing through array we put some value in pointer which may or may not be our answer ( look one time code you understand my point :) )\\n\\nsupport my hard by your love -> upvote\\nApproach\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        \\n        int cnt1 = 0 ,  cnt2= 0 ; \\n         int x = INT_MAX , y= INT_MAX;\\n         vector<int>ans;\\n\\n         for( auto it : nums )\\n         {\\n            if( cnt1 ==0 && y!=it ) {  x = it ; cnt1 =1; }\\n\\n            else if(cnt2 ==0 && x!= it ) { y =it ; cnt2=1 ;}\\n            \\n         else if( x==it) { cnt1 ++; }\\n\\n         else if( y==it ){ cnt2++; }\\n\\n         else {cnt1--; cnt2--;}\\n\\n         }\\n         cnt1 =0 ;cnt2 =0;\\n      \\n      int val = (nums.size()/3)+1; \\n\\n\\n      for(auto it :nums)\\n      {\\n          if( x==it) { cnt1 ++ ; }\\n\\n          if( y ==it ) { cnt2++ ; }\\n\\n           if( cnt1 ==val) { ans.push_back(it); cnt1 = 0; x = INT_MAX;}\\n           \\n           if( cnt2 ==val) { ans.push_back(it); cnt2 = 0;  y =INT_MAX ;}\\n      }\\n         \\n         return ans ;\\n    \\n    }\\n};"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The follow up in O(1) space is hard, and the original question is easy, neither of them are medium. \n\nAnything that I can solve in under 5 minutes with a one-liner can't be a medium. Anything that requires you to come up with an algorithm which bears not one but two names of famous dudes probably can't be medium either"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This! I don\\'t why people think ask problems like these which are very easy after knowing the trick/algo and are super hard if you don\\'t."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Very Intersting algorithm"
                    },
                    {
                        "username": "asthakul17",
                        "content": "it should be marked easy"
                    },
                    {
                        "username": "zcore",
                        "content": "The space constraint is O(1), read the follow up, that is what makes it a medium problem."
                    }
                ]
            },
            {
                "id": 1868197,
                "content": [
                    {
                        "username": "alanmiller",
                        "content": "This article is for those who are familiar with how Moore\\'s voting algorithm is implemented, but don\\'t understand why it works, or seeks for a rigorous proof of its correctness.\\n\\nIntuitive idea:\\nLet\\'s start with the basic case: [169. Majority Element](https://leetcode.com/problems/majority-element/)\\nOne can think of the algorithm as a battle process, whenever two different elements encountered, the battle occurs, and they both vanishes. The candidate is whoever that survives this battle process. The point here is that whenever a majority element vanishes (no matter it is the current candidate or not), there is at least (exactly) one other element dies with it. Hence, the majority element survives, since there are at least n/2 of them.\\n\\nNow for this problem, the only difference is that there are two candidates, corresponding to two survivors that we pick. And whenever an element vanishes in a battle, there are at least (exactly) 2 other elements die with it. Hence, whenever an element with occurences > n/3 dies (no matter it is a current candidate or not), there are at least 2 other elements die with it. So it survives.\\n\\nRigorous proof this problem:\\nThe above intuitive idea can easily be turned into a rigorous proof.\\nLet\\'s prove by contradiction, suppose an element with occurences > n/3 is not a candidate after the algorithm finishes. Then, they must be all cancelled out at a certain point (either got counted down as a candidate element, or as a non-candidate to cause two candidates counted down), this corresponds to all of them vanishes in the battle. But whenever a cancellation occurs, three elements are recorded (two candidates counted down, and one non-candidate got passed), this corresponds to whenever an element dies, two others die with it. So in total, there are > 3*(n/3) elements recorded, but there are only n elements. Contradiction.\\n\\nGeneralization:\\nAs one can see, the point is whenever an element dies, 2 others die with it. For general k,  just choose k candidates, and there will be (k-1) elements die with it. The proof is almost verbatim.\\n"
                    },
                    {
                        "username": "malkaraj",
                        "content": "able to solve this problem thanks"
                    },
                    {
                        "username": "ashu_kr",
                        "content": "[@Amarjeet Kumar](/getbusylivingOrgetbusydying) because only two candidate greater than two is only possible\\nlet the 2 candidate be greater than n/3 and the remaining will be x\\n(>n/3)+(>n/3)+x=n     \\ntherefore,x<n/3;// so the 3rd element will occur less than n/3 times\\nthat\\'s why we are taking 2 candidate"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "why taking two candidate here??\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro I can\\'t thank you enough for this explanation. People underestimate how much intuition understanding of a problem is necessary."
                    },
                    {
                        "username": "shivanshx365",
                        "content": "Nice Explanation \\uD83D\\uDC4D"
                    },
                    {
                        "username": "prtyhr",
                        "content": "the battle analogy was great, thanks!"
                    },
                    {
                        "username": "tekmark",
                        "content": "i am so dumb."
                    },
                    {
                        "username": "pramoth-kj",
                        "content": "Same as me\\n"
                    },
                    {
                        "username": "workspace9801",
                        "content": ":-<\\n"
                    },
                    {
                        "username": "justine-135",
                        "content": "LMAO sorry i\\'m so u"
                    },
                    {
                        "username": "munenndragaur",
                        "content": "[@ajinkode](/ajinkode) yeah he is correct make use of brain and pen and paper \\nyou will baap of these qustions "
                    },
                    {
                        "username": "ajinkode",
                        "content": "You are not dumb. You just haven\\'t practiced enough problems yet  :)"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i\\'m also "
                    },
                    {
                        "username": "irshadcc135",
                        "content": "Hint explanation\n\nLet n denote total number of elements. \n\n\nIf an element \"a\" occurs more than n/3 times, then number of elements excluding \"a\" is \n\nn - ((n/3)+1)  = (2n-3)/3 \n\nIf an element \"b\" occurs more than n/3 times, then number of element excluding \"a\" and \"b\" is \n\n((2n-3)/3) - ((n/3) +1) = (n-6)/3 \n\nNow we have only left (n-6)/3 elements, and no elements can occur more than (n/3) times, since (n-6)/3 is less than (n/3)\n\nWe only have to look for 2 elements using O(n) algorithm. I hope the hint make sense now. \n"
                    },
                    {
                        "username": "lgylym",
                        "content": "And it\\'ll absurd if the interviewer is looking for that.\\n\\nVery interesting algorithm though."
                    },
                    {
                        "username": "Daciuk",
                        "content": "Did leetcode just not give us test cases that show the strength of O(1) space?  Does that make sense to anyone?"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "nah, not at all"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Freaking mind-blowing problem!"
                    },
                    {
                        "username": "ankush920",
                        "content": "I CRACK THE ACTUAL CONCEPT MOLDING FOR ALL N/NUM|| MUST ONE TIME WATCH || )(N) || 0(1)\\nankush920\\n0\\nin a few seconds\\nC++\\nIntuition\\nhello community , i appricate your presence and belive me try to conveny my thought process with my best .( sorry if my language is not so strong )\\n\\nprocess\\n-> we have to find the element have freq more than ( not equal ) n/i ( 2<i<n)\\n\\npointer and counter\\nfor n/i we have to take i-1 pointer and i-1 ;\\nwhy?\\n-> because in n size array only maximum i-1 element is present who is more than freq of n/i\\nbecause they are more then n/i time (not equal more than )\\n\\nlook => n-(i-1)((n/i)+1) > n/i (put value and can check it )\\npointer store\\nbecause each pointer show one possible majority element so, each pointer store unique value or number or candidate\\n\\nmanually check\\nwe have to verify our pointer value( number store in pointer )\\nis actually a majority element or not by checking it occurence\\n\\n-> do iteration and count their frq == n/i+1 if yes then push to ans vector if no leave it\\n\\nwhy we do manually check ?\\nbecause while traversing through array we put some value in pointer which may or may not be our answer ( look one time code you understand my point :) )\\n\\nsupport my hard by your love -> upvote\\nApproach\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        \\n        int cnt1 = 0 ,  cnt2= 0 ; \\n         int x = INT_MAX , y= INT_MAX;\\n         vector<int>ans;\\n\\n         for( auto it : nums )\\n         {\\n            if( cnt1 ==0 && y!=it ) {  x = it ; cnt1 =1; }\\n\\n            else if(cnt2 ==0 && x!= it ) { y =it ; cnt2=1 ;}\\n            \\n         else if( x==it) { cnt1 ++; }\\n\\n         else if( y==it ){ cnt2++; }\\n\\n         else {cnt1--; cnt2--;}\\n\\n         }\\n         cnt1 =0 ;cnt2 =0;\\n      \\n      int val = (nums.size()/3)+1; \\n\\n\\n      for(auto it :nums)\\n      {\\n          if( x==it) { cnt1 ++ ; }\\n\\n          if( y ==it ) { cnt2++ ; }\\n\\n           if( cnt1 ==val) { ans.push_back(it); cnt1 = 0; x = INT_MAX;}\\n           \\n           if( cnt2 ==val) { ans.push_back(it); cnt2 = 0;  y =INT_MAX ;}\\n      }\\n         \\n         return ans ;\\n    \\n    }\\n};"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The follow up in O(1) space is hard, and the original question is easy, neither of them are medium. \n\nAnything that I can solve in under 5 minutes with a one-liner can't be a medium. Anything that requires you to come up with an algorithm which bears not one but two names of famous dudes probably can't be medium either"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This! I don\\'t why people think ask problems like these which are very easy after knowing the trick/algo and are super hard if you don\\'t."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Very Intersting algorithm"
                    },
                    {
                        "username": "asthakul17",
                        "content": "it should be marked easy"
                    },
                    {
                        "username": "zcore",
                        "content": "The space constraint is O(1), read the follow up, that is what makes it a medium problem."
                    }
                ]
            },
            {
                "id": 1755924,
                "content": [
                    {
                        "username": "alanmiller",
                        "content": "This article is for those who are familiar with how Moore\\'s voting algorithm is implemented, but don\\'t understand why it works, or seeks for a rigorous proof of its correctness.\\n\\nIntuitive idea:\\nLet\\'s start with the basic case: [169. Majority Element](https://leetcode.com/problems/majority-element/)\\nOne can think of the algorithm as a battle process, whenever two different elements encountered, the battle occurs, and they both vanishes. The candidate is whoever that survives this battle process. The point here is that whenever a majority element vanishes (no matter it is the current candidate or not), there is at least (exactly) one other element dies with it. Hence, the majority element survives, since there are at least n/2 of them.\\n\\nNow for this problem, the only difference is that there are two candidates, corresponding to two survivors that we pick. And whenever an element vanishes in a battle, there are at least (exactly) 2 other elements die with it. Hence, whenever an element with occurences > n/3 dies (no matter it is a current candidate or not), there are at least 2 other elements die with it. So it survives.\\n\\nRigorous proof this problem:\\nThe above intuitive idea can easily be turned into a rigorous proof.\\nLet\\'s prove by contradiction, suppose an element with occurences > n/3 is not a candidate after the algorithm finishes. Then, they must be all cancelled out at a certain point (either got counted down as a candidate element, or as a non-candidate to cause two candidates counted down), this corresponds to all of them vanishes in the battle. But whenever a cancellation occurs, three elements are recorded (two candidates counted down, and one non-candidate got passed), this corresponds to whenever an element dies, two others die with it. So in total, there are > 3*(n/3) elements recorded, but there are only n elements. Contradiction.\\n\\nGeneralization:\\nAs one can see, the point is whenever an element dies, 2 others die with it. For general k,  just choose k candidates, and there will be (k-1) elements die with it. The proof is almost verbatim.\\n"
                    },
                    {
                        "username": "malkaraj",
                        "content": "able to solve this problem thanks"
                    },
                    {
                        "username": "ashu_kr",
                        "content": "[@Amarjeet Kumar](/getbusylivingOrgetbusydying) because only two candidate greater than two is only possible\\nlet the 2 candidate be greater than n/3 and the remaining will be x\\n(>n/3)+(>n/3)+x=n     \\ntherefore,x<n/3;// so the 3rd element will occur less than n/3 times\\nthat\\'s why we are taking 2 candidate"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "why taking two candidate here??\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro I can\\'t thank you enough for this explanation. People underestimate how much intuition understanding of a problem is necessary."
                    },
                    {
                        "username": "shivanshx365",
                        "content": "Nice Explanation \\uD83D\\uDC4D"
                    },
                    {
                        "username": "prtyhr",
                        "content": "the battle analogy was great, thanks!"
                    },
                    {
                        "username": "tekmark",
                        "content": "i am so dumb."
                    },
                    {
                        "username": "pramoth-kj",
                        "content": "Same as me\\n"
                    },
                    {
                        "username": "workspace9801",
                        "content": ":-<\\n"
                    },
                    {
                        "username": "justine-135",
                        "content": "LMAO sorry i\\'m so u"
                    },
                    {
                        "username": "munenndragaur",
                        "content": "[@ajinkode](/ajinkode) yeah he is correct make use of brain and pen and paper \\nyou will baap of these qustions "
                    },
                    {
                        "username": "ajinkode",
                        "content": "You are not dumb. You just haven\\'t practiced enough problems yet  :)"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i\\'m also "
                    },
                    {
                        "username": "irshadcc135",
                        "content": "Hint explanation\n\nLet n denote total number of elements. \n\n\nIf an element \"a\" occurs more than n/3 times, then number of elements excluding \"a\" is \n\nn - ((n/3)+1)  = (2n-3)/3 \n\nIf an element \"b\" occurs more than n/3 times, then number of element excluding \"a\" and \"b\" is \n\n((2n-3)/3) - ((n/3) +1) = (n-6)/3 \n\nNow we have only left (n-6)/3 elements, and no elements can occur more than (n/3) times, since (n-6)/3 is less than (n/3)\n\nWe only have to look for 2 elements using O(n) algorithm. I hope the hint make sense now. \n"
                    },
                    {
                        "username": "lgylym",
                        "content": "And it\\'ll absurd if the interviewer is looking for that.\\n\\nVery interesting algorithm though."
                    },
                    {
                        "username": "Daciuk",
                        "content": "Did leetcode just not give us test cases that show the strength of O(1) space?  Does that make sense to anyone?"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "nah, not at all"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Freaking mind-blowing problem!"
                    },
                    {
                        "username": "ankush920",
                        "content": "I CRACK THE ACTUAL CONCEPT MOLDING FOR ALL N/NUM|| MUST ONE TIME WATCH || )(N) || 0(1)\\nankush920\\n0\\nin a few seconds\\nC++\\nIntuition\\nhello community , i appricate your presence and belive me try to conveny my thought process with my best .( sorry if my language is not so strong )\\n\\nprocess\\n-> we have to find the element have freq more than ( not equal ) n/i ( 2<i<n)\\n\\npointer and counter\\nfor n/i we have to take i-1 pointer and i-1 ;\\nwhy?\\n-> because in n size array only maximum i-1 element is present who is more than freq of n/i\\nbecause they are more then n/i time (not equal more than )\\n\\nlook => n-(i-1)((n/i)+1) > n/i (put value and can check it )\\npointer store\\nbecause each pointer show one possible majority element so, each pointer store unique value or number or candidate\\n\\nmanually check\\nwe have to verify our pointer value( number store in pointer )\\nis actually a majority element or not by checking it occurence\\n\\n-> do iteration and count their frq == n/i+1 if yes then push to ans vector if no leave it\\n\\nwhy we do manually check ?\\nbecause while traversing through array we put some value in pointer which may or may not be our answer ( look one time code you understand my point :) )\\n\\nsupport my hard by your love -> upvote\\nApproach\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        \\n        int cnt1 = 0 ,  cnt2= 0 ; \\n         int x = INT_MAX , y= INT_MAX;\\n         vector<int>ans;\\n\\n         for( auto it : nums )\\n         {\\n            if( cnt1 ==0 && y!=it ) {  x = it ; cnt1 =1; }\\n\\n            else if(cnt2 ==0 && x!= it ) { y =it ; cnt2=1 ;}\\n            \\n         else if( x==it) { cnt1 ++; }\\n\\n         else if( y==it ){ cnt2++; }\\n\\n         else {cnt1--; cnt2--;}\\n\\n         }\\n         cnt1 =0 ;cnt2 =0;\\n      \\n      int val = (nums.size()/3)+1; \\n\\n\\n      for(auto it :nums)\\n      {\\n          if( x==it) { cnt1 ++ ; }\\n\\n          if( y ==it ) { cnt2++ ; }\\n\\n           if( cnt1 ==val) { ans.push_back(it); cnt1 = 0; x = INT_MAX;}\\n           \\n           if( cnt2 ==val) { ans.push_back(it); cnt2 = 0;  y =INT_MAX ;}\\n      }\\n         \\n         return ans ;\\n    \\n    }\\n};"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The follow up in O(1) space is hard, and the original question is easy, neither of them are medium. \n\nAnything that I can solve in under 5 minutes with a one-liner can't be a medium. Anything that requires you to come up with an algorithm which bears not one but two names of famous dudes probably can't be medium either"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This! I don\\'t why people think ask problems like these which are very easy after knowing the trick/algo and are super hard if you don\\'t."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Very Intersting algorithm"
                    },
                    {
                        "username": "asthakul17",
                        "content": "it should be marked easy"
                    },
                    {
                        "username": "zcore",
                        "content": "The space constraint is O(1), read the follow up, that is what makes it a medium problem."
                    }
                ]
            },
            {
                "id": 1796488,
                "content": [
                    {
                        "username": "alanmiller",
                        "content": "This article is for those who are familiar with how Moore\\'s voting algorithm is implemented, but don\\'t understand why it works, or seeks for a rigorous proof of its correctness.\\n\\nIntuitive idea:\\nLet\\'s start with the basic case: [169. Majority Element](https://leetcode.com/problems/majority-element/)\\nOne can think of the algorithm as a battle process, whenever two different elements encountered, the battle occurs, and they both vanishes. The candidate is whoever that survives this battle process. The point here is that whenever a majority element vanishes (no matter it is the current candidate or not), there is at least (exactly) one other element dies with it. Hence, the majority element survives, since there are at least n/2 of them.\\n\\nNow for this problem, the only difference is that there are two candidates, corresponding to two survivors that we pick. And whenever an element vanishes in a battle, there are at least (exactly) 2 other elements die with it. Hence, whenever an element with occurences > n/3 dies (no matter it is a current candidate or not), there are at least 2 other elements die with it. So it survives.\\n\\nRigorous proof this problem:\\nThe above intuitive idea can easily be turned into a rigorous proof.\\nLet\\'s prove by contradiction, suppose an element with occurences > n/3 is not a candidate after the algorithm finishes. Then, they must be all cancelled out at a certain point (either got counted down as a candidate element, or as a non-candidate to cause two candidates counted down), this corresponds to all of them vanishes in the battle. But whenever a cancellation occurs, three elements are recorded (two candidates counted down, and one non-candidate got passed), this corresponds to whenever an element dies, two others die with it. So in total, there are > 3*(n/3) elements recorded, but there are only n elements. Contradiction.\\n\\nGeneralization:\\nAs one can see, the point is whenever an element dies, 2 others die with it. For general k,  just choose k candidates, and there will be (k-1) elements die with it. The proof is almost verbatim.\\n"
                    },
                    {
                        "username": "malkaraj",
                        "content": "able to solve this problem thanks"
                    },
                    {
                        "username": "ashu_kr",
                        "content": "[@Amarjeet Kumar](/getbusylivingOrgetbusydying) because only two candidate greater than two is only possible\\nlet the 2 candidate be greater than n/3 and the remaining will be x\\n(>n/3)+(>n/3)+x=n     \\ntherefore,x<n/3;// so the 3rd element will occur less than n/3 times\\nthat\\'s why we are taking 2 candidate"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "why taking two candidate here??\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro I can\\'t thank you enough for this explanation. People underestimate how much intuition understanding of a problem is necessary."
                    },
                    {
                        "username": "shivanshx365",
                        "content": "Nice Explanation \\uD83D\\uDC4D"
                    },
                    {
                        "username": "prtyhr",
                        "content": "the battle analogy was great, thanks!"
                    },
                    {
                        "username": "tekmark",
                        "content": "i am so dumb."
                    },
                    {
                        "username": "pramoth-kj",
                        "content": "Same as me\\n"
                    },
                    {
                        "username": "workspace9801",
                        "content": ":-<\\n"
                    },
                    {
                        "username": "justine-135",
                        "content": "LMAO sorry i\\'m so u"
                    },
                    {
                        "username": "munenndragaur",
                        "content": "[@ajinkode](/ajinkode) yeah he is correct make use of brain and pen and paper \\nyou will baap of these qustions "
                    },
                    {
                        "username": "ajinkode",
                        "content": "You are not dumb. You just haven\\'t practiced enough problems yet  :)"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i\\'m also "
                    },
                    {
                        "username": "irshadcc135",
                        "content": "Hint explanation\n\nLet n denote total number of elements. \n\n\nIf an element \"a\" occurs more than n/3 times, then number of elements excluding \"a\" is \n\nn - ((n/3)+1)  = (2n-3)/3 \n\nIf an element \"b\" occurs more than n/3 times, then number of element excluding \"a\" and \"b\" is \n\n((2n-3)/3) - ((n/3) +1) = (n-6)/3 \n\nNow we have only left (n-6)/3 elements, and no elements can occur more than (n/3) times, since (n-6)/3 is less than (n/3)\n\nWe only have to look for 2 elements using O(n) algorithm. I hope the hint make sense now. \n"
                    },
                    {
                        "username": "lgylym",
                        "content": "And it\\'ll absurd if the interviewer is looking for that.\\n\\nVery interesting algorithm though."
                    },
                    {
                        "username": "Daciuk",
                        "content": "Did leetcode just not give us test cases that show the strength of O(1) space?  Does that make sense to anyone?"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "nah, not at all"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Freaking mind-blowing problem!"
                    },
                    {
                        "username": "ankush920",
                        "content": "I CRACK THE ACTUAL CONCEPT MOLDING FOR ALL N/NUM|| MUST ONE TIME WATCH || )(N) || 0(1)\\nankush920\\n0\\nin a few seconds\\nC++\\nIntuition\\nhello community , i appricate your presence and belive me try to conveny my thought process with my best .( sorry if my language is not so strong )\\n\\nprocess\\n-> we have to find the element have freq more than ( not equal ) n/i ( 2<i<n)\\n\\npointer and counter\\nfor n/i we have to take i-1 pointer and i-1 ;\\nwhy?\\n-> because in n size array only maximum i-1 element is present who is more than freq of n/i\\nbecause they are more then n/i time (not equal more than )\\n\\nlook => n-(i-1)((n/i)+1) > n/i (put value and can check it )\\npointer store\\nbecause each pointer show one possible majority element so, each pointer store unique value or number or candidate\\n\\nmanually check\\nwe have to verify our pointer value( number store in pointer )\\nis actually a majority element or not by checking it occurence\\n\\n-> do iteration and count their frq == n/i+1 if yes then push to ans vector if no leave it\\n\\nwhy we do manually check ?\\nbecause while traversing through array we put some value in pointer which may or may not be our answer ( look one time code you understand my point :) )\\n\\nsupport my hard by your love -> upvote\\nApproach\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        \\n        int cnt1 = 0 ,  cnt2= 0 ; \\n         int x = INT_MAX , y= INT_MAX;\\n         vector<int>ans;\\n\\n         for( auto it : nums )\\n         {\\n            if( cnt1 ==0 && y!=it ) {  x = it ; cnt1 =1; }\\n\\n            else if(cnt2 ==0 && x!= it ) { y =it ; cnt2=1 ;}\\n            \\n         else if( x==it) { cnt1 ++; }\\n\\n         else if( y==it ){ cnt2++; }\\n\\n         else {cnt1--; cnt2--;}\\n\\n         }\\n         cnt1 =0 ;cnt2 =0;\\n      \\n      int val = (nums.size()/3)+1; \\n\\n\\n      for(auto it :nums)\\n      {\\n          if( x==it) { cnt1 ++ ; }\\n\\n          if( y ==it ) { cnt2++ ; }\\n\\n           if( cnt1 ==val) { ans.push_back(it); cnt1 = 0; x = INT_MAX;}\\n           \\n           if( cnt2 ==val) { ans.push_back(it); cnt2 = 0;  y =INT_MAX ;}\\n      }\\n         \\n         return ans ;\\n    \\n    }\\n};"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The follow up in O(1) space is hard, and the original question is easy, neither of them are medium. \n\nAnything that I can solve in under 5 minutes with a one-liner can't be a medium. Anything that requires you to come up with an algorithm which bears not one but two names of famous dudes probably can't be medium either"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This! I don\\'t why people think ask problems like these which are very easy after knowing the trick/algo and are super hard if you don\\'t."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Very Intersting algorithm"
                    },
                    {
                        "username": "asthakul17",
                        "content": "it should be marked easy"
                    },
                    {
                        "username": "zcore",
                        "content": "The space constraint is O(1), read the follow up, that is what makes it a medium problem."
                    }
                ]
            },
            {
                "id": 1566876,
                "content": [
                    {
                        "username": "alanmiller",
                        "content": "This article is for those who are familiar with how Moore\\'s voting algorithm is implemented, but don\\'t understand why it works, or seeks for a rigorous proof of its correctness.\\n\\nIntuitive idea:\\nLet\\'s start with the basic case: [169. Majority Element](https://leetcode.com/problems/majority-element/)\\nOne can think of the algorithm as a battle process, whenever two different elements encountered, the battle occurs, and they both vanishes. The candidate is whoever that survives this battle process. The point here is that whenever a majority element vanishes (no matter it is the current candidate or not), there is at least (exactly) one other element dies with it. Hence, the majority element survives, since there are at least n/2 of them.\\n\\nNow for this problem, the only difference is that there are two candidates, corresponding to two survivors that we pick. And whenever an element vanishes in a battle, there are at least (exactly) 2 other elements die with it. Hence, whenever an element with occurences > n/3 dies (no matter it is a current candidate or not), there are at least 2 other elements die with it. So it survives.\\n\\nRigorous proof this problem:\\nThe above intuitive idea can easily be turned into a rigorous proof.\\nLet\\'s prove by contradiction, suppose an element with occurences > n/3 is not a candidate after the algorithm finishes. Then, they must be all cancelled out at a certain point (either got counted down as a candidate element, or as a non-candidate to cause two candidates counted down), this corresponds to all of them vanishes in the battle. But whenever a cancellation occurs, three elements are recorded (two candidates counted down, and one non-candidate got passed), this corresponds to whenever an element dies, two others die with it. So in total, there are > 3*(n/3) elements recorded, but there are only n elements. Contradiction.\\n\\nGeneralization:\\nAs one can see, the point is whenever an element dies, 2 others die with it. For general k,  just choose k candidates, and there will be (k-1) elements die with it. The proof is almost verbatim.\\n"
                    },
                    {
                        "username": "malkaraj",
                        "content": "able to solve this problem thanks"
                    },
                    {
                        "username": "ashu_kr",
                        "content": "[@Amarjeet Kumar](/getbusylivingOrgetbusydying) because only two candidate greater than two is only possible\\nlet the 2 candidate be greater than n/3 and the remaining will be x\\n(>n/3)+(>n/3)+x=n     \\ntherefore,x<n/3;// so the 3rd element will occur less than n/3 times\\nthat\\'s why we are taking 2 candidate"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "why taking two candidate here??\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro I can\\'t thank you enough for this explanation. People underestimate how much intuition understanding of a problem is necessary."
                    },
                    {
                        "username": "shivanshx365",
                        "content": "Nice Explanation \\uD83D\\uDC4D"
                    },
                    {
                        "username": "prtyhr",
                        "content": "the battle analogy was great, thanks!"
                    },
                    {
                        "username": "tekmark",
                        "content": "i am so dumb."
                    },
                    {
                        "username": "pramoth-kj",
                        "content": "Same as me\\n"
                    },
                    {
                        "username": "workspace9801",
                        "content": ":-<\\n"
                    },
                    {
                        "username": "justine-135",
                        "content": "LMAO sorry i\\'m so u"
                    },
                    {
                        "username": "munenndragaur",
                        "content": "[@ajinkode](/ajinkode) yeah he is correct make use of brain and pen and paper \\nyou will baap of these qustions "
                    },
                    {
                        "username": "ajinkode",
                        "content": "You are not dumb. You just haven\\'t practiced enough problems yet  :)"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i\\'m also "
                    },
                    {
                        "username": "irshadcc135",
                        "content": "Hint explanation\n\nLet n denote total number of elements. \n\n\nIf an element \"a\" occurs more than n/3 times, then number of elements excluding \"a\" is \n\nn - ((n/3)+1)  = (2n-3)/3 \n\nIf an element \"b\" occurs more than n/3 times, then number of element excluding \"a\" and \"b\" is \n\n((2n-3)/3) - ((n/3) +1) = (n-6)/3 \n\nNow we have only left (n-6)/3 elements, and no elements can occur more than (n/3) times, since (n-6)/3 is less than (n/3)\n\nWe only have to look for 2 elements using O(n) algorithm. I hope the hint make sense now. \n"
                    },
                    {
                        "username": "lgylym",
                        "content": "And it\\'ll absurd if the interviewer is looking for that.\\n\\nVery interesting algorithm though."
                    },
                    {
                        "username": "Daciuk",
                        "content": "Did leetcode just not give us test cases that show the strength of O(1) space?  Does that make sense to anyone?"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "nah, not at all"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Freaking mind-blowing problem!"
                    },
                    {
                        "username": "ankush920",
                        "content": "I CRACK THE ACTUAL CONCEPT MOLDING FOR ALL N/NUM|| MUST ONE TIME WATCH || )(N) || 0(1)\\nankush920\\n0\\nin a few seconds\\nC++\\nIntuition\\nhello community , i appricate your presence and belive me try to conveny my thought process with my best .( sorry if my language is not so strong )\\n\\nprocess\\n-> we have to find the element have freq more than ( not equal ) n/i ( 2<i<n)\\n\\npointer and counter\\nfor n/i we have to take i-1 pointer and i-1 ;\\nwhy?\\n-> because in n size array only maximum i-1 element is present who is more than freq of n/i\\nbecause they are more then n/i time (not equal more than )\\n\\nlook => n-(i-1)((n/i)+1) > n/i (put value and can check it )\\npointer store\\nbecause each pointer show one possible majority element so, each pointer store unique value or number or candidate\\n\\nmanually check\\nwe have to verify our pointer value( number store in pointer )\\nis actually a majority element or not by checking it occurence\\n\\n-> do iteration and count their frq == n/i+1 if yes then push to ans vector if no leave it\\n\\nwhy we do manually check ?\\nbecause while traversing through array we put some value in pointer which may or may not be our answer ( look one time code you understand my point :) )\\n\\nsupport my hard by your love -> upvote\\nApproach\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        \\n        int cnt1 = 0 ,  cnt2= 0 ; \\n         int x = INT_MAX , y= INT_MAX;\\n         vector<int>ans;\\n\\n         for( auto it : nums )\\n         {\\n            if( cnt1 ==0 && y!=it ) {  x = it ; cnt1 =1; }\\n\\n            else if(cnt2 ==0 && x!= it ) { y =it ; cnt2=1 ;}\\n            \\n         else if( x==it) { cnt1 ++; }\\n\\n         else if( y==it ){ cnt2++; }\\n\\n         else {cnt1--; cnt2--;}\\n\\n         }\\n         cnt1 =0 ;cnt2 =0;\\n      \\n      int val = (nums.size()/3)+1; \\n\\n\\n      for(auto it :nums)\\n      {\\n          if( x==it) { cnt1 ++ ; }\\n\\n          if( y ==it ) { cnt2++ ; }\\n\\n           if( cnt1 ==val) { ans.push_back(it); cnt1 = 0; x = INT_MAX;}\\n           \\n           if( cnt2 ==val) { ans.push_back(it); cnt2 = 0;  y =INT_MAX ;}\\n      }\\n         \\n         return ans ;\\n    \\n    }\\n};"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The follow up in O(1) space is hard, and the original question is easy, neither of them are medium. \n\nAnything that I can solve in under 5 minutes with a one-liner can't be a medium. Anything that requires you to come up with an algorithm which bears not one but two names of famous dudes probably can't be medium either"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This! I don\\'t why people think ask problems like these which are very easy after knowing the trick/algo and are super hard if you don\\'t."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Very Intersting algorithm"
                    },
                    {
                        "username": "asthakul17",
                        "content": "it should be marked easy"
                    },
                    {
                        "username": "zcore",
                        "content": "The space constraint is O(1), read the follow up, that is what makes it a medium problem."
                    }
                ]
            },
            {
                "id": 1567923,
                "content": [
                    {
                        "username": "alanmiller",
                        "content": "This article is for those who are familiar with how Moore\\'s voting algorithm is implemented, but don\\'t understand why it works, or seeks for a rigorous proof of its correctness.\\n\\nIntuitive idea:\\nLet\\'s start with the basic case: [169. Majority Element](https://leetcode.com/problems/majority-element/)\\nOne can think of the algorithm as a battle process, whenever two different elements encountered, the battle occurs, and they both vanishes. The candidate is whoever that survives this battle process. The point here is that whenever a majority element vanishes (no matter it is the current candidate or not), there is at least (exactly) one other element dies with it. Hence, the majority element survives, since there are at least n/2 of them.\\n\\nNow for this problem, the only difference is that there are two candidates, corresponding to two survivors that we pick. And whenever an element vanishes in a battle, there are at least (exactly) 2 other elements die with it. Hence, whenever an element with occurences > n/3 dies (no matter it is a current candidate or not), there are at least 2 other elements die with it. So it survives.\\n\\nRigorous proof this problem:\\nThe above intuitive idea can easily be turned into a rigorous proof.\\nLet\\'s prove by contradiction, suppose an element with occurences > n/3 is not a candidate after the algorithm finishes. Then, they must be all cancelled out at a certain point (either got counted down as a candidate element, or as a non-candidate to cause two candidates counted down), this corresponds to all of them vanishes in the battle. But whenever a cancellation occurs, three elements are recorded (two candidates counted down, and one non-candidate got passed), this corresponds to whenever an element dies, two others die with it. So in total, there are > 3*(n/3) elements recorded, but there are only n elements. Contradiction.\\n\\nGeneralization:\\nAs one can see, the point is whenever an element dies, 2 others die with it. For general k,  just choose k candidates, and there will be (k-1) elements die with it. The proof is almost verbatim.\\n"
                    },
                    {
                        "username": "malkaraj",
                        "content": "able to solve this problem thanks"
                    },
                    {
                        "username": "ashu_kr",
                        "content": "[@Amarjeet Kumar](/getbusylivingOrgetbusydying) because only two candidate greater than two is only possible\\nlet the 2 candidate be greater than n/3 and the remaining will be x\\n(>n/3)+(>n/3)+x=n     \\ntherefore,x<n/3;// so the 3rd element will occur less than n/3 times\\nthat\\'s why we are taking 2 candidate"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "why taking two candidate here??\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro I can\\'t thank you enough for this explanation. People underestimate how much intuition understanding of a problem is necessary."
                    },
                    {
                        "username": "shivanshx365",
                        "content": "Nice Explanation \\uD83D\\uDC4D"
                    },
                    {
                        "username": "prtyhr",
                        "content": "the battle analogy was great, thanks!"
                    },
                    {
                        "username": "tekmark",
                        "content": "i am so dumb."
                    },
                    {
                        "username": "pramoth-kj",
                        "content": "Same as me\\n"
                    },
                    {
                        "username": "workspace9801",
                        "content": ":-<\\n"
                    },
                    {
                        "username": "justine-135",
                        "content": "LMAO sorry i\\'m so u"
                    },
                    {
                        "username": "munenndragaur",
                        "content": "[@ajinkode](/ajinkode) yeah he is correct make use of brain and pen and paper \\nyou will baap of these qustions "
                    },
                    {
                        "username": "ajinkode",
                        "content": "You are not dumb. You just haven\\'t practiced enough problems yet  :)"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i\\'m also "
                    },
                    {
                        "username": "irshadcc135",
                        "content": "Hint explanation\n\nLet n denote total number of elements. \n\n\nIf an element \"a\" occurs more than n/3 times, then number of elements excluding \"a\" is \n\nn - ((n/3)+1)  = (2n-3)/3 \n\nIf an element \"b\" occurs more than n/3 times, then number of element excluding \"a\" and \"b\" is \n\n((2n-3)/3) - ((n/3) +1) = (n-6)/3 \n\nNow we have only left (n-6)/3 elements, and no elements can occur more than (n/3) times, since (n-6)/3 is less than (n/3)\n\nWe only have to look for 2 elements using O(n) algorithm. I hope the hint make sense now. \n"
                    },
                    {
                        "username": "lgylym",
                        "content": "And it\\'ll absurd if the interviewer is looking for that.\\n\\nVery interesting algorithm though."
                    },
                    {
                        "username": "Daciuk",
                        "content": "Did leetcode just not give us test cases that show the strength of O(1) space?  Does that make sense to anyone?"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "nah, not at all"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Freaking mind-blowing problem!"
                    },
                    {
                        "username": "ankush920",
                        "content": "I CRACK THE ACTUAL CONCEPT MOLDING FOR ALL N/NUM|| MUST ONE TIME WATCH || )(N) || 0(1)\\nankush920\\n0\\nin a few seconds\\nC++\\nIntuition\\nhello community , i appricate your presence and belive me try to conveny my thought process with my best .( sorry if my language is not so strong )\\n\\nprocess\\n-> we have to find the element have freq more than ( not equal ) n/i ( 2<i<n)\\n\\npointer and counter\\nfor n/i we have to take i-1 pointer and i-1 ;\\nwhy?\\n-> because in n size array only maximum i-1 element is present who is more than freq of n/i\\nbecause they are more then n/i time (not equal more than )\\n\\nlook => n-(i-1)((n/i)+1) > n/i (put value and can check it )\\npointer store\\nbecause each pointer show one possible majority element so, each pointer store unique value or number or candidate\\n\\nmanually check\\nwe have to verify our pointer value( number store in pointer )\\nis actually a majority element or not by checking it occurence\\n\\n-> do iteration and count their frq == n/i+1 if yes then push to ans vector if no leave it\\n\\nwhy we do manually check ?\\nbecause while traversing through array we put some value in pointer which may or may not be our answer ( look one time code you understand my point :) )\\n\\nsupport my hard by your love -> upvote\\nApproach\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        \\n        int cnt1 = 0 ,  cnt2= 0 ; \\n         int x = INT_MAX , y= INT_MAX;\\n         vector<int>ans;\\n\\n         for( auto it : nums )\\n         {\\n            if( cnt1 ==0 && y!=it ) {  x = it ; cnt1 =1; }\\n\\n            else if(cnt2 ==0 && x!= it ) { y =it ; cnt2=1 ;}\\n            \\n         else if( x==it) { cnt1 ++; }\\n\\n         else if( y==it ){ cnt2++; }\\n\\n         else {cnt1--; cnt2--;}\\n\\n         }\\n         cnt1 =0 ;cnt2 =0;\\n      \\n      int val = (nums.size()/3)+1; \\n\\n\\n      for(auto it :nums)\\n      {\\n          if( x==it) { cnt1 ++ ; }\\n\\n          if( y ==it ) { cnt2++ ; }\\n\\n           if( cnt1 ==val) { ans.push_back(it); cnt1 = 0; x = INT_MAX;}\\n           \\n           if( cnt2 ==val) { ans.push_back(it); cnt2 = 0;  y =INT_MAX ;}\\n      }\\n         \\n         return ans ;\\n    \\n    }\\n};"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The follow up in O(1) space is hard, and the original question is easy, neither of them are medium. \n\nAnything that I can solve in under 5 minutes with a one-liner can't be a medium. Anything that requires you to come up with an algorithm which bears not one but two names of famous dudes probably can't be medium either"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This! I don\\'t why people think ask problems like these which are very easy after knowing the trick/algo and are super hard if you don\\'t."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Very Intersting algorithm"
                    },
                    {
                        "username": "asthakul17",
                        "content": "it should be marked easy"
                    },
                    {
                        "username": "zcore",
                        "content": "The space constraint is O(1), read the follow up, that is what makes it a medium problem."
                    }
                ]
            },
            {
                "id": 1782535,
                "content": [
                    {
                        "username": "alanmiller",
                        "content": "This article is for those who are familiar with how Moore\\'s voting algorithm is implemented, but don\\'t understand why it works, or seeks for a rigorous proof of its correctness.\\n\\nIntuitive idea:\\nLet\\'s start with the basic case: [169. Majority Element](https://leetcode.com/problems/majority-element/)\\nOne can think of the algorithm as a battle process, whenever two different elements encountered, the battle occurs, and they both vanishes. The candidate is whoever that survives this battle process. The point here is that whenever a majority element vanishes (no matter it is the current candidate or not), there is at least (exactly) one other element dies with it. Hence, the majority element survives, since there are at least n/2 of them.\\n\\nNow for this problem, the only difference is that there are two candidates, corresponding to two survivors that we pick. And whenever an element vanishes in a battle, there are at least (exactly) 2 other elements die with it. Hence, whenever an element with occurences > n/3 dies (no matter it is a current candidate or not), there are at least 2 other elements die with it. So it survives.\\n\\nRigorous proof this problem:\\nThe above intuitive idea can easily be turned into a rigorous proof.\\nLet\\'s prove by contradiction, suppose an element with occurences > n/3 is not a candidate after the algorithm finishes. Then, they must be all cancelled out at a certain point (either got counted down as a candidate element, or as a non-candidate to cause two candidates counted down), this corresponds to all of them vanishes in the battle. But whenever a cancellation occurs, three elements are recorded (two candidates counted down, and one non-candidate got passed), this corresponds to whenever an element dies, two others die with it. So in total, there are > 3*(n/3) elements recorded, but there are only n elements. Contradiction.\\n\\nGeneralization:\\nAs one can see, the point is whenever an element dies, 2 others die with it. For general k,  just choose k candidates, and there will be (k-1) elements die with it. The proof is almost verbatim.\\n"
                    },
                    {
                        "username": "malkaraj",
                        "content": "able to solve this problem thanks"
                    },
                    {
                        "username": "ashu_kr",
                        "content": "[@Amarjeet Kumar](/getbusylivingOrgetbusydying) because only two candidate greater than two is only possible\\nlet the 2 candidate be greater than n/3 and the remaining will be x\\n(>n/3)+(>n/3)+x=n     \\ntherefore,x<n/3;// so the 3rd element will occur less than n/3 times\\nthat\\'s why we are taking 2 candidate"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "why taking two candidate here??\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro I can\\'t thank you enough for this explanation. People underestimate how much intuition understanding of a problem is necessary."
                    },
                    {
                        "username": "shivanshx365",
                        "content": "Nice Explanation \\uD83D\\uDC4D"
                    },
                    {
                        "username": "prtyhr",
                        "content": "the battle analogy was great, thanks!"
                    },
                    {
                        "username": "tekmark",
                        "content": "i am so dumb."
                    },
                    {
                        "username": "pramoth-kj",
                        "content": "Same as me\\n"
                    },
                    {
                        "username": "workspace9801",
                        "content": ":-<\\n"
                    },
                    {
                        "username": "justine-135",
                        "content": "LMAO sorry i\\'m so u"
                    },
                    {
                        "username": "munenndragaur",
                        "content": "[@ajinkode](/ajinkode) yeah he is correct make use of brain and pen and paper \\nyou will baap of these qustions "
                    },
                    {
                        "username": "ajinkode",
                        "content": "You are not dumb. You just haven\\'t practiced enough problems yet  :)"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i\\'m also "
                    },
                    {
                        "username": "irshadcc135",
                        "content": "Hint explanation\n\nLet n denote total number of elements. \n\n\nIf an element \"a\" occurs more than n/3 times, then number of elements excluding \"a\" is \n\nn - ((n/3)+1)  = (2n-3)/3 \n\nIf an element \"b\" occurs more than n/3 times, then number of element excluding \"a\" and \"b\" is \n\n((2n-3)/3) - ((n/3) +1) = (n-6)/3 \n\nNow we have only left (n-6)/3 elements, and no elements can occur more than (n/3) times, since (n-6)/3 is less than (n/3)\n\nWe only have to look for 2 elements using O(n) algorithm. I hope the hint make sense now. \n"
                    },
                    {
                        "username": "lgylym",
                        "content": "And it\\'ll absurd if the interviewer is looking for that.\\n\\nVery interesting algorithm though."
                    },
                    {
                        "username": "Daciuk",
                        "content": "Did leetcode just not give us test cases that show the strength of O(1) space?  Does that make sense to anyone?"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "nah, not at all"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Freaking mind-blowing problem!"
                    },
                    {
                        "username": "ankush920",
                        "content": "I CRACK THE ACTUAL CONCEPT MOLDING FOR ALL N/NUM|| MUST ONE TIME WATCH || )(N) || 0(1)\\nankush920\\n0\\nin a few seconds\\nC++\\nIntuition\\nhello community , i appricate your presence and belive me try to conveny my thought process with my best .( sorry if my language is not so strong )\\n\\nprocess\\n-> we have to find the element have freq more than ( not equal ) n/i ( 2<i<n)\\n\\npointer and counter\\nfor n/i we have to take i-1 pointer and i-1 ;\\nwhy?\\n-> because in n size array only maximum i-1 element is present who is more than freq of n/i\\nbecause they are more then n/i time (not equal more than )\\n\\nlook => n-(i-1)((n/i)+1) > n/i (put value and can check it )\\npointer store\\nbecause each pointer show one possible majority element so, each pointer store unique value or number or candidate\\n\\nmanually check\\nwe have to verify our pointer value( number store in pointer )\\nis actually a majority element or not by checking it occurence\\n\\n-> do iteration and count their frq == n/i+1 if yes then push to ans vector if no leave it\\n\\nwhy we do manually check ?\\nbecause while traversing through array we put some value in pointer which may or may not be our answer ( look one time code you understand my point :) )\\n\\nsupport my hard by your love -> upvote\\nApproach\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        \\n        int cnt1 = 0 ,  cnt2= 0 ; \\n         int x = INT_MAX , y= INT_MAX;\\n         vector<int>ans;\\n\\n         for( auto it : nums )\\n         {\\n            if( cnt1 ==0 && y!=it ) {  x = it ; cnt1 =1; }\\n\\n            else if(cnt2 ==0 && x!= it ) { y =it ; cnt2=1 ;}\\n            \\n         else if( x==it) { cnt1 ++; }\\n\\n         else if( y==it ){ cnt2++; }\\n\\n         else {cnt1--; cnt2--;}\\n\\n         }\\n         cnt1 =0 ;cnt2 =0;\\n      \\n      int val = (nums.size()/3)+1; \\n\\n\\n      for(auto it :nums)\\n      {\\n          if( x==it) { cnt1 ++ ; }\\n\\n          if( y ==it ) { cnt2++ ; }\\n\\n           if( cnt1 ==val) { ans.push_back(it); cnt1 = 0; x = INT_MAX;}\\n           \\n           if( cnt2 ==val) { ans.push_back(it); cnt2 = 0;  y =INT_MAX ;}\\n      }\\n         \\n         return ans ;\\n    \\n    }\\n};"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The follow up in O(1) space is hard, and the original question is easy, neither of them are medium. \n\nAnything that I can solve in under 5 minutes with a one-liner can't be a medium. Anything that requires you to come up with an algorithm which bears not one but two names of famous dudes probably can't be medium either"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This! I don\\'t why people think ask problems like these which are very easy after knowing the trick/algo and are super hard if you don\\'t."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Very Intersting algorithm"
                    },
                    {
                        "username": "asthakul17",
                        "content": "it should be marked easy"
                    },
                    {
                        "username": "zcore",
                        "content": "The space constraint is O(1), read the follow up, that is what makes it a medium problem."
                    }
                ]
            },
            {
                "id": 1567298,
                "content": [
                    {
                        "username": "alanmiller",
                        "content": "This article is for those who are familiar with how Moore\\'s voting algorithm is implemented, but don\\'t understand why it works, or seeks for a rigorous proof of its correctness.\\n\\nIntuitive idea:\\nLet\\'s start with the basic case: [169. Majority Element](https://leetcode.com/problems/majority-element/)\\nOne can think of the algorithm as a battle process, whenever two different elements encountered, the battle occurs, and they both vanishes. The candidate is whoever that survives this battle process. The point here is that whenever a majority element vanishes (no matter it is the current candidate or not), there is at least (exactly) one other element dies with it. Hence, the majority element survives, since there are at least n/2 of them.\\n\\nNow for this problem, the only difference is that there are two candidates, corresponding to two survivors that we pick. And whenever an element vanishes in a battle, there are at least (exactly) 2 other elements die with it. Hence, whenever an element with occurences > n/3 dies (no matter it is a current candidate or not), there are at least 2 other elements die with it. So it survives.\\n\\nRigorous proof this problem:\\nThe above intuitive idea can easily be turned into a rigorous proof.\\nLet\\'s prove by contradiction, suppose an element with occurences > n/3 is not a candidate after the algorithm finishes. Then, they must be all cancelled out at a certain point (either got counted down as a candidate element, or as a non-candidate to cause two candidates counted down), this corresponds to all of them vanishes in the battle. But whenever a cancellation occurs, three elements are recorded (two candidates counted down, and one non-candidate got passed), this corresponds to whenever an element dies, two others die with it. So in total, there are > 3*(n/3) elements recorded, but there are only n elements. Contradiction.\\n\\nGeneralization:\\nAs one can see, the point is whenever an element dies, 2 others die with it. For general k,  just choose k candidates, and there will be (k-1) elements die with it. The proof is almost verbatim.\\n"
                    },
                    {
                        "username": "malkaraj",
                        "content": "able to solve this problem thanks"
                    },
                    {
                        "username": "ashu_kr",
                        "content": "[@Amarjeet Kumar](/getbusylivingOrgetbusydying) because only two candidate greater than two is only possible\\nlet the 2 candidate be greater than n/3 and the remaining will be x\\n(>n/3)+(>n/3)+x=n     \\ntherefore,x<n/3;// so the 3rd element will occur less than n/3 times\\nthat\\'s why we are taking 2 candidate"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "why taking two candidate here??\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro I can\\'t thank you enough for this explanation. People underestimate how much intuition understanding of a problem is necessary."
                    },
                    {
                        "username": "shivanshx365",
                        "content": "Nice Explanation \\uD83D\\uDC4D"
                    },
                    {
                        "username": "prtyhr",
                        "content": "the battle analogy was great, thanks!"
                    },
                    {
                        "username": "tekmark",
                        "content": "i am so dumb."
                    },
                    {
                        "username": "pramoth-kj",
                        "content": "Same as me\\n"
                    },
                    {
                        "username": "workspace9801",
                        "content": ":-<\\n"
                    },
                    {
                        "username": "justine-135",
                        "content": "LMAO sorry i\\'m so u"
                    },
                    {
                        "username": "munenndragaur",
                        "content": "[@ajinkode](/ajinkode) yeah he is correct make use of brain and pen and paper \\nyou will baap of these qustions "
                    },
                    {
                        "username": "ajinkode",
                        "content": "You are not dumb. You just haven\\'t practiced enough problems yet  :)"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i\\'m also "
                    },
                    {
                        "username": "irshadcc135",
                        "content": "Hint explanation\n\nLet n denote total number of elements. \n\n\nIf an element \"a\" occurs more than n/3 times, then number of elements excluding \"a\" is \n\nn - ((n/3)+1)  = (2n-3)/3 \n\nIf an element \"b\" occurs more than n/3 times, then number of element excluding \"a\" and \"b\" is \n\n((2n-3)/3) - ((n/3) +1) = (n-6)/3 \n\nNow we have only left (n-6)/3 elements, and no elements can occur more than (n/3) times, since (n-6)/3 is less than (n/3)\n\nWe only have to look for 2 elements using O(n) algorithm. I hope the hint make sense now. \n"
                    },
                    {
                        "username": "lgylym",
                        "content": "And it\\'ll absurd if the interviewer is looking for that.\\n\\nVery interesting algorithm though."
                    },
                    {
                        "username": "Daciuk",
                        "content": "Did leetcode just not give us test cases that show the strength of O(1) space?  Does that make sense to anyone?"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "nah, not at all"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Freaking mind-blowing problem!"
                    },
                    {
                        "username": "ankush920",
                        "content": "I CRACK THE ACTUAL CONCEPT MOLDING FOR ALL N/NUM|| MUST ONE TIME WATCH || )(N) || 0(1)\\nankush920\\n0\\nin a few seconds\\nC++\\nIntuition\\nhello community , i appricate your presence and belive me try to conveny my thought process with my best .( sorry if my language is not so strong )\\n\\nprocess\\n-> we have to find the element have freq more than ( not equal ) n/i ( 2<i<n)\\n\\npointer and counter\\nfor n/i we have to take i-1 pointer and i-1 ;\\nwhy?\\n-> because in n size array only maximum i-1 element is present who is more than freq of n/i\\nbecause they are more then n/i time (not equal more than )\\n\\nlook => n-(i-1)((n/i)+1) > n/i (put value and can check it )\\npointer store\\nbecause each pointer show one possible majority element so, each pointer store unique value or number or candidate\\n\\nmanually check\\nwe have to verify our pointer value( number store in pointer )\\nis actually a majority element or not by checking it occurence\\n\\n-> do iteration and count their frq == n/i+1 if yes then push to ans vector if no leave it\\n\\nwhy we do manually check ?\\nbecause while traversing through array we put some value in pointer which may or may not be our answer ( look one time code you understand my point :) )\\n\\nsupport my hard by your love -> upvote\\nApproach\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        \\n        int cnt1 = 0 ,  cnt2= 0 ; \\n         int x = INT_MAX , y= INT_MAX;\\n         vector<int>ans;\\n\\n         for( auto it : nums )\\n         {\\n            if( cnt1 ==0 && y!=it ) {  x = it ; cnt1 =1; }\\n\\n            else if(cnt2 ==0 && x!= it ) { y =it ; cnt2=1 ;}\\n            \\n         else if( x==it) { cnt1 ++; }\\n\\n         else if( y==it ){ cnt2++; }\\n\\n         else {cnt1--; cnt2--;}\\n\\n         }\\n         cnt1 =0 ;cnt2 =0;\\n      \\n      int val = (nums.size()/3)+1; \\n\\n\\n      for(auto it :nums)\\n      {\\n          if( x==it) { cnt1 ++ ; }\\n\\n          if( y ==it ) { cnt2++ ; }\\n\\n           if( cnt1 ==val) { ans.push_back(it); cnt1 = 0; x = INT_MAX;}\\n           \\n           if( cnt2 ==val) { ans.push_back(it); cnt2 = 0;  y =INT_MAX ;}\\n      }\\n         \\n         return ans ;\\n    \\n    }\\n};"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The follow up in O(1) space is hard, and the original question is easy, neither of them are medium. \n\nAnything that I can solve in under 5 minutes with a one-liner can't be a medium. Anything that requires you to come up with an algorithm which bears not one but two names of famous dudes probably can't be medium either"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This! I don\\'t why people think ask problems like these which are very easy after knowing the trick/algo and are super hard if you don\\'t."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Very Intersting algorithm"
                    },
                    {
                        "username": "asthakul17",
                        "content": "it should be marked easy"
                    },
                    {
                        "username": "zcore",
                        "content": "The space constraint is O(1), read the follow up, that is what makes it a medium problem."
                    }
                ]
            },
            {
                "id": 1569972,
                "content": [
                    {
                        "username": "alanmiller",
                        "content": "This article is for those who are familiar with how Moore\\'s voting algorithm is implemented, but don\\'t understand why it works, or seeks for a rigorous proof of its correctness.\\n\\nIntuitive idea:\\nLet\\'s start with the basic case: [169. Majority Element](https://leetcode.com/problems/majority-element/)\\nOne can think of the algorithm as a battle process, whenever two different elements encountered, the battle occurs, and they both vanishes. The candidate is whoever that survives this battle process. The point here is that whenever a majority element vanishes (no matter it is the current candidate or not), there is at least (exactly) one other element dies with it. Hence, the majority element survives, since there are at least n/2 of them.\\n\\nNow for this problem, the only difference is that there are two candidates, corresponding to two survivors that we pick. And whenever an element vanishes in a battle, there are at least (exactly) 2 other elements die with it. Hence, whenever an element with occurences > n/3 dies (no matter it is a current candidate or not), there are at least 2 other elements die with it. So it survives.\\n\\nRigorous proof this problem:\\nThe above intuitive idea can easily be turned into a rigorous proof.\\nLet\\'s prove by contradiction, suppose an element with occurences > n/3 is not a candidate after the algorithm finishes. Then, they must be all cancelled out at a certain point (either got counted down as a candidate element, or as a non-candidate to cause two candidates counted down), this corresponds to all of them vanishes in the battle. But whenever a cancellation occurs, three elements are recorded (two candidates counted down, and one non-candidate got passed), this corresponds to whenever an element dies, two others die with it. So in total, there are > 3*(n/3) elements recorded, but there are only n elements. Contradiction.\\n\\nGeneralization:\\nAs one can see, the point is whenever an element dies, 2 others die with it. For general k,  just choose k candidates, and there will be (k-1) elements die with it. The proof is almost verbatim.\\n"
                    },
                    {
                        "username": "malkaraj",
                        "content": "able to solve this problem thanks"
                    },
                    {
                        "username": "ashu_kr",
                        "content": "[@Amarjeet Kumar](/getbusylivingOrgetbusydying) because only two candidate greater than two is only possible\\nlet the 2 candidate be greater than n/3 and the remaining will be x\\n(>n/3)+(>n/3)+x=n     \\ntherefore,x<n/3;// so the 3rd element will occur less than n/3 times\\nthat\\'s why we are taking 2 candidate"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "why taking two candidate here??\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro I can\\'t thank you enough for this explanation. People underestimate how much intuition understanding of a problem is necessary."
                    },
                    {
                        "username": "shivanshx365",
                        "content": "Nice Explanation \\uD83D\\uDC4D"
                    },
                    {
                        "username": "prtyhr",
                        "content": "the battle analogy was great, thanks!"
                    },
                    {
                        "username": "tekmark",
                        "content": "i am so dumb."
                    },
                    {
                        "username": "pramoth-kj",
                        "content": "Same as me\\n"
                    },
                    {
                        "username": "workspace9801",
                        "content": ":-<\\n"
                    },
                    {
                        "username": "justine-135",
                        "content": "LMAO sorry i\\'m so u"
                    },
                    {
                        "username": "munenndragaur",
                        "content": "[@ajinkode](/ajinkode) yeah he is correct make use of brain and pen and paper \\nyou will baap of these qustions "
                    },
                    {
                        "username": "ajinkode",
                        "content": "You are not dumb. You just haven\\'t practiced enough problems yet  :)"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i\\'m also "
                    },
                    {
                        "username": "irshadcc135",
                        "content": "Hint explanation\n\nLet n denote total number of elements. \n\n\nIf an element \"a\" occurs more than n/3 times, then number of elements excluding \"a\" is \n\nn - ((n/3)+1)  = (2n-3)/3 \n\nIf an element \"b\" occurs more than n/3 times, then number of element excluding \"a\" and \"b\" is \n\n((2n-3)/3) - ((n/3) +1) = (n-6)/3 \n\nNow we have only left (n-6)/3 elements, and no elements can occur more than (n/3) times, since (n-6)/3 is less than (n/3)\n\nWe only have to look for 2 elements using O(n) algorithm. I hope the hint make sense now. \n"
                    },
                    {
                        "username": "lgylym",
                        "content": "And it\\'ll absurd if the interviewer is looking for that.\\n\\nVery interesting algorithm though."
                    },
                    {
                        "username": "Daciuk",
                        "content": "Did leetcode just not give us test cases that show the strength of O(1) space?  Does that make sense to anyone?"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "nah, not at all"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Freaking mind-blowing problem!"
                    },
                    {
                        "username": "ankush920",
                        "content": "I CRACK THE ACTUAL CONCEPT MOLDING FOR ALL N/NUM|| MUST ONE TIME WATCH || )(N) || 0(1)\\nankush920\\n0\\nin a few seconds\\nC++\\nIntuition\\nhello community , i appricate your presence and belive me try to conveny my thought process with my best .( sorry if my language is not so strong )\\n\\nprocess\\n-> we have to find the element have freq more than ( not equal ) n/i ( 2<i<n)\\n\\npointer and counter\\nfor n/i we have to take i-1 pointer and i-1 ;\\nwhy?\\n-> because in n size array only maximum i-1 element is present who is more than freq of n/i\\nbecause they are more then n/i time (not equal more than )\\n\\nlook => n-(i-1)((n/i)+1) > n/i (put value and can check it )\\npointer store\\nbecause each pointer show one possible majority element so, each pointer store unique value or number or candidate\\n\\nmanually check\\nwe have to verify our pointer value( number store in pointer )\\nis actually a majority element or not by checking it occurence\\n\\n-> do iteration and count their frq == n/i+1 if yes then push to ans vector if no leave it\\n\\nwhy we do manually check ?\\nbecause while traversing through array we put some value in pointer which may or may not be our answer ( look one time code you understand my point :) )\\n\\nsupport my hard by your love -> upvote\\nApproach\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        \\n        int cnt1 = 0 ,  cnt2= 0 ; \\n         int x = INT_MAX , y= INT_MAX;\\n         vector<int>ans;\\n\\n         for( auto it : nums )\\n         {\\n            if( cnt1 ==0 && y!=it ) {  x = it ; cnt1 =1; }\\n\\n            else if(cnt2 ==0 && x!= it ) { y =it ; cnt2=1 ;}\\n            \\n         else if( x==it) { cnt1 ++; }\\n\\n         else if( y==it ){ cnt2++; }\\n\\n         else {cnt1--; cnt2--;}\\n\\n         }\\n         cnt1 =0 ;cnt2 =0;\\n      \\n      int val = (nums.size()/3)+1; \\n\\n\\n      for(auto it :nums)\\n      {\\n          if( x==it) { cnt1 ++ ; }\\n\\n          if( y ==it ) { cnt2++ ; }\\n\\n           if( cnt1 ==val) { ans.push_back(it); cnt1 = 0; x = INT_MAX;}\\n           \\n           if( cnt2 ==val) { ans.push_back(it); cnt2 = 0;  y =INT_MAX ;}\\n      }\\n         \\n         return ans ;\\n    \\n    }\\n};"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The follow up in O(1) space is hard, and the original question is easy, neither of them are medium. \n\nAnything that I can solve in under 5 minutes with a one-liner can't be a medium. Anything that requires you to come up with an algorithm which bears not one but two names of famous dudes probably can't be medium either"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This! I don\\'t why people think ask problems like these which are very easy after knowing the trick/algo and are super hard if you don\\'t."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Very Intersting algorithm"
                    },
                    {
                        "username": "asthakul17",
                        "content": "it should be marked easy"
                    },
                    {
                        "username": "zcore",
                        "content": "The space constraint is O(1), read the follow up, that is what makes it a medium problem."
                    }
                ]
            },
            {
                "id": 1730445,
                "content": [
                    {
                        "username": "alanmiller",
                        "content": "This article is for those who are familiar with how Moore\\'s voting algorithm is implemented, but don\\'t understand why it works, or seeks for a rigorous proof of its correctness.\\n\\nIntuitive idea:\\nLet\\'s start with the basic case: [169. Majority Element](https://leetcode.com/problems/majority-element/)\\nOne can think of the algorithm as a battle process, whenever two different elements encountered, the battle occurs, and they both vanishes. The candidate is whoever that survives this battle process. The point here is that whenever a majority element vanishes (no matter it is the current candidate or not), there is at least (exactly) one other element dies with it. Hence, the majority element survives, since there are at least n/2 of them.\\n\\nNow for this problem, the only difference is that there are two candidates, corresponding to two survivors that we pick. And whenever an element vanishes in a battle, there are at least (exactly) 2 other elements die with it. Hence, whenever an element with occurences > n/3 dies (no matter it is a current candidate or not), there are at least 2 other elements die with it. So it survives.\\n\\nRigorous proof this problem:\\nThe above intuitive idea can easily be turned into a rigorous proof.\\nLet\\'s prove by contradiction, suppose an element with occurences > n/3 is not a candidate after the algorithm finishes. Then, they must be all cancelled out at a certain point (either got counted down as a candidate element, or as a non-candidate to cause two candidates counted down), this corresponds to all of them vanishes in the battle. But whenever a cancellation occurs, three elements are recorded (two candidates counted down, and one non-candidate got passed), this corresponds to whenever an element dies, two others die with it. So in total, there are > 3*(n/3) elements recorded, but there are only n elements. Contradiction.\\n\\nGeneralization:\\nAs one can see, the point is whenever an element dies, 2 others die with it. For general k,  just choose k candidates, and there will be (k-1) elements die with it. The proof is almost verbatim.\\n"
                    },
                    {
                        "username": "malkaraj",
                        "content": "able to solve this problem thanks"
                    },
                    {
                        "username": "ashu_kr",
                        "content": "[@Amarjeet Kumar](/getbusylivingOrgetbusydying) because only two candidate greater than two is only possible\\nlet the 2 candidate be greater than n/3 and the remaining will be x\\n(>n/3)+(>n/3)+x=n     \\ntherefore,x<n/3;// so the 3rd element will occur less than n/3 times\\nthat\\'s why we are taking 2 candidate"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "why taking two candidate here??\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro I can\\'t thank you enough for this explanation. People underestimate how much intuition understanding of a problem is necessary."
                    },
                    {
                        "username": "shivanshx365",
                        "content": "Nice Explanation \\uD83D\\uDC4D"
                    },
                    {
                        "username": "prtyhr",
                        "content": "the battle analogy was great, thanks!"
                    },
                    {
                        "username": "tekmark",
                        "content": "i am so dumb."
                    },
                    {
                        "username": "pramoth-kj",
                        "content": "Same as me\\n"
                    },
                    {
                        "username": "workspace9801",
                        "content": ":-<\\n"
                    },
                    {
                        "username": "justine-135",
                        "content": "LMAO sorry i\\'m so u"
                    },
                    {
                        "username": "munenndragaur",
                        "content": "[@ajinkode](/ajinkode) yeah he is correct make use of brain and pen and paper \\nyou will baap of these qustions "
                    },
                    {
                        "username": "ajinkode",
                        "content": "You are not dumb. You just haven\\'t practiced enough problems yet  :)"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i\\'m also "
                    },
                    {
                        "username": "irshadcc135",
                        "content": "Hint explanation\n\nLet n denote total number of elements. \n\n\nIf an element \"a\" occurs more than n/3 times, then number of elements excluding \"a\" is \n\nn - ((n/3)+1)  = (2n-3)/3 \n\nIf an element \"b\" occurs more than n/3 times, then number of element excluding \"a\" and \"b\" is \n\n((2n-3)/3) - ((n/3) +1) = (n-6)/3 \n\nNow we have only left (n-6)/3 elements, and no elements can occur more than (n/3) times, since (n-6)/3 is less than (n/3)\n\nWe only have to look for 2 elements using O(n) algorithm. I hope the hint make sense now. \n"
                    },
                    {
                        "username": "lgylym",
                        "content": "And it\\'ll absurd if the interviewer is looking for that.\\n\\nVery interesting algorithm though."
                    },
                    {
                        "username": "Daciuk",
                        "content": "Did leetcode just not give us test cases that show the strength of O(1) space?  Does that make sense to anyone?"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "nah, not at all"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Freaking mind-blowing problem!"
                    },
                    {
                        "username": "ankush920",
                        "content": "I CRACK THE ACTUAL CONCEPT MOLDING FOR ALL N/NUM|| MUST ONE TIME WATCH || )(N) || 0(1)\\nankush920\\n0\\nin a few seconds\\nC++\\nIntuition\\nhello community , i appricate your presence and belive me try to conveny my thought process with my best .( sorry if my language is not so strong )\\n\\nprocess\\n-> we have to find the element have freq more than ( not equal ) n/i ( 2<i<n)\\n\\npointer and counter\\nfor n/i we have to take i-1 pointer and i-1 ;\\nwhy?\\n-> because in n size array only maximum i-1 element is present who is more than freq of n/i\\nbecause they are more then n/i time (not equal more than )\\n\\nlook => n-(i-1)((n/i)+1) > n/i (put value and can check it )\\npointer store\\nbecause each pointer show one possible majority element so, each pointer store unique value or number or candidate\\n\\nmanually check\\nwe have to verify our pointer value( number store in pointer )\\nis actually a majority element or not by checking it occurence\\n\\n-> do iteration and count their frq == n/i+1 if yes then push to ans vector if no leave it\\n\\nwhy we do manually check ?\\nbecause while traversing through array we put some value in pointer which may or may not be our answer ( look one time code you understand my point :) )\\n\\nsupport my hard by your love -> upvote\\nApproach\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        \\n        int cnt1 = 0 ,  cnt2= 0 ; \\n         int x = INT_MAX , y= INT_MAX;\\n         vector<int>ans;\\n\\n         for( auto it : nums )\\n         {\\n            if( cnt1 ==0 && y!=it ) {  x = it ; cnt1 =1; }\\n\\n            else if(cnt2 ==0 && x!= it ) { y =it ; cnt2=1 ;}\\n            \\n         else if( x==it) { cnt1 ++; }\\n\\n         else if( y==it ){ cnt2++; }\\n\\n         else {cnt1--; cnt2--;}\\n\\n         }\\n         cnt1 =0 ;cnt2 =0;\\n      \\n      int val = (nums.size()/3)+1; \\n\\n\\n      for(auto it :nums)\\n      {\\n          if( x==it) { cnt1 ++ ; }\\n\\n          if( y ==it ) { cnt2++ ; }\\n\\n           if( cnt1 ==val) { ans.push_back(it); cnt1 = 0; x = INT_MAX;}\\n           \\n           if( cnt2 ==val) { ans.push_back(it); cnt2 = 0;  y =INT_MAX ;}\\n      }\\n         \\n         return ans ;\\n    \\n    }\\n};"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The follow up in O(1) space is hard, and the original question is easy, neither of them are medium. \n\nAnything that I can solve in under 5 minutes with a one-liner can't be a medium. Anything that requires you to come up with an algorithm which bears not one but two names of famous dudes probably can't be medium either"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This! I don\\'t why people think ask problems like these which are very easy after knowing the trick/algo and are super hard if you don\\'t."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Very Intersting algorithm"
                    },
                    {
                        "username": "asthakul17",
                        "content": "it should be marked easy"
                    },
                    {
                        "username": "zcore",
                        "content": "The space constraint is O(1), read the follow up, that is what makes it a medium problem."
                    }
                ]
            },
            {
                "id": 1902185,
                "content": [
                    {
                        "username": "alanmiller",
                        "content": "This article is for those who are familiar with how Moore\\'s voting algorithm is implemented, but don\\'t understand why it works, or seeks for a rigorous proof of its correctness.\\n\\nIntuitive idea:\\nLet\\'s start with the basic case: [169. Majority Element](https://leetcode.com/problems/majority-element/)\\nOne can think of the algorithm as a battle process, whenever two different elements encountered, the battle occurs, and they both vanishes. The candidate is whoever that survives this battle process. The point here is that whenever a majority element vanishes (no matter it is the current candidate or not), there is at least (exactly) one other element dies with it. Hence, the majority element survives, since there are at least n/2 of them.\\n\\nNow for this problem, the only difference is that there are two candidates, corresponding to two survivors that we pick. And whenever an element vanishes in a battle, there are at least (exactly) 2 other elements die with it. Hence, whenever an element with occurences > n/3 dies (no matter it is a current candidate or not), there are at least 2 other elements die with it. So it survives.\\n\\nRigorous proof this problem:\\nThe above intuitive idea can easily be turned into a rigorous proof.\\nLet\\'s prove by contradiction, suppose an element with occurences > n/3 is not a candidate after the algorithm finishes. Then, they must be all cancelled out at a certain point (either got counted down as a candidate element, or as a non-candidate to cause two candidates counted down), this corresponds to all of them vanishes in the battle. But whenever a cancellation occurs, three elements are recorded (two candidates counted down, and one non-candidate got passed), this corresponds to whenever an element dies, two others die with it. So in total, there are > 3*(n/3) elements recorded, but there are only n elements. Contradiction.\\n\\nGeneralization:\\nAs one can see, the point is whenever an element dies, 2 others die with it. For general k,  just choose k candidates, and there will be (k-1) elements die with it. The proof is almost verbatim.\\n"
                    },
                    {
                        "username": "malkaraj",
                        "content": "able to solve this problem thanks"
                    },
                    {
                        "username": "ashu_kr",
                        "content": "[@Amarjeet Kumar](/getbusylivingOrgetbusydying) because only two candidate greater than two is only possible\\nlet the 2 candidate be greater than n/3 and the remaining will be x\\n(>n/3)+(>n/3)+x=n     \\ntherefore,x<n/3;// so the 3rd element will occur less than n/3 times\\nthat\\'s why we are taking 2 candidate"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "why taking two candidate here??\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro I can\\'t thank you enough for this explanation. People underestimate how much intuition understanding of a problem is necessary."
                    },
                    {
                        "username": "shivanshx365",
                        "content": "Nice Explanation \\uD83D\\uDC4D"
                    },
                    {
                        "username": "prtyhr",
                        "content": "the battle analogy was great, thanks!"
                    },
                    {
                        "username": "tekmark",
                        "content": "i am so dumb."
                    },
                    {
                        "username": "pramoth-kj",
                        "content": "Same as me\\n"
                    },
                    {
                        "username": "workspace9801",
                        "content": ":-<\\n"
                    },
                    {
                        "username": "justine-135",
                        "content": "LMAO sorry i\\'m so u"
                    },
                    {
                        "username": "munenndragaur",
                        "content": "[@ajinkode](/ajinkode) yeah he is correct make use of brain and pen and paper \\nyou will baap of these qustions "
                    },
                    {
                        "username": "ajinkode",
                        "content": "You are not dumb. You just haven\\'t practiced enough problems yet  :)"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i\\'m also "
                    },
                    {
                        "username": "irshadcc135",
                        "content": "Hint explanation\n\nLet n denote total number of elements. \n\n\nIf an element \"a\" occurs more than n/3 times, then number of elements excluding \"a\" is \n\nn - ((n/3)+1)  = (2n-3)/3 \n\nIf an element \"b\" occurs more than n/3 times, then number of element excluding \"a\" and \"b\" is \n\n((2n-3)/3) - ((n/3) +1) = (n-6)/3 \n\nNow we have only left (n-6)/3 elements, and no elements can occur more than (n/3) times, since (n-6)/3 is less than (n/3)\n\nWe only have to look for 2 elements using O(n) algorithm. I hope the hint make sense now. \n"
                    },
                    {
                        "username": "lgylym",
                        "content": "And it\\'ll absurd if the interviewer is looking for that.\\n\\nVery interesting algorithm though."
                    },
                    {
                        "username": "Daciuk",
                        "content": "Did leetcode just not give us test cases that show the strength of O(1) space?  Does that make sense to anyone?"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "nah, not at all"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Freaking mind-blowing problem!"
                    },
                    {
                        "username": "ankush920",
                        "content": "I CRACK THE ACTUAL CONCEPT MOLDING FOR ALL N/NUM|| MUST ONE TIME WATCH || )(N) || 0(1)\\nankush920\\n0\\nin a few seconds\\nC++\\nIntuition\\nhello community , i appricate your presence and belive me try to conveny my thought process with my best .( sorry if my language is not so strong )\\n\\nprocess\\n-> we have to find the element have freq more than ( not equal ) n/i ( 2<i<n)\\n\\npointer and counter\\nfor n/i we have to take i-1 pointer and i-1 ;\\nwhy?\\n-> because in n size array only maximum i-1 element is present who is more than freq of n/i\\nbecause they are more then n/i time (not equal more than )\\n\\nlook => n-(i-1)((n/i)+1) > n/i (put value and can check it )\\npointer store\\nbecause each pointer show one possible majority element so, each pointer store unique value or number or candidate\\n\\nmanually check\\nwe have to verify our pointer value( number store in pointer )\\nis actually a majority element or not by checking it occurence\\n\\n-> do iteration and count their frq == n/i+1 if yes then push to ans vector if no leave it\\n\\nwhy we do manually check ?\\nbecause while traversing through array we put some value in pointer which may or may not be our answer ( look one time code you understand my point :) )\\n\\nsupport my hard by your love -> upvote\\nApproach\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        \\n        int cnt1 = 0 ,  cnt2= 0 ; \\n         int x = INT_MAX , y= INT_MAX;\\n         vector<int>ans;\\n\\n         for( auto it : nums )\\n         {\\n            if( cnt1 ==0 && y!=it ) {  x = it ; cnt1 =1; }\\n\\n            else if(cnt2 ==0 && x!= it ) { y =it ; cnt2=1 ;}\\n            \\n         else if( x==it) { cnt1 ++; }\\n\\n         else if( y==it ){ cnt2++; }\\n\\n         else {cnt1--; cnt2--;}\\n\\n         }\\n         cnt1 =0 ;cnt2 =0;\\n      \\n      int val = (nums.size()/3)+1; \\n\\n\\n      for(auto it :nums)\\n      {\\n          if( x==it) { cnt1 ++ ; }\\n\\n          if( y ==it ) { cnt2++ ; }\\n\\n           if( cnt1 ==val) { ans.push_back(it); cnt1 = 0; x = INT_MAX;}\\n           \\n           if( cnt2 ==val) { ans.push_back(it); cnt2 = 0;  y =INT_MAX ;}\\n      }\\n         \\n         return ans ;\\n    \\n    }\\n};"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The follow up in O(1) space is hard, and the original question is easy, neither of them are medium. \n\nAnything that I can solve in under 5 minutes with a one-liner can't be a medium. Anything that requires you to come up with an algorithm which bears not one but two names of famous dudes probably can't be medium either"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This! I don\\'t why people think ask problems like these which are very easy after knowing the trick/algo and are super hard if you don\\'t."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Very Intersting algorithm"
                    },
                    {
                        "username": "asthakul17",
                        "content": "it should be marked easy"
                    },
                    {
                        "username": "zcore",
                        "content": "The space constraint is O(1), read the follow up, that is what makes it a medium problem."
                    }
                ]
            },
            {
                "id": 1868197,
                "content": [
                    {
                        "username": "alanmiller",
                        "content": "This article is for those who are familiar with how Moore\\'s voting algorithm is implemented, but don\\'t understand why it works, or seeks for a rigorous proof of its correctness.\\n\\nIntuitive idea:\\nLet\\'s start with the basic case: [169. Majority Element](https://leetcode.com/problems/majority-element/)\\nOne can think of the algorithm as a battle process, whenever two different elements encountered, the battle occurs, and they both vanishes. The candidate is whoever that survives this battle process. The point here is that whenever a majority element vanishes (no matter it is the current candidate or not), there is at least (exactly) one other element dies with it. Hence, the majority element survives, since there are at least n/2 of them.\\n\\nNow for this problem, the only difference is that there are two candidates, corresponding to two survivors that we pick. And whenever an element vanishes in a battle, there are at least (exactly) 2 other elements die with it. Hence, whenever an element with occurences > n/3 dies (no matter it is a current candidate or not), there are at least 2 other elements die with it. So it survives.\\n\\nRigorous proof this problem:\\nThe above intuitive idea can easily be turned into a rigorous proof.\\nLet\\'s prove by contradiction, suppose an element with occurences > n/3 is not a candidate after the algorithm finishes. Then, they must be all cancelled out at a certain point (either got counted down as a candidate element, or as a non-candidate to cause two candidates counted down), this corresponds to all of them vanishes in the battle. But whenever a cancellation occurs, three elements are recorded (two candidates counted down, and one non-candidate got passed), this corresponds to whenever an element dies, two others die with it. So in total, there are > 3*(n/3) elements recorded, but there are only n elements. Contradiction.\\n\\nGeneralization:\\nAs one can see, the point is whenever an element dies, 2 others die with it. For general k,  just choose k candidates, and there will be (k-1) elements die with it. The proof is almost verbatim.\\n"
                    },
                    {
                        "username": "malkaraj",
                        "content": "able to solve this problem thanks"
                    },
                    {
                        "username": "ashu_kr",
                        "content": "[@Amarjeet Kumar](/getbusylivingOrgetbusydying) because only two candidate greater than two is only possible\\nlet the 2 candidate be greater than n/3 and the remaining will be x\\n(>n/3)+(>n/3)+x=n     \\ntherefore,x<n/3;// so the 3rd element will occur less than n/3 times\\nthat\\'s why we are taking 2 candidate"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "why taking two candidate here??\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro I can\\'t thank you enough for this explanation. People underestimate how much intuition understanding of a problem is necessary."
                    },
                    {
                        "username": "shivanshx365",
                        "content": "Nice Explanation \\uD83D\\uDC4D"
                    },
                    {
                        "username": "prtyhr",
                        "content": "the battle analogy was great, thanks!"
                    },
                    {
                        "username": "tekmark",
                        "content": "i am so dumb."
                    },
                    {
                        "username": "pramoth-kj",
                        "content": "Same as me\\n"
                    },
                    {
                        "username": "workspace9801",
                        "content": ":-<\\n"
                    },
                    {
                        "username": "justine-135",
                        "content": "LMAO sorry i\\'m so u"
                    },
                    {
                        "username": "munenndragaur",
                        "content": "[@ajinkode](/ajinkode) yeah he is correct make use of brain and pen and paper \\nyou will baap of these qustions "
                    },
                    {
                        "username": "ajinkode",
                        "content": "You are not dumb. You just haven\\'t practiced enough problems yet  :)"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i\\'m also "
                    },
                    {
                        "username": "irshadcc135",
                        "content": "Hint explanation\n\nLet n denote total number of elements. \n\n\nIf an element \"a\" occurs more than n/3 times, then number of elements excluding \"a\" is \n\nn - ((n/3)+1)  = (2n-3)/3 \n\nIf an element \"b\" occurs more than n/3 times, then number of element excluding \"a\" and \"b\" is \n\n((2n-3)/3) - ((n/3) +1) = (n-6)/3 \n\nNow we have only left (n-6)/3 elements, and no elements can occur more than (n/3) times, since (n-6)/3 is less than (n/3)\n\nWe only have to look for 2 elements using O(n) algorithm. I hope the hint make sense now. \n"
                    },
                    {
                        "username": "lgylym",
                        "content": "And it\\'ll absurd if the interviewer is looking for that.\\n\\nVery interesting algorithm though."
                    },
                    {
                        "username": "Daciuk",
                        "content": "Did leetcode just not give us test cases that show the strength of O(1) space?  Does that make sense to anyone?"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "nah, not at all"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Freaking mind-blowing problem!"
                    },
                    {
                        "username": "ankush920",
                        "content": "I CRACK THE ACTUAL CONCEPT MOLDING FOR ALL N/NUM|| MUST ONE TIME WATCH || )(N) || 0(1)\\nankush920\\n0\\nin a few seconds\\nC++\\nIntuition\\nhello community , i appricate your presence and belive me try to conveny my thought process with my best .( sorry if my language is not so strong )\\n\\nprocess\\n-> we have to find the element have freq more than ( not equal ) n/i ( 2<i<n)\\n\\npointer and counter\\nfor n/i we have to take i-1 pointer and i-1 ;\\nwhy?\\n-> because in n size array only maximum i-1 element is present who is more than freq of n/i\\nbecause they are more then n/i time (not equal more than )\\n\\nlook => n-(i-1)((n/i)+1) > n/i (put value and can check it )\\npointer store\\nbecause each pointer show one possible majority element so, each pointer store unique value or number or candidate\\n\\nmanually check\\nwe have to verify our pointer value( number store in pointer )\\nis actually a majority element or not by checking it occurence\\n\\n-> do iteration and count their frq == n/i+1 if yes then push to ans vector if no leave it\\n\\nwhy we do manually check ?\\nbecause while traversing through array we put some value in pointer which may or may not be our answer ( look one time code you understand my point :) )\\n\\nsupport my hard by your love -> upvote\\nApproach\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        \\n        int cnt1 = 0 ,  cnt2= 0 ; \\n         int x = INT_MAX , y= INT_MAX;\\n         vector<int>ans;\\n\\n         for( auto it : nums )\\n         {\\n            if( cnt1 ==0 && y!=it ) {  x = it ; cnt1 =1; }\\n\\n            else if(cnt2 ==0 && x!= it ) { y =it ; cnt2=1 ;}\\n            \\n         else if( x==it) { cnt1 ++; }\\n\\n         else if( y==it ){ cnt2++; }\\n\\n         else {cnt1--; cnt2--;}\\n\\n         }\\n         cnt1 =0 ;cnt2 =0;\\n      \\n      int val = (nums.size()/3)+1; \\n\\n\\n      for(auto it :nums)\\n      {\\n          if( x==it) { cnt1 ++ ; }\\n\\n          if( y ==it ) { cnt2++ ; }\\n\\n           if( cnt1 ==val) { ans.push_back(it); cnt1 = 0; x = INT_MAX;}\\n           \\n           if( cnt2 ==val) { ans.push_back(it); cnt2 = 0;  y =INT_MAX ;}\\n      }\\n         \\n         return ans ;\\n    \\n    }\\n};"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The follow up in O(1) space is hard, and the original question is easy, neither of them are medium. \n\nAnything that I can solve in under 5 minutes with a one-liner can't be a medium. Anything that requires you to come up with an algorithm which bears not one but two names of famous dudes probably can't be medium either"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This! I don\\'t why people think ask problems like these which are very easy after knowing the trick/algo and are super hard if you don\\'t."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Very Intersting algorithm"
                    },
                    {
                        "username": "asthakul17",
                        "content": "it should be marked easy"
                    },
                    {
                        "username": "zcore",
                        "content": "The space constraint is O(1), read the follow up, that is what makes it a medium problem."
                    }
                ]
            },
            {
                "id": 1755924,
                "content": [
                    {
                        "username": "alanmiller",
                        "content": "This article is for those who are familiar with how Moore\\'s voting algorithm is implemented, but don\\'t understand why it works, or seeks for a rigorous proof of its correctness.\\n\\nIntuitive idea:\\nLet\\'s start with the basic case: [169. Majority Element](https://leetcode.com/problems/majority-element/)\\nOne can think of the algorithm as a battle process, whenever two different elements encountered, the battle occurs, and they both vanishes. The candidate is whoever that survives this battle process. The point here is that whenever a majority element vanishes (no matter it is the current candidate or not), there is at least (exactly) one other element dies with it. Hence, the majority element survives, since there are at least n/2 of them.\\n\\nNow for this problem, the only difference is that there are two candidates, corresponding to two survivors that we pick. And whenever an element vanishes in a battle, there are at least (exactly) 2 other elements die with it. Hence, whenever an element with occurences > n/3 dies (no matter it is a current candidate or not), there are at least 2 other elements die with it. So it survives.\\n\\nRigorous proof this problem:\\nThe above intuitive idea can easily be turned into a rigorous proof.\\nLet\\'s prove by contradiction, suppose an element with occurences > n/3 is not a candidate after the algorithm finishes. Then, they must be all cancelled out at a certain point (either got counted down as a candidate element, or as a non-candidate to cause two candidates counted down), this corresponds to all of them vanishes in the battle. But whenever a cancellation occurs, three elements are recorded (two candidates counted down, and one non-candidate got passed), this corresponds to whenever an element dies, two others die with it. So in total, there are > 3*(n/3) elements recorded, but there are only n elements. Contradiction.\\n\\nGeneralization:\\nAs one can see, the point is whenever an element dies, 2 others die with it. For general k,  just choose k candidates, and there will be (k-1) elements die with it. The proof is almost verbatim.\\n"
                    },
                    {
                        "username": "malkaraj",
                        "content": "able to solve this problem thanks"
                    },
                    {
                        "username": "ashu_kr",
                        "content": "[@Amarjeet Kumar](/getbusylivingOrgetbusydying) because only two candidate greater than two is only possible\\nlet the 2 candidate be greater than n/3 and the remaining will be x\\n(>n/3)+(>n/3)+x=n     \\ntherefore,x<n/3;// so the 3rd element will occur less than n/3 times\\nthat\\'s why we are taking 2 candidate"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "why taking two candidate here??\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro I can\\'t thank you enough for this explanation. People underestimate how much intuition understanding of a problem is necessary."
                    },
                    {
                        "username": "shivanshx365",
                        "content": "Nice Explanation \\uD83D\\uDC4D"
                    },
                    {
                        "username": "prtyhr",
                        "content": "the battle analogy was great, thanks!"
                    },
                    {
                        "username": "tekmark",
                        "content": "i am so dumb."
                    },
                    {
                        "username": "pramoth-kj",
                        "content": "Same as me\\n"
                    },
                    {
                        "username": "workspace9801",
                        "content": ":-<\\n"
                    },
                    {
                        "username": "justine-135",
                        "content": "LMAO sorry i\\'m so u"
                    },
                    {
                        "username": "munenndragaur",
                        "content": "[@ajinkode](/ajinkode) yeah he is correct make use of brain and pen and paper \\nyou will baap of these qustions "
                    },
                    {
                        "username": "ajinkode",
                        "content": "You are not dumb. You just haven\\'t practiced enough problems yet  :)"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i\\'m also "
                    },
                    {
                        "username": "irshadcc135",
                        "content": "Hint explanation\n\nLet n denote total number of elements. \n\n\nIf an element \"a\" occurs more than n/3 times, then number of elements excluding \"a\" is \n\nn - ((n/3)+1)  = (2n-3)/3 \n\nIf an element \"b\" occurs more than n/3 times, then number of element excluding \"a\" and \"b\" is \n\n((2n-3)/3) - ((n/3) +1) = (n-6)/3 \n\nNow we have only left (n-6)/3 elements, and no elements can occur more than (n/3) times, since (n-6)/3 is less than (n/3)\n\nWe only have to look for 2 elements using O(n) algorithm. I hope the hint make sense now. \n"
                    },
                    {
                        "username": "lgylym",
                        "content": "And it\\'ll absurd if the interviewer is looking for that.\\n\\nVery interesting algorithm though."
                    },
                    {
                        "username": "Daciuk",
                        "content": "Did leetcode just not give us test cases that show the strength of O(1) space?  Does that make sense to anyone?"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "nah, not at all"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Freaking mind-blowing problem!"
                    },
                    {
                        "username": "ankush920",
                        "content": "I CRACK THE ACTUAL CONCEPT MOLDING FOR ALL N/NUM|| MUST ONE TIME WATCH || )(N) || 0(1)\\nankush920\\n0\\nin a few seconds\\nC++\\nIntuition\\nhello community , i appricate your presence and belive me try to conveny my thought process with my best .( sorry if my language is not so strong )\\n\\nprocess\\n-> we have to find the element have freq more than ( not equal ) n/i ( 2<i<n)\\n\\npointer and counter\\nfor n/i we have to take i-1 pointer and i-1 ;\\nwhy?\\n-> because in n size array only maximum i-1 element is present who is more than freq of n/i\\nbecause they are more then n/i time (not equal more than )\\n\\nlook => n-(i-1)((n/i)+1) > n/i (put value and can check it )\\npointer store\\nbecause each pointer show one possible majority element so, each pointer store unique value or number or candidate\\n\\nmanually check\\nwe have to verify our pointer value( number store in pointer )\\nis actually a majority element or not by checking it occurence\\n\\n-> do iteration and count their frq == n/i+1 if yes then push to ans vector if no leave it\\n\\nwhy we do manually check ?\\nbecause while traversing through array we put some value in pointer which may or may not be our answer ( look one time code you understand my point :) )\\n\\nsupport my hard by your love -> upvote\\nApproach\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        \\n        int cnt1 = 0 ,  cnt2= 0 ; \\n         int x = INT_MAX , y= INT_MAX;\\n         vector<int>ans;\\n\\n         for( auto it : nums )\\n         {\\n            if( cnt1 ==0 && y!=it ) {  x = it ; cnt1 =1; }\\n\\n            else if(cnt2 ==0 && x!= it ) { y =it ; cnt2=1 ;}\\n            \\n         else if( x==it) { cnt1 ++; }\\n\\n         else if( y==it ){ cnt2++; }\\n\\n         else {cnt1--; cnt2--;}\\n\\n         }\\n         cnt1 =0 ;cnt2 =0;\\n      \\n      int val = (nums.size()/3)+1; \\n\\n\\n      for(auto it :nums)\\n      {\\n          if( x==it) { cnt1 ++ ; }\\n\\n          if( y ==it ) { cnt2++ ; }\\n\\n           if( cnt1 ==val) { ans.push_back(it); cnt1 = 0; x = INT_MAX;}\\n           \\n           if( cnt2 ==val) { ans.push_back(it); cnt2 = 0;  y =INT_MAX ;}\\n      }\\n         \\n         return ans ;\\n    \\n    }\\n};"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The follow up in O(1) space is hard, and the original question is easy, neither of them are medium. \n\nAnything that I can solve in under 5 minutes with a one-liner can't be a medium. Anything that requires you to come up with an algorithm which bears not one but two names of famous dudes probably can't be medium either"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This! I don\\'t why people think ask problems like these which are very easy after knowing the trick/algo and are super hard if you don\\'t."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Very Intersting algorithm"
                    },
                    {
                        "username": "asthakul17",
                        "content": "it should be marked easy"
                    },
                    {
                        "username": "zcore",
                        "content": "The space constraint is O(1), read the follow up, that is what makes it a medium problem."
                    }
                ]
            },
            {
                "id": 1796488,
                "content": [
                    {
                        "username": "alanmiller",
                        "content": "This article is for those who are familiar with how Moore\\'s voting algorithm is implemented, but don\\'t understand why it works, or seeks for a rigorous proof of its correctness.\\n\\nIntuitive idea:\\nLet\\'s start with the basic case: [169. Majority Element](https://leetcode.com/problems/majority-element/)\\nOne can think of the algorithm as a battle process, whenever two different elements encountered, the battle occurs, and they both vanishes. The candidate is whoever that survives this battle process. The point here is that whenever a majority element vanishes (no matter it is the current candidate or not), there is at least (exactly) one other element dies with it. Hence, the majority element survives, since there are at least n/2 of them.\\n\\nNow for this problem, the only difference is that there are two candidates, corresponding to two survivors that we pick. And whenever an element vanishes in a battle, there are at least (exactly) 2 other elements die with it. Hence, whenever an element with occurences > n/3 dies (no matter it is a current candidate or not), there are at least 2 other elements die with it. So it survives.\\n\\nRigorous proof this problem:\\nThe above intuitive idea can easily be turned into a rigorous proof.\\nLet\\'s prove by contradiction, suppose an element with occurences > n/3 is not a candidate after the algorithm finishes. Then, they must be all cancelled out at a certain point (either got counted down as a candidate element, or as a non-candidate to cause two candidates counted down), this corresponds to all of them vanishes in the battle. But whenever a cancellation occurs, three elements are recorded (two candidates counted down, and one non-candidate got passed), this corresponds to whenever an element dies, two others die with it. So in total, there are > 3*(n/3) elements recorded, but there are only n elements. Contradiction.\\n\\nGeneralization:\\nAs one can see, the point is whenever an element dies, 2 others die with it. For general k,  just choose k candidates, and there will be (k-1) elements die with it. The proof is almost verbatim.\\n"
                    },
                    {
                        "username": "malkaraj",
                        "content": "able to solve this problem thanks"
                    },
                    {
                        "username": "ashu_kr",
                        "content": "[@Amarjeet Kumar](/getbusylivingOrgetbusydying) because only two candidate greater than two is only possible\\nlet the 2 candidate be greater than n/3 and the remaining will be x\\n(>n/3)+(>n/3)+x=n     \\ntherefore,x<n/3;// so the 3rd element will occur less than n/3 times\\nthat\\'s why we are taking 2 candidate"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "why taking two candidate here??\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro I can\\'t thank you enough for this explanation. People underestimate how much intuition understanding of a problem is necessary."
                    },
                    {
                        "username": "shivanshx365",
                        "content": "Nice Explanation \\uD83D\\uDC4D"
                    },
                    {
                        "username": "prtyhr",
                        "content": "the battle analogy was great, thanks!"
                    },
                    {
                        "username": "tekmark",
                        "content": "i am so dumb."
                    },
                    {
                        "username": "pramoth-kj",
                        "content": "Same as me\\n"
                    },
                    {
                        "username": "workspace9801",
                        "content": ":-<\\n"
                    },
                    {
                        "username": "justine-135",
                        "content": "LMAO sorry i\\'m so u"
                    },
                    {
                        "username": "munenndragaur",
                        "content": "[@ajinkode](/ajinkode) yeah he is correct make use of brain and pen and paper \\nyou will baap of these qustions "
                    },
                    {
                        "username": "ajinkode",
                        "content": "You are not dumb. You just haven\\'t practiced enough problems yet  :)"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i\\'m also "
                    },
                    {
                        "username": "irshadcc135",
                        "content": "Hint explanation\n\nLet n denote total number of elements. \n\n\nIf an element \"a\" occurs more than n/3 times, then number of elements excluding \"a\" is \n\nn - ((n/3)+1)  = (2n-3)/3 \n\nIf an element \"b\" occurs more than n/3 times, then number of element excluding \"a\" and \"b\" is \n\n((2n-3)/3) - ((n/3) +1) = (n-6)/3 \n\nNow we have only left (n-6)/3 elements, and no elements can occur more than (n/3) times, since (n-6)/3 is less than (n/3)\n\nWe only have to look for 2 elements using O(n) algorithm. I hope the hint make sense now. \n"
                    },
                    {
                        "username": "lgylym",
                        "content": "And it\\'ll absurd if the interviewer is looking for that.\\n\\nVery interesting algorithm though."
                    },
                    {
                        "username": "Daciuk",
                        "content": "Did leetcode just not give us test cases that show the strength of O(1) space?  Does that make sense to anyone?"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "nah, not at all"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Freaking mind-blowing problem!"
                    },
                    {
                        "username": "ankush920",
                        "content": "I CRACK THE ACTUAL CONCEPT MOLDING FOR ALL N/NUM|| MUST ONE TIME WATCH || )(N) || 0(1)\\nankush920\\n0\\nin a few seconds\\nC++\\nIntuition\\nhello community , i appricate your presence and belive me try to conveny my thought process with my best .( sorry if my language is not so strong )\\n\\nprocess\\n-> we have to find the element have freq more than ( not equal ) n/i ( 2<i<n)\\n\\npointer and counter\\nfor n/i we have to take i-1 pointer and i-1 ;\\nwhy?\\n-> because in n size array only maximum i-1 element is present who is more than freq of n/i\\nbecause they are more then n/i time (not equal more than )\\n\\nlook => n-(i-1)((n/i)+1) > n/i (put value and can check it )\\npointer store\\nbecause each pointer show one possible majority element so, each pointer store unique value or number or candidate\\n\\nmanually check\\nwe have to verify our pointer value( number store in pointer )\\nis actually a majority element or not by checking it occurence\\n\\n-> do iteration and count their frq == n/i+1 if yes then push to ans vector if no leave it\\n\\nwhy we do manually check ?\\nbecause while traversing through array we put some value in pointer which may or may not be our answer ( look one time code you understand my point :) )\\n\\nsupport my hard by your love -> upvote\\nApproach\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        \\n        int cnt1 = 0 ,  cnt2= 0 ; \\n         int x = INT_MAX , y= INT_MAX;\\n         vector<int>ans;\\n\\n         for( auto it : nums )\\n         {\\n            if( cnt1 ==0 && y!=it ) {  x = it ; cnt1 =1; }\\n\\n            else if(cnt2 ==0 && x!= it ) { y =it ; cnt2=1 ;}\\n            \\n         else if( x==it) { cnt1 ++; }\\n\\n         else if( y==it ){ cnt2++; }\\n\\n         else {cnt1--; cnt2--;}\\n\\n         }\\n         cnt1 =0 ;cnt2 =0;\\n      \\n      int val = (nums.size()/3)+1; \\n\\n\\n      for(auto it :nums)\\n      {\\n          if( x==it) { cnt1 ++ ; }\\n\\n          if( y ==it ) { cnt2++ ; }\\n\\n           if( cnt1 ==val) { ans.push_back(it); cnt1 = 0; x = INT_MAX;}\\n           \\n           if( cnt2 ==val) { ans.push_back(it); cnt2 = 0;  y =INT_MAX ;}\\n      }\\n         \\n         return ans ;\\n    \\n    }\\n};"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The follow up in O(1) space is hard, and the original question is easy, neither of them are medium. \n\nAnything that I can solve in under 5 minutes with a one-liner can't be a medium. Anything that requires you to come up with an algorithm which bears not one but two names of famous dudes probably can't be medium either"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This! I don\\'t why people think ask problems like these which are very easy after knowing the trick/algo and are super hard if you don\\'t."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Very Intersting algorithm"
                    },
                    {
                        "username": "asthakul17",
                        "content": "it should be marked easy"
                    },
                    {
                        "username": "zcore",
                        "content": "The space constraint is O(1), read the follow up, that is what makes it a medium problem."
                    }
                ]
            },
            {
                "id": 1571462,
                "content": [
                    {
                        "username": "eric135",
                        "content": "All the solutions I'm seeing here are either \"sort then count\" (satisfying the O(1) space constraint but not the O(n) runtime constraint) or \"count by hashmap\" (satisfying the O(n) runtime constraint but not the O(1) space constraint).\\n\\nDoes anyone have a solution that *actually* satisfies the requirements?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "[@cartesPerforees](/cartesPerforees) bro that comment was posted in 2016😭"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "what are you talking about? all the top voted solutions are about the Boyer-Moore algo"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "get familiar with Moore\\'s voting algo"
                    },
                    {
                        "username": "AKR_2610",
                        "content": "Use a set to store unique elements and use a map to store the number of repetitions\\n\\nBingo..."
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "that will not be an optimised solution"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Bruh, that\\'s like the most unoptimized solution   "
                    },
                    {
                        "username": "dineshdivi377",
                        "content": "we can solve in o(1) space with Boyer - Moore algo"
                    },
                    {
                        "username": "kumar029941",
                        "content": "In Moore\\'s voting algorithm why we have taken only two elements, why not three or four."
                    },
                    {
                        "username": "t4n",
                        "content": "Is it cheating to use a dictionary to keep track of count and just return values  > math.floor(n/3)"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "yes definitely"
                    },
                    {
                        "username": "AbhimatPandey",
                        "content": "we can use the given array ...for O(1) ....\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n      int n= nums.size()/3;   int i=1, k=0 , ct=1;  \\n      \\n       sort(nums.begin(), nums.end());\\n\\n        while(i<nums.size()){\\n\\n            if((nums[i]^(nums[i-1]))==0){\\n                nums[i]=0;\\n                ct++;\\n            }\\n            else{  nums[k]=0;\\n             if(ct>n){nums[k]=nums[i-1];}\\n                nums[i-1]=0;\\n                k++;\\n                ct=1;\\n            } }\\n\\n\\n    return nums ;    \\n    }\\n};"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "you are using sort, so it will take nlogn time, this is not optimised"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This problem may be marked easy because we can use maps. But the real challange is O(1) space complexity.\\nThis problem blew my mind. 77 test case pass out of 87. When you put one condition the other test case fails. We have to be very carefull about the corner cases. This is a freeking amazing problem. Iv been sitting for like 2 hours now."
                    },
                    {
                        "username": "gangadharkr27",
                        "content": "Question \\uD83D\\uDC4C"
                    },
                    {
                        "username": "aayushdhimann",
                        "content": "why my code is failing @ [0,0,0] and working @ [1,1,1]\n\n\n`class Solution {\n  public:\n    vector<int> majorityElement(vector<int>& arr) {\n        int e1=0,count1=0, n = arr.size();\n        int e2=0,count2=0;\n        for(int i=0; i<n; i++){\n            if(count1==0 && arr[i]!=e2){\n                count1=1;\n                e1=arr[i];\n            }\n            else if(count2==0 && arr[i]!=e1){\n                count2=1;\n                e2=arr[i];\n            }\n            else if(arr[i]==e1){\n                count1++;\n            }\n            else if(arr[i]==e2){\n                count2++;\n            }\n            else{\n                count1--,count2--;\n            }\n        }\n        \n        vector<int> v;\n        count1=0, count2=0;\n\n        for(int i=0; i<n; i++){\n            if(e1==arr[i]){\n                count1++;\n            }\n            if(e2==arr[i]){\n                count2++;\n            }\n        }\n\n        int mini=(int)(n/3)+1;\n\n        if( count1>=mini) v.emplace_back(e1);\n        if( count2>=mini) v.emplace_back(e2);\n        sort(v.begin(),v.end());\n        return v;\n    }\n};`"
                    },
                    {
                        "username": "Noman62",
                        "content": "I think, this problem mark as easy problem. If anyone can not understand how can approach this problem, I will give some hints,\\n1. use a hash table and count the occurrence of the number.\\n2. then apply a condition to check the which value is greater than \\u230A n/3 \\u230B "
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "you approach is correct, but not optimised"
                    },
                    {
                        "username": "sahebs450",
                        "content": "Question asking for O(1) space complexity."
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "class Solution {\n    public List<Integer> majorityElement(int[] nums) {\n        ArrayList<Integer> majority_elements=new ArrayList<>();\n        int votes=0;\n        int candidate=nums[0];\n        Arrays.sort(nums);\n        for(int i=0;i<nums.length;i++){\n            if(votes>((nums.length)/3)){\n                if(!majority_elements.contains(candidate))\n                    majority_elements.add(candidate);\n            }\n            if(votes==0){\n                candidate=nums[i];\n                votes=1;\n            }\n            else if(nums[i] == candidate){\n                votes++;\n            }\n            else if(nums[i] != candidate){\n                candidate=nums[i];\n                votes=1;\n            }\n        }\n        if(votes>((nums.length)/3)){\n            if(!majority_elements.contains(candidate))\n                majority_elements.add(candidate);\n        }\n        return majority_elements;\n    }\n}"
                    }
                ]
            },
            {
                "id": 1754790,
                "content": [
                    {
                        "username": "eric135",
                        "content": "All the solutions I'm seeing here are either \"sort then count\" (satisfying the O(1) space constraint but not the O(n) runtime constraint) or \"count by hashmap\" (satisfying the O(n) runtime constraint but not the O(1) space constraint).\\n\\nDoes anyone have a solution that *actually* satisfies the requirements?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "[@cartesPerforees](/cartesPerforees) bro that comment was posted in 2016😭"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "what are you talking about? all the top voted solutions are about the Boyer-Moore algo"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "get familiar with Moore\\'s voting algo"
                    },
                    {
                        "username": "AKR_2610",
                        "content": "Use a set to store unique elements and use a map to store the number of repetitions\\n\\nBingo..."
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "that will not be an optimised solution"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Bruh, that\\'s like the most unoptimized solution   "
                    },
                    {
                        "username": "dineshdivi377",
                        "content": "we can solve in o(1) space with Boyer - Moore algo"
                    },
                    {
                        "username": "kumar029941",
                        "content": "In Moore\\'s voting algorithm why we have taken only two elements, why not three or four."
                    },
                    {
                        "username": "t4n",
                        "content": "Is it cheating to use a dictionary to keep track of count and just return values  > math.floor(n/3)"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "yes definitely"
                    },
                    {
                        "username": "AbhimatPandey",
                        "content": "we can use the given array ...for O(1) ....\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n      int n= nums.size()/3;   int i=1, k=0 , ct=1;  \\n      \\n       sort(nums.begin(), nums.end());\\n\\n        while(i<nums.size()){\\n\\n            if((nums[i]^(nums[i-1]))==0){\\n                nums[i]=0;\\n                ct++;\\n            }\\n            else{  nums[k]=0;\\n             if(ct>n){nums[k]=nums[i-1];}\\n                nums[i-1]=0;\\n                k++;\\n                ct=1;\\n            } }\\n\\n\\n    return nums ;    \\n    }\\n};"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "you are using sort, so it will take nlogn time, this is not optimised"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This problem may be marked easy because we can use maps. But the real challange is O(1) space complexity.\\nThis problem blew my mind. 77 test case pass out of 87. When you put one condition the other test case fails. We have to be very carefull about the corner cases. This is a freeking amazing problem. Iv been sitting for like 2 hours now."
                    },
                    {
                        "username": "gangadharkr27",
                        "content": "Question \\uD83D\\uDC4C"
                    },
                    {
                        "username": "aayushdhimann",
                        "content": "why my code is failing @ [0,0,0] and working @ [1,1,1]\n\n\n`class Solution {\n  public:\n    vector<int> majorityElement(vector<int>& arr) {\n        int e1=0,count1=0, n = arr.size();\n        int e2=0,count2=0;\n        for(int i=0; i<n; i++){\n            if(count1==0 && arr[i]!=e2){\n                count1=1;\n                e1=arr[i];\n            }\n            else if(count2==0 && arr[i]!=e1){\n                count2=1;\n                e2=arr[i];\n            }\n            else if(arr[i]==e1){\n                count1++;\n            }\n            else if(arr[i]==e2){\n                count2++;\n            }\n            else{\n                count1--,count2--;\n            }\n        }\n        \n        vector<int> v;\n        count1=0, count2=0;\n\n        for(int i=0; i<n; i++){\n            if(e1==arr[i]){\n                count1++;\n            }\n            if(e2==arr[i]){\n                count2++;\n            }\n        }\n\n        int mini=(int)(n/3)+1;\n\n        if( count1>=mini) v.emplace_back(e1);\n        if( count2>=mini) v.emplace_back(e2);\n        sort(v.begin(),v.end());\n        return v;\n    }\n};`"
                    },
                    {
                        "username": "Noman62",
                        "content": "I think, this problem mark as easy problem. If anyone can not understand how can approach this problem, I will give some hints,\\n1. use a hash table and count the occurrence of the number.\\n2. then apply a condition to check the which value is greater than \\u230A n/3 \\u230B "
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "you approach is correct, but not optimised"
                    },
                    {
                        "username": "sahebs450",
                        "content": "Question asking for O(1) space complexity."
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "class Solution {\n    public List<Integer> majorityElement(int[] nums) {\n        ArrayList<Integer> majority_elements=new ArrayList<>();\n        int votes=0;\n        int candidate=nums[0];\n        Arrays.sort(nums);\n        for(int i=0;i<nums.length;i++){\n            if(votes>((nums.length)/3)){\n                if(!majority_elements.contains(candidate))\n                    majority_elements.add(candidate);\n            }\n            if(votes==0){\n                candidate=nums[i];\n                votes=1;\n            }\n            else if(nums[i] == candidate){\n                votes++;\n            }\n            else if(nums[i] != candidate){\n                candidate=nums[i];\n                votes=1;\n            }\n        }\n        if(votes>((nums.length)/3)){\n            if(!majority_elements.contains(candidate))\n                majority_elements.add(candidate);\n        }\n        return majority_elements;\n    }\n}"
                    }
                ]
            },
            {
                "id": 2067614,
                "content": [
                    {
                        "username": "eric135",
                        "content": "All the solutions I'm seeing here are either \"sort then count\" (satisfying the O(1) space constraint but not the O(n) runtime constraint) or \"count by hashmap\" (satisfying the O(n) runtime constraint but not the O(1) space constraint).\\n\\nDoes anyone have a solution that *actually* satisfies the requirements?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "[@cartesPerforees](/cartesPerforees) bro that comment was posted in 2016😭"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "what are you talking about? all the top voted solutions are about the Boyer-Moore algo"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "get familiar with Moore\\'s voting algo"
                    },
                    {
                        "username": "AKR_2610",
                        "content": "Use a set to store unique elements and use a map to store the number of repetitions\\n\\nBingo..."
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "that will not be an optimised solution"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Bruh, that\\'s like the most unoptimized solution   "
                    },
                    {
                        "username": "dineshdivi377",
                        "content": "we can solve in o(1) space with Boyer - Moore algo"
                    },
                    {
                        "username": "kumar029941",
                        "content": "In Moore\\'s voting algorithm why we have taken only two elements, why not three or four."
                    },
                    {
                        "username": "t4n",
                        "content": "Is it cheating to use a dictionary to keep track of count and just return values  > math.floor(n/3)"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "yes definitely"
                    },
                    {
                        "username": "AbhimatPandey",
                        "content": "we can use the given array ...for O(1) ....\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n      int n= nums.size()/3;   int i=1, k=0 , ct=1;  \\n      \\n       sort(nums.begin(), nums.end());\\n\\n        while(i<nums.size()){\\n\\n            if((nums[i]^(nums[i-1]))==0){\\n                nums[i]=0;\\n                ct++;\\n            }\\n            else{  nums[k]=0;\\n             if(ct>n){nums[k]=nums[i-1];}\\n                nums[i-1]=0;\\n                k++;\\n                ct=1;\\n            } }\\n\\n\\n    return nums ;    \\n    }\\n};"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "you are using sort, so it will take nlogn time, this is not optimised"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This problem may be marked easy because we can use maps. But the real challange is O(1) space complexity.\\nThis problem blew my mind. 77 test case pass out of 87. When you put one condition the other test case fails. We have to be very carefull about the corner cases. This is a freeking amazing problem. Iv been sitting for like 2 hours now."
                    },
                    {
                        "username": "gangadharkr27",
                        "content": "Question \\uD83D\\uDC4C"
                    },
                    {
                        "username": "aayushdhimann",
                        "content": "why my code is failing @ [0,0,0] and working @ [1,1,1]\n\n\n`class Solution {\n  public:\n    vector<int> majorityElement(vector<int>& arr) {\n        int e1=0,count1=0, n = arr.size();\n        int e2=0,count2=0;\n        for(int i=0; i<n; i++){\n            if(count1==0 && arr[i]!=e2){\n                count1=1;\n                e1=arr[i];\n            }\n            else if(count2==0 && arr[i]!=e1){\n                count2=1;\n                e2=arr[i];\n            }\n            else if(arr[i]==e1){\n                count1++;\n            }\n            else if(arr[i]==e2){\n                count2++;\n            }\n            else{\n                count1--,count2--;\n            }\n        }\n        \n        vector<int> v;\n        count1=0, count2=0;\n\n        for(int i=0; i<n; i++){\n            if(e1==arr[i]){\n                count1++;\n            }\n            if(e2==arr[i]){\n                count2++;\n            }\n        }\n\n        int mini=(int)(n/3)+1;\n\n        if( count1>=mini) v.emplace_back(e1);\n        if( count2>=mini) v.emplace_back(e2);\n        sort(v.begin(),v.end());\n        return v;\n    }\n};`"
                    },
                    {
                        "username": "Noman62",
                        "content": "I think, this problem mark as easy problem. If anyone can not understand how can approach this problem, I will give some hints,\\n1. use a hash table and count the occurrence of the number.\\n2. then apply a condition to check the which value is greater than \\u230A n/3 \\u230B "
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "you approach is correct, but not optimised"
                    },
                    {
                        "username": "sahebs450",
                        "content": "Question asking for O(1) space complexity."
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "class Solution {\n    public List<Integer> majorityElement(int[] nums) {\n        ArrayList<Integer> majority_elements=new ArrayList<>();\n        int votes=0;\n        int candidate=nums[0];\n        Arrays.sort(nums);\n        for(int i=0;i<nums.length;i++){\n            if(votes>((nums.length)/3)){\n                if(!majority_elements.contains(candidate))\n                    majority_elements.add(candidate);\n            }\n            if(votes==0){\n                candidate=nums[i];\n                votes=1;\n            }\n            else if(nums[i] == candidate){\n                votes++;\n            }\n            else if(nums[i] != candidate){\n                candidate=nums[i];\n                votes=1;\n            }\n        }\n        if(votes>((nums.length)/3)){\n            if(!majority_elements.contains(candidate))\n                majority_elements.add(candidate);\n        }\n        return majority_elements;\n    }\n}"
                    }
                ]
            },
            {
                "id": 2063705,
                "content": [
                    {
                        "username": "eric135",
                        "content": "All the solutions I'm seeing here are either \"sort then count\" (satisfying the O(1) space constraint but not the O(n) runtime constraint) or \"count by hashmap\" (satisfying the O(n) runtime constraint but not the O(1) space constraint).\\n\\nDoes anyone have a solution that *actually* satisfies the requirements?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "[@cartesPerforees](/cartesPerforees) bro that comment was posted in 2016😭"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "what are you talking about? all the top voted solutions are about the Boyer-Moore algo"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "get familiar with Moore\\'s voting algo"
                    },
                    {
                        "username": "AKR_2610",
                        "content": "Use a set to store unique elements and use a map to store the number of repetitions\\n\\nBingo..."
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "that will not be an optimised solution"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Bruh, that\\'s like the most unoptimized solution   "
                    },
                    {
                        "username": "dineshdivi377",
                        "content": "we can solve in o(1) space with Boyer - Moore algo"
                    },
                    {
                        "username": "kumar029941",
                        "content": "In Moore\\'s voting algorithm why we have taken only two elements, why not three or four."
                    },
                    {
                        "username": "t4n",
                        "content": "Is it cheating to use a dictionary to keep track of count and just return values  > math.floor(n/3)"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "yes definitely"
                    },
                    {
                        "username": "AbhimatPandey",
                        "content": "we can use the given array ...for O(1) ....\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n      int n= nums.size()/3;   int i=1, k=0 , ct=1;  \\n      \\n       sort(nums.begin(), nums.end());\\n\\n        while(i<nums.size()){\\n\\n            if((nums[i]^(nums[i-1]))==0){\\n                nums[i]=0;\\n                ct++;\\n            }\\n            else{  nums[k]=0;\\n             if(ct>n){nums[k]=nums[i-1];}\\n                nums[i-1]=0;\\n                k++;\\n                ct=1;\\n            } }\\n\\n\\n    return nums ;    \\n    }\\n};"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "you are using sort, so it will take nlogn time, this is not optimised"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This problem may be marked easy because we can use maps. But the real challange is O(1) space complexity.\\nThis problem blew my mind. 77 test case pass out of 87. When you put one condition the other test case fails. We have to be very carefull about the corner cases. This is a freeking amazing problem. Iv been sitting for like 2 hours now."
                    },
                    {
                        "username": "gangadharkr27",
                        "content": "Question \\uD83D\\uDC4C"
                    },
                    {
                        "username": "aayushdhimann",
                        "content": "why my code is failing @ [0,0,0] and working @ [1,1,1]\n\n\n`class Solution {\n  public:\n    vector<int> majorityElement(vector<int>& arr) {\n        int e1=0,count1=0, n = arr.size();\n        int e2=0,count2=0;\n        for(int i=0; i<n; i++){\n            if(count1==0 && arr[i]!=e2){\n                count1=1;\n                e1=arr[i];\n            }\n            else if(count2==0 && arr[i]!=e1){\n                count2=1;\n                e2=arr[i];\n            }\n            else if(arr[i]==e1){\n                count1++;\n            }\n            else if(arr[i]==e2){\n                count2++;\n            }\n            else{\n                count1--,count2--;\n            }\n        }\n        \n        vector<int> v;\n        count1=0, count2=0;\n\n        for(int i=0; i<n; i++){\n            if(e1==arr[i]){\n                count1++;\n            }\n            if(e2==arr[i]){\n                count2++;\n            }\n        }\n\n        int mini=(int)(n/3)+1;\n\n        if( count1>=mini) v.emplace_back(e1);\n        if( count2>=mini) v.emplace_back(e2);\n        sort(v.begin(),v.end());\n        return v;\n    }\n};`"
                    },
                    {
                        "username": "Noman62",
                        "content": "I think, this problem mark as easy problem. If anyone can not understand how can approach this problem, I will give some hints,\\n1. use a hash table and count the occurrence of the number.\\n2. then apply a condition to check the which value is greater than \\u230A n/3 \\u230B "
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "you approach is correct, but not optimised"
                    },
                    {
                        "username": "sahebs450",
                        "content": "Question asking for O(1) space complexity."
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "class Solution {\n    public List<Integer> majorityElement(int[] nums) {\n        ArrayList<Integer> majority_elements=new ArrayList<>();\n        int votes=0;\n        int candidate=nums[0];\n        Arrays.sort(nums);\n        for(int i=0;i<nums.length;i++){\n            if(votes>((nums.length)/3)){\n                if(!majority_elements.contains(candidate))\n                    majority_elements.add(candidate);\n            }\n            if(votes==0){\n                candidate=nums[i];\n                votes=1;\n            }\n            else if(nums[i] == candidate){\n                votes++;\n            }\n            else if(nums[i] != candidate){\n                candidate=nums[i];\n                votes=1;\n            }\n        }\n        if(votes>((nums.length)/3)){\n            if(!majority_elements.contains(candidate))\n                majority_elements.add(candidate);\n        }\n        return majority_elements;\n    }\n}"
                    }
                ]
            },
            {
                "id": 2045763,
                "content": [
                    {
                        "username": "eric135",
                        "content": "All the solutions I'm seeing here are either \"sort then count\" (satisfying the O(1) space constraint but not the O(n) runtime constraint) or \"count by hashmap\" (satisfying the O(n) runtime constraint but not the O(1) space constraint).\\n\\nDoes anyone have a solution that *actually* satisfies the requirements?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "[@cartesPerforees](/cartesPerforees) bro that comment was posted in 2016😭"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "what are you talking about? all the top voted solutions are about the Boyer-Moore algo"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "get familiar with Moore\\'s voting algo"
                    },
                    {
                        "username": "AKR_2610",
                        "content": "Use a set to store unique elements and use a map to store the number of repetitions\\n\\nBingo..."
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "that will not be an optimised solution"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Bruh, that\\'s like the most unoptimized solution   "
                    },
                    {
                        "username": "dineshdivi377",
                        "content": "we can solve in o(1) space with Boyer - Moore algo"
                    },
                    {
                        "username": "kumar029941",
                        "content": "In Moore\\'s voting algorithm why we have taken only two elements, why not three or four."
                    },
                    {
                        "username": "t4n",
                        "content": "Is it cheating to use a dictionary to keep track of count and just return values  > math.floor(n/3)"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "yes definitely"
                    },
                    {
                        "username": "AbhimatPandey",
                        "content": "we can use the given array ...for O(1) ....\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n      int n= nums.size()/3;   int i=1, k=0 , ct=1;  \\n      \\n       sort(nums.begin(), nums.end());\\n\\n        while(i<nums.size()){\\n\\n            if((nums[i]^(nums[i-1]))==0){\\n                nums[i]=0;\\n                ct++;\\n            }\\n            else{  nums[k]=0;\\n             if(ct>n){nums[k]=nums[i-1];}\\n                nums[i-1]=0;\\n                k++;\\n                ct=1;\\n            } }\\n\\n\\n    return nums ;    \\n    }\\n};"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "you are using sort, so it will take nlogn time, this is not optimised"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This problem may be marked easy because we can use maps. But the real challange is O(1) space complexity.\\nThis problem blew my mind. 77 test case pass out of 87. When you put one condition the other test case fails. We have to be very carefull about the corner cases. This is a freeking amazing problem. Iv been sitting for like 2 hours now."
                    },
                    {
                        "username": "gangadharkr27",
                        "content": "Question \\uD83D\\uDC4C"
                    },
                    {
                        "username": "aayushdhimann",
                        "content": "why my code is failing @ [0,0,0] and working @ [1,1,1]\n\n\n`class Solution {\n  public:\n    vector<int> majorityElement(vector<int>& arr) {\n        int e1=0,count1=0, n = arr.size();\n        int e2=0,count2=0;\n        for(int i=0; i<n; i++){\n            if(count1==0 && arr[i]!=e2){\n                count1=1;\n                e1=arr[i];\n            }\n            else if(count2==0 && arr[i]!=e1){\n                count2=1;\n                e2=arr[i];\n            }\n            else if(arr[i]==e1){\n                count1++;\n            }\n            else if(arr[i]==e2){\n                count2++;\n            }\n            else{\n                count1--,count2--;\n            }\n        }\n        \n        vector<int> v;\n        count1=0, count2=0;\n\n        for(int i=0; i<n; i++){\n            if(e1==arr[i]){\n                count1++;\n            }\n            if(e2==arr[i]){\n                count2++;\n            }\n        }\n\n        int mini=(int)(n/3)+1;\n\n        if( count1>=mini) v.emplace_back(e1);\n        if( count2>=mini) v.emplace_back(e2);\n        sort(v.begin(),v.end());\n        return v;\n    }\n};`"
                    },
                    {
                        "username": "Noman62",
                        "content": "I think, this problem mark as easy problem. If anyone can not understand how can approach this problem, I will give some hints,\\n1. use a hash table and count the occurrence of the number.\\n2. then apply a condition to check the which value is greater than \\u230A n/3 \\u230B "
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "you approach is correct, but not optimised"
                    },
                    {
                        "username": "sahebs450",
                        "content": "Question asking for O(1) space complexity."
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "class Solution {\n    public List<Integer> majorityElement(int[] nums) {\n        ArrayList<Integer> majority_elements=new ArrayList<>();\n        int votes=0;\n        int candidate=nums[0];\n        Arrays.sort(nums);\n        for(int i=0;i<nums.length;i++){\n            if(votes>((nums.length)/3)){\n                if(!majority_elements.contains(candidate))\n                    majority_elements.add(candidate);\n            }\n            if(votes==0){\n                candidate=nums[i];\n                votes=1;\n            }\n            else if(nums[i] == candidate){\n                votes++;\n            }\n            else if(nums[i] != candidate){\n                candidate=nums[i];\n                votes=1;\n            }\n        }\n        if(votes>((nums.length)/3)){\n            if(!majority_elements.contains(candidate))\n                majority_elements.add(candidate);\n        }\n        return majority_elements;\n    }\n}"
                    }
                ]
            },
            {
                "id": 2012089,
                "content": [
                    {
                        "username": "eric135",
                        "content": "All the solutions I'm seeing here are either \"sort then count\" (satisfying the O(1) space constraint but not the O(n) runtime constraint) or \"count by hashmap\" (satisfying the O(n) runtime constraint but not the O(1) space constraint).\\n\\nDoes anyone have a solution that *actually* satisfies the requirements?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "[@cartesPerforees](/cartesPerforees) bro that comment was posted in 2016😭"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "what are you talking about? all the top voted solutions are about the Boyer-Moore algo"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "get familiar with Moore\\'s voting algo"
                    },
                    {
                        "username": "AKR_2610",
                        "content": "Use a set to store unique elements and use a map to store the number of repetitions\\n\\nBingo..."
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "that will not be an optimised solution"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Bruh, that\\'s like the most unoptimized solution   "
                    },
                    {
                        "username": "dineshdivi377",
                        "content": "we can solve in o(1) space with Boyer - Moore algo"
                    },
                    {
                        "username": "kumar029941",
                        "content": "In Moore\\'s voting algorithm why we have taken only two elements, why not three or four."
                    },
                    {
                        "username": "t4n",
                        "content": "Is it cheating to use a dictionary to keep track of count and just return values  > math.floor(n/3)"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "yes definitely"
                    },
                    {
                        "username": "AbhimatPandey",
                        "content": "we can use the given array ...for O(1) ....\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n      int n= nums.size()/3;   int i=1, k=0 , ct=1;  \\n      \\n       sort(nums.begin(), nums.end());\\n\\n        while(i<nums.size()){\\n\\n            if((nums[i]^(nums[i-1]))==0){\\n                nums[i]=0;\\n                ct++;\\n            }\\n            else{  nums[k]=0;\\n             if(ct>n){nums[k]=nums[i-1];}\\n                nums[i-1]=0;\\n                k++;\\n                ct=1;\\n            } }\\n\\n\\n    return nums ;    \\n    }\\n};"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "you are using sort, so it will take nlogn time, this is not optimised"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This problem may be marked easy because we can use maps. But the real challange is O(1) space complexity.\\nThis problem blew my mind. 77 test case pass out of 87. When you put one condition the other test case fails. We have to be very carefull about the corner cases. This is a freeking amazing problem. Iv been sitting for like 2 hours now."
                    },
                    {
                        "username": "gangadharkr27",
                        "content": "Question \\uD83D\\uDC4C"
                    },
                    {
                        "username": "aayushdhimann",
                        "content": "why my code is failing @ [0,0,0] and working @ [1,1,1]\n\n\n`class Solution {\n  public:\n    vector<int> majorityElement(vector<int>& arr) {\n        int e1=0,count1=0, n = arr.size();\n        int e2=0,count2=0;\n        for(int i=0; i<n; i++){\n            if(count1==0 && arr[i]!=e2){\n                count1=1;\n                e1=arr[i];\n            }\n            else if(count2==0 && arr[i]!=e1){\n                count2=1;\n                e2=arr[i];\n            }\n            else if(arr[i]==e1){\n                count1++;\n            }\n            else if(arr[i]==e2){\n                count2++;\n            }\n            else{\n                count1--,count2--;\n            }\n        }\n        \n        vector<int> v;\n        count1=0, count2=0;\n\n        for(int i=0; i<n; i++){\n            if(e1==arr[i]){\n                count1++;\n            }\n            if(e2==arr[i]){\n                count2++;\n            }\n        }\n\n        int mini=(int)(n/3)+1;\n\n        if( count1>=mini) v.emplace_back(e1);\n        if( count2>=mini) v.emplace_back(e2);\n        sort(v.begin(),v.end());\n        return v;\n    }\n};`"
                    },
                    {
                        "username": "Noman62",
                        "content": "I think, this problem mark as easy problem. If anyone can not understand how can approach this problem, I will give some hints,\\n1. use a hash table and count the occurrence of the number.\\n2. then apply a condition to check the which value is greater than \\u230A n/3 \\u230B "
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "you approach is correct, but not optimised"
                    },
                    {
                        "username": "sahebs450",
                        "content": "Question asking for O(1) space complexity."
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "class Solution {\n    public List<Integer> majorityElement(int[] nums) {\n        ArrayList<Integer> majority_elements=new ArrayList<>();\n        int votes=0;\n        int candidate=nums[0];\n        Arrays.sort(nums);\n        for(int i=0;i<nums.length;i++){\n            if(votes>((nums.length)/3)){\n                if(!majority_elements.contains(candidate))\n                    majority_elements.add(candidate);\n            }\n            if(votes==0){\n                candidate=nums[i];\n                votes=1;\n            }\n            else if(nums[i] == candidate){\n                votes++;\n            }\n            else if(nums[i] != candidate){\n                candidate=nums[i];\n                votes=1;\n            }\n        }\n        if(votes>((nums.length)/3)){\n            if(!majority_elements.contains(candidate))\n                majority_elements.add(candidate);\n        }\n        return majority_elements;\n    }\n}"
                    }
                ]
            },
            {
                "id": 1998850,
                "content": [
                    {
                        "username": "eric135",
                        "content": "All the solutions I'm seeing here are either \"sort then count\" (satisfying the O(1) space constraint but not the O(n) runtime constraint) or \"count by hashmap\" (satisfying the O(n) runtime constraint but not the O(1) space constraint).\\n\\nDoes anyone have a solution that *actually* satisfies the requirements?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "[@cartesPerforees](/cartesPerforees) bro that comment was posted in 2016😭"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "what are you talking about? all the top voted solutions are about the Boyer-Moore algo"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "get familiar with Moore\\'s voting algo"
                    },
                    {
                        "username": "AKR_2610",
                        "content": "Use a set to store unique elements and use a map to store the number of repetitions\\n\\nBingo..."
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "that will not be an optimised solution"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Bruh, that\\'s like the most unoptimized solution   "
                    },
                    {
                        "username": "dineshdivi377",
                        "content": "we can solve in o(1) space with Boyer - Moore algo"
                    },
                    {
                        "username": "kumar029941",
                        "content": "In Moore\\'s voting algorithm why we have taken only two elements, why not three or four."
                    },
                    {
                        "username": "t4n",
                        "content": "Is it cheating to use a dictionary to keep track of count and just return values  > math.floor(n/3)"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "yes definitely"
                    },
                    {
                        "username": "AbhimatPandey",
                        "content": "we can use the given array ...for O(1) ....\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n      int n= nums.size()/3;   int i=1, k=0 , ct=1;  \\n      \\n       sort(nums.begin(), nums.end());\\n\\n        while(i<nums.size()){\\n\\n            if((nums[i]^(nums[i-1]))==0){\\n                nums[i]=0;\\n                ct++;\\n            }\\n            else{  nums[k]=0;\\n             if(ct>n){nums[k]=nums[i-1];}\\n                nums[i-1]=0;\\n                k++;\\n                ct=1;\\n            } }\\n\\n\\n    return nums ;    \\n    }\\n};"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "you are using sort, so it will take nlogn time, this is not optimised"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This problem may be marked easy because we can use maps. But the real challange is O(1) space complexity.\\nThis problem blew my mind. 77 test case pass out of 87. When you put one condition the other test case fails. We have to be very carefull about the corner cases. This is a freeking amazing problem. Iv been sitting for like 2 hours now."
                    },
                    {
                        "username": "gangadharkr27",
                        "content": "Question \\uD83D\\uDC4C"
                    },
                    {
                        "username": "aayushdhimann",
                        "content": "why my code is failing @ [0,0,0] and working @ [1,1,1]\n\n\n`class Solution {\n  public:\n    vector<int> majorityElement(vector<int>& arr) {\n        int e1=0,count1=0, n = arr.size();\n        int e2=0,count2=0;\n        for(int i=0; i<n; i++){\n            if(count1==0 && arr[i]!=e2){\n                count1=1;\n                e1=arr[i];\n            }\n            else if(count2==0 && arr[i]!=e1){\n                count2=1;\n                e2=arr[i];\n            }\n            else if(arr[i]==e1){\n                count1++;\n            }\n            else if(arr[i]==e2){\n                count2++;\n            }\n            else{\n                count1--,count2--;\n            }\n        }\n        \n        vector<int> v;\n        count1=0, count2=0;\n\n        for(int i=0; i<n; i++){\n            if(e1==arr[i]){\n                count1++;\n            }\n            if(e2==arr[i]){\n                count2++;\n            }\n        }\n\n        int mini=(int)(n/3)+1;\n\n        if( count1>=mini) v.emplace_back(e1);\n        if( count2>=mini) v.emplace_back(e2);\n        sort(v.begin(),v.end());\n        return v;\n    }\n};`"
                    },
                    {
                        "username": "Noman62",
                        "content": "I think, this problem mark as easy problem. If anyone can not understand how can approach this problem, I will give some hints,\\n1. use a hash table and count the occurrence of the number.\\n2. then apply a condition to check the which value is greater than \\u230A n/3 \\u230B "
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "you approach is correct, but not optimised"
                    },
                    {
                        "username": "sahebs450",
                        "content": "Question asking for O(1) space complexity."
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "class Solution {\n    public List<Integer> majorityElement(int[] nums) {\n        ArrayList<Integer> majority_elements=new ArrayList<>();\n        int votes=0;\n        int candidate=nums[0];\n        Arrays.sort(nums);\n        for(int i=0;i<nums.length;i++){\n            if(votes>((nums.length)/3)){\n                if(!majority_elements.contains(candidate))\n                    majority_elements.add(candidate);\n            }\n            if(votes==0){\n                candidate=nums[i];\n                votes=1;\n            }\n            else if(nums[i] == candidate){\n                votes++;\n            }\n            else if(nums[i] != candidate){\n                candidate=nums[i];\n                votes=1;\n            }\n        }\n        if(votes>((nums.length)/3)){\n            if(!majority_elements.contains(candidate))\n                majority_elements.add(candidate);\n        }\n        return majority_elements;\n    }\n}"
                    }
                ]
            },
            {
                "id": 1991343,
                "content": [
                    {
                        "username": "eric135",
                        "content": "All the solutions I'm seeing here are either \"sort then count\" (satisfying the O(1) space constraint but not the O(n) runtime constraint) or \"count by hashmap\" (satisfying the O(n) runtime constraint but not the O(1) space constraint).\\n\\nDoes anyone have a solution that *actually* satisfies the requirements?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "[@cartesPerforees](/cartesPerforees) bro that comment was posted in 2016😭"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "what are you talking about? all the top voted solutions are about the Boyer-Moore algo"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "get familiar with Moore\\'s voting algo"
                    },
                    {
                        "username": "AKR_2610",
                        "content": "Use a set to store unique elements and use a map to store the number of repetitions\\n\\nBingo..."
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "that will not be an optimised solution"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Bruh, that\\'s like the most unoptimized solution   "
                    },
                    {
                        "username": "dineshdivi377",
                        "content": "we can solve in o(1) space with Boyer - Moore algo"
                    },
                    {
                        "username": "kumar029941",
                        "content": "In Moore\\'s voting algorithm why we have taken only two elements, why not three or four."
                    },
                    {
                        "username": "t4n",
                        "content": "Is it cheating to use a dictionary to keep track of count and just return values  > math.floor(n/3)"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "yes definitely"
                    },
                    {
                        "username": "AbhimatPandey",
                        "content": "we can use the given array ...for O(1) ....\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n      int n= nums.size()/3;   int i=1, k=0 , ct=1;  \\n      \\n       sort(nums.begin(), nums.end());\\n\\n        while(i<nums.size()){\\n\\n            if((nums[i]^(nums[i-1]))==0){\\n                nums[i]=0;\\n                ct++;\\n            }\\n            else{  nums[k]=0;\\n             if(ct>n){nums[k]=nums[i-1];}\\n                nums[i-1]=0;\\n                k++;\\n                ct=1;\\n            } }\\n\\n\\n    return nums ;    \\n    }\\n};"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "you are using sort, so it will take nlogn time, this is not optimised"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This problem may be marked easy because we can use maps. But the real challange is O(1) space complexity.\\nThis problem blew my mind. 77 test case pass out of 87. When you put one condition the other test case fails. We have to be very carefull about the corner cases. This is a freeking amazing problem. Iv been sitting for like 2 hours now."
                    },
                    {
                        "username": "gangadharkr27",
                        "content": "Question \\uD83D\\uDC4C"
                    },
                    {
                        "username": "aayushdhimann",
                        "content": "why my code is failing @ [0,0,0] and working @ [1,1,1]\n\n\n`class Solution {\n  public:\n    vector<int> majorityElement(vector<int>& arr) {\n        int e1=0,count1=0, n = arr.size();\n        int e2=0,count2=0;\n        for(int i=0; i<n; i++){\n            if(count1==0 && arr[i]!=e2){\n                count1=1;\n                e1=arr[i];\n            }\n            else if(count2==0 && arr[i]!=e1){\n                count2=1;\n                e2=arr[i];\n            }\n            else if(arr[i]==e1){\n                count1++;\n            }\n            else if(arr[i]==e2){\n                count2++;\n            }\n            else{\n                count1--,count2--;\n            }\n        }\n        \n        vector<int> v;\n        count1=0, count2=0;\n\n        for(int i=0; i<n; i++){\n            if(e1==arr[i]){\n                count1++;\n            }\n            if(e2==arr[i]){\n                count2++;\n            }\n        }\n\n        int mini=(int)(n/3)+1;\n\n        if( count1>=mini) v.emplace_back(e1);\n        if( count2>=mini) v.emplace_back(e2);\n        sort(v.begin(),v.end());\n        return v;\n    }\n};`"
                    },
                    {
                        "username": "Noman62",
                        "content": "I think, this problem mark as easy problem. If anyone can not understand how can approach this problem, I will give some hints,\\n1. use a hash table and count the occurrence of the number.\\n2. then apply a condition to check the which value is greater than \\u230A n/3 \\u230B "
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "you approach is correct, but not optimised"
                    },
                    {
                        "username": "sahebs450",
                        "content": "Question asking for O(1) space complexity."
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "class Solution {\n    public List<Integer> majorityElement(int[] nums) {\n        ArrayList<Integer> majority_elements=new ArrayList<>();\n        int votes=0;\n        int candidate=nums[0];\n        Arrays.sort(nums);\n        for(int i=0;i<nums.length;i++){\n            if(votes>((nums.length)/3)){\n                if(!majority_elements.contains(candidate))\n                    majority_elements.add(candidate);\n            }\n            if(votes==0){\n                candidate=nums[i];\n                votes=1;\n            }\n            else if(nums[i] == candidate){\n                votes++;\n            }\n            else if(nums[i] != candidate){\n                candidate=nums[i];\n                votes=1;\n            }\n        }\n        if(votes>((nums.length)/3)){\n            if(!majority_elements.contains(candidate))\n                majority_elements.add(candidate);\n        }\n        return majority_elements;\n    }\n}"
                    }
                ]
            },
            {
                "id": 1969039,
                "content": [
                    {
                        "username": "eric135",
                        "content": "All the solutions I'm seeing here are either \"sort then count\" (satisfying the O(1) space constraint but not the O(n) runtime constraint) or \"count by hashmap\" (satisfying the O(n) runtime constraint but not the O(1) space constraint).\\n\\nDoes anyone have a solution that *actually* satisfies the requirements?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "[@cartesPerforees](/cartesPerforees) bro that comment was posted in 2016😭"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "what are you talking about? all the top voted solutions are about the Boyer-Moore algo"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "get familiar with Moore\\'s voting algo"
                    },
                    {
                        "username": "AKR_2610",
                        "content": "Use a set to store unique elements and use a map to store the number of repetitions\\n\\nBingo..."
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "that will not be an optimised solution"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Bruh, that\\'s like the most unoptimized solution   "
                    },
                    {
                        "username": "dineshdivi377",
                        "content": "we can solve in o(1) space with Boyer - Moore algo"
                    },
                    {
                        "username": "kumar029941",
                        "content": "In Moore\\'s voting algorithm why we have taken only two elements, why not three or four."
                    },
                    {
                        "username": "t4n",
                        "content": "Is it cheating to use a dictionary to keep track of count and just return values  > math.floor(n/3)"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "yes definitely"
                    },
                    {
                        "username": "AbhimatPandey",
                        "content": "we can use the given array ...for O(1) ....\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n      int n= nums.size()/3;   int i=1, k=0 , ct=1;  \\n      \\n       sort(nums.begin(), nums.end());\\n\\n        while(i<nums.size()){\\n\\n            if((nums[i]^(nums[i-1]))==0){\\n                nums[i]=0;\\n                ct++;\\n            }\\n            else{  nums[k]=0;\\n             if(ct>n){nums[k]=nums[i-1];}\\n                nums[i-1]=0;\\n                k++;\\n                ct=1;\\n            } }\\n\\n\\n    return nums ;    \\n    }\\n};"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "you are using sort, so it will take nlogn time, this is not optimised"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This problem may be marked easy because we can use maps. But the real challange is O(1) space complexity.\\nThis problem blew my mind. 77 test case pass out of 87. When you put one condition the other test case fails. We have to be very carefull about the corner cases. This is a freeking amazing problem. Iv been sitting for like 2 hours now."
                    },
                    {
                        "username": "gangadharkr27",
                        "content": "Question \\uD83D\\uDC4C"
                    },
                    {
                        "username": "aayushdhimann",
                        "content": "why my code is failing @ [0,0,0] and working @ [1,1,1]\n\n\n`class Solution {\n  public:\n    vector<int> majorityElement(vector<int>& arr) {\n        int e1=0,count1=0, n = arr.size();\n        int e2=0,count2=0;\n        for(int i=0; i<n; i++){\n            if(count1==0 && arr[i]!=e2){\n                count1=1;\n                e1=arr[i];\n            }\n            else if(count2==0 && arr[i]!=e1){\n                count2=1;\n                e2=arr[i];\n            }\n            else if(arr[i]==e1){\n                count1++;\n            }\n            else if(arr[i]==e2){\n                count2++;\n            }\n            else{\n                count1--,count2--;\n            }\n        }\n        \n        vector<int> v;\n        count1=0, count2=0;\n\n        for(int i=0; i<n; i++){\n            if(e1==arr[i]){\n                count1++;\n            }\n            if(e2==arr[i]){\n                count2++;\n            }\n        }\n\n        int mini=(int)(n/3)+1;\n\n        if( count1>=mini) v.emplace_back(e1);\n        if( count2>=mini) v.emplace_back(e2);\n        sort(v.begin(),v.end());\n        return v;\n    }\n};`"
                    },
                    {
                        "username": "Noman62",
                        "content": "I think, this problem mark as easy problem. If anyone can not understand how can approach this problem, I will give some hints,\\n1. use a hash table and count the occurrence of the number.\\n2. then apply a condition to check the which value is greater than \\u230A n/3 \\u230B "
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "you approach is correct, but not optimised"
                    },
                    {
                        "username": "sahebs450",
                        "content": "Question asking for O(1) space complexity."
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "class Solution {\n    public List<Integer> majorityElement(int[] nums) {\n        ArrayList<Integer> majority_elements=new ArrayList<>();\n        int votes=0;\n        int candidate=nums[0];\n        Arrays.sort(nums);\n        for(int i=0;i<nums.length;i++){\n            if(votes>((nums.length)/3)){\n                if(!majority_elements.contains(candidate))\n                    majority_elements.add(candidate);\n            }\n            if(votes==0){\n                candidate=nums[i];\n                votes=1;\n            }\n            else if(nums[i] == candidate){\n                votes++;\n            }\n            else if(nums[i] != candidate){\n                candidate=nums[i];\n                votes=1;\n            }\n        }\n        if(votes>((nums.length)/3)){\n            if(!majority_elements.contains(candidate))\n                majority_elements.add(candidate);\n        }\n        return majority_elements;\n    }\n}"
                    }
                ]
            },
            {
                "id": 1964921,
                "content": [
                    {
                        "username": "eric135",
                        "content": "All the solutions I'm seeing here are either \"sort then count\" (satisfying the O(1) space constraint but not the O(n) runtime constraint) or \"count by hashmap\" (satisfying the O(n) runtime constraint but not the O(1) space constraint).\\n\\nDoes anyone have a solution that *actually* satisfies the requirements?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "[@cartesPerforees](/cartesPerforees) bro that comment was posted in 2016😭"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "what are you talking about? all the top voted solutions are about the Boyer-Moore algo"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "get familiar with Moore\\'s voting algo"
                    },
                    {
                        "username": "AKR_2610",
                        "content": "Use a set to store unique elements and use a map to store the number of repetitions\\n\\nBingo..."
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "that will not be an optimised solution"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Bruh, that\\'s like the most unoptimized solution   "
                    },
                    {
                        "username": "dineshdivi377",
                        "content": "we can solve in o(1) space with Boyer - Moore algo"
                    },
                    {
                        "username": "kumar029941",
                        "content": "In Moore\\'s voting algorithm why we have taken only two elements, why not three or four."
                    },
                    {
                        "username": "t4n",
                        "content": "Is it cheating to use a dictionary to keep track of count and just return values  > math.floor(n/3)"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "yes definitely"
                    },
                    {
                        "username": "AbhimatPandey",
                        "content": "we can use the given array ...for O(1) ....\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n      int n= nums.size()/3;   int i=1, k=0 , ct=1;  \\n      \\n       sort(nums.begin(), nums.end());\\n\\n        while(i<nums.size()){\\n\\n            if((nums[i]^(nums[i-1]))==0){\\n                nums[i]=0;\\n                ct++;\\n            }\\n            else{  nums[k]=0;\\n             if(ct>n){nums[k]=nums[i-1];}\\n                nums[i-1]=0;\\n                k++;\\n                ct=1;\\n            } }\\n\\n\\n    return nums ;    \\n    }\\n};"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "you are using sort, so it will take nlogn time, this is not optimised"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This problem may be marked easy because we can use maps. But the real challange is O(1) space complexity.\\nThis problem blew my mind. 77 test case pass out of 87. When you put one condition the other test case fails. We have to be very carefull about the corner cases. This is a freeking amazing problem. Iv been sitting for like 2 hours now."
                    },
                    {
                        "username": "gangadharkr27",
                        "content": "Question \\uD83D\\uDC4C"
                    },
                    {
                        "username": "aayushdhimann",
                        "content": "why my code is failing @ [0,0,0] and working @ [1,1,1]\n\n\n`class Solution {\n  public:\n    vector<int> majorityElement(vector<int>& arr) {\n        int e1=0,count1=0, n = arr.size();\n        int e2=0,count2=0;\n        for(int i=0; i<n; i++){\n            if(count1==0 && arr[i]!=e2){\n                count1=1;\n                e1=arr[i];\n            }\n            else if(count2==0 && arr[i]!=e1){\n                count2=1;\n                e2=arr[i];\n            }\n            else if(arr[i]==e1){\n                count1++;\n            }\n            else if(arr[i]==e2){\n                count2++;\n            }\n            else{\n                count1--,count2--;\n            }\n        }\n        \n        vector<int> v;\n        count1=0, count2=0;\n\n        for(int i=0; i<n; i++){\n            if(e1==arr[i]){\n                count1++;\n            }\n            if(e2==arr[i]){\n                count2++;\n            }\n        }\n\n        int mini=(int)(n/3)+1;\n\n        if( count1>=mini) v.emplace_back(e1);\n        if( count2>=mini) v.emplace_back(e2);\n        sort(v.begin(),v.end());\n        return v;\n    }\n};`"
                    },
                    {
                        "username": "Noman62",
                        "content": "I think, this problem mark as easy problem. If anyone can not understand how can approach this problem, I will give some hints,\\n1. use a hash table and count the occurrence of the number.\\n2. then apply a condition to check the which value is greater than \\u230A n/3 \\u230B "
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "you approach is correct, but not optimised"
                    },
                    {
                        "username": "sahebs450",
                        "content": "Question asking for O(1) space complexity."
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "class Solution {\n    public List<Integer> majorityElement(int[] nums) {\n        ArrayList<Integer> majority_elements=new ArrayList<>();\n        int votes=0;\n        int candidate=nums[0];\n        Arrays.sort(nums);\n        for(int i=0;i<nums.length;i++){\n            if(votes>((nums.length)/3)){\n                if(!majority_elements.contains(candidate))\n                    majority_elements.add(candidate);\n            }\n            if(votes==0){\n                candidate=nums[i];\n                votes=1;\n            }\n            else if(nums[i] == candidate){\n                votes++;\n            }\n            else if(nums[i] != candidate){\n                candidate=nums[i];\n                votes=1;\n            }\n        }\n        if(votes>((nums.length)/3)){\n            if(!majority_elements.contains(candidate))\n                majority_elements.add(candidate);\n        }\n        return majority_elements;\n    }\n}"
                    }
                ]
            }
        ]
    },
    {
        "title": "Longest Increasing Path in a Matrix",
        "question_content": "<p>Given an <code>m x n</code> integers <code>matrix</code>, return <em>the length of the longest increasing path in </em><code>matrix</code>.</p>\n\n<p>From each cell, you can either move in four directions: left, right, up, or down. You <strong>may not</strong> move <strong>diagonally</strong> or move <strong>outside the boundary</strong> (i.e., wrap-around is not allowed).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/05/grid1.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[9,9,4],[6,6,8],[2,1,1]]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The longest increasing path is <code>[1, 2, 6, 9]</code>.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/27/tmp-grid.jpg\" style=\"width: 253px; height: 253px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[3,4,5],[3,2,6],[2,2,1]]\n<strong>Output:</strong> 4\n<strong>Explanation: </strong>The longest increasing path is <code>[3, 4, 5, 6]</code>. Moving diagonally is not allowed.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> matrix = [[1]]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>0 &lt;= matrix[i][j] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 78308,
                "title": "15ms-concise-java-solution",
                "content": "To get max length of increasing sequences:\\n\\n 1. Do `DFS` from every cell\\n 2. Compare every 4 direction and skip cells that are out of boundary or smaller\\n 3. Get matrix `max` from every cell's `max`\\n 4. Use `matrix[x][y] <= matrix[i][j]` so we don't need a `visited[m][n]` array\\n 4. The key is to `cache` the distance because it's highly possible to revisit a cell\\n\\nHope it helps!\\n\\n    public static final int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    \\n    public int longestIncreasingPath(int[][] matrix) {\\n        if(matrix.length == 0) return 0;\\n        int m = matrix.length, n = matrix[0].length;\\n        int[][] cache = new int[m][n];\\n        int max = 1;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                int len = dfs(matrix, i, j, m, n, cache);\\n                max = Math.max(max, len);\\n            }\\n        }   \\n        return max;\\n    }\\n    \\n    public int dfs(int[][] matrix, int i, int j, int m, int n, int[][] cache) {\\n        if(cache[i][j] != 0) return cache[i][j];\\n        int max = 1;\\n        for(int[] dir: dirs) {\\n            int x = i + dir[0], y = j + dir[1];\\n            if(x < 0 || x >= m || y < 0 || y >= n || matrix[x][y] <= matrix[i][j]) continue;\\n            int len = 1 + dfs(matrix, x, y, m, n, cache);\\n            max = Math.max(max, len);\\n        }\\n        cache[i][j] = max;\\n        return max;\\n    }",
                "solutionTags": [],
                "code": "To get max length of increasing sequences:\\n\\n 1. Do `DFS` from every cell\\n 2. Compare every 4 direction and skip cells that are out of boundary or smaller\\n 3. Get matrix `max` from every cell's `max`\\n 4. Use `matrix[x][y] <= matrix[i][j]` so we don't need a `visited[m][n]` array\\n 4. The key is to `cache` the distance because it's highly possible to revisit a cell\\n\\nHope it helps!\\n\\n    public static final int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    \\n    public int longestIncreasingPath(int[][] matrix) {\\n        if(matrix.length == 0) return 0;\\n        int m = matrix.length, n = matrix[0].length;\\n        int[][] cache = new int[m][n];\\n        int max = 1;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                int len = dfs(matrix, i, j, m, n, cache);\\n                max = Math.max(max, len);\\n            }\\n        }   \\n        return max;\\n    }\\n    \\n    public int dfs(int[][] matrix, int i, int j, int m, int n, int[][] cache) {\\n        if(cache[i][j] != 0) return cache[i][j];\\n        int max = 1;\\n        for(int[] dir: dirs) {\\n            int x = i + dir[0], y = j + dir[1];\\n            if(x < 0 || x >= m || y < 0 || y >= n || matrix[x][y] <= matrix[i][j]) continue;\\n            int len = 1 + dfs(matrix, x, y, m, n, cache);\\n            max = Math.max(max, len);\\n        }\\n        cache[i][j] = max;\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 288520,
                "title": "longest-path-in-dag",
                "content": "We regard \\n* a cell in the matrix as a node,\\n* a directed edge from node x to node y if x and y are adjacent and x\\'s value  < y\\'s value\\n\\nThen a graph is formed.\\n\\nNo cycles can exist in the graph, i.e. a DAG is formed.\\n\\nThe problem becomes to get the longest path in the DAG.\\n\\nTopological sort can iterate the vertices of a DAG in the linear ordering.\\n\\nUsing Kahn\\'s algorithm(BFS) to implement topological sort while counting the levels can give us the longest chain of nodes in the DAG.\\n\\n```\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        rows = len(matrix)\\n        if rows == 0:\\n            return 0\\n        \\n        cols = len(matrix[0])\\n        indegree = [[0 for x in range(cols)] for y in range(rows)] \\n        directions = [(0, -1), (0, 1), (1, 0), (-1, 0)]\\n        \\n        for x in range(rows):\\n            for y in range(cols):\\n                for direction in directions:\\n                    nx, ny = x + direction[0], y + direction[1]\\n                    if nx >= 0 and ny >= 0 and nx < rows and ny < cols:\\n                        if matrix[nx][ny] < matrix[x][y]:\\n                            indegree[x][y] += 1\\n                            \\n        queue = []\\n        for x in range(rows):\\n            for y in range(cols):\\n                if indegree[x][y] == 0:\\n                    queue.append((x, y))\\n    \\n        path_len = 0\\n        while queue:\\n            sz = len(queue)\\n            for i in range(sz):\\n                x, y = queue.pop(0)\\n                for direction in directions:\\n                    nx, ny = x + direction[0], y + direction[1]\\n                    if nx >= 0 and ny >= 0 and nx < rows and ny < cols:\\n                        if matrix[nx][ny] > matrix[x][y]:\\n                            indegree[nx][ny] -= 1\\n                            if indegree[nx][ny] == 0:\\n                                queue.append((nx, ny))\\n            path_len += 1\\n        return path_len \\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        rows = len(matrix)\\n        if rows == 0:\\n            return 0\\n        \\n        cols = len(matrix[0])\\n        indegree = [[0 for x in range(cols)] for y in range(rows)] \\n        directions = [(0, -1), (0, 1), (1, 0), (-1, 0)]\\n        \\n        for x in range(rows):\\n            for y in range(cols):\\n                for direction in directions:\\n                    nx, ny = x + direction[0], y + direction[1]\\n                    if nx >= 0 and ny >= 0 and nx < rows and ny < cols:\\n                        if matrix[nx][ny] < matrix[x][y]:\\n                            indegree[x][y] += 1\\n                            \\n        queue = []\\n        for x in range(rows):\\n            for y in range(cols):\\n                if indegree[x][y] == 0:\\n                    queue.append((x, y))\\n    \\n        path_len = 0\\n        while queue:\\n            sz = len(queue)\\n            for i in range(sz):\\n                x, y = queue.pop(0)\\n                for direction in directions:\\n                    nx, ny = x + direction[0], y + direction[1]\\n                    if nx >= 0 and ny >= 0 and nx < rows and ny < cols:\\n                        if matrix[nx][ny] > matrix[x][y]:\\n                            indegree[nx][ny] -= 1\\n                            if indegree[nx][ny] == 0:\\n                                queue.append((nx, ny))\\n            path_len += 1\\n        return path_len \\n```",
                "codeTag": "Java"
            },
            {
                "id": 78334,
                "title": "python-solution-memoization-dp-288ms",
                "content": "We can find longest decreasing path instead, the result will be the same. Use `dp` to record previous results and choose the max `dp` value of smaller neighbors.\\n\\n    def longestIncreasingPath(self, matrix):\\n        def dfs(i, j):\\n            if not dp[i][j]:\\n                val = matrix[i][j]\\n                dp[i][j] = 1 + max(\\n                    dfs(i - 1, j) if i and val > matrix[i - 1][j] else 0,\\n                    dfs(i + 1, j) if i < M - 1 and val > matrix[i + 1][j] else 0,\\n                    dfs(i, j - 1) if j and val > matrix[i][j - 1] else 0,\\n                    dfs(i, j + 1) if j < N - 1 and val > matrix[i][j + 1] else 0)\\n            return dp[i][j]\\n\\n        if not matrix or not matrix[0]: return 0\\n        M, N = len(matrix), len(matrix[0])\\n        dp = [[0] * N for i in range(M)]\\n        return max(dfs(x, y) for x in range(M) for y in range(N))",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "We can find longest decreasing path instead, the result will be the same. Use `dp` to record previous results and choose the max `dp` value of smaller neighbors.\\n\\n    def longestIncreasingPath(self, matrix):\\n        def dfs(i, j):\\n            if not dp[i][j]:\\n                val = matrix[i][j]\\n                dp[i][j] = 1 + max(\\n                    dfs(i - 1, j) if i and val > matrix[i - 1][j] else 0,\\n                    dfs(i + 1, j) if i < M - 1 and val > matrix[i + 1][j] else 0,\\n                    dfs(i, j - 1) if j and val > matrix[i][j - 1] else 0,\\n                    dfs(i, j + 1) if j < N - 1 and val > matrix[i][j + 1] else 0)\\n            return dp[i][j]\\n\\n        if not matrix or not matrix[0]: return 0\\n        M, N = len(matrix), len(matrix[0])\\n        dp = [[0] * N for i in range(M)]\\n        return max(dfs(x, y) for x in range(M) for y in range(N))",
                "codeTag": "Python3"
            },
            {
                "id": 1151423,
                "title": "c-optimization-from-brute-force-to-dp-easy-solution-w-explanation",
                "content": "I will explain step-by-step process to solve this problem from naive brute-force to optimised approach and the thought-process behind each one.\\n\\n---\\n\\n\\u274C ***Solution - I (Recursive Brute-Force Approach) [TLE]***\\n\\nLet\\'s start with just doing what the problem asks us to do. We are given a matrix and are asked to find longest path. \\n\\nThe optimal (longest) path can start from any cell of the matrix. So, for each cell `matrix[i][j]`, we find the longest path that we can go to, starting from the current cell such that each next cell value in the path is greater than the previous cell value. At each cell, we are given 4 options - \\n\\n&emsp;&emsp;&emsp;&emsp; \\u2726 **Go Up**&emsp;&emsp;&emsp;&emsp; \\u2726 **Go Down**&emsp;&emsp;&emsp;&emsp; \\u2726 **Go Left**&emsp;&emsp;&emsp;&emsp; \\u2726 **Go Right**\\n\\nAnd so we go on exploring each option available on the current cell till we can (At last, we either reach bounds of matrix or all adjacent cells will be smaller than current cell value - these denote the **base conditions** to stop our recursion). The recursive function is very similar to **DFS traversal**.\\n\\nThe implementation below has additional comments which explains more about this approach at each step -\\n\\n```\\nint moves[4][2] = { {-1,0},{1,0},{0,-1},{0,1} };   // all the moves available to us - top, down, left, right\\nint longestIncreasingPath(vector<vector<int>>& matrix) {\\n\\tint maxPath = 1; // atleast one cell can always be selected in the path\\n\\t// explore each cell of matrix to find longest path achievable from that cell and finally return the maximum\\n\\tfor(int i = 0; i < size(matrix); i++)\\n\\t\\tfor(int j = 0; j < size(matrix[0]); j++)\\n\\t\\t\\tmaxPath = max(maxPath, solve(matrix, i, j));\\t\\t        \\n\\treturn maxPath;\\n}\\n// recursive solver for each cell \\nint solve(vector<vector<int>>& mat, int i, int j){\\n\\tint MAX = 1;  // max length of path starting from cell i,j of matrix\\n\\t// choosing all the 4 moves available for current cell\\n\\tfor(int k = 0; k < 4; k++){\\n\\t\\tint new_i = i + moves[k][0], new_j = j + moves[k][1];\\n\\t\\t// bound checking as well as move to next cell only when it is greater in value\\n\\t\\tif(new_i < 0 || new_j < 0 || new_i >= size(mat) || new_j >= size(mat[0]) || mat[new_i][new_j] <= mat[i][j]) continue;\\n\\t\\t// MAX will be updated each time to store maximum of path length from each move\\n\\t\\tMAX = max(MAX, 1 + solve(mat, new_i, new_j));\\n\\t}         \\n\\treturn MAX;\\n}\\n```\\n\\n***Time Complexity :*** `O((N*M)*4^(N*M))`. We are calculating longest path for each cell and for each cell we are invoking 4 additional functions. All those invoked functions may further call 4 additional functions and this may continue maximum of `N*M` times taking the overall time complexity to `O((N*M)*4^(N*M))`.\\n We can see that 4 further functions are invoked only the first time `solve` is called and each subsequent time we only make 3 additional calls at max. So we can put `O((N*M)*3^(N*M))` as a more tighter upper bound of the given solution.\\n***Space Complexity :*** `O(N*M)`, maximum recursive stack depth for a cell can be `O(N*M)` when maximum path is `N*M`.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Recursive with Dynamic Programming - Memoization) [Accepted]***\\n\\nWe have to realize that in the above solution, we were doing a lot of repeated calculation which can be avoided if we use **dynamic programming** to store the previously calculated results. \\n\\nFor eg. If we have calculated optimal path for `matrix[0][0]` and suppose that it is - `(0,0) -> (0, 1) -> (0, 2) -> (1, 2) ->(1, 1) ->(1, 0)`, which is 6 in length. Now, for finding the optimal path for `matrix[0][1]`, there\\'s no need to recalculate the path again because it is **part of optimal path of matrix[0][0]** and for getting the optimal path for matrix[0][0], we must also have gotten the optimal path of its adjacent visitable cells. So, optimal answer for matrix[0][1] could have directly been returned as `5` if we had used **DP**. \\n\\nFrom the above, it is apparent that the naive brute force approach has - \\n\\n&emsp;&emsp;&emsp;\\uD83D\\uDC49 Many **overlapping subproblems** - As already seen in the example above, once we calculate the optimal answer for a cell, we most probably have also recursed for its adjacent cells and calculated the optimal answers for them as well. There\\'s no need to repeat the same calculations again.\\n\\n&emsp;&emsp;&emsp;\\uD83D\\uDC49 The problem has **optimal substructure property** meaning that the solutions of bigger problems can be calculated from optimal solutions of its sub-problems. So, if there\\'s a longest path (optimal solution) for a given cell starting at that cell, all the cells in its path must also have optimal paths as well starting at those cells respectively.\\n\\nSo, the repeated recalculation of sub-problems can be avoided using dp as given below -\\n\\n```\\nint moves[4][2] = { {-1,0},{1,0},{0,-1},{0,1} };\\nvector<vector<int> > dp; // dp[i][j] will store maximum path length starting from matrix[i][j]\\nint maxPath, n, m;\\nint longestIncreasingPath(vector<vector<int>>& matrix) {\\n\\tmaxPath = 0, n = size(matrix), m = size(matrix[0]);\\n\\tdp.resize(n, vector<int>(m));\\n\\t// calculating maximum path from each cell and at last returning the maximum length\\n\\tfor(int i = 0; i < n; i++)\\n\\t\\tfor(int j = 0; j < m; j++)\\n\\t\\t\\tmaxPath = max(maxPath, solve(matrix, i, j));            \\n\\treturn maxPath;\\n}\\n// recursive solver for each cell with dp for storing each calculated result\\nint solve(vector<vector<int>>& mat, int i, int j){\\n\\tif(dp[i][j]) return dp[i][j]; // return if result is already calculated\\n\\tdp[i][j] = 1;  // minimum path from each cell is always atleast 1\\n\\t// choosing each possible move available to us\\n\\tfor(int k = 0; k < 4; k++){ \\n\\t\\tint new_i = i + moves[k][0], new_j = j + moves[k][1];\\n\\t\\t// bound checking as well as move to next cell only when it is greater in value\\n\\t\\tif(new_i < 0 || new_j < 0 || new_i >= n || new_j >= m || mat[new_i][new_j] <= mat[i][j]) continue;\\n\\t\\t// max( current optimal, select current + optimal solution after moves[k] from current cell\\n\\t\\tdp[i][j] = max(dp[i][j], 1 + solve(mat, new_i, new_j));\\n\\t}         \\n\\treturn dp[i][j];\\n}\\n```\\n\\n***Time Complexity :*** **`O(NM)`**\\n***Space Complexity :*** **`O(NM)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Concise Solution - II***\\n\\nThis is the same as above solution just more shorter & cleaner version.\\n\\n```\\nint dp[200][200]{}; // constraints are small enough that we can just set them to MAX\\nint maxPath, n, m;\\nint longestIncreasingPath(vector<vector<int>>& matrix) {\\n\\tmaxPath = 0, n = size(matrix), m = size(matrix[0]);\\n\\tfor(int i = 0; i < n; i++)\\n\\t\\tfor(int j = 0; j < m; j++)\\n\\t\\t\\tmaxPath = max(maxPath, solve(matrix, i, j, -1));            \\n\\treturn maxPath;\\n}\\nint solve(vector<vector<int>>& mat, int i, int j, int prev){\\n\\tif(i < 0 || j < 0 || i >= n || j >= m || mat[i][j] <= prev) return 0;\\n\\tif(dp[i][j]) return dp[i][j];\\n\\treturn dp[i][j] = 1 + max({ solve(mat, i + 1, j, mat[i][j]),\\n\\t\\t\\t\\t\\t\\t\\t    solve(mat, i - 1, j, mat[i][j]),\\n\\t\\t\\t\\t\\t\\t\\t    solve(mat, i, j + 1, mat[i][j]),\\n\\t\\t\\t\\t\\t\\t\\t    solve(mat, i, j - 1, mat[i][j]) });       \\n}\\n```\\n\\n---\\n\\n*Best Runtime -*\\n\\n<table><tr><td><img src = https://assets.leetcode.com/users/images/907d87f0-289c-4c92-8fa5-3b5b0f8fcad6_1618056082.304802.png /> </td> </tr> </table>\\n\\n---\\n\\n*Why not Bottom-up Approach ?*\\nAns : This problem has a natural and intuitive top-down recursive solution which can be optimized using memoization. Of course, it can be converted to iterative version as well. One way is to use a explicit stack and just convert the above solution to iterative version. Though technically a iterative solution, this won\\'t be any different logically than the recursive one. \\n\\nIn another iterative version, we would need to use priority queue to do this efficiently. This priority queue will allow us to start from the maximum value cell from the matrix which is necessary and makes it possible for us to apply dp on it. This makes the solution a bit complex and also the priority queue would require an extra `O(logn)` to give the max value cell each time taking the overall time complexity to **`O(MNlog(MN))`**.\\n\\n\\n---\\n---\\n\\n\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any questions or mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```\\nint moves[4][2] = { {-1,0},{1,0},{0,-1},{0,1} };   // all the moves available to us - top, down, left, right\\nint longestIncreasingPath(vector<vector<int>>& matrix) {\\n\\tint maxPath = 1; // atleast one cell can always be selected in the path\\n\\t// explore each cell of matrix to find longest path achievable from that cell and finally return the maximum\\n\\tfor(int i = 0; i < size(matrix); i++)\\n\\t\\tfor(int j = 0; j < size(matrix[0]); j++)\\n\\t\\t\\tmaxPath = max(maxPath, solve(matrix, i, j));\\t\\t        \\n\\treturn maxPath;\\n}\\n// recursive solver for each cell \\nint solve(vector<vector<int>>& mat, int i, int j){\\n\\tint MAX = 1;  // max length of path starting from cell i,j of matrix\\n\\t// choosing all the 4 moves available for current cell\\n\\tfor(int k = 0; k < 4; k++){\\n\\t\\tint new_i = i + moves[k][0], new_j = j + moves[k][1];\\n\\t\\t// bound checking as well as move to next cell only when it is greater in value\\n\\t\\tif(new_i < 0 || new_j < 0 || new_i >= size(mat) || new_j >= size(mat[0]) || mat[new_i][new_j] <= mat[i][j]) continue;\\n\\t\\t// MAX will be updated each time to store maximum of path length from each move\\n\\t\\tMAX = max(MAX, 1 + solve(mat, new_i, new_j));\\n\\t}         \\n\\treturn MAX;\\n}\\n```\n```\\nint moves[4][2] = { {-1,0},{1,0},{0,-1},{0,1} };\\nvector<vector<int> > dp; // dp[i][j] will store maximum path length starting from matrix[i][j]\\nint maxPath, n, m;\\nint longestIncreasingPath(vector<vector<int>>& matrix) {\\n\\tmaxPath = 0, n = size(matrix), m = size(matrix[0]);\\n\\tdp.resize(n, vector<int>(m));\\n\\t// calculating maximum path from each cell and at last returning the maximum length\\n\\tfor(int i = 0; i < n; i++)\\n\\t\\tfor(int j = 0; j < m; j++)\\n\\t\\t\\tmaxPath = max(maxPath, solve(matrix, i, j));            \\n\\treturn maxPath;\\n}\\n// recursive solver for each cell with dp for storing each calculated result\\nint solve(vector<vector<int>>& mat, int i, int j){\\n\\tif(dp[i][j]) return dp[i][j]; // return if result is already calculated\\n\\tdp[i][j] = 1;  // minimum path from each cell is always atleast 1\\n\\t// choosing each possible move available to us\\n\\tfor(int k = 0; k < 4; k++){ \\n\\t\\tint new_i = i + moves[k][0], new_j = j + moves[k][1];\\n\\t\\t// bound checking as well as move to next cell only when it is greater in value\\n\\t\\tif(new_i < 0 || new_j < 0 || new_i >= n || new_j >= m || mat[new_i][new_j] <= mat[i][j]) continue;\\n\\t\\t// max( current optimal, select current + optimal solution after moves[k] from current cell\\n\\t\\tdp[i][j] = max(dp[i][j], 1 + solve(mat, new_i, new_j));\\n\\t}         \\n\\treturn dp[i][j];\\n}\\n```\n```\\nint dp[200][200]{}; // constraints are small enough that we can just set them to MAX\\nint maxPath, n, m;\\nint longestIncreasingPath(vector<vector<int>>& matrix) {\\n\\tmaxPath = 0, n = size(matrix), m = size(matrix[0]);\\n\\tfor(int i = 0; i < n; i++)\\n\\t\\tfor(int j = 0; j < m; j++)\\n\\t\\t\\tmaxPath = max(maxPath, solve(matrix, i, j, -1));            \\n\\treturn maxPath;\\n}\\nint solve(vector<vector<int>>& mat, int i, int j, int prev){\\n\\tif(i < 0 || j < 0 || i >= n || j >= m || mat[i][j] <= prev) return 0;\\n\\tif(dp[i][j]) return dp[i][j];\\n\\treturn dp[i][j] = 1 + max({ solve(mat, i + 1, j, mat[i][j]),\\n\\t\\t\\t\\t\\t\\t\\t    solve(mat, i - 1, j, mat[i][j]),\\n\\t\\t\\t\\t\\t\\t\\t    solve(mat, i, j + 1, mat[i][j]),\\n\\t\\t\\t\\t\\t\\t\\t    solve(mat, i, j - 1, mat[i][j]) });       \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2052360,
                "title": "python-beginner-friendly-recursion-to-dp-intuition-explained",
                "content": "See, here we want to get the **longest increasing path** in a matrix.\\n\\n***The idea*** for this is to iterate through each element of the matrix and perform a depth first search expanding in all the four directions (left, right, top, bottom). \\n\\nWhile expanding we check the following points:\\n* The expansion cannot go out of the boundaries of the matrix.\\n* The current element should be strictly greater than the previous element.\\n\\nSo the **above two conditions serves as the base condition** (the point where the recursive function calls terminates) for our recursive approach.\\n\\nNow, coming to **the recursive part**.\\nWe want the max number of increasing nodes, that forms a longest increasing path in the matrix. These paths can come from 4 directions and we will **choose the max_path_length from all the 4 directions and add 1 to it** (just to consider the current node as well). \\n\\n* **Note:** Generally **traversal algorithms** (like BFS, DFS, etc..) **needs a visited set** to keep track of the elements that were already visited earlier, so that we do not revisit them later *(as it may turn out to be an infinite loop where you keep visiting nodes again and again, without teminating the loop/recursion)*.\\n\\nBut in this case, we only visit elements that are strictly greater than the current element. \\nLets say from `x` we go to `y` as `y > x`. Now, when we reached `y` we can never come back to `x` as `x will never be greater than y`. So the node once visited (in this scenerio), can never be revisited again (by default) as it will always be smaller that the current node. Hence, in this case **we do not need a visited  set**.\\n\\nI hope you got the intuition behind the recursive approach. \\n\\nThe full recursive code (**Not Accepted, TLE**) is given below:\\n\\n```\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n\\t    \\n        m, n = len(matrix), len(matrix[0])\\n        \\n        def dfs(i, j, prev):\\n            \\n            # base condition : check \"out of boundaries\" situation and \\n            # also if \"current <= previous\" then these are invalid conditions. \\n            if i < 0 or j < 0 or i >= m or j >= n or matrix[i][j] <= prev:\\n                return 0\\n            \\n            # expand and look in all four directions using simple depth first search\\n            left = dfs(i, j - 1, matrix[i][j])\\n            right = dfs(i, j + 1, matrix[i][j])\\n            top = dfs(i - 1, j, matrix[i][j])\\n            bottom = dfs(i + 1, j, matrix[i][j])\\n            \\n            # return max depth of longest increasing path and \\n            # plus 1 to consider the current element.\\n            return max(left, right, top, bottom) + 1\\n             \\n        \\n        # compute the longest increasing path for each element and\\n        # update the max value as answer.\\n        ans = -1\\n        for i in range(m):\\n            for j in range(n):\\n                ans = max(ans, dfs(i, j, -1))\\n        return ans\\n```\\n\\nNot a doubt, this solution is perfectly correct. But not optimized as per the question\\'s requirement.\\n\\n**Why do we get a TLE for the above code??** \\n1. We use two nested (simultaneous) loops for traversing through the matrix of size `m * n`  = `O(m * n)`.\\n2. Also, we have 4 possibilites to expand from each of the element of matrix = `O(4 ^ (m * n))`\\n\\nHence, total **time complexity** for the above approach **= O(m * n * 4 ^ (m * n))** =  O( 200 * 200 * 4 ^ (200 * 200)) see constraints for this = O(40000 * 4 ^ 40000) **much greater than O(10^8)**. \\n\\nPython generally does not allow us to exceed `10 ^ 8`. **Hence** we will definitely get **TLE**.\\n\\n**So, what\\'s the solution?** See generally when you have TLE for recursive solutions, you can always memoize it (it\\'s just a random observation). But this is not a good reason to say to the interviewers. xD\\n\\n**How to identify a DP problem?** Analyze the problem and Check for overlapping subproblems, so that we can memoize it.\\n\\nConsider the first example as shown below: `(indexes of each element is given in **red**, in (i, j) format).`\\n![image](https://assets.leetcode.com/users/images/93678fb7-cd1a-4f94-8334-07ea30b83fa6_1652925397.1484113.png)\\n\\n\\n* Assume you are at index (1, 0) having value as 6.\\nYou recursively call indices (1, -1), (1, 1), (0, 0), (2, 0). \\nHere, (1, -1) gets eliminated due to \"out of boundaries\" conditions.\\nIndices (1, 1)  and (2, 0) gets eliminated as previous <= current. \\nNow, when index (0, 0) is called it gets satisfied and not eleminated. Hence, recursively call (0, 0) having value = 9.\\nNow, for index (0, 0) there will be 4 recursive calls but all of them will be eliminated as `left and top side of (0, 0) is out of bound` and `right and bottom are <= 9`.\\nSo the function that was recursively called having value 9 at index (0, 0) will return max(0, 0, 0 ,0) + 1 = 1.\\nSo at index (1, 0) having value = 6  we will return max(0, 0, 1, 0) + 1  = 1.\\n\\nNow, assume we have reached index (2, 0) having value = 2 it will again call index (1, 0) having value = 6 and index (1, 0) will not be eliminated as it is inside the matrix and its value = 6 is greater than \\'2\\'. \\n\\nSo now recursively compute (1, 0) and return it back to (2, 0). \\n\\n**But Whyyyyyyyy??????????? **\\n\\nHaven\\'t we already calcuated (1, 0) earlier? **Why to recompute**? Just store the previously computed value and return it whenever the (already computed) index (1, 0) is called. Similarly, do the same for all indices that requires recomputation. \\nThis process of finding overlapping subproblems, storing the computed value, reusing the previously computed value and reducing the recomputation complexity is called **Memoization** or **Top Down Dynamic Programming Approach**.\\n\\nThe optimized Code (**Accepted**) is given below:\\n```\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        \\n        # create a dp array of size m * n to store already computed max_increasing_path_length for index (i, j)\\n        # where 0 <= i < m and 0 <= j < n\\n        # initialize the dp array by -1 as length of path can only be a whole number. \\n        dp = [[-1] * n for _ in range(m)]\\n        \\n        def dfs(i, j, prev):\\n            if i < 0 or j < 0 or i >= m or j >= n or matrix[i][j] <= prev:\\n                return 0\\n            \\n            # if dp[i][j] != -1, that means dp[i][j] has been updated by some >= 0 path length.\\n            # hence directly use it without recomputing and save recursion time and space.\\n            if dp[i][j] != -1:\\n                return dp[i][j]\\n            \\n            # compute if dp[i][j] = -1 meaning (i, j) still not computed\\n            left = dfs(i, j - 1, matrix[i][j])\\n            right = dfs(i, j + 1, matrix[i][j])\\n            top = dfs(i - 1, j, matrix[i][j])\\n            bottom = dfs(i + 1, j, matrix[i][j])\\n            \\n            # update the dp value after computing path length for index (i , j)\\n            # so that we can use it next time without recomputation.\\n            dp[i][j] = max(left, right, top, bottom) + 1\\n            return dp[i][j]\\n        \\n        ans = -1\\n        for i in range(m):\\n            for j in range(n):\\n                ans = max(ans, dfs(i, j, -1))\\n        return ans\\n```\\n\\n![image](https://assets.leetcode.com/users/images/211f8c3b-2d13-46f1-a040-c912c1591104_1652927727.239362.png)\\n\\n\\n**Time and Space Complexity analysis:**\\nHere, each of the successful recursive calls (whose value will be inserted in the dp matrix) will exactly be called once, because later it will take it directly from the dp array in constant time. And the unsuccessful recursive calls will return from the base condition in constant time. But we are traversing through the matrix of size \\'m * n\\' through nested loops (simultaneously). Thus, **optimized time complexity = O(m * n)** owing to the traversal of matrix. \\n\\nNow, we have used only one variable sized space that is dp array of size \\'m * n\\'. Apart from that all other variables are constant sized like n, m, ans, etc.. are fixed sized 32 - bit integer variables. So, no need to consider that, as their size will always be fixed and will not change with respect to change in input variable. Hence, **Space complexity  = O(m * n) owing to the dp array.**\\n\\nAnd this is what/how you will say to the interviewers. \\n\\n**Please upvote**, if this post helps.\\n\\n***Similar Problems with detailed intuitions explained:***\\n* *Leetcode 576. Out of Boundary Paths: https://leetcode.com/problems/out-of-boundary-paths/discuss/1293697/python-easy-to-understand-explanation-recursion-and-memoization-with-time-and-space-complexity*\\n* *Leetcode 792. Number of Matching Subsequences:  https://leetcode.com/problems/number-of-matching-subsequences/discuss/1289549/python-explained-all-possible-solutions-with-time-and-space-complexity*",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n\\t    \\n        m, n = len(matrix), len(matrix[0])\\n        \\n        def dfs(i, j, prev):\\n            \\n            # base condition : check \"out of boundaries\" situation and \\n            # also if \"current <= previous\" then these are invalid conditions. \\n            if i < 0 or j < 0 or i >= m or j >= n or matrix[i][j] <= prev:\\n                return 0\\n            \\n            # expand and look in all four directions using simple depth first search\\n            left = dfs(i, j - 1, matrix[i][j])\\n            right = dfs(i, j + 1, matrix[i][j])\\n            top = dfs(i - 1, j, matrix[i][j])\\n            bottom = dfs(i + 1, j, matrix[i][j])\\n            \\n            # return max depth of longest increasing path and \\n            # plus 1 to consider the current element.\\n            return max(left, right, top, bottom) + 1\\n             \\n        \\n        # compute the longest increasing path for each element and\\n        # update the max value as answer.\\n        ans = -1\\n        for i in range(m):\\n            for j in range(n):\\n                ans = max(ans, dfs(i, j, -1))\\n        return ans\\n```\n```\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        \\n        # create a dp array of size m * n to store already computed max_increasing_path_length for index (i, j)\\n        # where 0 <= i < m and 0 <= j < n\\n        # initialize the dp array by -1 as length of path can only be a whole number. \\n        dp = [[-1] * n for _ in range(m)]\\n        \\n        def dfs(i, j, prev):\\n            if i < 0 or j < 0 or i >= m or j >= n or matrix[i][j] <= prev:\\n                return 0\\n            \\n            # if dp[i][j] != -1, that means dp[i][j] has been updated by some >= 0 path length.\\n            # hence directly use it without recomputing and save recursion time and space.\\n            if dp[i][j] != -1:\\n                return dp[i][j]\\n            \\n            # compute if dp[i][j] = -1 meaning (i, j) still not computed\\n            left = dfs(i, j - 1, matrix[i][j])\\n            right = dfs(i, j + 1, matrix[i][j])\\n            top = dfs(i - 1, j, matrix[i][j])\\n            bottom = dfs(i + 1, j, matrix[i][j])\\n            \\n            # update the dp value after computing path length for index (i , j)\\n            # so that we can use it next time without recomputation.\\n            dp[i][j] = max(left, right, top, bottom) + 1\\n            return dp[i][j]\\n        \\n        ans = -1\\n        for i in range(m):\\n            for j in range(n):\\n                ans = max(ans, dfs(i, j, -1))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1429348,
                "title": "c-python-2-solutions-dfs-memoization-topology-sort-peel-onion-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: DFS & Memoization**\\n\\n<iframe src=\"https://leetcode.com/playground/k3N9kCqM/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>\\n\\n**Complexity**\\n- Time: `O(M * N)`, where `M <= 200` is number of rows, `N <= 200` is number of columns.\\n- Space: `O(M * N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Topology Sort - Peel Onion**\\n![image](https://assets.leetcode.com/users/images/445c1c42-4e60-4052-9d4c-27af7366f720_1633418671.759919.png)\\n\\n```python\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        DIR = [0, 1, 0, -1, 0]\\n        m, n = len(matrix), len(matrix[0])\\n        \\n        outDegree = [[0] * n for _ in range(m)]\\n        for r in range(m):\\n            for c in range(n):\\n                for i in range(4):\\n                    nr, nc = r + DIR[i], c + DIR[i+1]\\n                    if nr < 0 or nr == m or nc < 0 or nc == n or matrix[nr][nc] <= matrix[r][c]: continue\\n                    outDegree[r][c] += 1\\n            \\n        q = deque([])\\n        for r in range(m):\\n            for c in range(n):\\n                if outDegree[r][c] == 0:\\n                    q.append([r, c])\\n                    \\n        level = 0\\n        while q:\\n            level += 1\\n            for _ in range(len(q)):\\n                r, c = q.popleft()\\n                for i in range(4):\\n                    nr, nc = r + DIR[i], c + DIR[i+1]\\n                    if nr < 0 or nr == m or nc < 0 or nc == n or matrix[nr][nc] >= matrix[r][c]: continue\\n                    outDegree[nr][nc] -= 1\\n                    if outDegree[nr][nc] == 0:\\n                        q.append([nr, nc])\\n                    \\n        return level\\n```\\n**Complexity**\\n- Time: `O(M * N)`, where `M <= 200` is number of rows, `N <= 200` is number of columns.\\n- Space: `O(M * N)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        DIR = [0, 1, 0, -1, 0]\\n        m, n = len(matrix), len(matrix[0])\\n        \\n        outDegree = [[0] * n for _ in range(m)]\\n        for r in range(m):\\n            for c in range(n):\\n                for i in range(4):\\n                    nr, nc = r + DIR[i], c + DIR[i+1]\\n                    if nr < 0 or nr == m or nc < 0 or nc == n or matrix[nr][nc] <= matrix[r][c]: continue\\n                    outDegree[r][c] += 1\\n            \\n        q = deque([])\\n        for r in range(m):\\n            for c in range(n):\\n                if outDegree[r][c] == 0:\\n                    q.append([r, c])\\n                    \\n        level = 0\\n        while q:\\n            level += 1\\n            for _ in range(len(q)):\\n                r, c = q.popleft()\\n                for i in range(4):\\n                    nr, nc = r + DIR[i], c + DIR[i+1]\\n                    if nr < 0 or nr == m or nc < 0 or nc == n or matrix[nr][nc] >= matrix[r][c]: continue\\n                    outDegree[nr][nc] -= 1\\n                    if outDegree[nr][nc] == 0:\\n                        q.append([nr, nc])\\n                    \\n        return level\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78317,
                "title": "c-dp-dfs-solution-sharing",
                "content": "    class Solution {\\n    public:\\n        int longestIncreasingPath(vector<vector<int>>& matrix) {\\n            int rows = matrix.size();\\n            if (!rows) return 0;\\n            int cols = matrix[0].size();\\n            \\n            vector<vector<int>> dp(rows, vector<int>(cols, 0));\\n            std::function<int(int, int)> dfs = [&] (int x, int y) {\\n                if (dp[x][y]) return dp[x][y];\\n                vector<vector<int>> dirs = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n                for (auto &dir : dirs) {\\n                    int xx = x + dir[0], yy = y + dir[1];\\n                    if (xx < 0 || xx >= rows || yy < 0 || yy >= cols) continue;\\n                    if (matrix[xx][yy] <= matrix[x][y]) continue;\\n                    dp[x][y] = std::max(dp[x][y], dfs(xx, yy));\\n                }\\n                return ++dp[x][y];\\n            };\\n            \\n            int ret = 0;\\n            for (int i = 0; i < rows; ++i) {\\n                for (int j = 0; j < cols; ++j) {\\n                    ret = std::max(ret, dfs(i, j));\\n                }\\n            }\\n            \\n            return ret;\\n        }\\n    };",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        int longestIncreasingPath(vector<vector<int>>& matrix) {\\n            int rows = matrix.size();\\n            if (!rows) return 0;\\n            int cols = matrix[0].size();\\n            \\n            vector<vector<int>> dp(rows, vector<int>(cols, 0));\\n            std::function<int(int, int)> dfs = [&] (int x, int y) {\\n                if (dp[x][y]) return dp[x][y];\\n                vector<vector<int>> dirs = {{-1, 0}",
                "codeTag": "Java"
            },
            {
                "id": 78381,
                "title": "short-python",
                "content": "Solution 1\\n-\\n\\nBottom-up DP, about 480 ms.\\n\\n    def longestIncreasingPath(self, matrix):\\n        matrix = {i + j*1j: val\\n                  for i, row in enumerate(matrix)\\n                  for j, val in enumerate(row)}\\n        length = {}\\n        for z in sorted(matrix, key=matrix.get):\\n            length[z] = 1 + max([length[Z]\\n                                 for Z in z+1, z-1, z+1j, z-1j\\n                                 if Z in matrix and matrix[z] > matrix[Z]]\\n                                or [0])\\n        return max(length.values() or [0])\\n\\n---\\n\\nSolution 2\\n-\\n\\nTop-down DP, about 560 ms.\\n\\n    def longestIncreasingPath(self, matrix):\\n        def length(z):\\n            if z not in memo:\\n                memo[z] = 1 + max([length(Z)\\n                                   for Z in z+1, z-1, z+1j, z-1j\\n                                   if Z in matrix and matrix[z] > matrix[Z]]\\n                                  or [0])\\n            return memo[z]\\n        memo = {}\\n        matrix = {i + j*1j: val\\n                  for i, row in enumerate(matrix)\\n                  for j, val in enumerate(row)}\\n        return max(map(length, matrix) or [0])",
                "solutionTags": [
                    "Python"
                ],
                "code": "Solution 1\\n-\\n\\nBottom-up DP, about 480 ms.\\n\\n    def longestIncreasingPath(self, matrix):\\n        matrix = {i + j*1j: val\\n                  for i, row in enumerate(matrix)\\n                  for j, val in enumerate(row)}\\n        length = {}\\n        for z in sorted(matrix, key=matrix.get):\\n            length[z] = 1 + max([length[Z]\\n                                 for Z in z+1, z-1, z+1j, z-1j\\n                                 if Z in matrix and matrix[z] > matrix[Z]]\\n                                or [0])\\n        return max(length.values() or [0])\\n\\n---\\n\\nSolution 2\\n-\\n\\nTop-down DP, about 560 ms.\\n\\n    def longestIncreasingPath(self, matrix):\\n        def length(z):\\n            if z not in memo:\\n                memo[z] = 1 + max([length(Z)\\n                                   for Z in z+1, z-1, z+1j, z-1j\\n                                   if Z in matrix and matrix[z] > matrix[Z]]\\n                                  or [0])\\n            return memo[z]\\n        memo = {}\\n        matrix = {i + j*1j: val\\n                  for i, row in enumerate(matrix)\\n                  for j, val in enumerate(row)}\\n        return max(map(length, matrix) or [0])",
                "codeTag": "Python3"
            },
            {
                "id": 78313,
                "title": "java-14ms-relative-short-easy-to-code-solution-with-explanation-o-mn-time-o-mn-space-dfs-dp",
                "content": "The idea is simple and intuitive:  \\n    1. For each cell, try it's left, right, up and down for smaller number.  \\n    2. If it's smaller, means we are on the right track and we should keep going. If larger, stop and return.  \\n    3. Treat each cell as a start cell. Calculate and memorize the longest distance for this cell, so we don't need to calculate it again in the future.  \\n\\nQuestions and advices are welcome.\\n\\n    public class Solution {\\n        public int longestIncreasingPath(int[][] matrix) {\\n            if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\\n                return 0;\\n            }\\n            int[][] cache = new int[matrix.length][matrix[0].length];\\n            int max = 0;\\n            for (int i = 0; i < matrix.length; i++) {\\n                for (int j = 0; j < matrix[0].length; j++) {\\n                    int length = findSmallAround(i, j, matrix, cache, Integer.MAX_VALUE);\\n                    max = Math.max(length, max);\\n                }\\n            }\\n            return max;\\n        }\\n        private int findSmallAround(int i, int j, int[][] matrix, int[][] cache, int pre) {\\n            // if out of bond OR current cell value larger than previous cell value.\\n            if (i < 0 || i >= matrix.length || j < 0 || j >= matrix[0].length || matrix[i][j] >= pre) {\\n                return 0;\\n            }\\n            // if calculated before, no need to do it again\\n            if (cache[i][j] > 0) {\\n                return cache[i][j];\\n            } else {\\n                int cur = matrix[i][j];\\n                int tempMax = 0;\\n                tempMax = Math.max(findSmallAround(i - 1, j, matrix, cache, cur), tempMax);\\n                tempMax = Math.max(findSmallAround(i + 1, j, matrix, cache, cur), tempMax);\\n                tempMax = Math.max(findSmallAround(i, j - 1, matrix, cache, cur), tempMax);\\n                tempMax = Math.max(findSmallAround(i, j + 1, matrix, cache, cur), tempMax);\\n                cache[i][j] = ++tempMax;\\n                return tempMax;\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n        public int longestIncreasingPath(int[][] matrix) {\\n            if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1151418,
                "title": "longest-increasing-path-in-a-matrix-short-simple-w-explanation",
                "content": "I will explain step-by-step process to solve this problem from naive brute-force to optimised approach and the thought-process behind each one.\\n\\n---\\n\\n\\u274C ***Solution - I (Recursive Brute-Force Approach) [TLE]***\\n\\nLet\\'s start with just doing what the problem asks us to do. We are given a matrix and are asked to find longest path. \\n\\nThe optimal (longest) path can start from any cell of the matrix. So, for each cell `matrix[i][j]`, we find the longest path that we can go to, starting from the current cell such that each next cell value in the path is greater than the previous cell value. At each cell, we are given 4 options - \\n\\n&emsp;&emsp;&emsp;&emsp; \\u2726 **Go Up**&emsp;&emsp;&emsp;&emsp; \\u2726 **Go Down**&emsp;&emsp;&emsp;&emsp; \\u2726 **Go Left**&emsp;&emsp;&emsp;&emsp; \\u2726 **Go Right**\\n\\nAnd so we go on exploring each option available on the current cell till we can (At last, we either reach bounds of matrix or all adjacent cells will be smaller than current cell value - these denote the **base conditions** to stop our recursion). The recursive function is very similar to **DFS traversal**.\\n\\nThe implementation below has additional comments which explains more about this approach at each step -\\n\\n```\\nint moves[4][2] = { {-1,0},{1,0},{0,-1},{0,1} };   // all the moves available to us - top, down, left, right\\nint longestIncreasingPath(vector<vector<int>>& matrix) {\\n\\tint longestPath = 1; // atleast one cell can always be selected in the path\\n\\t// explore each cell of matrix to find longest path achievable from that cell and finally return the maximum\\n\\tfor(int i = 0; i < size(matrix); i++)\\n\\t\\tfor(int j = 0; j < size(matrix[0]); j++)\\n\\t\\t\\tlongestPath = max(longestPath, solve(matrix, i, j));\\t\\t        \\n\\treturn longestPath;\\n}\\n// recursive solver for each cell \\nint solve(vector<vector<int>>& mat, int i, int j){\\n\\tint MAX = 1;  // max length of path starting from cell i,j of matrix\\n\\t// choosing all the 4 moves available for current cell\\n\\tfor(int k = 0; k < 4; k++){\\n\\t\\tint new_i = i + moves[k][0], new_j = j + moves[k][1];\\n\\t\\t// bound checking as well as move to next cell only when it is greater in value\\n\\t\\tif(new_i < 0 || new_j < 0 || new_i >= size(mat) || new_j >= size(mat[0]) || mat[new_i][new_j] <= mat[i][j]) continue;\\n\\t\\t// MAX will be updated each time to store maximum of path length from each move\\n\\t\\tMAX = max(MAX, 1 + solve(mat, new_i, new_j));\\n\\t}         \\n\\treturn MAX;\\n}\\n```\\n\\n***Time Complexity :*** `O((N*M)*4^(N*M))`. We are calculating longest path for each cell and for each cell we are invoking 4 additional functions. All those invoked functions may further call 4 additional functions and this may continue maximum of `N*M` times taking the overall time complexity to `O((N*M)*4^(N*M))`.\\n We can see that 4 further functions are invoked only the first time `solve` is called and each subsequent time we only make 3 additional calls at max. So we can put `O((N*M)*3^(N*M))` as a more tighter upper bound of the given solution.\\n***Space Complexity :*** `O(N*M)`, maximum recursive stack depth for a cell can be `O(N*M)` when maximum path is `N*M`.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Recursive with Dynamic Programming - Memoization) [Accepted]***\\n\\nWe have to realize that in the above solution, we were doing a lot of repeated calculation which can be avoided if we use **dynamic programming** to store the previously calculated results. \\n\\nFor eg. If we have calculated optimal path for `matrix[0][0]` and suppose that it is - `(0,0) -> (0, 1) -> (0, 2) -> (1, 2) ->(1, 1) ->(1, 0)`, which is 6 in length. Now, for finding the optimal path for `matrix[0][1]`, there\\'s no need to recalculate the path again because it is **part of optimal path of matrix[0][0]** and for getting the optimal path for matrix[0][0], we must also have gotten the optimal path of its adjacent visitable cells. So, optimal answer for matrix[0][1] could have directly been returned as `5` if we had used **DP**. \\n\\nFrom the above, it is apparent that the naive brute force approach has - \\n\\n&emsp;&emsp;&emsp;\\uD83D\\uDC49 Many **overlapping subproblems** - As already seen in the example above, once we calculate the optimal answer for a cell, we most probably have also recursed for its adjacent cells and calculated the optimal answers for them as well. There\\'s no need to repeat the same calculations again.\\n\\n&emsp;&emsp;&emsp;\\uD83D\\uDC49 The problem has **optimal substructure property** meaning that the solutions of bigger problems can be calculated from optimal solutions of its sub-problems. So, if there\\'s a longest path (optimal solution) for a given cell starting at that cell, all the cells in its path must also have optimal paths as well starting at those cells respectively.\\n\\nSo, the repeated recalculation of sub-problems can be avoided using dp as given below -\\n\\n```\\nint moves[4][2] = { {-1,0},{1,0},{0,-1},{0,1} };\\nvector<vector<int> > dp; // dp[i][j] will store maximum path length starting from matrix[i][j]\\nint cnt, n, m;\\nint longestIncreasingPath(vector<vector<int>>& matrix) {\\n\\tmaxPath = 0, n = size(matrix), m = size(matrix[0]);\\n\\tdp.resize(n, vector<int>(m));\\n\\t// calculating maximum path from each cell and at last returning the maximum length\\n\\tfor(int i = 0; i < n; i++)\\n\\t\\tfor(int j = 0; j < m; j++)\\n\\t\\t\\tmaxPath = max(maxPath, solve(matrix, i, j, -1));            \\n\\treturn maxPath;\\n}\\n// recursive solver for each cell with dp for storing each calculated result\\nint solve(vector<vector<int>>& mat, int i, int j, int prev){\\n\\tif(dp[i][j]) return dp[i][j]; // return if result is already calculated\\n\\tdp[i][j] = 1;  // minimum path from each cell is always atleast 1\\n\\t// choosing each possible move available to us\\n\\tfor(int k = 0; k < 4; k++){ \\n\\t\\tint new_i = i + moves[k][0], new_j = j + moves[k][1];\\n\\t\\t// bound checking as well as move to next cell only when it is greater in value\\n\\t\\tif(new_i < 0 || new_j < 0 || new_i >= n || new_j >= m || mat[new_i][new_j] <= mat[i][j]) continue;\\n\\t\\t// max( current optimal, select current + optimal solution after moves[k] from current cell\\n\\t\\tdp[i][j] = max(dp[i][j], 1 + solve(mat, new_i, new_j, mat[i][j]));\\n\\t}         \\n\\treturn dp[i][j];\\n}\\n```\\n\\n***Time Complexity :*** **`O(NM)`**\\n***Space Complexity :*** **`O(NM)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Concise Solution - II***\\n\\nThis is the same as above solution just more shorter & cleaner version.\\n\\n```\\nint dp[200][200]; // constraints are small enough that we can just set them to MAX\\nint cnt, n, m;\\nint longestIncreasingPath(vector<vector<int>>& matrix) {\\n\\tcnt = 0, n = size(matrix), m = size(matrix[0]);\\n\\tfor(int i = 0; i < n; i++)\\n\\t\\tfor(int j = 0; j < m; j++)\\n\\t\\t\\tcnt = max(cnt, solve(matrix, i, j, -1));            \\n\\treturn cnt;\\n}\\nint solve(vector<vector<int>>& mat, int i, int j, int prev){\\n\\tif(i < 0 || j < 0 || i >= n || j >= m || mat[i][j] <= prev) return 0;\\n\\tif(dp[i][j]) return dp[i][j];\\n\\treturn dp[i][j] = 1 + max({ solve(mat, i + 1, j, mat[i][j]),\\n\\t\\t\\t\\t\\t\\t\\t    solve(mat, i - 1, j, mat[i][j]),\\n\\t\\t\\t\\t\\t\\t\\t    solve(mat, i, j + 1, mat[i][j]),\\n\\t\\t\\t\\t\\t\\t\\t    solve(mat, i, j - 1, mat[i][j]) });       \\n}\\n```\\n\\n---\\n\\n*Best Runtime -*\\n\\n<table><tr><td><img src = https://assets.leetcode.com/users/images/907d87f0-289c-4c92-8fa5-3b5b0f8fcad6_1618056082.304802.png /> </td> </tr> </table>\\n\\n---\\n\\n*Why not Bottom-up Approach ?*\\nAns : This problem has a natural and intuitive top-down recursive solution which can be optimized using memoization. Of course, it can be converted to iterative version as well. One way is to use a explicit stack and just convert the above solution to iterative version. Though technically a iterative solution, this won\\'t be any different logically than the recursive one. \\n\\nIn another iterative version, we would need to use priority queue to do this efficiently. This priority queue will allow us to start from the maximum value cell from the matrix which is necessary and makes it possible for us to apply dp on it. This makes the solution a bit complex and also the priority queue would require an extra `O(logn)` to give the max value cell each time taking the overall time complexity to **`O(MNlog(MN))`**.\\n\\n\\n---\\n---\\n\\n\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any questions or mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint moves[4][2] = { {-1,0},{1,0},{0,-1},{0,1} };   // all the moves available to us - top, down, left, right\\nint longestIncreasingPath(vector<vector<int>>& matrix) {\\n\\tint longestPath = 1; // atleast one cell can always be selected in the path\\n\\t// explore each cell of matrix to find longest path achievable from that cell and finally return the maximum\\n\\tfor(int i = 0; i < size(matrix); i++)\\n\\t\\tfor(int j = 0; j < size(matrix[0]); j++)\\n\\t\\t\\tlongestPath = max(longestPath, solve(matrix, i, j));\\t\\t        \\n\\treturn longestPath;\\n}\\n// recursive solver for each cell \\nint solve(vector<vector<int>>& mat, int i, int j){\\n\\tint MAX = 1;  // max length of path starting from cell i,j of matrix\\n\\t// choosing all the 4 moves available for current cell\\n\\tfor(int k = 0; k < 4; k++){\\n\\t\\tint new_i = i + moves[k][0], new_j = j + moves[k][1];\\n\\t\\t// bound checking as well as move to next cell only when it is greater in value\\n\\t\\tif(new_i < 0 || new_j < 0 || new_i >= size(mat) || new_j >= size(mat[0]) || mat[new_i][new_j] <= mat[i][j]) continue;\\n\\t\\t// MAX will be updated each time to store maximum of path length from each move\\n\\t\\tMAX = max(MAX, 1 + solve(mat, new_i, new_j));\\n\\t}         \\n\\treturn MAX;\\n}\\n```\n```\\nint moves[4][2] = { {-1,0},{1,0},{0,-1},{0,1} };\\nvector<vector<int> > dp; // dp[i][j] will store maximum path length starting from matrix[i][j]\\nint cnt, n, m;\\nint longestIncreasingPath(vector<vector<int>>& matrix) {\\n\\tmaxPath = 0, n = size(matrix), m = size(matrix[0]);\\n\\tdp.resize(n, vector<int>(m));\\n\\t// calculating maximum path from each cell and at last returning the maximum length\\n\\tfor(int i = 0; i < n; i++)\\n\\t\\tfor(int j = 0; j < m; j++)\\n\\t\\t\\tmaxPath = max(maxPath, solve(matrix, i, j, -1));            \\n\\treturn maxPath;\\n}\\n// recursive solver for each cell with dp for storing each calculated result\\nint solve(vector<vector<int>>& mat, int i, int j, int prev){\\n\\tif(dp[i][j]) return dp[i][j]; // return if result is already calculated\\n\\tdp[i][j] = 1;  // minimum path from each cell is always atleast 1\\n\\t// choosing each possible move available to us\\n\\tfor(int k = 0; k < 4; k++){ \\n\\t\\tint new_i = i + moves[k][0], new_j = j + moves[k][1];\\n\\t\\t// bound checking as well as move to next cell only when it is greater in value\\n\\t\\tif(new_i < 0 || new_j < 0 || new_i >= n || new_j >= m || mat[new_i][new_j] <= mat[i][j]) continue;\\n\\t\\t// max( current optimal, select current + optimal solution after moves[k] from current cell\\n\\t\\tdp[i][j] = max(dp[i][j], 1 + solve(mat, new_i, new_j, mat[i][j]));\\n\\t}         \\n\\treturn dp[i][j];\\n}\\n```\n```\\nint dp[200][200]; // constraints are small enough that we can just set them to MAX\\nint cnt, n, m;\\nint longestIncreasingPath(vector<vector<int>>& matrix) {\\n\\tcnt = 0, n = size(matrix), m = size(matrix[0]);\\n\\tfor(int i = 0; i < n; i++)\\n\\t\\tfor(int j = 0; j < m; j++)\\n\\t\\t\\tcnt = max(cnt, solve(matrix, i, j, -1));            \\n\\treturn cnt;\\n}\\nint solve(vector<vector<int>>& mat, int i, int j, int prev){\\n\\tif(i < 0 || j < 0 || i >= n || j >= m || mat[i][j] <= prev) return 0;\\n\\tif(dp[i][j]) return dp[i][j];\\n\\treturn dp[i][j] = 1 + max({ solve(mat, i + 1, j, mat[i][j]),\\n\\t\\t\\t\\t\\t\\t\\t    solve(mat, i - 1, j, mat[i][j]),\\n\\t\\t\\t\\t\\t\\t\\t    solve(mat, i, j + 1, mat[i][j]),\\n\\t\\t\\t\\t\\t\\t\\t    solve(mat, i, j - 1, mat[i][j]) });       \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1151092,
                "title": "c-easy-memoize-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    int dfs(vector<vector<int>> &mat, int i, int j, int pre) {\\n        if (i < 0 || j < 0 || i == mat.size() || j == mat[0].size() || pre >= mat[i][j])\\n            return 0;\\n        if (dp[i][j]) return dp[i][j];\\n        int l = dfs(mat, i, j - 1, mat[i][j]);\\n        int r = dfs(mat, i, j + 1, mat[i][j]);\\n        int u = dfs(mat, i - 1, j, mat[i][j]);\\n        int d = dfs(mat, i + 1, j, mat[i][j]);\\n        return dp[i][j] = max({l, r, u, d}) + 1;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int maxVal = 0;\\n        for (int i = 0; i < matrix.size(); i++)\\n            for (int j = 0; j < matrix[i].size(); j++)\\n                maxVal = max(maxVal, dfs(matrix, i, j, -1));\\n        return maxVal;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    int dfs(vector<vector<int>> &mat, int i, int j, int pre) {\\n        if (i < 0 || j < 0 || i == mat.size() || j == mat[0].size() || pre >= mat[i][j])\\n            return 0;\\n        if (dp[i][j]) return dp[i][j];\\n        int l = dfs(mat, i, j - 1, mat[i][j]);\\n        int r = dfs(mat, i, j + 1, mat[i][j]);\\n        int u = dfs(mat, i - 1, j, mat[i][j]);\\n        int d = dfs(mat, i + 1, j, mat[i][j]);\\n        return dp[i][j] = max({l, r, u, d}) + 1;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int maxVal = 0;\\n        for (int i = 0; i < matrix.size(); i++)\\n            for (int j = 0; j < matrix[i].size(); j++)\\n                maxVal = max(maxVal, dfs(matrix, i, j, -1));\\n        return maxVal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78336,
                "title": "graph-theory-java-solution-o-v-2-no-dfs",
                "content": "Treat matrix as a graph. Then we find the longest path in graph. In this way, it can be solved in polynomial time. I drew a picture in my blog, check my [blog][1]\\n\\n    public static class Point{\\n        int x;\\n        int y;\\n        public Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n\\n    public static int longestIncreasingPath(int[][] matrix) {\\n        if (matrix == null || matrix.length == 0 || matrix[0] == null || matrix[0].length == 0)\\n            return 0;\\n        int n = matrix.length, m = matrix[0].length, count = m * n, ans = 0;\\n        while (count > 0) {\\n            HashSet<Point> remove = new HashSet<Point>();\\n            // each round, remove the peak number.\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < m; j++) {\\n                    if (matrix[i][j] == Integer.MIN_VALUE)\\n                        continue;\\n                    boolean up = (i == 0 || matrix[i][j] >= matrix[i - 1][j]);\\n                    boolean bottom = (i == n - 1 || matrix[i][j] >= matrix[i + 1][j]);\\n                    boolean left = (j == 0 || matrix[i][j] >= matrix[i][j - 1]);\\n                    boolean right = (j == m - 1 || matrix[i][j] >= matrix[i][j + 1]);\\n                    if (up && bottom && left && right)\\n                        remove.add(new Point(i, j));\\n                }\\n            }\\n            for (Point point : remove) {\\n                matrix[point.x][point.y] = Integer.MIN_VALUE;\\n                count--;\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n\\n  [1]: http://www.allenlipeng47.com/blog/index.php/2016/01/22/longest-increasing-path-in-a-matrix/",
                "solutionTags": [
                    "Graph"
                ],
                "code": "Treat matrix as a graph. Then we find the longest path in graph. In this way, it can be solved in polynomial time. I drew a picture in my blog, check my [blog][1]\\n\\n    public static class Point{\\n        int x;\\n        int y;\\n        public Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n\\n    public static int longestIncreasingPath(int[][] matrix) {\\n        if (matrix == null || matrix.length == 0 || matrix[0] == null || matrix[0].length == 0)\\n            return 0;\\n        int n = matrix.length, m = matrix[0].length, count = m * n, ans = 0;\\n        while (count > 0) {\\n            HashSet<Point> remove = new HashSet<Point>();\\n            // each round, remove the peak number.\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < m; j++) {\\n                    if (matrix[i][j] == Integer.MIN_VALUE)\\n                        continue;\\n                    boolean up = (i == 0 || matrix[i][j] >= matrix[i - 1][j]);\\n                    boolean bottom = (i == n - 1 || matrix[i][j] >= matrix[i + 1][j]);\\n                    boolean left = (j == 0 || matrix[i][j] >= matrix[i][j - 1]);\\n                    boolean right = (j == m - 1 || matrix[i][j] >= matrix[i][j + 1]);\\n                    if (up && bottom && left && right)\\n                        remove.add(new Point(i, j));\\n                }\\n            }\\n            for (Point point : remove) {\\n                matrix[point.x][point.y] = Integer.MIN_VALUE;\\n                count--;\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n\\n  [1]: http://www.allenlipeng47.com/blog/index.php/2016/01/22/longest-increasing-path-in-a-matrix/",
                "codeTag": "Java"
            },
            {
                "id": 402112,
                "title": "python-topological-sorting-on-a-directed-graph",
                "content": "We first build a directed acyclic graph (DAG) with directed edges `(i,j)->(x,y)`, where `(i,j)` and `(x,y)` are neighboring cells in the matrix, and value at `(i,j)` is strictly smaller than the value at `(x,y)`. Then, by topologically sorting this DAG while maintaining `max_path_len`, we can find the longest increasing path.\\n\\n```python\\ndef longestIncreasingPath(self, matrix):\\n\\t# Step 1: build a directed acyclic graph\\n\\tgraph = collections.defaultdict(list)\\n\\tindegree = collections.defaultdict(int)\\n\\tfor i in range(len(matrix)):\\n\\t\\tfor j in range(len(matrix[0])):\\n\\t\\t\\tneighbors = [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]\\n\\t\\t\\tfor x, y in neighbors:\\n\\t\\t\\t\\tif 0<=x<len(matrix) and 0<=y<len(matrix[0]) and matrix[i][j] < matrix[x][y]:\\n\\t\\t\\t\\t\\tgraph[(i,j)].append((x,y))\\n\\t\\t\\t\\t\\tindegree[(x,y)]+=1\\n\\n\\t# Step 2: Topological sorting with Kahn\\'s algorithm\\n\\tqueue = collections.deque([(i, j) for i in range(len(matrix)) for j in range(len(matrix[0])) if (i,j) not in indegree])\\n\\tmax_path_len = 0\\n\\twhile queue:\\n\\t\\tmax_path_len += 1\\n\\t\\tfor _ in range(len(queue)):\\n\\t\\t\\tnode = queue.popleft()\\n\\t\\t\\tfor neigh in graph[node]:\\n\\t\\t\\t\\tindegree[neigh] -= 1\\n\\t\\t\\t\\tif not indegree[neigh]:\\n\\t\\t\\t\\t\\tqueue.append(neigh)\\n\\treturn max_path_len\\n```",
                "solutionTags": [],
                "code": "```python\\ndef longestIncreasingPath(self, matrix):\\n\\t# Step 1: build a directed acyclic graph\\n\\tgraph = collections.defaultdict(list)\\n\\tindegree = collections.defaultdict(int)\\n\\tfor i in range(len(matrix)):\\n\\t\\tfor j in range(len(matrix[0])):\\n\\t\\t\\tneighbors = [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]\\n\\t\\t\\tfor x, y in neighbors:\\n\\t\\t\\t\\tif 0<=x<len(matrix) and 0<=y<len(matrix[0]) and matrix[i][j] < matrix[x][y]:\\n\\t\\t\\t\\t\\tgraph[(i,j)].append((x,y))\\n\\t\\t\\t\\t\\tindegree[(x,y)]+=1\\n\\n\\t# Step 2: Topological sorting with Kahn\\'s algorithm\\n\\tqueue = collections.deque([(i, j) for i in range(len(matrix)) for j in range(len(matrix[0])) if (i,j) not in indegree])\\n\\tmax_path_len = 0\\n\\twhile queue:\\n\\t\\tmax_path_len += 1\\n\\t\\tfor _ in range(len(queue)):\\n\\t\\t\\tnode = queue.popleft()\\n\\t\\t\\tfor neigh in graph[node]:\\n\\t\\t\\t\\tindegree[neigh] -= 1\\n\\t\\t\\t\\tif not indegree[neigh]:\\n\\t\\t\\t\\t\\tqueue.append(neigh)\\n\\treturn max_path_len\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 155469,
                "title": "python-very-simple-dfs-memoization-only-one-dictionary-with-short-explaination",
                "content": "\\'\\'\\' Make a table to keep track of maximum form each node. Apply dfs on each node and collect the max length from all four sides. Increment + 1 while returning and store in the table so that next time it will directly fetch the value from the table\\'\\'\\'\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\n\\tdef __init__(self):\\n\\t  self.max_len = 0\\n\\t  self.table = {}\\n        \\n    def longestIncreasingPath(self, matrix):\\n        def dfs(x, y, prev):\\n            if x < 0 or x >= len(matrix) or y < 0 or y >= len(matrix[0]) or matrix[x][y] <= prev: \\n\\t\\t\\t\\treturn 0\\n            \\n\\t\\t\\tif (x,y) in self.table: \\n\\t\\t\\t\\treturn self.table[(x,y)]\\n            \\n\\t\\t\\tpath = 1 + max(dfs(x+1, y, matrix[x][y]), dfs(x-1, y, matrix[x][y]), dfs(x, y+1, matrix[x][y]), dfs(x, y-1, matrix[x][y]))\\n            \\n\\t\\t\\tself.max_len = max(self.max_len, path)\\n\\t\\t\\tself.table[(x,y)] = path\\n            return path\\n            \\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                dfs(i, j, -sys.maxint)\\n        \\n\\t\\treturn self.max_len",
                "solutionTags": [],
                "code": "\\'\\'\\' Make a table to keep track of maximum form each node. Apply dfs on each node and collect the max length from all four sides. Increment + 1 while returning and store in the table so that next time it will directly fetch the value from the table\\'\\'\\'\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\n\\tdef __init__(self):\\n\\t  self.max_len = 0\\n\\t  self.table = {}\\n        \\n    def longestIncreasingPath(self, matrix):\\n        def dfs(x, y, prev):\\n            if x < 0 or x >= len(matrix) or y < 0 or y >= len(matrix[0]) or matrix[x][y] <= prev: \\n\\t\\t\\t\\treturn 0\\n            \\n\\t\\t\\tif (x,y) in self.table: \\n\\t\\t\\t\\treturn self.table[(x,y)]\\n            \\n\\t\\t\\tpath = 1 + max(dfs(x+1, y, matrix[x][y]), dfs(x-1, y, matrix[x][y]), dfs(x, y+1, matrix[x][y]), dfs(x, y-1, matrix[x][y]))\\n            \\n\\t\\t\\tself.max_len = max(self.max_len, path)\\n\\t\\t\\tself.table[(x,y)] = path\\n            return path\\n            \\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                dfs(i, j, -sys.maxint)\\n        \\n\\t\\treturn self.max_len",
                "codeTag": "Python3"
            },
            {
                "id": 2052444,
                "title": "4-approaches-bfs-memorization-dfs-dp-topo-sorting",
                "content": "[Leetcode](https://leetcode.com/) [329. Longest Increasing Path in a Matrix](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/).\\n\\nHere shows **4** Approaches to slove this problem: BFS, Memorization DFS, DP, Topo Sorting.\\n\\n\\n# BFS\\n\\nThe simplest method that comes to my mind is **BFS**. We start search from each node, spread out like water, to see how far it can flood, and record the maximum flood path length of all nodes.\\n\\n```java\\nclass Solution {\\n    public int longestIncreasingPath(int[][] matrix) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\\n            return 0;\\n        }\\n\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        if (row == 1 && col == 1) {\\n            return 1;\\n        }\\n\\n        int max = 1;\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                max = Math.max(max, bfs(matrix, i, j));\\n            }\\n        }\\n\\n        return max;\\n    }\\n\\n    public int bfs(int[][] matrix, int x, int y) {\\n        int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n\\n        int ans = 0;\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[]{x, y});\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            ans++;\\n\\n            for (int i = 0; i < size; i++) {\\n                int[] curPos = queue.poll();\\n\\n                for (int[] dir : dirs) {\\n                    int nextX = curPos[0] + dir[0];\\n                    int nextY = curPos[1] + dir[1];\\n\\n                    if (nextX < 0 || nextX >= row || nextY < 0 || nextY >= col) {\\n                        continue;\\n                    }\\n\\n                    if (matrix[nextX][nextY] <= matrix[curPos[0]][curPos[1]]) {\\n                        continue;\\n                    }\\n\\n                    queue.offer(new int[]{nextX, nextY});\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(m^2n^2)$.\\n- **Space Complexity**: $O(mn)$.\\n\\n# Memorization DFS\\n\\nIt\\'s easy to figure out that there are some repeated enqueuing in BFS method.\\n\\nTake a example, when searching the longest path of $2$, the longest path of $6$ will also be searched. However, we will search $6$ again as a starting node in BFS. \\n\\n![Grid](https://assets.leetcode.com/uploads/2021/01/05/grid1.jpg)\\n\\nSo how to **prune** the search?\\n\\nIf we search $6$ first and store the result. When search $2$, we can know the result is $len(2) + len(6)$. \\n\\nSo we can use a memory to store the result, use **DFS** to search the longest path of each node. \\n\\n```java\\nclass Solution {\\n    public int longestIncreasingPath(int[][] matrix) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        if (row == 1 && col == 1) {\\n            return 1;\\n        }\\n\\n        int max = 0;\\n        int[][] memo = new int[row][col];\\n\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                if (memo[i][j] == 0) {\\n                    max = Math.max(max, dfs(matrix, memo, i, j));\\n                }\\n            }\\n        }\\n\\n        return max;\\n    }\\n\\n    public int dfs(int[][] matrix, int[][] memo, int x, int y) {\\n        if (memo[x][y] > 0) {\\n            return memo[x][y];\\n        }\\n\\n        int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n\\n        int ans = 1;\\n\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n\\n        for (int[] dir : dirs) {\\n            int nextX = x + dir[0];\\n            int nextY = y + dir[1];\\n\\n            if (nextX < 0 || nextX >= row || nextY < 0 || nextY >= col) {\\n                continue;\\n            }\\n\\n            if (matrix[nextX][nextY] <= matrix[x][y]) {\\n                continue;\\n            }\\n\\n            ans = Math.max(ans, dfs(matrix, memo, nextX, nextY) + 1);\\n        }\\n\\n        memo[x][y] = ans;\\n        return ans;\\n    }\\n}\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(mn)$.\\n- **Space Complexity**: $O(mn)$.\\n\\n# DP\\n\\nWe can also use the **DP** to solve this problem.\\n\\n$dp[i][j]$ means the longest path from the position of $matrix[i][j]$.\\n\\nThe **DP** tranfer equation is as follows:\\n\\n$$\\ndp[i][j] = max(dp[i][j], dp[nextX][nextY] + 1), matrix[nextX][nextY] > matrix[i][j]\\n$$\\n\\n1. At the beginning, all the node is $1$.\\n2. We should search the larger adjacent nodes first.\\n\\n```java\\nclass Solution {\\n    public int longestIncreasingPath(int[][] matrix) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        if (row == 1 && col == 1) {\\n            return 1;\\n        }\\n\\n        int max = 1;\\n\\n        List<int[]> numList = new ArrayList<>();\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                numList.add(new int[]{matrix[i][j], i, j});\\n            }\\n        }\\n\\n        Collections.sort(numList, (o1, o2) -> o2[0] - o1[0]);\\n\\n        int[][] dp = new int[row][col];\\n        for (int i = 0; i < row; i++) {\\n            Arrays.fill(dp[i], 1);\\n        }\\n\\n        int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n\\n        for (int[] item : numList) {\\n            int x = item[1];\\n            int y = item[2];\\n\\n            for (int[] dir : dirs) {\\n                int nextX = x + dir[0];\\n                int nextY = y + dir[1];\\n\\n                if (nextX < 0 || nextX >= row || nextY < 0 || nextY >= col || matrix[nextX][nextY] <= matrix[x][y]) {\\n                    continue;\\n                }\\n\\n                dp[x][y] = Math.max(dp[x][y], dp[nextX][nextY] + 1);\\n            }\\n\\n            max = Math.max(max, dp[x][y]);\\n        }\\n\\n        return max;\\n    }\\n}\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(mnlog(mn)$.\\n- **Space Complexity**: $O(mn)$.\\n\\n# Topo Sorting\\n\\nConsider the matrix as a **directed graph**, and calculate the out-degree corresponding to each cell, how many edges start from the cell. \\n\\nIf the value of a cell is smaller than the value of all adjacent cells, so the out-degree of the cell will increate.\\n\\nWe can solve this problem using topo sorting.\\n\\n```java\\nclass Solution {\\n    public int longestIncreasingPath(int[][] matrix) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        if (row == 1 && col == 1) {\\n            return 1;\\n        }\\n\\n        int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n\\n        int[][] outDegrees = new int[row][col];\\n\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                for (int[] dir : dirs) {\\n                    int nextX = i + dir[0];\\n                    int nextY = j + dir[1];\\n\\n                    if (nextX < 0 || nextX >= row || nextY < 0 || nextY >= col || matrix[nextX][nextY] <= matrix[i][j]) {\\n                        continue;\\n                    }\\n\\n                    outDegrees[i][j]++;\\n                }\\n            }\\n        }\\n\\n        Queue<int[]> queue = new LinkedList<>();\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                if (outDegrees[i][j] == 0) {\\n                    queue.offer(new int[]{i, j});\\n                }\\n            }\\n        }\\n\\n        int max = 0;\\n        while (!queue.isEmpty()) {\\n            max++;\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                int[] curPos = queue.poll();\\n                int x = curPos[0];\\n                int y = curPos[1];\\n                for (int[] dir : dirs) {\\n                    int prevX = x + dir[0];\\n                    int prevY = y + dir[1];\\n\\n                    if (prevX < 0 || prevX >= row || prevY < 0 || prevY >= col) {\\n                        continue;\\n                    }\\n\\n                    if (matrix[prevX][prevY] >= matrix[x][y]) {\\n                        continue;\\n                    }\\n\\n                    if (--outDegrees[prevX][prevY] == 0) {\\n                        queue.offer(new int[]{prevX, prevY});\\n                    }\\n                }\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(mn)$.\\n- **Space Complexity**: $O(mn)$.\\n\\n------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```java\\nclass Solution {\\n    public int longestIncreasingPath(int[][] matrix) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\\n            return 0;\\n        }\\n\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        if (row == 1 && col == 1) {\\n            return 1;\\n        }\\n\\n        int max = 1;\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                max = Math.max(max, bfs(matrix, i, j));\\n            }\\n        }\\n\\n        return max;\\n    }\\n\\n    public int bfs(int[][] matrix, int x, int y) {\\n        int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n\\n        int ans = 0;\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[]{x, y});\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            ans++;\\n\\n            for (int i = 0; i < size; i++) {\\n                int[] curPos = queue.poll();\\n\\n                for (int[] dir : dirs) {\\n                    int nextX = curPos[0] + dir[0];\\n                    int nextY = curPos[1] + dir[1];\\n\\n                    if (nextX < 0 || nextX >= row || nextY < 0 || nextY >= col) {\\n                        continue;\\n                    }\\n\\n                    if (matrix[nextX][nextY] <= matrix[curPos[0]][curPos[1]]) {\\n                        continue;\\n                    }\\n\\n                    queue.offer(new int[]{nextX, nextY});\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int longestIncreasingPath(int[][] matrix) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        if (row == 1 && col == 1) {\\n            return 1;\\n        }\\n\\n        int max = 0;\\n        int[][] memo = new int[row][col];\\n\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                if (memo[i][j] == 0) {\\n                    max = Math.max(max, dfs(matrix, memo, i, j));\\n                }\\n            }\\n        }\\n\\n        return max;\\n    }\\n\\n    public int dfs(int[][] matrix, int[][] memo, int x, int y) {\\n        if (memo[x][y] > 0) {\\n            return memo[x][y];\\n        }\\n\\n        int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n\\n        int ans = 1;\\n\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n\\n        for (int[] dir : dirs) {\\n            int nextX = x + dir[0];\\n            int nextY = y + dir[1];\\n\\n            if (nextX < 0 || nextX >= row || nextY < 0 || nextY >= col) {\\n                continue;\\n            }\\n\\n            if (matrix[nextX][nextY] <= matrix[x][y]) {\\n                continue;\\n            }\\n\\n            ans = Math.max(ans, dfs(matrix, memo, nextX, nextY) + 1);\\n        }\\n\\n        memo[x][y] = ans;\\n        return ans;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int longestIncreasingPath(int[][] matrix) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        if (row == 1 && col == 1) {\\n            return 1;\\n        }\\n\\n        int max = 1;\\n\\n        List<int[]> numList = new ArrayList<>();\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                numList.add(new int[]{matrix[i][j], i, j});\\n            }\\n        }\\n\\n        Collections.sort(numList, (o1, o2) -> o2[0] - o1[0]);\\n\\n        int[][] dp = new int[row][col];\\n        for (int i = 0; i < row; i++) {\\n            Arrays.fill(dp[i], 1);\\n        }\\n\\n        int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n\\n        for (int[] item : numList) {\\n            int x = item[1];\\n            int y = item[2];\\n\\n            for (int[] dir : dirs) {\\n                int nextX = x + dir[0];\\n                int nextY = y + dir[1];\\n\\n                if (nextX < 0 || nextX >= row || nextY < 0 || nextY >= col || matrix[nextX][nextY] <= matrix[x][y]) {\\n                    continue;\\n                }\\n\\n                dp[x][y] = Math.max(dp[x][y], dp[nextX][nextY] + 1);\\n            }\\n\\n            max = Math.max(max, dp[x][y]);\\n        }\\n\\n        return max;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int longestIncreasingPath(int[][] matrix) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        if (row == 1 && col == 1) {\\n            return 1;\\n        }\\n\\n        int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n\\n        int[][] outDegrees = new int[row][col];\\n\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                for (int[] dir : dirs) {\\n                    int nextX = i + dir[0];\\n                    int nextY = j + dir[1];\\n\\n                    if (nextX < 0 || nextX >= row || nextY < 0 || nextY >= col || matrix[nextX][nextY] <= matrix[i][j]) {\\n                        continue;\\n                    }\\n\\n                    outDegrees[i][j]++;\\n                }\\n            }\\n        }\\n\\n        Queue<int[]> queue = new LinkedList<>();\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                if (outDegrees[i][j] == 0) {\\n                    queue.offer(new int[]{i, j});\\n                }\\n            }\\n        }\\n\\n        int max = 0;\\n        while (!queue.isEmpty()) {\\n            max++;\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                int[] curPos = queue.poll();\\n                int x = curPos[0];\\n                int y = curPos[1];\\n                for (int[] dir : dirs) {\\n                    int prevX = x + dir[0];\\n                    int prevY = y + dir[1];\\n\\n                    if (prevX < 0 || prevX >= row || prevY < 0 || prevY >= col) {\\n                        continue;\\n                    }\\n\\n                    if (matrix[prevX][prevY] >= matrix[x][y]) {\\n                        continue;\\n                    }\\n\\n                    if (--outDegrees[prevX][prevY] == 0) {\\n                        queue.offer(new int[]{prevX, prevY});\\n                    }\\n                }\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78341,
                "title": "simple-c-solution",
                "content": "    class Solution {\\n    public:\\n        int DFS(vector<vector<int>>& matrix, int y, int x, int val, vector<vector<int>>& hash)\\n        {\\n            if(y < 0 || y >= matrix.size() || x <0 || x >= matrix[0].size())\\n                return 0;\\n            if(matrix[y][x] > val)\\n            {\\n                if(hash[y][x] != 0) return hash[y][x]; //if this path has been searched\\n                int a = DFS(matrix, y, x+1,matrix[y][x], hash) + 1;\\n                int b = DFS(matrix, y, x-1,matrix[y][x], hash) + 1;\\n                int c = DFS(matrix, y+1, x,matrix[y][x], hash) + 1;\\n                int d = DFS(matrix, y-1, x,matrix[y][x], hash) + 1;\\n                hash[y][x] = max(a, max(b,max(c, d)));\\n                return hash[y][x];\\n            }\\n            return 0;\\n        }\\n        int longestIncreasingPath(vector<vector<int>>& matrix) {\\n            if(matrix.size() == 0) return 0;\\n            int Max = 0;\\n            vector<int> tem(matrix[0].size(),0);\\n            vector<vector<int>> hash(matrix.size(), tem);\\n            for(int i = 0; i< matrix.size(); i++)\\n                for(int j = 0; j < matrix[0].size(); j++)\\n                    Max = max(DFS(matrix, i, j, INT_MIN, hash), Max);\\n            return Max;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int DFS(vector<vector<int>>& matrix, int y, int x, int val, vector<vector<int>>& hash)\\n        {\\n            if(y < 0 || y >= matrix.size() || x <0 || x >= matrix[0].size())\\n                return 0;\\n            if(matrix[y][x] > val)\\n            {\\n                if(hash[y][x] != 0) return hash[y][x]; //if this path has been searched\\n                int a = DFS(matrix, y, x+1,matrix[y][x], hash) + 1;\\n                int b = DFS(matrix, y, x-1,matrix[y][x], hash) + 1;\\n                int c = DFS(matrix, y+1, x,matrix[y][x], hash) + 1;\\n                int d = DFS(matrix, y-1, x,matrix[y][x], hash) + 1;\\n                hash[y][x] = max(a, max(b,max(c, d)));\\n                return hash[y][x];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2053151,
                "title": "c-dp-clean-memoization",
                "content": "* Start DFS from every index of matrix if it is not already processed i.e. ` dp[i][j]==-1`.\\n* During DFS, move to each valid index in the matrix and determine the maximum depth to which you can go.\\n* Store your answers at every index of matrix in vector `dp` for optimisation.\\n* TC : **O(M*N)**\\n* SC: **O(M*N)**\\n```\\nclass Solution {\\npublic:\\n    \\n    bool checkLimits(int i, int j, int n, int m){\\n        \\n        return (i>=0 and i<n and j>=0 and j<m);\\n        \\n        \\n    }\\n    \\n    int func(vector<vector<int>> &matrix, vector<vector<int>> &dp, int i, int j, int n, int m){\\n        \\n        if(!checkLimits(i, j, n, m)) return 0;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int c1 = 0, c2 = 0, c3 = 0, c4 =0;\\n        \\n        if(checkLimits(i+1, j, n, m) and matrix[i+1][j]>matrix[i][j]){\\n            c1 = func(matrix, dp, i+1, j, n, m);\\n        }\\n        \\n        if(checkLimits(i-1, j, n, m) and matrix[i-1][j]>matrix[i][j]){\\n            c2 = func(matrix, dp, i-1, j, n, m);\\n        }\\n        \\n        if(checkLimits(i, j+1, n, m) and matrix[i][j+1]>matrix[i][j]){\\n            c3 = func(matrix, dp, i, j+1, n, m);\\n        }\\n        \\n        if(checkLimits(i, j-1, n, m) and matrix[i][j-1]>matrix[i][j]){\\n            c4 = func(matrix, dp, i, j-1, n, m);\\n        }\\n        \\n        dp[i][j] = 1 + max(c1, max(c2, max(c3, c4)));\\n        \\n        return dp[i][j];        \\n        \\n    }\\n    \\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        \\n        int n = matrix.size(), m = matrix[0].size();\\n        int ans = 1;\\n        vector<vector<int>> dp(n, vector<int> (m, -1));\\n        \\n        for(int i = 0; i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(dp[i][j]==-1){\\n                    ans = max(ans, func(matrix, dp, i, j, n, m));\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool checkLimits(int i, int j, int n, int m){\\n        \\n        return (i>=0 and i<n and j>=0 and j<m);\\n        \\n        \\n    }\\n    \\n    int func(vector<vector<int>> &matrix, vector<vector<int>> &dp, int i, int j, int n, int m){\\n        \\n        if(!checkLimits(i, j, n, m)) return 0;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int c1 = 0, c2 = 0, c3 = 0, c4 =0;\\n        \\n        if(checkLimits(i+1, j, n, m) and matrix[i+1][j]>matrix[i][j]){\\n            c1 = func(matrix, dp, i+1, j, n, m);\\n        }\\n        \\n        if(checkLimits(i-1, j, n, m) and matrix[i-1][j]>matrix[i][j]){\\n            c2 = func(matrix, dp, i-1, j, n, m);\\n        }\\n        \\n        if(checkLimits(i, j+1, n, m) and matrix[i][j+1]>matrix[i][j]){\\n            c3 = func(matrix, dp, i, j+1, n, m);\\n        }\\n        \\n        if(checkLimits(i, j-1, n, m) and matrix[i][j-1]>matrix[i][j]){\\n            c4 = func(matrix, dp, i, j-1, n, m);\\n        }\\n        \\n        dp[i][j] = 1 + max(c1, max(c2, max(c3, c4)));\\n        \\n        return dp[i][j];        \\n        \\n    }\\n    \\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        \\n        int n = matrix.size(), m = matrix[0].size();\\n        int ans = 1;\\n        vector<vector<int>> dp(n, vector<int> (m, -1));\\n        \\n        for(int i = 0; i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(dp[i][j]==-1){\\n                    ans = max(ans, func(matrix, dp, i, j, n, m));\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997533,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int m, n;\\n    short path[200][200];\\n    \\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        m = matrix.size();\\n        n = matrix[0].size();\\n\\n        memset(path, 0, sizeof(path));\\n    \\n        int max_path = 1;\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                max_path = max(max_path, dfs(i, j, matrix));\\n\\n        return max_path;\\n    }\\n\\n    int dfs(int i, int j, vector<vector<int>>& mat) {\\n        if(path[i][j] >   0) return path[i][j];\\n        if(path[i][j] == -1) return 0;\\n        int max_next = 0;\\n        path[i][j] = -1;\\n        if(i > 0   && mat[i][j] < mat[i-1][j]) max_next = max(max_next, dfs(i-1, j, mat));\\n        if(j > 0   && mat[i][j] < mat[i][j-1]) max_next = max(max_next, dfs(i, j-1, mat));\\n        if(i < m-1 && mat[i][j] < mat[i+1][j]) max_next = max(max_next, dfs(i+1, j, mat));\\n        if(j < n-1 && mat[i][j] < mat[i][j+1]) max_next = max(max_next, dfs(i, j+1, mat));\\n        return path[i][j] = 1 + max_next;\\n    }\\n\\npublic:\\n    Solution() {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        wcin.tie(nullptr);\\n        cerr.tie(nullptr);\\n        wcerr.tie(nullptr);\\n        clog.tie(nullptr);\\n        wclog.tie(nullptr);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        if not matrix or not matrix[0]:\\n            return 0\\n        rows, cols = len(matrix), len(matrix[0])\\n        dp =[[0] * cols for i in range(rows)]\\n        def dfs(i, j):\\n            if not dp[i][j]:\\n                val = matrix[i][j]\\n                dp[i][j] = 1 + max(\\n                    dfs(i - 1, j) if i and val > matrix[i - 1][j] else 0,\\n                    dfs(i + 1, j) if i < rows - 1 and val > matrix[i + 1][j] else 0,\\n                    dfs(i, j - 1) if j and val > matrix[i][j - 1] else 0,\\n                    dfs(i, j + 1) if j < cols - 1 and val > matrix[i][j + 1] else 0)\\n            return dp[i][j]\\n        \\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r,c)\\n        return max(max(x) for x in dp)\\n```\\n\\n```Java []\\nclass Solution {\\n    public int longestIncreasingPath(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int[][] dp = new int[m][n];\\n        for (int d[] : dp) Arrays.fill(d, -1);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (dp[i][j] == -1) dfs(matrix, dp, m, n, i, j, -1);\\n            }\\n        }\\n        int max = Integer.MIN_VALUE;\\n        for (int[] d : dp) {\\n            for (int i : d) max = Math.max(i, max);\\n        }\\n        return max;\\n    }\\n\\n    public int dfs(\\n        int[][] matrix,\\n        int[][] dp,\\n        int m,\\n        int n,\\n        int i,\\n        int j,\\n        int parent\\n    ) {\\n        if (\\n            i >= m || j >= n || i < 0 || j < 0 || matrix[i][j] <= parent\\n        ) return 0;\\n        parent = matrix[i][j];\\n        if (dp[i][j] != -1) return dp[i][j];\\n        int left = dfs(matrix, dp, m, n, i, j - 1, parent);\\n        int right = dfs(matrix, dp, m, n, i, j + 1, parent);\\n        int bottom = dfs(matrix, dp, m, n, i + 1, j, parent);\\n        int top = dfs(matrix, dp, m, n, i - 1, j, parent);\\n        dp[i][j] = 1 + Math.max(Math.max(left, right), Math.max(top, bottom));\\n        return dp[i][j];\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int m, n;\\n    short path[200][200];\\n    \\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        m = matrix.size();\\n        n = matrix[0].size();\\n\\n        memset(path, 0, sizeof(path));\\n    \\n        int max_path = 1;\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                max_path = max(max_path, dfs(i, j, matrix));\\n\\n        return max_path;\\n    }\\n\\n    int dfs(int i, int j, vector<vector<int>>& mat) {\\n        if(path[i][j] >   0) return path[i][j];\\n        if(path[i][j] == -1) return 0;\\n        int max_next = 0;\\n        path[i][j] = -1;\\n        if(i > 0   && mat[i][j] < mat[i-1][j]) max_next = max(max_next, dfs(i-1, j, mat));\\n        if(j > 0   && mat[i][j] < mat[i][j-1]) max_next = max(max_next, dfs(i, j-1, mat));\\n        if(i < m-1 && mat[i][j] < mat[i+1][j]) max_next = max(max_next, dfs(i+1, j, mat));\\n        if(j < n-1 && mat[i][j] < mat[i][j+1]) max_next = max(max_next, dfs(i, j+1, mat));\\n        return path[i][j] = 1 + max_next;\\n    }\\n\\npublic:\\n    Solution() {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        wcin.tie(nullptr);\\n        cerr.tie(nullptr);\\n        wcerr.tie(nullptr);\\n        clog.tie(nullptr);\\n        wclog.tie(nullptr);\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        if not matrix or not matrix[0]:\\n            return 0\\n        rows, cols = len(matrix), len(matrix[0])\\n        dp =[[0] * cols for i in range(rows)]\\n        def dfs(i, j):\\n            if not dp[i][j]:\\n                val = matrix[i][j]\\n                dp[i][j] = 1 + max(\\n                    dfs(i - 1, j) if i and val > matrix[i - 1][j] else 0,\\n                    dfs(i + 1, j) if i < rows - 1 and val > matrix[i + 1][j] else 0,\\n                    dfs(i, j - 1) if j and val > matrix[i][j - 1] else 0,\\n                    dfs(i, j + 1) if j < cols - 1 and val > matrix[i][j + 1] else 0)\\n            return dp[i][j]\\n        \\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r,c)\\n        return max(max(x) for x in dp)\\n```\n```Java []\\nclass Solution {\\n    public int longestIncreasingPath(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int[][] dp = new int[m][n];\\n        for (int d[] : dp) Arrays.fill(d, -1);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (dp[i][j] == -1) dfs(matrix, dp, m, n, i, j, -1);\\n            }\\n        }\\n        int max = Integer.MIN_VALUE;\\n        for (int[] d : dp) {\\n            for (int i : d) max = Math.max(i, max);\\n        }\\n        return max;\\n    }\\n\\n    public int dfs(\\n        int[][] matrix,\\n        int[][] dp,\\n        int m,\\n        int n,\\n        int i,\\n        int j,\\n        int parent\\n    ) {\\n        if (\\n            i >= m || j >= n || i < 0 || j < 0 || matrix[i][j] <= parent\\n        ) return 0;\\n        parent = matrix[i][j];\\n        if (dp[i][j] != -1) return dp[i][j];\\n        int left = dfs(matrix, dp, m, n, i, j - 1, parent);\\n        int right = dfs(matrix, dp, m, n, i, j + 1, parent);\\n        int bottom = dfs(matrix, dp, m, n, i + 1, j, parent);\\n        int top = dfs(matrix, dp, m, n, i - 1, j, parent);\\n        dp[i][j] = 1 + Math.max(Math.max(left, right), Math.max(top, bottom));\\n        return dp[i][j];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1375981,
                "title": "generic-dfs-template-how-to-solve-dfs-based-problems",
                "content": "In a generic DFS problem, we look for a starting point and from there we look for an end target position to reach. \\n\\n`How is this question different than other DFS based problems ?`\\n\\nIn this, from a current cell we have to go in each direction and look for the maximum path length from all the possible directions we could go, right !\\n\\n# The template : \\nHere is the basic template that I use for solving the DFS problems : \\n```\\nBasic DFS Template : \\n1. Check when to apply DFS ( i.e. the valid position(/s) to start )\\n2. Writing dfs() : \\n\\t\\ta. base condition (`checking through isSafe()`)\\n\\t\\tb. main logic ( `traverse to all possible directions, if it isSafe `)\\n\\nNow, writing isSafe function could be a bit tricky but I will try to make it simple.\\n`At each step ( cell ) ask whether the current cell will help you to go ahead in dfs )` and based on this, the isSafe() would be implemented.\\n\\n```\\nFor example : \\n\\nThe question : \\nhttps://leetcode.com/problems/flood-fill/\\n\\nThe code : \\n```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        if(image == null || image.length == 0) return image;\\n        int rows = image.length;\\n        int cols = image[0].length;\\n        \\n        if(image[sr][sc] == newColor) return image;\\n        \\n\\t\\t// Step1 : CHECK WHEN TO APPLY DFS\\n        dfs(image, sr, sc, image[sr][sc], newColor, rows, cols);\\n\\n        return image;\\n    }\\n    private void dfs(int[][] image, int i, int j, int val, int newColor, int rows, int cols) {\\n        \\n        boolean isCurrentCellSafe = isSafe(image, i, j, val, rows, cols);\\n\\n        if(isCurrentCellSafe) {\\n            image[i][j] = newColor;\\n            dfs(image, i+1, j, val, newColor, rows, cols);\\n            dfs(image, i-1, j, val, newColor, rows, cols);\\n            dfs(image, i, j+1, val, newColor, rows, cols);\\n            dfs(image, i, j-1, val, newColor, rows, cols);\\n        }\\n    } \\n\\t// isSafe()\\n    private boolean isSafe(int[][] image, int i, int j, int val, int rows, int cols) {\\n        if(i>=0 && i<rows && j>=0 && j<cols && image[i][j] == val) return true;\\n        return false;\\n    }\\n}\\n```\\n\\n\\nFor the current question, the code is a bit different as I mentioned above. \\nAlso, we could remove the dp/memoized part for the time-being (` but it will give TLE` ) that is the basic reason I added the memoized code. ( and frankly speaking, this is the first question where I had to use memoization ) \\n\\n**What\\'s so different about this question though ?**\\n\\nIts important to mention that for most of dfs questions we do not add memoization upon a DFS. Normally when we could move to 4 directions, there would be cycle so we could not memoize the result. However since this question is strictly increasing, thus it is a DAG.\\n\\n\\nTC : `O(n * m)`\\nSC : `O(n * m)` \\n\\n****\\n```\\n\\nclass Solution {\\n    public int longestIncreasingPath(int[][] matrix) {\\n        if(matrix == null || matrix.length == 0) return 0;\\n        \\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n        int maxLength = 0;\\n        \\n\\t\\t// memoization\\n        int[][]dp = new int[rows+1][cols+1];\\n        for(int[] row : dp) {\\n            Arrays.fill(row, -1);\\n        }\\n        \\n\\t\\t// check when to apply DFS\\n        for(int i=0;i<rows;i++) {\\n            for(int j=0;j<cols;j++) {\\n                maxLength = Math.max(maxLength, dfs(matrix, dp, i, j, rows, cols, Integer.MIN_VALUE));\\n            }\\n        }\\n        \\n        return maxLength;\\n    }\\n    private int dfs(int[][] matrix, int[][]dp, int i, int j, int rows, int cols, int compareWith) {\\n        \\n        boolean isCurrentCellSafe = isSafe(matrix, i, j, compareWith);\\n    \\n        int result = 0;\\n\\n        if(isCurrentCellSafe) {\\n            \\n            if(dp[i][j] != -1) return dp[i][j];\\n            \\n            int ch = matrix[i][j];\\n            matrix[i][j] = -1;\\n            \\n            // Go in each direction, and check which path yields the maximum length path\\n            // This is giving TLE, so we will have to memoize the code\\n\\n            int d = dfs(matrix, dp, i+1, j, rows, cols, ch) ;\\n            int u = dfs(matrix, dp, i-1, j, rows, cols, ch) ;\\n            int r = dfs(matrix, dp, i, j+1, rows, cols, ch) ;\\n            int l = dfs(matrix, dp, i, j-1, rows, cols, ch) ;\\n            \\n            // adding 1, to include the current cell in the path\\n\\n            result = 1 + Math.max(Math.max(d,u), Math.max(l,r));\\n            matrix[i][j] = ch;\\n            \\n            dp[i][j] = result;\\n        }\\n        return result;\\n    }\\n    private boolean isSafe(int[][]matrix, int i, int j, int cw) {\\n        if(i>=0 && i<matrix.length && j>=0 && j<matrix[0].length && matrix[i][j] > cw && cw!=-1) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n\\nHope this helps you with the basic idea of solving the DFS based questions. \\n\\nIn general, this is the DFS template that would work in most/many questions with slight modifications.\\n\\n**Please upvote if this helped you !**",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nBasic DFS Template : \\n1. Check when to apply DFS ( i.e. the valid position(/s) to start )\\n2. Writing dfs() : \\n\\t\\ta. base condition (`checking through isSafe()`)\\n\\t\\tb. main logic ( `traverse to all possible directions, if it isSafe `)\\n\\nNow, writing isSafe function could be a bit tricky but I will try to make it simple.\\n`At each step ( cell ) ask whether the current cell will help you to go ahead in dfs )` and based on this, the isSafe() would be implemented.\\n\\n```\n```\\nclass Solution {\\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\\n        if(image == null || image.length == 0) return image;\\n        int rows = image.length;\\n        int cols = image[0].length;\\n        \\n        if(image[sr][sc] == newColor) return image;\\n        \\n\\t\\t// Step1 : CHECK WHEN TO APPLY DFS\\n        dfs(image, sr, sc, image[sr][sc], newColor, rows, cols);\\n\\n        return image;\\n    }\\n    private void dfs(int[][] image, int i, int j, int val, int newColor, int rows, int cols) {\\n        \\n        boolean isCurrentCellSafe = isSafe(image, i, j, val, rows, cols);\\n\\n        if(isCurrentCellSafe) {\\n            image[i][j] = newColor;\\n            dfs(image, i+1, j, val, newColor, rows, cols);\\n            dfs(image, i-1, j, val, newColor, rows, cols);\\n            dfs(image, i, j+1, val, newColor, rows, cols);\\n            dfs(image, i, j-1, val, newColor, rows, cols);\\n        }\\n    } \\n\\t// isSafe()\\n    private boolean isSafe(int[][] image, int i, int j, int val, int rows, int cols) {\\n        if(i>=0 && i<rows && j>=0 && j<cols && image[i][j] == val) return true;\\n        return false;\\n    }\\n}\\n```\n```\\n\\nclass Solution {\\n    public int longestIncreasingPath(int[][] matrix) {\\n        if(matrix == null || matrix.length == 0) return 0;\\n        \\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n        int maxLength = 0;\\n        \\n\\t\\t// memoization\\n        int[][]dp = new int[rows+1][cols+1];\\n        for(int[] row : dp) {\\n            Arrays.fill(row, -1);\\n        }\\n        \\n\\t\\t// check when to apply DFS\\n        for(int i=0;i<rows;i++) {\\n            for(int j=0;j<cols;j++) {\\n                maxLength = Math.max(maxLength, dfs(matrix, dp, i, j, rows, cols, Integer.MIN_VALUE));\\n            }\\n        }\\n        \\n        return maxLength;\\n    }\\n    private int dfs(int[][] matrix, int[][]dp, int i, int j, int rows, int cols, int compareWith) {\\n        \\n        boolean isCurrentCellSafe = isSafe(matrix, i, j, compareWith);\\n    \\n        int result = 0;\\n\\n        if(isCurrentCellSafe) {\\n            \\n            if(dp[i][j] != -1) return dp[i][j];\\n            \\n            int ch = matrix[i][j];\\n            matrix[i][j] = -1;\\n            \\n            // Go in each direction, and check which path yields the maximum length path\\n            // This is giving TLE, so we will have to memoize the code\\n\\n            int d = dfs(matrix, dp, i+1, j, rows, cols, ch) ;\\n            int u = dfs(matrix, dp, i-1, j, rows, cols, ch) ;\\n            int r = dfs(matrix, dp, i, j+1, rows, cols, ch) ;\\n            int l = dfs(matrix, dp, i, j-1, rows, cols, ch) ;\\n            \\n            // adding 1, to include the current cell in the path\\n\\n            result = 1 + Math.max(Math.max(d,u), Math.max(l,r));\\n            matrix[i][j] = ch;\\n            \\n            dp[i][j] = result;\\n        }\\n        return result;\\n    }\\n    private boolean isSafe(int[][]matrix, int i, int j, int cw) {\\n        if(i>=0 && i<matrix.length && j>=0 && j<matrix[0].length && matrix[i][j] > cw && cw!=-1) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78375,
                "title": "easy-java-solution",
                "content": "    public class Solution {\\n    \\n    \\tpublic int longestIncreasingPath(int[][] matrix) {\\n    \\n    \\t\\tif (matrix == null || matrix.length < 1 || matrix[0].length < 1)\\n    \\t\\t\\treturn 0;\\n    \\n    \\t\\tint max = 0, n = matrix.length, m = matrix[0].length;\\n    \\n    \\t\\t// create a cache matrix\\n    \\t\\tint[][] cache = new int[n][m];\\n    \\n    \\t\\t// dfs search on every element in matrix\\n    \\t\\tfor (int i = 0; i < n; i++) {\\n    \\t\\t\\tfor (int j = 0; j < m; j++) {\\n    \\t\\t\\t\\tmax = Math.max(dfs(matrix, Integer.MIN_VALUE, i, j, n, m, cache), max);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn max;\\n    \\t}\\n    \\n    \\tint dfs(int[][] matrix, int min, int i, int j, int n, int m, int[][] cache) {\\n    \\n    \\t\\t// check boundary limits\\n    \\t\\tif (i < 0 || j < 0 || i >= n || j >= m)\\n    \\t\\t\\treturn 0;\\n    \\n    \\t\\t// check min condition\\n    \\t\\tif (matrix[i][j] <= min)\\n    \\t\\t\\treturn 0;\\n    \\n    \\t\\t// check into cache\\n    \\t\\tif (cache[i][j] != 0)\\n    \\t\\t\\treturn cache[i][j];\\n    \\n    \\t\\t// update min\\n    \\t\\tmin = matrix[i][j];\\n    \\n    \\t\\t// run dfs in all four directions\\n    \\t\\tint a = dfs(matrix, min, i - 1, j, n, m, cache) + 1;\\n    \\t\\tint b = dfs(matrix, min, i + 1, j, n, m, cache) + 1;\\n    \\t\\tint c = dfs(matrix, min, i, j - 1, n, m, cache) + 1;\\n    \\t\\tint d = dfs(matrix, min, i, j + 1, n, m, cache) + 1;\\n    \\n    \\t\\t// find max and update cache\\n    \\t\\tint max = Math.max(a, Math.max(b, Math.max(c, d)));\\n    \\t\\tcache[i][j] = max;\\n    \\n    \\t\\treturn max;\\n    \\t}\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    \\tpublic int longestIncreasingPath(int[][] matrix) {\\n    \\n    \\t\\tif (matrix == null || matrix.length < 1 || matrix[0].length < 1)\\n    \\t\\t\\treturn 0;\\n    \\n    \\t\\tint max = 0, n = matrix.length, m = matrix[0].length;\\n    \\n    \\t\\t// create a cache matrix\\n    \\t\\tint[][] cache = new int[n][m];\\n    \\n    \\t\\t// dfs search on every element in matrix\\n    \\t\\tfor (int i = 0; i < n; i++) {\\n    \\t\\t\\tfor (int j = 0; j < m; j++) {\\n    \\t\\t\\t\\tmax = Math.max(dfs(matrix, Integer.MIN_VALUE, i, j, n, m, cache), max);\\n    \\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1151293,
                "title": "js-python-java-c-recursive-dfs-memoization-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe naive approach here would be to iterate through the entire matrix (**M**) and attempt to traverse down each branching path, but we\\'d find ourselves repeating the same stretches of path over and over again.\\n\\nRather than having to repeat subproblems, we should cache those completed subproblem results for future use in a **memoization** data structure (**memo**). Since the paths can branch at any location, we should also use a **depth-first search** (**DFS**) approach with **recursion** to efficiently traverse the paths.\\n\\n(_**Note**: It is possible to use a bottom-up **dynamic programming** (**DP**) approach here as well, but since there\\'s no convenient fixed point bottom location, we\\'d have to use a **max-heap** **priority queue** in order to traverse **M** in proper bottom-up order. That would push the **time complexity** to **O(N * M * log(N * M))**, so the memoization code is more efficient._)\\n\\nSo we can just iterate through every cell in **M** and run our recursive helper (**dfs**) which will fill in values in **memo** as it returns. For a given cell, if that cell\\'s solution has already been found, we can **return** it, otherwise we\\'ll take the best result of each of the four possible path directions.\\n\\nOnce the main iteration has finished, the highest value in **memo** will be our answer. so we should **return** it.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nPython can make good use of **@lru_cache** instead of having to manually create a memoization data structure.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **88ms / 41.1MB** (beats 100% / 100%).\\n```javascript\\nvar longestIncreasingPath = function(M) {\\n    let ylen = M.length, xlen = M[0].length, ans = 0,\\n        memo = Array.from({length: ylen}, el => new Uint16Array(xlen))\\n    const dfs = (y, x) => {\\n        if (memo[y][x]) return memo[y][x]\\n        let val = M[y][x]\\n        memo[y][x] = 1 + Math.max(\\n            y < ylen - 1 && M[y+1][x] < val ? dfs(y+1,x) : 0,\\n            y > 0 && M[y-1][x] < val ? dfs(y-1,x) : 0,\\n            x < xlen - 1 && M[y][x+1] < val ? dfs(y,x+1) : 0,\\n            x > 0 && M[y][x-1] < val ? dfs(y,x-1) : 0)\\n        return memo[y][x]\\n    }\\n    for (let i = 0; i < ylen; i++)\\n        for (let j = 0; j < xlen; j++)\\n            ans = Math.max(ans, dfs(i, j))\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **320ms / 18.7MB** (beats 100% / 22%).\\n```python\\nclass Solution:\\n    def longestIncreasingPath(self, M: List[List[int]]) -> int:\\n        ylen, xlen = len(M), len(M[0])\\n        @lru_cache(maxsize=None)\\n        def dfs(y, x):\\n            val = M[y][x]\\n            return 1 + max(\\n                dfs(y+1,x) if y < ylen - 1 and val > M[y+1][x] else 0,\\n                dfs(y-1,x) if y > 0 and val > M[y-1][x] else 0, \\n                dfs(y,x+1) if x < xlen - 1 and val > M[y][x+1] else 0,\\n                dfs(y,x-1) if x > 0 and val > M[y][x-1] else 0)\\n        return max(dfs(y, x) for y in range(ylen) for x in range(xlen))\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **5ms / 38.7MB** (beats 100% / 99%).\\n```java\\nclass Solution {\\n    public int longestIncreasingPath(int[][] M) {\\n        int ylen = M.length, xlen = M[0].length, ans = 0;\\n        int[][] memo = new int[ylen][xlen];\\n        for (int i = 0; i < ylen; i++)\\n            for (int j = 0; j < xlen; j++)\\n                ans = Math.max(ans, dfs(i,j,M,memo));\\n        return ans;\\n    }\\n    public int dfs(int y, int x, int[][] M, int[][] memo) {\\n        if (memo[y][x] > 0) return memo[y][x];\\n        int val = M[y][x];\\n        memo[y][x] = 1 + Math.max(\\n            Math.max(y < M.length - 1 && M[y+1][x] < val ? dfs(y+1,x,M,memo) : 0,\\n                     y > 0 && M[y-1][x] < val ? dfs(y-1,x,M,memo) : 0),\\n            Math.max(x < M[0].length - 1 && M[y][x+1] < val ? dfs(y,x+1,M,memo) : 0,\\n                     x > 0 && M[y][x-1] < val ? dfs(y,x-1,M,memo) : 0));\\n        return memo[y][x];\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **24ms / 14.7MB** (beats 100% / 99%).\\n```c++\\nclass Solution {\\npublic:\\n    int memo[200][200];\\n    \\n    int longestIncreasingPath(vector<vector<int>>& M) {\\n        int ylen = M.size(), xlen = M[0].size(), ans = 0;\\n        for (int i = 0; i < ylen; i++)\\n            for (int j = 0; j < xlen; j++)\\n                ans = max(ans, dfs(i,j,M));\\n        return ans;\\n    }\\n    int dfs(int y, int x, vector<vector<int>>& M) {\\n        if (memo[y][x]) return memo[y][x];\\n        int val = M[y][x];\\n        memo[y][x] = 1 + max(\\n            max(y < M.size() - 1 && M[y+1][x] < val ? dfs(y+1,x,M) : 0,\\n                y > 0 && M[y-1][x] < val ? dfs(y-1,x,M) : 0),\\n            max(x < M[0].size() - 1 && M[y][x+1] < val ? dfs(y,x+1,M) : 0,\\n                x > 0 && M[y][x-1] < val ? dfs(y,x-1,M) : 0));\\n        return memo[y][x];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar longestIncreasingPath = function(M) {\\n    let ylen = M.length, xlen = M[0].length, ans = 0,\\n        memo = Array.from({length: ylen}, el => new Uint16Array(xlen))\\n    const dfs = (y, x) => {\\n        if (memo[y][x]) return memo[y][x]\\n        let val = M[y][x]\\n        memo[y][x] = 1 + Math.max(\\n            y < ylen - 1 && M[y+1][x] < val ? dfs(y+1,x) : 0,\\n            y > 0 && M[y-1][x] < val ? dfs(y-1,x) : 0,\\n            x < xlen - 1 && M[y][x+1] < val ? dfs(y,x+1) : 0,\\n            x > 0 && M[y][x-1] < val ? dfs(y,x-1) : 0)\\n        return memo[y][x]\\n    }\\n    for (let i = 0; i < ylen; i++)\\n        for (let j = 0; j < xlen; j++)\\n            ans = Math.max(ans, dfs(i, j))\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def longestIncreasingPath(self, M: List[List[int]]) -> int:\\n        ylen, xlen = len(M), len(M[0])\\n        @lru_cache(maxsize=None)\\n        def dfs(y, x):\\n            val = M[y][x]\\n            return 1 + max(\\n                dfs(y+1,x) if y < ylen - 1 and val > M[y+1][x] else 0,\\n                dfs(y-1,x) if y > 0 and val > M[y-1][x] else 0, \\n                dfs(y,x+1) if x < xlen - 1 and val > M[y][x+1] else 0,\\n                dfs(y,x-1) if x > 0 and val > M[y][x-1] else 0)\\n        return max(dfs(y, x) for y in range(ylen) for x in range(xlen))\\n```\n```java\\nclass Solution {\\n    public int longestIncreasingPath(int[][] M) {\\n        int ylen = M.length, xlen = M[0].length, ans = 0;\\n        int[][] memo = new int[ylen][xlen];\\n        for (int i = 0; i < ylen; i++)\\n            for (int j = 0; j < xlen; j++)\\n                ans = Math.max(ans, dfs(i,j,M,memo));\\n        return ans;\\n    }\\n    public int dfs(int y, int x, int[][] M, int[][] memo) {\\n        if (memo[y][x] > 0) return memo[y][x];\\n        int val = M[y][x];\\n        memo[y][x] = 1 + Math.max(\\n            Math.max(y < M.length - 1 && M[y+1][x] < val ? dfs(y+1,x,M,memo) : 0,\\n                     y > 0 && M[y-1][x] < val ? dfs(y-1,x,M,memo) : 0),\\n            Math.max(x < M[0].length - 1 && M[y][x+1] < val ? dfs(y,x+1,M,memo) : 0,\\n                     x > 0 && M[y][x-1] < val ? dfs(y,x-1,M,memo) : 0));\\n        return memo[y][x];\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int memo[200][200];\\n    \\n    int longestIncreasingPath(vector<vector<int>>& M) {\\n        int ylen = M.size(), xlen = M[0].size(), ans = 0;\\n        for (int i = 0; i < ylen; i++)\\n            for (int j = 0; j < xlen; j++)\\n                ans = max(ans, dfs(i,j,M));\\n        return ans;\\n    }\\n    int dfs(int y, int x, vector<vector<int>>& M) {\\n        if (memo[y][x]) return memo[y][x];\\n        int val = M[y][x];\\n        memo[y][x] = 1 + max(\\n            max(y < M.size() - 1 && M[y+1][x] < val ? dfs(y+1,x,M) : 0,\\n                y > 0 && M[y-1][x] < val ? dfs(y-1,x,M) : 0),\\n            max(x < M[0].size() - 1 && M[y][x+1] < val ? dfs(y,x+1,M) : 0,\\n                x > 0 && M[y][x-1] < val ? dfs(y,x-1,M) : 0));\\n        return memo[y][x];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1151187,
                "title": "python-short-dfs-with-lru-cache-explained",
                "content": "This problem is dynamic programming problem, the problem is to understand how to traverse our matrix. Actually we can look at this problem as directed graph, and the goal is to find the longest path. One way to do it is to use bfs, where we start from all nodes with outgoing degree equel to `0` and then traverse all nodes from which we can reach these nodes and so on. Another way is to use dynamic programming (sometimes it is called memoisation here, because it is not the usual way to traverse elements), but in fact it is just usual dynamic programming.\\n\\n1. Let `dfs(x, y)` be an answer for cell with coordinates `(x, y)`. In the beginning we define it as `1`: there is a path of length `1` for sure.\\n2. Then we check all neighbours and check answers for them and if we can continue path, we update `ans`. \\n3. In the end we check values for all cells and return the maximum one.\\n\\nNotice, how short and clean you code will be when we use memoisation here, we do not need to bother where to start our traversal, in the end we always reach bottom nodes and they will be traversed first.\\n\\n#### Complexity\\nTime complexity is just `O(mn)`, because we have this number of states and for each state we have at most `4` transitions. Space complexity is the same.\\n\\n#### Code\\n```\\nclass Solution:\\n    def longestIncreasingPath(self, matrix):\\n        m, n = len(matrix), len(matrix[0])\\n        neibs = [(0, -1), (0, 1), (1, 0), (-1, 0)]\\n        \\n        @lru_cache(None)\\n        def dfs(x, y):\\n            ans = 1\\n            for dx, dy in neibs:\\n                if 0 <= x+dx < m and 0 <= y+dy <n and matrix[x+dx][y+dy] < matrix[x][y]:\\n                    ans = max(ans, dfs(x+dx, y+dy) + 1) \\n            return ans\\n        \\n        return max(dfs(i, j) for i, j in product(range(m), range(n)))\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def longestIncreasingPath(self, matrix):\\n        m, n = len(matrix), len(matrix[0])\\n        neibs = [(0, -1), (0, 1), (1, 0), (-1, 0)]\\n        \\n        @lru_cache(None)\\n        def dfs(x, y):\\n            ans = 1\\n            for dx, dy in neibs:\\n                if 0 <= x+dx < m and 0 <= y+dy <n and matrix[x+dx][y+dy] < matrix[x][y]:\\n                    ans = max(ans, dfs(x+dx, y+dy) + 1) \\n            return ans\\n        \\n        return max(dfs(i, j) for i, j in product(range(m), range(n)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1151294,
                "title": "longest-increasing-path-in-a-matrix-js-python-java-c-recursive-dfs-memo-solution-w-explan",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe naive approach here would be to iterate through the entire matrix (**M**) and attempt to traverse down each branching path, but we\\'d find ourselves repeating the same stretches of path over and over again.\\n\\nRather than having to repeat subproblems, we should cache those completed subproblem results for future use in a **memoization** data structure (**memo**). Since the paths can branch at any location, we should also use a **depth-first search** (**DFS**) approach with **recursion** to efficiently traverse the paths.\\n\\n(_**Note**: It is possible to use a bottom-up **dynamic programming** (**DP**) approach here as well, but since there\\'s no convenient fixed point bottom location, we\\'d have to use a **max-heap** **priority queue** in order to traverse **M** in proper bottom-up order. That would push the **time complexity** to **O(N * M * log(N * M))**, so the memoization code is more efficient._)\\n\\nSo we can just iterate through every cell in **M** and run our recursive helper (**dfs**) which will fill in values in **memo** as it returns. For a given cell, if that cell\\'s solution has already been found, we can **return** it, otherwise we\\'ll take the best result of each of the four possible path directions.\\n\\nOnce the main iteration has finished, the highest value in **memo** will be our answer. so we should **return** it.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nPython can make good use of **@lru_cache** instead of having to manually create a memoization data structure.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **88ms / 41.1MB** (beats 100% / 100%).\\n```javascript\\nvar longestIncreasingPath = function(M) {\\n    let ylen = M.length, xlen = M[0].length, ans = 0,\\n        memo = Array.from({length: ylen}, el => new Uint16Array(xlen))\\n    const dfs = (y, x) => {\\n        if (memo[y][x]) return memo[y][x]\\n        let val = M[y][x]\\n        memo[y][x] = 1 + Math.max(\\n            y < ylen - 1 && M[y+1][x] < val ? dfs(y+1,x) : 0,\\n            y > 0 && M[y-1][x] < val ? dfs(y-1,x) : 0,\\n            x < xlen - 1 && M[y][x+1] < val ? dfs(y,x+1) : 0,\\n            x > 0 && M[y][x-1] < val ? dfs(y,x-1) : 0)\\n        return memo[y][x]\\n    }\\n    for (let i = 0; i < ylen; i++)\\n        for (let j = 0; j < xlen; j++)\\n            ans = Math.max(ans, dfs(i, j))\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **320ms / 18.7MB** (beats 100% / 22%).\\n```python\\nclass Solution:\\n    def longestIncreasingPath(self, M: List[List[int]]) -> int:\\n        ylen, xlen = len(M), len(M[0])\\n        @lru_cache(maxsize=None)\\n        def dfs(y, x):\\n            val = M[y][x]\\n            return 1 + max(\\n                dfs(y+1,x) if y < ylen - 1 and val > M[y+1][x] else 0,\\n                dfs(y-1,x) if y > 0 and val > M[y-1][x] else 0, \\n                dfs(y,x+1) if x < xlen - 1 and val > M[y][x+1] else 0,\\n                dfs(y,x-1) if x > 0 and val > M[y][x-1] else 0)\\n        return max(dfs(y, x) for y in range(ylen) for x in range(xlen))\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **5ms / 38.7MB** (beats 100% / 99%).\\n```java\\nclass Solution {\\n    public int longestIncreasingPath(int[][] M) {\\n        int ylen = M.length, xlen = M[0].length, ans = 0;\\n        int[][] memo = new int[ylen][xlen];\\n        for (int i = 0; i < ylen; i++)\\n            for (int j = 0; j < xlen; j++)\\n                ans = Math.max(ans, dfs(i,j,M,memo));\\n        return ans;\\n    }\\n    public int dfs(int y, int x, int[][] M, int[][] memo) {\\n        if (memo[y][x] > 0) return memo[y][x];\\n        int val = M[y][x];\\n        memo[y][x] = 1 + Math.max(\\n            Math.max(y < M.length - 1 && M[y+1][x] < val ? dfs(y+1,x,M,memo) : 0,\\n                     y > 0 && M[y-1][x] < val ? dfs(y-1,x,M,memo) : 0),\\n            Math.max(x < M[0].length - 1 && M[y][x+1] < val ? dfs(y,x+1,M,memo) : 0,\\n                     x > 0 && M[y][x-1] < val ? dfs(y,x-1,M,memo) : 0));\\n        return memo[y][x];\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **24ms / 14.7MB** (beats 100% / 99%).\\n```c++\\nclass Solution {\\npublic:\\n    int memo[200][200];\\n    \\n    int longestIncreasingPath(vector<vector<int>>& M) {\\n        int ylen = M.size(), xlen = M[0].size(), ans = 0;\\n        for (int i = 0; i < ylen; i++)\\n            for (int j = 0; j < xlen; j++)\\n                ans = max(ans, dfs(i,j,M));\\n        return ans;\\n    }\\n    int dfs(int y, int x, vector<vector<int>>& M) {\\n        if (memo[y][x]) return memo[y][x];\\n        int val = M[y][x];\\n        memo[y][x] = 1 + max(\\n            max(y < M.size() - 1 && M[y+1][x] < val ? dfs(y+1,x,M) : 0,\\n                y > 0 && M[y-1][x] < val ? dfs(y-1,x,M) : 0),\\n            max(x < M[0].size() - 1 && M[y][x+1] < val ? dfs(y,x+1,M) : 0,\\n                x > 0 && M[y][x-1] < val ? dfs(y,x-1,M) : 0));\\n        return memo[y][x];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar longestIncreasingPath = function(M) {\\n    let ylen = M.length, xlen = M[0].length, ans = 0,\\n        memo = Array.from({length: ylen}, el => new Uint16Array(xlen))\\n    const dfs = (y, x) => {\\n        if (memo[y][x]) return memo[y][x]\\n        let val = M[y][x]\\n        memo[y][x] = 1 + Math.max(\\n            y < ylen - 1 && M[y+1][x] < val ? dfs(y+1,x) : 0,\\n            y > 0 && M[y-1][x] < val ? dfs(y-1,x) : 0,\\n            x < xlen - 1 && M[y][x+1] < val ? dfs(y,x+1) : 0,\\n            x > 0 && M[y][x-1] < val ? dfs(y,x-1) : 0)\\n        return memo[y][x]\\n    }\\n    for (let i = 0; i < ylen; i++)\\n        for (let j = 0; j < xlen; j++)\\n            ans = Math.max(ans, dfs(i, j))\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def longestIncreasingPath(self, M: List[List[int]]) -> int:\\n        ylen, xlen = len(M), len(M[0])\\n        @lru_cache(maxsize=None)\\n        def dfs(y, x):\\n            val = M[y][x]\\n            return 1 + max(\\n                dfs(y+1,x) if y < ylen - 1 and val > M[y+1][x] else 0,\\n                dfs(y-1,x) if y > 0 and val > M[y-1][x] else 0, \\n                dfs(y,x+1) if x < xlen - 1 and val > M[y][x+1] else 0,\\n                dfs(y,x-1) if x > 0 and val > M[y][x-1] else 0)\\n        return max(dfs(y, x) for y in range(ylen) for x in range(xlen))\\n```\n```java\\nclass Solution {\\n    public int longestIncreasingPath(int[][] M) {\\n        int ylen = M.length, xlen = M[0].length, ans = 0;\\n        int[][] memo = new int[ylen][xlen];\\n        for (int i = 0; i < ylen; i++)\\n            for (int j = 0; j < xlen; j++)\\n                ans = Math.max(ans, dfs(i,j,M,memo));\\n        return ans;\\n    }\\n    public int dfs(int y, int x, int[][] M, int[][] memo) {\\n        if (memo[y][x] > 0) return memo[y][x];\\n        int val = M[y][x];\\n        memo[y][x] = 1 + Math.max(\\n            Math.max(y < M.length - 1 && M[y+1][x] < val ? dfs(y+1,x,M,memo) : 0,\\n                     y > 0 && M[y-1][x] < val ? dfs(y-1,x,M,memo) : 0),\\n            Math.max(x < M[0].length - 1 && M[y][x+1] < val ? dfs(y,x+1,M,memo) : 0,\\n                     x > 0 && M[y][x-1] < val ? dfs(y,x-1,M,memo) : 0));\\n        return memo[y][x];\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int memo[200][200];\\n    \\n    int longestIncreasingPath(vector<vector<int>>& M) {\\n        int ylen = M.size(), xlen = M[0].size(), ans = 0;\\n        for (int i = 0; i < ylen; i++)\\n            for (int j = 0; j < xlen; j++)\\n                ans = max(ans, dfs(i,j,M));\\n        return ans;\\n    }\\n    int dfs(int y, int x, vector<vector<int>>& M) {\\n        if (memo[y][x]) return memo[y][x];\\n        int val = M[y][x];\\n        memo[y][x] = 1 + max(\\n            max(y < M.size() - 1 && M[y+1][x] < val ? dfs(y+1,x,M) : 0,\\n                y > 0 && M[y-1][x] < val ? dfs(y-1,x,M) : 0),\\n            max(x < M[0].size() - 1 && M[y][x+1] < val ? dfs(y,x+1,M) : 0,\\n                x > 0 && M[y][x-1] < val ? dfs(y,x-1,M) : 0));\\n        return memo[y][x];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 425023,
                "title": "python-dfs-w-memoization-easy-to-understand",
                "content": "Keep track of the longest path for each coordinates that we\\'ve already visited in a cache. If we encounter them again in the future we can just do a O(1) lookup in the cache. \\n```\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        if not matrix:\\n            return 0\\n        \\n        longest_path = 0\\n        rows = len(matrix)\\n        cols = len(matrix[0])\\n        cache = [[None] * cols for _ in range(rows)]\\n        \\n        def dfs(x: int, y: int) -> int:\\n            if cache[x][y]:\\n                return cache[x][y]\\n            longest_path = 0\\n            for i, j in [(0,1),(0,-1),(1,0),(-1,0)]:\\n                newX, newY = x+i, y+j\\n                if newX >= 0 and newX < rows and newY >= 0 and newY < cols and matrix[newX][newY] > matrix[x][y]:\\n                    longest_path = max(longest_path, dfs(newX, newY))\\n            cache[x][y] = longest_path + 1\\n            return cache[x][y]\\n        \\n        for x in range(rows):\\n            for y in range(cols):\\n                longest_path = max(longest_path, dfs(x, y))\\n        \\n        return longest_path\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        if not matrix:\\n            return 0\\n        \\n        longest_path = 0\\n        rows = len(matrix)\\n        cols = len(matrix[0])\\n        cache = [[None] * cols for _ in range(rows)]\\n        \\n        def dfs(x: int, y: int) -> int:\\n            if cache[x][y]:\\n                return cache[x][y]\\n            longest_path = 0\\n            for i, j in [(0,1),(0,-1),(1,0),(-1,0)]:\\n                newX, newY = x+i, y+j\\n                if newX >= 0 and newX < rows and newY >= 0 and newY < cols and matrix[newX][newY] > matrix[x][y]:\\n                    longest_path = max(longest_path, dfs(newX, newY))\\n            cache[x][y] = longest_path + 1\\n            return cache[x][y]\\n        \\n        for x in range(rows):\\n            for y in range(cols):\\n                longest_path = max(longest_path, dfs(x, y))\\n        \\n        return longest_path\\n```",
                "codeTag": "Java"
            },
            {
                "id": 144558,
                "title": "java-bfs-topological-sort",
                "content": "Inspired by this [C++ post](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/discuss/78354/C++-use-BFS-topologic-template-standard-and-easy-to-understand), translated into Java version. The idea behind it is [BFS Topological Sort: Kahn\\'s Algorithm](https://en.wikipedia.org/wiki/Topological_sorting)\\n```\\nclass Solution {\\n    // Topological sorting : BFS   \\n    // if the problem changes to find longest **non-decreasing** path, topological sorting will not work.\\n    // e.x   2 2\\n    //       3 4    \\n    // 2 and 2 both have outdeg == 1. there is no outdeg == 0 nodes in matrix.\\n    private static final int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    private int m, n;\\n    public int longestIncreasingPath(int[][] matrix) {\\n        // input validation\\n        if (matrix == null || matrix.length == 0) \\n            return 0;\\n        // bfs starting from nodes with indegree as 0\\n        m = matrix.length; n = matrix[0].length;\\n        int[][] indegree = new int[m][n];\\n        Queue<int[]> q = new LinkedList();\\n        for (int row = 0; row < m; row++) {\\n            for (int col = 0; col < n; col++) {\\n                for(int i = 0; i < 4; i++) {\\n                    int nextRow = row + dirs[i][0];\\n                    int nextCol = col + dirs[i][1];\\n                    if (nextRow >= 0 && nextRow < m && nextCol >= 0 && nextCol < n && \\n                        matrix[row][col] > matrix[nextRow][nextCol]) {\\n                        indegree[row][col]++;\\n                    }\\n                }\\n                if (indegree[row][col] == 0) q.offer(new int[]{row, col});\\n            }\\n        }\\n        // process graph layer-by-layer\\n        int len = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            while (size-- > 0) { // consume all nodes in cur layer and add next layer into queue\\n                int[] coord = q.poll();\\n                int row = coord[0], col = coord[1];\\n                for(int i = 0; i < 4; i++) {\\n                    int nextRow = row + dirs[i][0];\\n                    int nextCol = col + dirs[i][1];\\n                    if (nextRow >= 0 && nextRow < m && nextCol >= 0 && nextCol < n && \\n                        matrix[row][col] < matrix[nextRow][nextCol]) {\\n                        if (--indegree[nextRow][nextCol] == 0)     // remove edge\\n                            q.offer(new int[]{nextRow, nextCol});  // add as next level node\\n                    }\\n                }\\n            }\\n            len++; // at the end of each layer, increase the length\\n        }\\n        return len;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // Topological sorting : BFS   \\n    // if the problem changes to find longest **non-decreasing** path, topological sorting will not work.\\n    // e.x   2 2\\n    //       3 4    \\n    // 2 and 2 both have outdeg == 1. there is no outdeg == 0 nodes in matrix.\\n    private static final int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    private int m, n;\\n    public int longestIncreasingPath(int[][] matrix) {\\n        // input validation\\n        if (matrix == null || matrix.length == 0) \\n            return 0;\\n        // bfs starting from nodes with indegree as 0\\n        m = matrix.length; n = matrix[0].length;\\n        int[][] indegree = new int[m][n];\\n        Queue<int[]> q = new LinkedList();\\n        for (int row = 0; row < m; row++) {\\n            for (int col = 0; col < n; col++) {\\n                for(int i = 0; i < 4; i++) {\\n                    int nextRow = row + dirs[i][0];\\n                    int nextCol = col + dirs[i][1];\\n                    if (nextRow >= 0 && nextRow < m && nextCol >= 0 && nextCol < n && \\n                        matrix[row][col] > matrix[nextRow][nextCol]) {\\n                        indegree[row][col]++;\\n                    }\\n                }\\n                if (indegree[row][col] == 0) q.offer(new int[]{row, col});\\n            }\\n        }\\n        // process graph layer-by-layer\\n        int len = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            while (size-- > 0) { // consume all nodes in cur layer and add next layer into queue\\n                int[] coord = q.poll();\\n                int row = coord[0], col = coord[1];\\n                for(int i = 0; i < 4; i++) {\\n                    int nextRow = row + dirs[i][0];\\n                    int nextCol = col + dirs[i][1];\\n                    if (nextRow >= 0 && nextRow < m && nextCol >= 0 && nextCol < n && \\n                        matrix[row][col] < matrix[nextRow][nextCol]) {\\n                        if (--indegree[nextRow][nextCol] == 0)     // remove edge\\n                            q.offer(new int[]{nextRow, nextCol});  // add as next level node\\n                    }\\n                }\\n            }\\n            len++; // at the end of each layer, increase the length\\n        }\\n        return len;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2052285,
                "title": "c-dp-dfs",
                "content": "Solved live on stream everyday 6pm.  Come join us.  Link in profile\\n\\n```\\nclass Solution {\\n    \\n    vector<vector<int>> dirs = {\\n            {-1,0},\\n    {0,-1},        {0,1},\\n            {1,0}\\n    };\\n    \\n    int dfs(vector<vector<int>>& matrix, int r, int c, vector<vector<int>>& dp, int prev) {\\n        if(r < 0 || r >= matrix.size()) return 0;\\n        if(c < 0 || c >= matrix[r].size()) return 0;\\n        if(matrix[r][c] <= prev) return 0;\\n        \\n        if(dp[r][c] != -1) return dp[r][c];\\n        int best = 0;\\n        \\n        for(auto& dir : dirs) {\\n            int nr = dir[0] + r;\\n            int nc = dir[1] + c;\\n            int cur = dfs(matrix, nr, nc, dp, matrix[r][c]);\\n            best = max(best, cur);\\n        }\\n        \\n        return dp[r][c] = best + 1;\\n    }\\n    \\npublic:\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int ROWS = matrix.size();\\n        int COLS = matrix[0].size();\\n        \\n        vector<vector<int>> dp(ROWS, vector<int>(COLS, -1));\\n        \\n        int ans = 0;\\n        \\n        for(int r = 0; r < ROWS; r++) {\\n            for(int c = 0; c < COLS; c++) {\\n                int lip = dfs(matrix, r, c, dp, -1000000);\\n                ans = max(ans, lip);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    vector<vector<int>> dirs = {\\n            {-1,0},\\n    {0,-1},        {0,1},\\n            {1,0}\\n    };\\n    \\n    int dfs(vector<vector<int>>& matrix, int r, int c, vector<vector<int>>& dp, int prev) {\\n        if(r < 0 || r >= matrix.size()) return 0;\\n        if(c < 0 || c >= matrix[r].size()) return 0;\\n        if(matrix[r][c] <= prev) return 0;\\n        \\n        if(dp[r][c] != -1) return dp[r][c];\\n        int best = 0;\\n        \\n        for(auto& dir : dirs) {\\n            int nr = dir[0] + r;\\n            int nc = dir[1] + c;\\n            int cur = dfs(matrix, nr, nc, dp, matrix[r][c]);\\n            best = max(best, cur);\\n        }\\n        \\n        return dp[r][c] = best + 1;\\n    }\\n    \\npublic:\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int ROWS = matrix.size();\\n        int COLS = matrix[0].size();\\n        \\n        vector<vector<int>> dp(ROWS, vector<int>(COLS, -1));\\n        \\n        int ans = 0;\\n        \\n        for(int r = 0; r < ROWS; r++) {\\n            for(int c = 0; c < COLS; c++) {\\n                int lip = dfs(matrix, r, c, dp, -1000000);\\n                ans = max(ans, lip);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 242278,
                "title": "python-solution",
                "content": "DFS + memoization: Time complexity: `O(n^2*m^2)`, space complexity: `O(nm)`.\\n\\n```\\nclass Solution(object):\\n    def longestIncreasingPath(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        def dfs(i, j):\\n            if dp[i][j] != 0:\\n                return dp[i][j]\\n            dirs = {(i-1,j), (i+1,j), (i,j-1), (i,j+1)}\\n            for x, y in dirs:\\n                if 0 <= x < n and 0 <= y < m:\\n                    if matrix[x][y] > matrix[i][j]:\\n                        dp[i][j] = max(dp[i][j], dfs(x, y))\\n            dp[i][j] += 1\\n            return dp[i][j]\\n        \\n        if not matrix or not matrix[0]:\\n            return 0\\n        res = 0\\n        n = len(matrix)\\n        m = len(matrix[0])\\n        dp = [[0]*m for _ in range(n)]\\n        for i in range(n):\\n            for j in range(m):\\n                res = max(res, dfs(i, j))\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def longestIncreasingPath(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        def dfs(i, j):\\n            if dp[i][j] != 0:\\n                return dp[i][j]\\n            dirs = {(i-1,j), (i+1,j), (i,j-1), (i,j+1)}\\n            for x, y in dirs:\\n                if 0 <= x < n and 0 <= y < m:\\n                    if matrix[x][y] > matrix[i][j]:\\n                        dp[i][j] = max(dp[i][j], dfs(x, y))\\n            dp[i][j] += 1\\n            return dp[i][j]\\n        \\n        if not matrix or not matrix[0]:\\n            return 0\\n        res = 0\\n        n = len(matrix)\\n        m = len(matrix[0])\\n        dp = [[0]*m for _ in range(n)]\\n        for i in range(n):\\n            for j in range(m):\\n                res = max(res, dfs(i, j))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225388,
                "title": "easy-c-solution-dfs-memoization-hard-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt can be solved by using Simple DFS Algorithm.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nChoose every element of the matrix as a starting point and apply the DFS algorithm in which we check the maximum possible length of the increasing path through a particular starting point, now we take the the maximum of the all possible paths. This might give a TLE . SO, SIMPLE MEMOIZATION CAN BE DONE FOR THE SAME CODE!! \\n# Complexity\\n- Time complexity: $$O(N*M)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: $$O(N*M)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fun(int row, int col, vector<vector<int>> & mat, vector<vector<int>> & dp) {\\n        int n = mat.size(),m = mat[0].size();\\n        int delrow[] = {-1,0,1,0};\\n        int delcol[] = {0,1,0,-1};\\n        int maxim = 0;\\n        if(dp[row][col] != -1)\\n        return dp[row][col];\\n        for(int i = 0;i < 4;i++) {\\n            int drow=delrow[i] + row;\\n            int dcol=delcol[i] + col;\\n            if(drow >= 0 && dcol >= 0 && drow < n && dcol < m && mat[drow][dcol] > mat[row][col]) {\\n                maxim = max(maxim , 1 + fun(drow,dcol,mat,dp));\\n            }\\n        }\\n        return dp[row][col] = maxim;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n = matrix.size(),m = matrix[0].size();\\n        vector<vector<int>> dp(n,vector<int> (m,-1));\\n        int ans = 0;\\n        for(int i = 0;i < n;i++) {\\n            for(int j = 0;j < m;j++) {\\n                ans=max(ans,fun(i,j,matrix,dp));\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```\\nPLEASE UPVOTE IF IT HELPED !! :)",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(int row, int col, vector<vector<int>> & mat, vector<vector<int>> & dp) {\\n        int n = mat.size(),m = mat[0].size();\\n        int delrow[] = {-1,0,1,0};\\n        int delcol[] = {0,1,0,-1};\\n        int maxim = 0;\\n        if(dp[row][col] != -1)\\n        return dp[row][col];\\n        for(int i = 0;i < 4;i++) {\\n            int drow=delrow[i] + row;\\n            int dcol=delcol[i] + col;\\n            if(drow >= 0 && dcol >= 0 && drow < n && dcol < m && mat[drow][dcol] > mat[row][col]) {\\n                maxim = max(maxim , 1 + fun(drow,dcol,mat,dp));\\n            }\\n        }\\n        return dp[row][col] = maxim;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n = matrix.size(),m = matrix[0].size();\\n        vector<vector<int>> dp(n,vector<int> (m,-1));\\n        int ans = 0;\\n        for(int i = 0;i < n;i++) {\\n            for(int j = 0;j < m;j++) {\\n                ans=max(ans,fun(i,j,matrix,dp));\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2052493,
                "title": "c-solution-dp-memoization",
                "content": "Idea: We will Just use recursion to let longest length of every element for first time and then store it in 2D array and use it.\\n```\\nclass Solution {\\npublic:\\n    int help(vector<vector<int>>& matrix, int i, int j, vector<vector<int>>& h)\\n    {\\n        if(h[i][j] != -1) return h[i][j];\\n        int x[] = {0,0,1,-1};\\n        int y[] = {1,-1,0,0};\\n        int tmp_ans = 0;\\n        for(int n = 0; n < 4; n++)\\n        {\\n            int new_i = x[n] + i;\\n            int new_j = y[n] + j;\\n            if(new_i >= 0 && new_j >= 0 && new_i < matrix.size() && new_j < matrix[i].size()) \\n            {\\n                if(matrix[new_i][new_j] > matrix[i][j])\\n                tmp_ans = max(tmp_ans,1+help(matrix,new_i,new_j,h));\\n            }\\n        }\\n        h[i][j] = tmp_ans;\\n        return h[i][j];\\n    }\\n    \\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        vector<vector<int>> h (matrix.size(),vector<int>(matrix[0].size(),-1));\\n        \\n        \\n        \\n        int ans = 0;\\n        for(int i = 0; i < matrix.size(); i++)\\n        {\\n            for(int j = 0; j < matrix[0].size(); j++)\\n            {\\n               ans = max(ans,1+help(matrix,i,j,h));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**If Helps Upvote**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int help(vector<vector<int>>& matrix, int i, int j, vector<vector<int>>& h)\\n    {\\n        if(h[i][j] != -1) return h[i][j];\\n        int x[] = {0,0,1,-1};\\n        int y[] = {1,-1,0,0};\\n        int tmp_ans = 0;\\n        for(int n = 0; n < 4; n++)\\n        {\\n            int new_i = x[n] + i;\\n            int new_j = y[n] + j;\\n            if(new_i >= 0 && new_j >= 0 && new_i < matrix.size() && new_j < matrix[i].size()) \\n            {\\n                if(matrix[new_i][new_j] > matrix[i][j])\\n                tmp_ans = max(tmp_ans,1+help(matrix,new_i,new_j,h));\\n            }\\n        }\\n        h[i][j] = tmp_ans;\\n        return h[i][j];\\n    }\\n    \\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        vector<vector<int>> h (matrix.size(),vector<int>(matrix[0].size(),-1));\\n        \\n        \\n        \\n        int ans = 0;\\n        for(int i = 0; i < matrix.size(); i++)\\n        {\\n            for(int j = 0; j < matrix[0].size(); j++)\\n            {\\n               ans = max(ans,1+help(matrix,i,j,h));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1045570,
                "title": "python-top-down-dp-2-steps",
                "content": "Questions are welcome.\\n\\n**Approach:**\\n\\n1. Convert the matrix into graph **g**.\\n**g[i][j]** contains a list of neighboring positions\\nthat have a larger value than **matrix[i][j]**\\n\\n2. Recursively explore all possible paths from each location.\\nThe **helper** function tries exploring all possible neighbors\\nof position (i, j) and returns the longest path.  If position (i, j)\\nhas no neighbors that are larger than it, return 1 because the\\nlongest path from the current position is just the position itself.\\n\\n**Optimization:**\\n\\nMemoization is added to the helper function in the form of a wrapper **@functools.lru_cache**.  \\nThis means if we already know the longest path from position (i, j) is 5 we can return 5 immediately\\nwithout spending the effort to calculate the longest path when we visit position (i, j) a second or third time.  \\n\\nAt the cost of readability, one could also reduce the graph creation process by only checking the neighbor\\nabove and the neighbor to the left, then **g[i][j].append((r, c))** if matrix[r][c] is **greater than** matrix[i][j] and\\n**g[r][c].append((i, j))** if matrix[r][c] is **less than** matrix[i][j].  \\n\\n<br>\\n\\n```python\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        R, C = len(matrix), len(matrix[0])\\n        g = [[[] for _ in range(C)] for _ in range(R)]\\n        for i in range(R):\\n            for j in range(C):\\n                for (r, c) in ((i+1, j), (i-1, j), (i, j+1), (i, j-1)):\\n                    if 0 <= r < R and 0 <= c < C and matrix[r][c] > matrix[i][j]:\\n                        g[i][j].append((r,c))\\n                        \\n        @functools.lru_cache(None)\\n        def helper(i, j):\\n            return 1 + max(helper(r, c) for r, c in g[i][j]) if g[i][j] else 1\\n        \\n        return max(helper(i, j) for i in range(R) for j in range(C))\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```python\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        R, C = len(matrix), len(matrix[0])\\n        g = [[[] for _ in range(C)] for _ in range(R)]\\n        for i in range(R):\\n            for j in range(C):\\n                for (r, c) in ((i+1, j), (i-1, j), (i, j+1), (i, j-1)):\\n                    if 0 <= r < R and 0 <= c < C and matrix[r][c] > matrix[i][j]:\\n                        g[i][j].append((r,c))\\n                        \\n        @functools.lru_cache(None)\\n        def helper(i, j):\\n            return 1 + max(helper(r, c) for r, c in g[i][j]) if g[i][j] else 1\\n        \\n        return max(helper(i, j) for i in range(R) for j in range(C))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78433,
                "title": "my-dp-solution-with-explanation-search-nearby-using-dfs-o-mn-easy-to-read",
                "content": "The question is just a 2 dimensional version of LIS. We can use brute force, but it is too costful. By storing the longest number of increasing subsequence starting from the node (i,j) in a 2d array, we can effectively prune many redundant recursive computations (although it's a dfs).  \\n\\n    int longestpath(vector<vector<int>>& matrix, vector<vector<int>>& states, int i, int j, int m, int n) {\\n        if(states[i][j] > 0)\\n            return states[i][j];\\n        \\n        int maxd = 0;\\n        \\n        if(j>0 && matrix[i][j-1] < matrix[i][j]) {\\n            int left = longestpath(matrix, states, i, j-1, m, n);\\n            maxd = max(maxd, left); \\n        }\\n        if(j<n-1 && matrix[i][j+1] < matrix[i][j]) {\\n            \\n            int right = longestpath(matrix, states, i, j+1, m, n);\\n            maxd = max(maxd, right);\\n        };\\n        if(i>0 && matrix[i-1][j] < matrix[i][j]) {\\n            int up = longestpath(matrix, states, i-1, j, m, n);\\n            maxd = max(maxd, up);\\n            \\n        };\\n        if(i<m-1 && matrix[i+1][j] < matrix[i][j]) {\\n            int down = longestpath(matrix, states, i+1, j, m, n);\\n            maxd = max(maxd, down);\\n        };\\n        \\n        states[i][j] = maxd + 1;\\n        return states[i][j];\\n        \\n    }\\n\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        \\n        \\n        int m = matrix.size(); \\n        if (m == 0) return 0;\\n        int n = matrix[0].size();\\n        int res = 0;\\n        \\n        vector<vector<int>> states(m, vector<int>(n, 0));\\n        \\n        for(int i = 0; i < m; ++ i) {\\n            \\n            for(int j = 0; j < n; ++ j) {\\n             //each element\\n             \\n             res = max(res, longestpath(matrix, states, i, j, m, n));\\n\\n            }\\n            \\n        }\\n        \\n        return res;        \\n        \\n    }",
                "solutionTags": [],
                "code": "The question is just a 2 dimensional version of LIS. We can use brute force, but it is too costful. By storing the longest number of increasing subsequence starting from the node (i,j) in a 2d array, we can effectively prune many redundant recursive computations (although it's a dfs).  \\n\\n    int longestpath(vector<vector<int>>& matrix, vector<vector<int>>& states, int i, int j, int m, int n) {\\n        if(states[i][j] > 0)\\n            return states[i][j];\\n        \\n        int maxd = 0;\\n        \\n        if(j>0 && matrix[i][j-1] < matrix[i][j]) {\\n            int left = longestpath(matrix, states, i, j-1, m, n);\\n            maxd = max(maxd, left); \\n        }\\n        if(j<n-1 && matrix[i][j+1] < matrix[i][j]) {\\n            \\n            int right = longestpath(matrix, states, i, j+1, m, n);\\n            maxd = max(maxd, right);\\n        };\\n        if(i>0 && matrix[i-1][j] < matrix[i][j]) {\\n            int up = longestpath(matrix, states, i-1, j, m, n);\\n            maxd = max(maxd, up);\\n            \\n        };\\n        if(i<m-1 && matrix[i+1][j] < matrix[i][j]) {\\n            int down = longestpath(matrix, states, i+1, j, m, n);\\n            maxd = max(maxd, down);\\n        };\\n        \\n        states[i][j] = maxd + 1;\\n        return states[i][j];\\n        \\n    }\\n\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        \\n        \\n        int m = matrix.size(); \\n        if (m == 0) return 0;\\n        int n = matrix[0].size();\\n        int res = 0;\\n        \\n        vector<vector<int>> states(m, vector<int>(n, 0));\\n        \\n        for(int i = 0; i < m; ++ i) {\\n            \\n            for(int j = 0; j < n; ++ j) {\\n             //each element\\n             \\n             res = max(res, longestpath(matrix, states, i, j, m, n));\\n\\n            }\\n            \\n        }\\n        \\n        return res;        \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 78405,
                "title": "60ms-c-beat-100-elegant-and-concise-code",
                "content": "    class Solution {\\n        vector<vector<int>> visited;\\n        int height = 0, width = 0;\\n        int floodfill(vector<vector<int>>& matrix, int cur, int i, int j)\\n        {\\n            if (i < 0 || i >= height || j < 0 || j >= width )\\n                return 0;\\n            if (matrix[i][j] <= cur)\\n                return 0;\\n            if (visited[i][j] > 0)\\n                return visited[i][j];\\n            int r = floodfill(matrix, matrix[i][j], i + 1, j);\\n            int l = floodfill(matrix, matrix[i][j], i - 1, j);\\n            int u = floodfill(matrix, matrix[i][j], i, j + 1);\\n            int d = floodfill(matrix, matrix[i][j], i, j - 1);\\n            visited[i][j] = max(r, max(l, max(u, d))) + 1;\\n            return visited[i][j];\\n        }\\n    public:\\n        int longestIncreasingPath(vector<vector<int>>& matrix) {\\n            if (matrix.empty())\\n                return 0;\\n            height = matrix.size(), width = matrix[0].size();\\n            visited.resize(height, vector<int>(width));\\n            int max_len = 0;\\n            for (int i = 0; i < height; ++i)\\n                for (int j = 0; j < width; ++j)\\n                    max_len = max(max_len, floodfill(matrix, INT_MIN, i, j));\\n            return max_len;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        vector<vector<int>> visited;\\n        int height = 0, width = 0;\\n        int floodfill(vector<vector<int>>& matrix, int cur, int i, int j)\\n        {\\n            if (i < 0 || i >= height || j < 0 || j >= width )\\n                return 0;\\n            if (matrix[i][j] <= cur)\\n                return 0;\\n            if (visited[i][j] > 0)\\n                return visited[i][j];\\n            int r = floodfill(matrix, matrix[i][j], i + 1, j);\\n            int l = floodfill(matrix, matrix[i][j], i - 1, j);\\n            int u = floodfill(matrix, matrix[i][j], i, j + 1);\\n            int d = floodfill(matrix, matrix[i][j], i, j - 1);\\n            visited[i][j] = max(r, max(l, max(u, d))) + 1;\\n            return visited[i][j];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2052846,
                "title": "recursion-memoization-dp-simple-understandable-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int m, n;\\n    int fun(int i, int j, vector<vector<int>>& matrix){\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int cnt = 1;\\n        if(i>0 && matrix[i-1][j]<matrix[i][j])  cnt = max(cnt, 1+fun(i-1, j, matrix));\\n        if(j>0 && matrix[i][j-1]<matrix[i][j])  cnt = max(cnt, 1+fun(i, j-1, matrix));\\n        if((i+1)<m && matrix[i+1][j]<matrix[i][j]) cnt = max(cnt, 1+fun(i+1, j, matrix));\\n        if((j+1)<n && matrix[i][j+1]<matrix[i][j]) cnt = max(cnt, 1+fun(i, j+1, matrix));\\n        return dp[i][j] = cnt;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        m = matrix.size(), n = matrix[0].size();\\n        dp.resize(m, vector<int>(n, -1));\\n        int ans = 1;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                ans = max(ans, fun(i, j, matrix));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int m, n;\\n    int fun(int i, int j, vector<vector<int>>& matrix){\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int cnt = 1;\\n        if(i>0 && matrix[i-1][j]<matrix[i][j])  cnt = max(cnt, 1+fun(i-1, j, matrix));\\n        if(j>0 && matrix[i][j-1]<matrix[i][j])  cnt = max(cnt, 1+fun(i, j-1, matrix));\\n        if((i+1)<m && matrix[i+1][j]<matrix[i][j]) cnt = max(cnt, 1+fun(i+1, j, matrix));\\n        if((j+1)<n && matrix[i][j+1]<matrix[i][j]) cnt = max(cnt, 1+fun(i, j+1, matrix));\\n        return dp[i][j] = cnt;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        m = matrix.size(), n = matrix[0].size();\\n        dp.resize(m, vector<int>(n, -1));\\n        int ans = 1;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                ans = max(ans, fun(i, j, matrix));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2052232,
                "title": "python-easy-solution-memoization-dfs",
                "content": "The following solution is correct because of the path must be increasing otherwise (if we would seek the maximum sum path the memoization would be more complex in term of space complexity)\\n\\n**Please upvote if you find it useful !**\\n```\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        longest_by_pos={}\\n        deltas=[(1,0),(-1,0),(0,1),(0,-1)]\\n        ROWS,COLS = len(matrix),len(matrix[0])\\n        \\n        def dfs(pos):\\n            if pos in longest_by_pos:\\n                return longest_by_pos[pos]\\n            \\n            val=matrix[pos[0]][pos[1]]\\n            longest=1\\n            for delta_x,delta_y in deltas:\\n                neighbor_x=delta_x+pos[0]\\n                neighbor_y=delta_y+pos[1]\\n                \\n                if 0<=neighbor_x<ROWS and 0<=neighbor_y<COLS and matrix[neighbor_x][neighbor_y]>val:\\n                    longest=max(longest,1+dfs((neighbor_x,neighbor_y)))\\n            \\n            longest_by_pos[pos]=longest\\n            return longest\\n        \\n        max_path=1\\n        for row in range(ROWS):\\n            for col in range(COLS):\\n                max_path=max(max_path,dfs((row,col)))\\n        return max_path\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        longest_by_pos={}\\n        deltas=[(1,0),(-1,0),(0,1),(0,-1)]\\n        ROWS,COLS = len(matrix),len(matrix[0])\\n        \\n        def dfs(pos):\\n            if pos in longest_by_pos:\\n                return longest_by_pos[pos]\\n            \\n            val=matrix[pos[0]][pos[1]]\\n            longest=1\\n            for delta_x,delta_y in deltas:\\n                neighbor_x=delta_x+pos[0]\\n                neighbor_y=delta_y+pos[1]\\n                \\n                if 0<=neighbor_x<ROWS and 0<=neighbor_y<COLS and matrix[neighbor_x][neighbor_y]>val:\\n                    longest=max(longest,1+dfs((neighbor_x,neighbor_y)))\\n            \\n            longest_by_pos[pos]=longest\\n            return longest\\n        \\n        max_path=1\\n        for row in range(ROWS):\\n            for col in range(COLS):\\n                max_path=max(max_path,dfs((row,col)))\\n        return max_path\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78463,
                "title": "java-dfs-dp-solution",
                "content": "    public class Solution {\\n    int[][] dis = {{1,0},{-1,0},{0,1},{0,-1}};\\n    public int longestIncreasingPath(int[][] matrix) {\\n      if(matrix.length == 0 ){\\n            return 0;\\n      }\\n      int[][] state = new int[matrix.length][matrix[0].length];\\n      int res = 0;\\n      for(int i = 0; i < matrix.length; i++){\\n          for(int j = 0; j < matrix[0].length; j++){\\n             res = Math.max(res,dfs(i,j,matrix,state));\\n          }\\n      }\\n      return res;\\n    }\\n      public int dfs(int i, int j, int[][] matrix,int[][] state){\\n          if(state[i][j] > 0) return state[i][j];\\n          int max = 0;\\n          for(int m = 0; m < dis.length; m++){\\n              if(i + dis[m][0] >= 0 && i + dis[m][0] < matrix.length && j + dis[m][1] >= 0 && j + dis[m][1] < matrix[0].length && matrix[i+dis[m][0]][j+dis[m][1]] > matrix[i][j]){\\n                  max = Math.max(max,dfs(i + dis[m][0],j + dis[m][1],matrix,state));\\n              }\\n          }\\n          state[i][j] = 1 + max;\\n          return state[i][j];\\n          \\n      }\\n    \\n \\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    int[][] dis = {{1,0}",
                "codeTag": "Java"
            },
            {
                "id": 3538440,
                "title": "c-dp-recursion-memoization",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int c(int i,int j,vector<vector<int>>&dp,vector<vector<int>>&v){\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int n=v.size();\\n        int m=v[0].size();\\n        int ans=1;\\n        int dx[4]={1,-1,0,0};\\n        int dy[4]={0,0,1,-1};\\n        for(int k=0;k<4;k++){\\n            int nx=i+dx[k];\\n            int ny=j+dy[k];\\n            if(nx>=0 && ny>=0 && nx<n && ny<m && v[i][j]<v[nx][ny]){\\n                ans = max(ans , 1 + c(nx,ny,dp,v));\\n            }\\n        }\\n        dp[i][j]=ans;\\n        return ans;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& v) {\\n        int ans=1;\\n        int n=v.size();\\n        int m=v[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans = max(ans,c(i,j,dp,v));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/77ce11a3-3fc0-46c3-99eb-81a15959c7f9_1684414971.425493.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int c(int i,int j,vector<vector<int>>&dp,vector<vector<int>>&v){\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int n=v.size();\\n        int m=v[0].size();\\n        int ans=1;\\n        int dx[4]={1,-1,0,0};\\n        int dy[4]={0,0,1,-1};\\n        for(int k=0;k<4;k++){\\n            int nx=i+dx[k];\\n            int ny=j+dy[k];\\n            if(nx>=0 && ny>=0 && nx<n && ny<m && v[i][j]<v[nx][ny]){\\n                ans = max(ans , 1 + c(nx,ny,dp,v));\\n            }\\n        }\\n        dp[i][j]=ans;\\n        return ans;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& v) {\\n        int ans=1;\\n        int n=v.size();\\n        int m=v[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans = max(ans,c(i,j,dp,v));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 545381,
                "title": "javascript-96-clean-dfs-memoized-explanation",
                "content": "* This problem can be a bit confusing at first, as far as understanding how to go about the traversal. \\n\\t* How do we efficiently explore all paths? \\n\\t* How do we avoid cycles ?\\n\\t* How do we count nodes?\\n* If we pay attention to the statement, we can **only** go through **increasing paths**. That means, that **the value of the next node in our path must be grater than our current node**. If we lay out what a graph representation of this matrix would look like, based on that premise, we would get:\\n\\ninput:\\n[\\n  [9,9,4],\\n  [6,6,8],\\n  [2,1,1]\\n] \\n\\ngraph:\\n![image](https://assets.leetcode.com/users/mateatomico/image_1584713663.png)\\n\\n* As you can see, this is a directed acyclic graph.  There will be no cycles, since paths can only go 1 way. \\n* So all we have to do now, is perform a classic graph DFS traversal and count the number of nodes.\\n* For each node, we get valid adjacents and recurr, until we reach the end of our path, which will be either no valid adjacent nodes or the border of the matrix. At each point, we keep track of the maximum counts and return;\\n* This approach can have a time complexity that can get our of hand, since for each node we need to in turn explore in the worst case 4 adjacents. \\n* We can improve on this. Once we go down one path, we already registered the lengths of the longest valid paths for each node. This can be memoized so we don\\'t have to re-calculate if on a different instance of the traversal we travel the same path.\\n\\nSo, here\\'s the algo:\\n* Init a memo\\n* iterate all matrix cells\\n\\t* for each matrix, get max path length doing dfs \\n\\t\\t* we pass init parent value of -Inf, as placeholder and memo\\n\\t* update global max\\n* return global max\\n* DFS:\\n\\t* a cell is valid if:\\n\\t\\t* it is within matrix bounds\\n\\t\\t* its value is less than the parent cell (cell that called it)\\n\\t* if invalid, return 0, no more paths to add here.\\n\\t* if cell is memoized, then return that\\n\\t* otherwise, recurr for all adjacent cells in 4 directions, and get the max path. Add +1 to account for current node. \\n\\t\\t* when calling function recursively, we pass on value of cell to be used as parent of next cell.\\n\\t* memoize result\\n\\t* return\\n\\n```javascript\\nconst longestIncreasingPath = (matrix) => {\\n    if(!matrix || matrix.length === 0) return 0;\\n    \\n    const memo = new Array(matrix.length)\\n                        .fill(-1)\\n                        .map(row => new Array(matrix[0].length).fill(-1));\\n    \\n    let max = 0;\\n    for(let row = 0; row < matrix.length; row++) {\\n        for(let col = 0; col < matrix[0].length; col++) {\\n            max = Math.max(max, dfs(matrix, row, col, Number.MIN_SAFE_INTEGER, memo) );\\n        }\\n    }\\n    \\n    return max;\\n};\\n\\nconst dfs = (matrix, row, col, parent, memo) => {\\n    if(\\n        row < 0\\n        || row >= matrix.length\\n        || col < 0\\n        || col >= matrix[0].length\\n        || matrix[row][col] <= parent\\n    ) return 0;\\n    \\n    if(memo[row][col] === -1) {\\n        const   rowVector = [1, -1, 0, 0],\\n                colVector = [0, 0, 1, -1];\\n\\n        let maxPath = 0;\\n        for(let dir = 0; dir < 4; dir++) {\\n\\t\\t\\tconst maxForNode = 1 + dfs(matrix, row + rowVector[dir], col + colVector[dir], matrix[row][col], memo);\\n            maxPath = Math.max(maxPath, maxForNode);\\n        }\\n        \\n        memo[row][col] = maxPath;\\n    }\\n    \\n    return  memo[row][col];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```javascript\\nconst longestIncreasingPath = (matrix) => {\\n    if(!matrix || matrix.length === 0) return 0;\\n    \\n    const memo = new Array(matrix.length)\\n                        .fill(-1)\\n                        .map(row => new Array(matrix[0].length).fill(-1));\\n    \\n    let max = 0;\\n    for(let row = 0; row < matrix.length; row++) {\\n        for(let col = 0; col < matrix[0].length; col++) {\\n            max = Math.max(max, dfs(matrix, row, col, Number.MIN_SAFE_INTEGER, memo) );\\n        }\\n    }\\n    \\n    return max;\\n};\\n\\nconst dfs = (matrix, row, col, parent, memo) => {\\n    if(\\n        row < 0\\n        || row >= matrix.length\\n        || col < 0\\n        || col >= matrix[0].length\\n        || matrix[row][col] <= parent\\n    ) return 0;\\n    \\n    if(memo[row][col] === -1) {\\n        const   rowVector = [1, -1, 0, 0],\\n                colVector = [0, 0, 1, -1];\\n\\n        let maxPath = 0;\\n        for(let dir = 0; dir < 4; dir++) {\\n\\t\\t\\tconst maxForNode = 1 + dfs(matrix, row + rowVector[dir], col + colVector[dir], matrix[row][col], memo);\\n            maxPath = Math.max(maxPath, maxForNode);\\n        }\\n        \\n        memo[row][col] = maxPath;\\n    }\\n    \\n    return  memo[row][col];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 462711,
                "title": "javascript-dfs",
                "content": "**Idea**\\n* for each cell, perform DFS traveral and keep a record of maximum len as we go\\n* if seen before, return immediately with the cached result\\n* compare and store maximum path during traversal\\n    \\n```\\n/**\\n * @param {number[][]} matrix\\n * @return {number}\\n */\\nvar longestIncreasingPath = function(matrix) {\\n\\n    if(matrix.length === 0) return 0;\\n    \\n    let max = 0;\\n\\t\\n    const map = new Map(); // key, value => i|j, count\\n    \\n    const isOutside = (i, j) => i < 0 || j < 0 || i >= matrix.length || j >= matrix[0].length;\\n    \\n    const helper = (i, j, prev) => {\\n        \\n        const key = `${i}|${j}`;\\n        \\n        if(isOutside(i, j) || matrix[i][j] <= prev) return 0;\\n        if(map.has(key)) return map.get(key);\\n        \\n        const num = matrix[i][j];\\n        \\n        const l = helper(i, j - 1, num);\\n        const r = helper(i, j + 1, num);\\n        const t = helper(i - 1, j, num);\\n        const d = helper(i + 1, j, num);\\n\\n        map.set(key, Math.max(l, r, t, d) + 1);\\n        max = Math.max(max, map.get(key));\\n        \\n        return map.get(key);\\n        \\n    };\\n    \\n    for(let i = 0; i < matrix.length; i++) {\\n        for(let j = 0; j < matrix[0].length; j++) {\\n            const key = `${i}|${j}`;\\n            if(!map.has(key)) helper(i, j, -Number.MAX_VALUE);\\n        }\\n    }\\n    \\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {number}\\n */\\nvar longestIncreasingPath = function(matrix) {\\n\\n    if(matrix.length === 0) return 0;\\n    \\n    let max = 0;\\n\\t\\n    const map = new Map(); // key, value => i|j, count\\n    \\n    const isOutside = (i, j) => i < 0 || j < 0 || i >= matrix.length || j >= matrix[0].length;\\n    \\n    const helper = (i, j, prev) => {\\n        \\n        const key = `${i}|${j}`;\\n        \\n        if(isOutside(i, j) || matrix[i][j] <= prev) return 0;\\n        if(map.has(key)) return map.get(key);\\n        \\n        const num = matrix[i][j];\\n        \\n        const l = helper(i, j - 1, num);\\n        const r = helper(i, j + 1, num);\\n        const t = helper(i - 1, j, num);\\n        const d = helper(i + 1, j, num);\\n\\n        map.set(key, Math.max(l, r, t, d) + 1);\\n        max = Math.max(max, map.get(key));\\n        \\n        return map.get(key);\\n        \\n    };\\n    \\n    for(let i = 0; i < matrix.length; i++) {\\n        for(let j = 0; j < matrix[0].length; j++) {\\n            const key = `${i}|${j}`;\\n            if(!map.has(key)) helper(i, j, -Number.MAX_VALUE);\\n        }\\n    }\\n    \\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 438920,
                "title": "python-dfs-memoization",
                "content": "Inspired from this post:\\n[Python beats 98%. DFS template using set and recursion.](https://leetcode.com/problems/pacific-atlantic-water-flow/discuss/438276/python-beats-98-dfs-template-using-set-and-recursion)\\n\\n\\n```python\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        # Check edge case\\n        if not matrix:\\n            return 0\\n\\n        # Initialize\\n        rows, cols = len(matrix), len(matrix[0])\\n        directions = ((0, 1), (0, -1), (-1, 0), (1, 0))\\n        visited = [[-1] * cols for _ in range(rows)]\\n        res = 0\\n\\n        def dfs(i, j):\\n            # Check if visited\\n            if visited[i][j] != -1:\\n                return visited[i][j]\\n\\n            res = 1\\n\\n            # work with neighbors\\n            for direction in directions:\\n                next_i, next_j = i + direction[0], j + direction[1]\\n\\n                # for each direction we try to find a new count\\n                direction_count = 0\\n                if 0 <= next_i < rows and 0 <= next_j < cols:\\n                    if matrix[i][j] < matrix[next_i][next_j]:\\n                        direction_count = 1 + dfs(next_i, next_j)\\n\\n                res = max(direction_count, res)\\n\\n            visited[i][j] = res\\n            return res\\n\\n        for row in range(rows):\\n            for col in range(cols):\\n                res = max(dfs(row, col), res)\\n\\n        return res\\n``` \\n\\n### Complexity Analysis:\\n- Time Complexity: `O(mn)` each cell is visited once.\\n\\n- Space Complexity: `O(mn + h) = O(mn)`. \\n\\t- For each DFS we need `O(h)` space used by the system stack, where `h` is the maximum depth of the recursion. In the worst case, `O(h) = O(m*n)`.\\n\\t- Each visited set can have at maximum all cells from the matrix so `O(mn)`",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        # Check edge case\\n        if not matrix:\\n            return 0\\n\\n        # Initialize\\n        rows, cols = len(matrix), len(matrix[0])\\n        directions = ((0, 1), (0, -1), (-1, 0), (1, 0))\\n        visited = [[-1] * cols for _ in range(rows)]\\n        res = 0\\n\\n        def dfs(i, j):\\n            # Check if visited\\n            if visited[i][j] != -1:\\n                return visited[i][j]\\n\\n            res = 1\\n\\n            # work with neighbors\\n            for direction in directions:\\n                next_i, next_j = i + direction[0], j + direction[1]\\n\\n                # for each direction we try to find a new count\\n                direction_count = 0\\n                if 0 <= next_i < rows and 0 <= next_j < cols:\\n                    if matrix[i][j] < matrix[next_i][next_j]:\\n                        direction_count = 1 + dfs(next_i, next_j)\\n\\n                res = max(direction_count, res)\\n\\n            visited[i][j] = res\\n            return res\\n\\n        for row in range(rows):\\n            for col in range(cols):\\n                res = max(dfs(row, col), res)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78423,
                "title": "neat-java-dfs-solution-with-memoization",
                "content": "Starting with each element of matrix and also remember the longest length starting from each element to remove duplicate computations. \\n\\nThe tricky part is a visited map is not required (cause visited value is always smaller). And this also guarantees that the cache will work, once a longest length is computed for an element, the value preserves no matter how previous sequence lands here (as it always follow the increasing order).\\n \\n    public class Solution {\\n        \\n        private int dfs(int[][] matrix, int i, int j, int[][] cache) {\\n            if(cache[i][j] > 0)\\n                return cache[i][j];\\n            int longest = 0;\\n            if(i>0 && matrix[i][j]<matrix[i-1][j]) \\n                longest = Math.max(longest, dfs(matrix, i-1, j, cache));\\n            if(j>0 && matrix[i][j]<matrix[i][j-1])\\n                longest = Math.max(longest, dfs(matrix, i, j-1, cache));\\n            if(i<matrix.length-1 && matrix[i][j]<matrix[i+1][j])\\n                longest = Math.max(longest, dfs(matrix, i+1, j, cache));\\n            if(j<matrix[0].length-1 && matrix[i][j]<matrix[i][j+1])\\n                longest = Math.max(longest, dfs(matrix, i, j+1, cache));\\n            cache[i][j] = longest+1;\\n            return longest+1;\\n        }\\n        \\n        public int longestIncreasingPath(int[][] matrix) {\\n            if(matrix.length==0)\\n                return 0;\\n            int[][] cache = new int[matrix.length][matrix[0].length];\\n            int longest = 0;\\n            for(int i=0; i<matrix.length; i++)\\n                for(int j=0; j<matrix[0].length; j++)\\n                    longest = Math.max(longest, dfs(matrix, i, j, cache));\\n            return longest;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        \\n        private int dfs(int[][] matrix, int i, int j, int[][] cache) {\\n            if(cache[i][j] > 0)\\n                return cache[i][j];\\n            int longest = 0;\\n            if(i>0 && matrix[i][j]<matrix[i-1][j]) \\n                longest = Math.max(longest, dfs(matrix, i-1, j, cache));\\n            if(j>0 && matrix[i][j]<matrix[i][j-1])\\n                longest = Math.max(longest, dfs(matrix, i, j-1, cache));\\n            if(i<matrix.length-1 && matrix[i][j]<matrix[i+1][j])\\n                longest = Math.max(longest, dfs(matrix, i+1, j, cache));\\n            if(j<matrix[0].length-1 && matrix[i][j]<matrix[i][j+1])\\n                longest = Math.max(longest, dfs(matrix, i, j+1, cache));\\n            cache[i][j] = longest+1;\\n            return longest+1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2053435,
                "title": "c-use-dp-and-dfs-easy-explanation-with-comments",
                "content": "**Please upvote if this solution is helpful :)**\\n```\\nclass Solution {\\n    \\n    //possible moving directions {up, left, right, down}\\n    vector<vector<int>> dirs = {\\n            {-1,0},\\n    {0,-1},        {0,1},\\n            {1,0}\\n    };\\n    \\n    int dfs(vector<vector<int>>& matrix, int r, int c, vector<vector<int>>& dp, int prev) \\n    {\\n        //boundary conditon\\n        if(r<0 || r>=matrix.size() || c<0 || c>=matrix[0].size()) return 0;\\n        \\n        //if current value is less than or equal to the previous value return 0;\\n        if(matrix[r][c] <= prev) return 0;\\n        \\n        //if we have already the path length of the cell, we return it (dp concept)\\n        if(dp[r][c] != -1) return dp[r][c];\\n        int best = 0; //store best path length\\n        \\n        //moving in all 4 directions and call dfs function\\n        for(auto dir : dirs) {\\n            int next_r = dir[0] + r;\\n            int next_c = dir[1] + c;\\n            int cur = dfs(matrix, next_r, next_c, dp, matrix[r][c]);\\n            best = max(best, cur); //store max. path length\\n        }\\n        \\n        return dp[r][c] = best + 1; //return path length of the cell\\n    }\\n    \\npublic:\\n    int longestIncreasingPath(vector<vector<int>>& matrix) \\n    {\\n        //getting no. of row and col of the matrix\\n        int row = matrix.size(), col = matrix[0].size();\\n        \\n        //for dp, create mxn matrix and initialize it with -1\\n        vector<vector<int>> dp(row, vector<int>(col, -1));\\n        \\n        //store longest path\\n        int longest_path = 0;\\n        \\n        //traverse through the matrix\\n        for(int i=0; i<row; i++) \\n        {\\n            for(int j=0; j<col; j++) \\n            {\\n                int path = dfs(matrix, i, j, dp, -1000000); //call dfs function\\n                longest_path = max(longest_path, path); //store the maximum path\\n            }\\n        }\\n        \\n        return longest_path; //return maximum path\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    \\n    //possible moving directions {up, left, right, down}\\n    vector<vector<int>> dirs = {\\n            {-1,0},\\n    {0,-1},        {0,1},\\n            {1,0}\\n    };\\n    \\n    int dfs(vector<vector<int>>& matrix, int r, int c, vector<vector<int>>& dp, int prev) \\n    {\\n        //boundary conditon\\n        if(r<0 || r>=matrix.size() || c<0 || c>=matrix[0].size()) return 0;\\n        \\n        //if current value is less than or equal to the previous value return 0;\\n        if(matrix[r][c] <= prev) return 0;\\n        \\n        //if we have already the path length of the cell, we return it (dp concept)\\n        if(dp[r][c] != -1) return dp[r][c];\\n        int best = 0; //store best path length\\n        \\n        //moving in all 4 directions and call dfs function\\n        for(auto dir : dirs) {\\n            int next_r = dir[0] + r;\\n            int next_c = dir[1] + c;\\n            int cur = dfs(matrix, next_r, next_c, dp, matrix[r][c]);\\n            best = max(best, cur); //store max. path length\\n        }\\n        \\n        return dp[r][c] = best + 1; //return path length of the cell\\n    }\\n    \\npublic:\\n    int longestIncreasingPath(vector<vector<int>>& matrix) \\n    {\\n        //getting no. of row and col of the matrix\\n        int row = matrix.size(), col = matrix[0].size();\\n        \\n        //for dp, create mxn matrix and initialize it with -1\\n        vector<vector<int>> dp(row, vector<int>(col, -1));\\n        \\n        //store longest path\\n        int longest_path = 0;\\n        \\n        //traverse through the matrix\\n        for(int i=0; i<row; i++) \\n        {\\n            for(int j=0; j<col; j++) \\n            {\\n                int path = dfs(matrix, i, j, dp, -1000000); //call dfs function\\n                longest_path = max(longest_path, path); //store the maximum path\\n            }\\n        }\\n        \\n        return longest_path; //return maximum path\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2052190,
                "title": "java-dfs-solution",
                "content": "```\\nclass Solution {\\n    int[][] matrix, helper;\\n    int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    public int longestIncreasingPath(int[][] matrix) {\\n        helper = new int[matrix.length][matrix[0].length];\\n        this.matrix= matrix;\\n        int path = 0;\\n        for(int i=0;i<matrix.length;i++) {\\n            for(int j=0;j<matrix[0].length;j++) \\n                path = Math.max(path, dfs(i, j));\\n        }\\n        \\n        return path;\\n    }\\n     \\n    private int dfs(int x, int y) {\\n        if (helper[x][y] != 0) return helper[x][y];\\n        for(int d=0;d<dirs.length;d++) {\\n            int i = dirs[d][0] + x, j = dirs[d][1] + y;\\n            if(i >= 0 && i < matrix.length && j >= 0 && j < matrix[0].length && matrix[x][y] < matrix[i][j]) {\\n                helper[x][y] = Math.max(helper[x][y], dfs(i, j));\\n            }\\n        }\\n        return ++helper[x][y];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int[][] matrix, helper;\\n    int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    public int longestIncreasingPath(int[][] matrix) {\\n        helper = new int[matrix.length][matrix[0].length];\\n        this.matrix= matrix;\\n        int path = 0;\\n        for(int i=0;i<matrix.length;i++) {\\n            for(int j=0;j<matrix[0].length;j++) \\n                path = Math.max(path, dfs(i, j));\\n        }\\n        \\n        return path;\\n    }\\n     \\n    private int dfs(int x, int y) {\\n        if (helper[x][y] != 0) return helper[x][y];\\n        for(int d=0;d<dirs.length;d++) {\\n            int i = dirs[d][0] + x, j = dirs[d][1] + y;\\n            if(i >= 0 && i < matrix.length && j >= 0 && j < matrix[0].length && matrix[x][y] < matrix[i][j]) {\\n                helper[x][y] = Math.max(helper[x][y], dfs(i, j));\\n            }\\n        }\\n        return ++helper[x][y];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218470,
                "title": "c-topological-sorting-on-a-directed-graph",
                "content": "```\\nclass Solution {\\n    vector<vector<int>> directions = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n    int rows, cols, longest = 0;\\npublic:\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        rows = matrix.size();\\n        // Empty\\n        if(!rows) return 0;\\n        cols = matrix[0].size();\\n        // Matrix corresponding to Indegree count\\n        vector<vector<int>> Indegree(rows, vector<int>(cols));\\n        // Source nodes of increasing paths\\n        queue<pair<int, int>> q;\\n        \\n        for(int i = 0; i < rows; i++){\\n            for(int j = 0; j < cols; j++){\\n                for(auto &d: directions){\\n                    int x = i + d[0];\\n                    int y = j + d[1];\\n                    // OUT OF BOUNDS CHECK\\n                    if(x >= 0 && x < rows && y >= 0 && y < cols){\\n                        // Increasing Path (end)\\n                        if(matrix[x][y] < matrix[i][j]) Indegree[i][j]++;\\n                    }\\n                }\\n                // Increasing Path (start)\\n                if(!Indegree[i][j]) q.push({i, j});\\n            }\\n        }\\n        // BFS\\n        while(!q.empty()){\\n            int size = q.size();\\n            while(size--){\\n                pair<int,int> current = q.front();    // Current matrix cell\\n                q.pop();\\n                // Explore neigbhors\\n                for(auto &d: directions){\\n                    int x = current.first + d[0];\\n                    int y = current.second + d[1];\\n                    // OUT OF BOUNDS CHECK\\n                    if(x >= 0 && x < rows && y >= 0 && y < cols){\\n                      // \"Erase\" current cell and move onto next level\\n                        if(matrix[x][y] > matrix[current.first][current.second] && --Indegree[x][y] == 0)\\n                            q.push({x,y});\\n                    }\\n                }\\n            }\\n            longest++;\\n        }\\n        return longest;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> directions = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n    int rows, cols, longest = 0;\\npublic:\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        rows = matrix.size();\\n        // Empty\\n        if(!rows) return 0;\\n        cols = matrix[0].size();\\n        // Matrix corresponding to Indegree count\\n        vector<vector<int>> Indegree(rows, vector<int>(cols));\\n        // Source nodes of increasing paths\\n        queue<pair<int, int>> q;\\n        \\n        for(int i = 0; i < rows; i++){\\n            for(int j = 0; j < cols; j++){\\n                for(auto &d: directions){\\n                    int x = i + d[0];\\n                    int y = j + d[1];\\n                    // OUT OF BOUNDS CHECK\\n                    if(x >= 0 && x < rows && y >= 0 && y < cols){\\n                        // Increasing Path (end)\\n                        if(matrix[x][y] < matrix[i][j]) Indegree[i][j]++;\\n                    }\\n                }\\n                // Increasing Path (start)\\n                if(!Indegree[i][j]) q.push({i, j});\\n            }\\n        }\\n        // BFS\\n        while(!q.empty()){\\n            int size = q.size();\\n            while(size--){\\n                pair<int,int> current = q.front();    // Current matrix cell\\n                q.pop();\\n                // Explore neigbhors\\n                for(auto &d: directions){\\n                    int x = current.first + d[0];\\n                    int y = current.second + d[1];\\n                    // OUT OF BOUNDS CHECK\\n                    if(x >= 0 && x < rows && y >= 0 && y < cols){\\n                      // \"Erase\" current cell and move onto next level\\n                        if(matrix[x][y] > matrix[current.first][current.second] && --Indegree[x][y] == 0)\\n                            q.push({x,y});\\n                    }\\n                }\\n            }\\n            longest++;\\n        }\\n        return longest;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 652927,
                "title": "c-two-approaches-with-detailed-explanation",
                "content": "**DP Approach**(60ms)\\nThis is a recursive implementation of dp.\\nThe way to think of it is if r-1>=0 and ```matrix[r-1][c]>matrix[r][c]``` then we do a recursive call and check if this repeates for any of the 4 directions and store it in dp[r][c].\\nThis is a basic Longest Increasing Subsequence problem nut u just have to think of it 2 dimensionally on all the four directions.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int findinc(int r,int c,vector<vector<int>> &matrix)\\n    {\\n        if(dp[r][c]>0)return dp[r][c];\\n        int curr=matrix[r][c];\\n        int m=0;\\n        if(r+1<matrix.size() && matrix[r+1][c]>curr)\\n            m=max(m,findinc(r+1,c,matrix));\\n        if(r-1>=0 && matrix[r-1][c]>curr)\\n            m=max(m,findinc(r-1,c,matrix));\\n        if(c+1<matrix[0].size() && matrix[r][c+1]>curr)\\n            m=max(m,findinc(r,c+1,matrix));\\n        if(c-1>=0 && matrix[r][c-1]>curr)\\n            m=max(m,findinc(r,c-1,matrix));\\n        dp[r][c]=m+1;\\n        return m+1;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        if(matrix.size()==0)return 0;\\n        int n=matrix.size(),m=matrix[0].size();\\n        int ans=0;\\n        dp.resize(n,vector<int>(m));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int inc=findinc(i,j,matrix);\\n                ans=max(ans,inc);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Graph Approach**(108ms\\nYea two of the most scariest topics :) . This can be solve using Kahns Algorithm(Topological Sort).\\nThis wont click for most of the people because the problem statement looks like a typical dp problem.\\n**Algorithm**\\n1. Increment the indegrees of of the smaller values that are connected the bigger one which is in the vicinity of the 4 directions.\\n2. Push the coordinates having indegree 0 into the queue\\n3. Explore these corrdinatinates and remove them from the graph by decrementing indegree values.\\n4. After decrementing them check if it hits 0,if it does push it into the queue.\\n5. The depth of the bfs done will the final answer.\\n```\\nclass Solution {\\npublic:\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        if(matrix.size()==0)return 0;\\n        vector<vector<int>> dir={{0,1},{0,-1},{1,0},{-1,0}};\\n        int n=matrix.size(),m=matrix[0].size();\\n        vector<vector<int>> indegree(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                for(auto &x:dir)\\n                {\\n                    int nx=i+x[0];\\n                    int ny=j+x[1];\\n                    if(nx>=0 && ny>=0 && nx<n && ny<m)\\n                    {\\n                        if(matrix[nx][ny]>matrix[i][j])\\n                            indegree[i][j]++;\\n                    }\\n                }\\n            }\\n        }\\n        queue<pair<int,int>> q;\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(indegree[i][j]==0)q.push({i,j});\\n        int ans=0;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                pair<int,int> p=q.front();\\n                q.pop();\\n                for(auto &x:dir)\\n                {\\n                    int nx=p.first+x[0];\\n                    int ny=p.second+x[1];\\n                    if(nx>=0 && ny>=0 && nx<n &&ny<m )\\n                    {\\n                        if(matrix[nx][ny]<matrix[p.first][p.second]&& --indegree[nx][ny]==0)\\n                            q.push({nx,ny});\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Graph"
                ],
                "code": "```matrix[r-1][c]>matrix[r][c]```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int findinc(int r,int c,vector<vector<int>> &matrix)\\n    {\\n        if(dp[r][c]>0)return dp[r][c];\\n        int curr=matrix[r][c];\\n        int m=0;\\n        if(r+1<matrix.size() && matrix[r+1][c]>curr)\\n            m=max(m,findinc(r+1,c,matrix));\\n        if(r-1>=0 && matrix[r-1][c]>curr)\\n            m=max(m,findinc(r-1,c,matrix));\\n        if(c+1<matrix[0].size() && matrix[r][c+1]>curr)\\n            m=max(m,findinc(r,c+1,matrix));\\n        if(c-1>=0 && matrix[r][c-1]>curr)\\n            m=max(m,findinc(r,c-1,matrix));\\n        dp[r][c]=m+1;\\n        return m+1;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        if(matrix.size()==0)return 0;\\n        int n=matrix.size(),m=matrix[0].size();\\n        int ans=0;\\n        dp.resize(n,vector<int>(m));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int inc=findinc(i,j,matrix);\\n                ans=max(ans,inc);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        if(matrix.size()==0)return 0;\\n        vector<vector<int>> dir={{0,1},{0,-1},{1,0},{-1,0}};\\n        int n=matrix.size(),m=matrix[0].size();\\n        vector<vector<int>> indegree(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                for(auto &x:dir)\\n                {\\n                    int nx=i+x[0];\\n                    int ny=j+x[1];\\n                    if(nx>=0 && ny>=0 && nx<n && ny<m)\\n                    {\\n                        if(matrix[nx][ny]>matrix[i][j])\\n                            indegree[i][j]++;\\n                    }\\n                }\\n            }\\n        }\\n        queue<pair<int,int>> q;\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(indegree[i][j]==0)q.push({i,j});\\n        int ans=0;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                pair<int,int> p=q.front();\\n                q.pop();\\n                for(auto &x:dir)\\n                {\\n                    int nx=p.first+x[0];\\n                    int ny=p.second+x[1];\\n                    if(nx>=0 && ny>=0 && nx<n &&ny<m )\\n                    {\\n                        if(matrix[nx][ny]<matrix[p.first][p.second]&& --indegree[nx][ny]==0)\\n                            q.push({nx,ny});\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 559282,
                "title": "c-concise-dp-solution-memoization",
                "content": "Runtime: 56 ms, faster than 39.66% of C++ online submissions for Longest Increasing Path in a Matrix.\\nMemory Usage: 11.1 MB, less than 100.00% of C++ online submissions for Longest Increasing Path in a Matrix.\\n\\n```\\nclass Solution {\\npublic:\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        \\n        int n = matrix.size();\\n        if(n == 0)\\n            return 0;\\n        \\n        int m = matrix[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n        int res = 1;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                if(dp[i][j] == -1)\\n                    calculateLongestPath(matrix, dp, i, j);\\n                res = max(res, dp[i][j]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    int calculateLongestPath(vector<vector<int>>& matrix, vector<vector<int>>& dp, int i, int j)\\n    {\\n        if(i < 0 || j < 0 || i >= matrix.size() || j >= matrix[0].size())\\n            return 0;\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        int x = INT_MIN;\\n        int y = INT_MIN;\\n        int z = INT_MIN;\\n        int w = INT_MIN;\\n        \\n        if(j+1 < matrix[0].size() && matrix[i][j+1] > matrix[i][j])\\n            x = 1 + calculateLongestPath(matrix, dp, i, j+1);\\n        if(j > 0 && matrix[i][j-1] > matrix[i][j])\\n            y = 1 + calculateLongestPath(matrix, dp, i, j-1);\\n        if(i+1 < matrix.size() && matrix[i+1][j] > matrix[i][j])\\n            z = 1 + calculateLongestPath(matrix, dp, i+1, j);\\n        if(i > 0 && matrix[i-1][j] > matrix[i][j])\\n            w = 1 + calculateLongestPath(matrix, dp, i-1, j);\\n        dp[i][j] = max(x, max(y, max(z, max(w, 1))));\\n        \\n        return dp[i][j];\\n    }\\n};\\n",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        \\n        int n = matrix.size();\\n        if(n == 0)\\n            return 0;\\n        \\n        int m = matrix[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n        int res = 1;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                if(dp[i][j] == -1)\\n                    calculateLongestPath(matrix, dp, i, j);\\n                res = max(res, dp[i][j]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 332696,
                "title": "python-topological-sort-with-explanation",
                "content": "We can model this problem as a graph in which each cell is a vertex. An edge exists only from node `u` to node `v` if `u` and `v` are adjacent up/down/left/right neighbors in `matrix` and if `matrix[u] < matrix[v]` - this is because we are looking to model only increasing paths per problem statement. \\n       \\nmodel matrix as a graph (defaultdict of sets)\\n\\n`adj_to = {u1 : {v1, v2, v3}}`\\n\\ncompute indegrees of all vertices in a defaultdict of ints\\n\\n`indegree = {v1: 1, v2: 2}`\\n\\nperform standard topological sort of graph, keeping track of the max possible depth we can reach.\\n\\nfor topological sort we start with all vertices of 0 indegree\\nwe visit those vertices and decrement their adjacent neighbors\\' indegrees by 1\\nif any of those are now 0, add them to our `to_visit` queue\\nwe also keep track of the depth reached on the queue\\n\\n ```\\n def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n\\n        adj_to = collections.defaultdict(set)\\n        indegree = collections.defaultdict(int)\\n        \\n        for i, row in enumerate(matrix):\\n            for j, cell in enumerate(row):\\n                if i > 0 and cell < matrix[i-1][j]:\\n                    adj_to[(i,j)] |= {(i-1,j)}\\n                    indegree[(i-1,j)] += 1\\n                if j > 0 and cell < matrix[i][j-1]:\\n                    adj_to[(i,j)] |= {(i,j-1)}\\n                    indegree[(i,j-1)] += 1\\n                if i < len(matrix)-1 and cell < matrix[i+1][j]:\\n                    adj_to[(i,j)] |= {(i+1,j)}\\n                    indegree[(i+1,j)] += 1\\n                if j < len(row)-1 and cell < matrix[i][j+1]:\\n                    adj_to[(i,j)] |= {(i,j+1)}\\n                    indegree[(i,j+1)] += 1\\n        \\n        to_visit = collections.deque()\\n        \\n        [to_visit.append(((i,j),1)) \\n         for i in range(len(matrix)) \\n         for j in range(len(matrix[i])) \\n         if not indegree[(i,j)]]\\n        \\n        max_depth = 0\\n        \\n        while to_visit:\\n            \\n            cur, depth = to_visit.popleft()\\n            max_depth = max(max_depth, depth)\\n            for adj in adj_to[cur]:\\n                indegree[adj] -= 1\\n                if not indegree[adj]:\\n                    to_visit.append((adj,depth+1))\\n        \\n        return max_depth\\n```",
                "solutionTags": [],
                "code": "```\\n def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n\\n        adj_to = collections.defaultdict(set)\\n        indegree = collections.defaultdict(int)\\n        \\n        for i, row in enumerate(matrix):\\n            for j, cell in enumerate(row):\\n                if i > 0 and cell < matrix[i-1][j]:\\n                    adj_to[(i,j)] |= {(i-1,j)}\\n                    indegree[(i-1,j)] += 1\\n                if j > 0 and cell < matrix[i][j-1]:\\n                    adj_to[(i,j)] |= {(i,j-1)}\\n                    indegree[(i,j-1)] += 1\\n                if i < len(matrix)-1 and cell < matrix[i+1][j]:\\n                    adj_to[(i,j)] |= {(i+1,j)}\\n                    indegree[(i+1,j)] += 1\\n                if j < len(row)-1 and cell < matrix[i][j+1]:\\n                    adj_to[(i,j)] |= {(i,j+1)}\\n                    indegree[(i,j+1)] += 1\\n        \\n        to_visit = collections.deque()\\n        \\n        [to_visit.append(((i,j),1)) \\n         for i in range(len(matrix)) \\n         for j in range(len(matrix[i])) \\n         if not indegree[(i,j)]]\\n        \\n        max_depth = 0\\n        \\n        while to_visit:\\n            \\n            cur, depth = to_visit.popleft()\\n            max_depth = max(max_depth, depth)\\n            for adj in adj_to[cur]:\\n                indegree[adj] -= 1\\n                if not indegree[adj]:\\n                    to_visit.append((adj,depth+1))\\n        \\n        return max_depth\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1151668,
                "title": "java-solution-with-explanation-recursion-memoization-dfs-approach",
                "content": "*------Please **upvote!** if you like the solution and explanation.  Please put your doubts/queries in the comments section below.  I will try my best to answer them.------*\\n\\n**EXPLANATION:**\\n\\n1. Each cell in the input matrix will be the starting point for DFS.\\n2. For each cell, check if the adjacent cell is valid and whether the value in the adjacent cell is greater than the value in the current cell.\\n3. If yes, recur for the adjacent cell and increase the length of the current path by 1 and update a global max length accordingly.  Do this for all the 4 directions.\\n4. Now, just memoize the above steps!\\n5. Return the max length.\\n\\n```\\nclass Solution {\\n    public int dp [][];\\n    public int longestIncreasingPath (int[][] matrix) {\\n        if (matrix == null || matrix.length == 0)\\n            return 0;\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        dp = new int [n][m];\\n        for (int arr [] : dp)\\n            Arrays.fill (arr, -1);\\n        int max = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++)\\n                max = Math.max (max, DFS (matrix, i, j));\\n        }\\n        return max;\\n    }\\n    \\n    public int DFS (int matrix [][], int i, int j) {\\n        if (dp [i][j] != -1)\\n            return dp [i][j];\\n        int max = 1;\\n        \\n        if (i+1 < matrix.length && matrix [i+1][j] > matrix [i][j])\\n            max = Math.max (max, 1 + DFS (matrix, i+1, j));\\n        \\n        if (i-1 >= 0 && matrix [i-1][j] > matrix [i][j])\\n            max = Math.max (max, 1 + DFS (matrix, i-1, j));\\n        \\n        if (j+1 < matrix[0].length && matrix [i][j+1] > matrix [i][j])\\n            max = Math.max (max, 1 + DFS (matrix, i, j+1));\\n        \\n        if (j-1 >= 0 && matrix [i][j-1] > matrix [i][j])\\n            max = Math.max (max, 1 + DFS (matrix, i, j-1));\\n        return dp [i][j] = max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int dp [][];\\n    public int longestIncreasingPath (int[][] matrix) {\\n        if (matrix == null || matrix.length == 0)\\n            return 0;\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        dp = new int [n][m];\\n        for (int arr [] : dp)\\n            Arrays.fill (arr, -1);\\n        int max = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++)\\n                max = Math.max (max, DFS (matrix, i, j));\\n        }\\n        return max;\\n    }\\n    \\n    public int DFS (int matrix [][], int i, int j) {\\n        if (dp [i][j] != -1)\\n            return dp [i][j];\\n        int max = 1;\\n        \\n        if (i+1 < matrix.length && matrix [i+1][j] > matrix [i][j])\\n            max = Math.max (max, 1 + DFS (matrix, i+1, j));\\n        \\n        if (i-1 >= 0 && matrix [i-1][j] > matrix [i][j])\\n            max = Math.max (max, 1 + DFS (matrix, i-1, j));\\n        \\n        if (j+1 < matrix[0].length && matrix [i][j+1] > matrix [i][j])\\n            max = Math.max (max, 1 + DFS (matrix, i, j+1));\\n        \\n        if (j-1 >= 0 && matrix [i][j-1] > matrix [i][j])\\n            max = Math.max (max, 1 + DFS (matrix, i, j-1));\\n        return dp [i][j] = max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 341489,
                "title": "a-follow-up-question-return-the-actual-longest-path-instead-of-the-length",
                "content": "I came across this follow up in an interview:\\nnot return the length of the longest increasing path, but the actual path, if there are multiple, return any one of them.\\n\\nMy idea is:\\nFor DFS+DP solution, we can find the max length, then iterate the matrix again, build the pathl. This solution requires two rounds of iterating the matrix.\\nDoes anybody have a better approach to only iterate the matrix once?\\n\\nJava solution. Introduced a buildPath() function, only print out the results for testing.\\n```\\nclass Solution {\\n    private int[][] dict = new int[][]{{0,1},{0,-1},{1,0},{-1,0}};\\n    \\n    public int longestIncreasingPath(int[][] matrix) {\\n        if (matrix == null || matrix.length == 0) return 0;\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int[][] mem = new int[row][col];\\n        int max = 0;\\n        for (int r = 0; r < row; r++) {\\n            for (int c = 0; c < col; c++) {\\n                max = Math.max(max, dfs(matrix, r, c, mem));\\n            }\\n        }\\n        for (int r = 0; r < row; r++) {\\n            for (int c = 0; c < col; c++) {\\n                if (mem[r][c] == max) {\\n                    System.out.println(buildPath(matrix, r, c, mem));\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    private List<String> buildPath(int[][] matrix, int r, int c, int[][] mem) {\\n        if (mem[r][c] == 1) {\\n            List<String> rst = new LinkedList<>();\\n            rst.add(r + \":\" + c + \":\" + matrix[r][c]);\\n            return rst;\\n        }\\n        for (int i = 0; i < dict.length; i++) {\\n            int nr = r + dict[i][0];\\n            int nc = c + dict[i][1];\\n            if (nr < 0 || nr >= matrix.length ||\\n                nc < 0 || nc >= matrix[0].length) continue;\\n            if (mem[nr][nc] == mem[r][c] - 1) {\\n                List<String> rst = buildPath(matrix, nr, nc, mem);\\n                rst.add(0, r + \":\" + c + \":\" + matrix[r][c]);\\n                return rst;\\n            }\\n        }\\n        return new LinkedList<>();\\n    }\\n    \\n    private int dfs(int[][] matrix, int r, int c, int[][] mem) {\\n        if (mem[r][c] != 0) return mem[r][c];\\n        int max = 1;\\n        for (int i = 0; i < dict.length; i++) {\\n            int nr = r + dict[i][0];\\n            int nc = c + dict[i][1];\\n            if (nr < 0 || nc < 0 || nr >= matrix.length || nc >= matrix[0].length ||\\n                matrix[nr][nc] <= matrix[r][c]) continue;\\n            max = Math.max(max, dfs(matrix, nr, nc, mem) + 1);\\n        }\\n        mem[r][c] = max;\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int[][] dict = new int[][]{{0,1},{0,-1},{1,0},{-1,0}};\\n    \\n    public int longestIncreasingPath(int[][] matrix) {\\n        if (matrix == null || matrix.length == 0) return 0;\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int[][] mem = new int[row][col];\\n        int max = 0;\\n        for (int r = 0; r < row; r++) {\\n            for (int c = 0; c < col; c++) {\\n                max = Math.max(max, dfs(matrix, r, c, mem));\\n            }\\n        }\\n        for (int r = 0; r < row; r++) {\\n            for (int c = 0; c < col; c++) {\\n                if (mem[r][c] == max) {\\n                    System.out.println(buildPath(matrix, r, c, mem));\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    private List<String> buildPath(int[][] matrix, int r, int c, int[][] mem) {\\n        if (mem[r][c] == 1) {\\n            List<String> rst = new LinkedList<>();\\n            rst.add(r + \":\" + c + \":\" + matrix[r][c]);\\n            return rst;\\n        }\\n        for (int i = 0; i < dict.length; i++) {\\n            int nr = r + dict[i][0];\\n            int nc = c + dict[i][1];\\n            if (nr < 0 || nr >= matrix.length ||\\n                nc < 0 || nc >= matrix[0].length) continue;\\n            if (mem[nr][nc] == mem[r][c] - 1) {\\n                List<String> rst = buildPath(matrix, nr, nc, mem);\\n                rst.add(0, r + \":\" + c + \":\" + matrix[r][c]);\\n                return rst;\\n            }\\n        }\\n        return new LinkedList<>();\\n    }\\n    \\n    private int dfs(int[][] matrix, int r, int c, int[][] mem) {\\n        if (mem[r][c] != 0) return mem[r][c];\\n        int max = 1;\\n        for (int i = 0; i < dict.length; i++) {\\n            int nr = r + dict[i][0];\\n            int nc = c + dict[i][1];\\n            if (nr < 0 || nc < 0 || nr >= matrix.length || nc >= matrix[0].length ||\\n                matrix[nr][nc] <= matrix[r][c]) continue;\\n            max = Math.max(max, dfs(matrix, nr, nc, mem) + 1);\\n        }\\n        mem[r][c] = max;\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303386,
                "title": "easy-to-understand-matrix-dfs-optimization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int vis[200][200];\\n    int tra(vector<vector<int>>&arr,int i,int j,int x,int y){\\n        if(i<0||i>=arr.size()||j<0||j>=arr[0].size()){\\n            return 0;\\n        }\\n        if(x!=-1&&y!=-1&&arr[i][j]<=arr[x][y]){\\n            return 0;\\n        }\\n        if(x!=-1&&y!=-1&&arr[i][j]>arr[x][y]&&vis[i][j]!=0){\\n            return vis[i][j];\\n        }\\n        int ct=0;\\n        ct=max(ct,tra(arr,i-1,j,i,j));\\n        ct=max(ct,tra(arr,i+1,j,i,j));\\n        ct=max(ct,tra(arr,i,j-1,i,j));\\n        ct=max(ct,tra(arr,i,j+1,i,j));\\n        return vis[i][j]=ct+1;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& arr) {\\n        int ans=0;\\n        for(int i=0;i<arr.size();i++){\\n            for(int j=0;j<arr[0].size();j++){\\n                if(vis[i][j]==0){\\n                    tra(arr,i,j,-1,-1);\\n                }\\n                ans=max(ans,vis[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int vis[200][200];\\n    int tra(vector<vector<int>>&arr,int i,int j,int x,int y){\\n        if(i<0||i>=arr.size()||j<0||j>=arr[0].size()){\\n            return 0;\\n        }\\n        if(x!=-1&&y!=-1&&arr[i][j]<=arr[x][y]){\\n            return 0;\\n        }\\n        if(x!=-1&&y!=-1&&arr[i][j]>arr[x][y]&&vis[i][j]!=0){\\n            return vis[i][j];\\n        }\\n        int ct=0;\\n        ct=max(ct,tra(arr,i-1,j,i,j));\\n        ct=max(ct,tra(arr,i+1,j,i,j));\\n        ct=max(ct,tra(arr,i,j-1,i,j));\\n        ct=max(ct,tra(arr,i,j+1,i,j));\\n        return vis[i][j]=ct+1;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& arr) {\\n        int ans=0;\\n        for(int i=0;i<arr.size();i++){\\n            for(int j=0;j<arr[0].size();j++){\\n                if(vis[i][j]==0){\\n                    tra(arr,i,j,-1,-1);\\n                }\\n                ans=max(ans,vis[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397158,
                "title": "c-fast-recursive-memoized-well-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int helper(vector<vector<int>> &matrix, int i, int j, vector<vector<int>> &dp) {\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        int x = matrix[i][j];\\n        matrix[i][j] = -12;\\n        int u = i-1 >= 0 && matrix[i-1][j] > x ? helper(matrix,i-1,j,dp) : 0;\\n        int d = i+1 < matrix.size() && matrix[i+1][j] > x ? helper(matrix,i+1,j,dp) : 0;\\n        int l = j-1 >= 0 && matrix[i][j-1] > x ? helper(matrix,i,j-1,dp) : 0;\\n        int r = j+1 < matrix[0].size() && matrix[i][j+1] > x ? helper(matrix,i,j+1,dp) : 0;\\n        matrix[i][j] = x;\\n        return dp[i][j] = 1 + max({u, d, l, r});\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int m = matrix.size(), n = matrix[0].size(), ans=0;\\n        vector<vector<int>> dp(m, vector<int>(n,-1));\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n               dp[i][j] = helper(matrix, i, j, dp);\\n               ans = max(ans, dp[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nExplanation :\\n\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<vector<int>> &matrix, int i, int j, vector<vector<int>> &dp)\\n    {\\n        if(dp[i][j] != -1) // this step helps in saving time as we say memoization, initally \\n            // dp is filled with -1 but if its not -1 , it means we have updated d[i][j] \\n            // before so instead of recomputing, simply return dp[i][j] \\n            return dp[i][j]; \\n        // but when we updated dp[i][j] ? nice question, see the last statement of helper function\\n        \\n        int x = matrix[i][j]; // just for temporary cause, dont worry\\n        matrix[i][j] = -12; // we are dealing with matrix[i][j] and we are going to do               \\n\\t\\t// comparisons so just to be safe, we put negative value here , you can put -2 , -12         \\n\\t\\t// or anything, we havent lost original matrix[i][j] as its saved in x\\n        \\n        // This is heart of this question :\\n        // u, d, l, r are variables that helps to determine can we move in a particular             \\n\\t\\t// direction up, down, left or right respectively, if yes than how much units\\n        // The condition before ? for u, d, l, r is simple try to imagine it or draw on            \\n\\t\\t// paper.  Lets try : we have matrix :\\n        // 9 9 4\\n        // 6 6 8\\n        // 2 1 1 \\n        // lets say we are at i=0,j=0 that is 9 for this case we cant move in up or left \\n        // direction but only in right and down , this is it.\\n        // condition after && checks if next element is greater than current element (x)\\n        // if both condition holds call the helper method again and again to get how many \\n        // units you can move. If both condition dont satisfy simply store 0 as we cant move\\n        int u = i-1 >= 0 && matrix[i-1][j] > x ? helper(matrix,i-1,j,dp) : 0;\\n        int d = i+1 < matrix.size() && matrix[i+1][j] > x ? helper(matrix,i+1,j,dp) : 0;\\n        int l = j-1 >= 0 && matrix[i][j-1] > x ? helper(matrix,i,j-1,dp) : 0;\\n        int r = j+1 < matrix[0].size() && matrix[i][j+1] > x ? helper(matrix,i,j+1,dp) : 0;\\n        \\n        matrix[i][j] = x; // after recurive calls, lets give original value of matrix[i][j] back to it\\n        \\n        return dp[i][j] = 1 + max({u, d, l, r}); // 1 + because question is silly, \\n        // longest path means 1->2->6->9 o/p should be 3 as we had 3 movements but question wants 4 as its taking into consideration \\n\\t\\t// original element also on which we are standing or beginning. max point is clear i guess as we need max value from up, down, left and\\n\\t\\t// right for particular (i,j). Not only we are returning 1 + ( max of up, down, left, right ) we are also updating the value in dp[i][j] \\n\\t\\t// before returning, this is the whole point of having dp matrix , just to save time. Lets take an example, as in question:\\n        // matrix: 9 9 4       dp in beginning is -1 -1 -1\\n        //         6 6 8                          -1 -1 -1\\n        //         2 1 1                          -1 -1 -1\\n        // lets go to function call when i = 2, j = 1, at this point we are at element 1 at \\n        // second row and first column, after computing our answer which is 4 ofcourse, we \\n        // are saving it in dp[2][1] so that value becomes 4\\n        // I know before coming to this point all the previous values in dp before i = 2, j\\n        // = 1 has been updated , but the idea is same for every dp\\'s element\\n    }\\n\\t\\n\\t\\n    int longestIncreasingPath(vector<vector<int>>& matrix) \\n    {\\n        // Initialize m and n with size of matrix, ans is our final answer\\n        int m = matrix.size(), n = matrix[0].size(), ans=0;\\n        // Create a 2d vector dp which will help us in memoization to have fast solution\\n        // We initialized it with -1 and its size is m*n same as matrix\\n        vector<vector<int>> dp(m, vector<int>(n,-1));\\n         \\n        // Iterate over each and every element of matrix and find the longest increasing             \\n\\t\\t// path by calling helper method for each and every element of matrix \\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                // for particular i,j element of matrix we have maximum increasing sum in \\n                // dp[i][j] which we received from helper method\\n               dp[i][j] = helper(matrix, i, j, dp);    \\n                // compare evert time is this max inc sum greater than any previous sum we \\n                // obtained so far, if yes update ans variable\\n               ans = max(ans, dp[i][j]);\\n            }\\n        }\\n        return ans; // output\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<vector<int>> &matrix, int i, int j, vector<vector<int>> &dp) {\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        int x = matrix[i][j];\\n        matrix[i][j] = -12;\\n        int u = i-1 >= 0 && matrix[i-1][j] > x ? helper(matrix,i-1,j,dp) : 0;\\n        int d = i+1 < matrix.size() && matrix[i+1][j] > x ? helper(matrix,i+1,j,dp) : 0;\\n        int l = j-1 >= 0 && matrix[i][j-1] > x ? helper(matrix,i,j-1,dp) : 0;\\n        int r = j+1 < matrix[0].size() && matrix[i][j+1] > x ? helper(matrix,i,j+1,dp) : 0;\\n        matrix[i][j] = x;\\n        return dp[i][j] = 1 + max({u, d, l, r});\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int m = matrix.size(), n = matrix[0].size(), ans=0;\\n        vector<vector<int>> dp(m, vector<int>(n,-1));\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n               dp[i][j] = helper(matrix, i, j, dp);\\n               ans = max(ans, dp[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int helper(vector<vector<int>> &matrix, int i, int j, vector<vector<int>> &dp)\\n    {\\n        if(dp[i][j] != -1) // this step helps in saving time as we say memoization, initally \\n            // dp is filled with -1 but if its not -1 , it means we have updated d[i][j] \\n            // before so instead of recomputing, simply return dp[i][j] \\n            return dp[i][j]; \\n        // but when we updated dp[i][j] ? nice question, see the last statement of helper function\\n        \\n        int x = matrix[i][j]; // just for temporary cause, dont worry\\n        matrix[i][j] = -12; // we are dealing with matrix[i][j] and we are going to do               \\n\\t\\t// comparisons so just to be safe, we put negative value here , you can put -2 , -12         \\n\\t\\t// or anything, we havent lost original matrix[i][j] as its saved in x\\n        \\n        // This is heart of this question :\\n        // u, d, l, r are variables that helps to determine can we move in a particular             \\n\\t\\t// direction up, down, left or right respectively, if yes than how much units\\n        // The condition before ? for u, d, l, r is simple try to imagine it or draw on            \\n\\t\\t// paper.  Lets try : we have matrix :\\n        // 9 9 4\\n        // 6 6 8\\n        // 2 1 1 \\n        // lets say we are at i=0,j=0 that is 9 for this case we cant move in up or left \\n        // direction but only in right and down , this is it.\\n        // condition after && checks if next element is greater than current element (x)\\n        // if both condition holds call the helper method again and again to get how many \\n        // units you can move. If both condition dont satisfy simply store 0 as we cant move\\n        int u = i-1 >= 0 && matrix[i-1][j] > x ? helper(matrix,i-1,j,dp) : 0;\\n        int d = i+1 < matrix.size() && matrix[i+1][j] > x ? helper(matrix,i+1,j,dp) : 0;\\n        int l = j-1 >= 0 && matrix[i][j-1] > x ? helper(matrix,i,j-1,dp) : 0;\\n        int r = j+1 < matrix[0].size() && matrix[i][j+1] > x ? helper(matrix,i,j+1,dp) : 0;\\n        \\n        matrix[i][j] = x; // after recurive calls, lets give original value of matrix[i][j] back to it\\n        \\n        return dp[i][j] = 1 + max({u, d, l, r}); // 1 + because question is silly, \\n        // longest path means 1->2->6->9 o/p should be 3 as we had 3 movements but question wants 4 as its taking into consideration \\n\\t\\t// original element also on which we are standing or beginning. max point is clear i guess as we need max value from up, down, left and\\n\\t\\t// right for particular (i,j). Not only we are returning 1 + ( max of up, down, left, right ) we are also updating the value in dp[i][j] \\n\\t\\t// before returning, this is the whole point of having dp matrix , just to save time. Lets take an example, as in question:\\n        // matrix: 9 9 4       dp in beginning is -1 -1 -1\\n        //         6 6 8                          -1 -1 -1\\n        //         2 1 1                          -1 -1 -1\\n        // lets go to function call when i = 2, j = 1, at this point we are at element 1 at \\n        // second row and first column, after computing our answer which is 4 ofcourse, we \\n        // are saving it in dp[2][1] so that value becomes 4\\n        // I know before coming to this point all the previous values in dp before i = 2, j\\n        // = 1 has been updated , but the idea is same for every dp\\'s element\\n    }\\n\\t\\n\\t\\n    int longestIncreasingPath(vector<vector<int>>& matrix) \\n    {\\n        // Initialize m and n with size of matrix, ans is our final answer\\n        int m = matrix.size(), n = matrix[0].size(), ans=0;\\n        // Create a 2d vector dp which will help us in memoization to have fast solution\\n        // We initialized it with -1 and its size is m*n same as matrix\\n        vector<vector<int>> dp(m, vector<int>(n,-1));\\n         \\n        // Iterate over each and every element of matrix and find the longest increasing             \\n\\t\\t// path by calling helper method for each and every element of matrix \\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                // for particular i,j element of matrix we have maximum increasing sum in \\n                // dp[i][j] which we received from helper method\\n               dp[i][j] = helper(matrix, i, j, dp);    \\n                // compare evert time is this max inc sum greater than any previous sum we \\n                // obtained so far, if yes update ans variable\\n               ans = max(ans, dp[i][j]);\\n            }\\n        }\\n        return ans; // output\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357552,
                "title": "c-faster-than-80-dfs-memoization-easy-to-understand",
                "content": "**Before you see this solution, I would highly suggest you to try these two below problem :**\\n***\\uD83D\\uDC49 [https://leetcode.com/problems/number-of-islands/***\\n***\\uD83D\\uDC49 https://leetcode.com/problems/max-area-of-island***\\n\\nIf you solved the above problems, that\\'s great.\\uD83D\\uDC4D You can try again this problem and if you still can\\'t, then continue seeing this solution.\\nIn case you couldn\\'t solve above link problems, just continue reading this solution post, everything will become crystal-clear to you.\\uD83D\\uDC47\\n\\n**\\uD83D\\uDC7E Number of Islands Solution**\\n```\\nclass Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int count= 0;\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[i].size(); j++){\\n                if(grid[i][j] == \\'1\\')\\n                    count+= dfs(grid, i, j);\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    int dfs(vector<vector<char>>& grid, int i, int j){\\n        if(i<0 || i>=grid.size() || j<0 || j>=grid[i].size() || grid[i][j] == \\'0\\')\\n            return 0;\\n        \\n        grid[i][j] = \\'0\\';\\n        dfs(grid, i+1, j);\\n        dfs(grid, i-1, j);\\n        dfs(grid, i, j+1);\\n        dfs(grid, i, j-1);\\n        return 1;\\n    }\\n};\\n```\\n\\n**\\uD83E\\uDD16 Max Area of Islands Solution**\\n```\\nclass Solution {\\npublic:\\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\\n        int maxarea= 0;\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[i].size(); j++){\\n                if(grid[i][j] == 1){\\n                    maxarea = max(maxarea, dfs(grid, i, j));\\n                }\\n            }\\n        }\\n        \\n        return maxarea;\\n    }\\n    \\n    int dfs(vector<vector<int>>& grid, int i, int j){\\n        if(i<0 || i>=grid.size() || j<0 || j>=grid[i].size() || grid[i][j] == 0)\\n            return 0;\\n        \\n        grid[i][j] = 0;\\n        int count = 1;\\n        count += dfs(grid, i+1, j);\\n        count += dfs(grid, i-1, j);\\n        count += dfs(grid, i, j+1);\\n        count += dfs(grid, i, j-1);\\n        \\n        return count;\\n    }\\n};\\n```\\n\\n***Finally, now if you think you can solve this problem, try again, & then go ahead if you can\\'t.***\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[200][200];\\n    int n, m;\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int cnt = 0;\\n        n = size(matrix), m = size(matrix[0]);\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                cnt = max(cnt, dfs(matrix, i, j, -1));            \\n        return cnt;\\n    }\\n    \\n    int dfs(vector<vector<int>>& mat, int i, int j, int prev){\\n        //Base Case\\n        if(i < 0 || j < 0 || i >= n || j >= m || mat[i][j] <= prev) return 0;\\n        \\n        //Memoization check\\n        if(dp[i][j]) return dp[i][j];\\n        \\n        //Recursive relation\\n        return dp[i][j] = 1 + max({ dfs(mat, i + 1, j, mat[i][j]),\\n                                    dfs(mat, i - 1, j, mat[i][j]),\\n                                    dfs(mat, i, j + 1, mat[i][j]),\\n                                    dfs(mat, i, j - 1, mat[i][j]) });       \\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int count= 0;\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[i].size(); j++){\\n                if(grid[i][j] == \\'1\\')\\n                    count+= dfs(grid, i, j);\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    int dfs(vector<vector<char>>& grid, int i, int j){\\n        if(i<0 || i>=grid.size() || j<0 || j>=grid[i].size() || grid[i][j] == \\'0\\')\\n            return 0;\\n        \\n        grid[i][j] = \\'0\\';\\n        dfs(grid, i+1, j);\\n        dfs(grid, i-1, j);\\n        dfs(grid, i, j+1);\\n        dfs(grid, i, j-1);\\n        return 1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\\n        int maxarea= 0;\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[i].size(); j++){\\n                if(grid[i][j] == 1){\\n                    maxarea = max(maxarea, dfs(grid, i, j));\\n                }\\n            }\\n        }\\n        \\n        return maxarea;\\n    }\\n    \\n    int dfs(vector<vector<int>>& grid, int i, int j){\\n        if(i<0 || i>=grid.size() || j<0 || j>=grid[i].size() || grid[i][j] == 0)\\n            return 0;\\n        \\n        grid[i][j] = 0;\\n        int count = 1;\\n        count += dfs(grid, i+1, j);\\n        count += dfs(grid, i-1, j);\\n        count += dfs(grid, i, j+1);\\n        count += dfs(grid, i, j-1);\\n        \\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[200][200];\\n    int n, m;\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int cnt = 0;\\n        n = size(matrix), m = size(matrix[0]);\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                cnt = max(cnt, dfs(matrix, i, j, -1));            \\n        return cnt;\\n    }\\n    \\n    int dfs(vector<vector<int>>& mat, int i, int j, int prev){\\n        //Base Case\\n        if(i < 0 || j < 0 || i >= n || j >= m || mat[i][j] <= prev) return 0;\\n        \\n        //Memoization check\\n        if(dp[i][j]) return dp[i][j];\\n        \\n        //Recursive relation\\n        return dp[i][j] = 1 + max({ dfs(mat, i + 1, j, mat[i][j]),\\n                                    dfs(mat, i - 1, j, mat[i][j]),\\n                                    dfs(mat, i, j + 1, mat[i][j]),\\n                                    dfs(mat, i, j - 1, mat[i][j]) });       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917132,
                "title": "java-simple-solution",
                "content": "Create a dp Array to store the path for every element and store the maximum path received from all four direction on that index.\\n1. Explore every path using dfs \\n2. Store the result\\n3. if already explored used same result\\n\\n```\\n\\nclass Solution {\\n    public int longestIncreasingPath(int[][] matrix) {\\n        \\n\\t\\t//Base condition\\n        if(matrix.length==0)\\n            return 0;\\n        \\n\\t\\t\\n        int dp[][] = new int[matrix.length][matrix[0].length];\\n        int max = 0;\\n        \\n        for(int i =0;i<matrix.length;i++){\\n            for(int j =0;j<matrix[0].length;j++){\\n                //result is not stored\\n                if(dp[i][j]==0){\\n                   dfs(matrix,i,j,Integer.MIN_VALUE,dp);\\n                   max = Math.max(dp[i][j],max); \\n                }\\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    private int dfs(int[][] matrix,int i,int j,int pre,int[][] dp){\\n        //Dont fo beyond boundaries and next element should be greater for increasing path\\n        if(i<0 || j<0 ||i>=matrix.length || j>=matrix[0].length || pre>=matrix[i][j])\\n            return 0;\\n\\t\\t\\t\\n\\t\\t//already explored\\n        else if(dp[i][j]!=0) return dp[i][j];\\n        \\n\\t\\t//exploring all direction\\n        int pathOne = dfs(matrix,i+1,j,matrix[i][j],dp);\\n        int pathTwo = dfs(matrix,i-1,j,matrix[i][j],dp);\\n        int pathThree = dfs(matrix,i,j-1,matrix[i][j],dp);\\n        int pathFour = dfs(matrix,i,j+1,matrix[i][j],dp);\\n        \\n\\t\\t//finding the max path\\n        int maxOne = Math.max(pathOne,pathTwo);\\n        int maxTwo = Math.max(pathThree,pathFour);\\n        \\n\\t\\t//store maximum path on that index\\n        dp[i][j] = 1+Math.max(maxOne,maxTwo);\\n        \\n        return dp[i][j];\\n        \\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int longestIncreasingPath(int[][] matrix) {\\n        \\n\\t\\t//Base condition\\n        if(matrix.length==0)\\n            return 0;\\n        \\n\\t\\t\\n        int dp[][] = new int[matrix.length][matrix[0].length];\\n        int max = 0;\\n        \\n        for(int i =0;i<matrix.length;i++){\\n            for(int j =0;j<matrix[0].length;j++){\\n                //result is not stored\\n                if(dp[i][j]==0){\\n                   dfs(matrix,i,j,Integer.MIN_VALUE,dp);\\n                   max = Math.max(dp[i][j],max); \\n                }\\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    private int dfs(int[][] matrix,int i,int j,int pre,int[][] dp){\\n        //Dont fo beyond boundaries and next element should be greater for increasing path\\n        if(i<0 || j<0 ||i>=matrix.length || j>=matrix[0].length || pre>=matrix[i][j])\\n            return 0;\\n\\t\\t\\t\\n\\t\\t//already explored\\n        else if(dp[i][j]!=0) return dp[i][j];\\n        \\n\\t\\t//exploring all direction\\n        int pathOne = dfs(matrix,i+1,j,matrix[i][j],dp);\\n        int pathTwo = dfs(matrix,i-1,j,matrix[i][j],dp);\\n        int pathThree = dfs(matrix,i,j-1,matrix[i][j],dp);\\n        int pathFour = dfs(matrix,i,j+1,matrix[i][j],dp);\\n        \\n\\t\\t//finding the max path\\n        int maxOne = Math.max(pathOne,pathTwo);\\n        int maxTwo = Math.max(pathThree,pathFour);\\n        \\n\\t\\t//store maximum path on that index\\n        dp[i][j] = 1+Math.max(maxOne,maxTwo);\\n        \\n        return dp[i][j];\\n        \\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 651529,
                "title": "dfs-with-memoization",
                "content": "idea is simple , traverse in all 4 valid directions where its possible and make mark it as visited,\\nstore answers for all cells which you have scene so far essencially catching the answers for cells\\n```\\nint x[] = {-1,0,1,0};      // these will guide us for our next direction\\nint y[] = {0,1,0,-1};     // here direction are in order up, right , down , left , ie. clockwise from up\\nclass Solution {\\npublic:\\n    int n,m;    vector<vector<int>> dp; vector<vector<bool>> vis;\\n    int ans=0;\\n\\n    int dfs(vector<vector<int>> &mat , int i, int j)\\n    {\\n        if(dp[i][j])    return dp[i][j];\\n        vis[i][j] = true;\\n        int small_ans = 0;\\n        for(int k=0 ; k<4 ; k++)\\n        {\\n            int newi = i+x[k];\\n            int newj = j+y[k];\\n\\t\\t\\t// now make sure newi and newj are within bounds and valid , valid means that we have not previously visited in current DFS chain\\n\\t\\t\\t//and matric of newi,j as greater than our previous location.\\n            if(newi>=0 and newj>=0 and newi<n and newj<m and mat[newi][newj]>mat[i][j] and vis[newi][newj] == false)\\n               small_ans = max(small_ans , dfs(mat,newi,newj) + 1);\\n        }\\n        dp[i][j] = max(1, small_ans);\\n        vis[i][j] = false;\\n        ans = max(ans , dp[i][j]);\\n        return dp[i][j];\\n    }\\n    \\n    int longestIncreasingPath(vector<vector<int>>& mat) {\\n        n = mat.size();\\n        if(n==0)    return 0;\\n        m = mat[0].size();\\n        dp = vector<vector<int>>(n, vector<int>(m));\\n        vis = vector<vector<bool>>(n,vector<bool>(m));\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            for(int j=0 ; j<m ; j++)\\n            {\\n                dfs(mat,i,j);\\n            }\\n        }\\n    return ans;        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nint x[] = {-1,0,1,0};      // these will guide us for our next direction\\nint y[] = {0,1,0,-1};     // here direction are in order up, right , down , left , ie. clockwise from up\\nclass Solution {\\npublic:\\n    int n,m;    vector<vector<int>> dp; vector<vector<bool>> vis;\\n    int ans=0;\\n\\n    int dfs(vector<vector<int>> &mat , int i, int j)\\n    {\\n        if(dp[i][j])    return dp[i][j];\\n        vis[i][j] = true;\\n        int small_ans = 0;\\n        for(int k=0 ; k<4 ; k++)\\n        {\\n            int newi = i+x[k];\\n            int newj = j+y[k];\\n\\t\\t\\t// now make sure newi and newj are within bounds and valid , valid means that we have not previously visited in current DFS chain\\n\\t\\t\\t//and matric of newi,j as greater than our previous location.\\n            if(newi>=0 and newj>=0 and newi<n and newj<m and mat[newi][newj]>mat[i][j] and vis[newi][newj] == false)\\n               small_ans = max(small_ans , dfs(mat,newi,newj) + 1);\\n        }\\n        dp[i][j] = max(1, small_ans);\\n        vis[i][j] = false;\\n        ans = max(ans , dp[i][j]);\\n        return dp[i][j];\\n    }\\n    \\n    int longestIncreasingPath(vector<vector<int>>& mat) {\\n        n = mat.size();\\n        if(n==0)    return 0;\\n        m = mat[0].size();\\n        dp = vector<vector<int>>(n, vector<int>(m));\\n        vis = vector<vector<bool>>(n,vector<bool>(m));\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            for(int j=0 ; j<m ; j++)\\n            {\\n                dfs(mat,i,j);\\n            }\\n        }\\n    return ans;        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 288758,
                "title": "javascript-short-clean-and-easy-to-read-solution",
                "content": "Solution uses depth-first search (DFS) and memory (dynamic programmimg)\\n\\nBeats 100% on a good run with 76ms \\n\\nShould be less convoluted and easier to understand than some of the existing Javascript solutions out there (at the time)\\n\\n```\\n/**\\n * @param {number[][]} matrix\\n * @return {number}\\n */\\nvar longestIncreasingPath = function(matrix) {\\n    if (!matrix.length) return 0;\\n    const rows = matrix.length;\\n    const cols = matrix[0].length;\\n    \\n    // mem keeps the longest path count that starts at matrix[row][col]\\n    const mem = new Array(rows);\\n    for (let i = 0; i < mem.length; i++) {\\n        mem[i] = new Array(cols);\\n    }\\n    \\n    // DFS helper that recursively looks to the top, bottom, left, and right\\n    const dfs = (i = 0, j = 0, min = Number.MIN_SAFE_INTEGER) => {\\n        if (i < 0 || j < 0 || i >= rows || j >= cols) {\\n            return 0;\\n        }\\n        \\n        if (matrix[i][j] <= min) {\\n            return 0;\\n        }\\n        \\n        if (mem[i][j] != null) {\\n            return mem[i][j];\\n        }\\n        \\n        let top = dfs(i+1, j, matrix[i][j]);\\n        let bottom = dfs(i-1, j, matrix[i][j]);\\n        let right = dfs(i, j+1, matrix[i][j]);\\n        let left = dfs(i, j-1, matrix[i][j]);\\n        \\n        let count = 1 + Math.max(top, bottom, left, right);\\n        mem[i][j] = count;\\n        return count;\\n    };\\n    \\n    let maxCount = 0;\\n    // Compute the distance from every point in matrix\\n    for (let i = 0; i < rows; i++) {\\n        for (let j = 0; j < cols; j++) {\\n            maxCount = Math.max(maxCount, dfs(i, j));\\n        }\\n    }\\n    \\n    return maxCount;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {number}\\n */\\nvar longestIncreasingPath = function(matrix) {\\n    if (!matrix.length) return 0;\\n    const rows = matrix.length;\\n    const cols = matrix[0].length;\\n    \\n    // mem keeps the longest path count that starts at matrix[row][col]\\n    const mem = new Array(rows);\\n    for (let i = 0; i < mem.length; i++) {\\n        mem[i] = new Array(cols);\\n    }\\n    \\n    // DFS helper that recursively looks to the top, bottom, left, and right\\n    const dfs = (i = 0, j = 0, min = Number.MIN_SAFE_INTEGER) => {\\n        if (i < 0 || j < 0 || i >= rows || j >= cols) {\\n            return 0;\\n        }\\n        \\n        if (matrix[i][j] <= min) {\\n            return 0;\\n        }\\n        \\n        if (mem[i][j] != null) {\\n            return mem[i][j];\\n        }\\n        \\n        let top = dfs(i+1, j, matrix[i][j]);\\n        let bottom = dfs(i-1, j, matrix[i][j]);\\n        let right = dfs(i, j+1, matrix[i][j]);\\n        let left = dfs(i, j-1, matrix[i][j]);\\n        \\n        let count = 1 + Math.max(top, bottom, left, right);\\n        mem[i][j] = count;\\n        return count;\\n    };\\n    \\n    let maxCount = 0;\\n    // Compute the distance from every point in matrix\\n    for (let i = 0; i < rows; i++) {\\n        for (let j = 0; j < cols; j++) {\\n            maxCount = Math.max(maxCount, dfs(i, j));\\n        }\\n    }\\n    \\n    return maxCount;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3242417,
                "title": "329-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe problem can be solved by performing a depth-first search (DFS) on each cell of the matrix and keeping track of the longest increasing path found so far. We start the search from each cell of the matrix and for each cell, we move in all four directions (left, right, up, and down) to find the increasing path. We use memoization to store the length of the longest increasing path starting from each cell to avoid recomputing it.\\n\\nStep-by-step algorithm:\\n\\n1. Create a memoization matrix of the same size as the input matrix to store the length of the longest increasing path starting from each cell.\\n2. For each cell in the matrix, perform a DFS to find the length of the longest increasing path starting from that cell.\\n3. During the DFS, for each unvisited neighbor of the current cell that has a greater value, perform a DFS on that neighbor and update the memoization matrix with the length of the longest increasing path starting from that neighbor.\\n4. If we have already computed the length of the longest increasing path starting from a neighbor, we can use that value from the memoization matrix instead of recomputing it.\\n5. During the DFS, keep track of the maximum length of the increasing path found so far and return it as the result.\\n\\nTime Complexity: O(mn), where m and n are the dimensions of the matrix, as we perform a DFS starting from each cell of the matrix, and each cell is visited only once.\\n\\nSpace Complexity: O(mn), for the memoization matrix used to store the length of the longest increasing path starting from each cell.\\n\\n# Complexity\\n- Time complexity:\\n89.87%\\n\\n- Space complexity:\\n53.39%\\n\\n# Code\\n```\\nclass Solution:\\n  def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n    if not matrix:\\n        return 0\\n    m, n = len(matrix), len(matrix[0])\\n    memo = [[0]*n for _ in range(m)]   # memoization matrix to store the length of the longest increasing path starting from each cell\\n    res = 0   # maximum length of the increasing path found so far\\n    \\n    # DFS function to find the length of the longest increasing path starting from the current cell\\n    def dfs(i, j):\\n        if memo[i][j]:\\n            return memo[i][j]\\n        path = 1   # length of the increasing path starting from the current cell\\n        for x, y in [(0, 1), (0, -1), (1, 0), (-1, 0)]:   # explore all four directions (right, left, down, up)\\n            if 0 <= i+x < m and 0 <= j+y < n and matrix[i+x][j+y] > matrix[i][j]:   # if the neighbor has a greater value, move to it\\n                path = max(path, 1 + dfs(i+x, j+y))   # update the length of the increasing path\\n        memo[i][j] = path   # memoize the length of the increasing path starting from the current cell\\n        return path\\n    \\n    for i in range(m):\\n        for j in range(n):\\n            res = max(res, dfs(i, j))   # update the maximum length of the increasing path found so far\\n    return res\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n  def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n    if not matrix:\\n        return 0\\n    m, n = len(matrix), len(matrix[0])\\n    memo = [[0]*n for _ in range(m)]   # memoization matrix to store the length of the longest increasing path starting from each cell\\n    res = 0   # maximum length of the increasing path found so far\\n    \\n    # DFS function to find the length of the longest increasing path starting from the current cell\\n    def dfs(i, j):\\n        if memo[i][j]:\\n            return memo[i][j]\\n        path = 1   # length of the increasing path starting from the current cell\\n        for x, y in [(0, 1), (0, -1), (1, 0), (-1, 0)]:   # explore all four directions (right, left, down, up)\\n            if 0 <= i+x < m and 0 <= j+y < n and matrix[i+x][j+y] > matrix[i][j]:   # if the neighbor has a greater value, move to it\\n                path = max(path, 1 + dfs(i+x, j+y))   # update the length of the increasing path\\n        memo[i][j] = path   # memoize the length of the increasing path starting from the current cell\\n        return path\\n    \\n    for i in range(m):\\n        for j in range(n):\\n            res = max(res, dfs(i, j))   # update the maximum length of the increasing path found so far\\n    return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1348141,
                "title": "java-7-ms-simple-dfs-memoization",
                "content": "```\\nclass Solution {\\n    public int longestIncreasingPath(int[][] matrix) {\\n        int[][] dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int[][] dp = new int[n][m];\\n        int max = 0;\\n        for(int[] d : dp) Arrays.fill(d, -1);\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                max = Math.max(max,dfs(matrix, i, j, dir, dp));\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    public int dfs(int[][] arr, int sr, int sc, int[][] dir, int[][] dp){\\n        if(dp[sr][sc] != -1) return dp[sr][sc];\\n        int count = 0;\\n        for(int d = 0 ; d < dir.length ; d++){\\n            int r = sr + dir[d][0];\\n            int c = sc + dir[d][1];\\n            if(r < arr.length && c < arr[0].length && r >= 0 && c >= 0 && arr[r][c] > arr[sr][sc]){\\n                count = Math.max(count,dfs(arr, r, c, dir, dp));\\n            }\\n        }\\n        return dp[sr][sc] = count + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int longestIncreasingPath(int[][] matrix) {\\n        int[][] dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int[][] dp = new int[n][m];\\n        int max = 0;\\n        for(int[] d : dp) Arrays.fill(d, -1);\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                max = Math.max(max,dfs(matrix, i, j, dir, dp));\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    public int dfs(int[][] arr, int sr, int sc, int[][] dir, int[][] dp){\\n        if(dp[sr][sc] != -1) return dp[sr][sc];\\n        int count = 0;\\n        for(int d = 0 ; d < dir.length ; d++){\\n            int r = sr + dir[d][0];\\n            int c = sc + dir[d][1];\\n            if(r < arr.length && c < arr[0].length && r >= 0 && c >= 0 && arr[r][c] > arr[sr][sc]){\\n                count = Math.max(count,dfs(arr, r, c, dir, dp));\\n            }\\n        }\\n        return dp[sr][sc] = count + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780427,
                "title": "python-dfs-memo",
                "content": "```\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        if not matrix or not matrix[0]:\\n            return 0\\n        \\n        visited = {}\\n        res = 0\\n        \\n        m = len(matrix)\\n        n = len(matrix[0])\\n        \\n        def dfs(i, j):\\n            if (i,j) in visited:\\n                return visited[(i,j)]\\n            \\n            step = 1\\n            for x,y in ((0,1),(0,-1),(1,0),(-1,0)):\\n                ni = i+x\\n                nj = j+y\\n                if 0<=ni<m and 0<=nj<n and matrix[ni][nj] > matrix[i][j]:\\n                    tmp = 1 + dfs(ni, nj)\\n                    step = max(tmp, step)\\n            visited[(i,j)] = step\\n            return step\\n        \\n        \\n        for i in range(m):\\n            for j in range(n):\\n                tmp = dfs(i,j)\\n                res = max(res, tmp)\\n        \\n        return res",
                "solutionTags": [],
                "code": "class Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        if not matrix or not matrix[0]:\\n            return 0\\n        \\n        visited = {}",
                "codeTag": "Java"
            },
            {
                "id": 760499,
                "title": "python-dfs-memoization",
                "content": "A simple DFS solution results in a TLE. We can observe that the computation is repeated when we re-visit the cell a second time. So we can cache the maximum length at each cell and reuse it.\\nThis reduces the complexity from exponential to O(mn).\\n\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.grid = []\\n        self.rows = 0\\n        self.cols = 0\\n        self.global_max = 0\\n        self.memo = {}\\n        \\n    def dfs(self, curr_row, curr_col,target_val):\\n        #checking the bounds\\n        if curr_row<0 or curr_row>=self.rows or curr_col<0 or curr_col>=self.cols:    \\n            return 0\\n        #we need to search a cell only if it is a part of an increasing sequence and \\n        #is not being processed.\\n        \\n        if self.grid[curr_row][curr_col] == -1 or self.grid[curr_row][curr_col]<=target_val :\\n            return 0\\n        \\n        #check if we have the results in cache\\n        if (curr_row, curr_col) in self.memo:\\n            return self.memo[(curr_row, curr_col)]\\n        \\n        #store a temporary copy of the variable and update the cell to -1 to indicate that it\\'s being processed.\\n        tmp = self.grid[curr_row][curr_col]\\n        self.grid[curr_row][curr_col] = -1\\n        \\n        #four directions\\n        co_ords = [[1,0], [-1,0], [0,-1], [0,1]]\\n        #variable for max length at that cell\\n        cmax = 0\\n        \\n        for co_ord in co_ords:\\n            \\n            nr, nc = curr_row+co_ord[0] , curr_col+co_ord[1]        \\n            cmax = max(cmax, self.dfs(nr, nc, tmp))\\n        \\n        #reset the value after the processing is complete\\n        self.grid[curr_row][curr_col] = tmp\\n        #store the value for the cell in cache\\n        self.memo[(curr_row, curr_col)] = cmax+1\\n        return cmax+1\\n            \\n    \\n    \\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        if len(matrix)==0:\\n            return 0\\n        \\n        self.grid=matrix\\n        self.rows = len(matrix)\\n        self.cols = len(matrix[0])\\n        \\n        for i in range(self.rows):\\n            for j in range(self.cols):     \\n                curr_len = self.dfs(i,j,-1)\\n                self.global_max= max(self.global_max, curr_len)\\n               \\n        \\n        return self.global_max\\n\\t\\t\\n\\t\\t\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "class Solution:\\n    def __init__(self):\\n        self.grid = []\\n        self.rows = 0\\n        self.cols = 0\\n        self.global_max = 0\\n        self.memo = {}",
                "codeTag": "Java"
            },
            {
                "id": 518125,
                "title": "javascript-dfs-memoization",
                "content": "```\\nvar longestIncreasingPath = function(matrix) {\\n    \\n    const memo = {};\\n    \\n    function dfs(row, col) {\\n        \\n        if(memo[`${row},${col}`] !== undefined) {\\n            return memo[`${row},${col}`];\\n        }\\n        \\n        let count = 1;\\n        \\n        if(row + 1 < matrix.length && matrix[row+1][col] > matrix[row][col]) {\\n            count = Math.max(dfs(row+1, col) + 1, count);\\n        }\\n        \\n        if(row - 1 >= 0 && matrix[row-1][col] > matrix[row][col]) {\\n            count = Math.max(dfs(row-1, col) + 1, count);\\n        }\\n        \\n        if(col + 1 < matrix[0].length && matrix[row][col+1] > matrix[row][col]) {\\n            count = Math.max(dfs(row, col+1) + 1, count);\\n        }\\n        \\n        if(col - 1 >= 0 && matrix[row][col-1] > matrix[row][col]) {\\n            count = Math.max(dfs(row, col-1) + 1, count);\\n        }\\n        \\n        memo[`${row},${col}`] = count;\\n        \\n        return count; \\n    }\\n    \\n    let res = 0;\\n    \\n    for(let row = 0; row < matrix.length; row++) {\\n        for(let col = 0; col < matrix[0].length; col++) {\\n            res = Math.max(res, dfs(row, col));\\n        }\\n    }\\n    \\n    return res;\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar longestIncreasingPath = function(matrix) {\\n    \\n    const memo = {};\\n    \\n    function dfs(row, col) {\\n        \\n        if(memo[`${row},${col}`] !== undefined) {\\n            return memo[`${row},${col}`];\\n        }\\n        \\n        let count = 1;\\n        \\n        if(row + 1 < matrix.length && matrix[row+1][col] > matrix[row][col]) {\\n            count = Math.max(dfs(row+1, col) + 1, count);\\n        }\\n        \\n        if(row - 1 >= 0 && matrix[row-1][col] > matrix[row][col]) {\\n            count = Math.max(dfs(row-1, col) + 1, count);\\n        }\\n        \\n        if(col + 1 < matrix[0].length && matrix[row][col+1] > matrix[row][col]) {\\n            count = Math.max(dfs(row, col+1) + 1, count);\\n        }\\n        \\n        if(col - 1 >= 0 && matrix[row][col-1] > matrix[row][col]) {\\n            count = Math.max(dfs(row, col-1) + 1, count);\\n        }\\n        \\n        memo[`${row},${col}`] = count;\\n        \\n        return count; \\n    }\\n    \\n    let res = 0;\\n    \\n    for(let row = 0; row < matrix.length; row++) {\\n        for(let col = 0; col < matrix[0].length; col++) {\\n            res = Math.max(res, dfs(row, col));\\n        }\\n    }\\n    \\n    return res;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 78345,
                "title": "clean-c-29ms-dp-solution-beats-96-39",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        if(matrix.size() == 0 || matrix[0].size() == 0) return 0;\\n        int m = matrix.size() , n = matrix[0].size();\\n        vector<vector<int>>dp(m, vector<int>(n));\\n        vector<vector<int>>visited(m, vector<int>(n));\\n        int maxlen = 0;\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                maxlen = max(maxlen, DFS(matrix, visited, dp, i, j, m, n));\\n        return maxlen;\\n    }\\n    \\n    int DFS(vector<vector<int>>& matrix, vector<vector<int>>& visited, vector<vector<int>>& dp, int r, int c, int m, int n){\\n        if(visited[r][c]) return 0;\\n        if(dp[r][c]) return dp[r][c];\\n        visited[r][c] = 1;\\n        int up(1), down(1), left(1), right(1);\\n        if(r - 1 >= 0 && matrix[r - 1][c] > matrix[r][c])     up = DFS(matrix, visited, dp, r - 1, c, m, n) + 1;\\n        if(r + 1 < m  && matrix[r + 1][c] > matrix[r][c])   down = DFS(matrix, visited, dp, r + 1, c, m, n) + 1;\\n        if(c - 1 >= 0 && matrix[r][c - 1] > matrix[r][c])   left = DFS(matrix, visited, dp, r, c - 1, m, n) + 1;\\n        if(c + 1 < n  && matrix[r][c + 1] > matrix[r][c])  right = DFS(matrix, visited, dp, r, c + 1, m, n) + 1;\\n        visited[r][c] = 0;\\n        dp[r][c] = max(up, max(down, max(left, right)));\\n        return dp[r][c];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        if(matrix.size() == 0 || matrix[0].size() == 0) return 0;\\n        int m = matrix.size() , n = matrix[0].size();\\n        vector<vector<int>>dp(m, vector<int>(n));\\n        vector<vector<int>>visited(m, vector<int>(n));\\n        int maxlen = 0;\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                maxlen = max(maxlen, DFS(matrix, visited, dp, i, j, m, n));\\n        return maxlen;\\n    }\\n    \\n    int DFS(vector<vector<int>>& matrix, vector<vector<int>>& visited, vector<vector<int>>& dp, int r, int c, int m, int n){\\n        if(visited[r][c]) return 0;\\n        if(dp[r][c]) return dp[r][c];\\n        visited[r][c] = 1;\\n        int up(1), down(1), left(1), right(1);\\n        if(r - 1 >= 0 && matrix[r - 1][c] > matrix[r][c])     up = DFS(matrix, visited, dp, r - 1, c, m, n) + 1;\\n        if(r + 1 < m  && matrix[r + 1][c] > matrix[r][c])   down = DFS(matrix, visited, dp, r + 1, c, m, n) + 1;\\n        if(c - 1 >= 0 && matrix[r][c - 1] > matrix[r][c])   left = DFS(matrix, visited, dp, r, c - 1, m, n) + 1;\\n        if(c + 1 < n  && matrix[r][c + 1] > matrix[r][c])  right = DFS(matrix, visited, dp, r, c + 1, m, n) + 1;\\n        visited[r][c] = 0;\\n        dp[r][c] = max(up, max(down, max(left, right)));\\n        return dp[r][c];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652057,
                "title": "dfs-memoization-c-beats-85",
                "content": "# If it Helps You, Please Upvote me...\\u2764\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfor each and every cell **Apply DFS** to Compute the **longest Increasing** Path And Store the value of DFS Call using **Memoization**.\\n\\n# Complexity\\n- Time complexity:O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> X = {0,0,+1,-1};\\n    vector<int> Y = {+1,-1,0,0};\\n    int n,m;\\n    bool isvalid(int x,int y)\\n    {\\n        if(x<0 || x>=n || y<0 || y>=m)\\n        return false;\\n        \\n        return true;\\n    }\\n    int DFS(vector<vector<int>> &mat,int x,int y,vector<vector<int>> &dp)\\n    {\\n        int count = 0;\\n        if(dp[x][y]!=-1)\\n        return dp[x][y];\\n\\n        for(int i = 0;i<4;i++)\\n        {\\n            int nx = x+X[i],ny = y+Y[i];\\n            if(isvalid(nx,ny) && mat[x][y]<mat[nx][ny])\\n            count = max(count,1+DFS(mat,nx,ny,dp));\\n        }\\n        return dp[x][y] = count;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& mat) {\\n       n = mat.size();\\n       m = mat[0].size();\\n       vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n\\n      int ans = -1;\\n      for(int i = 0;i<n;i++)\\n      {\\n          for(int j = 0;j<m;j++)\\n          ans = max(ans,DFS(mat,i,j,dp));\\n      }\\n      return ans+1; \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/331202dc-9a0a-43a3-b3e6-bf55f833835b_1687084087.094313.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> X = {0,0,+1,-1};\\n    vector<int> Y = {+1,-1,0,0};\\n    int n,m;\\n    bool isvalid(int x,int y)\\n    {\\n        if(x<0 || x>=n || y<0 || y>=m)\\n        return false;\\n        \\n        return true;\\n    }\\n    int DFS(vector<vector<int>> &mat,int x,int y,vector<vector<int>> &dp)\\n    {\\n        int count = 0;\\n        if(dp[x][y]!=-1)\\n        return dp[x][y];\\n\\n        for(int i = 0;i<4;i++)\\n        {\\n            int nx = x+X[i],ny = y+Y[i];\\n            if(isvalid(nx,ny) && mat[x][y]<mat[nx][ny])\\n            count = max(count,1+DFS(mat,nx,ny,dp));\\n        }\\n        return dp[x][y] = count;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& mat) {\\n       n = mat.size();\\n       m = mat[0].size();\\n       vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n\\n      int ans = -1;\\n      for(int i = 0;i<n;i++)\\n      {\\n          for(int j = 0;j<m;j++)\\n          ans = max(ans,DFS(mat,i,j,dp));\\n      }\\n      return ans+1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049569,
                "title": "java-dfs-with-memoization",
                "content": "# Intuition\\n- DFS to find the longest path\\n- cache when the slot in matrix has been visited\\n\\n# Approach\\n- DFS\\n- Create `memo` matrix to track that it has been checked.\\n- return max from 4 directions + 1;\\n# Complexity\\n- Time complexity: $$O(n*m)$$\\n\\n- Space complexity: $$O(n*m)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestIncreasingPath(int[][] matrix) {\\n        int ROW = matrix.length;\\n        int COL = matrix[0].length;\\n\\n        int[][] memo = new int[ROW][COL];\\n\\n        int max = Integer.MIN_VALUE;\\n\\n        for(int i = 0; i < ROW; i++) {\\n            for(int j = 0; j < COL; j++) {\\n               int currMax = dfs(matrix, i, j, -1, memo);\\n               max = Math.max(max, currMax);\\n            }\\n        }\\n        return max;\\n    }\\n\\n    private int dfs(int[][] matrix, int i, int j, int previous, int[][] memo) {\\n        if(!isInBound(matrix, i, j)) return 0;\\n        if(previous >= matrix[i][j]) return 0;\\n        if(memo[i][j] != 0) return memo[i][j];\\n\\n\\n        int curr = matrix[i][j];\\n\\n        int top = dfs(matrix, i-1, j, curr, memo);\\n        int bottom = dfs(matrix, i+1, j, curr, memo);\\n        int left = dfs(matrix, i, j-1, curr, memo);\\n        int right = dfs(matrix, i, j+1, curr, memo);\\n\\n        int max = top;\\n        max = Math.max(max, bottom);\\n        max = Math.max(max, left);\\n        max = Math.max(max, right);\\n\\n\\n        memo[i][j] = max + 1;\\n        return memo[i][j];\\n    }\\n\\n    private boolean isInBound(int[][] matrix, int i, int j) {\\n        return i >=0 && j >= 0 && i < matrix.length && j < matrix[i].length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestIncreasingPath(int[][] matrix) {\\n        int ROW = matrix.length;\\n        int COL = matrix[0].length;\\n\\n        int[][] memo = new int[ROW][COL];\\n\\n        int max = Integer.MIN_VALUE;\\n\\n        for(int i = 0; i < ROW; i++) {\\n            for(int j = 0; j < COL; j++) {\\n               int currMax = dfs(matrix, i, j, -1, memo);\\n               max = Math.max(max, currMax);\\n            }\\n        }\\n        return max;\\n    }\\n\\n    private int dfs(int[][] matrix, int i, int j, int previous, int[][] memo) {\\n        if(!isInBound(matrix, i, j)) return 0;\\n        if(previous >= matrix[i][j]) return 0;\\n        if(memo[i][j] != 0) return memo[i][j];\\n\\n\\n        int curr = matrix[i][j];\\n\\n        int top = dfs(matrix, i-1, j, curr, memo);\\n        int bottom = dfs(matrix, i+1, j, curr, memo);\\n        int left = dfs(matrix, i, j-1, curr, memo);\\n        int right = dfs(matrix, i, j+1, curr, memo);\\n\\n        int max = top;\\n        max = Math.max(max, bottom);\\n        max = Math.max(max, left);\\n        max = Math.max(max, right);\\n\\n\\n        memo[i][j] = max + 1;\\n        return memo[i][j];\\n    }\\n\\n    private boolean isInBound(int[][] matrix, int i, int j) {\\n        return i >=0 && j >= 0 && i < matrix.length && j < matrix[i].length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2054882,
                "title": "c-dp-solution-dlc-may20",
                "content": "```\\nclass Solution {\\npublic:\\n    int dir[5] = {1, 0, -1, 0, 1};\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        //DP: Store longest path for previous element in a matrix, so whenever we need we can use thet value to find largest path\\n        int row = matrix.size(), col = matrix[0].size();\\n        vector<vector<int>> dp(row, vector<int>(col, 0));\\n        \\n        int mx = 0; //this will store the largest path value   \\n        for(int i=0; i<row; i++)\\n        {\\n            for(int j=0; j<col; j++)\\n            {\\n                mx = max(mx, helper(matrix, dp, i, j));  //find larget path by taking all elements one by one in the matrix\\n            }\\n        }\\n        \\n        return mx+1;\\n    }\\n    \\n    int helper(vector<vector<int>>& matrix, vector<vector<int>>& dp, int r, int c){\\n        int row = matrix.size(), col  = matrix[0].size();\\n        \\n        if(dp[r][c] !=0)    //if we already know what is the length of the path from here\\n            return dp[r][c];\\n        \\n        //we need to find the largest path from this place\\n        //look out in all four directions, one by one if there is any greater element than this current element(matrix[r][c])\\n        for(int i=0; i<4; i++)\\n        {\\n            int newr = dir[i]+r;\\n            int newc = dir[i+1]+c;\\n            \\n            if(isValid(newr, newc, row, col) && matrix[newr][newc] > matrix[r][c])\\n                dp[r][c] = max(dp[r][c], 1+helper(matrix, dp, newr, newc));  //max path we need from all four directions\\n        }\\n                               \\n        return dp[r][c];\\n    }\\n    \\n    bool isValid(int r, int c, int R, int C){\\n        return (r>=0 && c>=0 && r<R && c<C);\\n    }\\n//      bool isValid(int& r,int& c,int R, int C)\\n//     {\\n//         // if we are not inside the the boundary then return false \\n//         if(r<0 || c<0 || r>=R || c>=C)\\n//             return false;\\n        \\n//         // else return true\\n//         return true;\\n//     }\\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dir[5] = {1, 0, -1, 0, 1};\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        //DP: Store longest path for previous element in a matrix, so whenever we need we can use thet value to find largest path\\n        int row = matrix.size(), col = matrix[0].size();\\n        vector<vector<int>> dp(row, vector<int>(col, 0));\\n        \\n        int mx = 0; //this will store the largest path value   \\n        for(int i=0; i<row; i++)\\n        {\\n            for(int j=0; j<col; j++)\\n            {\\n                mx = max(mx, helper(matrix, dp, i, j));  //find larget path by taking all elements one by one in the matrix\\n            }\\n        }\\n        \\n        return mx+1;\\n    }\\n    \\n    int helper(vector<vector<int>>& matrix, vector<vector<int>>& dp, int r, int c){\\n        int row = matrix.size(), col  = matrix[0].size();\\n        \\n        if(dp[r][c] !=0)    //if we already know what is the length of the path from here\\n            return dp[r][c];\\n        \\n        //we need to find the largest path from this place\\n        //look out in all four directions, one by one if there is any greater element than this current element(matrix[r][c])\\n        for(int i=0; i<4; i++)\\n        {\\n            int newr = dir[i]+r;\\n            int newc = dir[i+1]+c;\\n            \\n            if(isValid(newr, newc, row, col) && matrix[newr][newc] > matrix[r][c])\\n                dp[r][c] = max(dp[r][c], 1+helper(matrix, dp, newr, newc));  //max path we need from all four directions\\n        }\\n                               \\n        return dp[r][c];\\n    }\\n    \\n    bool isValid(int r, int c, int R, int C){\\n        return (r>=0 && c>=0 && r<R && c<C);\\n    }\\n//      bool isValid(int& r,int& c,int R, int C)\\n//     {\\n//         // if we are not inside the the boundary then return false \\n//         if(r<0 || c<0 || r>=R || c>=C)\\n//             return false;\\n        \\n//         // else return true\\n//         return true;\\n//     }\\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2054633,
                "title": "c-2-solutions-topological-sort-dfs-dp-memoization",
                "content": "This is a standard longest path in a DAG problem.\\n\\n**Approach 1 : Topological sort**\\nTime complexity : O(n*m)\\nSpace complexity : O(n*m)\\nIt is always good to start the sequence with a cell with 0 indegree.\\n\\n```\\nclass Solution {\\npublic:\\n    int n,m;\\n    vector<int> dx = {0,0,1,-1}, dy = {1,-1,0,0};\\n    \\n    bool valid(int x, int y){\\n        return x<n && y<m && x>=0 && y>=0;\\n    }\\n    \\n    \\n    int longestIncreasingPath(vector<vector<int>>& a) {\\n        n = a.size(); m = a[0].size();\\n        vector<vector<int>> indegree(n, vector<int>(m,0));\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                for(int k=0; k<4; k++){\\n                    int x = i+dx[k], y = j+dy[k];\\n                    if(valid(x,y) && a[i][j]>a[x][y]) indegree[i][j]++;\\n                }\\n            }\\n        }\\n        \\n        queue<vector<int>> q;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(indegree[i][j]==0)q.push({i,j});\\n            }\\n        }\\n        \\n        int ans=0;\\n        while(!q.empty()){\\n            int sz=q.size();\\n            while(sz--){\\n                int x = q.front()[0], y = q.front()[1]; \\n                q.pop();\\n                for(int i=0; i<4; i++){\\n                    int newx = x+dx[i], newy = y+dy[i];\\n                    if(valid(newx,newy) && a[newx][newy]>a[x][y]){\\n                        indegree[newx][newy]--;\\n                        if(!indegree[newx][newy])q.push({newx,newy});\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Approach 2 : DFS + DP (Memoization)**\\nTime complexity : O(n*m)\\nSpace complexity : O(n*m)\\n\\n```\\nclass Solution {\\npublic:\\n    int n,m;\\n    vector<int> dx = {0,0,1,-1}, dy = {1,-1,0,0};\\n    int dp[200][200];\\n    \\n    bool valid(int x, int y){\\n        return x<n && y<m && x>=0 && y>=0;\\n    }\\n    \\n    int dfs(int i, int j, vector<vector<int>>& a) {\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int mx=0;\\n        for(int k=0; k<4; k++){\\n            int x = i+dx[k], y = j+dy[k];\\n            if(valid(x,y) && a[i][j]<a[x][y]){\\n                mx = max(mx, dfs(x,y,a));\\n            }\\n        }\\n        return dp[i][j]=mx+1;   \\n    }\\n    \\n    int longestIncreasingPath(vector<vector<int>>& a) {\\n        int res=0;\\n        n=a.size(), m=a[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                res=max(res,dfs(i,j,a));\\n        return res;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Topological Sort",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    vector<int> dx = {0,0,1,-1}, dy = {1,-1,0,0};\\n    \\n    bool valid(int x, int y){\\n        return x<n && y<m && x>=0 && y>=0;\\n    }\\n    \\n    \\n    int longestIncreasingPath(vector<vector<int>>& a) {\\n        n = a.size(); m = a[0].size();\\n        vector<vector<int>> indegree(n, vector<int>(m,0));\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                for(int k=0; k<4; k++){\\n                    int x = i+dx[k], y = j+dy[k];\\n                    if(valid(x,y) && a[i][j]>a[x][y]) indegree[i][j]++;\\n                }\\n            }\\n        }\\n        \\n        queue<vector<int>> q;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(indegree[i][j]==0)q.push({i,j});\\n            }\\n        }\\n        \\n        int ans=0;\\n        while(!q.empty()){\\n            int sz=q.size();\\n            while(sz--){\\n                int x = q.front()[0], y = q.front()[1]; \\n                q.pop();\\n                for(int i=0; i<4; i++){\\n                    int newx = x+dx[i], newy = y+dy[i];\\n                    if(valid(newx,newy) && a[newx][newy]>a[x][y]){\\n                        indegree[newx][newy]--;\\n                        if(!indegree[newx][newy])q.push({newx,newy});\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int n,m;\\n    vector<int> dx = {0,0,1,-1}, dy = {1,-1,0,0};\\n    int dp[200][200];\\n    \\n    bool valid(int x, int y){\\n        return x<n && y<m && x>=0 && y>=0;\\n    }\\n    \\n    int dfs(int i, int j, vector<vector<int>>& a) {\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int mx=0;\\n        for(int k=0; k<4; k++){\\n            int x = i+dx[k], y = j+dy[k];\\n            if(valid(x,y) && a[i][j]<a[x][y]){\\n                mx = max(mx, dfs(x,y,a));\\n            }\\n        }\\n        return dp[i][j]=mx+1;   \\n    }\\n    \\n    int longestIncreasingPath(vector<vector<int>>& a) {\\n        int res=0;\\n        n=a.size(), m=a[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                res=max(res,dfs(i,j,a));\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2052681,
                "title": "c-dp-memoization",
                "content": "**Time: O(m*n)**\\n**Space: O(m*n)**\\n```\\nclass Solution {\\npublic:\\n    int dx[4] = {0,1,0,-1};\\n    int dy[4] = {1,0,-1,0};\\n    int dp[201][201];\\n    \\n    bool isValid(int r, int c, int x, int y){\\n        if(x>=0 && x<r && y>=0 && y<c) return true;\\n        return false;\\n    }\\n    \\n    int solve(vector<vector<int>>& matrix, int x, int y){\\n        int n = matrix.size(), m = matrix[0].size();\\n        \\n        if(dp[x][y] != -1) return dp[x][y];\\n        int cur = 1;\\n        for(int i=0; i<4; ++i){\\n            int x1 = x+dx[i], y1=y+dy[i];\\n            if(isValid(n,m,x1,y1) && matrix[x1][y1] > matrix[x][y]){\\n                cur = max(cur, 1 + solve(matrix,x1,y1));\\n            }\\n        }\\n        return dp[x][y] = cur;\\n    }\\n    \\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans = 0;\\n        int n = matrix.size(), m = matrix[0].size();\\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<m; ++j){\\n                ans = max(ans, solve(matrix,i,j));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nplease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4] = {0,1,0,-1};\\n    int dy[4] = {1,0,-1,0};\\n    int dp[201][201];\\n    \\n    bool isValid(int r, int c, int x, int y){\\n        if(x>=0 && x<r && y>=0 && y<c) return true;\\n        return false;\\n    }\\n    \\n    int solve(vector<vector<int>>& matrix, int x, int y){\\n        int n = matrix.size(), m = matrix[0].size();\\n        \\n        if(dp[x][y] != -1) return dp[x][y];\\n        int cur = 1;\\n        for(int i=0; i<4; ++i){\\n            int x1 = x+dx[i], y1=y+dy[i];\\n            if(isValid(n,m,x1,y1) && matrix[x1][y1] > matrix[x][y]){\\n                cur = max(cur, 1 + solve(matrix,x1,y1));\\n            }\\n        }\\n        return dp[x][y] = cur;\\n    }\\n    \\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans = 0;\\n        int n = matrix.size(), m = matrix[0].size();\\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<m; ++j){\\n                ans = max(ans, solve(matrix,i,j));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2052380,
                "title": "python-dfs-with-memoization-beats-90",
                "content": "The solution is quite straightforward. The code just performs a dfs traversal from each cell in the grid and finds the length of valid path.\\n\\nBelow is the code with the comments\\n```\\nclass Solution:\\n    def longestIncreasingPath(self, grid: List[List[int]]) -> int:\\n        m,n=len(grid),len(grid[0])\\n        directions = [0, 1, 0, -1, 0] # four directions \\n        \\n        @lru_cache(maxsize=None) # using python cache lib for memoization\\n        def dfs(r,c):\\n            ans=1                  \\n\\t\\t\\t# iterating through all 4 directions\\n            for i in range(4): \\n                new_row,new_col=r+directions[i], c+directions[i+1] # calculating the new cell\\n\\t\\t\\t\\t# check if new cell is within the grid bounds and is an increasing sequence\\n                if 0<=new_row<m and 0<=new_col<n and grid[new_row][new_col]>grid[r][c]: \\n                    ans = max(ans, dfs(new_row, new_col) + 1 )  # finding the max length of valid path from the current cell                                      \\n            return ans\\n        \\n        return max(dfs(r,c) for r in range(m) for c in range(n)) \\n```\\n**Time - O(m.n)** - memoization helps to reduce the time as it doesn\\'t visit the same cell twice.\\n**Space -  O(m.n)** - space required for recursive call stack and cache.\\n\\n---\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestIncreasingPath(self, grid: List[List[int]]) -> int:\\n        m,n=len(grid),len(grid[0])\\n        directions = [0, 1, 0, -1, 0] # four directions \\n        \\n        @lru_cache(maxsize=None) # using python cache lib for memoization\\n        def dfs(r,c):\\n            ans=1                  \\n\\t\\t\\t# iterating through all 4 directions\\n            for i in range(4): \\n                new_row,new_col=r+directions[i], c+directions[i+1] # calculating the new cell\\n\\t\\t\\t\\t# check if new cell is within the grid bounds and is an increasing sequence\\n                if 0<=new_row<m and 0<=new_col<n and grid[new_row][new_col]>grid[r][c]: \\n                    ans = max(ans, dfs(new_row, new_col) + 1 )  # finding the max length of valid path from the current cell                                      \\n            return ans\\n        \\n        return max(dfs(r,c) for r in range(m) for c in range(n)) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1348254,
                "title": "java-15-ms-kahn-s-algo",
                "content": "```\\nclass Solution {\\n    \\n    public class Pair{\\n        int r,c;\\n        Pair(int r, int c){\\n            this.r = r;\\n            this.c = c;\\n        }\\n    }\\n    \\n    public int longestIncreasingPath(int[][] arr) {\\n        int n = arr.length;\\n        int m = arr[0].length;\\n        int[][] dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n        int[][] inDegree = new int[n][m];\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                for(int d = 0 ; d < dir.length; d++){\\n                    int r = i + dir[d][0];\\n                    int c = j + dir[d][1];\\n                    if(r < n && c < m && r >= 0 && c >= 0 && arr[r][c] > arr[i][j]){\\n                        inDegree[r][c]++;\\n                    }\\n                }\\n            }   \\n        }\\n        \\n        Queue<Pair> q = new LinkedList<>();\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                if(inDegree[i][j] == 0) q.add(new Pair(i,j));\\n            }   \\n        }\\n        \\n        int lev = 1;\\n        \\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            while(size-- > 0){\\n                Pair rp = q.remove();\\n                for(int d = 0 ; d < dir.length; d++){\\n                    int r = rp.r + dir[d][0];\\n                    int c = rp.c + dir[d][1];\\n                    if(r < n && c < m && r >= 0 && c >= 0 && arr[r][c] > arr[rp.r][rp.c]){\\n                        if(--inDegree[r][c] == 0) q.add(new Pair(r,c));\\n                    }\\n                }\\n            }\\n            if(!q.isEmpty()) lev++;\\n        }\\n        return lev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public class Pair{\\n        int r,c;\\n        Pair(int r, int c){\\n            this.r = r;\\n            this.c = c;\\n        }\\n    }\\n    \\n    public int longestIncreasingPath(int[][] arr) {\\n        int n = arr.length;\\n        int m = arr[0].length;\\n        int[][] dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n        int[][] inDegree = new int[n][m];\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                for(int d = 0 ; d < dir.length; d++){\\n                    int r = i + dir[d][0];\\n                    int c = j + dir[d][1];\\n                    if(r < n && c < m && r >= 0 && c >= 0 && arr[r][c] > arr[i][j]){\\n                        inDegree[r][c]++;\\n                    }\\n                }\\n            }   \\n        }\\n        \\n        Queue<Pair> q = new LinkedList<>();\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                if(inDegree[i][j] == 0) q.add(new Pair(i,j));\\n            }   \\n        }\\n        \\n        int lev = 1;\\n        \\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            while(size-- > 0){\\n                Pair rp = q.remove();\\n                for(int d = 0 ; d < dir.length; d++){\\n                    int r = rp.r + dir[d][0];\\n                    int c = rp.c + dir[d][1];\\n                    if(r < n && c < m && r >= 0 && c >= 0 && arr[r][c] > arr[rp.r][rp.c]){\\n                        if(--inDegree[r][c] == 0) q.add(new Pair(r,c));\\n                    }\\n                }\\n            }\\n            if(!q.isEmpty()) lev++;\\n        }\\n        return lev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1310937,
                "title": "c-easy-recursion-with-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[201][201]={0};\\n    int LIP(int i, int j, vector<vector<int>>& matrix, int prev)\\n    {\\n        if(i<0 || j<0 || i>=matrix.size() || j>=matrix[0].size() || prev>=matrix[i][j])\\n        {\\n            return 0;\\n        }\\n        if(dp[i][j])\\n        {\\n            return dp[i][j];\\n        }\\n        int a = 1+LIP(i+1,j,matrix,matrix[i][j]);\\n        int b = 1+LIP(i-1,j,matrix,matrix[i][j]);\\n        int c = 1+LIP(i,j+1,matrix,matrix[i][j]);\\n        int d = 1+LIP(i,j-1,matrix,matrix[i][j]);\\n        dp[i][j]=max({a,b,c,d});\\n        return dp[i][j];\\n    }\\n    \\n    int longestIncreasingPath(vector<vector<int>>& matrix) \\n    {\\n        int mx = 0;\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            for(int j=0;j<matrix[0].size();j++)\\n            {\\n                mx=max(mx, LIP(i, j, matrix, INT_MIN));\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[201][201]={0};\\n    int LIP(int i, int j, vector<vector<int>>& matrix, int prev)\\n    {\\n        if(i<0 || j<0 || i>=matrix.size() || j>=matrix[0].size() || prev>=matrix[i][j])\\n        {\\n            return 0;\\n        }\\n        if(dp[i][j])\\n        {\\n            return dp[i][j];\\n        }\\n        int a = 1+LIP(i+1,j,matrix,matrix[i][j]);\\n        int b = 1+LIP(i-1,j,matrix,matrix[i][j]);\\n        int c = 1+LIP(i,j+1,matrix,matrix[i][j]);\\n        int d = 1+LIP(i,j-1,matrix,matrix[i][j]);\\n        dp[i][j]=max({a,b,c,d});\\n        return dp[i][j];\\n    }\\n    \\n    int longestIncreasingPath(vector<vector<int>>& matrix) \\n    {\\n        int mx = 0;\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            for(int j=0;j<matrix[0].size();j++)\\n            {\\n                mx=max(mx, LIP(i, j, matrix, INT_MIN));\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152726,
                "title": "python-easy-self-explaining-code-beats-99",
                "content": "**Summary**: Take dp of each element in the matrix to show the maximum length of path that can be travelled from that element (source) to any other element (destination) keeping the path strictly increasing.\\n\\n**Solution**: the maximum value out of all the dp of elements will give us the longest increasing path possible.\\n\\n**Flow**: Initialize dp as -1 to show every element in matrix as unvisited (not calculated), recursively go through each element and keep on upsolving the dp by visiting neighbour elements (left, right, up, down) if possible (inside the matrix) and conditions satisfy (strictly increasing).\\n```\\ndef longestIncreasingPath(matrix: [[int]]) -> int:\\n    def dfs(row: int, col: int) -> int:\\n        if dp[row][col] == -1:  # only calculate if not already done\\n            val = matrix[row][col]\\n            dfs_up = dfs(row - 1, col) if row and val < matrix[row - 1][col] else 0\\n            dfs_down = dfs(row + 1, col) if row + 1 < m and val < matrix[row + 1][col] else 0\\n            dfs_left = dfs(row, col - 1) if col and val < matrix[row][col - 1] else 0\\n            dfs_right = dfs(row, col + 1) if col + 1 < n and val < matrix[row][col + 1] else 0\\n            dp[row][col] = 1 + max(dfs_up, dfs_down, dfs_left, dfs_right)\\n        return dp[row][col]\\n\\n    m, n = len(matrix), len(matrix[0])\\n    dp = [[-1] * n for _ in range(m)]\\n    return max(dfs(r, c) for r in range(m) for c in range(n))\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\ndef longestIncreasingPath(matrix: [[int]]) -> int:\\n    def dfs(row: int, col: int) -> int:\\n        if dp[row][col] == -1:  # only calculate if not already done\\n            val = matrix[row][col]\\n            dfs_up = dfs(row - 1, col) if row and val < matrix[row - 1][col] else 0\\n            dfs_down = dfs(row + 1, col) if row + 1 < m and val < matrix[row + 1][col] else 0\\n            dfs_left = dfs(row, col - 1) if col and val < matrix[row][col - 1] else 0\\n            dfs_right = dfs(row, col + 1) if col + 1 < n and val < matrix[row][col + 1] else 0\\n            dp[row][col] = 1 + max(dfs_up, dfs_down, dfs_left, dfs_right)\\n        return dp[row][col]\\n\\n    m, n = len(matrix), len(matrix[0])\\n    dp = [[-1] * n for _ in range(m)]\\n    return max(dfs(r, c) for r in range(m) for c in range(n))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 775043,
                "title": "both-dfs-and-bfs-solutions",
                "content": "```\\nclass Solution {\\n    \\n    // only dfs ===> tle\\n    // dfs only on topo points(indegree->0)  ===> tle\\n    // dfs with memo  ===> pass\\n    // dfs on topo points with memoization  ===>pass\\n    // kahn\\'s algo (bfs) ===>pass\\n    \\n    public int[][] dir={{1,0},{0,1},{-1,0},{0,-1}};\\n\\t\\n    public int longestIncreasingPath(int[][] matrix) {\\n       // return DFS_topoPoints_Memo(matrix);\\n       // return DFS_AllPoints_Memo(matrix);\\n        return BFS_kahnsAlgo(matrix);\\n    }\\n    public int DFS_topoPoints_Memo(int[][] matrix){\\n        int n=matrix.length;\\n        if(n==0) return 0;\\n        int m=matrix[0].length;\\n        ArrayList<int[]> startPoints=new ArrayList<int[]>();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                boolean indegree=false;\\n                for(int k=0;k<4;k++){\\n                    int r=i+dir[k][0];\\n                    int c=j+dir[k][1];\\n                    if(r>=0 && c>=0 && r<n && c<m && matrix[r][c]<matrix[i][j]){\\n                        indegree=true;\\n                        break;\\n                    } \\n                }\\n                if(!indegree) startPoints.add(new int[]{i,j});\\n            }\\n        }\\n        int[][] dp=new int[matrix.length][matrix[0].length];\\n        int max=1;\\n        for(int i=0;i<startPoints.size();i++){\\n            int[] rPair=startPoints.get(i);\\n            max=Math.max(max,longestIncreasingPath_DFS(rPair[0],rPair[1],matrix,dp));\\n        }\\n        return max;\\n    }\\n    public int DFS_AllPoints_Memo(int[][] matrix){\\n         int n=matrix.length;\\n        if(n==0) return 0;\\n        int m=matrix[0].length;\\n        ArrayList<int[]> startPoints=new ArrayList<int[]>();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                boolean indegree=false;\\n                for(int k=0;k<4;k++){\\n                    int r=i+dir[k][0];\\n                    int c=j+dir[k][1];\\n                    if(r>=0 && c>=0 && r<n && c<m && matrix[r][c]<matrix[i][j]){\\n                        indegree=true;\\n                        break;\\n                    } \\n                }\\n                if(!indegree) startPoints.add(new int[]{i,j});\\n            }\\n        }\\n        int[][] dp=new int[matrix.length][matrix[0].length];\\n        int max=1;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                 max=Math.max(max,longestIncreasingPath_DFS(i,j,matrix,dp));\\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    public int longestIncreasingPath_DFS(int x,int y,int[][] matrix,int[][] dp){ \\n        if(dp[x][y]!=0) return dp[x][y];\\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n        int length=0;\\n        for(int k=0;k<4;k++){\\n                    int r=x+dir[k][0];\\n                    int c=y+dir[k][1];\\n                    if(r>=0 && c>=0 && r<n && c<m && matrix[r][c]>matrix[x][y]){\\n                        length=Math.max(length,longestIncreasingPath_DFS(r,c,matrix,dp));\\n                    } \\n                }\\n        return dp[x][y]=length+1;\\n    }\\n    \\n     public int BFS_kahnsAlgo(int[][] matrix){\\n        int n=matrix.length;\\n        if(n==0) return 0;\\n        int m=matrix[0].length;\\n        int[][] indegree=new int[matrix.length][matrix[0].length];\\n        LinkedList<int[]> que=new LinkedList<int[]>();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int indegreeCount=0;\\n                for(int k=0;k<4;k++){\\n                    int r=i+dir[k][0];\\n                    int c=j+dir[k][1];\\n                    if(r>=0 && c>=0 && r<n && c<m && matrix[r][c]<matrix[i][j]){\\n                       indegreeCount++;\\n                    } \\n                }\\n                indegree[i][j]=indegreeCount;\\n                if(indegree[i][j]==0) que.addLast(new int[]{i,j});\\n            }\\n        }\\n        int length=0;\\n        while(!que.isEmpty()){\\n            int size=que.size();\\n            while(size-->0){\\n                int[] rPair=que.removeFirst();\\n                int i=rPair[0];\\n                int j=rPair[1];\\n                for(int k=0;k<4;k++){\\n                    int r=i+dir[k][0];\\n                    int c=j+dir[k][1];\\n                    if(r>=0 && c>=0 && r<n && c<m && matrix[r][c]>matrix[i][j] && --indegree[r][c]==0){\\n                        que.addLast(new int[]{r,c});\\n                    }\\n                }\\n            }\\n            length++;\\n        }\\n        return length;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    // only dfs ===> tle\\n    // dfs only on topo points(indegree->0)  ===> tle\\n    // dfs with memo  ===> pass\\n    // dfs on topo points with memoization  ===>pass\\n    // kahn\\'s algo (bfs) ===>pass\\n    \\n    public int[][] dir={{1,0},{0,1},{-1,0},{0,-1}};\\n\\t\\n    public int longestIncreasingPath(int[][] matrix) {\\n       // return DFS_topoPoints_Memo(matrix);\\n       // return DFS_AllPoints_Memo(matrix);\\n        return BFS_kahnsAlgo(matrix);\\n    }\\n    public int DFS_topoPoints_Memo(int[][] matrix){\\n        int n=matrix.length;\\n        if(n==0) return 0;\\n        int m=matrix[0].length;\\n        ArrayList<int[]> startPoints=new ArrayList<int[]>();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                boolean indegree=false;\\n                for(int k=0;k<4;k++){\\n                    int r=i+dir[k][0];\\n                    int c=j+dir[k][1];\\n                    if(r>=0 && c>=0 && r<n && c<m && matrix[r][c]<matrix[i][j]){\\n                        indegree=true;\\n                        break;\\n                    } \\n                }\\n                if(!indegree) startPoints.add(new int[]{i,j});\\n            }\\n        }\\n        int[][] dp=new int[matrix.length][matrix[0].length];\\n        int max=1;\\n        for(int i=0;i<startPoints.size();i++){\\n            int[] rPair=startPoints.get(i);\\n            max=Math.max(max,longestIncreasingPath_DFS(rPair[0],rPair[1],matrix,dp));\\n        }\\n        return max;\\n    }\\n    public int DFS_AllPoints_Memo(int[][] matrix){\\n         int n=matrix.length;\\n        if(n==0) return 0;\\n        int m=matrix[0].length;\\n        ArrayList<int[]> startPoints=new ArrayList<int[]>();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                boolean indegree=false;\\n                for(int k=0;k<4;k++){\\n                    int r=i+dir[k][0];\\n                    int c=j+dir[k][1];\\n                    if(r>=0 && c>=0 && r<n && c<m && matrix[r][c]<matrix[i][j]){\\n                        indegree=true;\\n                        break;\\n                    } \\n                }\\n                if(!indegree) startPoints.add(new int[]{i,j});\\n            }\\n        }\\n        int[][] dp=new int[matrix.length][matrix[0].length];\\n        int max=1;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                 max=Math.max(max,longestIncreasingPath_DFS(i,j,matrix,dp));\\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    public int longestIncreasingPath_DFS(int x,int y,int[][] matrix,int[][] dp){ \\n        if(dp[x][y]!=0) return dp[x][y];\\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n        int length=0;\\n        for(int k=0;k<4;k++){\\n                    int r=x+dir[k][0];\\n                    int c=y+dir[k][1];\\n                    if(r>=0 && c>=0 && r<n && c<m && matrix[r][c]>matrix[x][y]){\\n                        length=Math.max(length,longestIncreasingPath_DFS(r,c,matrix,dp));\\n                    } \\n                }\\n        return dp[x][y]=length+1;\\n    }\\n    \\n     public int BFS_kahnsAlgo(int[][] matrix){\\n        int n=matrix.length;\\n        if(n==0) return 0;\\n        int m=matrix[0].length;\\n        int[][] indegree=new int[matrix.length][matrix[0].length];\\n        LinkedList<int[]> que=new LinkedList<int[]>();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int indegreeCount=0;\\n                for(int k=0;k<4;k++){\\n                    int r=i+dir[k][0];\\n                    int c=j+dir[k][1];\\n                    if(r>=0 && c>=0 && r<n && c<m && matrix[r][c]<matrix[i][j]){\\n                       indegreeCount++;\\n                    } \\n                }\\n                indegree[i][j]=indegreeCount;\\n                if(indegree[i][j]==0) que.addLast(new int[]{i,j});\\n            }\\n        }\\n        int length=0;\\n        while(!que.isEmpty()){\\n            int size=que.size();\\n            while(size-->0){\\n                int[] rPair=que.removeFirst();\\n                int i=rPair[0];\\n                int j=rPair[1];\\n                for(int k=0;k<4;k++){\\n                    int r=i+dir[k][0];\\n                    int c=j+dir[k][1];\\n                    if(r>=0 && c>=0 && r<n && c<m && matrix[r][c]>matrix[i][j] && --indegree[r][c]==0){\\n                        que.addLast(new int[]{r,c});\\n                    }\\n                }\\n            }\\n            length++;\\n        }\\n        return length;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057694,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[200][200]={0};\\n    int m, n;\\n    int dfs(vector<vector<int>>& matrix, int i, int j, int p)\\n    {\\n        if(i<0 || j<0 || i>=m || j>=n || matrix[i][j]<=p)\\n            return 0;\\n        if(dp[i][j])\\n            return dp[i][j];\\n        p=matrix[i][j];\\n        return dp[i][j] = 1+ max({dfs(matrix, i+1, j, p),\\n                      dfs(matrix, i-1, j, p),\\n                      dfs(matrix, i, j+1, p),\\n                      dfs(matrix, i, j-1, p)});\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int ans=0;\\n        m=matrix.size();\\n        n=matrix[0].size();\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n            ans=max(ans, dfs(matrix, i, j, -1)); \\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[200][200]={0};\\n    int m, n;\\n    int dfs(vector<vector<int>>& matrix, int i, int j, int p)\\n    {\\n        if(i<0 || j<0 || i>=m || j>=n || matrix[i][j]<=p)\\n            return 0;\\n        if(dp[i][j])\\n            return dp[i][j];\\n        p=matrix[i][j];\\n        return dp[i][j] = 1+ max({dfs(matrix, i+1, j, p),\\n                      dfs(matrix, i-1, j, p),\\n                      dfs(matrix, i, j+1, p),\\n                      dfs(matrix, i, j-1, p)});\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int ans=0;\\n        m=matrix.size();\\n        n=matrix[0].size();\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n            ans=max(ans, dfs(matrix, i, j, -1)); \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2713376,
                "title": "dp-bfs-faster-than-81-01-of-c-online-submissions",
                "content": "UPVOTE :)\\n```\\nclass Solution {\\npublic:\\n    int dfs(int i, int j , vector<vector<int>> & matrix,int prev, vector<vector<int>> &vis, vector<vector<int>> &dp)\\n    {\\n        if(i>=matrix.size() || j>=matrix[0].size() || i<0 || j < 0 || prev >= matrix[i][j] || vis[i][j]==1)\\n        {\\n            return 0;\\n        }\\n        if(dp[i][j] != -1) return dp[i][j];\\n        vis[i][j] = 1;\\n        int down =1+dfs(i+1, j, matrix,matrix[i][j],vis,dp);\\n        int right = 1+dfs(i, j+1, matrix,matrix[i][j],vis,dp);\\n        int up =  1+dfs(i-1, j, matrix,matrix[i][j],vis,dp);\\n        int left =  1+dfs(i, j-1, matrix,matrix[i][j],vis,dp);\\n        vis[i][j] = 0;\\n        return dp[i][j] = max(down,max(up,max(right,left)));\\n        \\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int ans = INT_MIN;\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        vector<vector<int>> dp(n+1,vector<int>(m+1, -1));\\n        for(int i = 0; i< matrix.size(); i++)\\n        {\\n            for(int j  = 0; j < matrix[0].size(); j++)\\n            {\\n                ans = max(ans,dfs(i, j, matrix,-1,vis,dp));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int i, int j , vector<vector<int>> & matrix,int prev, vector<vector<int>> &vis, vector<vector<int>> &dp)\\n    {\\n        if(i>=matrix.size() || j>=matrix[0].size() || i<0 || j < 0 || prev >= matrix[i][j] || vis[i][j]==1)\\n        {\\n            return 0;\\n        }\\n        if(dp[i][j] != -1) return dp[i][j];\\n        vis[i][j] = 1;\\n        int down =1+dfs(i+1, j, matrix,matrix[i][j],vis,dp);\\n        int right = 1+dfs(i, j+1, matrix,matrix[i][j],vis,dp);\\n        int up =  1+dfs(i-1, j, matrix,matrix[i][j],vis,dp);\\n        int left =  1+dfs(i, j-1, matrix,matrix[i][j],vis,dp);\\n        vis[i][j] = 0;\\n        return dp[i][j] = max(down,max(up,max(right,left)));\\n        \\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int ans = INT_MIN;\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        vector<vector<int>> dp(n+1,vector<int>(m+1, -1));\\n        for(int i = 0; i< matrix.size(); i++)\\n        {\\n            for(int j  = 0; j < matrix[0].size(); j++)\\n            {\\n                ans = max(ans,dfs(i, j, matrix,-1,vis,dp));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2273341,
                "title": "kahn-s-algorithm-java",
                "content": "\\n```\\n\\nclass Solution {\\n    public int longestIncreasingPath(int[][] matrix) {\\n        \\n        int n = matrix.length, m = matrix[0].length;\\n        \\n        int[][] indegree = new int[n][m];\\n        int[][] dir = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};\\n        \\n        for(int i = 0 ; i < n; i++){\\n            for(int j = 0; j < m ; j++){\\n                \\n                for(int[] d : dir){\\n                    int r = i + d[0];\\n                    int c = j + d[1];\\n                    \\n                    if(r >= 0 && c >= 0 && r < n && c < m && matrix[r][c] < matrix[i][j] ) indegree[i][j]++;\\n                }\\n            }\\n        }\\n        for(int i = 0 ; i < n; i++){\\n            for(int j = 0; j < m ; j++){\\n                System.out.print(indegree[i][j] +\" \");\\n            }\\n            System.out.println();\\n        }\\n        \\n        LinkedList<int[]> q = new LinkedList<>();\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(indegree[i][j] == 0) q.add(new int[]{i, j});\\n            }\\n        }\\n        \\n        int level = 0;\\n        \\n        while(!q.isEmpty()){\\n            int sz = q.size();\\n            while(sz-- > 0){\\n                int[] curr = q.poll();\\n                \\n                int i = curr[0], j = curr[1];\\n                \\n                for(int[] d : dir){\\n                    int r = i + d[0];\\n                    int c = j + d[1];\\n                    \\n                    if(r >= 0 && c >= 0 && r < n && c < m && matrix[r][c] > matrix[i][j] && --indegree[r][c] == 0) q.add(new int[]{ r, c});\\n                }\\n            }\\n            level++;\\n        }\\n        return level;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int longestIncreasingPath(int[][] matrix) {\\n        \\n        int n = matrix.length, m = matrix[0].length;\\n        \\n        int[][] indegree = new int[n][m];\\n        int[][] dir = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};\\n        \\n        for(int i = 0 ; i < n; i++){\\n            for(int j = 0; j < m ; j++){\\n                \\n                for(int[] d : dir){\\n                    int r = i + d[0];\\n                    int c = j + d[1];\\n                    \\n                    if(r >= 0 && c >= 0 && r < n && c < m && matrix[r][c] < matrix[i][j] ) indegree[i][j]++;\\n                }\\n            }\\n        }\\n        for(int i = 0 ; i < n; i++){\\n            for(int j = 0; j < m ; j++){\\n                System.out.print(indegree[i][j] +\" \");\\n            }\\n            System.out.println();\\n        }\\n        \\n        LinkedList<int[]> q = new LinkedList<>();\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(indegree[i][j] == 0) q.add(new int[]{i, j});\\n            }\\n        }\\n        \\n        int level = 0;\\n        \\n        while(!q.isEmpty()){\\n            int sz = q.size();\\n            while(sz-- > 0){\\n                int[] curr = q.poll();\\n                \\n                int i = curr[0], j = curr[1];\\n                \\n                for(int[] d : dir){\\n                    int r = i + d[0];\\n                    int c = j + d[1];\\n                    \\n                    if(r >= 0 && c >= 0 && r < n && c < m && matrix[r][c] > matrix[i][j] && --indegree[r][c] == 0) q.add(new int[]{ r, c});\\n                }\\n            }\\n            level++;\\n        }\\n        return level;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2194151,
                "title": "c-dp-backtracking-topo-sort",
                "content": "**Few Points:**\\n1. Code is **not concise** because I think readability is more important than sweating over fewer lines of code.\\n1. **Tip**: It might sound un-conventional, but a good way to understand backtracking solution or recursive soultion is by doing dry run by building a tree, and tracing the calls, takes time but really solidifies the understanding for future.\\n\\n**1. DP + Backtracking**\\nDP[M][N] tells longest increasing path length from position grid[M][N].\\n**Time complexity:**\\n* Without memoization: O(NxMx4^(MxN))\\n* With memoization: O(NxM)\\n```\\nclass Solution {\\npublic:\\n    int longestIncreasingPath(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(), maxLen = 0;\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, -1));\\n        for(int i=0; i<m; i++){\\n            for(int j= 0; j<n; j++){\\n                int incLen = findLen(i, j, grid, dp);\\n                maxLen = max(incLen, maxLen);\\n            }\\n        }\\n        return maxLen;\\n    }\\n    \\nprivate:\\n    int directions[4][2] = {{1,0}, {0,1}, {0,-1}, {-1,0}};\\n    \\n    int findLen(int row, int col, vector<vector<int>>& grid, vector<vector<int>>& dp){\\n        int m = grid.size(), n = grid[0].size();\\n        if(dp[row][col] != -1) return dp[row][col];\\n        \\n        //Mark cur index visited\\n        int val = grid[row][col];\\n        grid[row][col] = -1;\\n        int maxPathLenFromCurPos = 1;\\n        \\n        //Backtracking: Search for increasing number in all 4 directions\\n        for(int i=0; i<4; i++){\\n            int newRow = row + directions[i][0];\\n            int newCol = col + directions[i][1];\\n            \\n            //Pathlen stores length of each path from current position, our function should return maximum path length from current position, \\n\\t\\t\\t//hence we keep computing maximum path length every time.\\n            int pathLen = 1;\\n            if(isValid(newRow, newCol, m, n) && grid[newRow][newCol] != -1 && grid[newRow][newCol]> val){\\n                pathLen = 1 + findLen(newRow, newCol, grid, dp);\\n                maxPathLenFromCurPos = max(maxPathLenFromCurPos, pathLen);\\n            }\\n        }\\n        \\n        //Reset grid[row][col] \\n        grid[row][col] = val;\\n        return dp[row][col] = maxPathLenFromCurPos;\\n    }\\n    \\n    bool isValid(int row, int col, int totalRows, int totalCols){\\n        if(row >= 0 && col >= 0 && row < totalRows && col < totalCols) return true;\\n        return false;\\n    }\\n};\\n```\\n\\n**2. Topo Sort:** Using BFS (Kahn\\'s Algo)\\nThis was  [GraceMeng\\'s brilliant idea](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/discuss/288520/Longest-Path-in-DAG).\\n**Time Complexity:** O(MxN)\\n```\\nclass Solution {\\npublic:\\n    int longestIncreasingPath(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(), maxLen = 0;\\n        vector<vector<int>> indegree(m, vector<int>(n, 0));\\n        \\n        //Find indegree of each node\\n        for(int i=0; i<m; i++){\\n            for(int j= 0; j<n; j++){\\n                for(int k=0; k<4; k++){\\n                    int newRow = i + directions[k][0];\\n                    int newCol = j + directions[k][1];\\n                    if(isValid(newRow,newCol,m,n) && grid[newRow][newCol] > grid[i][j]){\\n                        //Smaller value points towards larger value.\\n                        indegree[newRow][newCol] += 1;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        //Store nodes with 0 indegree in queue\\n        queue<pair<int, int>> q;\\n        for(int i=0; i<m; i++){\\n            for(int j= 0; j<n; j++){\\n                if(indegree[i][j] == 0) q.push({i, j});\\n            }\\n        }\\n        \\n        \\n        //Take node out from queue and visit its neighbors to find longes path\\n\\t\\t//This process is level order traversal\\n        int level = 1;\\n        while(!q.empty()){\\n            int qSize = q.size();\\n\\t\\t\\t\\n            for(int i=0; i<qSize; i++){\\n                auto rowCol = q.front();\\n                q.pop();\\n                int row = rowCol.first, col = rowCol.second;\\n                for(int k=0; k<4; k++){\\n                    int newRow = row + directions[k][0];\\n                    int newCol = col + directions[k][1];\\n\\n                    if(isValid(newRow,newCol,m,n) && grid[newRow][newCol] > grid[row][col]){\\n                        indegree[newRow][newCol] -= 1;\\n                        if(indegree[newRow][newCol] == 0) q.push({newRow, newCol});\\n                    }\\n                }\\n            }\\n            maxLen = max(level, maxLen);\\n            level += 1;\\n        }\\n        return maxLen;\\n    }\\n    \\nprivate:\\n    int directions[4][2] = {{1,0}, {0,1}, {0,-1}, {-1,0}};\\n    \\n    bool isValid(int row, int col, int totalRows, int totalCols){\\n        if(row >= 0 && col >= 0 && row < totalRows && col < totalCols) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestIncreasingPath(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(), maxLen = 0;\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, -1));\\n        for(int i=0; i<m; i++){\\n            for(int j= 0; j<n; j++){\\n                int incLen = findLen(i, j, grid, dp);\\n                maxLen = max(incLen, maxLen);\\n            }\\n        }\\n        return maxLen;\\n    }\\n    \\nprivate:\\n    int directions[4][2] = {{1,0}, {0,1}, {0,-1}, {-1,0}};\\n    \\n    int findLen(int row, int col, vector<vector<int>>& grid, vector<vector<int>>& dp){\\n        int m = grid.size(), n = grid[0].size();\\n        if(dp[row][col] != -1) return dp[row][col];\\n        \\n        //Mark cur index visited\\n        int val = grid[row][col];\\n        grid[row][col] = -1;\\n        int maxPathLenFromCurPos = 1;\\n        \\n        //Backtracking: Search for increasing number in all 4 directions\\n        for(int i=0; i<4; i++){\\n            int newRow = row + directions[i][0];\\n            int newCol = col + directions[i][1];\\n            \\n            //Pathlen stores length of each path from current position, our function should return maximum path length from current position, \\n\\t\\t\\t//hence we keep computing maximum path length every time.\\n            int pathLen = 1;\\n            if(isValid(newRow, newCol, m, n) && grid[newRow][newCol] != -1 && grid[newRow][newCol]> val){\\n                pathLen = 1 + findLen(newRow, newCol, grid, dp);\\n                maxPathLenFromCurPos = max(maxPathLenFromCurPos, pathLen);\\n            }\\n        }\\n        \\n        //Reset grid[row][col] \\n        grid[row][col] = val;\\n        return dp[row][col] = maxPathLenFromCurPos;\\n    }\\n    \\n    bool isValid(int row, int col, int totalRows, int totalCols){\\n        if(row >= 0 && col >= 0 && row < totalRows && col < totalCols) return true;\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int longestIncreasingPath(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(), maxLen = 0;\\n        vector<vector<int>> indegree(m, vector<int>(n, 0));\\n        \\n        //Find indegree of each node\\n        for(int i=0; i<m; i++){\\n            for(int j= 0; j<n; j++){\\n                for(int k=0; k<4; k++){\\n                    int newRow = i + directions[k][0];\\n                    int newCol = j + directions[k][1];\\n                    if(isValid(newRow,newCol,m,n) && grid[newRow][newCol] > grid[i][j]){\\n                        //Smaller value points towards larger value.\\n                        indegree[newRow][newCol] += 1;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        //Store nodes with 0 indegree in queue\\n        queue<pair<int, int>> q;\\n        for(int i=0; i<m; i++){\\n            for(int j= 0; j<n; j++){\\n                if(indegree[i][j] == 0) q.push({i, j});\\n            }\\n        }\\n        \\n        \\n        //Take node out from queue and visit its neighbors to find longes path\\n\\t\\t//This process is level order traversal\\n        int level = 1;\\n        while(!q.empty()){\\n            int qSize = q.size();\\n\\t\\t\\t\\n            for(int i=0; i<qSize; i++){\\n                auto rowCol = q.front();\\n                q.pop();\\n                int row = rowCol.first, col = rowCol.second;\\n                for(int k=0; k<4; k++){\\n                    int newRow = row + directions[k][0];\\n                    int newCol = col + directions[k][1];\\n\\n                    if(isValid(newRow,newCol,m,n) && grid[newRow][newCol] > grid[row][col]){\\n                        indegree[newRow][newCol] -= 1;\\n                        if(indegree[newRow][newCol] == 0) q.push({newRow, newCol});\\n                    }\\n                }\\n            }\\n            maxLen = max(level, maxLen);\\n            level += 1;\\n        }\\n        return maxLen;\\n    }\\n    \\nprivate:\\n    int directions[4][2] = {{1,0}, {0,1}, {0,-1}, {-1,0}};\\n    \\n    bool isValid(int row, int col, int totalRows, int totalCols){\\n        if(row >= 0 && col >= 0 && row < totalRows && col < totalCols) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2054570,
                "title": "python-easy-solution-dfs-dp-memoization-faster-than-99",
                "content": "```\\nclass Solution:\\n    def longestIncreasingPath(self, mat: List[List[int]]) -> int:\\n        m,n = len(mat),len(mat[0])\\n        visited = []\\n        for i in range(m):\\n            visited.append([0]*n)\\n            \\n        def fun(i,j):\\n            if visited[i][j]:\\n                return visited[i][j]\\n           \\n            up,down,left,right = 0,0,0,0\\n            if i+1<m and mat[i][j]<mat[i+1][j]:\\n                down=fun(i+1,j)\\n                \\n            if j+1<n and mat[i][j]<mat[i][j+1]:\\n                right=fun(i,j+1)\\n                \\n            if i-1>=0 and mat[i][j]<mat[i-1][j]:\\n                up=fun(i-1,j)  \\n            \\n            if j-1>=0 and mat[i][j]<mat[i][j-1]:\\n                left=fun(i,j-1)\\n                \\n            maxpath = 1+max(up,down,left,right)\\n            visited[i][j] = maxpath\\n            \\n            return maxpath\\n        \\n        ans = 1\\n        for i in range(m):\\n            for j in range(n):\\n                ans = max(ans,fun(i,j))\\n        \\n        return ans",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def longestIncreasingPath(self, mat: List[List[int]]) -> int:\\n        m,n = len(mat),len(mat[0])\\n        visited = []\\n        for i in range(m):\\n            visited.append([0]*n)\\n            \\n        def fun(i,j):\\n            if visited[i][j]:\\n                return visited[i][j]\\n           \\n            up,down,left,right = 0,0,0,0\\n            if i+1<m and mat[i][j]<mat[i+1][j]:\\n                down=fun(i+1,j)\\n                \\n            if j+1<n and mat[i][j]<mat[i][j+1]:\\n                right=fun(i,j+1)\\n                \\n            if i-1>=0 and mat[i][j]<mat[i-1][j]:\\n                up=fun(i-1,j)  \\n            \\n            if j-1>=0 and mat[i][j]<mat[i][j-1]:\\n                left=fun(i,j-1)\\n                \\n            maxpath = 1+max(up,down,left,right)\\n            visited[i][j] = maxpath\\n            \\n            return maxpath\\n        \\n        ans = 1\\n        for i in range(m):\\n            for j in range(n):\\n                ans = max(ans,fun(i,j))\\n        \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2053510,
                "title": "c-explanation-with-comments-dp-bfs-daily-leetcoding-challenge-may-day-19",
                "content": "**Please Upvote If It Helps**\\n\\n```\\nclass Solution {\\nprivate:\\n    \\n    //          {-1,0}\\n    //  {0,-1}         {0,1}\\n    //          {1,0}\\n    int dirs[5] = {1,0,-1,0,1};\\n    \\n    bool isvalid(int& r,int& c,int R, int C)\\n    {\\n        // if we are not inside the the boundary then return false \\n        if(r<0 || c<0 || r>=R || c>=C)\\n            return false;\\n        \\n        // else return true\\n        return true;\\n    }\\n    \\n    int helper(vector<vector<int>>& matrix, vector<vector<int>>& dp, int r, int c)\\n    {\\n        // extracting the row and column size of the given matrix\\n        int R = matrix.size();\\n        int C = matrix[0].size();\\n        \\n        // if we have already computed the value for the cell then no need to compute again\\n        if(dp[r][c]!=0)\\n            return dp[r][c];\\n        \\n        // now according to condition we can move into 4 different directions \\n        // so just go and compute the value in each direction\\n        for(int i=0;i<4;i++)\\n        {\\n            // according to current directions compute cells position\\n            int n_row = dirs[i]+r;\\n            int n_col = dirs[i+1]+c;\\n            \\n            // if our new direction is inside the boundary and the value is greater than the current one only then we will go for that\\n            if(isvalid(n_row,n_col,R,C) && matrix[n_row][n_col]>matrix[r][c])\\n                dp[r][c] = max(dp[r][c],1+helper(matrix,dp,n_row,n_col));                    // we are adding 1 here , because each cell length is 1 as we are taking this cell in our path so just add one\\n        }\\n        return dp[r][c];\\n    }\\n    \\n public:   \\n    int longestIncreasingPath(vector<vector<int>>& matrix) \\n    {\\n        // extracting the row and column size of the given matrix\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        \\n        // created a new matrix and assign all value 0 initially\\n        vector<vector<int>> dp(row,vector<int>(col,0));\\n        int mx = 0;                                               // it will store the final max length\\n        \\n        // computing the max increasing length for each matrix cell\\n        // and returning the max one\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                // if cell is not computed\\n                if(dp[i][j]==0)\\n                {\\n                    // there is a helper function that will compute the maximum increasing length for cells\\n                    mx = max(mx,helper(matrix,dp,i,j));\\n                } \\n            }\\n        }\\n        return mx+1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    \\n    //          {-1,0}\\n    //  {0,-1}         {0,1}\\n    //          {1,0}\\n    int dirs[5] = {1,0,-1,0,1};\\n    \\n    bool isvalid(int& r,int& c,int R, int C)\\n    {\\n        // if we are not inside the the boundary then return false \\n        if(r<0 || c<0 || r>=R || c>=C)\\n            return false;\\n        \\n        // else return true\\n        return true;\\n    }\\n    \\n    int helper(vector<vector<int>>& matrix, vector<vector<int>>& dp, int r, int c)\\n    {\\n        // extracting the row and column size of the given matrix\\n        int R = matrix.size();\\n        int C = matrix[0].size();\\n        \\n        // if we have already computed the value for the cell then no need to compute again\\n        if(dp[r][c]!=0)\\n            return dp[r][c];\\n        \\n        // now according to condition we can move into 4 different directions \\n        // so just go and compute the value in each direction\\n        for(int i=0;i<4;i++)\\n        {\\n            // according to current directions compute cells position\\n            int n_row = dirs[i]+r;\\n            int n_col = dirs[i+1]+c;\\n            \\n            // if our new direction is inside the boundary and the value is greater than the current one only then we will go for that\\n            if(isvalid(n_row,n_col,R,C) && matrix[n_row][n_col]>matrix[r][c])\\n                dp[r][c] = max(dp[r][c],1+helper(matrix,dp,n_row,n_col));                    // we are adding 1 here , because each cell length is 1 as we are taking this cell in our path so just add one\\n        }\\n        return dp[r][c];\\n    }\\n    \\n public:   \\n    int longestIncreasingPath(vector<vector<int>>& matrix) \\n    {\\n        // extracting the row and column size of the given matrix\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        \\n        // created a new matrix and assign all value 0 initially\\n        vector<vector<int>> dp(row,vector<int>(col,0));\\n        int mx = 0;                                               // it will store the final max length\\n        \\n        // computing the max increasing length for each matrix cell\\n        // and returning the max one\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                // if cell is not computed\\n                if(dp[i][j]==0)\\n                {\\n                    // there is a helper function that will compute the maximum increasing length for cells\\n                    mx = max(mx,helper(matrix,dp,i,j));\\n                } \\n            }\\n        }\\n        return mx+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2052795,
                "title": "dynamic-approach-dfs-readable-code",
                "content": "lip -> longest Increasing Path\\n```\\nclass Solution {\\n    static Integer[][] lip;\\n    static int[][] matrix;\\n    static int[][] dirs = {{-1,0},{0,1},{1,0},{0,-1}};\\n    static int dfs(int row,int col){\\n        lip[row][col] = 1;\\n        int longestPath = Integer.MIN_VALUE;\\n        \\n        for(int[] dir: dirs){\\n            int pathLength = 1;\\n            int newRow = row + dir[0];\\n            int newCol = col + dir[1];\\n            if(newRow>=0\\n              &&newCol>=0\\n              &&newRow<lip.length\\n              &&newCol<lip[0].length\\n              &&matrix[newRow][newCol] < matrix[row][col])\\n            {\\n                if(lip[newRow][newCol]==null)\\n                    pathLength = dfs(newRow,newCol)+1;\\n                else\\n                    pathLength = lip[newRow][newCol] + 1;\\n            }\\n            longestPath = Math.max(longestPath,pathLength);\\n        }\\n        \\n        lip[row][col] = longestPath;\\n        return longestPath;\\n    }\\n    \\n    public int longestIncreasingPath(int[][] matrix) {\\n        lip = new Integer[matrix.length][matrix[0].length];\\n        this.matrix = matrix;\\n        int max = Integer.MIN_VALUE;\\n        for(int row=0; row<matrix.length;row++){\\n            for(int col=0;col<matrix[0].length;col++){\\n                if(lip[row][col] == null){\\n                    int temp = dfs(row,col);\\n                    max = Math.max(temp,max);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\\nHappy LeetCoding",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    static Integer[][] lip;\\n    static int[][] matrix;\\n    static int[][] dirs = {{-1,0},{0,1},{1,0},{0,-1}};\\n    static int dfs(int row,int col){\\n        lip[row][col] = 1;\\n        int longestPath = Integer.MIN_VALUE;\\n        \\n        for(int[] dir: dirs){\\n            int pathLength = 1;\\n            int newRow = row + dir[0];\\n            int newCol = col + dir[1];\\n            if(newRow>=0\\n              &&newCol>=0\\n              &&newRow<lip.length\\n              &&newCol<lip[0].length\\n              &&matrix[newRow][newCol] < matrix[row][col])\\n            {\\n                if(lip[newRow][newCol]==null)\\n                    pathLength = dfs(newRow,newCol)+1;\\n                else\\n                    pathLength = lip[newRow][newCol] + 1;\\n            }\\n            longestPath = Math.max(longestPath,pathLength);\\n        }\\n        \\n        lip[row][col] = longestPath;\\n        return longestPath;\\n    }\\n    \\n    public int longestIncreasingPath(int[][] matrix) {\\n        lip = new Integer[matrix.length][matrix[0].length];\\n        this.matrix = matrix;\\n        int max = Integer.MIN_VALUE;\\n        for(int row=0; row<matrix.length;row++){\\n            for(int col=0;col<matrix[0].length;col++){\\n                if(lip[row][col] == null){\\n                    int temp = dfs(row,col);\\n                    max = Math.max(temp,max);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2052458,
                "title": "java-simple-and-concise-dfs-dp",
                "content": "```\\nclass Solution {\\n    private static final int[] DIR_X = new int[]{-1,0,1,0};\\n    private static final int[] DIR_Y = new int[]{0,1,0,-1};\\n        \\n    public int longestIncreasingPath(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int max = 0;\\n        // Max increasing path length from each cell\\n        int[][] dp = new int[m][n];        \\n        \\n        // Check increasing path length from each cell\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                max = Math.max(max, longestIncreasingPath(matrix, m, n, i, j, dp));\\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    private int longestIncreasingPath(int[][] matrix, int m, int n, int x, int y, int[][] dp) {\\n        // If increasing path length has already been calculated, return the length \\n        if( dp[x][y] != 0 ) return dp[x][y];\\n        \\n        int max = 0;\\n        \\n        /* Try moving in all the four directions from current cell, and get the maximum\\n        of it */\\n        for(int i=0; i<4; i++) {\\n            int dx = x + DIR_X[i];\\n            int dy = y + DIR_Y[i];\\n            \\n            if( dx < 0 || dy < 0 || dx >= m || dy >= n || matrix[x][y] >= matrix[dx][dy])\\n                continue;\\n            \\n            max = Math.max( max, longestIncreasingPath(matrix, m, n, dx, dy, dp) );\\n        }\\n        \\n        // Include current cell in the max path length and store it in the dp.\\n        return dp[x][y] = max+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static final int[] DIR_X = new int[]{-1,0,1,0};\\n    private static final int[] DIR_Y = new int[]{0,1,0,-1};\\n        \\n    public int longestIncreasingPath(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int max = 0;\\n        // Max increasing path length from each cell\\n        int[][] dp = new int[m][n];        \\n        \\n        // Check increasing path length from each cell\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                max = Math.max(max, longestIncreasingPath(matrix, m, n, i, j, dp));\\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    private int longestIncreasingPath(int[][] matrix, int m, int n, int x, int y, int[][] dp) {\\n        // If increasing path length has already been calculated, return the length \\n        if( dp[x][y] != 0 ) return dp[x][y];\\n        \\n        int max = 0;\\n        \\n        /* Try moving in all the four directions from current cell, and get the maximum\\n        of it */\\n        for(int i=0; i<4; i++) {\\n            int dx = x + DIR_X[i];\\n            int dy = y + DIR_Y[i];\\n            \\n            if( dx < 0 || dy < 0 || dx >= m || dy >= n || matrix[x][y] >= matrix[dx][dy])\\n                continue;\\n            \\n            max = Math.max( max, longestIncreasingPath(matrix, m, n, dx, dy, dp) );\\n        }\\n        \\n        // Include current cell in the max path length and store it in the dp.\\n        return dp[x][y] = max+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2052197,
                "title": "easy-to-understand-solution-with-explaination-in-c",
                "content": "Start from every node and check which path is greater.\\n\\nPLEASE UPVOTE IF YOU LIKE\\n\\n\\n1.c++ solution\\n```\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    int dfs(vector<vector<int>> &mat, int i, int j, int pre) {\\n\\t//check node is valid or not and also increasing\\n        if (i < 0 || j < 0 || i == mat.size() || j == mat[0].size() || pre >= mat[i][j])\\n            return 0;\\n        if (dp[i][j]) return dp[i][j];\\n\\t\\t// find solution in every possible direction\\n\\t\\t//1.left\\n        int l = dfs(mat, i, j - 1, mat[i][j]);\\n\\t\\t//right\\n        int r = dfs(mat, i, j + 1, mat[i][j]);\\n\\t\\t//up\\n        int u = dfs(mat, i - 1, j, mat[i][j]);\\n\\t\\t//down\\n        int d = dfs(mat, i + 1, j, mat[i][j]);\\n\\t\\t//if any path is possible then increase its by one \\n        return dp[i][j] = max({l, r, u, d}) + 1;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int maxVal = 0;\\n\\t\\t// we must check every node because any node should be our starting node\\n        for (int i = 0; i < matrix.size(); i++)\\n            for (int j = 0; j < matrix[i].size(); j++)\\n\\t\\t\\t//store max value\\n                maxVal = max(maxVal, dfs(matrix, i, j, -1));\\n        return maxVal;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int dp[201][201];\\n    int dfs(vector<vector<int>> &mat, int i, int j, int pre) {\\n\\t//check node is valid or not and also increasing\\n        if (i < 0 || j < 0 || i == mat.size() || j == mat[0].size() || pre >= mat[i][j])\\n            return 0;\\n        if (dp[i][j]) return dp[i][j];\\n\\t\\t// find solution in every possible direction\\n\\t\\t//1.left\\n        int l = dfs(mat, i, j - 1, mat[i][j]);\\n\\t\\t//right\\n        int r = dfs(mat, i, j + 1, mat[i][j]);\\n\\t\\t//up\\n        int u = dfs(mat, i - 1, j, mat[i][j]);\\n\\t\\t//down\\n        int d = dfs(mat, i + 1, j, mat[i][j]);\\n\\t\\t//if any path is possible then increase its by one \\n        return dp[i][j] = max({l, r, u, d}",
                "codeTag": "Java"
            },
            {
                "id": 1331333,
                "title": "c-onion-peeling-topological-sort",
                "content": "**Intution:**\\n\\n* Graph topological sort from biggest to smallest\\n\\n```\\nclass Solution {\\npublic:\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = n ? matrix[0].size() : 0;\\n        vector<vector<int>> indegree(n, vector<int>(m,0));\\n        \\n        vector<int> xdiff = {0,1,0,-1}; \\n        vector<int> ydiff = {-1,0,1,0}; \\n\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                for(int k =0;k<4;++k){\\n                    int nx=i+xdiff[k];\\n                    int ny=j+ydiff[k];\\n                    if(nx>=0 && ny>=0 && nx<n && ny<m)\\n                    {\\n                        if(matrix[nx][ny]>matrix[i][j])\\n                            indegree[i][j]++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        queue<pair<int,int>> q;\\n        int ans =0;\\n        for(int i=0;i < n;++i){\\n            for(int j=0;j < m;++j){\\n                if(indegree[i][j] == 0){\\n                    q.push({i,j});\\n                }\\n            }\\n        }\\n\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                pair<int,int> node=q.front();\\n                q.pop();\\n                 for(int k =0;k<4;++k){\\n                     int nx = node.first+xdiff[k];\\n                     int ny = node.second+ydiff[k];\\n                    if(nx>=0 && ny>=0 && nx<n &&ny<m ){\\n                        if(matrix[node.first][node.second] > matrix[nx][ny] && --indegree[nx][ny] == 0){\\n                            q.push({nx,ny});\\n                        }\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = n ? matrix[0].size() : 0;\\n        vector<vector<int>> indegree(n, vector<int>(m,0));\\n        \\n        vector<int> xdiff = {0,1,0,-1}; \\n        vector<int> ydiff = {-1,0,1,0}; \\n\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                for(int k =0;k<4;++k){\\n                    int nx=i+xdiff[k];\\n                    int ny=j+ydiff[k];\\n                    if(nx>=0 && ny>=0 && nx<n && ny<m)\\n                    {\\n                        if(matrix[nx][ny]>matrix[i][j])\\n                            indegree[i][j]++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        queue<pair<int,int>> q;\\n        int ans =0;\\n        for(int i=0;i < n;++i){\\n            for(int j=0;j < m;++j){\\n                if(indegree[i][j] == 0){\\n                    q.push({i,j});\\n                }\\n            }\\n        }\\n\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                pair<int,int> node=q.front();\\n                q.pop();\\n                 for(int k =0;k<4;++k){\\n                     int nx = node.first+xdiff[k];\\n                     int ny = node.second+ydiff[k];\\n                    if(nx>=0 && ny>=0 && nx<n &&ny<m ){\\n                        if(matrix[node.first][node.second] > matrix[nx][ny] && --indegree[nx][ny] == 0){\\n                            q.push({nx,ny});\\n                        }\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1288930,
                "title": "c-dfs-dp-easiest-solution-beats-97-all-aprroach-explained",
                "content": "**DFS Approach**\\n* The ideal appoach is traverse every cell of matrix and do DFS for each cell.\\n* Keep a variable, that stores maxlen obtained from any cell so far.\\n* At the end, this variable will store maximum length.\\n* Time Comlexity= O((mxn) x (mxn)). mxn for traversal of every cell. mxn for dfs as dfs can atmost travel all nodes and total nodes(cell) are mxn.\\n* This will however result in TLE.\\n* But Lets understand the code for future optimizing.\\n\\n```\\nvector<int> dx={0,-1,0,1};\\n    vector<int> dy={-1,0,1,0};\\n    \\n    void dfs(int i,int j,vector<vector<int>>& matrix,int len,int &maxlen){\\n        if(len>maxlen)\\n            maxlen=len;\\n        \\n        int temp=matrix[i][j];\\n        matrix[i][j]=-1;// mark cell as visited\\n        for(int k=0;k<4;k++){\\n            int x= i+dx[k];\\n            int y= j+dy[k];\\n            if((x>=0 && x<matrix.size() && y>=0 && y<matrix[0].size()) && matrix[x][y]>temp){\\n                dfs(x,y,matrix,len+1,maxlen);\\n            }\\n        }\\n        matrix[i][j]=temp;\\n    }\\n    \\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n=matrix.size(),m=matrix[0].size();\\n        int maxlen=0,len=1;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                dfs(i,j,matrix,len,maxlen);\\n            }\\n        }\\n        return maxlen;\\n    }\\n```\\n\\n**DFS + DP Approach**\\n* The problem in the above approach is that it everytime calculates value for every cell.\\n* If we save the value once, then whenever we reach to this calculated cell, we need not to find its value. Rather, we can just return its value in * O(1)* time which earlier took O(mxn) time.\\n* Time Complexity= O(mxn + mxn) =O(mxn).  mxn for traversal of every cell. Every cell is calculated at most 1 time. so once only mxn. Therefore total time complexity= O(mxn +mxn) = O(mxn).\\n\\n```\\nvector<int> dx={0,-1,0,1};\\n    vector<int> dy={-1,0,1,0};\\n    \\n    int dfs(int i,int j,vector<vector<int>>& matrix,vector<vector<int>>& dp){\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int temp=matrix[i][j];\\n        matrix[i][j]=-1; //mark cell as visited\\n        \\n        dp[i][j]=1;\\n        for(int k=0;k<4;k++){\\n            int x=i+dx[k]; int y=j+dy[k];\\n            if((x>=0 && x<matrix.size() && y>=0 && y<matrix[i].size()) && matrix[x][y]>temp){\\n                dp[i][j]=max(dp[i][j],1+dfs(x,y,matrix,dp));\\n            }\\n        }\\n        matrix[i][j]=temp;\\n        return dp[i][j];\\n    }\\n    \\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n=matrix.size(),m=matrix[0].size();\\n        \\n        int maxlen=1;\\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(dp[i][j]==-1){ //!visited\\n                    int len=dfs(i,j,matrix,dp);\\n                    maxlen=max(maxlen,len);\\n                }\\n            }\\n        }\\n        return maxlen;\\n    }\\n```\\n\\n**Consider Upvoting if this helped !**",
                "solutionTags": [],
                "code": "```\\nvector<int> dx={0,-1,0,1};\\n    vector<int> dy={-1,0,1,0};\\n    \\n    void dfs(int i,int j,vector<vector<int>>& matrix,int len,int &maxlen){\\n        if(len>maxlen)\\n            maxlen=len;\\n        \\n        int temp=matrix[i][j];\\n        matrix[i][j]=-1;// mark cell as visited\\n        for(int k=0;k<4;k++){\\n            int x= i+dx[k];\\n            int y= j+dy[k];\\n            if((x>=0 && x<matrix.size() && y>=0 && y<matrix[0].size()) && matrix[x][y]>temp){\\n                dfs(x,y,matrix,len+1,maxlen);\\n            }\\n        }\\n        matrix[i][j]=temp;\\n    }\\n    \\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n=matrix.size(),m=matrix[0].size();\\n        int maxlen=0,len=1;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                dfs(i,j,matrix,len,maxlen);\\n            }\\n        }\\n        return maxlen;\\n    }\\n```\n```\\nvector<int> dx={0,-1,0,1};\\n    vector<int> dy={-1,0,1,0};\\n    \\n    int dfs(int i,int j,vector<vector<int>>& matrix,vector<vector<int>>& dp){\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int temp=matrix[i][j];\\n        matrix[i][j]=-1; //mark cell as visited\\n        \\n        dp[i][j]=1;\\n        for(int k=0;k<4;k++){\\n            int x=i+dx[k]; int y=j+dy[k];\\n            if((x>=0 && x<matrix.size() && y>=0 && y<matrix[i].size()) && matrix[x][y]>temp){\\n                dp[i][j]=max(dp[i][j],1+dfs(x,y,matrix,dp));\\n            }\\n        }\\n        matrix[i][j]=temp;\\n        return dp[i][j];\\n    }\\n    \\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n=matrix.size(),m=matrix[0].size();\\n        \\n        int maxlen=1;\\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(dp[i][j]==-1){ //!visited\\n                    int len=dfs(i,j,matrix,dp);\\n                    maxlen=max(maxlen,len);\\n                }\\n            }\\n        }\\n        return maxlen;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1231432,
                "title": "c-dfs-dp-100-faster-super-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[205][205];\\n    int d[4][2]={{-1,0},{0,-1},{1,0},{0,1}}; // For all 4 Directions\\n    int dfs(vector<vector<int>>&a , int i, int j , int c,int n, int m)\\n    {\\n        if(dp[i][j] != -1)\\n            return dp[i][j]+c;\\n        int c1=c;\\n        for(auto l:d)\\n        {\\n            int x=i+l[0];\\n            int y=j+l[1];\\n            if(x>=0 && x<n && y>=0 && y<m)\\n             if(a[x][y]>a[i][j])\\n             c1=max(c1,dfs(a,x,y,c+1,n,m));\\n        }\\n     dp[i][j]=c1-c;\\n        return c1;  \\n    }\\n    \\n    int longestIncreasingPath(vector<vector<int>>& a) {\\n        int n=a.size();\\n        int m=a[0].size();\\n        int as=-1;\\n        memset(dp,-1,sizeof dp);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n              as=max(as,dfs(a,i,j,1,n,m)); \\n            }\\n        }\\n        return as;\\n    }\\n};\\n```\\n**Upvote Plz if this help you**",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[205][205];\\n    int d[4][2]={{-1,0},{0,-1},{1,0},{0,1}}; // For all 4 Directions\\n    int dfs(vector<vector<int>>&a , int i, int j , int c,int n, int m)\\n    {\\n        if(dp[i][j] != -1)\\n            return dp[i][j]+c;\\n        int c1=c;\\n        for(auto l:d)\\n        {\\n            int x=i+l[0];\\n            int y=j+l[1];\\n            if(x>=0 && x<n && y>=0 && y<m)\\n             if(a[x][y]>a[i][j])\\n             c1=max(c1,dfs(a,x,y,c+1,n,m));\\n        }\\n     dp[i][j]=c1-c;\\n        return c1;  \\n    }\\n    \\n    int longestIncreasingPath(vector<vector<int>>& a) {\\n        int n=a.size();\\n        int m=a[0].size();\\n        int as=-1;\\n        memset(dp,-1,sizeof dp);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n              as=max(as,dfs(a,i,j,1,n,m)); \\n            }\\n        }\\n        return as;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154281,
                "title": "java-simple-and-easy-dfs-memoization-solution-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n\\n```\\nclass Solution {\\n    static int[][] DIRECTIONS = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    int rows;\\n    int cols;\\n    \\n    int[][] cache;\\n    public int longestIncreasingPath(int[][] matrix) {\\n        rows = matrix.length;\\n        if(rows == 0) return 0;\\n        \\n        cols = matrix[0].length;\\n        \\n        cache = new int[rows][cols];\\n        \\n        int maxIncreasingLengthPath = 0;\\n        for(int row = 0; row < rows; row++){\\n            for(int col = 0; col < cols; col++){\\n                maxIncreasingLengthPath = Math.max(maxIncreasingLengthPath, dfs(matrix, row, col));\\n            }\\n        }\\n        \\n        return maxIncreasingLengthPath;\\n    }\\n    \\n    \\n    private int dfs(int[][] matrix, int row, int col){\\n        if(cache[row][col] != 0) return cache[row][col];\\n        \\n        \\n        //just include this cell\\n        int maxIncreasingLengthPath = 1;\\n        \\n        for(int[] dir : DIRECTIONS){\\n            int adjRow = row + dir[0];\\n            int adjCol = col + dir[1];\\n            \\n            //outside the grid, ignore it\\n            if(adjRow < 0 || adjRow >= rows || adjCol < 0 || adjCol >= cols) continue;\\n            \\n            //not greater than current cell, ignore it\\n            if(matrix[adjRow][adjCol] <= matrix[row][col]) continue;\\n            \\n            \\n            maxIncreasingLengthPath = Math.max(maxIncreasingLengthPath, dfs(matrix, adjRow, adjCol) + 1);\\n        }\\n        \\n        cache[row][col] = maxIncreasingLengthPath;\\n        \\n        return cache[row][col];\\n    }\\n \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static int[][] DIRECTIONS = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    int rows;\\n    int cols;\\n    \\n    int[][] cache;\\n    public int longestIncreasingPath(int[][] matrix) {\\n        rows = matrix.length;\\n        if(rows == 0) return 0;\\n        \\n        cols = matrix[0].length;\\n        \\n        cache = new int[rows][cols];\\n        \\n        int maxIncreasingLengthPath = 0;\\n        for(int row = 0; row < rows; row++){\\n            for(int col = 0; col < cols; col++){\\n                maxIncreasingLengthPath = Math.max(maxIncreasingLengthPath, dfs(matrix, row, col));\\n            }\\n        }\\n        \\n        return maxIncreasingLengthPath;\\n    }\\n    \\n    \\n    private int dfs(int[][] matrix, int row, int col){\\n        if(cache[row][col] != 0) return cache[row][col];\\n        \\n        \\n        //just include this cell\\n        int maxIncreasingLengthPath = 1;\\n        \\n        for(int[] dir : DIRECTIONS){\\n            int adjRow = row + dir[0];\\n            int adjCol = col + dir[1];\\n            \\n            //outside the grid, ignore it\\n            if(adjRow < 0 || adjRow >= rows || adjCol < 0 || adjCol >= cols) continue;\\n            \\n            //not greater than current cell, ignore it\\n            if(matrix[adjRow][adjCol] <= matrix[row][col]) continue;\\n            \\n            \\n            maxIncreasingLengthPath = Math.max(maxIncreasingLengthPath, dfs(matrix, adjRow, adjCol) + 1);\\n        }\\n        \\n        cache[row][col] = maxIncreasingLengthPath;\\n        \\n        return cache[row][col];\\n    }\\n \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1151851,
                "title": "java-simple-recursion-with-memoization-explained-time-o-n-m-space-o-n-m-faster-than-98",
                "content": "The main idea is simple, to develop a recursive funtion so that we can go through and check elements in all the 4 directions. Save all the results in the cache to re-use them again. So, we create a simple recursive function which goes in all the 4 directions and checks if the next element is greater than the current one or not, and we take the maximum out of all the 4 results. We also count the current element so its \\'ans+1\\' and save this result in cache.\\n\\n```\\nclass Solution {\\n   \\n    public int longestIncreasingPath(int[][] matrix) {\\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n        \\n\\t\\t//We create a cache for saving the computed result\\n        int cache[][]=new int[n][m];\\n        int max=0;\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++)\\n                max=Math.max(max, recurse(matrix,i,j,cache));\\n        }\\n        return max;\\n    }\\n    \\n    public int recurse(int [][]mat, int r, int c, int [][]cache){\\n\\t//Check boundary condition\\n        if(r<0||r>=mat.length||c<0||c>=mat[0].length)\\n            return 0;\\n\\t\\t\\t//If result is pre-computed use the same result\\n        if(cache[r][c]!=0)\\n            return cache[r][c];\\n        \\n        int ans=0;\\n\\n        //In each direction up,bottom,left and right, check if it is possible to move or not\\n        if(c-1>=0&&mat[r][c-1]>mat[r][c])\\n            ans=Math.max(ans,recurse(mat,r,c-1,cache));\\n        if(c+1<mat[0].length&&mat[r][c+1]>mat[r][c])\\n            ans=Math.max(ans,recurse(mat,r,c+1,cache));\\n        if(r-1>=0&&mat[r-1][c]>mat[r][c])\\n            ans=Math.max(ans,recurse(mat,r-1,c,cache));\\n        if(r+1<mat.length&&mat[r+1][c]>mat[r][c])\\n            ans=Math.max(ans,recurse(mat,r+1,c,cache));        \\n\\t\\t\\t\\n\\t\\t//Finally, take the biggest possible answer and add 1 as this current element must be counted\\n\\t\\t//Store that result in the cache\\n        cache[r][c]=1+ans;\\n        return 1+ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n   \\n    public int longestIncreasingPath(int[][] matrix) {\\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n        \\n\\t\\t//We create a cache for saving the computed result\\n        int cache[][]=new int[n][m];\\n        int max=0;\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++)\\n                max=Math.max(max, recurse(matrix,i,j,cache));\\n        }\\n        return max;\\n    }\\n    \\n    public int recurse(int [][]mat, int r, int c, int [][]cache){\\n\\t//Check boundary condition\\n        if(r<0||r>=mat.length||c<0||c>=mat[0].length)\\n            return 0;\\n\\t\\t\\t//If result is pre-computed use the same result\\n        if(cache[r][c]!=0)\\n            return cache[r][c];\\n        \\n        int ans=0;\\n\\n        //In each direction up,bottom,left and right, check if it is possible to move or not\\n        if(c-1>=0&&mat[r][c-1]>mat[r][c])\\n            ans=Math.max(ans,recurse(mat,r,c-1,cache));\\n        if(c+1<mat[0].length&&mat[r][c+1]>mat[r][c])\\n            ans=Math.max(ans,recurse(mat,r,c+1,cache));\\n        if(r-1>=0&&mat[r-1][c]>mat[r][c])\\n            ans=Math.max(ans,recurse(mat,r-1,c,cache));\\n        if(r+1<mat.length&&mat[r+1][c]>mat[r][c])\\n            ans=Math.max(ans,recurse(mat,r+1,c,cache));        \\n\\t\\t\\t\\n\\t\\t//Finally, take the biggest possible answer and add 1 as this current element must be counted\\n\\t\\t//Store that result in the cache\\n        cache[r][c]=1+ans;\\n        return 1+ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1151224,
                "title": "python-by-dfs-memo-w-hint",
                "content": "Special thanks to [@StefanPochmann guidance on this post](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/discuss/78381/Short-Python...).\\n\\nThat post gives a demo to\\n\\n1. represent 2D coordination (x, y) in [complex plane](https://en.wikipedia.org/wiki/Complex_plane) as x + y j where j is the so-called Imaginary unit such that j^2 = -1\\n\\n2. solve classic 2D matrix/maze problem in DFS with memoization\\n\\n\\n**Hint**:\\n\\n1. Think of **DFS framework** for **2D matrix/maze** problem\\n\\n2. In order to **remove repeated computation** on visited grid, use **memoization** to speed up as a **tradeoff** between **space** and **time**.\\n\\n---\\n\\n**Implementation** by DFS + memoization\\n\\n```\\nclass Solution:\\n    def longestIncreasingPath(self, matrix):\\n        \\n        # -------------------------------------------\\n        def dfs( cur_position ):\\n            \\n            \\n            ## base case aka stop condition:\\n            if cur_position in table:\\n                \\n                # Quick response if cur_position has been explorered\\n                return table[cur_position]\\n            \\n            ## general cases:\\n            # visit each possible neighbor to compute longest increasing path\\n            \\n            longest_length = 0\\n            for next_pos in (cur_position + 1, cur_position - 1 , cur_position + 1j, cur_position - 1j ):\\n                \\n                if next_pos in grids and grids[next_pos] > grids[cur_position]:\\n                    \\n                    longest_length = max(longest_length, dfs(next_pos))\\n            \\n            # update memoization table, and 1 is the length of current position\\n            table[cur_position] = 1 + longest_length\\n            return table[cur_position]\\n        \\n        # -------------------------------------------\\n        \\n        # memoization for dfs\\n        table = {}\\n        \\n        ## dictionary\\n        # key: (X + Yj), 2D coordination in matrix. (j is imaginary part to present y axis in 2D coordination)\\n        # value: corresponding matrix value to (X, Y)\\n        grids = { x + y * 1j: value for y, row in enumerate(matrix) for x, value in enumerate(row) }\\n        \\n        # start DFS on each possible 2D coordination in grids\\n        return max( map(dfs, grids) )\\n```\\n\\n---\\n\\nReference:\\n\\n[1]  [@StefanPochmann guidance on this post: Short Python...](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/discuss/78381/Short-Python...)\\n\\n[2] [Python official docs about dictionary](https://www.python.org/dev/peps/pep-0274/)\\n\\n[3] [Python official docs about enumerate( ... )](https://docs.python.org/3/library/functions.html#enumerate)\\n\\n[4] [Python official docs about complex number a + b j](https://docs.python.org/3/library/numbers.html?highlight=complex%20number#the-numeric-tower)\\n\\n[5] [Wiki: Complex plane](https://en.wikipedia.org/wiki/Complex_plane)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def longestIncreasingPath(self, matrix):\\n        \\n        # -------------------------------------------\\n        def dfs( cur_position ):\\n            \\n            \\n            ## base case aka stop condition:\\n            if cur_position in table:\\n                \\n                # Quick response if cur_position has been explorered\\n                return table[cur_position]\\n            \\n            ## general cases:\\n            # visit each possible neighbor to compute longest increasing path\\n            \\n            longest_length = 0\\n            for next_pos in (cur_position + 1, cur_position - 1 , cur_position + 1j, cur_position - 1j ):\\n                \\n                if next_pos in grids and grids[next_pos] > grids[cur_position]:\\n                    \\n                    longest_length = max(longest_length, dfs(next_pos))\\n            \\n            # update memoization table, and 1 is the length of current position\\n            table[cur_position] = 1 + longest_length\\n            return table[cur_position]\\n        \\n        # -------------------------------------------\\n        \\n        # memoization for dfs\\n        table = {}\\n        \\n        ## dictionary\\n        # key: (X + Yj), 2D coordination in matrix. (j is imaginary part to present y axis in 2D coordination)\\n        # value: corresponding matrix value to (X, Y)\\n        grids = { x + y * 1j: value for y, row in enumerate(matrix) for x, value in enumerate(row) }\\n        \\n        # start DFS on each possible 2D coordination in grids\\n        return max( map(dfs, grids) )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1151208,
                "title": "js-faster-smaller-than-93-88-100ms-41-8mb-dp-memoization",
                "content": "Concept: Each position can be viewed as the longest trip of its neighbors +1\\nNote that this is only for neighbors who are *strictly* larger than itself\\nusing the sample:\\n```\\n[[9,9,4]\\n,[6,6,8]\\n,[2,1,1]]\\n```\\nthe length each positions longest path can be represented as:\\n```\\n[[1,1,2]\\n,[2,2,1]\\n,[3,4,2]]\\n```\\nNow this one can be solved by just iterating through from 0,0 to n-1, n[0]-1, but what if it looked like:\\n```\\n[[2,1,1]\\n,[6,6,8]\\n,[9,9,4]\\n```\\nThen, we wouldn\\'t have the tail end of the path completed before we reached the beginning.\\n\\nInstead we could write a greedy function, and build out strictly increasing paths.\\nSo, we create a matrix to track the maximum path length for each element, iterate through each value of the original matrix, calling a recursive greedy function to fill in their values, and keep track of the largest value found.\\n```\\n/**\\n * @param {number[][]} matrix\\n * @return {number}\\n */\\nvar longestIncreasingPath = function(matrix) {\\n    const dp = new Array(matrix.length);\\n\\t// begin by filling the matrix with 0\\'s, so we know when they\\'ve been altered.\\n    for(let i = 0; i < matrix.length; i++)dp[i] = new Array(matrix[0].length).fill(0); \\n    let max = 0;\\n\\t// visit each value in the matrix, calling our function on each\\n    for(let i = 0; i < matrix.length; i++){\\n        for(let j = 0; j < matrix[0].length; j++){\\n            max = Math.max(max, dfs(i,j));\\n        }\\n    }\\n    function dfs(x,y){\\n\\t\\t// if the value on dp is \\'0\\' we know it hasn\\'t been visited yet and need to be filled, if it is not \\'0\\', we have already been here and can just return its value.\\n        if(dp[x][y] === 0){\\n            dp[x][y] = 1; // set equal to one, to account for its own step in the path\\n\\t\\t\\t// now we call on each of the strictly increasing neighbors (if in range) and replace if the neighbor is larger (+1 for x,y\\'s step)\\n\\t\\t\\tif(x > 0 && matrix[x][y] < matrix[x-1][y]) dp[x][y] = Math.max(dp[x][y], dfs(x-1, y)+1);\\n            if(x +1 < matrix.length && matrix[x][y] < matrix[x+1][y]) dp[x][y] = Math.max(dp[x][y], dfs(x+1, y)+1);\\n            if(y > 0 && matrix[x][y] < matrix[x][y-1]) dp[x][y] = Math.max(dp[x][y], dfs(x, y-1)+1);\\n            if(y +1 < matrix[0].length && matrix[x][y] < matrix[x][y+1]) dp[x][y] = Math.max(dp[x][y], dfs(x, y+1)+1);\\n        }\\n        return dp[x][y]\\n    }\\n    return max\\n};\\n```\\n\\nIf you made it this far and it made sense, great! If not, let me know what wasn\\'t clear so I can be sure to edit and explain better in the future!\\n\\nAppreciate you taking the time and I hope this was of help.\\n\\nCheers!",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n[[9,9,4]\\n,[6,6,8]\\n,[2,1,1]]\\n```\n```\\n[[1,1,2]\\n,[2,2,1]\\n,[3,4,2]]\\n```\n```\\n[[2,1,1]\\n,[6,6,8]\\n,[9,9,4]\\n```\n```\\n/**\\n * @param {number[][]} matrix\\n * @return {number}\\n */\\nvar longestIncreasingPath = function(matrix) {\\n    const dp = new Array(matrix.length);\\n\\t// begin by filling the matrix with 0\\'s, so we know when they\\'ve been altered.\\n    for(let i = 0; i < matrix.length; i++)dp[i] = new Array(matrix[0].length).fill(0); \\n    let max = 0;\\n\\t// visit each value in the matrix, calling our function on each\\n    for(let i = 0; i < matrix.length; i++){\\n        for(let j = 0; j < matrix[0].length; j++){\\n            max = Math.max(max, dfs(i,j));\\n        }\\n    }\\n    function dfs(x,y){\\n\\t\\t// if the value on dp is \\'0\\' we know it hasn\\'t been visited yet and need to be filled, if it is not \\'0\\', we have already been here and can just return its value.\\n        if(dp[x][y] === 0){\\n            dp[x][y] = 1; // set equal to one, to account for its own step in the path\\n\\t\\t\\t// now we call on each of the strictly increasing neighbors (if in range) and replace if the neighbor is larger (+1 for x,y\\'s step)\\n\\t\\t\\tif(x > 0 && matrix[x][y] < matrix[x-1][y]) dp[x][y] = Math.max(dp[x][y], dfs(x-1, y)+1);\\n            if(x +1 < matrix.length && matrix[x][y] < matrix[x+1][y]) dp[x][y] = Math.max(dp[x][y], dfs(x+1, y)+1);\\n            if(y > 0 && matrix[x][y] < matrix[x][y-1]) dp[x][y] = Math.max(dp[x][y], dfs(x, y-1)+1);\\n            if(y +1 < matrix[0].length && matrix[x][y] < matrix[x][y+1]) dp[x][y] = Math.max(dp[x][y], dfs(x, y+1)+1);\\n        }\\n        return dp[x][y]\\n    }\\n    return max\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1036953,
                "title": "python-simple-and-intiuitive-topological-sort",
                "content": "```\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        \\n        m,n = len(matrix),len(matrix[0])\\n        \\n        # Topological Starting\\n        out_degrees = collections.defaultdict(list)\\n        in_degrees  = collections.defaultdict(int)\\n        \\n        # gets all neighbors that are in bound\\n        def get_neighbors(i,j):\\n            for new_i,new_j in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:\\n                if 0 <= new_i < m and 0 <= new_j < n:\\n                    yield (new_i,new_j)\\n        \\n        # for each neighbor of a specific cell that is greater\\n        # than the specific cell gets out and in degree modified\\n        for i in range(m):\\n            for j in range(n):\\n                for new_i,new_j in get_neighbors(i,j):\\n                    if matrix[i][j] < matrix[new_i][new_j]:\\n                        out_degrees[(i,j)] += [(new_i,new_j)]\\n                        in_degrees[(new_i,new_j)]  += 1\\n        \\n        # A cell with in-degree of 0 is a cell that is greater\\n        # than all its neighbors.\\n        queue = collections.deque()\\n        for i in range(m):\\n            for j in range(n):\\n                if in_degrees[(i,j)] == 0:\\n                    queue.append((i,j))\\n        \\n        # Go through each level(in degree\\'s with 0 first), and then decrement\\n        # the indegree for all the nodes the current node points to.\\n        # If that indegree then becomes 0 after decrement its ready to be\\n        # inserted to the next batch(level)\\n        # By each level increment the length\\n        max_len = 0\\n        while queue:\\n            max_len+=1\\n            for _ in range(len(queue)):\\n                i,j = queue.popleft()\\n                for new_coord in out_degrees[i,j]:\\n                    in_degrees[new_coord]-=1\\n                    if in_degrees[new_coord] == 0:\\n                        queue.append(new_coord)\\n        \\n        return max_len\\n```",
                "solutionTags": [
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        \\n        m,n = len(matrix),len(matrix[0])\\n        \\n        # Topological Starting\\n        out_degrees = collections.defaultdict(list)\\n        in_degrees  = collections.defaultdict(int)\\n        \\n        # gets all neighbors that are in bound\\n        def get_neighbors(i,j):\\n            for new_i,new_j in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:\\n                if 0 <= new_i < m and 0 <= new_j < n:\\n                    yield (new_i,new_j)\\n        \\n        # for each neighbor of a specific cell that is greater\\n        # than the specific cell gets out and in degree modified\\n        for i in range(m):\\n            for j in range(n):\\n                for new_i,new_j in get_neighbors(i,j):\\n                    if matrix[i][j] < matrix[new_i][new_j]:\\n                        out_degrees[(i,j)] += [(new_i,new_j)]\\n                        in_degrees[(new_i,new_j)]  += 1\\n        \\n        # A cell with in-degree of 0 is a cell that is greater\\n        # than all its neighbors.\\n        queue = collections.deque()\\n        for i in range(m):\\n            for j in range(n):\\n                if in_degrees[(i,j)] == 0:\\n                    queue.append((i,j))\\n        \\n        # Go through each level(in degree\\'s with 0 first), and then decrement\\n        # the indegree for all the nodes the current node points to.\\n        # If that indegree then becomes 0 after decrement its ready to be\\n        # inserted to the next batch(level)\\n        # By each level increment the length\\n        max_len = 0\\n        while queue:\\n            max_len+=1\\n            for _ in range(len(queue)):\\n                i,j = queue.popleft()\\n                for new_coord in out_degrees[i,j]:\\n                    in_degrees[new_coord]-=1\\n                    if in_degrees[new_coord] == 0:\\n                        queue.append(new_coord)\\n        \\n        return max_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 993121,
                "title": "java-dp-dfs",
                "content": "DP with simple DFS frpm each matrix element\\n\\n```\\nclass Solution {\\n    public int answer(int[][] a,int i,int j, int dp[][],int pre){\\n        if(i<0 || j<0 || i>=a.length || j>=a[i].length)\\n            return -1;\\n        if(a[i][j]<=pre)    return -1;\\n        if(dp[i][j]!=-1)    return dp[i][j];\\n        int temp = 1;\\n        temp = Math.max(temp,answer(a,i-1,j,dp,a[i][j])+1);\\n        temp = Math.max(temp,answer(a,i,j-1,dp,a[i][j])+1);\\n        temp = Math.max(temp,answer(a,i+1,j,dp,a[i][j])+1);\\n        temp = Math.max(temp,answer(a,i,j+1,dp,a[i][j])+1);\\n        dp[i][j] = temp;\\n        return temp;\\n    }\\n    public int longestIncreasingPath(int[][] a) {\\n        if(a.length==0) return 0;\\n        int dp[][] = new int[a.length][a[0].length];\\n        for(int i=0;i<a.length;i++){\\n            for(int j=0;j<a[i].length;j++){\\n                dp[i][j] = -1;\\n            }\\n        }\\n        int max = 0;\\n        for(int i=0;i<a.length;i++){\\n            for(int j=0;j<a[i].length;j++){\\n                max = Math.max(max,answer(a,i,j,dp,Integer.MIN_VALUE));\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int answer(int[][] a,int i,int j, int dp[][],int pre){\\n        if(i<0 || j<0 || i>=a.length || j>=a[i].length)\\n            return -1;\\n        if(a[i][j]<=pre)    return -1;\\n        if(dp[i][j]!=-1)    return dp[i][j];\\n        int temp = 1;\\n        temp = Math.max(temp,answer(a,i-1,j,dp,a[i][j])+1);\\n        temp = Math.max(temp,answer(a,i,j-1,dp,a[i][j])+1);\\n        temp = Math.max(temp,answer(a,i+1,j,dp,a[i][j])+1);\\n        temp = Math.max(temp,answer(a,i,j+1,dp,a[i][j])+1);\\n        dp[i][j] = temp;\\n        return temp;\\n    }\\n    public int longestIncreasingPath(int[][] a) {\\n        if(a.length==0) return 0;\\n        int dp[][] = new int[a.length][a[0].length];\\n        for(int i=0;i<a.length;i++){\\n            for(int j=0;j<a[i].length;j++){\\n                dp[i][j] = -1;\\n            }\\n        }\\n        int max = 0;\\n        for(int i=0;i<a.length;i++){\\n            for(int j=0;j<a[i].length;j++){\\n                max = Math.max(max,answer(a,i,j,dp,Integer.MIN_VALUE));\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 834211,
                "title": "java-dp-solution-with-explanation-and-example-nm-log-nm-time",
                "content": "The idea is simple - for each we want to calculate the longest path starting with current cell.\\nto do this, we begin with the highest value in the matrix. for it the longest path length = 1 (it includes this cell only). for all the next cells we calculate this path as MAX of all path lengths for the neighbouring cells with value bigger than current (and of course after calculating this max, we\\'ll do +1 to add current cell to current longest path).\\nfor example:\\n[\\n  [9,9,4],\\n  [6,6,8],\\n  [2,1,1]\\n]\\n\\n1. sort all the values: [9,9,8,6,6,4,2,1,1]\\n2. calculate for each cell the longest current path which will start from this cell:\\n\\n[**9**,9,8,6,6,4,2,1,1]\\n\\t \\n  [**1**,0,0],\\n  [0,0,0],\\n  [0,0,0]\\n\\n [9,**9**,8,6,6,4,2,1,1]\\n\\n[1,**1**,0], (getting max from cells only with values bigger than current)\\n  [0,0,0],\\n  [0,0,0]\\n  \\n [9,9,**8**,6,6,4,2,1,1]\\n\\n[1,1,0], \\n  [0,0,**1**],\\n  [0,0,0]  \\n  \\n   [9,9,8,**6**,6,4,2,1,1]\\n\\n[1,1,0], \\n  [0,**2**,1], (neighbouring cell contains 8 that is >6)\\n  [0,0,0] \\n \\n [9,9,8,6,**6**,4,2,1,1]\\n\\n[1,1,0], \\n  [**2**,2,1], (neighbouring cell contains 9 that is >6)\\n  [0,0,0] \\n  \\n   [9,9,8,6,6,**4**,2,1,1]\\n\\n[1,1,**2**],  (neighbouring cell contains 8 that is >4)\\n  [2,2,1],\\n  [0,0,0] \\n  \\n  \\n [9,9,8,6,6,4,**2**,1,1]\\n\\n[1,1,2],  \\n  [2,2,1],\\n  [**3**,0,0] (neighbouring cell contains 6 that is >2)\\n  \\n[9,9,8,6,6,4,2,**1**,1]\\n\\n[1,1,2],  \\n  [2,2,1],\\n  [3,**4**,0]  (neighbouring cell contains 6 that is >1)\\n  \\n[9,9,8,6,6,4,2,1,**1**]\\n\\n[1,1,2],  \\n  [2,2,1],\\n  [3,4,**2**]  (neighbouring cell contains 8 that is >1)\\n```\\nclass Solution {\\n    public int longestIncreasingPath(int[][] matrix) {\\n        int globalCount = 0;\\n        int n = matrix.length;\\n        if (n==0) return 0;\\n        int m = matrix[0].length;\\n        if (m==0) return 0;\\n        Map<Integer, Integer>map = new HashMap<>();\\n        Integer[]sorted = new Integer[m*n];\\n        Map<Integer,Integer>indices = new HashMap<>();\\n        for (int i=0;i<=m*n-1;i++){\\n            sorted[i]=i;\\n            map.put(i,0);\\n            indices.put(i, matrix[i/m][i%m]);\\n        }\\n        Arrays.sort(sorted, (e1,e2) ->  indices.get(e2)-indices.get(e1));\\n        for (int e: sorted){\\n            int count = 0;\\n            if (e/m>0 && indices.get(e)<indices.get(e-m)) count = Math.max(count, map.get(e-m));\\n            if (e/m<n-1 && indices.get(e)<indices.get(e+m))count = Math.max(count, map.get(e+m));\\n            if (e%m>0 && indices.get(e)<indices.get(e-1))count = Math.max(count, map.get(e-1));\\n            if (e%m<m-1 && indices.get(e)<indices.get(e+1))count = Math.max(count, map.get(e+1));\\n            map.put(e,count+1);\\n            globalCount=Math.max(globalCount, count+1);\\n        }\\n        return globalCount;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestIncreasingPath(int[][] matrix) {\\n        int globalCount = 0;\\n        int n = matrix.length;\\n        if (n==0) return 0;\\n        int m = matrix[0].length;\\n        if (m==0) return 0;\\n        Map<Integer, Integer>map = new HashMap<>();\\n        Integer[]sorted = new Integer[m*n];\\n        Map<Integer,Integer>indices = new HashMap<>();\\n        for (int i=0;i<=m*n-1;i++){\\n            sorted[i]=i;\\n            map.put(i,0);\\n            indices.put(i, matrix[i/m][i%m]);\\n        }\\n        Arrays.sort(sorted, (e1,e2) ->  indices.get(e2)-indices.get(e1));\\n        for (int e: sorted){\\n            int count = 0;\\n            if (e/m>0 && indices.get(e)<indices.get(e-m)) count = Math.max(count, map.get(e-m));\\n            if (e/m<n-1 && indices.get(e)<indices.get(e+m))count = Math.max(count, map.get(e+m));\\n            if (e%m>0 && indices.get(e)<indices.get(e-1))count = Math.max(count, map.get(e-1));\\n            if (e%m<m-1 && indices.get(e)<indices.get(e+1))count = Math.max(count, map.get(e+1));\\n            map.put(e,count+1);\\n            globalCount=Math.max(globalCount, count+1);\\n        }\\n        return globalCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 215342,
                "title": "intuitive-c-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        //If matrix is empty, longest possible path is 0\\n        if(matrix.empty()) return 0;\\n        \\n        //Make a hash matrix to store calculated dfs values for hash[i][j]\\n        //hash is 2D vector of size m x n\\n        int m = matrix.size(), n = matrix[0].size();\\n        vector<vector<int>> hash(m, vector<int>(n, 0));\\n        \\n        //Initialize longest path\\n        int longest = 0;\\n        \\n        //Traverse all points in 2D vector, matrix\\n        //i in range(0, m), j in range(0, n)\\n        //longest will either be itself, or a new longer path starting at matrix[i][j]\\n        //Pass in INT_MIN to dfs calls to ensure all values encountered in matrix are initially larger\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++) longest = max(longest, dfs(matrix, i, j, INT_MIN, hash));\\n        \\n        return longest;\\n    }\\n    \\n    int dfs(const vector<vector<int>>& matrix, int i, int j, int comp, vector<vector<int>>& hash){\\n        //Edge cases. Make sure i (rows) and j (cols) are within boundaries\\n        //If not without boundaries, return zero because no path exists\\n        if(i < 0 || i >= matrix.size() || j < 0 || j >= matrix[0].size()) return 0;\\n        \\n        //if value at matrix[i][j] > comparison value\\n            //Check if we have already calculated a path for i,j in hash[i][j]\\n            //if so return that value, no need to recalculated\\n            //else call dfs on top, bottom, left, and right points of i,j\\n            //store the maximum path in hash[i][j]\\n        if(matrix[i][j] > comp){\\n            if(hash[i][j]) return hash[i][j];\\n            int top   = dfs(matrix, i - 1, j, matrix[i][j], hash) + 1;\\n            int bot   = dfs(matrix, i + 1, j, matrix[i][j], hash) + 1;\\n            int left  = dfs(matrix, i, j - 1, matrix[i][j], hash) + 1;\\n            int right = dfs(matrix, i, j + 1, matrix[i][j], hash) + 1;\\n            hash[i][j] = max(max(top, bot), max(left, right));\\n            return hash[i][j];\\n        }\\n        \\n        //if the value in matrix[i][j] is not greater than comp, path ends, return 0\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        //If matrix is empty, longest possible path is 0\\n        if(matrix.empty()) return 0;\\n        \\n        //Make a hash matrix to store calculated dfs values for hash[i][j]\\n        //hash is 2D vector of size m x n\\n        int m = matrix.size(), n = matrix[0].size();\\n        vector<vector<int>> hash(m, vector<int>(n, 0));\\n        \\n        //Initialize longest path\\n        int longest = 0;\\n        \\n        //Traverse all points in 2D vector, matrix\\n        //i in range(0, m), j in range(0, n)\\n        //longest will either be itself, or a new longer path starting at matrix[i][j]\\n        //Pass in INT_MIN to dfs calls to ensure all values encountered in matrix are initially larger\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++) longest = max(longest, dfs(matrix, i, j, INT_MIN, hash));\\n        \\n        return longest;\\n    }\\n    \\n    int dfs(const vector<vector<int>>& matrix, int i, int j, int comp, vector<vector<int>>& hash){\\n        //Edge cases. Make sure i (rows) and j (cols) are within boundaries\\n        //If not without boundaries, return zero because no path exists\\n        if(i < 0 || i >= matrix.size() || j < 0 || j >= matrix[0].size()) return 0;\\n        \\n        //if value at matrix[i][j] > comparison value\\n            //Check if we have already calculated a path for i,j in hash[i][j]\\n            //if so return that value, no need to recalculated\\n            //else call dfs on top, bottom, left, and right points of i,j\\n            //store the maximum path in hash[i][j]\\n        if(matrix[i][j] > comp){\\n            if(hash[i][j]) return hash[i][j];\\n            int top   = dfs(matrix, i - 1, j, matrix[i][j], hash) + 1;\\n            int bot   = dfs(matrix, i + 1, j, matrix[i][j], hash) + 1;\\n            int left  = dfs(matrix, i, j - 1, matrix[i][j], hash) + 1;\\n            int right = dfs(matrix, i, j + 1, matrix[i][j], hash) + 1;\\n            hash[i][j] = max(max(top, bot), max(left, right));\\n            return hash[i][j];\\n        }\\n        \\n        //if the value in matrix[i][j] is not greater than comp, path ends, return 0\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 146898,
                "title": "python-dp-memorization-solution-beat-99-88",
                "content": "```\\nclass Solution(object):\\n    def longestIncreasingPath(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        memory = [[None]*len(matrix[0]) for i in range(len(matrix))]\\n        res = 0\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                res = max(res,self.helper(i,j,matrix,memory))\\n        return res\\n    \\n    def helper(self,i,j,matrix,memory):\\n        if memory[i][j]:return memory[i][j]\\n        count = 0\\n        if i-1 >= 0 and matrix[i-1][j]>matrix[i][j]:\\n            count = max(count,self.helper(i-1,j,matrix,memory))\\n        if j-1 >= 0 and matrix[i][j-1]>matrix[i][j]:\\n            count = max(count,self.helper(i,j-1,matrix,memory))\\n        if i+1 < len(matrix) and matrix[i+1][j]>matrix[i][j]:\\n            count = max(count,self.helper(i+1,j,matrix,memory))\\n        if j+1 < len(matrix[0]) and matrix[i][j+1]>matrix[i][j]:\\n            count = max(count,self.helper(i,j+1,matrix,memory))    \\n        memory[i][j] = count+1\\n        return count+1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def longestIncreasingPath(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        memory = [[None]*len(matrix[0]) for i in range(len(matrix))]\\n        res = 0\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                res = max(res,self.helper(i,j,matrix,memory))\\n        return res\\n    \\n    def helper(self,i,j,matrix,memory):\\n        if memory[i][j]:return memory[i][j]\\n        count = 0\\n        if i-1 >= 0 and matrix[i-1][j]>matrix[i][j]:\\n            count = max(count,self.helper(i-1,j,matrix,memory))\\n        if j-1 >= 0 and matrix[i][j-1]>matrix[i][j]:\\n            count = max(count,self.helper(i,j-1,matrix,memory))\\n        if i+1 < len(matrix) and matrix[i+1][j]>matrix[i][j]:\\n            count = max(count,self.helper(i+1,j,matrix,memory))\\n        if j+1 < len(matrix[0]) and matrix[i][j+1]>matrix[i][j]:\\n            count = max(count,self.helper(i,j+1,matrix,memory))    \\n        memory[i][j] = count+1\\n        return count+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 129538,
                "title": "bfs-topological-sort",
                "content": "If you think this matrix as a directed graph, this problem will just be a topological sort problem.\\nJust think a directed edge exists between two adjecent numbers when its neighbor\\'s value is greater than itself.\\n\\n```\\n    private static class Point {\\n        int x, y;\\n        public Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n        @Override\\n        public int hashCode() {\\n            return Objects.hash(x, y);\\n        }\\n        @Override\\n        public boolean equals(Object o) {\\n            Point p = (Point)o;\\n            return p != null && p.x == x && p.y == y;\\n        }\\n    }\\n    \\n    public int longestIncreasingPath(int[][] matrix) {\\n        if (matrix.length < 1) return 0;\\n        \\n        Map<Point, Set<Point>> graph = new HashMap<>();\\n        Map<Point, Integer> indegree = new HashMap<>();\\n        for (int i=0; i<matrix.length; i++) {\\n            for (int j=0; j<matrix[i].length; j++) {\\n                Point p = new Point(i, j);\\n                if (i>0 && matrix[i-1][j] > matrix[i][j]) {\\n                    Point next = new Point(i-1, j);\\n                    graph.computeIfAbsent(p, k -> new HashSet<>()).add(next);\\n                    indegree.put(next, indegree.getOrDefault(next, 0)+1);\\n                }\\n                if (j>0 && matrix[i][j-1] > matrix[i][j]) {\\n                    Point next = new Point(i, j-1);\\n                    graph.computeIfAbsent(p, k -> new HashSet<>()).add(next);\\n                    indegree.put(next, indegree.getOrDefault(next, 0)+1);\\n                }\\n                if (i < matrix.length-1 && matrix[i+1][j] > matrix[i][j]) {\\n                    Point next = new Point(i+1, j);\\n                    graph.computeIfAbsent(p, k -> new HashSet<>()).add(next);\\n                    indegree.put(next, indegree.getOrDefault(next, 0)+1);\\n                }\\n                if (j < matrix[i].length-1 && matrix[i][j+1] > matrix[i][j]) {\\n                    Point next = new Point(i, j+1);\\n                    graph.computeIfAbsent(p, k -> new HashSet<>()).add(next);\\n                    indegree.put(next, indegree.getOrDefault(next, 0)+1);\\n                }\\n            }\\n        }\\n        Queue<Object[]> q = new LinkedList<>();\\n        int max = 1;\\n        for (Point p : graph.keySet()) {\\n            if (indegree.getOrDefault(p, 0) == 0) {\\n                q.add(new Object[] { p, 0 });\\n            }\\n        }\\n        while (!q.isEmpty()) {\\n            Object[] obj = q.remove();\\n            Point p = (Point)obj[0];\\n            int pathLen = (int)obj[1];\\n            max = Math.max(max, ++pathLen);\\n            for (Point next : graph.getOrDefault(p, Collections.emptySet())) {\\n                indegree.put(next, indegree.get(next)-1);\\n                if (indegree.get(next) == 0) {\\n                    q.add(new Object[] { next, pathLen });\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n```\\n\\nThe space is O(mn). The worst case is we have a ascending matrix like this\\n\\n1, 2, 3, 4\\n2, 3, 4, 5\\n3, 4, 5, 6\\n\\nSo there are exactly one edge between each adjecent number. And it\\'s easy to understand that there will be no more than one edge between two numbers.\\nTime should be O(mn) too, as we are iterating all the edges exactly one time. ",
                "solutionTags": [],
                "code": "```\\n    private static class Point {\\n        int x, y;\\n        public Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n        @Override\\n        public int hashCode() {\\n            return Objects.hash(x, y);\\n        }\\n        @Override\\n        public boolean equals(Object o) {\\n            Point p = (Point)o;\\n            return p != null && p.x == x && p.y == y;\\n        }\\n    }\\n    \\n    public int longestIncreasingPath(int[][] matrix) {\\n        if (matrix.length < 1) return 0;\\n        \\n        Map<Point, Set<Point>> graph = new HashMap<>();\\n        Map<Point, Integer> indegree = new HashMap<>();\\n        for (int i=0; i<matrix.length; i++) {\\n            for (int j=0; j<matrix[i].length; j++) {\\n                Point p = new Point(i, j);\\n                if (i>0 && matrix[i-1][j] > matrix[i][j]) {\\n                    Point next = new Point(i-1, j);\\n                    graph.computeIfAbsent(p, k -> new HashSet<>()).add(next);\\n                    indegree.put(next, indegree.getOrDefault(next, 0)+1);\\n                }\\n                if (j>0 && matrix[i][j-1] > matrix[i][j]) {\\n                    Point next = new Point(i, j-1);\\n                    graph.computeIfAbsent(p, k -> new HashSet<>()).add(next);\\n                    indegree.put(next, indegree.getOrDefault(next, 0)+1);\\n                }\\n                if (i < matrix.length-1 && matrix[i+1][j] > matrix[i][j]) {\\n                    Point next = new Point(i+1, j);\\n                    graph.computeIfAbsent(p, k -> new HashSet<>()).add(next);\\n                    indegree.put(next, indegree.getOrDefault(next, 0)+1);\\n                }\\n                if (j < matrix[i].length-1 && matrix[i][j+1] > matrix[i][j]) {\\n                    Point next = new Point(i, j+1);\\n                    graph.computeIfAbsent(p, k -> new HashSet<>()).add(next);\\n                    indegree.put(next, indegree.getOrDefault(next, 0)+1);\\n                }\\n            }\\n        }\\n        Queue<Object[]> q = new LinkedList<>();\\n        int max = 1;\\n        for (Point p : graph.keySet()) {\\n            if (indegree.getOrDefault(p, 0) == 0) {\\n                q.add(new Object[] { p, 0 });\\n            }\\n        }\\n        while (!q.isEmpty()) {\\n            Object[] obj = q.remove();\\n            Point p = (Point)obj[0];\\n            int pathLen = (int)obj[1];\\n            max = Math.max(max, ++pathLen);\\n            for (Point next : graph.getOrDefault(p, Collections.emptySet())) {\\n                indegree.put(next, indegree.get(next)-1);\\n                if (indegree.get(next) == 0) {\\n                    q.add(new Object[] { next, pathLen });\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78429,
                "title": "rainbowsecret-clean-c-implementation-with-detailed-explanation",
                "content": "At first, I use the bool-flag-array to record whether the position (i,j) has been visited. But when visited before, I should return the recorded value. When not, I should calculate the 4-direction-value and set the max value to be the value and add 1 to get the result.\\n\\nAlso, we can update the max-value when DFS .\\n\\n\\n    class Solution {\\n    public:\\n        int longestIncreasingPath(vector<vector<int>>& matrix) {\\n            int result=INT_MIN;\\n            int m=matrix.size();\\n            if(m==0)  return 0;\\n            int n=matrix[0].size();\\n            vector<vector<int>> state(m, vector<int>(n, 0));\\n            for(int i=0; i<m; i++){\\n                for(int j=0; j<n; j++){\\n                    if(state[i][j]==0)\\n                        dfs(i,j,matrix,state,result);\\n                }\\n            }\\n            return result;\\n        }\\n        \\n        /*** return the max-len-start-from-cur-position-i-j ***/\\n        int dfs(int i, int j, vector<vector<int>>& matrix, vector<vector<int>>& state, int& result){\\n            if(state[i][j]!=0)  return state[i][j];\\n            \\n            int len1=0, len2=0, len3=0, len4=0;\\n            /*** only-move-forward-when-next-step-value-satisfy-the-condition ***/\\n            if(i+1<state.size()  &&  matrix[i+1][j]>matrix[i][j])  \\n                len1=dfs(i+1, j, matrix, state, result);\\n            if(i-1>=0  &&  matrix[i-1][j]>matrix[i][j])  \\n                len2=dfs(i-1, j, matrix, state, result);\\n            if(j+1<state[0].size()  &&  matrix[i][j+1]>matrix[i][j])  \\n                len3=dfs(i, j+1, matrix, state, result);\\n            if(j-1>=0  &&  matrix[i][j-1]>matrix[i][j])  \\n                len4=dfs(i, j-1, matrix, state, result);\\n            /*** get-the-max-value-start-from-i-j ***/    \\n            state[i][j] =  max(max(max(len1, len2), len3), len4);\\n            state[i][j]++;\\n            /*** update-the-final-value ***/\\n            result=max(result, state[i][j]);\\n            return state[i][j];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int longestIncreasingPath(vector<vector<int>>& matrix) {\\n            int result=INT_MIN;\\n            int m=matrix.size();\\n            if(m==0)  return 0;\\n            int n=matrix[0].size();\\n            vector<vector<int>> state(m, vector<int>(n, 0));\\n            for(int i=0; i<m; i++){\\n                for(int j=0; j<n; j++){\\n                    if(state[i][j]==0)\\n                        dfs(i,j,matrix,state,result);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 78403,
                "title": "java-dfs-dp-with-explanations-o-mn-19ms",
                "content": "Key idea: compute the longest length starting from every index `(i, j)` in the matrix. This can be done by DFS. That is, at location `(i, j)`, we have 4 possible increasing directions, so we check every direction. If one direction satisfies the increasing requirement, increase longest[i][j] by 1. We stop searching when we reach a local maximum. Here, a local maximum refers to the index where none of its four neighbors is less than it. The `helper` function is to compute the longest length starting from `(i, j)`. We store longest[i][j] once it is computed.\\n\\nWe don't know where the ultimate longest length starts from, so we need to check every possible index if it is not already computed, and that's what the `for` loop in the main function is about.\\n\\nAs of time complexity, we check every index only once, so time complexity is `O(mn)`.\\n\\nA final little detail, the original matrix is expanded so that we don't need to consider all kinds of boundary issues. If original matrix is\\n\\n    *  *  *  *\\n    *  *  *  *\\n    *  *  *  *\\nThe extended matrix would be like follows:\\n\\n    0  \\u221e  \\u221e  \\u221e  \\u221e  0\\n    \\u221e  *  *  *  *  \\u221e\\n    \\u221e  *  *  *  *  \\u221e\\n    \\u221e  *  *  *  *  \\u221e\\n    0  \\u221e  \\u221e  \\u221e  \\u221e  0\\nIdeally the four corners should be \\u221e but since it does not matter (it is not reachable in the code), I will leave it as is. Thanks to @dietpepsi for pointing out the mistake in my previous extended matrix\\n\\n\\tpublic int longestIncreasingPath(int[][] matrix) {\\n\\t    int rows = matrix.length;\\n\\t    if(rows<1) return 0;\\n\\t    int cols = matrix[0].length;\\n\\t    int[][] matrixExt = new int[rows+2][cols+2], longest = new int[rows+2][cols+2]; // extended matrix and result matrix\\n\\t    for(int i=1; i<rows+1; i++) {\\n\\t        matrixExt[i][0] = matrixExt[i][cols+1] = 0x7fffffff;\\n\\t        for(int j=1; j<cols+1; j++) {\\n\\t        \\tmatrixExt[0][j] = matrixExt[rows+1][j] = 0x7fffffff;\\n\\t            matrixExt[i][j] = matrix[i-1][j-1];\\n\\t        }\\n\\t    }\\n\\n\\t    int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // 4 different directions\\n\\t    int max = 1;\\n\\t    for(int i=1; i<rows+1; i++) {\\n\\t        for(int j=1; j<cols+1; j++) {\\n\\t            int temp = helper(matrixExt, longest, dirs, rows, cols, i, j);\\n\\t            max = temp > max ? temp : max;\\n\\t        }\\n\\t    }\\n\\t    return max;\\n\\t}\\n\\n\\tprivate int helper(int[][] matrix, int[][] longest, int[][] dirs, int rows, int cols, int i, int j) {\\n\\t    if(longest[i][j]>0) return longest[i][j]; // reuse\\n\\t    int max = 1; // result\\n\\t    for(int[] d : dirs) {\\n\\t        if(matrix[i][j] > matrix[i+d[0]][j+d[1]]) {\\n\\t            int temp = helper(matrix, longest, dirs, rows, cols, i+d[0], j+d[1]) + 1; // recursively update longest[i][j]\\n\\t            max = temp > max ? temp : max;\\n\\t        }\\n\\t    }\\n\\t    longest[i][j] = max; // store for reuse\\n\\t    return max;\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "Key idea: compute the longest length starting from every index `(i, j)` in the matrix. This can be done by DFS. That is, at location `(i, j)`, we have 4 possible increasing directions, so we check every direction. If one direction satisfies the increasing requirement, increase longest[i][j] by 1. We stop searching when we reach a local maximum. Here, a local maximum refers to the index where none of its four neighbors is less than it. The `helper` function is to compute the longest length starting from `(i, j)`. We store longest[i][j] once it is computed.\\n\\nWe don't know where the ultimate longest length starts from, so we need to check every possible index if it is not already computed, and that's what the `for` loop in the main function is about.\\n\\nAs of time complexity, we check every index only once, so time complexity is `O(mn)`.\\n\\nA final little detail, the original matrix is expanded so that we don't need to consider all kinds of boundary issues. If original matrix is\\n\\n    *  *  *  *\\n    *  *  *  *\\n    *  *  *  *\\nThe extended matrix would be like follows:\\n\\n    0  \\u221e  \\u221e  \\u221e  \\u221e  0\\n    \\u221e  *  *  *  *  \\u221e\\n    \\u221e  *  *  *  *  \\u221e\\n    \\u221e  *  *  *  *  \\u221e\\n    0  \\u221e  \\u221e  \\u221e  \\u221e  0\\nIdeally the four corners should be \\u221e but since it does not matter (it is not reachable in the code), I will leave it as is. Thanks to @dietpepsi for pointing out the mistake in my previous extended matrix\\n\\n\\tpublic int longestIncreasingPath(int[][] matrix) {\\n\\t    int rows = matrix.length;\\n\\t    if(rows<1) return 0;\\n\\t    int cols = matrix[0].length;\\n\\t    int[][] matrixExt = new int[rows+2][cols+2], longest = new int[rows+2][cols+2]; // extended matrix and result matrix\\n\\t    for(int i=1; i<rows+1; i++) {\\n\\t        matrixExt[i][0] = matrixExt[i][cols+1] = 0x7fffffff;\\n\\t        for(int j=1; j<cols+1; j++) {\\n\\t        \\tmatrixExt[0][j] = matrixExt[rows+1][j] = 0x7fffffff;\\n\\t            matrixExt[i][j] = matrix[i-1][j-1];\\n\\t        }\\n\\t    }\\n\\n\\t    int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // 4 different directions\\n\\t    int max = 1;\\n\\t    for(int i=1; i<rows+1; i++) {\\n\\t        for(int j=1; j<cols+1; j++) {\\n\\t            int temp = helper(matrixExt, longest, dirs, rows, cols, i, j);\\n\\t            max = temp > max ? temp : max;\\n\\t        }\\n\\t    }\\n\\t    return max;\\n\\t}\\n\\n\\tprivate int helper(int[][] matrix, int[][] longest, int[][] dirs, int rows, int cols, int i, int j) {\\n\\t    if(longest[i][j]>0) return longest[i][j]; // reuse\\n\\t    int max = 1; // result\\n\\t    for(int[] d : dirs) {\\n\\t        if(matrix[i][j] > matrix[i+d[0]][j+d[1]]) {\\n\\t            int temp = helper(matrix, longest, dirs, rows, cols, i+d[0], j+d[1]) + 1; // recursively update longest[i][j]\\n\\t            max = temp > max ? temp : max;\\n\\t        }\\n\\t    }\\n\\t    longest[i][j] = max; // store for reuse\\n\\t    return max;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 78357,
                "title": "an-o-nm-dp-solution-with-explanations",
                "content": "A critical observation that the length of the longest increasing path must be finite, i.e., the path cannot be a cycle. This observation encourages us to design a concise DP solution.\\n\\nLet `dp[i][j]` indicate the maximum length of all possible increasing path starting from position (i, j). Then we have the following recurrence.\\n\\n 1. `dp[i][j] = 1`, if `matrix[i][j]`is greater than any of its\\n    neighbors.\\n 2. `dp[i][j] = 1 + max(dp[x][y])`, where (x, y) is any direct neighbor\\n    of (i, j) satisfying `matrix[i][j] < matrix[x][y]`. This simply means that\\n    we try to move one step forward, and among at most four possible\\n    longest subpaths, we choose the longest one.\\n\\nThe final answer is `max(dp[i][j])`. This DP approach clearly requires both O(nm) time and space, where `n` and `m` are the two dimensions of the given matrix.\\n\\n\\n\\n\\n    // Java Code\\n    public class Solution {\\n        int[] dx = {0, 0, 1, -1};\\n        int[] dy = {1, -1, 0, 0};\\n        int[][] f;\\n        \\n        int dp(int[][] a, int i, int j) {\\n            if (f[i][j] > 0) return f[i][j]; // f[i][j] has been computed already.\\n            f[i][j] = 1; // also works for base cases.\\n            for (int k=0; k<4; k++) {\\n                int x = i + dx[k], y = j + dy[k];\\n                if (x >= 0 && x < a.length && y >= 0 && y < a[0].length && a[i][j] < a[x][y])\\n                    f[i][j] = Math.max(f[i][j], 1 + dp(a, x, y));\\n            }\\n            return f[i][j];\\n        }\\n        \\n        public int longestIncreasingPath(int[][] matrix) {\\n            if (matrix.length == 0 || matrix[0].length == 0) return 0;\\n            f = new int[matrix.length][matrix[0].length];\\n            int ans = 0;\\n            for (int i=0; i<matrix.length; i++)\\n                for (int j=0; j<matrix[0].length; j++)\\n                    ans = Math.max(ans, dp(matrix, i, j));\\n            return ans;\\n        }\\n    }\\n\\nRemark. The code above is a top-down implementation. One can also implement it in a bottom-up manner. However, unlike many common DP problems, it requires a topological sort to determine the correct order to compute, i.e., when we try to compute `dp[i][j]`, all the `dp[x][y]`'s must be computed already. The topological sort can be done by a simple BFS or DFS (though we can already solve this problem by a DFS/BFS). Alternatively, one can achieve a correct topological order by simply sorting all the indices (i, j) in non-increasing order where `(i1, j1)` < `(i2, j2)` if and only if `matrix[i1][j1]` < `matrix[i2][j2]`. This idea is in some sense cute but costs an additional log(nm) factor due to sorting.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n        int[] dx = {0, 0, 1, -1}",
                "codeTag": "Java"
            },
            {
                "id": 3680727,
                "title": "short-and-concise-easy-code-in-c",
                "content": "# Intuition\\n- We can break down the problem into **smaller subproblems**, where each subproblem represents the length of the longest increasing path starting from a specific cell.\\n- By using **memoization**, we can store the results of subproblems in a memoization array (dp) to avoid recomputing them.\\n- Applying **dynamic programming** with memoization ensures that each subproblem is solved only once, leading to an efficient solution.\\n\\n\\n---\\n\\n\\n# Approach\\n- Create a **recursive function**, **solve**, to **explore all possible** **paths** starting from each cell.\\n- The **solve** function takes the **current position (i, j)**, the **previous value**, and **returns the length of the longest increasing path** **starting from that cell**.\\n- Check if the current cell is **out of bounds** or if its **value is less than or equal to the previous value**. If so, **return 0**.\\n- If the length of the path from the **current cell (i, j) has already been computed** and stored in the dp array, **return that value**.\\n- Otherwise, calculate the length of the path by **recursively exploring the neighboring cells** in all four directions, passing the **current cell\\'s value as the previous value**.\\n- **Update the dp array** with the computed path length and **return it**.\\n<!-- Describe your approach to solving the problem. -->\\n\\n---\\n\\n\\n# Complexity\\n- **Time complexity**:\\nThe time complexity of the code is **O(m * n)**, where m and n are the dimensions of the matrix. We explore each cell of the matrix once, and the recursive function solve takes constant time for each cell.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity**:\\nThe space complexity is **O(m * n)** as well. We use the dp array of the same size as the matrix to store the computed path lengths for each cell.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[200][200]={};\\n    int m,n,ans=1;\\n\\n    int solve(vector<vector<int>>& matrix,int i,int j, int prev){\\n        if(i<0 || i>=m || j<0 || j>=n || matrix[i][j]<=prev)return 0;\\n        if(dp[i][j])return dp[i][j];\\n        return dp[i][j]=1+max({\\n            solve(matrix,i+1,j,matrix[i][j]),\\n            solve(matrix,i,j+1,matrix[i][j]),\\n            solve(matrix,i-1,j,matrix[i][j]),\\n            solve(matrix,i,j-1,matrix[i][j])\\n        });\\n    }\\n\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        m=matrix.size(),n=matrix[0].size();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                ans=max(ans,solve(matrix,i,j,-1));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[200][200]={};\\n    int m,n,ans=1;\\n\\n    int solve(vector<vector<int>>& matrix,int i,int j, int prev){\\n        if(i<0 || i>=m || j<0 || j>=n || matrix[i][j]<=prev)return 0;\\n        if(dp[i][j])return dp[i][j];\\n        return dp[i][j]=1+max({\\n            solve(matrix,i+1,j,matrix[i][j]),\\n            solve(matrix,i,j+1,matrix[i][j]),\\n            solve(matrix,i-1,j,matrix[i][j]),\\n            solve(matrix,i,j-1,matrix[i][j])\\n        });\\n    }\\n\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        m=matrix.size(),n=matrix[0].size();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                ans=max(ans,solve(matrix,i,j,-1));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475883,
                "title": "java-solution-for-longest-increasing-path-in-a-matrix-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is that for each cell in the matrix, we can start a DFS search to find the longest increasing path that starts from that cell. We use memoization to store the results of the subproblems, so that we don\\'t need to repeat the computation for a cell that has already been visited.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is to iterate over all cells in the matrix, and for each cell, start a DFS search to find the longest increasing path that starts from that cell. We keep track of the longest path found so far and return it at the end.\\n\\nIn the DFS function, we try to explore all possible directions (up, down, left, right) from the current cell. If a neighbor cell has a greater value than the current cell, we recursively call the DFS function on that neighbor cell. We use memoization to store the result of the subproblem, which is the length of the longest increasing path that starts from the current cell.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m*n), where m is the number of rows and n is the number of columns in the matrix. This is because we visit each cell in the matrix exactly once. The DFS function takes O(1) time for each cell that has already been visited (because we can look up the result from the memoization table), and O(k) time for each unvisited neighbor cell, where k is the number of neighbors (which is a constant 4 in this case).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n O(m*n), because we need to store the memoization table.\\n\\n# Code\\n```\\nclass Solution {\\n    int[] dx = {-1, 1, 0, 0};\\n    int[] dy = {0, 0, -1, 1};\\n    public int longestIncreasingPath(int[][] matrix) {\\n        if(matrix==null||matrix.length==0||matrix[0].length==0)\\n            return 0;\\n        int[][] mem = new int[matrix.length][matrix[0].length];\\n        int longest=0;\\n        for(int i=0; i<matrix.length; i++)\\n        {\\n            for(int j=0; j<matrix[0].length; j++)\\n            {\\n                longest = Math.max(longest, dfs(matrix, i, j, mem));\\n            }\\n        }\\n        return longest;\\n    }\\n    public int dfs(int[][] matrix, int i, int j, int[][] mem)\\n    {\\n        if(mem[i][j]!=0)\\n            return mem[i][j];\\n        for(int m=0; m<4; m++)\\n        {\\n            int x = i+dx[m];\\n            int y = j+dy[m];\\n            if(x>=0&&y>=0&&x<matrix.length&&y<matrix[0].length&&matrix[x][y]>matrix[i][j])\\n            {\\n                mem[i][j]=Math.max(mem[i][j], dfs(matrix, x, y, mem));\\n            }\\n        }\\n        return ++mem[i][j];\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[] dx = {-1, 1, 0, 0};\\n    int[] dy = {0, 0, -1, 1};\\n    public int longestIncreasingPath(int[][] matrix) {\\n        if(matrix==null||matrix.length==0||matrix[0].length==0)\\n            return 0;\\n        int[][] mem = new int[matrix.length][matrix[0].length];\\n        int longest=0;\\n        for(int i=0; i<matrix.length; i++)\\n        {\\n            for(int j=0; j<matrix[0].length; j++)\\n            {\\n                longest = Math.max(longest, dfs(matrix, i, j, mem));\\n            }\\n        }\\n        return longest;\\n    }\\n    public int dfs(int[][] matrix, int i, int j, int[][] mem)\\n    {\\n        if(mem[i][j]!=0)\\n            return mem[i][j];\\n        for(int m=0; m<4; m++)\\n        {\\n            int x = i+dx[m];\\n            int y = j+dy[m];\\n            if(x>=0&&y>=0&&x<matrix.length&&y<matrix[0].length&&matrix[x][y]>matrix[i][j])\\n            {\\n                mem[i][j]=Math.max(mem[i][j], dfs(matrix, x, y, mem));\\n            }\\n        }\\n        return ++mem[i][j];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381341,
                "title": "easy-toposort-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // toposort \\n    // assuming directed edge from larger to smaller \\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n=matrix.size(),m=matrix[0].size();\\n        vector<vector<int>> indegree(n,vector<int> (m,0));\\n        \\n        vector<int> dr={-1,0,1,0},dc={0,1,0,-1};\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n              for(int k=0;k<4;k++)\\n              {\\n                  int nr=i+dr[k],nc=j+dc[k];\\n                  if(nr<n&&nr>=0&&nc<m&&nc>=0&&matrix[nr][nc]<matrix[i][j])\\n                  indegree[nr][nc]++;\\n              }\\n            }\\n        }\\n        queue<vector<int>> q;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(indegree[i][j]==0)\\n                q.push({i,j,1});\\n            }\\n        }\\n        int ans=0;\\n        while(!q.empty())\\n        {\\n          int r=q.front()[0],c=q.front()[1];\\n          ans=q.front()[2];\\n          q.pop();\\n          // relax the edges \\n          for(int i=0;i<4;i++)\\n          {\\n            int nr=r+dr[i],nc=c+dc[i];\\n            if(nr<n&&nr>=0&&nc<m&&nc>=0&&matrix[nr][nc]<matrix[r][c])\\n            {\\n                indegree[nr][nc]--;\\n                if(indegree[nr][nc]==0)\\n                q.push({nr,nc,ans+1});\\n            }\\n          }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // toposort \\n    // assuming directed edge from larger to smaller \\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n=matrix.size(),m=matrix[0].size();\\n        vector<vector<int>> indegree(n,vector<int> (m,0));\\n        \\n        vector<int> dr={-1,0,1,0},dc={0,1,0,-1};\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n              for(int k=0;k<4;k++)\\n              {\\n                  int nr=i+dr[k],nc=j+dc[k];\\n                  if(nr<n&&nr>=0&&nc<m&&nc>=0&&matrix[nr][nc]<matrix[i][j])\\n                  indegree[nr][nc]++;\\n              }\\n            }\\n        }\\n        queue<vector<int>> q;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(indegree[i][j]==0)\\n                q.push({i,j,1});\\n            }\\n        }\\n        int ans=0;\\n        while(!q.empty())\\n        {\\n          int r=q.front()[0],c=q.front()[1];\\n          ans=q.front()[2];\\n          q.pop();\\n          // relax the edges \\n          for(int i=0;i<4;i++)\\n          {\\n            int nr=r+dr[i],nc=c+dc[i];\\n            if(nr<n&&nr>=0&&nc<m&&nc>=0&&matrix[nr][nc]<matrix[r][c])\\n            {\\n                indegree[nr][nc]--;\\n                if(indegree[nr][nc]==0)\\n                q.push({nr,nc,ans+1});\\n            }\\n          }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350349,
                "title": "c-dp-recursion-short-sweet-easy-to-understand",
                "content": "````\\nclass Solution {\\npublic:\\n    int solve(int i,int j,int &m,int &n,vector<vector<int>> &dp,vector<vector<int>> &v){\\n        if(i<0||j<0||i>=m||j>=n)return 0;\\n        if(dp[i][j] != -1)return dp[i][j];\\n        int a = 0,b = 0,c = 0,d = 0;\\n        if(i+1<m&&v[i][j]>v[i+1][j]){\\n            a = solve(i+1,j,m,n,dp,v);\\n        }\\n        if(j+1<n&&v[i][j]>v[i][j+1]){\\n            b = solve(i,j+1,m,n,dp,v);\\n        }\\n        if(i-1>=0&&v[i][j]>v[i-1][j]){\\n            c = solve(i-1,j,m,n,dp,v);\\n        }\\n        if(j-1>=0&&v[i][j]>v[i][j-1]){\\n            d = solve(i,j-1,m,n,dp,v);\\n        }\\n        return dp[i][j] = max({a,b,c,d})+1;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& v) {\\n        int i,j,m=v.size(),n=v[0].size(),ans = 1;\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                if(dp[i][j]==-1){\\n                    ans=max(ans,solve(i,j,m,n,dp,v));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int solve(int i,int j,int &m,int &n,vector<vector<int>> &dp,vector<vector<int>> &v){\\n        if(i<0||j<0||i>=m||j>=n)return 0;\\n        if(dp[i][j] != -1)return dp[i][j];\\n        int a = 0,b = 0,c = 0,d = 0;\\n        if(i+1<m&&v[i][j]>v[i+1][j]){\\n            a = solve(i+1,j,m,n,dp,v);\\n        }\\n        if(j+1<n&&v[i][j]>v[i][j+1]){\\n            b = solve(i,j+1,m,n,dp,v);\\n        }\\n        if(i-1>=0&&v[i][j]>v[i-1][j]){\\n            c = solve(i-1,j,m,n,dp,v);\\n        }\\n        if(j-1>=0&&v[i][j]>v[i][j-1]){\\n            d = solve(i,j-1,m,n,dp,v);\\n        }\\n        return dp[i][j] = max({a,b,c,d})+1;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& v) {\\n        int i,j,m=v.size(),n=v[0].size(),ans = 1;\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                if(dp[i][j]==-1){\\n                    ans=max(ans,solve(i,j,m,n,dp,v));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319234,
                "title": "2-solutions-greedy-dp-dfs-c",
                "content": "# Greedy + DP\\n```\\nclass Solution {\\npublic:\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n = matrix.size(), m = matrix[0].size(), ans = 0;\\n        priority_queue<pair<int, pair<int, int>>> pq;\\n\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) pq.push({matrix[i][j], {i, j}});\\n        }\\n\\n        vector<vector<int>> dp(n, vector<int>(m));\\n        vector<int> dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1};\\n\\n        while(pq.size()) {\\n            int i = pq.top().second. first, j = pq.top().second.second, mx = 0;\\n            pq.pop();\\n            \\n            for(int k=0; k<4; k++) {\\n                int x = i + dx[k], y = j + dy[k];\\n                if(x >= 0 && x < n && y >= 0 && y < m && matrix[x][y] > matrix[i][j]) {\\n                    mx = max(mx, dp[x][y]);\\n                }\\n            }\\n            dp[i][j] = 1 + mx;\\n            ans = max(ans, dp[i][j]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# DFS\\n```\\nclass Solution {\\n    vector<int> dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1};\\n    int dfs(int i, int j, int n, int m, vector<vector<int>> &matrix, vector<vector<int>> &dp) {\\n        int mx = 0;\\n        for(int k=0; k<4; k++) {\\n            int x = i + dx[k], y = j + dy[k];\\n            if(x >= 0 && x < n && y >= 0 && y < m && matrix[x][y] > matrix[i][j]) {\\n                if(dp[x][y]) mx = max(mx, dp[x][y]);\\n                else mx = max(mx, dfs(x, y, n, m, matrix, dp));\\n            }\\n        }\\n        return dp[i][j] = 1 + mx;\\n    }\\npublic:\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n = matrix.size(), m = matrix[0].size(), ans = 0;\\n        vector<vector<int>> dp(n, vector<int>(m));\\n\\n       for(int i=0; i<n; i++) {\\n           for(int j=0; j<m; j++) {\\n               ans = max(ans, dfs(i, j, n, m, matrix, dp));\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy",
                    "Depth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n = matrix.size(), m = matrix[0].size(), ans = 0;\\n        priority_queue<pair<int, pair<int, int>>> pq;\\n\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) pq.push({matrix[i][j], {i, j}});\\n        }\\n\\n        vector<vector<int>> dp(n, vector<int>(m));\\n        vector<int> dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1};\\n\\n        while(pq.size()) {\\n            int i = pq.top().second. first, j = pq.top().second.second, mx = 0;\\n            pq.pop();\\n            \\n            for(int k=0; k<4; k++) {\\n                int x = i + dx[k], y = j + dy[k];\\n                if(x >= 0 && x < n && y >= 0 && y < m && matrix[x][y] > matrix[i][j]) {\\n                    mx = max(mx, dp[x][y]);\\n                }\\n            }\\n            dp[i][j] = 1 + mx;\\n            ans = max(ans, dp[i][j]);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    vector<int> dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1};\\n    int dfs(int i, int j, int n, int m, vector<vector<int>> &matrix, vector<vector<int>> &dp) {\\n        int mx = 0;\\n        for(int k=0; k<4; k++) {\\n            int x = i + dx[k], y = j + dy[k];\\n            if(x >= 0 && x < n && y >= 0 && y < m && matrix[x][y] > matrix[i][j]) {\\n                if(dp[x][y]) mx = max(mx, dp[x][y]);\\n                else mx = max(mx, dfs(x, y, n, m, matrix, dp));\\n            }\\n        }\\n        return dp[i][j] = 1 + mx;\\n    }\\npublic:\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n = matrix.size(), m = matrix[0].size(), ans = 0;\\n        vector<vector<int>> dp(n, vector<int>(m));\\n\\n       for(int i=0; i<n; i++) {\\n           for(int j=0; j<m; j++) {\\n               ans = max(ans, dfs(i, j, n, m, matrix, dp));\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2883675,
                "title": "easy-to-understand-c-code-2d-dp-dfs-memoization-graph",
                "content": "# Intuition\\nThe simplest brute-force approach will be to go to every node start from that node and go in every possible direction which has the greater valued node and find the maximum among all (i.e. up, down, right and left).\\nNote that while going through every direction the already visited node will never be visited again since we are going in increasing directions only so the nodes that we left behind are bound to have lesser value then the currently visiting node.\\nThat\\'s not so bad idea at first look but there might be many repeated calculations which can make time comlexity go worse. with simple aptitude we can understand that going through all nodes and getting the largest increasing path will have exponential time complexity.\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNot so good idea playing with exponential time complexity hense dynamic programing approach comes to our rescue. here we keep storing the length of the largest path we find starting from node (i, j) where 0 <= i < n and 0 <= j < m.\\nThe following Code is the top-down approach for the same intuition check comments on the code to understand the methodology further.\\n\\n# Complexity\\n- Time complexity: $$O(nm)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(nm)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // 2d DP || TOP-DOWN || DFS || Easy to understand solution.\\n    int helper(vector<vector<int>>& matrix, vector<vector<int>> &dp, int n, int m, int i, int j) {\\n        // Boundry condition\\n        if(i < 0 or j < 0 or i >= n or j>=m)\\n            return 0;\\n\\n        // Return the value if already memoized\\n        if(dp[i][j] != -1) {\\n            return dp[i][j];\\n        }\\n        // get longest increasing path length from all the neigbours \\n        int up = (i-1 >= 0 and matrix[i-1][j] > matrix[i][j])?helper(matrix, dp, n, m, i-1, j):0;\\n        int dn = (i+1 < n and matrix[i+1][j] > matrix[i][j])?helper(matrix, dp, n, m, i+1, j):0;\\n        int lf = (j-1 >= 0 and matrix[i][j-1] > matrix[i][j])?helper(matrix, dp, n, m, i, j-1):0;\\n        int rt = (j+1 < m and matrix[i][j+1] > matrix[i][j])?helper(matrix, dp, n, m, i, j+1):0;\\n        // The largest among all 4 will determine the longest increasing path length of current node.\\n        // note that overlaping of path with itself (i.e. one node calculated twice while proceeding)\\n        // is not possible here since it is increasing path and once we go further all the privious nodes are bound to have the lesser value then the current node hense the overlapping is out of the question.\\n        return dp[i][j] = max({up, dn, lf, rt})+1;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n = matrix.size(), m = matrix[0].size();\\n        // contains information of Longest Increasing Path starting from node i, j;\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n        int mx = 0;\\n\\n        // Find node from which Longest Increasing Path of the given matrix starts starts.\\n        for(int i=0; i<n; i++) {\\n            for(int j = 0; j<m; j++) {\\n                mx = max(mx, helper(matrix, dp, n, m, i, j));\\n            }\\n        }\\n        return mx;\\n    }\\n\\n    // Up-vote if you find this solution help-ful\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Graph",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // 2d DP || TOP-DOWN || DFS || Easy to understand solution.\\n    int helper(vector<vector<int>>& matrix, vector<vector<int>> &dp, int n, int m, int i, int j) {\\n        // Boundry condition\\n        if(i < 0 or j < 0 or i >= n or j>=m)\\n            return 0;\\n\\n        // Return the value if already memoized\\n        if(dp[i][j] != -1) {\\n            return dp[i][j];\\n        }\\n        // get longest increasing path length from all the neigbours \\n        int up = (i-1 >= 0 and matrix[i-1][j] > matrix[i][j])?helper(matrix, dp, n, m, i-1, j):0;\\n        int dn = (i+1 < n and matrix[i+1][j] > matrix[i][j])?helper(matrix, dp, n, m, i+1, j):0;\\n        int lf = (j-1 >= 0 and matrix[i][j-1] > matrix[i][j])?helper(matrix, dp, n, m, i, j-1):0;\\n        int rt = (j+1 < m and matrix[i][j+1] > matrix[i][j])?helper(matrix, dp, n, m, i, j+1):0;\\n        // The largest among all 4 will determine the longest increasing path length of current node.\\n        // note that overlaping of path with itself (i.e. one node calculated twice while proceeding)\\n        // is not possible here since it is increasing path and once we go further all the privious nodes are bound to have the lesser value then the current node hense the overlapping is out of the question.\\n        return dp[i][j] = max({up, dn, lf, rt})+1;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n = matrix.size(), m = matrix[0].size();\\n        // contains information of Longest Increasing Path starting from node i, j;\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n        int mx = 0;\\n\\n        // Find node from which Longest Increasing Path of the given matrix starts starts.\\n        for(int i=0; i<n; i++) {\\n            for(int j = 0; j<m; j++) {\\n                mx = max(mx, helper(matrix, dp, n, m, i, j));\\n            }\\n        }\\n        return mx;\\n    }\\n\\n    // Up-vote if you find this solution help-ful\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2866919,
                "title": "dfs-90-faster-easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    int dfs(vector<vector<int>> &mat, int i, int j, int pre) {\\n        if (i < 0 || j < 0 || i == mat.size() || j == mat[0].size() || pre >= mat[i][j])\\n            return 0;\\n        if (dp[i][j]) return dp[i][j];\\n        int l = dfs(mat, i, j - 1, mat[i][j]);\\n        int r = dfs(mat, i, j + 1, mat[i][j]);\\n        int u = dfs(mat, i - 1, j, mat[i][j]);\\n        int d = dfs(mat, i + 1, j, mat[i][j]);\\n        return dp[i][j] = max({l, r, u, d}) + 1;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int maxVal = 0;\\n        for (int i = 0; i < matrix.size(); i++)\\n            for (int j = 0; j < matrix[i].size(); j++)\\n                maxVal = max(maxVal, dfs(matrix, i, j, -1));\\n        return maxVal;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    int dfs(vector<vector<int>> &mat, int i, int j, int pre) {\\n        if (i < 0 || j < 0 || i == mat.size() || j == mat[0].size() || pre >= mat[i][j])\\n            return 0;\\n        if (dp[i][j]) return dp[i][j];\\n        int l = dfs(mat, i, j - 1, mat[i][j]);\\n        int r = dfs(mat, i, j + 1, mat[i][j]);\\n        int u = dfs(mat, i - 1, j, mat[i][j]);\\n        int d = dfs(mat, i + 1, j, mat[i][j]);\\n        return dp[i][j] = max({l, r, u, d}) + 1;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int maxVal = 0;\\n        for (int i = 0; i < matrix.size(); i++)\\n            for (int j = 0; j < matrix[i].size(); j++)\\n                maxVal = max(maxVal, dfs(matrix, i, j, -1));\\n        return maxVal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725739,
                "title": "c-dfs-dp-beginner-friendly-sol-easy",
                "content": "```\\nclass Solution {\\n    int n,m,ans = 0;\\n    using vvi = vector<vector<int>>;\\n    vector<int>  dx{0,0,1,-1}, dy{1,-1,0,0};\\n    int dfs(int i,int j,vvi& matrix,vvi& dp){\\n        if(dp[i][j]!=1) return dp[i][j];\\n        int mx = 0;\\n        for(int k = 0;k<4;k++){\\n            int x = i + dx[k];\\n            int y = j + dy[k];\\n            if(x<0 || y<0 || y>=m || x>=n)continue;\\n            if(matrix[x][y]<matrix[i][j]) mx = max(mx,dfs(x,y,matrix,dp));\\n        }\\n        return dp[i][j] = mx + 1;\\n    }\\npublic:\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        n = matrix.size(),m = matrix[0].size();\\n        vvi dp(n,vector(m,1));\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<m;j++){\\n                if(dp[i][j]==1) ans = max(ans,dfs(i,j,matrix,dp));\\n            }\\n        } \\n        return ans;\\n    }\\n};\\n\\n```\\n\\n***If you enjoy my sol, please upvote.***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    int n,m,ans = 0;\\n    using vvi = vector<vector<int>>;\\n    vector<int>  dx{0,0,1,-1}, dy{1,-1,0,0};\\n    int dfs(int i,int j,vvi& matrix,vvi& dp){\\n        if(dp[i][j]!=1) return dp[i][j];\\n        int mx = 0;\\n        for(int k = 0;k<4;k++){\\n            int x = i + dx[k];\\n            int y = j + dy[k];\\n            if(x<0 || y<0 || y>=m || x>=n)continue;\\n            if(matrix[x][y]<matrix[i][j]) mx = max(mx,dfs(x,y,matrix,dp));\\n        }\\n        return dp[i][j] = mx + 1;\\n    }\\npublic:\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        n = matrix.size(),m = matrix[0].size();\\n        vvi dp(n,vector(m,1));\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<m;j++){\\n                if(dp[i][j]==1) ans = max(ans,dfs(i,j,matrix,dp));\\n            }\\n        } \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700848,
                "title": "topological-sort-easy-understanding-clean-code-python",
                "content": "```\\n\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        n, m = len(matrix), len(matrix[0])\\n        is_valid = lambda i, j: 0 <= i < n and 0 <= j < m\\n        drn = [(0, 1), (1, 0), (-1, 0), (0, -1)]\\n        outgoing = defaultdict(set)\\n        inDegree = {}\\n        for i in range(n):\\n            for j in range(m):\\n                inDegree[(i, j)] = 0\\n                for i_drn, j_drn in drn:\\n                    new_i, new_j = i+i_drn, j+j_drn\\n                    if is_valid(new_i, new_j):\\n                        if matrix[i][j] > matrix[new_i][new_j]:\\n                            inDegree[(i, j)] += 1\\n                            outgoing[(new_i, new_j)].add((i, j))\\n        \\n        queue = deque()\\n        \\n        for key in inDegree:\\n            if inDegree[key] == 0:\\n                queue.append((key, 1))\\n        ans = 0\\n        while queue:\\n            for _ in range(len(queue)):\\n                current, ln = queue.popleft()\\n                ans = max(ans, ln)\\n                for neigh in outgoing[current]:\\n                    inDegree[neigh] -= 1\\n                    if inDegree[neigh] == 0:\\n                        queue.append((neigh, ln+1))\\n        return ans\\n        \\n\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\n\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        n, m = len(matrix), len(matrix[0])\\n        is_valid = lambda i, j: 0 <= i < n and 0 <= j < m\\n        drn = [(0, 1), (1, 0), (-1, 0), (0, -1)]\\n        outgoing = defaultdict(set)\\n        inDegree = {}\\n        for i in range(n):\\n            for j in range(m):\\n                inDegree[(i, j)] = 0\\n                for i_drn, j_drn in drn:\\n                    new_i, new_j = i+i_drn, j+j_drn\\n                    if is_valid(new_i, new_j):\\n                        if matrix[i][j] > matrix[new_i][new_j]:\\n                            inDegree[(i, j)] += 1\\n                            outgoing[(new_i, new_j)].add((i, j))\\n        \\n        queue = deque()\\n        \\n        for key in inDegree:\\n            if inDegree[key] == 0:\\n                queue.append((key, 1))\\n        ans = 0\\n        while queue:\\n            for _ in range(len(queue)):\\n                current, ln = queue.popleft()\\n                ans = max(ans, ln)\\n                for neigh in outgoing[current]:\\n                    inDegree[neigh] -= 1\\n                    if inDegree[neigh] == 0:\\n                        queue.append((neigh, ln+1))\\n        return ans\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549824,
                "title": "python-dfs-solution",
                "content": "```\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        rows, cols = len(matrix), len(matrix[0])\\n        visited = set()\\n        dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]]\\n        dp = [[-1 for _ in range(cols)] for _ in range(rows)]\\n        \\n        if rows <= 1 and cols <= 1:\\n            return 1\\n        \\n        def invalid(i, j):\\n            return i < 0 or j < 0 or i == rows or j == cols\\n        \\n        def dfs(i, j):\\n            if dp[i][j] != -1: return dp[i][j]\\n            dp[i][j] = 1\\n            for dx, dy in dirs:\\n                r, c = i + dx, j + dy\\n                if not invalid(r, c) and matrix[r][c] > matrix[i][j]:\\n                    dp[i][j] = max(dp[i][j], 1 + dfs(r, c))\\n            \\n            return dp[i][j]\\n        \\n        c = 0\\n        for i in range(rows):\\n            for j in range(cols):\\n                c = max(c, dfs(i, j))\\n        \\n        return c\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        rows, cols = len(matrix), len(matrix[0])\\n        visited = set()\\n        dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]]\\n        dp = [[-1 for _ in range(cols)] for _ in range(rows)]\\n        \\n        if rows <= 1 and cols <= 1:\\n            return 1\\n        \\n        def invalid(i, j):\\n            return i < 0 or j < 0 or i == rows or j == cols\\n        \\n        def dfs(i, j):\\n            if dp[i][j] != -1: return dp[i][j]\\n            dp[i][j] = 1\\n            for dx, dy in dirs:\\n                r, c = i + dx, j + dy\\n                if not invalid(r, c) and matrix[r][c] > matrix[i][j]:\\n                    dp[i][j] = max(dp[i][j], 1 + dfs(r, c))\\n            \\n            return dp[i][j]\\n        \\n        c = 0\\n        for i in range(rows):\\n            for j in range(cols):\\n                c = max(c, dfs(i, j))\\n        \\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2187695,
                "title": "js-visualised-dfs-memoization",
                "content": "# 329. Longest Increasing Path in a Matrix \\uD83D\\uDE80\\n***\\n### Solution Developed In:\\n![JavaScript](https://img.shields.io/badge/javascript-%23323330.svg?style=for-the-badge&logo=javascript&logoColor=%23F7DF1E)\\n\\n## The Question\\nFor this article we will be covering Leetcode\\'s \\'[329. Longest Increasing Path in a Matrix](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/)\\' question. A Dynamic Programming Graph Question.\\n\\n>![Example](https://assets.leetcode.com/users/images/58a1b97f-030c-41c2-a65b-c62799fd2311_1655992705.7585952.gif)\\n\\nQuestion:\\n\\n> Given an ` m x n ` integers `matrix`, return the **length** of the longest increasing path in `matrix`.\\n\\nFrom each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).\\n>![Example](https://assets.leetcode.com/uploads/2021/01/05/grid1.jpg)\\n\\n```\\nInput: matrix = [[9,9,4],[6,6,8],[2,1,1]]\\nOutput: 4\\nExplanation: The longest increasing path is [1, 2, 6, 9].\\n```\\n\\n## Explaining The Question\\nThis Question is rated **Hard**. Which I believe is entirely accurate, so long as you have solid foundations in [Graph Theory](https://en.wikipedia.org/wiki/Graph_theory) and it\\'s applications. As well as ideally being skilled in either [DFS](https://en.wikipedia.org/wiki/Depth-first_search) or [BFS](https://en.wikipedia.org/wiki/Breadth-first_search) algorithms as well as having knowledge in [Topological Sort](https://en.wikipedia.org/wiki/Topological_sorting) you will be able to solve this problem.\\n\\nNow this is a **Dynamic Programming** Question. Which we all love \\uD83D\\uDE09. This question should feel familiar to you if you have solved the [Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/) problem. Because they\\'re similar in pattern. Although, this is a **Dynamic Programming** Question, so of course we need to have everything hyper optimised. Meaning, we\\'re going to have a **Memoization** technique in order to prevent unnecessary calculations (Depth First Search in our case).\\n\\nWhat we have been asked is to find the **longest increasing path** in a matrix. Which is a **Graph Problem**. Where the bi directional edges are the **edges** in the matrix. Up, down, left and right. We need to find that longest path. Which we ultimately want to find by **Depth First Search**. \\n\\n\\n***\\n\\n##  Recommended Knowledge\\n1. [Graph Theory](https://en.wikipedia.org/wiki/Graph_theory#:~:text=In%20mathematics%2C%20graph%20theory%20is,also%20called%20links%20or%20lines)\\n3. [Depth First Search](https://en.wikipedia.org/wiki/Depth-first_search) (Recursive)\\n4. [Memoization](https://en.wikipedia.org/wiki/Memoization)\\n5. [Matrix](https://en.wikipedia.org/wiki/Matrix_(mathematics)) (Cache)\\n6. [Hash Map](https://en.wikipedia.org/wiki/Hash_table)\\n7. [Topological Sort](https://en.wikipedia.org/wiki/Topological_sorting)\\n\\n## What do we know?\\n1. We\\'re given a matrix that is **m x n**.\\n2. This matrix represents a graph.\\n3. We gotta find the longest path in this graph.\\n\\n## How we\\'re going to do it:\\n\\nWe\\'re going to use [Depth First Search](https://en.wikipedia.org/wiki/Depth-first_search) to find the longest path. At each node within the matrix / graph, we will perform a [Depth First Search](https://en.wikipedia.org/wiki/Depth-first_search) to see if we\\'re able to find a longer path. We do this recursively, until we have found the longest possible path from the root node we started from. Here, we use [Topological Sort](https://en.wikipedia.org/wiki/Topological_sorting) to [backtrack](https://en.wikipedia.org/wiki/Backtracking) to the root node, along the way create a [Memoization](https://en.wikipedia.org/wiki/Memoization) cache of the longest possible path from that given node. We do this for every node in the graph. By the end, we know the longest path. \\n\\n**Wow**, what a mouthful. In other words, we use DFS on each node to see how far we can get from that given node. We take this number and see if it\\'s longer than the current longest path. If it is, we update the longest path. We then create a cache of the longest path from that node, so we don\\'t have to redundantly calculate it later on. \\n\\nStill don\\'t understand, check the graphic at the top of the page. It\\'s rather confusing all of this, Dynamic Programming is never simple. You need to know a ton of concepts before attempting Dynamic Programming. \\n\\n1. We\\'re going to firstly create a `max_path_length` variable to store the longest path.\\n2. We\\'re then going to create a `max_path_length_cache` variable to store the longest path from each node. Essentially, it\\'s a mirror of the matrix where instead of the matrix values it\\'s the longest path from that node.\\n3. We then go over each node in the matrix.\\n4. We perform Depth First Search on all of them.\\n5. During the Depth First Search, we ask if we\\'re even allowed to travel to that node.\\n6. If we\\'re allowed to travel to that node, we then ask if we have already visited this node before. By asking the `max_path_length_cache` variable to see if it\\'s already been visited. If it has, we get the value from the cache. If it hasn\\'t, we perform a Depth First Search on that node too.\\n7. Once we have fully exhausted the Depth First Search, we then update the `max_path_length` variable if we have a longer path. This is done as apart of the [Topological Sort](https://en.wikipedia.org/wiki/Topological_sorting) algorithm. Which is confusing words for, \\'Back tracking\\' which is also confusing words for \\'Once I\\'ve done all the possible paths for this node I will do something.\\'\\n\\n## Big O Notation:\\n* Time Complexity:   *O(**V + E**)* / *O(**n**)* | Where ***n*** is the number of nodes in the Matrix. ***V*** is the number of vertices in the graph. ***E*** is the number of edges in the graph as we\\'re going to visit each vertex and each edge once. This is often represented as just **O(*n*)** as it\\'s the number of nodes in the graph. If we didn\\'t use the `max_path_length_cache` variable, we would have achieved a *O(**(V + E) ^ 2**)* time complexity due to the repeated work. \\n* Space Complexity: *O(**n**)* | Where ***n*** is the number of nodes in the `matrix` graph as we will be using a hashmap to keep track of all the nodes we\\'ve already visited. \\n\\n## Leetcode Results:\\n\\n[![LeetCode](https://img.shields.io/badge/LeetCode-000000?style=for-the-badge&logo=LeetCode&logoColor=#d16c06)](https://leetcode.com/submissions/detail/729350278/)\\n\\n\\n***\\n\\n# The Solution\\n\\n<iframe src=\"https://leetcode.com/playground/oHaFNLtV/shared\" width=\"100%\" height=\"600\"></iframe>\\n\\n```\\n/**\\n * @param {number[][]} matrix\\n * @return {number}\\n */\\n var longestIncreasingPath = function (matrix) {\\n\\n    // So this is a really interesting question. \\n    // It combines Dynamic Programming, Backtracking, Memoization,\\n    // and Graph Theory\\n\\n    // The Basic premise of this solution is to perform DFS on each\\n    // node, and keep track of the longest path, caching the results\\n    // along the way. It sounds simple, and it is, but the initial development of this \\n    // solution was far far from it.  \\n\\n    // What we\\'re going to do is reverse the logic, instead of going up nodes greater than \\n    // us, we\\'re only going to do it downwards. Why? Well, larger numbers are going to cover a greater\\n    // area so it populates our cache faster, requiring less stack frames to traverse.\\n\\n    // Our Return Value.\\n    let max_path_length = 0;\\n\\n    // Basic Maxes of the Matrix. Bound checks\\n    const max_rows = matrix.length - 1;\\n    const max_cols = matrix[0].length - 1;\\n\\n    // Our Memoization Array.\\n    // Our Cache, that looks like `node => nodes_max_path_from_here`\\n    // What this mean\\'s is we don\\'t need to check the same node twice.\\n    const max_path_length_cache = new Map();\\n    \\n    // Our Backtracking Function. We will be using Depth First Search\\n    // to traverse the matrix / graph in 4 directions. Asking, \"Can I go here?\"\\n    const depth_first_search = (row_index, col_index, prev) => {\\n\\n        // Is it within bounds?\\n        // Meaning, can we travel to this location. \\n        if (row_index > max_rows || col_index > max_cols || row_index < 0 || col_index < 0) {\\n            return 0;\\n        }\\n\\n        // Our Nodes Current value.\\n        const node_val = matrix[row_index][col_index];\\n\\n        // Is this node greater than the previous node?\\n        // Nope, we only want to waterfall down the graph\\'s values. Throw it out. \\n        if (node_val >= prev) {\\n            return 0;\\n        }\\n\\n        // Have we already explored this node and cached the result?\\n        // If so, just return the cached result. If not, we\\'ll need to explore it.\\n        // and then cache the results from there. \\n        if (!max_path_length_cache.has(`${row_index},${col_index}`)) {\\n\\n            // Explore the node\\'s edges\\n            const top                  = depth_first_search(row_index - 1, col_index, node_val);  // UP\\n            const bottom               = depth_first_search(row_index + 1, col_index, node_val);  // DOWN\\n            const left                 = depth_first_search(row_index, col_index - 1, node_val);  // LEFT\\n            const right                = depth_first_search(row_index, col_index + 1, node_val);  // RIGHT\\n            \\n            // Max Path Sum of this node\\n            const nodes_max_path_value = Math.max(left, right, top, bottom) + 1;\\n\\n            // Cache the results,. We\\'ll need to use this later.\\n            max_path_length_cache.set(`${row_index},${col_index}`, nodes_max_path_value);\\n        }\\n\\n        // Get the cached result.\\n        return max_path_length_cache.get(`${row_index},${col_index}`);\\n    };\\n\\n    // Traverse the matrix.\\n    matrix.forEach((row, row_index) => {\\n        row.forEach((col, col_index) => {\\n            max_path_length = Math.max(depth_first_search(row_index, col_index, Infinity), max_path_length);\\n        });\\n    });\\n     \\n    return max_path_length;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Graph",
                    "Memoization"
                ],
                "code": "```\\nInput: matrix = [[9,9,4],[6,6,8],[2,1,1]]\\nOutput: 4\\nExplanation: The longest increasing path is [1, 2, 6, 9].\\n```\n```\\n/**\\n * @param {number[][]} matrix\\n * @return {number}\\n */\\n var longestIncreasingPath = function (matrix) {\\n\\n    // So this is a really interesting question. \\n    // It combines Dynamic Programming, Backtracking, Memoization,\\n    // and Graph Theory\\n\\n    // The Basic premise of this solution is to perform DFS on each\\n    // node, and keep track of the longest path, caching the results\\n    // along the way. It sounds simple, and it is, but the initial development of this \\n    // solution was far far from it.  \\n\\n    // What we\\'re going to do is reverse the logic, instead of going up nodes greater than \\n    // us, we\\'re only going to do it downwards. Why? Well, larger numbers are going to cover a greater\\n    // area so it populates our cache faster, requiring less stack frames to traverse.\\n\\n    // Our Return Value.\\n    let max_path_length = 0;\\n\\n    // Basic Maxes of the Matrix. Bound checks\\n    const max_rows = matrix.length - 1;\\n    const max_cols = matrix[0].length - 1;\\n\\n    // Our Memoization Array.\\n    // Our Cache, that looks like `node => nodes_max_path_from_here`\\n    // What this mean\\'s is we don\\'t need to check the same node twice.\\n    const max_path_length_cache = new Map();\\n    \\n    // Our Backtracking Function. We will be using Depth First Search\\n    // to traverse the matrix / graph in 4 directions. Asking, \"Can I go here?\"\\n    const depth_first_search = (row_index, col_index, prev) => {\\n\\n        // Is it within bounds?\\n        // Meaning, can we travel to this location. \\n        if (row_index > max_rows || col_index > max_cols || row_index < 0 || col_index < 0) {\\n            return 0;\\n        }\\n\\n        // Our Nodes Current value.\\n        const node_val = matrix[row_index][col_index];\\n\\n        // Is this node greater than the previous node?\\n        // Nope, we only want to waterfall down the graph\\'s values. Throw it out. \\n        if (node_val >= prev) {\\n            return 0;\\n        }\\n\\n        // Have we already explored this node and cached the result?\\n        // If so, just return the cached result. If not, we\\'ll need to explore it.\\n        // and then cache the results from there. \\n        if (!max_path_length_cache.has(`${row_index},${col_index}`)) {\\n\\n            // Explore the node\\'s edges\\n            const top                  = depth_first_search(row_index - 1, col_index, node_val);  // UP\\n            const bottom               = depth_first_search(row_index + 1, col_index, node_val);  // DOWN\\n            const left                 = depth_first_search(row_index, col_index - 1, node_val);  // LEFT\\n            const right                = depth_first_search(row_index, col_index + 1, node_val);  // RIGHT\\n            \\n            // Max Path Sum of this node\\n            const nodes_max_path_value = Math.max(left, right, top, bottom) + 1;\\n\\n            // Cache the results,. We\\'ll need to use this later.\\n            max_path_length_cache.set(`${row_index},${col_index}`, nodes_max_path_value);\\n        }\\n\\n        // Get the cached result.\\n        return max_path_length_cache.get(`${row_index},${col_index}`);\\n    };\\n\\n    // Traverse the matrix.\\n    matrix.forEach((row, row_index) => {\\n        row.forEach((col, col_index) => {\\n            max_path_length = Math.max(depth_first_search(row_index, col_index, Infinity), max_path_length);\\n        });\\n    });\\n     \\n    return max_path_length;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2165003,
                "title": "python-solution-using-memoization",
                "content": "```\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        row = len(matrix); col = len(matrix[0])\\n        res = 0\\n        memo = {}\\n        directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]\\n        \\n        def helper(i, j):\\n            if (i,j) in memo: return memo[(i,j)]\\n            path = 1\\n            for move in directions:\\n                r = i + move[0]\\n                c = j + move[1]\\n                if (0<=r<row and 0<=c<col and\\n                    matrix[r][c] != \\'#\\' and matrix[r][c] > matrix[i][j]):\\n                    \\n                    tmp = matrix[i][j]\\n                    matrix[i][j] = \\'#\\'\\n                    path = max(path, helper(r, c) + 1)\\n                    matrix[i][j] = tmp\\n                    \\n            memo[(i,j)] = path \\n            return memo[(i,j)]\\n        \\n        for i in range(row):\\n            for j in range(col):\\n                res = max(res, helper(i, j))\\n    \\n        return res\\n\\n# Time: O(N^3)\\n# Space: O(N^2)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        row = len(matrix); col = len(matrix[0])\\n        res = 0\\n        memo = {}\\n        directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]\\n        \\n        def helper(i, j):\\n            if (i,j) in memo: return memo[(i,j)]\\n            path = 1\\n            for move in directions:\\n                r = i + move[0]\\n                c = j + move[1]\\n                if (0<=r<row and 0<=c<col and\\n                    matrix[r][c] != \\'#\\' and matrix[r][c] > matrix[i][j]):\\n                    \\n                    tmp = matrix[i][j]\\n                    matrix[i][j] = \\'#\\'\\n                    path = max(path, helper(r, c) + 1)\\n                    matrix[i][j] = tmp\\n                    \\n            memo[(i,j)] = path \\n            return memo[(i,j)]\\n        \\n        for i in range(row):\\n            for j in range(col):\\n                res = max(res, helper(i, j))\\n    \\n        return res\\n\\n# Time: O(N^3)\\n# Space: O(N^2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2053038,
                "title": "c-memoization",
                "content": "class Solution {\\npublic:\\n\\n     int dx[5]={0,-1,0,1,0};\\n    vector<vector<int>>dp;\\n    void dfs(int x,int y,int n,int m,vector<vector<int>>&mat)\\n    {\\n        dp[x][y]=1;\\n        int val=0;\\n        for(int k=0;k<4;k++)\\n        {\\n            int i=x+dx[k],j=y+dx[k+1];\\n            if(i<0||i>=n||j<0||j>=m) continue;\\n            if((mat[i][j]>mat[x][y])&& dp[i][j]==0)\\n            {\\n                dfs(i,j,n,m,mat);\\n            }\\n            if(mat[i][j]>mat[x][y])\\n            val=max(val,dp[i][j]);\\n        }\\n        dp[x][y]+=val;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n=matrix.size(),m=matrix[0].size();\\n        int ans=0;\\n        dp.resize(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(dp[i][j]==0)\\n                {\\n                    dfs(i,j,n,m,matrix);\\n                }\\n                ans=max(ans,dp[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n\\n     int dx[5]={0,-1,0,1,0}",
                "codeTag": "Java"
            },
            {
                "id": 2052698,
                "title": "c-easy-dfs-dp-solution-w-explanation",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint dp[201][201];\\n\\t\\tSolution(){\\n\\t\\t\\tmemset(dp,-1,sizeof(dp));  // initialising with -1\\n\\t\\t}\\n\\t\\tint dfs(int prev,int i,int j,vector<vector<int>>& matrix,int &r,int &c){\\n\\t\\t     //out of bound or invalid move\\n\\t\\t\\t if(i>=r or i<0 or j>=c or j<0 or matrix[i][j]<=prev) return 0; \\n\\t\\t\\t // if already calculated then return it\\n\\t\\t\\t if(dp[i][j]!=-1) return dp[i][j];\\n\\t\\t\\t int left=1,right=1,up=1,down=1;\\n\\t\\t\\t left=dfs(matrix[i][j],i,j-1,matrix,r,c);\\n\\t\\t\\t right=dfs(matrix[i][j],i,j+1,matrix,r,c);\\n\\t\\t\\t up=dfs(matrix[i][j],i-1,j,matrix,r,c);\\n\\t\\t\\t down=dfs(matrix[i][j],i+1,j,matrix,r,c);\\n\\t\\t\\t //store it before returning\\n\\t\\t\\t return dp[i][j]=max({left,right,up,down})+1;\\n\\t\\t}\\n\\t\\tint longestIncreasingPath(vector<vector<int>>& matrix) {\\n\\t\\t\\tint ans=1,r=matrix.size(),c=matrix[0].size();\\n\\t\\t\\tfor(int i=0;i<matrix.size();i++){\\n\\t\\t\\t\\tfor(int j=0;j<matrix[i].size();j++){\\n\\t\\t\\t\\t\\t int temp=dfs(-1,i,j,matrix,r,c);\\n\\t\\t\\t\\t\\t // take maximum of all path from every cell\\n\\t\\t\\t\\t\\tans=max(ans,temp);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\t\\n**WHY DP?**\\t - Try submitting without dp , exploring all path from every cell. It will give TLE because\\n                             for a given cell or element we would be traversing many times.(reduntant calls)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint dp[201][201];\\n\\t\\tSolution(){\\n\\t\\t\\tmemset(dp,-1,sizeof(dp));  // initialising with -1\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2052274,
                "title": "python-dfs-with-memoization-simple-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        rows = len(matrix)\\n        cols = len(matrix[0])\\n        # Each element stores max length of increasing path starting on r,c\\n        dp = [[-1] * cols for _ in range(rows)] \\n        \\n        # Traverse the graph using DFS \\n        def dfs(r,c: int) -> int:\\n            # If we already have results in `dp` - return it  \\n            if dp[r][c] >= 0:\\n                return dp[r][c]\\n            \\n            max_path_len = 0\\n            # Calculate max path length for all neigbours\\n            # Calling dfs function            \\n            for nr, nc in [(r+1, c),(r-1,c),(r,c-1),(r,c+1)]:\\n                if 0<=nr<rows and 0<=nc<cols and matrix[nr][nc] > matrix[r][c]:                    \\n                    max_path_len = max(max_path_len, dfs(nr, nc))\\n            \\n            # Record path length in `dp`\\n            dp[r][c] = max_path_len + 1            \\n            return dp[r][c]\\n        \\n        longest = 0\\n        for r in range(rows):\\n            for c in range(cols):\\n                longest = max(longest, dfs(r,c))\\n        \\n        return longest\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        rows = len(matrix)\\n        cols = len(matrix[0])\\n        # Each element stores max length of increasing path starting on r,c\\n        dp = [[-1] * cols for _ in range(rows)] \\n        \\n        # Traverse the graph using DFS \\n        def dfs(r,c: int) -> int:\\n            # If we already have results in `dp` - return it  \\n            if dp[r][c] >= 0:\\n                return dp[r][c]\\n            \\n            max_path_len = 0\\n            # Calculate max path length for all neigbours\\n            # Calling dfs function            \\n            for nr, nc in [(r+1, c),(r-1,c),(r,c-1),(r,c+1)]:\\n                if 0<=nr<rows and 0<=nc<cols and matrix[nr][nc] > matrix[r][c]:                    \\n                    max_path_len = max(max_path_len, dfs(nr, nc))\\n            \\n            # Record path length in `dp`\\n            dp[r][c] = max_path_len + 1            \\n            return dp[r][c]\\n        \\n        longest = 0\\n        for r in range(rows):\\n            for c in range(cols):\\n                longest = max(longest, dfs(r,c))\\n        \\n        return longest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1870646,
                "title": "c-recursion-memorization-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[200][200];\\n    bool is_valid(int i,int j,vector<vector<int>> &mat){\\n        int m = mat.size(), n = mat[0].size();\\n        if(i >= 0 and j >=0 and i < m and j < n) return true;\\n        return false;\\n    }\\n    int solve(int i,int j,vector<vector<int>> &mat){\\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int op1 = 0,op2 = 0,op3 = 0,op4 = 0;\\n        \\n        if(is_valid(i-1,j,mat) and mat[i-1][j] > mat[i][j])\\n            op1 = solve(i-1,j,mat);\\n        \\n        if(is_valid(i+1,j,mat) and mat[i+1][j] > mat[i][j])\\n            op2 = solve(i+1,j,mat);\\n        \\n        if(is_valid(i,j-1,mat) and mat[i][j-1] > mat[i][j])\\n            op3 = solve(i,j-1,mat);\\n        \\n        if(is_valid(i,j+1,mat) and mat[i][j+1] > mat[i][j])\\n            op4 = solve(i,j+1,mat);\\n        \\n        int ans = 1 + max({op1,op2,op3,op4});\\n        return dp[i][j] = ans;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& mat) {\\n        int m = mat.size(), n = mat[0].size();\\n        int res = 0;\\n        memset(dp,-1,sizeof dp);\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int ans = solve(i,j,mat);\\n                res = max(res,ans);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[200][200];\\n    bool is_valid(int i,int j,vector<vector<int>> &mat){\\n        int m = mat.size(), n = mat[0].size();\\n        if(i >= 0 and j >=0 and i < m and j < n) return true;\\n        return false;\\n    }\\n    int solve(int i,int j,vector<vector<int>> &mat){\\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int op1 = 0,op2 = 0,op3 = 0,op4 = 0;\\n        \\n        if(is_valid(i-1,j,mat) and mat[i-1][j] > mat[i][j])\\n            op1 = solve(i-1,j,mat);\\n        \\n        if(is_valid(i+1,j,mat) and mat[i+1][j] > mat[i][j])\\n            op2 = solve(i+1,j,mat);\\n        \\n        if(is_valid(i,j-1,mat) and mat[i][j-1] > mat[i][j])\\n            op3 = solve(i,j-1,mat);\\n        \\n        if(is_valid(i,j+1,mat) and mat[i][j+1] > mat[i][j])\\n            op4 = solve(i,j+1,mat);\\n        \\n        int ans = 1 + max({op1,op2,op3,op4});\\n        return dp[i][j] = ans;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& mat) {\\n        int m = mat.size(), n = mat[0].size();\\n        int res = 0;\\n        memset(dp,-1,sizeof dp);\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int ans = solve(i,j,mat);\\n                res = max(res,ans);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682577,
                "title": "java-2-approaches-dfs-dp-kahns-algo",
                "content": "**Do vote up if you like it :)**\\n\\n**Using DFS and DP**\\n\\nThe idea is to make a dfs call on each cell, and in that dfs call move until you find a cell a that is greater than the current cell.\\nNow, form your answer by taking maximum of all valid nbr cells + 1 for your current cell.\\n\\nNOTE : DP will store max length chain of the curr cell\\n\\n```\\nclass Solution {\\n    \\n    public int longestIncreasingPath(int[][] matrix) {\\n        \\n        int max = 1;\\n        int[][] dir = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        int[][] dp = new int[matrix.length][matrix[0].length];\\n        \\n        for(int i = 0; i < matrix.length; i++) {\\n            for(int j = 0; j < matrix[0].length; j++) {\\n                max = Math.max(max, dfs(matrix, i, j, dp, dir));\\n            }\\n        }       \\n        return max;\\n    }\\n    \\n    public static int dfs(int[][] matrix, int i, int j, int[][] dp, int[][] dir){\\n        \\n        if(dp[i][j] != 0) \\n            return dp[i][j];\\n        \\n        int max = 0;\\n        for(int d = 0;  d < dir.length; d++) {    \\n            int x = i + dir[d][0];\\n            int y = j + dir[d][1];\\n            \\n            if(x >= 0 && x < matrix.length && y >= 0 && y < matrix[0].length && matrix[x][y] > matrix[i][j]){\\n                max = Math.max(max, dfs(matrix, x, y, dp, dir));\\n            }\\n        }\\n        return dp[i][j] = max + 1;\\n    }\\n}\\n```\\n-------------------------------------------------------------\\n\\n**Kahns Algo**\\n\\n```\\nclass Solution {\\n    \\n    public int longestIncreasingPath(int[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int[][] indegree = new int[n][m];\\n        int[][] dir = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        \\n        // Creating indegree + adding in queue together\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                for(int d = 0; d < dir.length; d++) { // Check all your neighbours\\n                     int x = i + dir[d][0];\\n                     int y = j + dir[d][1]; \\n                \\n                     if(x >= 0 && y >= 0 && x < n && y < m && matrix[i][j] > matrix[x][y]) {\\n                        indegree[i][j]++; // If you are greater than your nbr, increase your indegree\\n                     }\\n                }\\n                if(indegree[i][j] == 0) queue.add(i * m + j);  // Adding all 0 indegee in queue \\n            }\\n        }\\n              \\n        // Kahn\\'s Algo\\n        int level = 0;\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            while(size-- > 0) {\\n                int idx = queue.poll();\\n                int r = idx / m;\\n                int c = idx % m;\\n                \\n                for(int d = 0; d < dir.length; d++) {\\n                     int x = r + dir[d][0];\\n                     int y = c + dir[d][1]; \\n                \\n                     if(x >= 0 && y >= 0 && x < n && y < m && matrix[x][y] > matrix[r][c]) {\\n                        indegree[x][y]--;\\n                        if(indegree[x][y] == 0) {\\n                            queue.add(x * m + y);\\n                        }\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n       return level; // Last level is your answer\\n    }\\n}\\n```\\n-------------------------------------------------------------",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int longestIncreasingPath(int[][] matrix) {\\n        \\n        int max = 1;\\n        int[][] dir = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        int[][] dp = new int[matrix.length][matrix[0].length];\\n        \\n        for(int i = 0; i < matrix.length; i++) {\\n            for(int j = 0; j < matrix[0].length; j++) {\\n                max = Math.max(max, dfs(matrix, i, j, dp, dir));\\n            }\\n        }       \\n        return max;\\n    }\\n    \\n    public static int dfs(int[][] matrix, int i, int j, int[][] dp, int[][] dir){\\n        \\n        if(dp[i][j] != 0) \\n            return dp[i][j];\\n        \\n        int max = 0;\\n        for(int d = 0;  d < dir.length; d++) {    \\n            int x = i + dir[d][0];\\n            int y = j + dir[d][1];\\n            \\n            if(x >= 0 && x < matrix.length && y >= 0 && y < matrix[0].length && matrix[x][y] > matrix[i][j]){\\n                max = Math.max(max, dfs(matrix, x, y, dp, dir));\\n            }\\n        }\\n        return dp[i][j] = max + 1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    public int longestIncreasingPath(int[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int[][] indegree = new int[n][m];\\n        int[][] dir = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        \\n        // Creating indegree + adding in queue together\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                for(int d = 0; d < dir.length; d++) { // Check all your neighbours\\n                     int x = i + dir[d][0];\\n                     int y = j + dir[d][1]; \\n                \\n                     if(x >= 0 && y >= 0 && x < n && y < m && matrix[i][j] > matrix[x][y]) {\\n                        indegree[i][j]++; // If you are greater than your nbr, increase your indegree\\n                     }\\n                }\\n                if(indegree[i][j] == 0) queue.add(i * m + j);  // Adding all 0 indegee in queue \\n            }\\n        }\\n              \\n        // Kahn\\'s Algo\\n        int level = 0;\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            while(size-- > 0) {\\n                int idx = queue.poll();\\n                int r = idx / m;\\n                int c = idx % m;\\n                \\n                for(int d = 0; d < dir.length; d++) {\\n                     int x = r + dir[d][0];\\n                     int y = c + dir[d][1]; \\n                \\n                     if(x >= 0 && y >= 0 && x < n && y < m && matrix[x][y] > matrix[r][c]) {\\n                        indegree[x][y]--;\\n                        if(indegree[x][y] == 0) {\\n                            queue.add(x * m + y);\\n                        }\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n       return level; // Last level is your answer\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1385120,
                "title": "easy-c-solution-using-dfs",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int helper(vector<vector<int>>&matrix,int i,int j,vector<vector<int>>&dp)\\n    {\\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }\\n        int x=matrix[i][j];\\n        matrix[i][j]=-2;\\n        int up=(i-1>=0 && matrix[i-1][j]>x?helper(matrix,i-1,j,dp):0);\\n        int down=(i+1<matrix.size() && matrix[i+1][j]>x?helper(matrix,i+1,j,dp):0);\\n        int left=(j-1>=0 && matrix[i][j-1]>x?helper(matrix,i,j-1,dp):0);\\n        int right=(j+1<matrix[0].size() && matrix[i][j+1]>x?helper(matrix,i,j+1,dp):0);\\n        matrix[i][j]=x;\\n        return dp[i][j]=1+max({up,down,left,right});\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) \\n    {\\n        int m=matrix.size(),n=matrix[0].size(),ans=0;\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(dp[i][j]==-1)\\n                {\\n                    dp[i][j]=helper(matrix,i,j,dp);\\n                }\\n                ans=max(ans,dp[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int helper(vector<vector<int>>&matrix,int i,int j,vector<vector<int>>&dp)\\n    {\\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }\\n        int x=matrix[i][j];\\n        matrix[i][j]=-2;\\n        int up=(i-1>=0 && matrix[i-1][j]>x?helper(matrix,i-1,j,dp):0);\\n        int down=(i+1<matrix.size() && matrix[i+1][j]>x?helper(matrix,i+1,j,dp):0);\\n        int left=(j-1>=0 && matrix[i][j-1]>x?helper(matrix,i,j-1,dp):0);\\n        int right=(j+1<matrix[0].size() && matrix[i][j+1]>x?helper(matrix,i,j+1,dp):0);\\n        matrix[i][j]=x;\\n        return dp[i][j]=1+max({up,down,left,right});\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) \\n    {\\n        int m=matrix.size(),n=matrix[0].size(),ans=0;\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(dp[i][j]==-1)\\n                {\\n                    dp[i][j]=helper(matrix,i,j,dp);\\n                }\\n                ans=max(ans,dp[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1348482,
                "title": "java-kahn-s-algorithm",
                "content": "Just calculate the indegree for each node(number of incoming edges) in the graph and return the maximum level size we can reach using BFS. Here the BFS is based on the Kahn\\'s algorithm. When we traverse a node then we will decrement it\\'s neighbouring node\\'s indegree. When indegree of that node becomes zero then we will add it into the queue. And ofcourse in the start we have to add only those elements whose indegree value is zero. When each node is traversed (queue is empty); end the loop and return the size of the level. \\n\\nThe level will be the answer because when we traverse a graph through BFS the last level we have traversed is always the length of the longest path in the graph.\\n\\nNote: You can even do it by calculating the outgoing edges and the conditions will be changed accordingly. The only difference is now all the edges of the graph that we will traverse will be reversed. But still the answer will remain the same.\\n\\n```\\nclass Solution {\\n    public int longestIncreasingPath(int[][] arr) {\\n        \\n        int n = arr.length, m = arr[0].length;\\n        int[][] indeg = new int[n][m];\\n        int[][] dir = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                for(int k = 0; k < dir.length; k++) {\\n                    if(i + dir[k][0] >= 0 && i + dir[k][0] < n && j + dir[k][1] >= 0 && j + dir[k][1] < m && arr[i][j] > arr[i + dir[k][0]][j + dir[k][1]]) {\\n                        indeg[i][j]++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        Queue<Integer> que = new LinkedList<>();\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(indeg[i][j] == 0) que.add(i * m + j);\\n            }\\n        }\\n        int count = 0;\\n        while(que.size() > 0) {\\n            \\n            int size = que.size();\\n            while(size-- > 0) {\\n                int polled = que.poll();\\n                \\n                int i = polled / m, j = polled % m;\\n                for(int k = 0; k < dir.length; k++) {\\n                    if(i + dir[k][0] >= 0 && i + dir[k][0] < n && j + dir[k][1] >= 0 && j + dir[k][1] < m && arr[i][j] < arr[i + dir[k][0]][j + dir[k][1]]) {\\n                        indeg[i + dir[k][0]][j + dir[k][1]]--;\\n                        if(indeg[i + dir[k][0]][j + dir[k][1]] == 0) que.add((i + dir[k][0])*m + (j + dir[k][1]));\\n                    }\\n                    \\n                }\\n            }\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestIncreasingPath(int[][] arr) {\\n        \\n        int n = arr.length, m = arr[0].length;\\n        int[][] indeg = new int[n][m];\\n        int[][] dir = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                for(int k = 0; k < dir.length; k++) {\\n                    if(i + dir[k][0] >= 0 && i + dir[k][0] < n && j + dir[k][1] >= 0 && j + dir[k][1] < m && arr[i][j] > arr[i + dir[k][0]][j + dir[k][1]]) {\\n                        indeg[i][j]++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        Queue<Integer> que = new LinkedList<>();\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(indeg[i][j] == 0) que.add(i * m + j);\\n            }\\n        }\\n        int count = 0;\\n        while(que.size() > 0) {\\n            \\n            int size = que.size();\\n            while(size-- > 0) {\\n                int polled = que.poll();\\n                \\n                int i = polled / m, j = polled % m;\\n                for(int k = 0; k < dir.length; k++) {\\n                    if(i + dir[k][0] >= 0 && i + dir[k][0] < n && j + dir[k][1] >= 0 && j + dir[k][1] < m && arr[i][j] < arr[i + dir[k][0]][j + dir[k][1]]) {\\n                        indeg[i + dir[k][0]][j + dir[k][1]]--;\\n                        if(indeg[i + dir[k][0]][j + dir[k][1]] == 0) que.add((i + dir[k][0])*m + (j + dir[k][1]));\\n                    }\\n                    \\n                }\\n            }\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1158379,
                "title": "python3-top-down-dp",
                "content": "\\n```\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        m, n = len(matrix), len(matrix[0]) # dimensions \\n        \\n        @cache\\n        def fn(i, j): \\n            \"\"\"Return max increasing path starting from (i, j).\"\"\"\\n            ans = 1\\n            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                if 0 <= ii < m and 0 <= jj < n and matrix[i][j] < matrix[ii][jj]: \\n                    ans = max(ans, 1 + fn(ii, jj))\\n            return ans \\n        \\n        return max(fn(i, j) for i in range(m) for j in range(n))\\n```\\n\\n**Approach 2 -- topological sort**\\n```\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        indeg = [[0]*n for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n): \\n                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                    if 0 <= ii < m and 0 <= jj < n and matrix[i][j] < matrix[ii][jj]: \\n                        indeg[ii][jj] += 1\\n        queue = deque([(i, j) for i in range(m) for j in range(n) if indeg[i][j] == 0])\\n        ans = 0\\n        while queue: \\n            for _ in range(len(queue)): \\n                i, j = queue.popleft()\\n                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                    if 0 <= ii < m and 0 <= jj < n and matrix[i][j] < matrix[ii][jj]: \\n                        indeg[ii][jj] -= 1\\n                        if indeg[ii][jj] == 0: queue.append((ii, jj))\\n            ans += 1\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        m, n = len(matrix), len(matrix[0]) # dimensions \\n        \\n        @cache\\n        def fn(i, j): \\n            \"\"\"Return max increasing path starting from (i, j).\"\"\"\\n            ans = 1\\n            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                if 0 <= ii < m and 0 <= jj < n and matrix[i][j] < matrix[ii][jj]: \\n                    ans = max(ans, 1 + fn(ii, jj))\\n            return ans \\n        \\n        return max(fn(i, j) for i in range(m) for j in range(n))\\n```\n```\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        indeg = [[0]*n for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n): \\n                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                    if 0 <= ii < m and 0 <= jj < n and matrix[i][j] < matrix[ii][jj]: \\n                        indeg[ii][jj] += 1\\n        queue = deque([(i, j) for i in range(m) for j in range(n) if indeg[i][j] == 0])\\n        ans = 0\\n        while queue: \\n            for _ in range(len(queue)): \\n                i, j = queue.popleft()\\n                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                    if 0 <= ii < m and 0 <= jj < n and matrix[i][j] < matrix[ii][jj]: \\n                        indeg[ii][jj] -= 1\\n                        if indeg[ii][jj] == 0: queue.append((ii, jj))\\n            ans += 1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1138953,
                "title": "python-dfs-memoization-simple",
                "content": "```\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        visited = dict()\\n        def dfs(row, col):\\n            sublength = 1\\n            path_length = 0\\n            for new_row, new_col in (row + 1, col), (row - 1, col), (row, col + 1), (row, col - 1):\\n                if 0 <= new_row <= len(matrix) - 1 and 0 <= new_col <= len(matrix[0]) - 1 and matrix[row][col] < matrix[new_row][new_col]:\\n                    if (new_row, new_col) in visited:\\n                        path_length = max(path_length, visited[(new_row, new_col)])\\n                    else:\\n                        path_length = max(path_length, dfs(new_row, new_col))\\n\\n            visited[(row, col)] = path_length + sublength\\n            return path_length + sublength\\n        \\n        for row in range(len(matrix)):\\n            for col in range(len(matrix[0])):\\n                if (row, col) not in visited:\\n                    dfs(row, col)\\n        \\n        return max(visited.values())\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        visited = dict()\\n        def dfs(row, col):\\n            sublength = 1\\n            path_length = 0\\n            for new_row, new_col in (row + 1, col), (row - 1, col), (row, col + 1), (row, col - 1):\\n                if 0 <= new_row <= len(matrix) - 1 and 0 <= new_col <= len(matrix[0]) - 1 and matrix[row][col] < matrix[new_row][new_col]:\\n                    if (new_row, new_col) in visited:\\n                        path_length = max(path_length, visited[(new_row, new_col)])\\n                    else:\\n                        path_length = max(path_length, dfs(new_row, new_col))\\n\\n            visited[(row, col)] = path_length + sublength\\n            return path_length + sublength\\n        \\n        for row in range(len(matrix)):\\n            for col in range(len(matrix[0])):\\n                if (row, col) not in visited:\\n                    dfs(row, col)\\n        \\n        return max(visited.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1103556,
                "title": "python-memoized-dfs",
                "content": "```\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        M, N = len(matrix), len(matrix[0])\\n        MOVES = [(1,0), (0,1), (-1,0), (0,-1)]\\n        \\n        @functools.cache\\n        def dfs(i, j):\\n            path_length = 0\\n            for di, dj in MOVES:\\n                ni, nj = i+di, j+dj\\n                if 0<=ni<M and 0<=nj<N and matrix[ni][nj] > matrix[i][j]:\\n                    path_length = max(path_length, dfs(ni, nj))\\n            return 1 + path_length\\n        \\n        res = 0\\n        for i in range(M):\\n            for j in range(N):\\n                res = max(res, dfs(i, j))\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        M, N = len(matrix), len(matrix[0])\\n        MOVES = [(1,0), (0,1), (-1,0), (0,-1)]\\n        \\n        @functools.cache\\n        def dfs(i, j):\\n            path_length = 0\\n            for di, dj in MOVES:\\n                ni, nj = i+di, j+dj\\n                if 0<=ni<M and 0<=nj<N and matrix[ni][nj] > matrix[i][j]:\\n                    path_length = max(path_length, dfs(ni, nj))\\n            return 1 + path_length\\n        \\n        res = 0\\n        for i in range(M):\\n            for j in range(N):\\n                res = max(res, dfs(i, j))\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074582,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    private int res = 0;\\n    \\n    public int LongestIncreasingPath(int[][] matrix) {\\n        if (matrix == null || matrix.Length == 0)\\n            return res;\\n        \\n        int[,] cache = new int[matrix.Length, matrix[0].Length];\\n        \\n        for (int i = 0; i < matrix.Length; i++)\\n            for (int j = 0; j < matrix[0].Length; j++)\\n                DFS(matrix, i, j, 0, cache);\\n        \\n        return res;\\n    }\\n    \\n    private void DFS(int[][] matrix, int i, int j, int curLen, int[,] cache)\\n    {\\n        curLen++;\\n        \\n        if (cache[i, j] >= curLen)\\n            return;\\n        else\\n        {\\n            cache[i, j] = curLen;\\n            res = Math.Max(res, curLen);\\n        }\\n        \\n        if (i - 1 > -1 && matrix[i - 1][j] > matrix[i][j])\\n            DFS(matrix, i - 1, j, curLen, cache);\\n        \\n        if (j - 1 > -1 && matrix[i][j - 1] > matrix[i][j])\\n            DFS(matrix, i, j - 1, curLen, cache);\\n        \\n        if (i + 1 < matrix.Length && matrix[i + 1][j] > matrix[i][j])\\n            DFS(matrix, i + 1, j, curLen, cache);\\n        \\n        if (j + 1 < matrix[0].Length && matrix[i][j + 1] > matrix[i][j])\\n            DFS(matrix, i, j + 1, curLen, cache);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    private int res = 0;\\n    \\n    public int LongestIncreasingPath(int[][] matrix) {\\n        if (matrix == null || matrix.Length == 0)\\n            return res;\\n        \\n        int[,] cache = new int[matrix.Length, matrix[0].Length];\\n        \\n        for (int i = 0; i < matrix.Length; i++)\\n            for (int j = 0; j < matrix[0].Length; j++)\\n                DFS(matrix, i, j, 0, cache);\\n        \\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 766038,
                "title": "swift-simple-sweet-from-naive-to-optimized-100",
                "content": "**NAIVE SOLUTION**\\n*Time: O(n^4), Space: O(n^2)*\\n```\\nfunc longestIncreasingPath(_ matrix: [[Int]]) -> Int {\\n\\tif matrix.isEmpty { return 0 }\\n\\n\\tlet w = matrix[0].count\\n\\tlet h = matrix.count\\n\\tvar visiteds = Array(repeating: Array(repeating: false, count: w), count: h)\\n\\tvar maxCount = 0\\n\\n\\tfor i in 0..<h {\\n\\t\\tfor j in 0..<w {\\n\\t\\t\\tlet num = matrix[i][j]\\n\\t\\t\\tlet count = lengthOf(matrix, i, j, nil, &visiteds)\\n\\t\\t\\tif count > (h*w) / 2 { return count }\\n\\t\\t\\tprint(count)\\n\\t\\t\\tmaxCount = max(maxCount, count)\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxCount\\n}\\n\\nfunc lengthOf(_ matrix: [[Int]], _ i: Int, _ j: Int, _ prev: Int?, _ visiteds: inout [[Bool]]) -> Int {\\n\\tif i < 0 || i >= matrix.count || j < 0 || j >= matrix[0].count { return 0 }\\n\\tif visiteds[i][j] { return 0 }\\n\\n\\tlet cur = matrix[i][j]\\n\\tif let prev = prev, cur <= prev { return 0 }\\n\\n\\tvisiteds[i][j] = true\\n\\tlet maxLength = 1 + max(lengthOf(matrix, i - 1, j, cur, &visiteds),\\n\\t\\t\\t\\t\\t\\t\\tlengthOf(matrix, i + 1, j, cur, &visiteds),\\n\\t\\t\\t\\t\\t\\t\\tlengthOf(matrix, i, j - 1, cur, &visiteds),\\n\\t\\t\\t\\t\\t\\t\\tlengthOf(matrix, i, j + 1, cur, &visiteds))\\n\\tvisiteds[i][j] = false\\n\\n\\treturn maxLength\\n}\\n```\\n\\n---\\n**OPTIMIZED SOLUTION**\\nThe idea of using a caching array of naive solution was great. Using that idea, we can build a better solution.\\n*O(n^2), Space: O(n^2)*\\n```\\nfunc longestIncreasingPath(_ matrix: [[Int]]) -> Int {\\n\\tif matrix.isEmpty { return 0 }\\n\\n\\tlet w = matrix[0].count\\n\\tlet h = matrix.count\\n\\tvar maxLengths = Array(repeating: Array(repeating: -1, count: w), count: h)\\n\\tvar maxCount = 0\\n\\n\\tfor i in 0..<h {\\n\\t\\tfor j in 0..<w {\\n\\t\\t\\tlet num = matrix[i][j]\\n\\t\\t\\tlet count = lengthOf(matrix, i, j, nil, &maxLengths)\\n\\t\\t\\tif count > (h*w) / 2 { return count }\\n\\t\\t\\tmaxCount = max(maxCount, count)\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxCount\\n}\\n\\nfunc lengthOf(_ matrix: [[Int]], _ i: Int, _ j: Int, _ prev: Int?, _ maxLengths: inout [[Int]]) -> Int {\\n\\tif i < 0 || i >= matrix.count || j < 0 || j >= matrix[0].count { return 0 }\\n\\n\\tlet cur = matrix[i][j]\\n\\tif let prev = prev, cur <= prev { return 0 }\\n\\tif maxLengths[i][j] != -1 { return maxLengths[i][j] }   // already solved, return\\n\\n\\tlet maxLength = 1 + max(lengthOf(matrix, i - 1, j, cur, &maxLengths),\\n\\t\\t\\t\\t\\t\\t\\tlengthOf(matrix, i + 1, j, cur, &maxLengths),\\n\\t\\t\\t\\t\\t\\t\\tlengthOf(matrix, i, j - 1, cur, &maxLengths),\\n\\t\\t\\t\\t\\t\\t\\tlengthOf(matrix, i, j + 1, cur, &maxLengths))\\n\\tmaxLengths[i][j] = maxLength\\n\\n\\treturn maxLength\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc longestIncreasingPath(_ matrix: [[Int]]) -> Int {\\n\\tif matrix.isEmpty { return 0 }\\n\\n\\tlet w = matrix[0].count\\n\\tlet h = matrix.count\\n\\tvar visiteds = Array(repeating: Array(repeating: false, count: w), count: h)\\n\\tvar maxCount = 0\\n\\n\\tfor i in 0..<h {\\n\\t\\tfor j in 0..<w {\\n\\t\\t\\tlet num = matrix[i][j]\\n\\t\\t\\tlet count = lengthOf(matrix, i, j, nil, &visiteds)\\n\\t\\t\\tif count > (h*w) / 2 { return count }\\n\\t\\t\\tprint(count)\\n\\t\\t\\tmaxCount = max(maxCount, count)\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxCount\\n}\\n\\nfunc lengthOf(_ matrix: [[Int]], _ i: Int, _ j: Int, _ prev: Int?, _ visiteds: inout [[Bool]]) -> Int {\\n\\tif i < 0 || i >= matrix.count || j < 0 || j >= matrix[0].count { return 0 }\\n\\tif visiteds[i][j] { return 0 }\\n\\n\\tlet cur = matrix[i][j]\\n\\tif let prev = prev, cur <= prev { return 0 }\\n\\n\\tvisiteds[i][j] = true\\n\\tlet maxLength = 1 + max(lengthOf(matrix, i - 1, j, cur, &visiteds),\\n\\t\\t\\t\\t\\t\\t\\tlengthOf(matrix, i + 1, j, cur, &visiteds),\\n\\t\\t\\t\\t\\t\\t\\tlengthOf(matrix, i, j - 1, cur, &visiteds),\\n\\t\\t\\t\\t\\t\\t\\tlengthOf(matrix, i, j + 1, cur, &visiteds))\\n\\tvisiteds[i][j] = false\\n\\n\\treturn maxLength\\n}\\n```\n```\\nfunc longestIncreasingPath(_ matrix: [[Int]]) -> Int {\\n\\tif matrix.isEmpty { return 0 }\\n\\n\\tlet w = matrix[0].count\\n\\tlet h = matrix.count\\n\\tvar maxLengths = Array(repeating: Array(repeating: -1, count: w), count: h)\\n\\tvar maxCount = 0\\n\\n\\tfor i in 0..<h {\\n\\t\\tfor j in 0..<w {\\n\\t\\t\\tlet num = matrix[i][j]\\n\\t\\t\\tlet count = lengthOf(matrix, i, j, nil, &maxLengths)\\n\\t\\t\\tif count > (h*w) / 2 { return count }\\n\\t\\t\\tmaxCount = max(maxCount, count)\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxCount\\n}\\n\\nfunc lengthOf(_ matrix: [[Int]], _ i: Int, _ j: Int, _ prev: Int?, _ maxLengths: inout [[Int]]) -> Int {\\n\\tif i < 0 || i >= matrix.count || j < 0 || j >= matrix[0].count { return 0 }\\n\\n\\tlet cur = matrix[i][j]\\n\\tif let prev = prev, cur <= prev { return 0 }\\n\\tif maxLengths[i][j] != -1 { return maxLengths[i][j] }   // already solved, return\\n\\n\\tlet maxLength = 1 + max(lengthOf(matrix, i - 1, j, cur, &maxLengths),\\n\\t\\t\\t\\t\\t\\t\\tlengthOf(matrix, i + 1, j, cur, &maxLengths),\\n\\t\\t\\t\\t\\t\\t\\tlengthOf(matrix, i, j - 1, cur, &maxLengths),\\n\\t\\t\\t\\t\\t\\t\\tlengthOf(matrix, i, j + 1, cur, &maxLengths))\\n\\tmaxLengths[i][j] = maxLength\\n\\n\\treturn maxLength\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 608110,
                "title": "c-dfs-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int dx[4] = {0, -1, 1, 0};\\n    int dy[4] = {1, 0, 0, -1};\\n    \\n    int dp[1001][1001];\\n    \\n    int dfs(vector<vector<int>>& grid, int i, int j, int prev) {\\n        if (i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size()) return 0;\\n        if (grid[i][j] <= prev) return 0;\\n        if (dp[i][j] != -1) return dp[i][j];\\n        int ans = 0;\\n        for (int k=0; k<4; k++) {\\n            int I = i + dx[k];\\n            int J = j + dy[k];\\n            ans = max(ans, 1 + dfs(grid, I, J, grid[i][j]));\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    \\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        if (!matrix.size()) return 0;\\n        memset(dp, -1, sizeof dp);\\n        int ans = 1;\\n        for (int i=0; i<matrix.size(); i++) {\\n            for (int j=0; j<matrix[0].size(); j++) {\\n                ans = max(ans, dfs(matrix, i, j, INT_MIN));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4] = {0, -1, 1, 0};\\n    int dy[4] = {1, 0, 0, -1};\\n    \\n    int dp[1001][1001];\\n    \\n    int dfs(vector<vector<int>>& grid, int i, int j, int prev) {\\n        if (i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size()) return 0;\\n        if (grid[i][j] <= prev) return 0;\\n        if (dp[i][j] != -1) return dp[i][j];\\n        int ans = 0;\\n        for (int k=0; k<4; k++) {\\n            int I = i + dx[k];\\n            int J = j + dy[k];\\n            ans = max(ans, 1 + dfs(grid, I, J, grid[i][j]));\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    \\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        if (!matrix.size()) return 0;\\n        memset(dp, -1, sizeof dp);\\n        int ans = 1;\\n        for (int i=0; i<matrix.size(); i++) {\\n            for (int j=0; j<matrix[0].size(); j++) {\\n                ans = max(ans, dfs(matrix, i, j, INT_MIN));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 595061,
                "title": "bfs",
                "content": "The idea is similar the the DFS but this approach is more selective and intuitive personally.\\n* You preprocess and generate an indegree array.\\n* Then you do a topological sort with bfs to get the result\\n```\\npublic:\\n    int R, C;\\n    bool valid(const int &row, const int &col) {\\n        return row >= 0 && row < R && col >= 0 && col < C;\\n    }\\n    \\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        if(matrix.empty() || !matrix.size())\\n            return 0;\\n        R = matrix.size(), C = matrix[0].size();\\n        \\n        vector<vector<int>> indegree(R, vector<int>(C));\\n        vector<pair<int, int>> dirs{{0, -1}, {0, 1}, {1, 0}, {-1, 0}};\\n        queue<pair<int, int>> q;\\n        \\n        for(int i = 0; i < R; i++) {\\n            for(int j = 0; j < C; j++) {\\n                for(const auto &p: dirs) {\\n                    int row = i + p.first, col = j + p.second;\\n                    if(valid(row, col) && matrix[i][j] > matrix[row][col])\\n                        indegree[i][j]++;\\n                }\\n                if(!indegree[i][j])\\n                    q.push({i, j});\\n            }\\n        }\\n        \\n        int len(0);\\n        while(!q.empty()) {\\n            int size = q.size();\\n            while(size--) {\\n                auto front = q.front();\\n                q.pop();\\n                int row = front.first, col = front.second;\\n                for(const auto &p: dirs) {\\n                    int nextRow = row + p.first;\\n                    int nextCol = col + p.second;\\n                    if(valid(nextRow, nextCol)\\n                       && matrix[nextRow][nextCol] > matrix[row][col]\\n                       && !--indegree[nextRow][nextCol])\\n                        q.push({nextRow, nextCol});\\n                }\\n            }\\n            len++;\\n        }\\n        return len;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\npublic:\\n    int R, C;\\n    bool valid(const int &row, const int &col) {\\n        return row >= 0 && row < R && col >= 0 && col < C;\\n    }\\n    \\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        if(matrix.empty() || !matrix.size())\\n            return 0;\\n        R = matrix.size(), C = matrix[0].size();\\n        \\n        vector<vector<int>> indegree(R, vector<int>(C));\\n        vector<pair<int, int>> dirs{{0, -1}, {0, 1}, {1, 0}, {-1, 0}};\\n        queue<pair<int, int>> q;\\n        \\n        for(int i = 0; i < R; i++) {\\n            for(int j = 0; j < C; j++) {\\n                for(const auto &p: dirs) {\\n                    int row = i + p.first, col = j + p.second;\\n                    if(valid(row, col) && matrix[i][j] > matrix[row][col])\\n                        indegree[i][j]++;\\n                }\\n                if(!indegree[i][j])\\n                    q.push({i, j});\\n            }\\n        }\\n        \\n        int len(0);\\n        while(!q.empty()) {\\n            int size = q.size();\\n            while(size--) {\\n                auto front = q.front();\\n                q.pop();\\n                int row = front.first, col = front.second;\\n                for(const auto &p: dirs) {\\n                    int nextRow = row + p.first;\\n                    int nextCol = col + p.second;\\n                    if(valid(nextRow, nextCol)\\n                       && matrix[nextRow][nextCol] > matrix[row][col]\\n                       && !--indegree[nextRow][nextCol])\\n                        q.push({nextRow, nextCol});\\n                }\\n            }\\n            len++;\\n        }\\n        return len;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 347735,
                "title": "dfs-memoization",
                "content": "DFS+Memoization\\nApproach:\\n\\tIt\\'s quite obvious at first glance, a dfs crawl through the matrix would get us the answer one way or another. Note dfs because we want to focus on exhausting a single path and then go on to the next one. It\\'s possible, I believe, that this can be solved with bfs as well, but it beats the point, as with bfs we will be exhausting all the possible paths at every depth.\\n\\tComing back, once we are sure of the dfs approach, lets finalize the termination condition. \\n\\tThe ususal one\\'s like i>=matrix.,length, i<0, j>=matrix[0].length and j<0 will be there. in addition, we also need to ensure, that the crawl keeps on going toward the next increasing number. \\n\\tThis can be achieved by breaking when matrix[new_i][new_j]<=matrix[i][j]. One way to acheve this is to pass the currently processing value into the recursion call. \\n\\tFor the very first initial call we can simply pass Integer.MIN_VALUE\\n\\tSo the first draft of the dfs function would look like\\n\\t\\n\\tpublic int dfs(int[][] matrix, int i, int j, int last)\\n    {\\n        if(i<0 || i>=matrix.length || j<0 || j>=matrix[0].length || matrix[i][j]<=last)\\n            return 0;\\n        int len=0;\\n        len=Math.max(len,dfs(matrix,memo,i-1,j,matrix[i][j]));\\n        len=Math.max(len,dfs(matrix,memo,i+1,j,matrix[i][j]));\\n        len=Math.max(len,dfs(matrix,memo,i,j-1,matrix[i][j]));\\n        len=Math.max(len,dfs(matrix,memo,i,j+1,matrix[i][j]));\\n        return len+1;    \\n    }\\n\\n\\t\\n\\tNow, from the above example\\n\\tInput: nums =\\n    [\\n      [9,9,4],\\n      [6,6,8],\\n      [2,1,1]\\n    ]\\n    Output: 4\\n    Explanation: The longest increasing path is [1, 2, 6, 9].\\n\\tIt\\'s obvious that when we process cell 1,0, the curr length is 2 [6,9]. When we process cell 2,0 the current length is 3 [2,6,9]. At 2,1 the length is 4 [1,2,6,9]\\n\\tSo there is an optimal subproblem. Hence memoization. \\n\\tWith memoization, the dfs function would look like  thiis\\n\\t\\n\\tpublic int dfs(int[][] matrix, int[][] memo, int i, int j, int last)\\n    {\\n        if(i<0 || i>=matrix.length || j<0 || j>=matrix[0].length || matrix[i][j]<=last)\\n            return 0;\\n        if(memo[i][j]!=0)\\n            return memo[i][j];\\n        int len=0;\\n        len=Math.max(len,dfs(matrix,memo,i-1,j,matrix[i][j]));\\n        len=Math.max(len,dfs(matrix,memo,i+1,j,matrix[i][j]));\\n        len=Math.max(len,dfs(matrix,memo,i,j-1,matrix[i][j]));\\n        len=Math.max(len,dfs(matrix,memo,i,j+1,matrix[i][j]));\\n        memo[i][j]=len+1;\\n        return len+1;\\n    }\\n\\t\\n\\nThe complete solution:\\n\\n    public int longestIncreasingPath(int[][] matrix) \\n    {\\n        if(matrix==null || matrix.length==0)\\n            return 0;\\n        int[][] memo=new int[matrix.length][matrix[0].length];\\n        int len=0;\\n        for(int i=0;i<matrix.length;i++)\\n            for(int j=0;j<matrix[0].length;j++)\\n                len=Math.max(len,dfs(matrix,memo,i,j,Integer.MIN_VALUE));\\n        return len;               \\n    }\\n    public int dfs(int[][] matrix, int[][] memo, int i, int j, int last)\\n    {\\n        if(i<0 || i>=matrix.length || j<0 || j>=matrix[0].length || matrix[i][j]<=last)\\n            return 0;\\n        if(memo[i][j]!=0)\\n            return memo[i][j];\\n        int len=0;\\n        len=Math.max(len,dfs(matrix,memo,i-1,j,matrix[i][j]));\\n        len=Math.max(len,dfs(matrix,memo,i+1,j,matrix[i][j]));\\n        len=Math.max(len,dfs(matrix,memo,i,j-1,matrix[i][j]));\\n        len=Math.max(len,dfs(matrix,memo,i,j+1,matrix[i][j]));\\n        memo[i][j]=len+1;\\n        return len+1;\\n    }\\n```",
                "solutionTags": [],
                "code": "DFS+Memoization\\nApproach:\\n\\tIt\\'s quite obvious at first glance, a dfs crawl through the matrix would get us the answer one way or another. Note dfs because we want to focus on exhausting a single path and then go on to the next one. It\\'s possible, I believe, that this can be solved with bfs as well, but it beats the point, as with bfs we will be exhausting all the possible paths at every depth.\\n\\tComing back, once we are sure of the dfs approach, lets finalize the termination condition. \\n\\tThe ususal one\\'s like i>=matrix.,length, i<0, j>=matrix[0].length and j<0 will be there. in addition, we also need to ensure, that the crawl keeps on going toward the next increasing number. \\n\\tThis can be achieved by breaking when matrix[new_i][new_j]<=matrix[i][j]. One way to acheve this is to pass the currently processing value into the recursion call. \\n\\tFor the very first initial call we can simply pass Integer.MIN_VALUE\\n\\tSo the first draft of the dfs function would look like\\n\\t\\n\\tpublic int dfs(int[][] matrix, int i, int j, int last)\\n    {\\n        if(i<0 || i>=matrix.length || j<0 || j>=matrix[0].length || matrix[i][j]<=last)\\n            return 0;\\n        int len=0;\\n        len=Math.max(len,dfs(matrix,memo,i-1,j,matrix[i][j]));\\n        len=Math.max(len,dfs(matrix,memo,i+1,j,matrix[i][j]));\\n        len=Math.max(len,dfs(matrix,memo,i,j-1,matrix[i][j]));\\n        len=Math.max(len,dfs(matrix,memo,i,j+1,matrix[i][j]));\\n        return len+1;    \\n    }\\n\\n\\t\\n\\tNow, from the above example\\n\\tInput: nums =\\n    [\\n      [9,9,4],\\n      [6,6,8],\\n      [2,1,1]\\n    ]\\n    Output: 4\\n    Explanation: The longest increasing path is [1, 2, 6, 9].\\n\\tIt\\'s obvious that when we process cell 1,0, the curr length is 2 [6,9]. When we process cell 2,0 the current length is 3 [2,6,9]. At 2,1 the length is 4 [1,2,6,9]\\n\\tSo there is an optimal subproblem. Hence memoization. \\n\\tWith memoization, the dfs function would look like  thiis\\n\\t\\n\\tpublic int dfs(int[][] matrix, int[][] memo, int i, int j, int last)\\n    {\\n        if(i<0 || i>=matrix.length || j<0 || j>=matrix[0].length || matrix[i][j]<=last)\\n            return 0;\\n        if(memo[i][j]!=0)\\n            return memo[i][j];\\n        int len=0;\\n        len=Math.max(len,dfs(matrix,memo,i-1,j,matrix[i][j]));\\n        len=Math.max(len,dfs(matrix,memo,i+1,j,matrix[i][j]));\\n        len=Math.max(len,dfs(matrix,memo,i,j-1,matrix[i][j]));\\n        len=Math.max(len,dfs(matrix,memo,i,j+1,matrix[i][j]));\\n        memo[i][j]=len+1;\\n        return len+1;\\n    }\\n\\t\\n\\nThe complete solution:\\n\\n    public int longestIncreasingPath(int[][] matrix) \\n    {\\n        if(matrix==null || matrix.length==0)\\n            return 0;\\n        int[][] memo=new int[matrix.length][matrix[0].length];\\n        int len=0;\\n        for(int i=0;i<matrix.length;i++)\\n            for(int j=0;j<matrix[0].length;j++)\\n                len=Math.max(len,dfs(matrix,memo,i,j,Integer.MIN_VALUE));\\n        return len;               \\n    }\\n    public int dfs(int[][] matrix, int[][] memo, int i, int j, int last)\\n    {\\n        if(i<0 || i>=matrix.length || j<0 || j>=matrix[0].length || matrix[i][j]<=last)\\n            return 0;\\n        if(memo[i][j]!=0)\\n            return memo[i][j];\\n        int len=0;\\n        len=Math.max(len,dfs(matrix,memo,i-1,j,matrix[i][j]));\\n        len=Math.max(len,dfs(matrix,memo,i+1,j,matrix[i][j]));\\n        len=Math.max(len,dfs(matrix,memo,i,j-1,matrix[i][j]));\\n        len=Math.max(len,dfs(matrix,memo,i,j+1,matrix[i][j]));\\n        memo[i][j]=len+1;\\n        return len+1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 299059,
                "title": "two-simple-python-dp-solutions",
                "content": "1. Bottom-up DP: sort the elements, then calculate the longest increasing path from smaller ones to larger ones.\\n```\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        if not matrix or not matrix[0]:\\n            return 0\\n        m, n = len(matrix), len(matrix[0])\\n        lst = []\\n        for i in range(m):\\n            for j in range(n):\\n                lst.append((matrix[i][j], i, j))\\n        lst.sort()\\n        dp = [[0 for _ in range(n)] for _ in range(m)]\\n        for num, i, j in lst:\\n            dp[i][j] = 1\\n            for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\\n                r, c = i + di, j + dj\\n                if 0 <= r < m and 0 <= c < n:\\n                    if matrix[i][j] > matrix[r][c]:\\n                        dp[i][j] = max(dp[i][j], 1 + dp[r][c])\\n        return max([dp[i][j] for i in range(m) for j in range(n)])\\n```\\n\\n2. DFS from top to bottom + memoization: use 2D table \\'dp\\' to record previous results, dp[i][j] == 0 means the neighbor is unvisited before. Don\\'t need to sort the elements.\\n```\\n        def dfs(i, j):\\n            if dp[i][j] == 0:\\n                dp[i][j] = 1\\n                num = matrix[i][j]\\n                for di,dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\\n                    r, c = i + di, j + dj\\n                    if 0 <= r < m and 0 <= c < n:\\n                        if num > matrix[r][c]:\\n                            dp[i][j] = max(dp[i][j], 1 + dfs(r, c))\\n            return dp[i][j]\\n    \\n        if not matrix or not matrix[0]:\\n            return 0\\n        m, n = len(matrix), len(matrix[0])\\n        dp = [[0 for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                dfs(i, j)\\n        return max([dp[i][j] for i in range(m) for j in range(n)])\\n```",
                "solutionTags": [],
                "code": "```\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        if not matrix or not matrix[0]:\\n            return 0\\n        m, n = len(matrix), len(matrix[0])\\n        lst = []\\n        for i in range(m):\\n            for j in range(n):\\n                lst.append((matrix[i][j], i, j))\\n        lst.sort()\\n        dp = [[0 for _ in range(n)] for _ in range(m)]\\n        for num, i, j in lst:\\n            dp[i][j] = 1\\n            for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\\n                r, c = i + di, j + dj\\n                if 0 <= r < m and 0 <= c < n:\\n                    if matrix[i][j] > matrix[r][c]:\\n                        dp[i][j] = max(dp[i][j], 1 + dp[r][c])\\n        return max([dp[i][j] for i in range(m) for j in range(n)])\\n```\n```\\n        def dfs(i, j):\\n            if dp[i][j] == 0:\\n                dp[i][j] = 1\\n                num = matrix[i][j]\\n                for di,dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\\n                    r, c = i + di, j + dj\\n                    if 0 <= r < m and 0 <= c < n:\\n                        if num > matrix[r][c]:\\n                            dp[i][j] = max(dp[i][j], 1 + dfs(r, c))\\n            return dp[i][j]\\n    \\n        if not matrix or not matrix[0]:\\n            return 0\\n        m, n = len(matrix), len(matrix[0])\\n        dp = [[0 for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                dfs(i, j)\\n        return max([dp[i][j] for i in range(m) for j in range(n)])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 269094,
                "title": "python-7-liner",
                "content": "```\\nclass Solution:\\n    def longestIncreasingPath(self, matrix):\\n        def dfs(i, j):\\n            if not dp[i][j]:\\n                dp[i][j] = 1+max((dfs(x,y) for x,y in ((i-1,j),(i+1,j),(i,j-1),(i,j+1)) if 0 <=x<m and 0<=y<n and matrix[x][y] > matrix[i][j]),default=0)\\n            return dp[i][j]\\n        m, n, = len(matrix), len(matrix and matrix[0])\\n        dp = [[0] * n for _ in range(m)]\\n        return max((dfs(i,j) for i in range(m) for j in range(n)),default=0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestIncreasingPath(self, matrix):\\n        def dfs(i, j):\\n            if not dp[i][j]:\\n                dp[i][j] = 1+max((dfs(x,y) for x,y in ((i-1,j),(i+1,j),(i,j-1),(i,j+1)) if 0 <=x<m and 0<=y<n and matrix[x][y] > matrix[i][j]),default=0)\\n            return dp[i][j]\\n        m, n, = len(matrix), len(matrix and matrix[0])\\n        dp = [[0] * n for _ in range(m)]\\n        return max((dfs(i,j) for i in range(m) for j in range(n)),default=0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 166119,
                "title": "swift-dfs-solution",
                "content": "```\\nclass Solution {\\n    func longestIncreasingPath(_ matrix: [[Int]]) -> Int {\\n        if(matrix.count == 0 || matrix[0].count == 0) {\\n            return 0\\n        }\\n        let m = matrix.count\\n        let n = matrix[0].count\\n        var maxValue = 0\\n        var cache = Array(repeating: Array(repeating: 0, count: n), count: m)\\n        for i in 0..<m {\\n            for j in 0..<n {\\n                let len = dfsHelper(i,j,m,n,matrix,&cache)\\n                maxValue = max(maxValue,len)\\n            }\\n        }\\n        return maxValue\\n    }\\n    \\n    func dfsHelper(_ i:Int, _ j :Int, _ rows:Int, _ cols:Int, _ matrix:[[Int]], _ cache:inout [[Int]]) ->Int {\\n        if(cache[i][j] != 0) {\\n            return cache[i][j]\\n        }\\n        var maxValue = 1\\n        let moves = [[1,0],[0,1],[-1,0],[0,-1]]\\n        for move in moves {\\n            let x = i + move[0]\\n            let y = j + move[1]\\n            if(x < 0 || x >= rows || y < 0 || y >= cols || matrix[x][y] <= matrix[i][j]) {\\n                continue\\n            }\\n            let len = 1 + dfsHelper(x,y,rows,cols,matrix,&cache)\\n            maxValue = max(maxValue,len)\\n        }\\n        cache[i][j] = maxValue\\n        return maxValue\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func longestIncreasingPath(_ matrix: [[Int]]) -> Int {\\n        if(matrix.count == 0 || matrix[0].count == 0) {\\n            return 0\\n        }\\n        let m = matrix.count\\n        let n = matrix[0].count\\n        var maxValue = 0\\n        var cache = Array(repeating: Array(repeating: 0, count: n), count: m)\\n        for i in 0..<m {\\n            for j in 0..<n {\\n                let len = dfsHelper(i,j,m,n,matrix,&cache)\\n                maxValue = max(maxValue,len)\\n            }\\n        }\\n        return maxValue\\n    }\\n    \\n    func dfsHelper(_ i:Int, _ j :Int, _ rows:Int, _ cols:Int, _ matrix:[[Int]], _ cache:inout [[Int]]) ->Int {\\n        if(cache[i][j] != 0) {\\n            return cache[i][j]\\n        }\\n        var maxValue = 1\\n        let moves = [[1,0],[0,1],[-1,0],[0,-1]]\\n        for move in moves {\\n            let x = i + move[0]\\n            let y = j + move[1]\\n            if(x < 0 || x >= rows || y < 0 || y >= cols || matrix[x][y] <= matrix[i][j]) {\\n                continue\\n            }\\n            let len = 1 + dfsHelper(x,y,rows,cols,matrix,&cache)\\n            maxValue = max(maxValue,len)\\n        }\\n        cache[i][j] = maxValue\\n        return maxValue\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78413,
                "title": "my-28ms-c-solution-beats-100-o-rowsize-colsize-time-using-dfs-concise-and-easy-to-understand",
                "content": "    #define MAXN 2048\\n    #define zip(x,y) ((x)*(col)+(y))\\n    \\n    int max(int a, int b)\\n    {\\n        return a > b?a:b;\\n    }\\n    int dp[MAXN*MAXN];\\n    int dfs(int x,int y,const int row,const int col,int last,int **mat)\\n    {\\n         if(x >= row || y >= col || x < 0 || y < 0 || mat[x][y] <= last)\\n            return 0;\\n        int t = zip(x,y);\\n        if(dp[t]) \\n            return dp[t];\\n        int ret = dfs(x-1,y,row,col,mat[x][y],mat);\\n        ret = max(ret,dfs(x+1,y,row,col,mat[x][y],mat));\\n        ret = max(ret,dfs(x,y-1,row,col,mat[x][y],mat));\\n        ret = max(ret,dfs(x,y+1,row,col,mat[x][y],mat));\\n        return dp[t] = ++ret;\\n     }\\n\\n     int longestIncreasingPath(int** mat, int row, int col) {\\n         int ret = 0;\\n         memset(dp,0,sizeof(int)*zip(row,col));\\n         for(int i = 0; i < row; i++)\\n            for(int j = 0; j < col; j++)\\n                ret = max(ret,dfs(i,j,row,col,mat[i][j] - 1,mat));\\n        return ret;\\n     }",
                "solutionTags": [],
                "code": "    #define MAXN 2048\\n    #define zip(x,y) ((x)*(col)+(y))\\n    \\n    int max(int a, int b)\\n    {\\n        return a > b?a:b;\\n    }\\n    int dp[MAXN*MAXN];\\n    int dfs(int x,int y,const int row,const int col,int last,int **mat)\\n    {\\n         if(x >= row || y >= col || x < 0 || y < 0 || mat[x][y] <= last)\\n            return 0;\\n        int t = zip(x,y);\\n        if(dp[t]) \\n            return dp[t];\\n        int ret = dfs(x-1,y,row,col,mat[x][y],mat);\\n        ret = max(ret,dfs(x+1,y,row,col,mat[x][y],mat));\\n        ret = max(ret,dfs(x,y-1,row,col,mat[x][y],mat));\\n        ret = max(ret,dfs(x,y+1,row,col,mat[x][y],mat));\\n        return dp[t] = ++ret;\\n     }\\n\\n     int longestIncreasingPath(int** mat, int row, int col) {\\n         int ret = 0;\\n         memset(dp,0,sizeof(int)*zip(row,col));\\n         for(int i = 0; i < row; i++)\\n            for(int j = 0; j < col; j++)\\n                ret = max(ret,dfs(i,j,row,col,mat[i][j] - 1,mat));\\n        return ret;\\n     }",
                "codeTag": "Unknown"
            },
            {
                "id": 78431,
                "title": "share-my-c-code-using-dfs",
                "content": "    void maxlength(int** matrix, int** length, int i, int j, int matrixRowSize, int matrixColSize) \\n    {\\n    int len = 0;\\n    if (i > 0 && matrix[i-1][j] < matrix[i][j]) {\\n        if (length[i-1][j] == 0)    maxlength(matrix, length, i-1, j, matrixRowSize, matrixColSize);\\n        len = len > length[i-1][j] ? len : length[i-1][j];\\n    }\\n    if (i < matrixRowSize-1 && matrix[i+1][j] < matrix[i][j]) {\\n        if (length[i+1][j] == 0)    maxlength(matrix, length, i+1, j, matrixRowSize, matrixColSize);\\n        len = len > length[i+1][j] ? len : length[i+1][j];\\n    }\\n    if (j > 0 && matrix[i][j-1] < matrix[i][j]) {\\n        if (length[i][j-1] == 0)    maxlength(matrix, length, i, j-1, matrixRowSize, matrixColSize);\\n        len = len > length[i][j-1] ? len : length[i][j-1];\\n    }\\n    if (j < matrixColSize-1 && matrix[i][j+1] < matrix[i][j]) {\\n        if (length[i][j+1] == 0)    maxlength(matrix, length, i, j+1, matrixRowSize, matrixColSize);\\n        len = len > length[i][j+1] ? len : length[i][j+1];\\n    }\\n    \\n    length[i][j] = len + 1;\\n    return;\\n    }\\n\\n    int longestIncreasingPath(int** matrix, int matrixRowSize, int matrixColSize) {\\n    if (matrixRowSize == 0 || matrixColSize == 0) return 0;\\n    \\n    int max = 1, i, j;\\n    int** length = (int**)malloc(sizeof(int*)*matrixRowSize);\\n    for (i = 0; i < matrixRowSize; i++)\\n        length[i] = (int*)calloc(matrixColSize, sizeof(int));\\n    \\n    for (i = 0; i < matrixRowSize; i++) {\\n        for (j = 0; j < matrixColSize; j++) {\\n            if (length[i][j] == 0) maxlength(matrix, length, i, j, matrixRowSize, matrixColSize);\\n            \\n            if (max < length[i][j]) max = length[i][j];\\n        }\\n    }\\n    \\n    for (i = 0; i < matrixRowSize; i++) free(length[i]);\\n    free(length);\\n    \\n    return max;\\n    }",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "    void maxlength(int** matrix, int** length, int i, int j, int matrixRowSize, int matrixColSize) \\n    {\\n    int len = 0;\\n    if (i > 0 && matrix[i-1][j] < matrix[i][j]) {\\n        if (length[i-1][j] == 0)    maxlength(matrix, length, i-1, j, matrixRowSize, matrixColSize);\\n        len = len > length[i-1][j] ? len : length[i-1][j];\\n    }\\n    if (i < matrixRowSize-1 && matrix[i+1][j] < matrix[i][j]) {\\n        if (length[i+1][j] == 0)    maxlength(matrix, length, i+1, j, matrixRowSize, matrixColSize);\\n        len = len > length[i+1][j] ? len : length[i+1][j];\\n    }\\n    if (j > 0 && matrix[i][j-1] < matrix[i][j]) {\\n        if (length[i][j-1] == 0)    maxlength(matrix, length, i, j-1, matrixRowSize, matrixColSize);\\n        len = len > length[i][j-1] ? len : length[i][j-1];\\n    }\\n    if (j < matrixColSize-1 && matrix[i][j+1] < matrix[i][j]) {\\n        if (length[i][j+1] == 0)    maxlength(matrix, length, i, j+1, matrixRowSize, matrixColSize);\\n        len = len > length[i][j+1] ? len : length[i][j+1];\\n    }\\n    \\n    length[i][j] = len + 1;\\n    return;\\n    }\\n\\n    int longestIncreasingPath(int** matrix, int matrixRowSize, int matrixColSize) {\\n    if (matrixRowSize == 0 || matrixColSize == 0) return 0;\\n    \\n    int max = 1, i, j;\\n    int** length = (int**)malloc(sizeof(int*)*matrixRowSize);\\n    for (i = 0; i < matrixRowSize; i++)\\n        length[i] = (int*)calloc(matrixColSize, sizeof(int));\\n    \\n    for (i = 0; i < matrixRowSize; i++) {\\n        for (j = 0; j < matrixColSize; j++) {\\n            if (length[i][j] == 0) maxlength(matrix, length, i, j, matrixRowSize, matrixColSize);\\n            \\n            if (max < length[i][j]) max = length[i][j];\\n        }\\n    }\\n    \\n    for (i = 0; i < matrixRowSize; i++) free(length[i]);\\n    free(length);\\n    \\n    return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 78439,
                "title": "compact-python-solution-dfs-memoization-beats-72-25",
                "content": "    class Solution(object):\\n        def longestIncreasingPath(self, matrix):\\n            result = [[None] * len(matrix[i]) for i in range(len(matrix))]\\n            m = 0\\n            for i in range(len(result)):\\n                for j in range(len(result[i])):\\n                    m = max(m, self.DFS(i, j, matrix, result))\\n            return m\\n        \\n        def DFS(self, i, j, matrix, result):\\n            if result[i][j]:\\n                return result[i][j]\\n            \\n            result[i][j] = 1\\n            if i-1 >= 0 and matrix[i][j] < matrix[i-1][j]:\\n                result[i][j] = max(result[i][j], self.DFS(i-1, j, matrix, result) + 1)\\n            if i+1 < len(result) and matrix[i][j] < matrix[i+1][j]:\\n                result[i][j] = max(result[i][j], self.DFS(i+1, j, matrix, result) + 1)\\n            if j-1 >= 0 and matrix[i][j] < matrix[i][j-1]:\\n                result[i][j] = max(result[i][j], self.DFS(i, j-1, matrix, result) + 1)\\n            if j+1 < len(result[i]) and matrix[i][j] < matrix[i][j+1]:\\n                result[i][j] = max(result[i][j], self.DFS(i, j+1, matrix, result) + 1)\\n            return result[i][j]",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def longestIncreasingPath(self, matrix):\\n            result = [[None] * len(matrix[i]) for i in range(len(matrix))]\\n            m = 0\\n            for i in range(len(result)):\\n                for j in range(len(result[i])):\\n                    m = max(m, self.DFS(i, j, matrix, result))\\n            return m\\n        \\n        def DFS(self, i, j, matrix, result):\\n            if result[i][j]:\\n                return result[i][j]\\n            \\n            result[i][j] = 1\\n            if i-1 >= 0 and matrix[i][j] < matrix[i-1][j]:\\n                result[i][j] = max(result[i][j], self.DFS(i-1, j, matrix, result) + 1)\\n            if i+1 < len(result) and matrix[i][j] < matrix[i+1][j]:\\n                result[i][j] = max(result[i][j], self.DFS(i+1, j, matrix, result) + 1)\\n            if j-1 >= 0 and matrix[i][j] < matrix[i][j-1]:\\n                result[i][j] = max(result[i][j], self.DFS(i, j-1, matrix, result) + 1)\\n            if j+1 < len(result[i]) and matrix[i][j] < matrix[i][j+1]:\\n                result[i][j] = max(result[i][j], self.DFS(i, j+1, matrix, result) + 1)\\n            return result[i][j]",
                "codeTag": "Java"
            },
            {
                "id": 78447,
                "title": "c-topological-sort-solution-no-recursion-linear-space-and-time-92ms",
                "content": "The basic idea is to record how many inputs a node has.\\nThe number of input nodes of a node is the number of the neighbors which is less (or greater) than it.\\n\\nAfter all, this is no more than a normal topological sort algorithm.\\n\\n    class Solution {\\n    public:\\n    \\tint longestIncreasingPath(const vector<vector<int>>& matrix) {\\n    \\t\\tconst int h = matrix.size();\\n    \\t\\tif (h == 0) return 0;\\n    \\t\\tconst int w = matrix[0].size();\\n    \\t\\tif (w == 0) return 0;\\n    \\t\\tvector<int> num_in(w*h, 0);\\n    \\t\\tqueue<pair<int,int>> q, nq;\\n    \\t\\tfor (int y = 0; y < h; ++y) {\\n    \\t\\t\\tfor (int x = 0; x < w; ++x) {\\n    \\t\\t\\t\\tint nin = 0;\\n    \\t\\t\\t\\tint cur = matrix[y][x];\\n    \\t\\t\\t\\tif (x-1 >= 0) { nin += cur < matrix[y][x-1]; }\\n    \\t\\t\\t\\tif (x+1 <  w) { nin += cur < matrix[y][x+1]; }\\n    \\t\\t\\t\\tif (y-1 >= 0) { nin += cur < matrix[y-1][x]; }\\n    \\t\\t\\t\\tif (y+1 <  h) { nin += cur < matrix[y+1][x]; }\\n    \\t\\t\\t\\tnum_in[w*y+x] = nin;\\n    \\t\\t\\t\\tif (nin == 0) {\\n    \\t\\t\\t\\t\\tq.emplace(y,x);\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tint l = 0;\\n    \\t\\twhile (not q.empty()) {\\n    \\t\\t\\twhile (not q.empty()) {\\n    \\t\\t\\t\\tpair<int,int> curpos = q.front();\\n    \\t\\t\\t\\tq.pop();\\n    \\t\\t\\t\\tint y = curpos.first;\\n    \\t\\t\\t\\tint x = curpos.second;\\n    \\t\\t\\t\\tint cur = matrix[y][x];\\n    #define WALK(y, x)\\\\\\n    \\tint &nin = num_in[w*(y)+(x)];\\\\\\n    \\tif (cur > matrix[y][x] and nin > 0) {\\\\\\n    \\t\\t--nin;\\\\\\n    \\t\\tif (nin == 0) {\\\\\\n    \\t\\t\\tnq.emplace(y, x);\\\\\\n    \\t\\t}\\\\\\n    \\t}\\n    \\t\\t\\t\\tif (x-1 >= 0) { WALK(y,x-1); }\\n    \\t\\t\\t\\tif (x+1 <  w) { WALK(y,x+1); }\\n    \\t\\t\\t\\tif (y-1 >= 0) { WALK(y-1,x); }\\n    \\t\\t\\t\\tif (y+1 <  h) { WALK(y+1,x); }\\n    #undef WALK\\n    \\t\\t\\t}\\n    \\t\\t\\t++l;\\n    \\t\\t\\tswap(q, nq);\\n    \\t\\t}\\n    \\t\\treturn l;\\n    \\t}\\n    };",
                "solutionTags": [
                    "C++",
                    "Topological Sort"
                ],
                "code": "class Solution {\\n    public:\\n    \\tint longestIncreasingPath(const vector<vector<int>>& matrix) {\\n    \\t\\tconst int h = matrix.size();\\n    \\t\\tif (h == 0) return 0;\\n    \\t\\tconst int w = matrix[0].size();\\n    \\t\\tif (w == 0) return 0;\\n    \\t\\tvector<int> num_in(w*h, 0);\\n    \\t\\tqueue<pair<int,int>> q, nq;\\n    \\t\\tfor (int y = 0; y < h; ++y) {\\n    \\t\\t\\tfor (int x = 0; x < w; ++x) {\\n    \\t\\t\\t\\tint nin = 0;\\n    \\t\\t\\t\\tint cur = matrix[y][x];\\n    \\t\\t\\t\\tif (x-1 >= 0) { nin += cur < matrix[y][x-1]; }",
                "codeTag": "Java"
            },
            {
                "id": 78453,
                "title": "c-dfs-solution-with-dp-optimized-76ms-but-beat-97-6-what",
                "content": " - dp[r][c] cache the LIS length started from matrix[r][c], since we will\\n   search all matrix[[r][c]'s LIS, we dont have to worry about when matrix[[r][c] is\\n   in the middle of an LIS.\\n - for every matrix[[r][c], we search in 4directions to get its max LIS length, if what we search is already in cache, we use it.\\n - NOTE that since we search for INCREASING, so we wont vist an position twice, such that we dont need an map to record the position that we have visted in DFS.\\n\\ncode:\\n\\n    class Solution {\\n    public:\\n        int longestIncreasingPath(vector<vector<int> >& matrix) {\\n            int m=0;\\n            row=matrix.size();\\n            if(row==0)\\n                return 0;\\n            col=matrix[0].size();\\n            dp.resize(row,vector<int>(col));\\n            for(int r=0;r<row;++r){\\n                for(int c=0;c<col;++c){\\n                    int inc=findIncreasing(r,c,matrix);\\n                    m=max(m,inc);\\n                }\\n            }\\n            return m;\\n        }\\n    private:\\n        int row,col;\\n        vector<vector<int> > dp;\\n        int findIncreasing(int r,int c,vector<vector<int> >& matrix){\\n            if(dp[r][c]>0)\\n                return dp[r][c];\\n            //cout<<\"<\"<<matrix[r][c]<<\" \";\\n            int m=0;\\n            int now=matrix[r][c];\\n            //up\\n            if(r-1>=0 && matrix[r-1][c]>now){\\n                m=max(m,findIncreasing(r-1,c,matrix));\\n            }\\n            //down\\n            if(r+1<row && matrix[r+1][c]>now){\\n                m=max(m,findIncreasing(r+1,c,matrix));\\n            }\\n            //left\\n            if(c-1>=0 && matrix[r][c-1]>now){\\n                m=max(m,findIncreasing(r,c-1,matrix));\\n            }\\n            //right\\n            if(c+1<col && matrix[r][c+1]>now){\\n                m=max(m,findIncreasing(r,c+1,matrix));\\n            }\\n            dp[r][c]=m+1;\\n            return m+1;\\n        }\\n    \\n    };",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        int longestIncreasingPath(vector<vector<int> >& matrix) {\\n            int m=0;\\n            row=matrix.size();\\n            if(row==0)\\n                return 0;\\n            col=matrix[0].size();\\n            dp.resize(row,vector<int>(col));\\n            for(int r=0;r<row;++r){\\n                for(int c=0;c<col;++c){\\n                    int inc=findIncreasing(r,c,matrix);\\n                    m=max(m,inc);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 78484,
                "title": "clean-python-code",
                "content": "The main idea is using DFS to search the longest increasing path from each point, and then cache the result for other paths passing it to use it.\\n\\n    class Solution(object):\\n        def search(self, i, j, val, m, n, matrix, r):\\n            if r[i][j] is not None:\\n                return r[i][j]\\n    \\n            length = 0\\n            for x, y in ((0, -1), (-1, 0), (0, 1), (1, 0)):\\n                ii, jj = i + x, j + y\\n                if 0 <= ii < m and 0 <= jj < n and matrix[ii][jj] > val:\\n                    v = matrix[ii][jj]\\n    \\n                    matrix[ii][jj] = float('-inf')\\n                    length = max(self.search(ii, jj, v, m, n, matrix, r), length)\\n                    matrix[ii][jj] = v\\n    \\n            r[i][j] = length + 1\\n            return r[i][j]\\n    \\n        def longestIncreasingPath(self, matrix):\\n            if not matrix:\\n                return 0\\n    \\n            m, n = len(matrix), len(matrix[0])\\n            r = [[None] * n for _ in xrange(m)]\\n    \\n            return max(\\n                self.search(i, j, val, m, n, matrix, r)\\n                for i, row in enumerate(matrix)\\n                for j, val in enumerate(row)\\n            )",
                "solutionTags": [
                    "Python"
                ],
                "code": "The main idea is using DFS to search the longest increasing path from each point, and then cache the result for other paths passing it to use it.\\n\\n    class Solution(object):\\n        def search(self, i, j, val, m, n, matrix, r):\\n            if r[i][j] is not None:\\n                return r[i][j]\\n    \\n            length = 0\\n            for x, y in ((0, -1), (-1, 0), (0, 1), (1, 0)):\\n                ii, jj = i + x, j + y\\n                if 0 <= ii < m and 0 <= jj < n and matrix[ii][jj] > val:\\n                    v = matrix[ii][jj]\\n    \\n                    matrix[ii][jj] = float('-inf')\\n                    length = max(self.search(ii, jj, v, m, n, matrix, r), length)\\n                    matrix[ii][jj] = v\\n    \\n            r[i][j] = length + 1\\n            return r[i][j]\\n    \\n        def longestIncreasingPath(self, matrix):\\n            if not matrix:\\n                return 0\\n    \\n            m, n = len(matrix), len(matrix[0])\\n            r = [[None] * n for _ in xrange(m)]\\n    \\n            return max(\\n                self.search(i, j, val, m, n, matrix, r)\\n                for i, row in enumerate(matrix)\\n                for j, val in enumerate(row)\\n            )",
                "codeTag": "Java"
            },
            {
                "id": 3652811,
                "title": "dfs-with-memoization-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is necessary to try all possible paths and optimize the algorithm\\'s complexity by using a map to store already calculated cases.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. A dictionary `memo` is declared, which will be used to store intermediate results of calculations and speed up the process.\\n\\n2. The function `Path` is defined, which takes row index `i` and column index `j` as arguments. This function returns the length of the longest path that can be constructed starting from position `(i, j)`.\\n\\n3. Inside the `Path` function, it checks if the result for position `(i, j)` is already present in the `memo` dictionary. If it is present, the stored result is directly returned.\\n\\n4. The variable `res` is initialized to 0 to keep track of the current path length from position `(i, j)`.\\n\\n5. Four checks are performed within the `Path` function to determine if it\\'s possible to move in an adjacent direction (up, down, left, right) and if the number in the adjacent position is strictly greater than the current number at `(i, j)`. If these conditions are met, the length of the path from that position is calculated using recursion.\\n\\n6. During the calculation of the path in each direction, the `max` function is used to keep track of the maximum length among all possible directions to move. This is done to ensure considering the longest path among valid directions.\\n\\n7. The result `res` is stored in the `memo` dictionary to avoid recomputation in the future, and it is returned.\\n\\n8. Outside the `Path` function, a nested `for` loop is executed to explore each position in the `grid` matrix. The `ans` value is updated using the `max` function to obtain the maximum length of the path among all positions.\\n\\n9. Finally, the value `ans + 1` is returned because the length of the path is counted including the starting position.\\n# Complexity\\n- Time complexity: $$O(row \\\\cdot col)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: $$O(row \\\\cdot col)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestIncreasingPath(self, grid: List[List[int]]) -> int:\\n        row, col, ans = len(grid), len(grid[0]), 0\\n        memo = {}\\n        \\n        def Path(i, j):\\n            if (i, j) in memo:\\n                return memo[(i, j)]\\n\\n            res = 0            \\n            if i + 1 < row and grid[i][j] < grid[i + 1][j]:\\n                res = max(res,1 + Path(i + 1, j))\\n                \\n            if i - 1 >= 0 and grid[i][j] < grid[i - 1][j]:\\n                res = max(res, 1 + Path(i - 1, j))\\n                \\n            if j + 1 < col and grid[i][j] < grid[i][j + 1]:\\n                res = max(res, 1 + Path(i, j + 1))\\n                \\n            if j - 1 >= 0 and grid[i][j] < grid[i][j - 1]:\\n                res = max(res, 1 + Path(i, j - 1))\\n                \\n            memo[(i, j)] = res\\n            return memo[(i, j)]\\n\\n        for i in range(row):\\n            for j in range(col):\\n                ans = max(ans,Path(i, j))\\n        \\n        return ans +1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestIncreasingPath(self, grid: List[List[int]]) -> int:\\n        row, col, ans = len(grid), len(grid[0]), 0\\n        memo = {}\\n        \\n        def Path(i, j):\\n            if (i, j) in memo:\\n                return memo[(i, j)]\\n\\n            res = 0            \\n            if i + 1 < row and grid[i][j] < grid[i + 1][j]:\\n                res = max(res,1 + Path(i + 1, j))\\n                \\n            if i - 1 >= 0 and grid[i][j] < grid[i - 1][j]:\\n                res = max(res, 1 + Path(i - 1, j))\\n                \\n            if j + 1 < col and grid[i][j] < grid[i][j + 1]:\\n                res = max(res, 1 + Path(i, j + 1))\\n                \\n            if j - 1 >= 0 and grid[i][j] < grid[i][j - 1]:\\n                res = max(res, 1 + Path(i, j - 1))\\n                \\n            memo[(i, j)] = res\\n            return memo[(i, j)]\\n\\n        for i in range(row):\\n            for j in range(col):\\n                ans = max(ans,Path(i, j))\\n        \\n        return ans +1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652237,
                "title": "c-dfs-memoization",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere may be many overlapping subproblem, so we have to store the result for future use.\\n\\nSo, if there\\'s a longest path (optimal solution) for a given cell starting at that cell, all the cells in its path must also have optimal paths as well starting at those cells respectively. \\n\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\nwe traverse through each index in matrix and save their longest increasing path by traversing all possible direction\\n\\n# Complexity\\n- Time complexity: ***O(n * m)*** \\n\\n\\n- Space complexity: ***O(n * m)***\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int r,c;\\n    int solve(vector<vector<int>>& mat,vector<vector<int>>& dp, int i, int j,int prev)\\n    {\\n        // r and c is the size of matrix \\n        // i and j is the current indices....\\n        if(i < 0 || i == r || j < 0 || j == c || mat[i][j] <= prev)\\n            return 0;\\n         \\n        if(dp[i][j] != 0)\\n            return dp[i][j];\\n\\n        int ans = 1;\\n        ans = max(ans,1 + solve(mat, dp, i + 1, j, mat[i][j]));\\n        ans = max(ans,1 + solve(mat, dp, i - 1, j, mat[i][j]));\\n        ans = max(ans,1 + solve(mat, dp, i, j + 1, mat[i][j]));\\n        ans = max(ans,1 + solve(mat, dp, i, j - 1, mat[i][j]));\\n        \\n        dp[i][j] = ans;\\n        return dp[i][j];\\n    }\\n\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n         r = matrix.size();\\n         c = matrix[0].size();\\n\\n        vector<vector<int>> dp(r,vector<int>(c,0));\\n\\n        int maxpath = 0;\\n        for(int i = 0; i < dp.size(); i++)\\n        {\\n            for(int j = 0; j < dp[0].size(); j++)\\n            {\\n                maxpath = max(maxpath, solve(matrix,dp,i,j,-1));\\n            }\\n        }\\n        return maxpath;\\n    }\\n};\\n```\\n ***upvote if you understand***",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int r,c;\\n    int solve(vector<vector<int>>& mat,vector<vector<int>>& dp, int i, int j,int prev)\\n    {\\n        // r and c is the size of matrix \\n        // i and j is the current indices....\\n        if(i < 0 || i == r || j < 0 || j == c || mat[i][j] <= prev)\\n            return 0;\\n         \\n        if(dp[i][j] != 0)\\n            return dp[i][j];\\n\\n        int ans = 1;\\n        ans = max(ans,1 + solve(mat, dp, i + 1, j, mat[i][j]));\\n        ans = max(ans,1 + solve(mat, dp, i - 1, j, mat[i][j]));\\n        ans = max(ans,1 + solve(mat, dp, i, j + 1, mat[i][j]));\\n        ans = max(ans,1 + solve(mat, dp, i, j - 1, mat[i][j]));\\n        \\n        dp[i][j] = ans;\\n        return dp[i][j];\\n    }\\n\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n         r = matrix.size();\\n         c = matrix[0].size();\\n\\n        vector<vector<int>> dp(r,vector<int>(c,0));\\n\\n        int maxpath = 0;\\n        for(int i = 0; i < dp.size(); i++)\\n        {\\n            for(int j = 0; j < dp[0].size(); j++)\\n            {\\n                maxpath = max(maxpath, solve(matrix,dp,i,j,-1));\\n            }\\n        }\\n        return maxpath;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3536827,
                "title": "java-dfs-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int startRow;\\n    int startCol;\\n    public int longestIncreasingPath(int[][] matrix) {\\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n        \\n        int delRow[]={1,-1,0,0};\\n        int delCol[]={0,0,1,-1};\\n        int visit[][]=new int[n][m];\\n   \\n        int max=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                if(visit[i][j]==0){\\n                    \\n                    max=Math.max(max,dfs(i,j,matrix,visit,n,m,delRow,delCol));\\n                    \\n                }\\n            }\\n        }\\n        return max;\\n    }\\n\\n    public int dfs(int row,int col,int [][]matrix,int [][]visit,int n,int m,int[]delRow,int[]delCol){     \\n        if(visit[row][col]>0){\\n            return visit[row][col];\\n        }\\n        //System.out.println(row+\",\"+col);\\n        int ans=1;\\n        for(int i=0;i<4;i++){\\n            int nrow=row+delRow[i];\\n            int ncol=col+delCol[i];\\n\\n            if (nrow < 0 || nrow >= n || ncol < 0 || ncol >= m) {\\n                continue;\\n            }\\n\\n            if (matrix[nrow][ncol] <= matrix[row][col]) {\\n                continue;\\n            }\\n\\n                ans=Math.max(ans,dfs(nrow,ncol,matrix,visit,n,m,delRow,delCol)+1);\\n        }\\n        visit[row][col]=ans;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int startRow;\\n    int startCol;\\n    public int longestIncreasingPath(int[][] matrix) {\\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n        \\n        int delRow[]={1,-1,0,0};\\n        int delCol[]={0,0,1,-1};\\n        int visit[][]=new int[n][m];\\n   \\n        int max=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                if(visit[i][j]==0){\\n                    \\n                    max=Math.max(max,dfs(i,j,matrix,visit,n,m,delRow,delCol));\\n                    \\n                }\\n            }\\n        }\\n        return max;\\n    }\\n\\n    public int dfs(int row,int col,int [][]matrix,int [][]visit,int n,int m,int[]delRow,int[]delCol){     \\n        if(visit[row][col]>0){\\n            return visit[row][col];\\n        }\\n        //System.out.println(row+\",\"+col);\\n        int ans=1;\\n        for(int i=0;i<4;i++){\\n            int nrow=row+delRow[i];\\n            int ncol=col+delCol[i];\\n\\n            if (nrow < 0 || nrow >= n || ncol < 0 || ncol >= m) {\\n                continue;\\n            }\\n\\n            if (matrix[nrow][ncol] <= matrix[row][col]) {\\n                continue;\\n            }\\n\\n                ans=Math.max(ans,dfs(nrow,ncol,matrix,visit,n,m,delRow,delCol)+1);\\n        }\\n        visit[row][col]=ans;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502385,
                "title": "made-easy-with-java-dfs-approach",
                "content": "\\nCreate a dp Array to store the path for every element and store the maximum path received from all four direction on that index.\\n\\nExplore every path using dfs\\nStore the result\\nif already explored used same result\\n\\n# Code\\n```\\n\\n\\n\\nclass Solution {\\n    public int longestIncreasingPath(int[][] matrix) {\\n        \\n\\t\\t//Base condition\\n        if(matrix.length==0)\\n            return 0;\\n        \\n\\t\\t\\n        int dp[][] = new int[matrix.length][matrix[0].length];\\n        int max = 0;\\n        \\n        for(int i =0;i<matrix.length;i++){\\n            for(int j =0;j<matrix[0].length;j++){\\n                //result is not stored\\n                if(dp[i][j]==0){\\n                   dfs(matrix,i,j,Integer.MIN_VALUE,dp);\\n                   max = Math.max(dp[i][j],max); \\n                }\\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    private int dfs(int[][] matrix,int i,int j,int pre,int[][] dp){\\n        //Dont fo beyond boundaries and next element should be greater for increasing path\\n        if(i<0 || j<0 ||i>=matrix.length || j>=matrix[0].length || pre>=matrix[i][j])\\n            return 0;\\n\\t\\t\\t\\n\\t\\t//already explored\\n        else if(dp[i][j]!=0) return dp[i][j];\\n        \\n\\t\\t//exploring all direction\\n        int pathOne = dfs(matrix,i+1,j,matrix[i][j],dp);\\n        int pathTwo = dfs(matrix,i-1,j,matrix[i][j],dp);\\n        int pathThree = dfs(matrix,i,j-1,matrix[i][j],dp);\\n        int pathFour = dfs(matrix,i,j+1,matrix[i][j],dp);\\n        \\n\\t\\t//finding the max path\\n        int maxOne = Math.max(pathOne,pathTwo);\\n        int maxTwo = Math.max(pathThree,pathFour);\\n        \\n\\t\\t//store maximum path on that index\\n        dp[i][j] = 1+Math.max(maxOne,maxTwo);\\n        \\n        return dp[i][j];\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n\\n\\nclass Solution {\\n    public int longestIncreasingPath(int[][] matrix) {\\n        \\n\\t\\t//Base condition\\n        if(matrix.length==0)\\n            return 0;\\n        \\n\\t\\t\\n        int dp[][] = new int[matrix.length][matrix[0].length];\\n        int max = 0;\\n        \\n        for(int i =0;i<matrix.length;i++){\\n            for(int j =0;j<matrix[0].length;j++){\\n                //result is not stored\\n                if(dp[i][j]==0){\\n                   dfs(matrix,i,j,Integer.MIN_VALUE,dp);\\n                   max = Math.max(dp[i][j],max); \\n                }\\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    private int dfs(int[][] matrix,int i,int j,int pre,int[][] dp){\\n        //Dont fo beyond boundaries and next element should be greater for increasing path\\n        if(i<0 || j<0 ||i>=matrix.length || j>=matrix[0].length || pre>=matrix[i][j])\\n            return 0;\\n\\t\\t\\t\\n\\t\\t//already explored\\n        else if(dp[i][j]!=0) return dp[i][j];\\n        \\n\\t\\t//exploring all direction\\n        int pathOne = dfs(matrix,i+1,j,matrix[i][j],dp);\\n        int pathTwo = dfs(matrix,i-1,j,matrix[i][j],dp);\\n        int pathThree = dfs(matrix,i,j-1,matrix[i][j],dp);\\n        int pathFour = dfs(matrix,i,j+1,matrix[i][j],dp);\\n        \\n\\t\\t//finding the max path\\n        int maxOne = Math.max(pathOne,pathTwo);\\n        int maxTwo = Math.max(pathThree,pathFour);\\n        \\n\\t\\t//store maximum path on that index\\n        dp[i][j] = 1+Math.max(maxOne,maxTwo);\\n        \\n        return dp[i][j];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760016,
                "title": "java-easy-understandable-solution-dfs",
                "content": "```\\nclass Solution {\\n    public int longestIncreasingPath(int[][] matrix) {\\n        Integer[][] cache = new Integer[matrix.length][matrix[0].length];\\n        int longest = 0;\\n        for(int i = 0; i < matrix.length; i++){\\n            for(int j = 0; j < matrix[0].length; j++){\\n                longest = Math.max(longest, dfs(i, j, -1, matrix, cache));\\n            }\\n        }\\n        return longest;\\n    }\\n    \\n    public int dfs(int row, int col, int parent, int[][] matrix, Integer[][] cache){\\n        if(row < 0 || row == matrix.length || col < 0 || col == matrix[0].length ||\\n          matrix[row][col] <= parent){\\n            return 0;\\n        }\\n        if(cache[row][col] != null){\\n            return cache[row][col];\\n        }\\n        int up = 1 + dfs(row + 1, col, matrix[row][col], matrix, cache);\\n        int down = 1 + dfs(row - 1, col, matrix[row][col], matrix, cache);\\n        int left = 1 + dfs(row, col - 1, matrix[row][col], matrix, cache);\\n        int right = 1 + dfs(row, col + 1, matrix[row][col], matrix, cache);\\n        \\n        int longestPath = Math.max(Math.max(up, down), Math.max(left, right));\\n        cache[row][col] = longestPath;\\n        return longestPath;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int longestIncreasingPath(int[][] matrix) {\\n        Integer[][] cache = new Integer[matrix.length][matrix[0].length];\\n        int longest = 0;\\n        for(int i = 0; i < matrix.length; i++){\\n            for(int j = 0; j < matrix[0].length; j++){\\n                longest = Math.max(longest, dfs(i, j, -1, matrix, cache));\\n            }\\n        }\\n        return longest;\\n    }\\n    \\n    public int dfs(int row, int col, int parent, int[][] matrix, Integer[][] cache){\\n        if(row < 0 || row == matrix.length || col < 0 || col == matrix[0].length ||\\n          matrix[row][col] <= parent){\\n            return 0;\\n        }\\n        if(cache[row][col] != null){\\n            return cache[row][col];\\n        }\\n        int up = 1 + dfs(row + 1, col, matrix[row][col], matrix, cache);\\n        int down = 1 + dfs(row - 1, col, matrix[row][col], matrix, cache);\\n        int left = 1 + dfs(row, col - 1, matrix[row][col], matrix, cache);\\n        int right = 1 + dfs(row, col + 1, matrix[row][col], matrix, cache);\\n        \\n        int longestPath = Math.max(Math.max(up, down), Math.max(left, right));\\n        cache[row][col] = longestPath;\\n        return longestPath;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2640382,
                "title": "python-dfs-memoization-solution-explanation-inclusive",
                "content": "the question basically says that we can start from anywhere and ending to anywhere in the matrix\\nwe have to find the longest increasing path\\nthe increasing path from one element to another cannot be considered digonally but just the adjacent bottom,up , right and left blocks\\n\\nstep 1: take the rows and columns of a matrix, declare an empty dp(hashmap is preferred)\\nstep 2: now write a dfs function and set the base conditions\\nbase condition 1: if the passed rows and column are out of bound i.e. greater than length of matrix or smaller than zero\\n    and we\\'ll check if the previously value is smaller than the current value we\\'re evaluating for or not\\n    if all conditions checks this way we simply return a 0 length indicating we cannot move to this direction\\nbase condition 2: we\\'ll see if the dp at that location is already visited or not\\n                    if it is visited then we return its value\\nstep 3: now we compute the length as result and as we are moving in four directon we will store the maximum length at dp in that place\\nand we will return our computed length\\n\\nhere the result is max computed from all four direction and 1 is added to each call to show that length is incremented by one each time \\nthe function is called for another adjacent element\\n\\nstep 4: is basically out of this dfs fucntion that is calling the dfs function for each element in the matrix\\n\\n```class Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        rows, cols = len(matrix), len(matrix[0])\\n        dp = {}\\n        def dfs(r, c, prevVal):\\n            if (r < 0 or r == rows or\\n                    c < 0 or c == cols or\\n                    matrix[r][c] <= prevVal):\\n                return 0\\n            if (r, c) in dp:\\n                return dp[(r, c)]\\n            res = 1\\n            res = max(res, 1 + dfs(r + 1, c, matrix[r][c]))\\n            res = max(res, 1 + dfs(r - 1, c, matrix[r][c]))\\n            res = max(res, 1 + dfs(r, c + 1, matrix[r][c]))\\n            res = max(res, 1 + dfs(r, c - 1, matrix[r][c]))\\n            dp[(r, c)] = res\\n            return res\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, -1)\\n        return max(dp.values())\\n\\t\\t```\\n\\t\\tplease upvote if found helpful :)",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```class Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        rows, cols = len(matrix), len(matrix[0])\\n        dp = {}\\n        def dfs(r, c, prevVal):\\n            if (r < 0 or r == rows or\\n                    c < 0 or c == cols or\\n                    matrix[r][c] <= prevVal):\\n                return 0\\n            if (r, c) in dp:\\n                return dp[(r, c)]\\n            res = 1\\n            res = max(res, 1 + dfs(r + 1, c, matrix[r][c]))\\n            res = max(res, 1 + dfs(r - 1, c, matrix[r][c]))\\n            res = max(res, 1 + dfs(r, c + 1, matrix[r][c]))\\n            res = max(res, 1 + dfs(r, c - 1, matrix[r][c]))\\n            dp[(r, c)] = res\\n            return res\\n        for r in range(rows):\\n            for c in range(cols):\\n                dfs(r, c, -1)\\n        return max(dp.values())\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2476633,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Recursion && Memoization***\\n\\n* ***Time Complexity :- O(N * M)***\\n\\n* ***Space Complexity :- O(N * M)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // declare a dp\\n    \\n    int dp[205][205];\\n    \\n    // direction coordinates of left, right, up, down\\n    \\n    vector<int> dx = {-1, 0, 1, 0};\\n    \\n    vector<int> dy = {0, 1, 0, -1};\\n    \\n    // dfs function\\n    \\n    int dfs(vector<vector<int>>& matrix, int i, int j, int n, int m)\\n    {\\n        // if value is already calculated for (i, j)th cell\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        // take the maximum of longest increasing path from all four directions\\n        \\n        int maxi = 0;\\n        \\n        for(int k = 0; k < 4; k++)\\n        {\\n            int new_i = i + dx[k];\\n            \\n            int new_j = j + dy[k];\\n            \\n            if(new_i >= 0 && new_i < n && new_j >= 0 && new_j < m && matrix[new_i][new_j] > matrix[i][j])\\n            {\\n                maxi = max(maxi, dfs(matrix, new_i, new_j, n, m));\\n            }\\n        }\\n        \\n        // store the res and return it\\n        \\n        return dp[i][j] = 1 + maxi;\\n    }\\n    \\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        \\n        int n = matrix.size();\\n        \\n        int m = matrix[0].size();\\n        \\n        // initialize dp with -1\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        // find the longest increasing path for each cell and take maximum of it\\n        \\n        int maxi = INT_MIN;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                int ans = dfs(matrix, i, j, n, m);\\n                \\n                maxi = max(maxi, ans);\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // declare a dp\\n    \\n    int dp[205][205];\\n    \\n    // direction coordinates of left, right, up, down\\n    \\n    vector<int> dx = {-1, 0, 1, 0};\\n    \\n    vector<int> dy = {0, 1, 0, -1};\\n    \\n    // dfs function\\n    \\n    int dfs(vector<vector<int>>& matrix, int i, int j, int n, int m)\\n    {\\n        // if value is already calculated for (i, j)th cell\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        // take the maximum of longest increasing path from all four directions\\n        \\n        int maxi = 0;\\n        \\n        for(int k = 0; k < 4; k++)\\n        {\\n            int new_i = i + dx[k];\\n            \\n            int new_j = j + dy[k];\\n            \\n            if(new_i >= 0 && new_i < n && new_j >= 0 && new_j < m && matrix[new_i][new_j] > matrix[i][j])\\n            {\\n                maxi = max(maxi, dfs(matrix, new_i, new_j, n, m));\\n            }\\n        }\\n        \\n        // store the res and return it\\n        \\n        return dp[i][j] = 1 + maxi;\\n    }\\n    \\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        \\n        int n = matrix.size();\\n        \\n        int m = matrix[0].size();\\n        \\n        // initialize dp with -1\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        // find the longest increasing path for each cell and take maximum of it\\n        \\n        int maxi = INT_MIN;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                int ans = dfs(matrix, i, j, n, m);\\n                \\n                maxi = max(maxi, ans);\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402351,
                "title": "c-bfs-dp",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int r , c ;\\n    vector<vector<int>> dp ;\\n    const int dx[4] = {-1,0,1,0} ;\\n    const int dy[4] = {0,1,0,-1} ;\\n    \\n    void bfs(int i , int j , vector<vector<int>> &grid){\\n        queue<array<int,2>> q ;\\n        q.push({i,j}) ;\\n        dp[i][j] = max(dp[i][j],1) ;\\n        \\n        while(q.size()){\\n            auto[x,y] = q.front() ; q.pop() ;\\n            \\n            for(int itr = 0 ; itr < 4 ; ++itr ){\\n                int xx = x + dx[itr] , yy = y + dy[itr] ;\\n                if(xx >= 0 and yy >= 0 and xx < r and yy < c and grid[xx][yy] > grid[x][y]){\\n                    if(dp[xx][yy] < dp[x][y] + 1){\\n                        \\n                        dp[xx][yy] = dp[x][y] + 1 ;\\n                        q.push({xx,yy}) ;\\n                    }\\n                }\\n            }\\n        }\\n        \\n    }\\n    \\n    // void print(){\\n    //     for(int i = 0 ; i < r; ++i ){\\n    //         for(int j = 0 ; j < c ; ++j ){\\n    //             cout << dp[i][j] << \" \" ;\\n    //         }cout << endl ;\\n    //     }\\n    // }\\n    \\n    int longestIncreasingPath(vector<vector<int>>& grid) {\\n        r = grid.size() , c = grid[0].size() ;\\n        dp.resize(r,vector<int>(c,1)) ;\\n        \\n        for(int i = 0 ; i < r ; ++i )\\n            for(int j = 0 ; j < c ; ++j ) \\n                bfs(i,j,grid) ;\\n        \\n        int ans = -1;\\n        // print() ;\\n        for(int i = 0 ; i < r ; ++i) ans = max(ans,*max_element(begin(dp[i]),end(dp[i]))) ;\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int r , c ;\\n    vector<vector<int>> dp ;\\n    const int dx[4] = {-1,0,1,0} ;\\n    const int dy[4] = {0,1,0,-1} ;\\n    \\n    void bfs(int i , int j , vector<vector<int>> &grid){\\n        queue<array<int,2>> q ;\\n        q.push({i,j}) ;\\n        dp[i][j] = max(dp[i][j],1) ;\\n        \\n        while(q.size()){\\n            auto[x,y] = q.front() ; q.pop() ;\\n            \\n            for(int itr = 0 ; itr < 4 ; ++itr ){\\n                int xx = x + dx[itr] , yy = y + dy[itr] ;\\n                if(xx >= 0 and yy >= 0 and xx < r and yy < c and grid[xx][yy] > grid[x][y]){\\n                    if(dp[xx][yy] < dp[x][y] + 1){\\n                        \\n                        dp[xx][yy] = dp[x][y] + 1 ;\\n                        q.push({xx,yy}) ;\\n                    }\\n                }\\n            }\\n        }\\n        \\n    }\\n    \\n    // void print(){\\n    //     for(int i = 0 ; i < r; ++i ){\\n    //         for(int j = 0 ; j < c ; ++j ){\\n    //             cout << dp[i][j] << \" \" ;\\n    //         }cout << endl ;\\n    //     }\\n    // }\\n    \\n    int longestIncreasingPath(vector<vector<int>>& grid) {\\n        r = grid.size() , c = grid[0].size() ;\\n        dp.resize(r,vector<int>(c,1)) ;\\n        \\n        for(int i = 0 ; i < r ; ++i )\\n            for(int j = 0 ; j < c ; ++j ) \\n                bfs(i,j,grid) ;\\n        \\n        int ans = -1;\\n        // print() ;\\n        for(int i = 0 ; i < r ; ++i) ans = max(ans,*max_element(begin(dp[i]),end(dp[i]))) ;\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2247239,
                "title": "c-recursion-memoization-dp-99-95-faster",
                "content": "**RECURSION**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\t\\n\\t\\tint solve(int i,int j,vector<vector<int>>& matrix,int n,int m,int last){\\n\\t\\t\\tif(i<0 || i>=n || j<0 || j>=m) return 0;\\n\\t\\t\\t\\n\\t\\t\\tif(last >= matrix[i][j]) return 0;\\n\\t\\t\\t\\n\\t\\t\\tint up = 1 + solve(i-1,j,matrix,n,m,matrix[i][j]);\\n\\t\\t\\tint down = 1 + solve(i+1,j,matrix,n,m,matrix[i][j]);\\n\\t\\t\\tint right = 1 + solve(i,j+1,matrix,n,m,matrix[i][j]);\\n\\t\\t\\tint left = 1 + solve(i,j-1,matrix,n,m,matrix[i][j]);\\n\\t\\t\\t\\n\\t\\t\\treturn max(up,max(down,max(left,right)));\\n\\t\\t}\\n\\t\\t\\n\\t\\tint longestIncreasingPath(vector<vector<int>>& matrix) {\\n\\t\\t\\tint maxi = -1e9;\\n\\t\\t\\tint n=matrix.size(),m=matrix[0].size();\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tfor(int j=0;j<m;j++){\\n\\t\\t\\t\\t\\tmaxi = max(maxi,solve(i,j,matrix,n,m,-1));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn maxi;\\n\\t\\t}\\n\\t};\\n\\t\\n**MEMOIZATION**\\n\\n\\tclass Solution {\\n\\tpublic:\\n    \\n\\t\\tint solve(int i,int j,vector<vector<int>>& matrix,int n,int m,int last,vector<vector<int>>& dp){\\n\\t\\t\\tif(i<0 || i>=n || j<0 || j>=m) return 0;\\n\\t\\t\\t\\n\\t\\t\\tif(last >= matrix[i][j]) return 0;\\n\\t\\t\\tif(dp[i][j]!=-1) return dp[i][j];\\n\\t\\t\\tint up = 1 + solve(i-1,j,matrix,n,m,matrix[i][j],dp);\\n\\t\\t\\tint down = 1 + solve(i+1,j,matrix,n,m,matrix[i][j],dp);\\n\\t\\t\\tint right = 1 + solve(i,j+1,matrix,n,m,matrix[i][j],dp);\\n\\t\\t\\tint left = 1 + solve(i,j-1,matrix,n,m,matrix[i][j],dp);\\n\\t\\t\\t\\n\\t\\t\\treturn dp[i][j] = max(up,max(down,max(left,right)));\\n\\t\\t}\\n\\t\\t\\n\\t\\tint longestIncreasingPath(vector<vector<int>>& matrix) {\\n\\t\\t\\tint maxi = -1e9;\\n\\t\\t\\tint n=matrix.size(),m=matrix[0].size();\\n\\t\\t\\tvector<vector<int>> dp(n,vector<int>(m,-1));\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tfor(int j=0;j<m;j++){\\n\\t\\t\\t\\t\\tmaxi = max(maxi,solve(i,j,matrix,n,m,-1,dp));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn maxi;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\t\\n\\t\\tint solve(int i,int j,vector<vector<int>>& matrix,int n,int m,int last){\\n\\t\\t\\tif(i<0 || i>=n || j<0 || j>=m) return 0;\\n\\t\\t\\t\\n\\t\\t\\tif(last >= matrix[i][j]) return 0;\\n\\t\\t\\t\\n\\t\\t\\tint up = 1 + solve(i-1,j,matrix,n,m,matrix[i][j]);\\n\\t\\t\\tint down = 1 + solve(i+1,j,matrix,n,m,matrix[i][j]);\\n\\t\\t\\tint right = 1 + solve(i,j+1,matrix,n,m,matrix[i][j]);\\n\\t\\t\\tint left = 1 + solve(i,j-1,matrix,n,m,matrix[i][j]);\\n\\t\\t\\t\\n\\t\\t\\treturn max(up,max(down,max(left,right)));\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2182886,
                "title": "13ms-concise-dfs-with-memoization-java-solution",
                "content": "\\n\\t \\n\\t class Solution {\\n    \\n     public int longestIncreasingPath(int[][] matrix) {\\n        \\n       int dp[][] = new int[matrix.length][matrix[0].length];\\n        int lis=Integer.MIN_VALUE;\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                int ans = solution(i,j,matrix,-1,dp);\\n                lis=Math.max(lis,ans);\\n               \\n            }\\n        }\\n        return lis;\\n        \\n    }\\n    \\n    public int solution(int i,int j,int[][] matrix,int prev,int dp[][]){\\n        \\n        if(i>=matrix.length || j>=matrix[0].length || i<0 || j<0 \\n           || matrix[i][j]<=prev)\\n            return 0;\\n        \\n        \\n        if(dp[i][j]!=0)//if this cell has already been accounted and computed for before,then directly return the value\\n            return dp[i][j];\\n        \\n        int down = solution(i+1,j,matrix,matrix[i][j],dp);//recursion for downward direction\\n        \\n        \\n        int left = solution(i,j-1,matrix,matrix[i][j],dp);////recursion for left direction\\n        \\n        \\n        int right = solution(i,j+1,matrix,matrix[i][j],dp);//recursion for right direction\\n        \\n        \\n        int up  = solution(i-1,j,matrix,matrix[i][j],dp);//recursion for up direction\\n        \\n        \\n        int max = Math.max(down,Math.max(left,Math.max(right,up))) + 1;//compute the maximum of strictly increasing sequence lengths from all directions and add 1 to it so as to count the current cell too\\n        \\n        \\n        \\n        dp[i][j] = max;//store the computed max in a memo/dp structure so that we dont recompute the cell multiple times\\n      \\n  \\n        return max;\\n        \\n       \\n        \\n    }\\n    }",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    \\n     public int longestIncreasingPath(int[][] matrix) {\\n        \\n       int dp[][] = new int[matrix.length][matrix[0].length];\\n        int lis=Integer.MIN_VALUE;\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                int ans = solution(i,j,matrix,-1,dp);\\n                lis=Math.max(lis,ans);\\n               \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2158375,
                "title": "c-dp-memoization",
                "content": "**SOLUTION USING DP(Memoization)**\\n\\n```\\nclass Solution {\\n    int dp[201][201];\\nprivate:\\n    int Find(int count, int i, int j, vector<vector<int>> &matrix) {\\n        int n = matrix[0].size();\\n        int m = matrix.size();\\n        count++;\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        //Going to the right\\n        if((j + 1) >= 0 && (j + 1) < n && matrix[i][j + 1] > matrix[i][j])\\n            count = max(count, 1 + Find(0, i, j + 1, matrix));\\n        \\n        //Going to the left\\n        if((j - 1) >= 0 && (j - 1) < n && matrix[i][j - 1] > matrix[i][j])\\n            count = max(count, 1 + Find(0, i, j - 1, matrix));\\n        \\n        //Going up\\n        if((i - 1) >= 0 && (i - 1) < m && matrix[i - 1][j] > matrix[i][j])\\n            count = max(count, 1 + Find(0, i - 1, j, matrix));\\n        \\n        //Going down\\n        if((i + 1) >= 0 && (i + 1) < m && matrix[i + 1][j] > matrix[i][j])\\n            count = max(count, 1 + Find(0, i + 1, j, matrix));\\n        \\n        return dp[i][j] = count;\\n    }\\n    \\npublic:\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n = matrix[0].size();\\n        int m = matrix.size();\\n        int max_length = INT_MIN;\\n        \\n        memset(dp, -1, sizeof dp);\\n        \\n        for(int i = 0; i < m; ++i)\\n            for(int j = 0; j < n; ++j)\\n                max_length = max(max_length, Find(0, i, j, matrix));\\n    \\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j)\\n                cout << dp[i][j] << \" \";\\n            cout << endl;\\n        }\\n        \\n        return max_length;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dp[201][201];\\nprivate:\\n    int Find(int count, int i, int j, vector<vector<int>> &matrix) {\\n        int n = matrix[0].size();\\n        int m = matrix.size();\\n        count++;\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        //Going to the right\\n        if((j + 1) >= 0 && (j + 1) < n && matrix[i][j + 1] > matrix[i][j])\\n            count = max(count, 1 + Find(0, i, j + 1, matrix));\\n        \\n        //Going to the left\\n        if((j - 1) >= 0 && (j - 1) < n && matrix[i][j - 1] > matrix[i][j])\\n            count = max(count, 1 + Find(0, i, j - 1, matrix));\\n        \\n        //Going up\\n        if((i - 1) >= 0 && (i - 1) < m && matrix[i - 1][j] > matrix[i][j])\\n            count = max(count, 1 + Find(0, i - 1, j, matrix));\\n        \\n        //Going down\\n        if((i + 1) >= 0 && (i + 1) < m && matrix[i + 1][j] > matrix[i][j])\\n            count = max(count, 1 + Find(0, i + 1, j, matrix));\\n        \\n        return dp[i][j] = count;\\n    }\\n    \\npublic:\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n = matrix[0].size();\\n        int m = matrix.size();\\n        int max_length = INT_MIN;\\n        \\n        memset(dp, -1, sizeof dp);\\n        \\n        for(int i = 0; i < m; ++i)\\n            for(int j = 0; j < n; ++j)\\n                max_length = max(max_length, Find(0, i, j, matrix));\\n    \\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j)\\n                cout << dp[i][j] << \" \";\\n            cout << endl;\\n        }\\n        \\n        return max_length;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2139752,
                "title": "intution-for-the-porblem-faster-than-96-64-of-java-online-submissions",
                "content": "Intution for the problem :\\n\\n**Main pick of this problem is to under that once you move from cell i,j to cell l,m you can never reach the cell i,j.**\\n\\nLet this sink in. \\n\\nWhy above statement is true? SInce we are looking from an stricly increasing path, that means if we have moved from cell i,j to l,m that mean value at l,m is greater then value at i,j. So when we will be exploring l,m we wont pick i,j beacuse its value is less then l,m.\\n\\n\\nRest of the code is plain dfs with along with that we are also storing intermidiate results.\\n\\n```\\nclass Solution {\\n    public int longestIncreasingPath(int[][] matrix) {\\n        if(matrix.length==0)\\n             return 0;\\n        \\n        int dp[][] = new int[matrix.length][matrix[0].length];\\n        \\n        int max = 0;\\n        \\n        for(int i=0;i<matrix.length;i++) {\\n            for(int j=0;j<matrix[0].length;j++) {\\n                int distance = dfs(i,j,dp,matrix);\\n                max = Math.max(distance,max);\\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    \\n    int dfs(int i,int j,int dp[][],int matrix[][]) {\\n        if(dp[i][j]!=0) {\\n            return dp[i][j];\\n        }else {\\n            int left=0,right=0,down=0,up=0;\\n            \\n            if(i-1>=0 && matrix[i-1][j] > matrix[i][j]) {\\n                up = 1 + dfs(i-1,j,dp,matrix);\\n            }\\n            if(i+1<matrix.length && matrix[i+1][j]>matrix[i][j]) {\\n                down = 1 + dfs(i+1,j,dp,matrix);\\n            }\\n            if(j-1>=0 && matrix[i][j-1] > matrix[i][j]) {\\n                left = 1 + dfs(i,j-1,dp,matrix);\\n            }\\n            if(j+1<matrix[0].length && matrix[i][j+1]>matrix[i][j]) {\\n                right = 1 + dfs(i,j+1,dp,matrix);\\n            }\\n            \\n            dp[i][j] = Math.max(1,Math.max(Math.max(left,right),Math.max(up,down)));\\n        }\\n      return dp[i][j];\\n    }\\n}\\n```\\n\\nCheers~~~\\n\\nPlease upvote if you like the solution.\\n\\n\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int longestIncreasingPath(int[][] matrix) {\\n        if(matrix.length==0)\\n             return 0;\\n        \\n        int dp[][] = new int[matrix.length][matrix[0].length];\\n        \\n        int max = 0;\\n        \\n        for(int i=0;i<matrix.length;i++) {\\n            for(int j=0;j<matrix[0].length;j++) {\\n                int distance = dfs(i,j,dp,matrix);\\n                max = Math.max(distance,max);\\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    \\n    int dfs(int i,int j,int dp[][],int matrix[][]) {\\n        if(dp[i][j]!=0) {\\n            return dp[i][j];\\n        }else {\\n            int left=0,right=0,down=0,up=0;\\n            \\n            if(i-1>=0 && matrix[i-1][j] > matrix[i][j]) {\\n                up = 1 + dfs(i-1,j,dp,matrix);\\n            }\\n            if(i+1<matrix.length && matrix[i+1][j]>matrix[i][j]) {\\n                down = 1 + dfs(i+1,j,dp,matrix);\\n            }\\n            if(j-1>=0 && matrix[i][j-1] > matrix[i][j]) {\\n                left = 1 + dfs(i,j-1,dp,matrix);\\n            }\\n            if(j+1<matrix[0].length && matrix[i][j+1]>matrix[i][j]) {\\n                right = 1 + dfs(i,j+1,dp,matrix);\\n            }\\n            \\n            dp[i][j] = Math.max(1,Math.max(Math.max(left,right),Math.max(up,down)));\\n        }\\n      return dp[i][j];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2054390,
                "title": "cache-easy-to-understand-javascript-typescript-solution-with-explanation-comments",
                "content": "upvote if it helps \\uD83D\\uDE43\\nRuntime: 147 ms\\nMemory Usage: 47.5 MB\\n```\\nfunction longestIncreasingPath(M) {\\n  // init variables\\n  // R for rows number\\n  // C for columns number\\n  // ans for answer\\n  // map for our cache. initial value \\u2013 [[], [], [], [], [], ...]\\n  const R = M.length\\n  const C = M[0].length\\n  let ans = 0\\n  const map = new Array(R).fill(null).map(() => new Array(C))\\n  \\n  // for every cell call dfs function with current position\\n  // we just go through our matrix and trying to get maximum answer\\n  for (let i = 0; i < R; i++) {\\n    for (let j = 0; j < C; j++) {\\n      ans = Math.max(ans, dfs(i, j))\\n    }\\n  }\\n  \\n  return ans\\n  \\n  \\n  function dfs(i, j) {\\n    // if we already have this cell in our map/cache - return it\\n    const curMapValue = map[i][j]\\n    if (curMapValue) return curMapValue\\n    \\n\\t// call dfs function with all possible directions\\n\\t// if we\\'ll meet cell that we\\'ve already seen - return it (see prev comment)\\n\\t// simplified - (1) && (2) ? (3) : (4)\\n\\t// 1 - if in matrix range\\n\\t// 2 - and less than cur value\\n\\t// 3 - then call dfs in this direction\\n\\t// 4 - else return 0. we\\'ll ignore it\\n    const v = M[i][j]\\n    const right = i < R-1 && M[i+1][j] < v ? dfs(i+1, j) : 0\\n    const left = i > 0 && M[i-1][j] < v ? dfs(i-1, j) : 0\\n    const bottom = j < C-1 && M[i][j+1] < v ? dfs(i, j+1) : 0\\n    const top = j > 0 && M[i][j-1] < v ? dfs(i, j-1) : 0\\n    \\n\\t// get max value around our cell and set it in our map/cache\\n\\t// and add 1 cuz we found next step of our path\\n    map[i][j] = 1 + Math.max(right, left, bottom, top)\\n    return map[i][j]\\n  }\\n};\\n  ```\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction longestIncreasingPath(M) {\\n  // init variables\\n  // R for rows number\\n  // C for columns number\\n  // ans for answer\\n  // map for our cache. initial value \\u2013 [[], [], [], [], [], ...]\\n  const R = M.length\\n  const C = M[0].length\\n  let ans = 0\\n  const map = new Array(R).fill(null).map(() => new Array(C))\\n  \\n  // for every cell call dfs function with current position\\n  // we just go through our matrix and trying to get maximum answer\\n  for (let i = 0; i < R; i++) {\\n    for (let j = 0; j < C; j++) {\\n      ans = Math.max(ans, dfs(i, j))\\n    }\\n  }\\n  \\n  return ans\\n  \\n  \\n  function dfs(i, j) {\\n    // if we already have this cell in our map/cache - return it\\n    const curMapValue = map[i][j]\\n    if (curMapValue) return curMapValue\\n    \\n\\t// call dfs function with all possible directions\\n\\t// if we\\'ll meet cell that we\\'ve already seen - return it (see prev comment)\\n\\t// simplified - (1) && (2) ? (3) : (4)\\n\\t// 1 - if in matrix range\\n\\t// 2 - and less than cur value\\n\\t// 3 - then call dfs in this direction\\n\\t// 4 - else return 0. we\\'ll ignore it\\n    const v = M[i][j]\\n    const right = i < R-1 && M[i+1][j] < v ? dfs(i+1, j) : 0\\n    const left = i > 0 && M[i-1][j] < v ? dfs(i-1, j) : 0\\n    const bottom = j < C-1 && M[i][j+1] < v ? dfs(i, j+1) : 0\\n    const top = j > 0 && M[i][j-1] < v ? dfs(i, j-1) : 0\\n    \\n\\t// get max value around our cell and set it in our map/cache\\n\\t// and add 1 cuz we found next step of our path\\n    map[i][j] = 1 + Math.max(right, left, bottom, top)\\n    return map[i][j]\\n  }\\n};\\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 2054173,
                "title": "why-dp-is-applicable-here",
                "content": "/*\\n->The brute-force way to solve this problem is by doing the dfs to find the longest increasing path in matrix starting from each point in the matrix. \\n\\n->Here while doing the dfs we don\\'t need to keep track of visited cells in the matrix. Because the cells in the matrix are connected as DAG(directed acyclic graph). Hence we are never gonna enter a cycle, thus won\\'t lead to infinite loop of dfs.\\n\\n->Also if we observe properly, while doing the dfs we are doing the recalculation of some of the subproblems. Hence we can think of applying memoization. But generally when we have to visit the cells in 4 directions, we can\\'t memoize the solution of subproblem because solution might be interdependent on each other and we might enter a deadlock. Consider the following example of 2X2 matrix example.\\n\\t\\t\\t\\t____\\n\\t\\t\\t\\n\\t\\t\\t\\t|1 2 |            -> here dp[0][0] depends on dp[0][1] and dp[1][0]\\n\\t\\t\\t\\t|3 4 |             but dp[0][1] depends on dp[0][0] and dp[1][1]. \\n\\t\\t\\t\\t\\t\\t\\t\\tthus, dp[0][0] and dp[0][1] enters in deadlock.\\n\\nBut if we consider the current problem, we have DAG. Thus we won\\'t enter in the deadlock because we will only look at the neighbours which are greater than current cell, thus if current cell ans depends on neighbouring cell then neighbouring cell ans won\\'t depend on current cell, because we want stricly increasing path. If we consider the above example of 2X2.\\n        dp[0][0] depends on dp[1][0] and dp[0][1]. because mat[1][0] and mat[0][1] greater than mat[0][0]\\n        dp[0][1] depends only on dp[1][1]. Thus no deadlock is present.\\n        \\nThus this is rare of a question where we are able to memoize our dfs solution because of the property of DAG(Directed acyclic graph).\\n\\nKey points learnt from this question:\\n-> if we have DAG, then no need to keep track of visited nodes/cells. Because we are never gonna enter infinte loop of dfs due to absence of cycle.\\n->If we have DAG and if we have overlapping subproblems then we can memoize dfs solution\\n\\n*/\\n\\n\\n\\n\\nint dir[4][2]={{-1,0},{1,0},{0,1},{0,-1}};\\nclass Solution {\\npublic:\\n\\n    int dfs(int i,int j,vector<vector<int>> &matrix, vector<vector<int>> &dp){\\n        if(dp[i][j]>0) return dp[i][j];\\n        \\n        dp[i][j]=1;\\n        for(int k=0;k<4;k++){\\n            int ni=i+dir[k][0];\\n            int nj=j+dir[k][1];\\n            \\n            if(ni>=0 && nj>=0 && ni<matrix.size() && nj<matrix[0].size() && matrix[ni][nj] > matrix[i][j]){\\n                dp[i][j]=max(dp[i][j],1+dfs(ni,nj,matrix,dp));\\n            }\\n        }\\n        return dp[i][j];\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        \\n        vector<vector<int>> dp(matrix.size(),vector<int>(matrix[0].size(),-1));\\n        \\n        int ans=1;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                ans=max(ans,dfs(i,j,matrix,dp));\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int dfs(int i,int j,vector<vector<int>> &matrix, vector<vector<int>> &dp){\\n        if(dp[i][j]>0) return dp[i][j];\\n        \\n        dp[i][j]=1;\\n        for(int k=0;k<4;k++){\\n            int ni=i+dir[k][0];\\n            int nj=j+dir[k][1];\\n            \\n            if(ni>=0 && nj>=0 && ni<matrix.size() && nj<matrix[0].size() && matrix[ni][nj] > matrix[i][j]){\\n                dp[i][j]=max(dp[i][j],1+dfs(ni,nj,matrix,dp));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2054073,
                "title": "simple-dfs-does-it-all",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = 1;\\n    int dx[4] = {0,0,-1,1};\\n    int dy[4] = {-1,1,0,0};\\n    int dp[201][201];\\n    Solution() {\\n        memset(dp,-1,sizeof(dp));\\n    }\\n    bool isvalid(int row, int col, int m, int n,vector<vector<int>>& matrix) {\\n        return row>=0 && row<m && col>=0 && col<n && matrix[row][col]!=0;\\n    }\\n    int dfs(int row, int col, int m, int n, vector<vector<int>>& matrix) {\\n        // int val = matrix[row][col];\\n        // matrix[row][col] = 0;\\n        if(dp[row][col]!=-1) {\\n            return dp[row][col];\\n        }\\n        int count = 1;\\n        for(int i =0;i<4;i++) {\\n            int x = row + dx[i];\\n            int y = col + dy[i];\\n            if(isvalid(x,y,m,n,matrix) && matrix[x][y]>matrix[row][col]) {\\n                count = max(count, 1+dfs(x,y,m,n,matrix));\\n            }\\n        }\\n        // matrix[row][col] = val;\\n        return dp[row][col] = count;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j = 0;j<n;j++) {\\n                if(isvalid(i,j,m,n,matrix)) {\\n                    ans = max(ans,dfs(i,j,m,n,matrix));\\n                }\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 1;\\n    int dx[4] = {0,0,-1,1};\\n    int dy[4] = {-1,1,0,0};\\n    int dp[201][201];\\n    Solution() {\\n        memset(dp,-1,sizeof(dp));\\n    }\\n    bool isvalid(int row, int col, int m, int n,vector<vector<int>>& matrix) {\\n        return row>=0 && row<m && col>=0 && col<n && matrix[row][col]!=0;\\n    }\\n    int dfs(int row, int col, int m, int n, vector<vector<int>>& matrix) {\\n        // int val = matrix[row][col];\\n        // matrix[row][col] = 0;\\n        if(dp[row][col]!=-1) {\\n            return dp[row][col];\\n        }\\n        int count = 1;\\n        for(int i =0;i<4;i++) {\\n            int x = row + dx[i];\\n            int y = col + dy[i];\\n            if(isvalid(x,y,m,n,matrix) && matrix[x][y]>matrix[row][col]) {\\n                count = max(count, 1+dfs(x,y,m,n,matrix));\\n            }\\n        }\\n        // matrix[row][col] = val;\\n        return dp[row][col] = count;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j = 0;j<n;j++) {\\n                if(isvalid(i,j,m,n,matrix)) {\\n                    ans = max(ans,dfs(i,j,m,n,matrix));\\n                }\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2053869,
                "title": "python-solution-with-dfs-and-memoization",
                "content": "```\\nclass Solution:\\n    from functools import lru_cache\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        \\n        self.height = len(matrix)\\n        self.width = len(matrix[0])\\n        self.grid = matrix\\n        \\n        return max([self.dfs(x, y) for x in range(self.height) for y in range(self.width)])\\n        \\n        \\n    \\n    @lru_cache(maxsize = None)\\n    def dfs(self, x, y, distance = 1):\\n        \\n        new_dist = distance\\n        \\n        for x_del, y_del in [(-1,0) , (0,1) , (1,0) , (0,-1)]:\\n            x_new, y_new = x+x_del, y+y_del\\n            \\n            if 0 <= x_new < self.height and 0 <= y_new <self.width and self.grid[x_new][y_new] > self.grid[x][y]:\\n\\n                new_dist = max(new_dist, distance + self.dfs(x_new, y_new, distance))\\n             \\n        return new_dist\\n```",
                "solutionTags": [
                    "Python",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    from functools import lru_cache\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        \\n        self.height = len(matrix)\\n        self.width = len(matrix[0])\\n        self.grid = matrix\\n        \\n        return max([self.dfs(x, y) for x in range(self.height) for y in range(self.width)])\\n        \\n        \\n    \\n    @lru_cache(maxsize = None)\\n    def dfs(self, x, y, distance = 1):\\n        \\n        new_dist = distance\\n        \\n        for x_del, y_del in [(-1,0) , (0,1) , (1,0) , (0,-1)]:\\n            x_new, y_new = x+x_del, y+y_del\\n            \\n            if 0 <= x_new < self.height and 0 <= y_new <self.width and self.grid[x_new][y_new] > self.grid[x][y]:\\n\\n                new_dist = max(new_dist, distance + self.dfs(x_new, y_new, distance))\\n             \\n        return new_dist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2053861,
                "title": "c-dp-46ms",
                "content": "```\\nclass Solution {\\n    // Possible directions\\n    int X[4] = {0,0,1,-1};\\n    int Y[4] = {1,-1,0,0};\\n    // DP array   // Globaly declared array are intialized with ZEROs\\n    int dp[207][207];\\n    \\nprivate:\\n    int find(vector<vector<int>> &m1 , int x , int y , int row , int col){\\n        if(dp[x][y])    return dp[x][y];\\n        int ans = 1;\\n        for(int i=0 ; i<4 ; i++){\\n            // New_Points\\n            int dx = x + X[i];\\n            int dy = y + Y[i];\\n            \\n            // Checking out_of_bound and valid_move   (Next > Current)\\n            if(dx>=0 and dy>=0 and dx<row and dy<col){\\n                if( m1[dx][dy] > m1[x][y] ){\\n                    ans = max(ans , 1 + find(m1 , dx , dy , row , col));\\n                }\\n            }\\n        }\\n        return dp[x][y] = ans;\\n    }\\n    \\npublic:\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int ans = 0;\\n        int n = matrix.size() , m = matrix[0].size();\\n        \\n\\t\\t// Checking for all indices\\n        for(int i=0 ; i<n ; i++){\\n            for(int j=0 ; j<m ; j++){\\n                ans = max(ans , find(matrix , i , j , n , m));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    // Possible directions\\n    int X[4] = {0,0,1,-1};\\n    int Y[4] = {1,-1,0,0};\\n    // DP array   // Globaly declared array are intialized with ZEROs\\n    int dp[207][207];\\n    \\nprivate:\\n    int find(vector<vector<int>> &m1 , int x , int y , int row , int col){\\n        if(dp[x][y])    return dp[x][y];\\n        int ans = 1;\\n        for(int i=0 ; i<4 ; i++){\\n            // New_Points\\n            int dx = x + X[i];\\n            int dy = y + Y[i];\\n            \\n            // Checking out_of_bound and valid_move   (Next > Current)\\n            if(dx>=0 and dy>=0 and dx<row and dy<col){\\n                if( m1[dx][dy] > m1[x][y] ){\\n                    ans = max(ans , 1 + find(m1 , dx , dy , row , col));\\n                }\\n            }\\n        }\\n        return dp[x][y] = ans;\\n    }\\n    \\npublic:\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int ans = 0;\\n        int n = matrix.size() , m = matrix[0].size();\\n        \\n\\t\\t// Checking for all indices\\n        for(int i=0 ; i<n ; i++){\\n            for(int j=0 ; j<m ; j++){\\n                ans = max(ans , find(matrix , i , j , n , m));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2053472,
                "title": "c-solution-not-like-a-hard-q",
                "content": "```\\nclass Solution {\\npublic:\\n       int solve(vector<vector<int>>& grid,vector<vector<int>>&dp,int i,int j, int prev, vector<vector<int>>& visited){\\n        if (i < 0 || j < 0 ||j >= grid[0].size() || i >= grid.size() || visited[i][j]==-1 || grid[i][j] <= prev ) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        visited[i][j] = -1;\\n        int left  = solve ( grid , dp , i+1,j , grid[i][j] , visited) ;\\n        int down  = solve ( grid , dp , i-1,j , grid[i][j] , visited) ;\\n        int right = solve ( grid , dp , i,j+1 , grid[i][j] , visited) ;\\n        int up    = solve ( grid , dp , i,j-1 , grid[i][j] , visited) ;\\n           \\n        visited[i][j] = 0;\\n           \\n        return dp[i][j] = 1 + max(max(left,right),max(up,down));\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& grid) {\\n      \\n      vector<vector<int>> dp(grid.size(), vector<int>(grid[0].size(),-1));\\n      vector<vector<int>> visited(grid.size(), vector<int>(grid[0].size(),0));\\n        \\n      int maxA = 1;\\n       for (int i = 0; i < grid.size(); i++)\\n       {\\n         for (int j = 0; j < grid[0].size(); j++)\\n         {\\n           maxA = max(maxA,solve(grid,dp,i,j,-1,visited));\\n         }\\n       }\\n        return maxA;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Graph",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n       int solve(vector<vector<int>>& grid,vector<vector<int>>&dp,int i,int j, int prev, vector<vector<int>>& visited){\\n        if (i < 0 || j < 0 ||j >= grid[0].size() || i >= grid.size() || visited[i][j]==-1 || grid[i][j] <= prev ) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        visited[i][j] = -1;\\n        int left  = solve ( grid , dp , i+1,j , grid[i][j] , visited) ;\\n        int down  = solve ( grid , dp , i-1,j , grid[i][j] , visited) ;\\n        int right = solve ( grid , dp , i,j+1 , grid[i][j] , visited) ;\\n        int up    = solve ( grid , dp , i,j-1 , grid[i][j] , visited) ;\\n           \\n        visited[i][j] = 0;\\n           \\n        return dp[i][j] = 1 + max(max(left,right),max(up,down));\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& grid) {\\n      \\n      vector<vector<int>> dp(grid.size(), vector<int>(grid[0].size(),-1));\\n      vector<vector<int>> visited(grid.size(), vector<int>(grid[0].size(),0));\\n        \\n      int maxA = 1;\\n       for (int i = 0; i < grid.size(); i++)\\n       {\\n         for (int j = 0; j < grid[0].size(); j++)\\n         {\\n           maxA = max(maxA,solve(grid,dp,i,j,-1,visited));\\n         }\\n       }\\n        return maxA;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2053339,
                "title": "those-who-are-afraid-of-recursion-don-t-use-it",
                "content": "it looks like i\\'m short on time and  can\\'t explain\\n```class Solution {\\n    public int longestIncreasingPath(int[][] mat) {\\n        int dx[]={1,-1,0,0};\\n        int dy[]={0,0,-1,1};\\n        Queue<int[]>p=new LinkedList<>();\\n        if(mat.length==0||mat[0].length==0)return 0;\\n        \\n        int ans=1;\\n        int dp[][]=new int [mat.length][mat[0].length];\\n        for(int i=0;i<mat.length;i++){\\n            for(int j=0;j<mat[0].length;j++){\\n                if(dp[i][j]!=0)continue;\\n                else{\\n                    int a[]={i,j};\\n                    p.add(a);\\n                    int c=1;\\n                    while(!p.isEmpty()){\\n                        int n=p.size();\\n                        c++;\\n                        for(int t=0;t<n;t++){\\n                            for(int l=0;l<4;l++){\\n                                int x=p.peek()[0]+dx[l];\\n                                int y=p.peek()[1]+dy[l];\\n                                if(x>=0&&y>=0&&x<mat.length&&y<mat[0].length&&mat[x][y]>mat[p.peek()[0]][p.peek()[1]]&&c>dp[x][y]){\\n                                    dp[x][y]=c;\\n                                    ans=Math.max(c,ans);\\n                                    int b[]={x,y};\\n                                    p.add(b);\\n                                }\\n                            }\\n                            p.poll();\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Memoization"
                ],
                "code": "```class Solution {\\n    public int longestIncreasingPath(int[][] mat) {\\n        int dx[]={1,-1,0,0};\\n        int dy[]={0,0,-1,1};\\n        Queue<int[]>p=new LinkedList<>();\\n        if(mat.length==0||mat[0].length==0)return 0;\\n        \\n        int ans=1;\\n        int dp[][]=new int [mat.length][mat[0].length];\\n        for(int i=0;i<mat.length;i++){\\n            for(int j=0;j<mat[0].length;j++){\\n                if(dp[i][j]!=0)continue;\\n                else{\\n                    int a[]={i,j};\\n                    p.add(a);\\n                    int c=1;\\n                    while(!p.isEmpty()){\\n                        int n=p.size();\\n                        c++;\\n                        for(int t=0;t<n;t++){\\n                            for(int l=0;l<4;l++){\\n                                int x=p.peek()[0]+dx[l];\\n                                int y=p.peek()[1]+dy[l];\\n                                if(x>=0&&y>=0&&x<mat.length&&y<mat[0].length&&mat[x][y]>mat[p.peek()[0]][p.peek()[1]]&&c>dp[x][y]){\\n                                    dp[x][y]=c;\\n                                    ans=Math.max(c,ans);\\n                                    int b[]={x,y};\\n                                    p.add(b);\\n                                }\\n                            }\\n                            p.poll();\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1569080,
                "content": [
                    {
                        "username": "rmn",
                        "content": "It's pretty straightforward Dfs + memoization. You don't even need to mark cells as seen due to the nature of the problem.\\nI think there are plenty of \"Medium\" rated questions out there that are a lot harder than this one :)"
                    },
                    {
                        "username": "feng3245",
                        "content": "[@cartesPerforees](/cartesPerforees) It is only hard if you believed it is hard and worked the difficulty into the question. Note how there is mention of no looping around... if you took it into account without looking at the property of the path being increasing then you would assume you could not use memoization... which will make this a hard"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Agreed. If this one is marked hard, then at the very least all DP problems should be marked as such, because this is one of the most straight forward DP to figure out"
                    },
                    {
                        "username": "hashdgwhansb",
                        "content": "For those who are having TLE in there memoized DFS, pass the matrix using call by reference rather call by value.\\nIn passing it through call by value it copies that 200 by 200 everytime which increases the time complexity. So pass it call by reference ;)"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "thanks!"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "helpful"
                    },
                    {
                        "username": "Linmuadido",
                        "content": "Hello, everybody:\\n\\nI think the relax-based method, either DP or DFS (or both) , is working fine with the complexity O(mn).\\n\\nIn terms of graph model, the original problem input is a DAG(directed acrylic graph). However \"non-decreasing\" path requires bi-directional edge between neighbors with the same value. That is, the graph is not a DAG anymore.\\n\\nIf the problem changes to longest \"non-decreasing\" instead of \"increasing\" path, anyone thinks it is still doable in O(mn) time? How? Or Why not?"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "In the case of DP only solution. Shouldn\\'t we perform two passes?"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "This should be medium while [Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/description/) should be hard."
                    },
                    {
                        "username": "asirojiddinov96",
                        "content": "i guess in both question logic is pretty same DFS+memo"
                    },
                    {
                        "username": "hlin117",
                        "content": "In the solution, they mention that the naive DFS solution starting from each square is O(2^(n + m)). Can someone explain how they derive this?"
                    },
                    {
                        "username": "aman07",
                        "content": "Hello everyone!, I was just curious as to why this question cannot be solved with BFS? Or maybe it can be solved but it is just too long. I don\\'t know, I am confused. Can anyone explain? Thanks in advance!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "A bit late here but at first glance with BFS you won\\'t be able to use memoization efficiently and hence will end up in TLE."
                    },
                    {
                        "username": "nick_nick_go",
                        "content": "Simple DFS with Memo works"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Naive DFS) [Time Limit Exceeded]\n\n  \n**Approach 2:** (DFS + Memoization) [Accepted]\n\n  \n**Approach 3:** (Peeling Onion) [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "use dfs and little memoization to solve it. go every node and check whethere we are getting maximum node from that point ."
                    },
                    {
                        "username": "littleRainRain",
                        "content": "Is there any way we can print the longest path ? \\nin other words, if we want to return a List<Integer> for the path instead of the length of the path.... how may we do it ?"
                    },
                    {
                        "username": "Decode_Apocalypse",
                        "content": "TO PRINT ALL PATHS\\n\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    vector<vector<int>> mat;\\n\\n    void valid(int x, int y, vector<vector<int>> &path, vector<int> build, int mx){\\n        build.push_back(mat[x][y]);\\n        if(dp[x][y]==mx){\\n            path.push_back(build);\\n            return;\\n        }\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        int X[4]={-1,1,0,0};\\n        int Y[4]={0,0,1,-1};\\n        for(int i=0;i<4;i++){\\n            int newX=x+X[i];\\n            int newY=y+Y[i];\\n            if(newX<n && newY<m && newX>=0 && newY>=0 && dp[newX][newY]==dp[x][y]+1){\\n                valid(newX,newY,path,build,mx);\\n            }\\n        }\\n        build.pop_back();\\n        return;\\n    }\\n\\n    void PRINT(int mx, int n, int m){\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                vector<vector<int>> path;\\n                int x=i;\\n                int y=j;\\n                if(dp[x][y]==1){\\n                    valid(x,y,path,{},mx);\\n                    for(auto p: path){\\n                        for(auto v: p){\\n                            cout<<v<<\"->\";\\n                        }\\n                        cout<<\"END\";\\n                        cout<<endl;\\n                    }\\n                    cout<<endl;\\n                }\\n            }\\n        }\\n    }\\n\\n    bool isSafe(vector<vector<int>> &mat, int x, int y, int n, int m, int prev){\\n        return x>=0 && y>=0 && x<n && y<m && mat[x][y]>prev;\\n    }\\n\\n    int LIP(vector<vector<int>> &mat, int x, int y, int n, int m, int prev){\\n        if(isSafe(mat,x,y,n,m,prev)==false){\\n            return 0;\\n        }\\n        if(dp[x][y]!=-1){\\n            return dp[x][y];\\n        }\\n        int UP=LIP(mat,x-1,y,n,m,mat[x][y]); \\n        int DOWN=LIP(mat,x+1,y,n,m,mat[x][y]);\\n        int RIGHT=LIP(mat,x,y+1,n,m,mat[x][y]);\\n        int LEFT=LIP(mat,x,y-1,n,m,mat[x][y]);\\n        return dp[x][y]=1+max({UP,DOWN,LEFT,RIGHT});\\n    }\\n\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int res=1;\\n        mat=matrix;\\n        memset(dp,-1,sizeof(dp));\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int temp=LIP(matrix,i,j,n,m,INT_MIN);\\n                res=max(res,temp);\\n            }\\n        }\\n        PRINT(res,n,m);\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1570536,
                "content": [
                    {
                        "username": "rmn",
                        "content": "It's pretty straightforward Dfs + memoization. You don't even need to mark cells as seen due to the nature of the problem.\\nI think there are plenty of \"Medium\" rated questions out there that are a lot harder than this one :)"
                    },
                    {
                        "username": "feng3245",
                        "content": "[@cartesPerforees](/cartesPerforees) It is only hard if you believed it is hard and worked the difficulty into the question. Note how there is mention of no looping around... if you took it into account without looking at the property of the path being increasing then you would assume you could not use memoization... which will make this a hard"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Agreed. If this one is marked hard, then at the very least all DP problems should be marked as such, because this is one of the most straight forward DP to figure out"
                    },
                    {
                        "username": "hashdgwhansb",
                        "content": "For those who are having TLE in there memoized DFS, pass the matrix using call by reference rather call by value.\\nIn passing it through call by value it copies that 200 by 200 everytime which increases the time complexity. So pass it call by reference ;)"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "thanks!"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "helpful"
                    },
                    {
                        "username": "Linmuadido",
                        "content": "Hello, everybody:\\n\\nI think the relax-based method, either DP or DFS (or both) , is working fine with the complexity O(mn).\\n\\nIn terms of graph model, the original problem input is a DAG(directed acrylic graph). However \"non-decreasing\" path requires bi-directional edge between neighbors with the same value. That is, the graph is not a DAG anymore.\\n\\nIf the problem changes to longest \"non-decreasing\" instead of \"increasing\" path, anyone thinks it is still doable in O(mn) time? How? Or Why not?"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "In the case of DP only solution. Shouldn\\'t we perform two passes?"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "This should be medium while [Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/description/) should be hard."
                    },
                    {
                        "username": "asirojiddinov96",
                        "content": "i guess in both question logic is pretty same DFS+memo"
                    },
                    {
                        "username": "hlin117",
                        "content": "In the solution, they mention that the naive DFS solution starting from each square is O(2^(n + m)). Can someone explain how they derive this?"
                    },
                    {
                        "username": "aman07",
                        "content": "Hello everyone!, I was just curious as to why this question cannot be solved with BFS? Or maybe it can be solved but it is just too long. I don\\'t know, I am confused. Can anyone explain? Thanks in advance!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "A bit late here but at first glance with BFS you won\\'t be able to use memoization efficiently and hence will end up in TLE."
                    },
                    {
                        "username": "nick_nick_go",
                        "content": "Simple DFS with Memo works"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Naive DFS) [Time Limit Exceeded]\n\n  \n**Approach 2:** (DFS + Memoization) [Accepted]\n\n  \n**Approach 3:** (Peeling Onion) [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "use dfs and little memoization to solve it. go every node and check whethere we are getting maximum node from that point ."
                    },
                    {
                        "username": "littleRainRain",
                        "content": "Is there any way we can print the longest path ? \\nin other words, if we want to return a List<Integer> for the path instead of the length of the path.... how may we do it ?"
                    },
                    {
                        "username": "Decode_Apocalypse",
                        "content": "TO PRINT ALL PATHS\\n\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    vector<vector<int>> mat;\\n\\n    void valid(int x, int y, vector<vector<int>> &path, vector<int> build, int mx){\\n        build.push_back(mat[x][y]);\\n        if(dp[x][y]==mx){\\n            path.push_back(build);\\n            return;\\n        }\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        int X[4]={-1,1,0,0};\\n        int Y[4]={0,0,1,-1};\\n        for(int i=0;i<4;i++){\\n            int newX=x+X[i];\\n            int newY=y+Y[i];\\n            if(newX<n && newY<m && newX>=0 && newY>=0 && dp[newX][newY]==dp[x][y]+1){\\n                valid(newX,newY,path,build,mx);\\n            }\\n        }\\n        build.pop_back();\\n        return;\\n    }\\n\\n    void PRINT(int mx, int n, int m){\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                vector<vector<int>> path;\\n                int x=i;\\n                int y=j;\\n                if(dp[x][y]==1){\\n                    valid(x,y,path,{},mx);\\n                    for(auto p: path){\\n                        for(auto v: p){\\n                            cout<<v<<\"->\";\\n                        }\\n                        cout<<\"END\";\\n                        cout<<endl;\\n                    }\\n                    cout<<endl;\\n                }\\n            }\\n        }\\n    }\\n\\n    bool isSafe(vector<vector<int>> &mat, int x, int y, int n, int m, int prev){\\n        return x>=0 && y>=0 && x<n && y<m && mat[x][y]>prev;\\n    }\\n\\n    int LIP(vector<vector<int>> &mat, int x, int y, int n, int m, int prev){\\n        if(isSafe(mat,x,y,n,m,prev)==false){\\n            return 0;\\n        }\\n        if(dp[x][y]!=-1){\\n            return dp[x][y];\\n        }\\n        int UP=LIP(mat,x-1,y,n,m,mat[x][y]); \\n        int DOWN=LIP(mat,x+1,y,n,m,mat[x][y]);\\n        int RIGHT=LIP(mat,x,y+1,n,m,mat[x][y]);\\n        int LEFT=LIP(mat,x,y-1,n,m,mat[x][y]);\\n        return dp[x][y]=1+max({UP,DOWN,LEFT,RIGHT});\\n    }\\n\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int res=1;\\n        mat=matrix;\\n        memset(dp,-1,sizeof(dp));\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int temp=LIP(matrix,i,j,n,m,INT_MIN);\\n                res=max(res,temp);\\n            }\\n        }\\n        PRINT(res,n,m);\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1566258,
                "content": [
                    {
                        "username": "rmn",
                        "content": "It's pretty straightforward Dfs + memoization. You don't even need to mark cells as seen due to the nature of the problem.\\nI think there are plenty of \"Medium\" rated questions out there that are a lot harder than this one :)"
                    },
                    {
                        "username": "feng3245",
                        "content": "[@cartesPerforees](/cartesPerforees) It is only hard if you believed it is hard and worked the difficulty into the question. Note how there is mention of no looping around... if you took it into account without looking at the property of the path being increasing then you would assume you could not use memoization... which will make this a hard"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Agreed. If this one is marked hard, then at the very least all DP problems should be marked as such, because this is one of the most straight forward DP to figure out"
                    },
                    {
                        "username": "hashdgwhansb",
                        "content": "For those who are having TLE in there memoized DFS, pass the matrix using call by reference rather call by value.\\nIn passing it through call by value it copies that 200 by 200 everytime which increases the time complexity. So pass it call by reference ;)"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "thanks!"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "helpful"
                    },
                    {
                        "username": "Linmuadido",
                        "content": "Hello, everybody:\\n\\nI think the relax-based method, either DP or DFS (or both) , is working fine with the complexity O(mn).\\n\\nIn terms of graph model, the original problem input is a DAG(directed acrylic graph). However \"non-decreasing\" path requires bi-directional edge between neighbors with the same value. That is, the graph is not a DAG anymore.\\n\\nIf the problem changes to longest \"non-decreasing\" instead of \"increasing\" path, anyone thinks it is still doable in O(mn) time? How? Or Why not?"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "In the case of DP only solution. Shouldn\\'t we perform two passes?"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "This should be medium while [Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/description/) should be hard."
                    },
                    {
                        "username": "asirojiddinov96",
                        "content": "i guess in both question logic is pretty same DFS+memo"
                    },
                    {
                        "username": "hlin117",
                        "content": "In the solution, they mention that the naive DFS solution starting from each square is O(2^(n + m)). Can someone explain how they derive this?"
                    },
                    {
                        "username": "aman07",
                        "content": "Hello everyone!, I was just curious as to why this question cannot be solved with BFS? Or maybe it can be solved but it is just too long. I don\\'t know, I am confused. Can anyone explain? Thanks in advance!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "A bit late here but at first glance with BFS you won\\'t be able to use memoization efficiently and hence will end up in TLE."
                    },
                    {
                        "username": "nick_nick_go",
                        "content": "Simple DFS with Memo works"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Naive DFS) [Time Limit Exceeded]\n\n  \n**Approach 2:** (DFS + Memoization) [Accepted]\n\n  \n**Approach 3:** (Peeling Onion) [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "use dfs and little memoization to solve it. go every node and check whethere we are getting maximum node from that point ."
                    },
                    {
                        "username": "littleRainRain",
                        "content": "Is there any way we can print the longest path ? \\nin other words, if we want to return a List<Integer> for the path instead of the length of the path.... how may we do it ?"
                    },
                    {
                        "username": "Decode_Apocalypse",
                        "content": "TO PRINT ALL PATHS\\n\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    vector<vector<int>> mat;\\n\\n    void valid(int x, int y, vector<vector<int>> &path, vector<int> build, int mx){\\n        build.push_back(mat[x][y]);\\n        if(dp[x][y]==mx){\\n            path.push_back(build);\\n            return;\\n        }\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        int X[4]={-1,1,0,0};\\n        int Y[4]={0,0,1,-1};\\n        for(int i=0;i<4;i++){\\n            int newX=x+X[i];\\n            int newY=y+Y[i];\\n            if(newX<n && newY<m && newX>=0 && newY>=0 && dp[newX][newY]==dp[x][y]+1){\\n                valid(newX,newY,path,build,mx);\\n            }\\n        }\\n        build.pop_back();\\n        return;\\n    }\\n\\n    void PRINT(int mx, int n, int m){\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                vector<vector<int>> path;\\n                int x=i;\\n                int y=j;\\n                if(dp[x][y]==1){\\n                    valid(x,y,path,{},mx);\\n                    for(auto p: path){\\n                        for(auto v: p){\\n                            cout<<v<<\"->\";\\n                        }\\n                        cout<<\"END\";\\n                        cout<<endl;\\n                    }\\n                    cout<<endl;\\n                }\\n            }\\n        }\\n    }\\n\\n    bool isSafe(vector<vector<int>> &mat, int x, int y, int n, int m, int prev){\\n        return x>=0 && y>=0 && x<n && y<m && mat[x][y]>prev;\\n    }\\n\\n    int LIP(vector<vector<int>> &mat, int x, int y, int n, int m, int prev){\\n        if(isSafe(mat,x,y,n,m,prev)==false){\\n            return 0;\\n        }\\n        if(dp[x][y]!=-1){\\n            return dp[x][y];\\n        }\\n        int UP=LIP(mat,x-1,y,n,m,mat[x][y]); \\n        int DOWN=LIP(mat,x+1,y,n,m,mat[x][y]);\\n        int RIGHT=LIP(mat,x,y+1,n,m,mat[x][y]);\\n        int LEFT=LIP(mat,x,y-1,n,m,mat[x][y]);\\n        return dp[x][y]=1+max({UP,DOWN,LEFT,RIGHT});\\n    }\\n\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int res=1;\\n        mat=matrix;\\n        memset(dp,-1,sizeof(dp));\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int temp=LIP(matrix,i,j,n,m,INT_MIN);\\n                res=max(res,temp);\\n            }\\n        }\\n        PRINT(res,n,m);\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1728744,
                "content": [
                    {
                        "username": "rmn",
                        "content": "It's pretty straightforward Dfs + memoization. You don't even need to mark cells as seen due to the nature of the problem.\\nI think there are plenty of \"Medium\" rated questions out there that are a lot harder than this one :)"
                    },
                    {
                        "username": "feng3245",
                        "content": "[@cartesPerforees](/cartesPerforees) It is only hard if you believed it is hard and worked the difficulty into the question. Note how there is mention of no looping around... if you took it into account without looking at the property of the path being increasing then you would assume you could not use memoization... which will make this a hard"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Agreed. If this one is marked hard, then at the very least all DP problems should be marked as such, because this is one of the most straight forward DP to figure out"
                    },
                    {
                        "username": "hashdgwhansb",
                        "content": "For those who are having TLE in there memoized DFS, pass the matrix using call by reference rather call by value.\\nIn passing it through call by value it copies that 200 by 200 everytime which increases the time complexity. So pass it call by reference ;)"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "thanks!"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "helpful"
                    },
                    {
                        "username": "Linmuadido",
                        "content": "Hello, everybody:\\n\\nI think the relax-based method, either DP or DFS (or both) , is working fine with the complexity O(mn).\\n\\nIn terms of graph model, the original problem input is a DAG(directed acrylic graph). However \"non-decreasing\" path requires bi-directional edge between neighbors with the same value. That is, the graph is not a DAG anymore.\\n\\nIf the problem changes to longest \"non-decreasing\" instead of \"increasing\" path, anyone thinks it is still doable in O(mn) time? How? Or Why not?"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "In the case of DP only solution. Shouldn\\'t we perform two passes?"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "This should be medium while [Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/description/) should be hard."
                    },
                    {
                        "username": "asirojiddinov96",
                        "content": "i guess in both question logic is pretty same DFS+memo"
                    },
                    {
                        "username": "hlin117",
                        "content": "In the solution, they mention that the naive DFS solution starting from each square is O(2^(n + m)). Can someone explain how they derive this?"
                    },
                    {
                        "username": "aman07",
                        "content": "Hello everyone!, I was just curious as to why this question cannot be solved with BFS? Or maybe it can be solved but it is just too long. I don\\'t know, I am confused. Can anyone explain? Thanks in advance!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "A bit late here but at first glance with BFS you won\\'t be able to use memoization efficiently and hence will end up in TLE."
                    },
                    {
                        "username": "nick_nick_go",
                        "content": "Simple DFS with Memo works"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Naive DFS) [Time Limit Exceeded]\n\n  \n**Approach 2:** (DFS + Memoization) [Accepted]\n\n  \n**Approach 3:** (Peeling Onion) [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "use dfs and little memoization to solve it. go every node and check whethere we are getting maximum node from that point ."
                    },
                    {
                        "username": "littleRainRain",
                        "content": "Is there any way we can print the longest path ? \\nin other words, if we want to return a List<Integer> for the path instead of the length of the path.... how may we do it ?"
                    },
                    {
                        "username": "Decode_Apocalypse",
                        "content": "TO PRINT ALL PATHS\\n\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    vector<vector<int>> mat;\\n\\n    void valid(int x, int y, vector<vector<int>> &path, vector<int> build, int mx){\\n        build.push_back(mat[x][y]);\\n        if(dp[x][y]==mx){\\n            path.push_back(build);\\n            return;\\n        }\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        int X[4]={-1,1,0,0};\\n        int Y[4]={0,0,1,-1};\\n        for(int i=0;i<4;i++){\\n            int newX=x+X[i];\\n            int newY=y+Y[i];\\n            if(newX<n && newY<m && newX>=0 && newY>=0 && dp[newX][newY]==dp[x][y]+1){\\n                valid(newX,newY,path,build,mx);\\n            }\\n        }\\n        build.pop_back();\\n        return;\\n    }\\n\\n    void PRINT(int mx, int n, int m){\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                vector<vector<int>> path;\\n                int x=i;\\n                int y=j;\\n                if(dp[x][y]==1){\\n                    valid(x,y,path,{},mx);\\n                    for(auto p: path){\\n                        for(auto v: p){\\n                            cout<<v<<\"->\";\\n                        }\\n                        cout<<\"END\";\\n                        cout<<endl;\\n                    }\\n                    cout<<endl;\\n                }\\n            }\\n        }\\n    }\\n\\n    bool isSafe(vector<vector<int>> &mat, int x, int y, int n, int m, int prev){\\n        return x>=0 && y>=0 && x<n && y<m && mat[x][y]>prev;\\n    }\\n\\n    int LIP(vector<vector<int>> &mat, int x, int y, int n, int m, int prev){\\n        if(isSafe(mat,x,y,n,m,prev)==false){\\n            return 0;\\n        }\\n        if(dp[x][y]!=-1){\\n            return dp[x][y];\\n        }\\n        int UP=LIP(mat,x-1,y,n,m,mat[x][y]); \\n        int DOWN=LIP(mat,x+1,y,n,m,mat[x][y]);\\n        int RIGHT=LIP(mat,x,y+1,n,m,mat[x][y]);\\n        int LEFT=LIP(mat,x,y-1,n,m,mat[x][y]);\\n        return dp[x][y]=1+max({UP,DOWN,LEFT,RIGHT});\\n    }\\n\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int res=1;\\n        mat=matrix;\\n        memset(dp,-1,sizeof(dp));\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int temp=LIP(matrix,i,j,n,m,INT_MIN);\\n                res=max(res,temp);\\n            }\\n        }\\n        PRINT(res,n,m);\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1568386,
                "content": [
                    {
                        "username": "rmn",
                        "content": "It's pretty straightforward Dfs + memoization. You don't even need to mark cells as seen due to the nature of the problem.\\nI think there are plenty of \"Medium\" rated questions out there that are a lot harder than this one :)"
                    },
                    {
                        "username": "feng3245",
                        "content": "[@cartesPerforees](/cartesPerforees) It is only hard if you believed it is hard and worked the difficulty into the question. Note how there is mention of no looping around... if you took it into account without looking at the property of the path being increasing then you would assume you could not use memoization... which will make this a hard"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Agreed. If this one is marked hard, then at the very least all DP problems should be marked as such, because this is one of the most straight forward DP to figure out"
                    },
                    {
                        "username": "hashdgwhansb",
                        "content": "For those who are having TLE in there memoized DFS, pass the matrix using call by reference rather call by value.\\nIn passing it through call by value it copies that 200 by 200 everytime which increases the time complexity. So pass it call by reference ;)"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "thanks!"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "helpful"
                    },
                    {
                        "username": "Linmuadido",
                        "content": "Hello, everybody:\\n\\nI think the relax-based method, either DP or DFS (or both) , is working fine with the complexity O(mn).\\n\\nIn terms of graph model, the original problem input is a DAG(directed acrylic graph). However \"non-decreasing\" path requires bi-directional edge between neighbors with the same value. That is, the graph is not a DAG anymore.\\n\\nIf the problem changes to longest \"non-decreasing\" instead of \"increasing\" path, anyone thinks it is still doable in O(mn) time? How? Or Why not?"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "In the case of DP only solution. Shouldn\\'t we perform two passes?"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "This should be medium while [Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/description/) should be hard."
                    },
                    {
                        "username": "asirojiddinov96",
                        "content": "i guess in both question logic is pretty same DFS+memo"
                    },
                    {
                        "username": "hlin117",
                        "content": "In the solution, they mention that the naive DFS solution starting from each square is O(2^(n + m)). Can someone explain how they derive this?"
                    },
                    {
                        "username": "aman07",
                        "content": "Hello everyone!, I was just curious as to why this question cannot be solved with BFS? Or maybe it can be solved but it is just too long. I don\\'t know, I am confused. Can anyone explain? Thanks in advance!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "A bit late here but at first glance with BFS you won\\'t be able to use memoization efficiently and hence will end up in TLE."
                    },
                    {
                        "username": "nick_nick_go",
                        "content": "Simple DFS with Memo works"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Naive DFS) [Time Limit Exceeded]\n\n  \n**Approach 2:** (DFS + Memoization) [Accepted]\n\n  \n**Approach 3:** (Peeling Onion) [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "use dfs and little memoization to solve it. go every node and check whethere we are getting maximum node from that point ."
                    },
                    {
                        "username": "littleRainRain",
                        "content": "Is there any way we can print the longest path ? \\nin other words, if we want to return a List<Integer> for the path instead of the length of the path.... how may we do it ?"
                    },
                    {
                        "username": "Decode_Apocalypse",
                        "content": "TO PRINT ALL PATHS\\n\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    vector<vector<int>> mat;\\n\\n    void valid(int x, int y, vector<vector<int>> &path, vector<int> build, int mx){\\n        build.push_back(mat[x][y]);\\n        if(dp[x][y]==mx){\\n            path.push_back(build);\\n            return;\\n        }\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        int X[4]={-1,1,0,0};\\n        int Y[4]={0,0,1,-1};\\n        for(int i=0;i<4;i++){\\n            int newX=x+X[i];\\n            int newY=y+Y[i];\\n            if(newX<n && newY<m && newX>=0 && newY>=0 && dp[newX][newY]==dp[x][y]+1){\\n                valid(newX,newY,path,build,mx);\\n            }\\n        }\\n        build.pop_back();\\n        return;\\n    }\\n\\n    void PRINT(int mx, int n, int m){\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                vector<vector<int>> path;\\n                int x=i;\\n                int y=j;\\n                if(dp[x][y]==1){\\n                    valid(x,y,path,{},mx);\\n                    for(auto p: path){\\n                        for(auto v: p){\\n                            cout<<v<<\"->\";\\n                        }\\n                        cout<<\"END\";\\n                        cout<<endl;\\n                    }\\n                    cout<<endl;\\n                }\\n            }\\n        }\\n    }\\n\\n    bool isSafe(vector<vector<int>> &mat, int x, int y, int n, int m, int prev){\\n        return x>=0 && y>=0 && x<n && y<m && mat[x][y]>prev;\\n    }\\n\\n    int LIP(vector<vector<int>> &mat, int x, int y, int n, int m, int prev){\\n        if(isSafe(mat,x,y,n,m,prev)==false){\\n            return 0;\\n        }\\n        if(dp[x][y]!=-1){\\n            return dp[x][y];\\n        }\\n        int UP=LIP(mat,x-1,y,n,m,mat[x][y]); \\n        int DOWN=LIP(mat,x+1,y,n,m,mat[x][y]);\\n        int RIGHT=LIP(mat,x,y+1,n,m,mat[x][y]);\\n        int LEFT=LIP(mat,x,y-1,n,m,mat[x][y]);\\n        return dp[x][y]=1+max({UP,DOWN,LEFT,RIGHT});\\n    }\\n\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int res=1;\\n        mat=matrix;\\n        memset(dp,-1,sizeof(dp));\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int temp=LIP(matrix,i,j,n,m,INT_MIN);\\n                res=max(res,temp);\\n            }\\n        }\\n        PRINT(res,n,m);\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1573909,
                "content": [
                    {
                        "username": "rmn",
                        "content": "It's pretty straightforward Dfs + memoization. You don't even need to mark cells as seen due to the nature of the problem.\\nI think there are plenty of \"Medium\" rated questions out there that are a lot harder than this one :)"
                    },
                    {
                        "username": "feng3245",
                        "content": "[@cartesPerforees](/cartesPerforees) It is only hard if you believed it is hard and worked the difficulty into the question. Note how there is mention of no looping around... if you took it into account without looking at the property of the path being increasing then you would assume you could not use memoization... which will make this a hard"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Agreed. If this one is marked hard, then at the very least all DP problems should be marked as such, because this is one of the most straight forward DP to figure out"
                    },
                    {
                        "username": "hashdgwhansb",
                        "content": "For those who are having TLE in there memoized DFS, pass the matrix using call by reference rather call by value.\\nIn passing it through call by value it copies that 200 by 200 everytime which increases the time complexity. So pass it call by reference ;)"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "thanks!"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "helpful"
                    },
                    {
                        "username": "Linmuadido",
                        "content": "Hello, everybody:\\n\\nI think the relax-based method, either DP or DFS (or both) , is working fine with the complexity O(mn).\\n\\nIn terms of graph model, the original problem input is a DAG(directed acrylic graph). However \"non-decreasing\" path requires bi-directional edge between neighbors with the same value. That is, the graph is not a DAG anymore.\\n\\nIf the problem changes to longest \"non-decreasing\" instead of \"increasing\" path, anyone thinks it is still doable in O(mn) time? How? Or Why not?"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "In the case of DP only solution. Shouldn\\'t we perform two passes?"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "This should be medium while [Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/description/) should be hard."
                    },
                    {
                        "username": "asirojiddinov96",
                        "content": "i guess in both question logic is pretty same DFS+memo"
                    },
                    {
                        "username": "hlin117",
                        "content": "In the solution, they mention that the naive DFS solution starting from each square is O(2^(n + m)). Can someone explain how they derive this?"
                    },
                    {
                        "username": "aman07",
                        "content": "Hello everyone!, I was just curious as to why this question cannot be solved with BFS? Or maybe it can be solved but it is just too long. I don\\'t know, I am confused. Can anyone explain? Thanks in advance!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "A bit late here but at first glance with BFS you won\\'t be able to use memoization efficiently and hence will end up in TLE."
                    },
                    {
                        "username": "nick_nick_go",
                        "content": "Simple DFS with Memo works"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Naive DFS) [Time Limit Exceeded]\n\n  \n**Approach 2:** (DFS + Memoization) [Accepted]\n\n  \n**Approach 3:** (Peeling Onion) [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "use dfs and little memoization to solve it. go every node and check whethere we are getting maximum node from that point ."
                    },
                    {
                        "username": "littleRainRain",
                        "content": "Is there any way we can print the longest path ? \\nin other words, if we want to return a List<Integer> for the path instead of the length of the path.... how may we do it ?"
                    },
                    {
                        "username": "Decode_Apocalypse",
                        "content": "TO PRINT ALL PATHS\\n\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    vector<vector<int>> mat;\\n\\n    void valid(int x, int y, vector<vector<int>> &path, vector<int> build, int mx){\\n        build.push_back(mat[x][y]);\\n        if(dp[x][y]==mx){\\n            path.push_back(build);\\n            return;\\n        }\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        int X[4]={-1,1,0,0};\\n        int Y[4]={0,0,1,-1};\\n        for(int i=0;i<4;i++){\\n            int newX=x+X[i];\\n            int newY=y+Y[i];\\n            if(newX<n && newY<m && newX>=0 && newY>=0 && dp[newX][newY]==dp[x][y]+1){\\n                valid(newX,newY,path,build,mx);\\n            }\\n        }\\n        build.pop_back();\\n        return;\\n    }\\n\\n    void PRINT(int mx, int n, int m){\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                vector<vector<int>> path;\\n                int x=i;\\n                int y=j;\\n                if(dp[x][y]==1){\\n                    valid(x,y,path,{},mx);\\n                    for(auto p: path){\\n                        for(auto v: p){\\n                            cout<<v<<\"->\";\\n                        }\\n                        cout<<\"END\";\\n                        cout<<endl;\\n                    }\\n                    cout<<endl;\\n                }\\n            }\\n        }\\n    }\\n\\n    bool isSafe(vector<vector<int>> &mat, int x, int y, int n, int m, int prev){\\n        return x>=0 && y>=0 && x<n && y<m && mat[x][y]>prev;\\n    }\\n\\n    int LIP(vector<vector<int>> &mat, int x, int y, int n, int m, int prev){\\n        if(isSafe(mat,x,y,n,m,prev)==false){\\n            return 0;\\n        }\\n        if(dp[x][y]!=-1){\\n            return dp[x][y];\\n        }\\n        int UP=LIP(mat,x-1,y,n,m,mat[x][y]); \\n        int DOWN=LIP(mat,x+1,y,n,m,mat[x][y]);\\n        int RIGHT=LIP(mat,x,y+1,n,m,mat[x][y]);\\n        int LEFT=LIP(mat,x,y-1,n,m,mat[x][y]);\\n        return dp[x][y]=1+max({UP,DOWN,LEFT,RIGHT});\\n    }\\n\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int res=1;\\n        mat=matrix;\\n        memset(dp,-1,sizeof(dp));\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int temp=LIP(matrix,i,j,n,m,INT_MIN);\\n                res=max(res,temp);\\n            }\\n        }\\n        PRINT(res,n,m);\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1573410,
                "content": [
                    {
                        "username": "rmn",
                        "content": "It's pretty straightforward Dfs + memoization. You don't even need to mark cells as seen due to the nature of the problem.\\nI think there are plenty of \"Medium\" rated questions out there that are a lot harder than this one :)"
                    },
                    {
                        "username": "feng3245",
                        "content": "[@cartesPerforees](/cartesPerforees) It is only hard if you believed it is hard and worked the difficulty into the question. Note how there is mention of no looping around... if you took it into account without looking at the property of the path being increasing then you would assume you could not use memoization... which will make this a hard"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Agreed. If this one is marked hard, then at the very least all DP problems should be marked as such, because this is one of the most straight forward DP to figure out"
                    },
                    {
                        "username": "hashdgwhansb",
                        "content": "For those who are having TLE in there memoized DFS, pass the matrix using call by reference rather call by value.\\nIn passing it through call by value it copies that 200 by 200 everytime which increases the time complexity. So pass it call by reference ;)"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "thanks!"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "helpful"
                    },
                    {
                        "username": "Linmuadido",
                        "content": "Hello, everybody:\\n\\nI think the relax-based method, either DP or DFS (or both) , is working fine with the complexity O(mn).\\n\\nIn terms of graph model, the original problem input is a DAG(directed acrylic graph). However \"non-decreasing\" path requires bi-directional edge between neighbors with the same value. That is, the graph is not a DAG anymore.\\n\\nIf the problem changes to longest \"non-decreasing\" instead of \"increasing\" path, anyone thinks it is still doable in O(mn) time? How? Or Why not?"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "In the case of DP only solution. Shouldn\\'t we perform two passes?"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "This should be medium while [Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/description/) should be hard."
                    },
                    {
                        "username": "asirojiddinov96",
                        "content": "i guess in both question logic is pretty same DFS+memo"
                    },
                    {
                        "username": "hlin117",
                        "content": "In the solution, they mention that the naive DFS solution starting from each square is O(2^(n + m)). Can someone explain how they derive this?"
                    },
                    {
                        "username": "aman07",
                        "content": "Hello everyone!, I was just curious as to why this question cannot be solved with BFS? Or maybe it can be solved but it is just too long. I don\\'t know, I am confused. Can anyone explain? Thanks in advance!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "A bit late here but at first glance with BFS you won\\'t be able to use memoization efficiently and hence will end up in TLE."
                    },
                    {
                        "username": "nick_nick_go",
                        "content": "Simple DFS with Memo works"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Naive DFS) [Time Limit Exceeded]\n\n  \n**Approach 2:** (DFS + Memoization) [Accepted]\n\n  \n**Approach 3:** (Peeling Onion) [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "use dfs and little memoization to solve it. go every node and check whethere we are getting maximum node from that point ."
                    },
                    {
                        "username": "littleRainRain",
                        "content": "Is there any way we can print the longest path ? \\nin other words, if we want to return a List<Integer> for the path instead of the length of the path.... how may we do it ?"
                    },
                    {
                        "username": "Decode_Apocalypse",
                        "content": "TO PRINT ALL PATHS\\n\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    vector<vector<int>> mat;\\n\\n    void valid(int x, int y, vector<vector<int>> &path, vector<int> build, int mx){\\n        build.push_back(mat[x][y]);\\n        if(dp[x][y]==mx){\\n            path.push_back(build);\\n            return;\\n        }\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        int X[4]={-1,1,0,0};\\n        int Y[4]={0,0,1,-1};\\n        for(int i=0;i<4;i++){\\n            int newX=x+X[i];\\n            int newY=y+Y[i];\\n            if(newX<n && newY<m && newX>=0 && newY>=0 && dp[newX][newY]==dp[x][y]+1){\\n                valid(newX,newY,path,build,mx);\\n            }\\n        }\\n        build.pop_back();\\n        return;\\n    }\\n\\n    void PRINT(int mx, int n, int m){\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                vector<vector<int>> path;\\n                int x=i;\\n                int y=j;\\n                if(dp[x][y]==1){\\n                    valid(x,y,path,{},mx);\\n                    for(auto p: path){\\n                        for(auto v: p){\\n                            cout<<v<<\"->\";\\n                        }\\n                        cout<<\"END\";\\n                        cout<<endl;\\n                    }\\n                    cout<<endl;\\n                }\\n            }\\n        }\\n    }\\n\\n    bool isSafe(vector<vector<int>> &mat, int x, int y, int n, int m, int prev){\\n        return x>=0 && y>=0 && x<n && y<m && mat[x][y]>prev;\\n    }\\n\\n    int LIP(vector<vector<int>> &mat, int x, int y, int n, int m, int prev){\\n        if(isSafe(mat,x,y,n,m,prev)==false){\\n            return 0;\\n        }\\n        if(dp[x][y]!=-1){\\n            return dp[x][y];\\n        }\\n        int UP=LIP(mat,x-1,y,n,m,mat[x][y]); \\n        int DOWN=LIP(mat,x+1,y,n,m,mat[x][y]);\\n        int RIGHT=LIP(mat,x,y+1,n,m,mat[x][y]);\\n        int LEFT=LIP(mat,x,y-1,n,m,mat[x][y]);\\n        return dp[x][y]=1+max({UP,DOWN,LEFT,RIGHT});\\n    }\\n\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int res=1;\\n        mat=matrix;\\n        memset(dp,-1,sizeof(dp));\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int temp=LIP(matrix,i,j,n,m,INT_MIN);\\n                res=max(res,temp);\\n            }\\n        }\\n        PRINT(res,n,m);\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1567761,
                "content": [
                    {
                        "username": "rmn",
                        "content": "It's pretty straightforward Dfs + memoization. You don't even need to mark cells as seen due to the nature of the problem.\\nI think there are plenty of \"Medium\" rated questions out there that are a lot harder than this one :)"
                    },
                    {
                        "username": "feng3245",
                        "content": "[@cartesPerforees](/cartesPerforees) It is only hard if you believed it is hard and worked the difficulty into the question. Note how there is mention of no looping around... if you took it into account without looking at the property of the path being increasing then you would assume you could not use memoization... which will make this a hard"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Agreed. If this one is marked hard, then at the very least all DP problems should be marked as such, because this is one of the most straight forward DP to figure out"
                    },
                    {
                        "username": "hashdgwhansb",
                        "content": "For those who are having TLE in there memoized DFS, pass the matrix using call by reference rather call by value.\\nIn passing it through call by value it copies that 200 by 200 everytime which increases the time complexity. So pass it call by reference ;)"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "thanks!"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "helpful"
                    },
                    {
                        "username": "Linmuadido",
                        "content": "Hello, everybody:\\n\\nI think the relax-based method, either DP or DFS (or both) , is working fine with the complexity O(mn).\\n\\nIn terms of graph model, the original problem input is a DAG(directed acrylic graph). However \"non-decreasing\" path requires bi-directional edge between neighbors with the same value. That is, the graph is not a DAG anymore.\\n\\nIf the problem changes to longest \"non-decreasing\" instead of \"increasing\" path, anyone thinks it is still doable in O(mn) time? How? Or Why not?"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "In the case of DP only solution. Shouldn\\'t we perform two passes?"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "This should be medium while [Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/description/) should be hard."
                    },
                    {
                        "username": "asirojiddinov96",
                        "content": "i guess in both question logic is pretty same DFS+memo"
                    },
                    {
                        "username": "hlin117",
                        "content": "In the solution, they mention that the naive DFS solution starting from each square is O(2^(n + m)). Can someone explain how they derive this?"
                    },
                    {
                        "username": "aman07",
                        "content": "Hello everyone!, I was just curious as to why this question cannot be solved with BFS? Or maybe it can be solved but it is just too long. I don\\'t know, I am confused. Can anyone explain? Thanks in advance!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "A bit late here but at first glance with BFS you won\\'t be able to use memoization efficiently and hence will end up in TLE."
                    },
                    {
                        "username": "nick_nick_go",
                        "content": "Simple DFS with Memo works"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Naive DFS) [Time Limit Exceeded]\n\n  \n**Approach 2:** (DFS + Memoization) [Accepted]\n\n  \n**Approach 3:** (Peeling Onion) [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "use dfs and little memoization to solve it. go every node and check whethere we are getting maximum node from that point ."
                    },
                    {
                        "username": "littleRainRain",
                        "content": "Is there any way we can print the longest path ? \\nin other words, if we want to return a List<Integer> for the path instead of the length of the path.... how may we do it ?"
                    },
                    {
                        "username": "Decode_Apocalypse",
                        "content": "TO PRINT ALL PATHS\\n\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    vector<vector<int>> mat;\\n\\n    void valid(int x, int y, vector<vector<int>> &path, vector<int> build, int mx){\\n        build.push_back(mat[x][y]);\\n        if(dp[x][y]==mx){\\n            path.push_back(build);\\n            return;\\n        }\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        int X[4]={-1,1,0,0};\\n        int Y[4]={0,0,1,-1};\\n        for(int i=0;i<4;i++){\\n            int newX=x+X[i];\\n            int newY=y+Y[i];\\n            if(newX<n && newY<m && newX>=0 && newY>=0 && dp[newX][newY]==dp[x][y]+1){\\n                valid(newX,newY,path,build,mx);\\n            }\\n        }\\n        build.pop_back();\\n        return;\\n    }\\n\\n    void PRINT(int mx, int n, int m){\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                vector<vector<int>> path;\\n                int x=i;\\n                int y=j;\\n                if(dp[x][y]==1){\\n                    valid(x,y,path,{},mx);\\n                    for(auto p: path){\\n                        for(auto v: p){\\n                            cout<<v<<\"->\";\\n                        }\\n                        cout<<\"END\";\\n                        cout<<endl;\\n                    }\\n                    cout<<endl;\\n                }\\n            }\\n        }\\n    }\\n\\n    bool isSafe(vector<vector<int>> &mat, int x, int y, int n, int m, int prev){\\n        return x>=0 && y>=0 && x<n && y<m && mat[x][y]>prev;\\n    }\\n\\n    int LIP(vector<vector<int>> &mat, int x, int y, int n, int m, int prev){\\n        if(isSafe(mat,x,y,n,m,prev)==false){\\n            return 0;\\n        }\\n        if(dp[x][y]!=-1){\\n            return dp[x][y];\\n        }\\n        int UP=LIP(mat,x-1,y,n,m,mat[x][y]); \\n        int DOWN=LIP(mat,x+1,y,n,m,mat[x][y]);\\n        int RIGHT=LIP(mat,x,y+1,n,m,mat[x][y]);\\n        int LEFT=LIP(mat,x,y-1,n,m,mat[x][y]);\\n        return dp[x][y]=1+max({UP,DOWN,LEFT,RIGHT});\\n    }\\n\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int res=1;\\n        mat=matrix;\\n        memset(dp,-1,sizeof(dp));\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int temp=LIP(matrix,i,j,n,m,INT_MIN);\\n                res=max(res,temp);\\n            }\\n        }\\n        PRINT(res,n,m);\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1675956,
                "content": [
                    {
                        "username": "rmn",
                        "content": "It's pretty straightforward Dfs + memoization. You don't even need to mark cells as seen due to the nature of the problem.\\nI think there are plenty of \"Medium\" rated questions out there that are a lot harder than this one :)"
                    },
                    {
                        "username": "feng3245",
                        "content": "[@cartesPerforees](/cartesPerforees) It is only hard if you believed it is hard and worked the difficulty into the question. Note how there is mention of no looping around... if you took it into account without looking at the property of the path being increasing then you would assume you could not use memoization... which will make this a hard"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Agreed. If this one is marked hard, then at the very least all DP problems should be marked as such, because this is one of the most straight forward DP to figure out"
                    },
                    {
                        "username": "hashdgwhansb",
                        "content": "For those who are having TLE in there memoized DFS, pass the matrix using call by reference rather call by value.\\nIn passing it through call by value it copies that 200 by 200 everytime which increases the time complexity. So pass it call by reference ;)"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "thanks!"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "helpful"
                    },
                    {
                        "username": "Linmuadido",
                        "content": "Hello, everybody:\\n\\nI think the relax-based method, either DP or DFS (or both) , is working fine with the complexity O(mn).\\n\\nIn terms of graph model, the original problem input is a DAG(directed acrylic graph). However \"non-decreasing\" path requires bi-directional edge between neighbors with the same value. That is, the graph is not a DAG anymore.\\n\\nIf the problem changes to longest \"non-decreasing\" instead of \"increasing\" path, anyone thinks it is still doable in O(mn) time? How? Or Why not?"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "In the case of DP only solution. Shouldn\\'t we perform two passes?"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "This should be medium while [Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/description/) should be hard."
                    },
                    {
                        "username": "asirojiddinov96",
                        "content": "i guess in both question logic is pretty same DFS+memo"
                    },
                    {
                        "username": "hlin117",
                        "content": "In the solution, they mention that the naive DFS solution starting from each square is O(2^(n + m)). Can someone explain how they derive this?"
                    },
                    {
                        "username": "aman07",
                        "content": "Hello everyone!, I was just curious as to why this question cannot be solved with BFS? Or maybe it can be solved but it is just too long. I don\\'t know, I am confused. Can anyone explain? Thanks in advance!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "A bit late here but at first glance with BFS you won\\'t be able to use memoization efficiently and hence will end up in TLE."
                    },
                    {
                        "username": "nick_nick_go",
                        "content": "Simple DFS with Memo works"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Naive DFS) [Time Limit Exceeded]\n\n  \n**Approach 2:** (DFS + Memoization) [Accepted]\n\n  \n**Approach 3:** (Peeling Onion) [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "use dfs and little memoization to solve it. go every node and check whethere we are getting maximum node from that point ."
                    },
                    {
                        "username": "littleRainRain",
                        "content": "Is there any way we can print the longest path ? \\nin other words, if we want to return a List<Integer> for the path instead of the length of the path.... how may we do it ?"
                    },
                    {
                        "username": "Decode_Apocalypse",
                        "content": "TO PRINT ALL PATHS\\n\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    vector<vector<int>> mat;\\n\\n    void valid(int x, int y, vector<vector<int>> &path, vector<int> build, int mx){\\n        build.push_back(mat[x][y]);\\n        if(dp[x][y]==mx){\\n            path.push_back(build);\\n            return;\\n        }\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        int X[4]={-1,1,0,0};\\n        int Y[4]={0,0,1,-1};\\n        for(int i=0;i<4;i++){\\n            int newX=x+X[i];\\n            int newY=y+Y[i];\\n            if(newX<n && newY<m && newX>=0 && newY>=0 && dp[newX][newY]==dp[x][y]+1){\\n                valid(newX,newY,path,build,mx);\\n            }\\n        }\\n        build.pop_back();\\n        return;\\n    }\\n\\n    void PRINT(int mx, int n, int m){\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                vector<vector<int>> path;\\n                int x=i;\\n                int y=j;\\n                if(dp[x][y]==1){\\n                    valid(x,y,path,{},mx);\\n                    for(auto p: path){\\n                        for(auto v: p){\\n                            cout<<v<<\"->\";\\n                        }\\n                        cout<<\"END\";\\n                        cout<<endl;\\n                    }\\n                    cout<<endl;\\n                }\\n            }\\n        }\\n    }\\n\\n    bool isSafe(vector<vector<int>> &mat, int x, int y, int n, int m, int prev){\\n        return x>=0 && y>=0 && x<n && y<m && mat[x][y]>prev;\\n    }\\n\\n    int LIP(vector<vector<int>> &mat, int x, int y, int n, int m, int prev){\\n        if(isSafe(mat,x,y,n,m,prev)==false){\\n            return 0;\\n        }\\n        if(dp[x][y]!=-1){\\n            return dp[x][y];\\n        }\\n        int UP=LIP(mat,x-1,y,n,m,mat[x][y]); \\n        int DOWN=LIP(mat,x+1,y,n,m,mat[x][y]);\\n        int RIGHT=LIP(mat,x,y+1,n,m,mat[x][y]);\\n        int LEFT=LIP(mat,x,y-1,n,m,mat[x][y]);\\n        return dp[x][y]=1+max({UP,DOWN,LEFT,RIGHT});\\n    }\\n\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int res=1;\\n        mat=matrix;\\n        memset(dp,-1,sizeof(dp));\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int temp=LIP(matrix,i,j,n,m,INT_MIN);\\n                res=max(res,temp);\\n            }\\n        }\\n        PRINT(res,n,m);\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1572277,
                "content": [
                    {
                        "username": "rmn",
                        "content": "It's pretty straightforward Dfs + memoization. You don't even need to mark cells as seen due to the nature of the problem.\\nI think there are plenty of \"Medium\" rated questions out there that are a lot harder than this one :)"
                    },
                    {
                        "username": "feng3245",
                        "content": "[@cartesPerforees](/cartesPerforees) It is only hard if you believed it is hard and worked the difficulty into the question. Note how there is mention of no looping around... if you took it into account without looking at the property of the path being increasing then you would assume you could not use memoization... which will make this a hard"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Agreed. If this one is marked hard, then at the very least all DP problems should be marked as such, because this is one of the most straight forward DP to figure out"
                    },
                    {
                        "username": "hashdgwhansb",
                        "content": "For those who are having TLE in there memoized DFS, pass the matrix using call by reference rather call by value.\\nIn passing it through call by value it copies that 200 by 200 everytime which increases the time complexity. So pass it call by reference ;)"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "thanks!"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "helpful"
                    },
                    {
                        "username": "Linmuadido",
                        "content": "Hello, everybody:\\n\\nI think the relax-based method, either DP or DFS (or both) , is working fine with the complexity O(mn).\\n\\nIn terms of graph model, the original problem input is a DAG(directed acrylic graph). However \"non-decreasing\" path requires bi-directional edge between neighbors with the same value. That is, the graph is not a DAG anymore.\\n\\nIf the problem changes to longest \"non-decreasing\" instead of \"increasing\" path, anyone thinks it is still doable in O(mn) time? How? Or Why not?"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "In the case of DP only solution. Shouldn\\'t we perform two passes?"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "This should be medium while [Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/description/) should be hard."
                    },
                    {
                        "username": "asirojiddinov96",
                        "content": "i guess in both question logic is pretty same DFS+memo"
                    },
                    {
                        "username": "hlin117",
                        "content": "In the solution, they mention that the naive DFS solution starting from each square is O(2^(n + m)). Can someone explain how they derive this?"
                    },
                    {
                        "username": "aman07",
                        "content": "Hello everyone!, I was just curious as to why this question cannot be solved with BFS? Or maybe it can be solved but it is just too long. I don\\'t know, I am confused. Can anyone explain? Thanks in advance!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "A bit late here but at first glance with BFS you won\\'t be able to use memoization efficiently and hence will end up in TLE."
                    },
                    {
                        "username": "nick_nick_go",
                        "content": "Simple DFS with Memo works"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Naive DFS) [Time Limit Exceeded]\n\n  \n**Approach 2:** (DFS + Memoization) [Accepted]\n\n  \n**Approach 3:** (Peeling Onion) [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "use dfs and little memoization to solve it. go every node and check whethere we are getting maximum node from that point ."
                    },
                    {
                        "username": "littleRainRain",
                        "content": "Is there any way we can print the longest path ? \\nin other words, if we want to return a List<Integer> for the path instead of the length of the path.... how may we do it ?"
                    },
                    {
                        "username": "Decode_Apocalypse",
                        "content": "TO PRINT ALL PATHS\\n\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    vector<vector<int>> mat;\\n\\n    void valid(int x, int y, vector<vector<int>> &path, vector<int> build, int mx){\\n        build.push_back(mat[x][y]);\\n        if(dp[x][y]==mx){\\n            path.push_back(build);\\n            return;\\n        }\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        int X[4]={-1,1,0,0};\\n        int Y[4]={0,0,1,-1};\\n        for(int i=0;i<4;i++){\\n            int newX=x+X[i];\\n            int newY=y+Y[i];\\n            if(newX<n && newY<m && newX>=0 && newY>=0 && dp[newX][newY]==dp[x][y]+1){\\n                valid(newX,newY,path,build,mx);\\n            }\\n        }\\n        build.pop_back();\\n        return;\\n    }\\n\\n    void PRINT(int mx, int n, int m){\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                vector<vector<int>> path;\\n                int x=i;\\n                int y=j;\\n                if(dp[x][y]==1){\\n                    valid(x,y,path,{},mx);\\n                    for(auto p: path){\\n                        for(auto v: p){\\n                            cout<<v<<\"->\";\\n                        }\\n                        cout<<\"END\";\\n                        cout<<endl;\\n                    }\\n                    cout<<endl;\\n                }\\n            }\\n        }\\n    }\\n\\n    bool isSafe(vector<vector<int>> &mat, int x, int y, int n, int m, int prev){\\n        return x>=0 && y>=0 && x<n && y<m && mat[x][y]>prev;\\n    }\\n\\n    int LIP(vector<vector<int>> &mat, int x, int y, int n, int m, int prev){\\n        if(isSafe(mat,x,y,n,m,prev)==false){\\n            return 0;\\n        }\\n        if(dp[x][y]!=-1){\\n            return dp[x][y];\\n        }\\n        int UP=LIP(mat,x-1,y,n,m,mat[x][y]); \\n        int DOWN=LIP(mat,x+1,y,n,m,mat[x][y]);\\n        int RIGHT=LIP(mat,x,y+1,n,m,mat[x][y]);\\n        int LEFT=LIP(mat,x,y-1,n,m,mat[x][y]);\\n        return dp[x][y]=1+max({UP,DOWN,LEFT,RIGHT});\\n    }\\n\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int res=1;\\n        mat=matrix;\\n        memset(dp,-1,sizeof(dp));\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int temp=LIP(matrix,i,j,n,m,INT_MIN);\\n                res=max(res,temp);\\n            }\\n        }\\n        PRINT(res,n,m);\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1569080,
                "content": [
                    {
                        "username": "rmn",
                        "content": "It's pretty straightforward Dfs + memoization. You don't even need to mark cells as seen due to the nature of the problem.\\nI think there are plenty of \"Medium\" rated questions out there that are a lot harder than this one :)"
                    },
                    {
                        "username": "feng3245",
                        "content": "[@cartesPerforees](/cartesPerforees) It is only hard if you believed it is hard and worked the difficulty into the question. Note how there is mention of no looping around... if you took it into account without looking at the property of the path being increasing then you would assume you could not use memoization... which will make this a hard"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Agreed. If this one is marked hard, then at the very least all DP problems should be marked as such, because this is one of the most straight forward DP to figure out"
                    },
                    {
                        "username": "hashdgwhansb",
                        "content": "For those who are having TLE in there memoized DFS, pass the matrix using call by reference rather call by value.\\nIn passing it through call by value it copies that 200 by 200 everytime which increases the time complexity. So pass it call by reference ;)"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "thanks!"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "helpful"
                    },
                    {
                        "username": "Linmuadido",
                        "content": "Hello, everybody:\\n\\nI think the relax-based method, either DP or DFS (or both) , is working fine with the complexity O(mn).\\n\\nIn terms of graph model, the original problem input is a DAG(directed acrylic graph). However \"non-decreasing\" path requires bi-directional edge between neighbors with the same value. That is, the graph is not a DAG anymore.\\n\\nIf the problem changes to longest \"non-decreasing\" instead of \"increasing\" path, anyone thinks it is still doable in O(mn) time? How? Or Why not?"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "In the case of DP only solution. Shouldn\\'t we perform two passes?"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "This should be medium while [Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/description/) should be hard."
                    },
                    {
                        "username": "asirojiddinov96",
                        "content": "i guess in both question logic is pretty same DFS+memo"
                    },
                    {
                        "username": "hlin117",
                        "content": "In the solution, they mention that the naive DFS solution starting from each square is O(2^(n + m)). Can someone explain how they derive this?"
                    },
                    {
                        "username": "aman07",
                        "content": "Hello everyone!, I was just curious as to why this question cannot be solved with BFS? Or maybe it can be solved but it is just too long. I don\\'t know, I am confused. Can anyone explain? Thanks in advance!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "A bit late here but at first glance with BFS you won\\'t be able to use memoization efficiently and hence will end up in TLE."
                    },
                    {
                        "username": "nick_nick_go",
                        "content": "Simple DFS with Memo works"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Naive DFS) [Time Limit Exceeded]\n\n  \n**Approach 2:** (DFS + Memoization) [Accepted]\n\n  \n**Approach 3:** (Peeling Onion) [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "use dfs and little memoization to solve it. go every node and check whethere we are getting maximum node from that point ."
                    },
                    {
                        "username": "littleRainRain",
                        "content": "Is there any way we can print the longest path ? \\nin other words, if we want to return a List<Integer> for the path instead of the length of the path.... how may we do it ?"
                    },
                    {
                        "username": "Decode_Apocalypse",
                        "content": "TO PRINT ALL PATHS\\n\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    vector<vector<int>> mat;\\n\\n    void valid(int x, int y, vector<vector<int>> &path, vector<int> build, int mx){\\n        build.push_back(mat[x][y]);\\n        if(dp[x][y]==mx){\\n            path.push_back(build);\\n            return;\\n        }\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        int X[4]={-1,1,0,0};\\n        int Y[4]={0,0,1,-1};\\n        for(int i=0;i<4;i++){\\n            int newX=x+X[i];\\n            int newY=y+Y[i];\\n            if(newX<n && newY<m && newX>=0 && newY>=0 && dp[newX][newY]==dp[x][y]+1){\\n                valid(newX,newY,path,build,mx);\\n            }\\n        }\\n        build.pop_back();\\n        return;\\n    }\\n\\n    void PRINT(int mx, int n, int m){\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                vector<vector<int>> path;\\n                int x=i;\\n                int y=j;\\n                if(dp[x][y]==1){\\n                    valid(x,y,path,{},mx);\\n                    for(auto p: path){\\n                        for(auto v: p){\\n                            cout<<v<<\"->\";\\n                        }\\n                        cout<<\"END\";\\n                        cout<<endl;\\n                    }\\n                    cout<<endl;\\n                }\\n            }\\n        }\\n    }\\n\\n    bool isSafe(vector<vector<int>> &mat, int x, int y, int n, int m, int prev){\\n        return x>=0 && y>=0 && x<n && y<m && mat[x][y]>prev;\\n    }\\n\\n    int LIP(vector<vector<int>> &mat, int x, int y, int n, int m, int prev){\\n        if(isSafe(mat,x,y,n,m,prev)==false){\\n            return 0;\\n        }\\n        if(dp[x][y]!=-1){\\n            return dp[x][y];\\n        }\\n        int UP=LIP(mat,x-1,y,n,m,mat[x][y]); \\n        int DOWN=LIP(mat,x+1,y,n,m,mat[x][y]);\\n        int RIGHT=LIP(mat,x,y+1,n,m,mat[x][y]);\\n        int LEFT=LIP(mat,x,y-1,n,m,mat[x][y]);\\n        return dp[x][y]=1+max({UP,DOWN,LEFT,RIGHT});\\n    }\\n\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int res=1;\\n        mat=matrix;\\n        memset(dp,-1,sizeof(dp));\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int temp=LIP(matrix,i,j,n,m,INT_MIN);\\n                res=max(res,temp);\\n            }\\n        }\\n        PRINT(res,n,m);\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1570536,
                "content": [
                    {
                        "username": "rmn",
                        "content": "It's pretty straightforward Dfs + memoization. You don't even need to mark cells as seen due to the nature of the problem.\\nI think there are plenty of \"Medium\" rated questions out there that are a lot harder than this one :)"
                    },
                    {
                        "username": "feng3245",
                        "content": "[@cartesPerforees](/cartesPerforees) It is only hard if you believed it is hard and worked the difficulty into the question. Note how there is mention of no looping around... if you took it into account without looking at the property of the path being increasing then you would assume you could not use memoization... which will make this a hard"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Agreed. If this one is marked hard, then at the very least all DP problems should be marked as such, because this is one of the most straight forward DP to figure out"
                    },
                    {
                        "username": "hashdgwhansb",
                        "content": "For those who are having TLE in there memoized DFS, pass the matrix using call by reference rather call by value.\\nIn passing it through call by value it copies that 200 by 200 everytime which increases the time complexity. So pass it call by reference ;)"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "thanks!"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "helpful"
                    },
                    {
                        "username": "Linmuadido",
                        "content": "Hello, everybody:\\n\\nI think the relax-based method, either DP or DFS (or both) , is working fine with the complexity O(mn).\\n\\nIn terms of graph model, the original problem input is a DAG(directed acrylic graph). However \"non-decreasing\" path requires bi-directional edge between neighbors with the same value. That is, the graph is not a DAG anymore.\\n\\nIf the problem changes to longest \"non-decreasing\" instead of \"increasing\" path, anyone thinks it is still doable in O(mn) time? How? Or Why not?"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "In the case of DP only solution. Shouldn\\'t we perform two passes?"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "This should be medium while [Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/description/) should be hard."
                    },
                    {
                        "username": "asirojiddinov96",
                        "content": "i guess in both question logic is pretty same DFS+memo"
                    },
                    {
                        "username": "hlin117",
                        "content": "In the solution, they mention that the naive DFS solution starting from each square is O(2^(n + m)). Can someone explain how they derive this?"
                    },
                    {
                        "username": "aman07",
                        "content": "Hello everyone!, I was just curious as to why this question cannot be solved with BFS? Or maybe it can be solved but it is just too long. I don\\'t know, I am confused. Can anyone explain? Thanks in advance!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "A bit late here but at first glance with BFS you won\\'t be able to use memoization efficiently and hence will end up in TLE."
                    },
                    {
                        "username": "nick_nick_go",
                        "content": "Simple DFS with Memo works"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Naive DFS) [Time Limit Exceeded]\n\n  \n**Approach 2:** (DFS + Memoization) [Accepted]\n\n  \n**Approach 3:** (Peeling Onion) [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "use dfs and little memoization to solve it. go every node and check whethere we are getting maximum node from that point ."
                    },
                    {
                        "username": "littleRainRain",
                        "content": "Is there any way we can print the longest path ? \\nin other words, if we want to return a List<Integer> for the path instead of the length of the path.... how may we do it ?"
                    },
                    {
                        "username": "Decode_Apocalypse",
                        "content": "TO PRINT ALL PATHS\\n\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    vector<vector<int>> mat;\\n\\n    void valid(int x, int y, vector<vector<int>> &path, vector<int> build, int mx){\\n        build.push_back(mat[x][y]);\\n        if(dp[x][y]==mx){\\n            path.push_back(build);\\n            return;\\n        }\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        int X[4]={-1,1,0,0};\\n        int Y[4]={0,0,1,-1};\\n        for(int i=0;i<4;i++){\\n            int newX=x+X[i];\\n            int newY=y+Y[i];\\n            if(newX<n && newY<m && newX>=0 && newY>=0 && dp[newX][newY]==dp[x][y]+1){\\n                valid(newX,newY,path,build,mx);\\n            }\\n        }\\n        build.pop_back();\\n        return;\\n    }\\n\\n    void PRINT(int mx, int n, int m){\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                vector<vector<int>> path;\\n                int x=i;\\n                int y=j;\\n                if(dp[x][y]==1){\\n                    valid(x,y,path,{},mx);\\n                    for(auto p: path){\\n                        for(auto v: p){\\n                            cout<<v<<\"->\";\\n                        }\\n                        cout<<\"END\";\\n                        cout<<endl;\\n                    }\\n                    cout<<endl;\\n                }\\n            }\\n        }\\n    }\\n\\n    bool isSafe(vector<vector<int>> &mat, int x, int y, int n, int m, int prev){\\n        return x>=0 && y>=0 && x<n && y<m && mat[x][y]>prev;\\n    }\\n\\n    int LIP(vector<vector<int>> &mat, int x, int y, int n, int m, int prev){\\n        if(isSafe(mat,x,y,n,m,prev)==false){\\n            return 0;\\n        }\\n        if(dp[x][y]!=-1){\\n            return dp[x][y];\\n        }\\n        int UP=LIP(mat,x-1,y,n,m,mat[x][y]); \\n        int DOWN=LIP(mat,x+1,y,n,m,mat[x][y]);\\n        int RIGHT=LIP(mat,x,y+1,n,m,mat[x][y]);\\n        int LEFT=LIP(mat,x,y-1,n,m,mat[x][y]);\\n        return dp[x][y]=1+max({UP,DOWN,LEFT,RIGHT});\\n    }\\n\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int res=1;\\n        mat=matrix;\\n        memset(dp,-1,sizeof(dp));\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int temp=LIP(matrix,i,j,n,m,INT_MIN);\\n                res=max(res,temp);\\n            }\\n        }\\n        PRINT(res,n,m);\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1566258,
                "content": [
                    {
                        "username": "rmn",
                        "content": "It's pretty straightforward Dfs + memoization. You don't even need to mark cells as seen due to the nature of the problem.\\nI think there are plenty of \"Medium\" rated questions out there that are a lot harder than this one :)"
                    },
                    {
                        "username": "feng3245",
                        "content": "[@cartesPerforees](/cartesPerforees) It is only hard if you believed it is hard and worked the difficulty into the question. Note how there is mention of no looping around... if you took it into account without looking at the property of the path being increasing then you would assume you could not use memoization... which will make this a hard"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Agreed. If this one is marked hard, then at the very least all DP problems should be marked as such, because this is one of the most straight forward DP to figure out"
                    },
                    {
                        "username": "hashdgwhansb",
                        "content": "For those who are having TLE in there memoized DFS, pass the matrix using call by reference rather call by value.\\nIn passing it through call by value it copies that 200 by 200 everytime which increases the time complexity. So pass it call by reference ;)"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "thanks!"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "helpful"
                    },
                    {
                        "username": "Linmuadido",
                        "content": "Hello, everybody:\\n\\nI think the relax-based method, either DP or DFS (or both) , is working fine with the complexity O(mn).\\n\\nIn terms of graph model, the original problem input is a DAG(directed acrylic graph). However \"non-decreasing\" path requires bi-directional edge between neighbors with the same value. That is, the graph is not a DAG anymore.\\n\\nIf the problem changes to longest \"non-decreasing\" instead of \"increasing\" path, anyone thinks it is still doable in O(mn) time? How? Or Why not?"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "In the case of DP only solution. Shouldn\\'t we perform two passes?"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "This should be medium while [Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/description/) should be hard."
                    },
                    {
                        "username": "asirojiddinov96",
                        "content": "i guess in both question logic is pretty same DFS+memo"
                    },
                    {
                        "username": "hlin117",
                        "content": "In the solution, they mention that the naive DFS solution starting from each square is O(2^(n + m)). Can someone explain how they derive this?"
                    },
                    {
                        "username": "aman07",
                        "content": "Hello everyone!, I was just curious as to why this question cannot be solved with BFS? Or maybe it can be solved but it is just too long. I don\\'t know, I am confused. Can anyone explain? Thanks in advance!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "A bit late here but at first glance with BFS you won\\'t be able to use memoization efficiently and hence will end up in TLE."
                    },
                    {
                        "username": "nick_nick_go",
                        "content": "Simple DFS with Memo works"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Naive DFS) [Time Limit Exceeded]\n\n  \n**Approach 2:** (DFS + Memoization) [Accepted]\n\n  \n**Approach 3:** (Peeling Onion) [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "use dfs and little memoization to solve it. go every node and check whethere we are getting maximum node from that point ."
                    },
                    {
                        "username": "littleRainRain",
                        "content": "Is there any way we can print the longest path ? \\nin other words, if we want to return a List<Integer> for the path instead of the length of the path.... how may we do it ?"
                    },
                    {
                        "username": "Decode_Apocalypse",
                        "content": "TO PRINT ALL PATHS\\n\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    vector<vector<int>> mat;\\n\\n    void valid(int x, int y, vector<vector<int>> &path, vector<int> build, int mx){\\n        build.push_back(mat[x][y]);\\n        if(dp[x][y]==mx){\\n            path.push_back(build);\\n            return;\\n        }\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        int X[4]={-1,1,0,0};\\n        int Y[4]={0,0,1,-1};\\n        for(int i=0;i<4;i++){\\n            int newX=x+X[i];\\n            int newY=y+Y[i];\\n            if(newX<n && newY<m && newX>=0 && newY>=0 && dp[newX][newY]==dp[x][y]+1){\\n                valid(newX,newY,path,build,mx);\\n            }\\n        }\\n        build.pop_back();\\n        return;\\n    }\\n\\n    void PRINT(int mx, int n, int m){\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                vector<vector<int>> path;\\n                int x=i;\\n                int y=j;\\n                if(dp[x][y]==1){\\n                    valid(x,y,path,{},mx);\\n                    for(auto p: path){\\n                        for(auto v: p){\\n                            cout<<v<<\"->\";\\n                        }\\n                        cout<<\"END\";\\n                        cout<<endl;\\n                    }\\n                    cout<<endl;\\n                }\\n            }\\n        }\\n    }\\n\\n    bool isSafe(vector<vector<int>> &mat, int x, int y, int n, int m, int prev){\\n        return x>=0 && y>=0 && x<n && y<m && mat[x][y]>prev;\\n    }\\n\\n    int LIP(vector<vector<int>> &mat, int x, int y, int n, int m, int prev){\\n        if(isSafe(mat,x,y,n,m,prev)==false){\\n            return 0;\\n        }\\n        if(dp[x][y]!=-1){\\n            return dp[x][y];\\n        }\\n        int UP=LIP(mat,x-1,y,n,m,mat[x][y]); \\n        int DOWN=LIP(mat,x+1,y,n,m,mat[x][y]);\\n        int RIGHT=LIP(mat,x,y+1,n,m,mat[x][y]);\\n        int LEFT=LIP(mat,x,y-1,n,m,mat[x][y]);\\n        return dp[x][y]=1+max({UP,DOWN,LEFT,RIGHT});\\n    }\\n\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int res=1;\\n        mat=matrix;\\n        memset(dp,-1,sizeof(dp));\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int temp=LIP(matrix,i,j,n,m,INT_MIN);\\n                res=max(res,temp);\\n            }\\n        }\\n        PRINT(res,n,m);\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1728744,
                "content": [
                    {
                        "username": "rmn",
                        "content": "It's pretty straightforward Dfs + memoization. You don't even need to mark cells as seen due to the nature of the problem.\\nI think there are plenty of \"Medium\" rated questions out there that are a lot harder than this one :)"
                    },
                    {
                        "username": "feng3245",
                        "content": "[@cartesPerforees](/cartesPerforees) It is only hard if you believed it is hard and worked the difficulty into the question. Note how there is mention of no looping around... if you took it into account without looking at the property of the path being increasing then you would assume you could not use memoization... which will make this a hard"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Agreed. If this one is marked hard, then at the very least all DP problems should be marked as such, because this is one of the most straight forward DP to figure out"
                    },
                    {
                        "username": "hashdgwhansb",
                        "content": "For those who are having TLE in there memoized DFS, pass the matrix using call by reference rather call by value.\\nIn passing it through call by value it copies that 200 by 200 everytime which increases the time complexity. So pass it call by reference ;)"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "thanks!"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "helpful"
                    },
                    {
                        "username": "Linmuadido",
                        "content": "Hello, everybody:\\n\\nI think the relax-based method, either DP or DFS (or both) , is working fine with the complexity O(mn).\\n\\nIn terms of graph model, the original problem input is a DAG(directed acrylic graph). However \"non-decreasing\" path requires bi-directional edge between neighbors with the same value. That is, the graph is not a DAG anymore.\\n\\nIf the problem changes to longest \"non-decreasing\" instead of \"increasing\" path, anyone thinks it is still doable in O(mn) time? How? Or Why not?"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "In the case of DP only solution. Shouldn\\'t we perform two passes?"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "This should be medium while [Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/description/) should be hard."
                    },
                    {
                        "username": "asirojiddinov96",
                        "content": "i guess in both question logic is pretty same DFS+memo"
                    },
                    {
                        "username": "hlin117",
                        "content": "In the solution, they mention that the naive DFS solution starting from each square is O(2^(n + m)). Can someone explain how they derive this?"
                    },
                    {
                        "username": "aman07",
                        "content": "Hello everyone!, I was just curious as to why this question cannot be solved with BFS? Or maybe it can be solved but it is just too long. I don\\'t know, I am confused. Can anyone explain? Thanks in advance!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "A bit late here but at first glance with BFS you won\\'t be able to use memoization efficiently and hence will end up in TLE."
                    },
                    {
                        "username": "nick_nick_go",
                        "content": "Simple DFS with Memo works"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Naive DFS) [Time Limit Exceeded]\n\n  \n**Approach 2:** (DFS + Memoization) [Accepted]\n\n  \n**Approach 3:** (Peeling Onion) [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "use dfs and little memoization to solve it. go every node and check whethere we are getting maximum node from that point ."
                    },
                    {
                        "username": "littleRainRain",
                        "content": "Is there any way we can print the longest path ? \\nin other words, if we want to return a List<Integer> for the path instead of the length of the path.... how may we do it ?"
                    },
                    {
                        "username": "Decode_Apocalypse",
                        "content": "TO PRINT ALL PATHS\\n\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    vector<vector<int>> mat;\\n\\n    void valid(int x, int y, vector<vector<int>> &path, vector<int> build, int mx){\\n        build.push_back(mat[x][y]);\\n        if(dp[x][y]==mx){\\n            path.push_back(build);\\n            return;\\n        }\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        int X[4]={-1,1,0,0};\\n        int Y[4]={0,0,1,-1};\\n        for(int i=0;i<4;i++){\\n            int newX=x+X[i];\\n            int newY=y+Y[i];\\n            if(newX<n && newY<m && newX>=0 && newY>=0 && dp[newX][newY]==dp[x][y]+1){\\n                valid(newX,newY,path,build,mx);\\n            }\\n        }\\n        build.pop_back();\\n        return;\\n    }\\n\\n    void PRINT(int mx, int n, int m){\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                vector<vector<int>> path;\\n                int x=i;\\n                int y=j;\\n                if(dp[x][y]==1){\\n                    valid(x,y,path,{},mx);\\n                    for(auto p: path){\\n                        for(auto v: p){\\n                            cout<<v<<\"->\";\\n                        }\\n                        cout<<\"END\";\\n                        cout<<endl;\\n                    }\\n                    cout<<endl;\\n                }\\n            }\\n        }\\n    }\\n\\n    bool isSafe(vector<vector<int>> &mat, int x, int y, int n, int m, int prev){\\n        return x>=0 && y>=0 && x<n && y<m && mat[x][y]>prev;\\n    }\\n\\n    int LIP(vector<vector<int>> &mat, int x, int y, int n, int m, int prev){\\n        if(isSafe(mat,x,y,n,m,prev)==false){\\n            return 0;\\n        }\\n        if(dp[x][y]!=-1){\\n            return dp[x][y];\\n        }\\n        int UP=LIP(mat,x-1,y,n,m,mat[x][y]); \\n        int DOWN=LIP(mat,x+1,y,n,m,mat[x][y]);\\n        int RIGHT=LIP(mat,x,y+1,n,m,mat[x][y]);\\n        int LEFT=LIP(mat,x,y-1,n,m,mat[x][y]);\\n        return dp[x][y]=1+max({UP,DOWN,LEFT,RIGHT});\\n    }\\n\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int res=1;\\n        mat=matrix;\\n        memset(dp,-1,sizeof(dp));\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int temp=LIP(matrix,i,j,n,m,INT_MIN);\\n                res=max(res,temp);\\n            }\\n        }\\n        PRINT(res,n,m);\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1568386,
                "content": [
                    {
                        "username": "rmn",
                        "content": "It's pretty straightforward Dfs + memoization. You don't even need to mark cells as seen due to the nature of the problem.\\nI think there are plenty of \"Medium\" rated questions out there that are a lot harder than this one :)"
                    },
                    {
                        "username": "feng3245",
                        "content": "[@cartesPerforees](/cartesPerforees) It is only hard if you believed it is hard and worked the difficulty into the question. Note how there is mention of no looping around... if you took it into account without looking at the property of the path being increasing then you would assume you could not use memoization... which will make this a hard"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Agreed. If this one is marked hard, then at the very least all DP problems should be marked as such, because this is one of the most straight forward DP to figure out"
                    },
                    {
                        "username": "hashdgwhansb",
                        "content": "For those who are having TLE in there memoized DFS, pass the matrix using call by reference rather call by value.\\nIn passing it through call by value it copies that 200 by 200 everytime which increases the time complexity. So pass it call by reference ;)"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "thanks!"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "helpful"
                    },
                    {
                        "username": "Linmuadido",
                        "content": "Hello, everybody:\\n\\nI think the relax-based method, either DP or DFS (or both) , is working fine with the complexity O(mn).\\n\\nIn terms of graph model, the original problem input is a DAG(directed acrylic graph). However \"non-decreasing\" path requires bi-directional edge between neighbors with the same value. That is, the graph is not a DAG anymore.\\n\\nIf the problem changes to longest \"non-decreasing\" instead of \"increasing\" path, anyone thinks it is still doable in O(mn) time? How? Or Why not?"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "In the case of DP only solution. Shouldn\\'t we perform two passes?"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "This should be medium while [Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/description/) should be hard."
                    },
                    {
                        "username": "asirojiddinov96",
                        "content": "i guess in both question logic is pretty same DFS+memo"
                    },
                    {
                        "username": "hlin117",
                        "content": "In the solution, they mention that the naive DFS solution starting from each square is O(2^(n + m)). Can someone explain how they derive this?"
                    },
                    {
                        "username": "aman07",
                        "content": "Hello everyone!, I was just curious as to why this question cannot be solved with BFS? Or maybe it can be solved but it is just too long. I don\\'t know, I am confused. Can anyone explain? Thanks in advance!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "A bit late here but at first glance with BFS you won\\'t be able to use memoization efficiently and hence will end up in TLE."
                    },
                    {
                        "username": "nick_nick_go",
                        "content": "Simple DFS with Memo works"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Naive DFS) [Time Limit Exceeded]\n\n  \n**Approach 2:** (DFS + Memoization) [Accepted]\n\n  \n**Approach 3:** (Peeling Onion) [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "use dfs and little memoization to solve it. go every node and check whethere we are getting maximum node from that point ."
                    },
                    {
                        "username": "littleRainRain",
                        "content": "Is there any way we can print the longest path ? \\nin other words, if we want to return a List<Integer> for the path instead of the length of the path.... how may we do it ?"
                    },
                    {
                        "username": "Decode_Apocalypse",
                        "content": "TO PRINT ALL PATHS\\n\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    vector<vector<int>> mat;\\n\\n    void valid(int x, int y, vector<vector<int>> &path, vector<int> build, int mx){\\n        build.push_back(mat[x][y]);\\n        if(dp[x][y]==mx){\\n            path.push_back(build);\\n            return;\\n        }\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        int X[4]={-1,1,0,0};\\n        int Y[4]={0,0,1,-1};\\n        for(int i=0;i<4;i++){\\n            int newX=x+X[i];\\n            int newY=y+Y[i];\\n            if(newX<n && newY<m && newX>=0 && newY>=0 && dp[newX][newY]==dp[x][y]+1){\\n                valid(newX,newY,path,build,mx);\\n            }\\n        }\\n        build.pop_back();\\n        return;\\n    }\\n\\n    void PRINT(int mx, int n, int m){\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                vector<vector<int>> path;\\n                int x=i;\\n                int y=j;\\n                if(dp[x][y]==1){\\n                    valid(x,y,path,{},mx);\\n                    for(auto p: path){\\n                        for(auto v: p){\\n                            cout<<v<<\"->\";\\n                        }\\n                        cout<<\"END\";\\n                        cout<<endl;\\n                    }\\n                    cout<<endl;\\n                }\\n            }\\n        }\\n    }\\n\\n    bool isSafe(vector<vector<int>> &mat, int x, int y, int n, int m, int prev){\\n        return x>=0 && y>=0 && x<n && y<m && mat[x][y]>prev;\\n    }\\n\\n    int LIP(vector<vector<int>> &mat, int x, int y, int n, int m, int prev){\\n        if(isSafe(mat,x,y,n,m,prev)==false){\\n            return 0;\\n        }\\n        if(dp[x][y]!=-1){\\n            return dp[x][y];\\n        }\\n        int UP=LIP(mat,x-1,y,n,m,mat[x][y]); \\n        int DOWN=LIP(mat,x+1,y,n,m,mat[x][y]);\\n        int RIGHT=LIP(mat,x,y+1,n,m,mat[x][y]);\\n        int LEFT=LIP(mat,x,y-1,n,m,mat[x][y]);\\n        return dp[x][y]=1+max({UP,DOWN,LEFT,RIGHT});\\n    }\\n\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int res=1;\\n        mat=matrix;\\n        memset(dp,-1,sizeof(dp));\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int temp=LIP(matrix,i,j,n,m,INT_MIN);\\n                res=max(res,temp);\\n            }\\n        }\\n        PRINT(res,n,m);\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1573909,
                "content": [
                    {
                        "username": "rmn",
                        "content": "It's pretty straightforward Dfs + memoization. You don't even need to mark cells as seen due to the nature of the problem.\\nI think there are plenty of \"Medium\" rated questions out there that are a lot harder than this one :)"
                    },
                    {
                        "username": "feng3245",
                        "content": "[@cartesPerforees](/cartesPerforees) It is only hard if you believed it is hard and worked the difficulty into the question. Note how there is mention of no looping around... if you took it into account without looking at the property of the path being increasing then you would assume you could not use memoization... which will make this a hard"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Agreed. If this one is marked hard, then at the very least all DP problems should be marked as such, because this is one of the most straight forward DP to figure out"
                    },
                    {
                        "username": "hashdgwhansb",
                        "content": "For those who are having TLE in there memoized DFS, pass the matrix using call by reference rather call by value.\\nIn passing it through call by value it copies that 200 by 200 everytime which increases the time complexity. So pass it call by reference ;)"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "thanks!"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "helpful"
                    },
                    {
                        "username": "Linmuadido",
                        "content": "Hello, everybody:\\n\\nI think the relax-based method, either DP or DFS (or both) , is working fine with the complexity O(mn).\\n\\nIn terms of graph model, the original problem input is a DAG(directed acrylic graph). However \"non-decreasing\" path requires bi-directional edge between neighbors with the same value. That is, the graph is not a DAG anymore.\\n\\nIf the problem changes to longest \"non-decreasing\" instead of \"increasing\" path, anyone thinks it is still doable in O(mn) time? How? Or Why not?"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "In the case of DP only solution. Shouldn\\'t we perform two passes?"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "This should be medium while [Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/description/) should be hard."
                    },
                    {
                        "username": "asirojiddinov96",
                        "content": "i guess in both question logic is pretty same DFS+memo"
                    },
                    {
                        "username": "hlin117",
                        "content": "In the solution, they mention that the naive DFS solution starting from each square is O(2^(n + m)). Can someone explain how they derive this?"
                    },
                    {
                        "username": "aman07",
                        "content": "Hello everyone!, I was just curious as to why this question cannot be solved with BFS? Or maybe it can be solved but it is just too long. I don\\'t know, I am confused. Can anyone explain? Thanks in advance!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "A bit late here but at first glance with BFS you won\\'t be able to use memoization efficiently and hence will end up in TLE."
                    },
                    {
                        "username": "nick_nick_go",
                        "content": "Simple DFS with Memo works"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Naive DFS) [Time Limit Exceeded]\n\n  \n**Approach 2:** (DFS + Memoization) [Accepted]\n\n  \n**Approach 3:** (Peeling Onion) [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "use dfs and little memoization to solve it. go every node and check whethere we are getting maximum node from that point ."
                    },
                    {
                        "username": "littleRainRain",
                        "content": "Is there any way we can print the longest path ? \\nin other words, if we want to return a List<Integer> for the path instead of the length of the path.... how may we do it ?"
                    },
                    {
                        "username": "Decode_Apocalypse",
                        "content": "TO PRINT ALL PATHS\\n\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    vector<vector<int>> mat;\\n\\n    void valid(int x, int y, vector<vector<int>> &path, vector<int> build, int mx){\\n        build.push_back(mat[x][y]);\\n        if(dp[x][y]==mx){\\n            path.push_back(build);\\n            return;\\n        }\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        int X[4]={-1,1,0,0};\\n        int Y[4]={0,0,1,-1};\\n        for(int i=0;i<4;i++){\\n            int newX=x+X[i];\\n            int newY=y+Y[i];\\n            if(newX<n && newY<m && newX>=0 && newY>=0 && dp[newX][newY]==dp[x][y]+1){\\n                valid(newX,newY,path,build,mx);\\n            }\\n        }\\n        build.pop_back();\\n        return;\\n    }\\n\\n    void PRINT(int mx, int n, int m){\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                vector<vector<int>> path;\\n                int x=i;\\n                int y=j;\\n                if(dp[x][y]==1){\\n                    valid(x,y,path,{},mx);\\n                    for(auto p: path){\\n                        for(auto v: p){\\n                            cout<<v<<\"->\";\\n                        }\\n                        cout<<\"END\";\\n                        cout<<endl;\\n                    }\\n                    cout<<endl;\\n                }\\n            }\\n        }\\n    }\\n\\n    bool isSafe(vector<vector<int>> &mat, int x, int y, int n, int m, int prev){\\n        return x>=0 && y>=0 && x<n && y<m && mat[x][y]>prev;\\n    }\\n\\n    int LIP(vector<vector<int>> &mat, int x, int y, int n, int m, int prev){\\n        if(isSafe(mat,x,y,n,m,prev)==false){\\n            return 0;\\n        }\\n        if(dp[x][y]!=-1){\\n            return dp[x][y];\\n        }\\n        int UP=LIP(mat,x-1,y,n,m,mat[x][y]); \\n        int DOWN=LIP(mat,x+1,y,n,m,mat[x][y]);\\n        int RIGHT=LIP(mat,x,y+1,n,m,mat[x][y]);\\n        int LEFT=LIP(mat,x,y-1,n,m,mat[x][y]);\\n        return dp[x][y]=1+max({UP,DOWN,LEFT,RIGHT});\\n    }\\n\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int res=1;\\n        mat=matrix;\\n        memset(dp,-1,sizeof(dp));\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int temp=LIP(matrix,i,j,n,m,INT_MIN);\\n                res=max(res,temp);\\n            }\\n        }\\n        PRINT(res,n,m);\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1573410,
                "content": [
                    {
                        "username": "rmn",
                        "content": "It's pretty straightforward Dfs + memoization. You don't even need to mark cells as seen due to the nature of the problem.\\nI think there are plenty of \"Medium\" rated questions out there that are a lot harder than this one :)"
                    },
                    {
                        "username": "feng3245",
                        "content": "[@cartesPerforees](/cartesPerforees) It is only hard if you believed it is hard and worked the difficulty into the question. Note how there is mention of no looping around... if you took it into account without looking at the property of the path being increasing then you would assume you could not use memoization... which will make this a hard"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Agreed. If this one is marked hard, then at the very least all DP problems should be marked as such, because this is one of the most straight forward DP to figure out"
                    },
                    {
                        "username": "hashdgwhansb",
                        "content": "For those who are having TLE in there memoized DFS, pass the matrix using call by reference rather call by value.\\nIn passing it through call by value it copies that 200 by 200 everytime which increases the time complexity. So pass it call by reference ;)"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "thanks!"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "helpful"
                    },
                    {
                        "username": "Linmuadido",
                        "content": "Hello, everybody:\\n\\nI think the relax-based method, either DP or DFS (or both) , is working fine with the complexity O(mn).\\n\\nIn terms of graph model, the original problem input is a DAG(directed acrylic graph). However \"non-decreasing\" path requires bi-directional edge between neighbors with the same value. That is, the graph is not a DAG anymore.\\n\\nIf the problem changes to longest \"non-decreasing\" instead of \"increasing\" path, anyone thinks it is still doable in O(mn) time? How? Or Why not?"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "In the case of DP only solution. Shouldn\\'t we perform two passes?"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "This should be medium while [Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/description/) should be hard."
                    },
                    {
                        "username": "asirojiddinov96",
                        "content": "i guess in both question logic is pretty same DFS+memo"
                    },
                    {
                        "username": "hlin117",
                        "content": "In the solution, they mention that the naive DFS solution starting from each square is O(2^(n + m)). Can someone explain how they derive this?"
                    },
                    {
                        "username": "aman07",
                        "content": "Hello everyone!, I was just curious as to why this question cannot be solved with BFS? Or maybe it can be solved but it is just too long. I don\\'t know, I am confused. Can anyone explain? Thanks in advance!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "A bit late here but at first glance with BFS you won\\'t be able to use memoization efficiently and hence will end up in TLE."
                    },
                    {
                        "username": "nick_nick_go",
                        "content": "Simple DFS with Memo works"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Naive DFS) [Time Limit Exceeded]\n\n  \n**Approach 2:** (DFS + Memoization) [Accepted]\n\n  \n**Approach 3:** (Peeling Onion) [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "use dfs and little memoization to solve it. go every node and check whethere we are getting maximum node from that point ."
                    },
                    {
                        "username": "littleRainRain",
                        "content": "Is there any way we can print the longest path ? \\nin other words, if we want to return a List<Integer> for the path instead of the length of the path.... how may we do it ?"
                    },
                    {
                        "username": "Decode_Apocalypse",
                        "content": "TO PRINT ALL PATHS\\n\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    vector<vector<int>> mat;\\n\\n    void valid(int x, int y, vector<vector<int>> &path, vector<int> build, int mx){\\n        build.push_back(mat[x][y]);\\n        if(dp[x][y]==mx){\\n            path.push_back(build);\\n            return;\\n        }\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        int X[4]={-1,1,0,0};\\n        int Y[4]={0,0,1,-1};\\n        for(int i=0;i<4;i++){\\n            int newX=x+X[i];\\n            int newY=y+Y[i];\\n            if(newX<n && newY<m && newX>=0 && newY>=0 && dp[newX][newY]==dp[x][y]+1){\\n                valid(newX,newY,path,build,mx);\\n            }\\n        }\\n        build.pop_back();\\n        return;\\n    }\\n\\n    void PRINT(int mx, int n, int m){\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                vector<vector<int>> path;\\n                int x=i;\\n                int y=j;\\n                if(dp[x][y]==1){\\n                    valid(x,y,path,{},mx);\\n                    for(auto p: path){\\n                        for(auto v: p){\\n                            cout<<v<<\"->\";\\n                        }\\n                        cout<<\"END\";\\n                        cout<<endl;\\n                    }\\n                    cout<<endl;\\n                }\\n            }\\n        }\\n    }\\n\\n    bool isSafe(vector<vector<int>> &mat, int x, int y, int n, int m, int prev){\\n        return x>=0 && y>=0 && x<n && y<m && mat[x][y]>prev;\\n    }\\n\\n    int LIP(vector<vector<int>> &mat, int x, int y, int n, int m, int prev){\\n        if(isSafe(mat,x,y,n,m,prev)==false){\\n            return 0;\\n        }\\n        if(dp[x][y]!=-1){\\n            return dp[x][y];\\n        }\\n        int UP=LIP(mat,x-1,y,n,m,mat[x][y]); \\n        int DOWN=LIP(mat,x+1,y,n,m,mat[x][y]);\\n        int RIGHT=LIP(mat,x,y+1,n,m,mat[x][y]);\\n        int LEFT=LIP(mat,x,y-1,n,m,mat[x][y]);\\n        return dp[x][y]=1+max({UP,DOWN,LEFT,RIGHT});\\n    }\\n\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int res=1;\\n        mat=matrix;\\n        memset(dp,-1,sizeof(dp));\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int temp=LIP(matrix,i,j,n,m,INT_MIN);\\n                res=max(res,temp);\\n            }\\n        }\\n        PRINT(res,n,m);\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1567761,
                "content": [
                    {
                        "username": "rmn",
                        "content": "It's pretty straightforward Dfs + memoization. You don't even need to mark cells as seen due to the nature of the problem.\\nI think there are plenty of \"Medium\" rated questions out there that are a lot harder than this one :)"
                    },
                    {
                        "username": "feng3245",
                        "content": "[@cartesPerforees](/cartesPerforees) It is only hard if you believed it is hard and worked the difficulty into the question. Note how there is mention of no looping around... if you took it into account without looking at the property of the path being increasing then you would assume you could not use memoization... which will make this a hard"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Agreed. If this one is marked hard, then at the very least all DP problems should be marked as such, because this is one of the most straight forward DP to figure out"
                    },
                    {
                        "username": "hashdgwhansb",
                        "content": "For those who are having TLE in there memoized DFS, pass the matrix using call by reference rather call by value.\\nIn passing it through call by value it copies that 200 by 200 everytime which increases the time complexity. So pass it call by reference ;)"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "thanks!"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "helpful"
                    },
                    {
                        "username": "Linmuadido",
                        "content": "Hello, everybody:\\n\\nI think the relax-based method, either DP or DFS (or both) , is working fine with the complexity O(mn).\\n\\nIn terms of graph model, the original problem input is a DAG(directed acrylic graph). However \"non-decreasing\" path requires bi-directional edge between neighbors with the same value. That is, the graph is not a DAG anymore.\\n\\nIf the problem changes to longest \"non-decreasing\" instead of \"increasing\" path, anyone thinks it is still doable in O(mn) time? How? Or Why not?"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "In the case of DP only solution. Shouldn\\'t we perform two passes?"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "This should be medium while [Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/description/) should be hard."
                    },
                    {
                        "username": "asirojiddinov96",
                        "content": "i guess in both question logic is pretty same DFS+memo"
                    },
                    {
                        "username": "hlin117",
                        "content": "In the solution, they mention that the naive DFS solution starting from each square is O(2^(n + m)). Can someone explain how they derive this?"
                    },
                    {
                        "username": "aman07",
                        "content": "Hello everyone!, I was just curious as to why this question cannot be solved with BFS? Or maybe it can be solved but it is just too long. I don\\'t know, I am confused. Can anyone explain? Thanks in advance!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "A bit late here but at first glance with BFS you won\\'t be able to use memoization efficiently and hence will end up in TLE."
                    },
                    {
                        "username": "nick_nick_go",
                        "content": "Simple DFS with Memo works"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Naive DFS) [Time Limit Exceeded]\n\n  \n**Approach 2:** (DFS + Memoization) [Accepted]\n\n  \n**Approach 3:** (Peeling Onion) [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "use dfs and little memoization to solve it. go every node and check whethere we are getting maximum node from that point ."
                    },
                    {
                        "username": "littleRainRain",
                        "content": "Is there any way we can print the longest path ? \\nin other words, if we want to return a List<Integer> for the path instead of the length of the path.... how may we do it ?"
                    },
                    {
                        "username": "Decode_Apocalypse",
                        "content": "TO PRINT ALL PATHS\\n\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    vector<vector<int>> mat;\\n\\n    void valid(int x, int y, vector<vector<int>> &path, vector<int> build, int mx){\\n        build.push_back(mat[x][y]);\\n        if(dp[x][y]==mx){\\n            path.push_back(build);\\n            return;\\n        }\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        int X[4]={-1,1,0,0};\\n        int Y[4]={0,0,1,-1};\\n        for(int i=0;i<4;i++){\\n            int newX=x+X[i];\\n            int newY=y+Y[i];\\n            if(newX<n && newY<m && newX>=0 && newY>=0 && dp[newX][newY]==dp[x][y]+1){\\n                valid(newX,newY,path,build,mx);\\n            }\\n        }\\n        build.pop_back();\\n        return;\\n    }\\n\\n    void PRINT(int mx, int n, int m){\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                vector<vector<int>> path;\\n                int x=i;\\n                int y=j;\\n                if(dp[x][y]==1){\\n                    valid(x,y,path,{},mx);\\n                    for(auto p: path){\\n                        for(auto v: p){\\n                            cout<<v<<\"->\";\\n                        }\\n                        cout<<\"END\";\\n                        cout<<endl;\\n                    }\\n                    cout<<endl;\\n                }\\n            }\\n        }\\n    }\\n\\n    bool isSafe(vector<vector<int>> &mat, int x, int y, int n, int m, int prev){\\n        return x>=0 && y>=0 && x<n && y<m && mat[x][y]>prev;\\n    }\\n\\n    int LIP(vector<vector<int>> &mat, int x, int y, int n, int m, int prev){\\n        if(isSafe(mat,x,y,n,m,prev)==false){\\n            return 0;\\n        }\\n        if(dp[x][y]!=-1){\\n            return dp[x][y];\\n        }\\n        int UP=LIP(mat,x-1,y,n,m,mat[x][y]); \\n        int DOWN=LIP(mat,x+1,y,n,m,mat[x][y]);\\n        int RIGHT=LIP(mat,x,y+1,n,m,mat[x][y]);\\n        int LEFT=LIP(mat,x,y-1,n,m,mat[x][y]);\\n        return dp[x][y]=1+max({UP,DOWN,LEFT,RIGHT});\\n    }\\n\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int res=1;\\n        mat=matrix;\\n        memset(dp,-1,sizeof(dp));\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int temp=LIP(matrix,i,j,n,m,INT_MIN);\\n                res=max(res,temp);\\n            }\\n        }\\n        PRINT(res,n,m);\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1675956,
                "content": [
                    {
                        "username": "rmn",
                        "content": "It's pretty straightforward Dfs + memoization. You don't even need to mark cells as seen due to the nature of the problem.\\nI think there are plenty of \"Medium\" rated questions out there that are a lot harder than this one :)"
                    },
                    {
                        "username": "feng3245",
                        "content": "[@cartesPerforees](/cartesPerforees) It is only hard if you believed it is hard and worked the difficulty into the question. Note how there is mention of no looping around... if you took it into account without looking at the property of the path being increasing then you would assume you could not use memoization... which will make this a hard"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Agreed. If this one is marked hard, then at the very least all DP problems should be marked as such, because this is one of the most straight forward DP to figure out"
                    },
                    {
                        "username": "hashdgwhansb",
                        "content": "For those who are having TLE in there memoized DFS, pass the matrix using call by reference rather call by value.\\nIn passing it through call by value it copies that 200 by 200 everytime which increases the time complexity. So pass it call by reference ;)"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "thanks!"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "helpful"
                    },
                    {
                        "username": "Linmuadido",
                        "content": "Hello, everybody:\\n\\nI think the relax-based method, either DP or DFS (or both) , is working fine with the complexity O(mn).\\n\\nIn terms of graph model, the original problem input is a DAG(directed acrylic graph). However \"non-decreasing\" path requires bi-directional edge between neighbors with the same value. That is, the graph is not a DAG anymore.\\n\\nIf the problem changes to longest \"non-decreasing\" instead of \"increasing\" path, anyone thinks it is still doable in O(mn) time? How? Or Why not?"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "In the case of DP only solution. Shouldn\\'t we perform two passes?"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "This should be medium while [Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/description/) should be hard."
                    },
                    {
                        "username": "asirojiddinov96",
                        "content": "i guess in both question logic is pretty same DFS+memo"
                    },
                    {
                        "username": "hlin117",
                        "content": "In the solution, they mention that the naive DFS solution starting from each square is O(2^(n + m)). Can someone explain how they derive this?"
                    },
                    {
                        "username": "aman07",
                        "content": "Hello everyone!, I was just curious as to why this question cannot be solved with BFS? Or maybe it can be solved but it is just too long. I don\\'t know, I am confused. Can anyone explain? Thanks in advance!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "A bit late here but at first glance with BFS you won\\'t be able to use memoization efficiently and hence will end up in TLE."
                    },
                    {
                        "username": "nick_nick_go",
                        "content": "Simple DFS with Memo works"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Naive DFS) [Time Limit Exceeded]\n\n  \n**Approach 2:** (DFS + Memoization) [Accepted]\n\n  \n**Approach 3:** (Peeling Onion) [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "use dfs and little memoization to solve it. go every node and check whethere we are getting maximum node from that point ."
                    },
                    {
                        "username": "littleRainRain",
                        "content": "Is there any way we can print the longest path ? \\nin other words, if we want to return a List<Integer> for the path instead of the length of the path.... how may we do it ?"
                    },
                    {
                        "username": "Decode_Apocalypse",
                        "content": "TO PRINT ALL PATHS\\n\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    vector<vector<int>> mat;\\n\\n    void valid(int x, int y, vector<vector<int>> &path, vector<int> build, int mx){\\n        build.push_back(mat[x][y]);\\n        if(dp[x][y]==mx){\\n            path.push_back(build);\\n            return;\\n        }\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        int X[4]={-1,1,0,0};\\n        int Y[4]={0,0,1,-1};\\n        for(int i=0;i<4;i++){\\n            int newX=x+X[i];\\n            int newY=y+Y[i];\\n            if(newX<n && newY<m && newX>=0 && newY>=0 && dp[newX][newY]==dp[x][y]+1){\\n                valid(newX,newY,path,build,mx);\\n            }\\n        }\\n        build.pop_back();\\n        return;\\n    }\\n\\n    void PRINT(int mx, int n, int m){\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                vector<vector<int>> path;\\n                int x=i;\\n                int y=j;\\n                if(dp[x][y]==1){\\n                    valid(x,y,path,{},mx);\\n                    for(auto p: path){\\n                        for(auto v: p){\\n                            cout<<v<<\"->\";\\n                        }\\n                        cout<<\"END\";\\n                        cout<<endl;\\n                    }\\n                    cout<<endl;\\n                }\\n            }\\n        }\\n    }\\n\\n    bool isSafe(vector<vector<int>> &mat, int x, int y, int n, int m, int prev){\\n        return x>=0 && y>=0 && x<n && y<m && mat[x][y]>prev;\\n    }\\n\\n    int LIP(vector<vector<int>> &mat, int x, int y, int n, int m, int prev){\\n        if(isSafe(mat,x,y,n,m,prev)==false){\\n            return 0;\\n        }\\n        if(dp[x][y]!=-1){\\n            return dp[x][y];\\n        }\\n        int UP=LIP(mat,x-1,y,n,m,mat[x][y]); \\n        int DOWN=LIP(mat,x+1,y,n,m,mat[x][y]);\\n        int RIGHT=LIP(mat,x,y+1,n,m,mat[x][y]);\\n        int LEFT=LIP(mat,x,y-1,n,m,mat[x][y]);\\n        return dp[x][y]=1+max({UP,DOWN,LEFT,RIGHT});\\n    }\\n\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int res=1;\\n        mat=matrix;\\n        memset(dp,-1,sizeof(dp));\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int temp=LIP(matrix,i,j,n,m,INT_MIN);\\n                res=max(res,temp);\\n            }\\n        }\\n        PRINT(res,n,m);\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1572277,
                "content": [
                    {
                        "username": "rmn",
                        "content": "It's pretty straightforward Dfs + memoization. You don't even need to mark cells as seen due to the nature of the problem.\\nI think there are plenty of \"Medium\" rated questions out there that are a lot harder than this one :)"
                    },
                    {
                        "username": "feng3245",
                        "content": "[@cartesPerforees](/cartesPerforees) It is only hard if you believed it is hard and worked the difficulty into the question. Note how there is mention of no looping around... if you took it into account without looking at the property of the path being increasing then you would assume you could not use memoization... which will make this a hard"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Agreed. If this one is marked hard, then at the very least all DP problems should be marked as such, because this is one of the most straight forward DP to figure out"
                    },
                    {
                        "username": "hashdgwhansb",
                        "content": "For those who are having TLE in there memoized DFS, pass the matrix using call by reference rather call by value.\\nIn passing it through call by value it copies that 200 by 200 everytime which increases the time complexity. So pass it call by reference ;)"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "thanks!"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "helpful"
                    },
                    {
                        "username": "Linmuadido",
                        "content": "Hello, everybody:\\n\\nI think the relax-based method, either DP or DFS (or both) , is working fine with the complexity O(mn).\\n\\nIn terms of graph model, the original problem input is a DAG(directed acrylic graph). However \"non-decreasing\" path requires bi-directional edge between neighbors with the same value. That is, the graph is not a DAG anymore.\\n\\nIf the problem changes to longest \"non-decreasing\" instead of \"increasing\" path, anyone thinks it is still doable in O(mn) time? How? Or Why not?"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "In the case of DP only solution. Shouldn\\'t we perform two passes?"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "This should be medium while [Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/description/) should be hard."
                    },
                    {
                        "username": "asirojiddinov96",
                        "content": "i guess in both question logic is pretty same DFS+memo"
                    },
                    {
                        "username": "hlin117",
                        "content": "In the solution, they mention that the naive DFS solution starting from each square is O(2^(n + m)). Can someone explain how they derive this?"
                    },
                    {
                        "username": "aman07",
                        "content": "Hello everyone!, I was just curious as to why this question cannot be solved with BFS? Or maybe it can be solved but it is just too long. I don\\'t know, I am confused. Can anyone explain? Thanks in advance!"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "A bit late here but at first glance with BFS you won\\'t be able to use memoization efficiently and hence will end up in TLE."
                    },
                    {
                        "username": "nick_nick_go",
                        "content": "Simple DFS with Memo works"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** (Naive DFS) [Time Limit Exceeded]\n\n  \n**Approach 2:** (DFS + Memoization) [Accepted]\n\n  \n**Approach 3:** (Peeling Onion) [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "use dfs and little memoization to solve it. go every node and check whethere we are getting maximum node from that point ."
                    },
                    {
                        "username": "littleRainRain",
                        "content": "Is there any way we can print the longest path ? \\nin other words, if we want to return a List<Integer> for the path instead of the length of the path.... how may we do it ?"
                    },
                    {
                        "username": "Decode_Apocalypse",
                        "content": "TO PRINT ALL PATHS\\n\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    vector<vector<int>> mat;\\n\\n    void valid(int x, int y, vector<vector<int>> &path, vector<int> build, int mx){\\n        build.push_back(mat[x][y]);\\n        if(dp[x][y]==mx){\\n            path.push_back(build);\\n            return;\\n        }\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        int X[4]={-1,1,0,0};\\n        int Y[4]={0,0,1,-1};\\n        for(int i=0;i<4;i++){\\n            int newX=x+X[i];\\n            int newY=y+Y[i];\\n            if(newX<n && newY<m && newX>=0 && newY>=0 && dp[newX][newY]==dp[x][y]+1){\\n                valid(newX,newY,path,build,mx);\\n            }\\n        }\\n        build.pop_back();\\n        return;\\n    }\\n\\n    void PRINT(int mx, int n, int m){\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                vector<vector<int>> path;\\n                int x=i;\\n                int y=j;\\n                if(dp[x][y]==1){\\n                    valid(x,y,path,{},mx);\\n                    for(auto p: path){\\n                        for(auto v: p){\\n                            cout<<v<<\"->\";\\n                        }\\n                        cout<<\"END\";\\n                        cout<<endl;\\n                    }\\n                    cout<<endl;\\n                }\\n            }\\n        }\\n    }\\n\\n    bool isSafe(vector<vector<int>> &mat, int x, int y, int n, int m, int prev){\\n        return x>=0 && y>=0 && x<n && y<m && mat[x][y]>prev;\\n    }\\n\\n    int LIP(vector<vector<int>> &mat, int x, int y, int n, int m, int prev){\\n        if(isSafe(mat,x,y,n,m,prev)==false){\\n            return 0;\\n        }\\n        if(dp[x][y]!=-1){\\n            return dp[x][y];\\n        }\\n        int UP=LIP(mat,x-1,y,n,m,mat[x][y]); \\n        int DOWN=LIP(mat,x+1,y,n,m,mat[x][y]);\\n        int RIGHT=LIP(mat,x,y+1,n,m,mat[x][y]);\\n        int LEFT=LIP(mat,x,y-1,n,m,mat[x][y]);\\n        return dp[x][y]=1+max({UP,DOWN,LEFT,RIGHT});\\n    }\\n\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int res=1;\\n        mat=matrix;\\n        memset(dp,-1,sizeof(dp));\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int temp=LIP(matrix,i,j,n,m,INT_MIN);\\n                res=max(res,temp);\\n            }\\n        }\\n        PRINT(res,n,m);\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1927393,
                "content": [
                    {
                        "username": "kenzgf",
                        "content": "More like medium. Much easier than some medium DP problems..."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**This problem was asked in the Accenture Coding Assessment 2024. It involved a slight modification[Easy Version]: \nIncreasing the subsequence by only 1. \nAdditionally, the matrix in this assessment had equal numbers of rows and columns.**"
                    },
                    {
                        "username": "BigDaddyO",
                        "content": "Why is the iterative dp approach used in the question 01 Matrix not applicable in here ??"
                    },
                    {
                        "username": "robert2189",
                        "content": "I\\'m surprised this was considered hard. Seemed like a medium question. "
                    },
                    {
                        "username": "mihirg42",
                        "content": "\\nclass Solution {\\n  public:\\n  int dp(vector<vector<int>>& matrix, int n, int m, int i, int j, vector<vector<int>> &t)\\n    {\\n        if(j >= m || i >= n || i < 0 || j < 0)\\n            return 0;\\n        if(t[i][j] != -1)\\n            return t[i][j];\\n        if(i > 0 && matrix[i][j] < matrix[i - 1][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i - 1, j, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(j > 0 && matrix[i][j] < matrix[i][j - 1])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i, j - 1, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(i < n - 1 && matrix[i + 1][j] > matrix[i][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i + 1, j, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(j < m - 1 && matrix[i][j + 1] > matrix[i][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i, j + 1, t), dp(matrix, n, m, i, j, t));\\n        }\\n        return 0;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> t(n, vector<int>(m, -1));\\n        int mx = -1;\\n        dp(matrix, n, m, 0, 0, t);\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n                mx = max(t[i][j], mx);\\n        }\\n        return mx;\\n    }\\n};"
                    },
                    {
                        "username": "mihirg42",
                        "content": "can someone help me debug this code? the matrix t(used for memoization) is not updating.\\n\\n\\nclass Solution {\\n  public:\\n  int dp(vector<vector<int>>& matrix, int n, int m, int i, int j, vector<vector<int>> &t)\\n    {\\n        if(j >= m || i >= n || i < 0 || j < 0)\\n            return 0;\\n        if(t[i][j] != -1)\\n            return t[i][j];\\n        if(i > 0 && matrix[i][j] < matrix[i - 1][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i - 1, j, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(j > 0 && matrix[i][j] < matrix[i][j - 1])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i, j - 1, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(i < n - 1 && matrix[i + 1][j] > matrix[i][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i + 1, j, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(j < m - 1 && matrix[i][j + 1] > matrix[i][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i, j + 1, t), dp(matrix, n, m, i, j, t));\\n        }\\n        return 0;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> t(n, vector<int>(m, -1));\\n        int mx = -1;\\n        dp(matrix, n, m, 0, 0, t);\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n                mx = max(t[i][j], mx);\\n        }\\n        return mx;\\n    }\\n};"
                    },
                    {
                        "username": "lookforlohith",
                        "content": " `class Solution:\\n\\n    def inbounds(self, index, size):\\n        return index >=0 and index < size\\n\\n    def longestIncreasingPathIndex(self, matrix, x, y, cache) -> int:\\n\\n        key=\"x=\"+str(x)+\"y=\"+str(y)\\n        if key in cache:\\n            return cache[key]\\n\\n        paths = [(0, 1),(1, 0), (0, -1),(-1, 0)]\\n        max_value=0\\n        for path in paths:\\n            new_x =x+path[0]\\n            new_y= y+path[1]\\n            left_inbound = self.inbounds(new_x, len(matrix))\\n            right_inbound = self.inbounds(new_y, len(matrix[0]))\\n            if left_inbound and right_inbound and (matrix[new_x][new_y] > matrix[x][y]):\\n                max_value = max(max_value, self.longestIncreasingPathIndex(matrix, new_x, new_y, cache))\\n        \\n        cache[key]=max_value+1\\n        return cache[key]\\n\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n\\n        cache = {}\\n        max_value=0\\n        for i in range(0, len(matrix)):\\n            for j in range(0, len(matrix[i])):\\n                result = self.longestIncreasingPathIndex(matrix, i, j, cache)\\n                max_value = max(max_value, result)\\n        \\n        return max_value`"
                    },
                    {
                        "username": "neergoel",
                        "content": "My JAVA solution\\nhttps://github.com/neerajgoel/LeetCode-Java/blob/1d8606a6a1c171cfadc3f0c2604e9dfc72ea5f24/src/com/questions/_329_Longest_Increasing_Path_in_a_Matrix_01.java"
                    },
                    {
                        "username": "lokie838",
                        "content": "I haven\\'t understood the solution. can anyone give a video explanation for this problem."
                    },
                    {
                        "username": "DeltaLF",
                        "content": "329:https://www.youtube.com/watch?v=wCc_nd-GiEc If you are familiar with dynamic programming questions, this one is not too hard. I suggest that you can try some simpler dynamic programming questions first. It will help you understand complicated questions."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nGraph DFS traversal C++... Simple\\n\\n# Approach\\n\\n1. Define two arrays: `rN` and `cN`, representing the row and column neighbors. These arrays store the relative positions of the neighboring cells in the matrix.\\n2. Create a recursive function called `rec` that takes the following parameters:\\n   - `row` and `col`: The current row and column indices.\\n   - `m` and `n`: The total number of rows and columns in the matrix.\\n   - `matrix`: The matrix containing integer values.\\n   - `dp`: A 2D vector representing a dynamic programming array used for memoization.\\n3. Check if the value for the current position `(row, col)` in the `dp` array is already calculated. If it is, return the stored value.\\n4. Initialize a variable `sum` to 1, representing the length of the current path starting from `(row, col)`.\\n5. Iterate through the four possible neighboring cells using a `for` loop:\\n   - Calculate the indices of the neighboring cell (`rV` and `cV`) by adding the corresponding values from the `rN` and `cN` arrays to the current position.\\n   - Check if the neighboring cell is within the bounds of the matrix and if the value in the neighboring cell is greater than the value in the current cell.\\n   - If the conditions are met, calculate the length of the longest increasing path starting from the neighboring cell by recursively calling the `rec` function with the updated indices.\\n   - Update the `sum` variable to the maximum value between the current `sum` and the length of the path starting from the neighboring cell.\\n6. Store the calculated `sum` in the `dp` array for the current position `(row, col)`.\\n7. Return the `sum` as the result of the `rec` function.\\n8. Implement the `longestIncreasingPath` function that takes the `matrix` as input.\\n9. Initialize variables `m` and `n` to store the number of rows and columns in the matrix, respectively.\\n10. Create a 2D vector `dp` of size `(m+1) x (n+1)` and initialize all values to -1.\\n11. Initialize a variable `ans` to store the maximum length of the increasing path found so far.\\n12. Iterate through each cell in the matrix using nested `for` loops:\\n    - Update the `ans` variable to the maximum value between the current `ans` and the result of the `rec` function called for each cell.\\n13. Return the `ans` as the final result of the `longestIncreasingPath` function.\\n---------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(m*n*4)\\n\\n- Space complexity:\\nS.C=O(m*n) \\n\\n------------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/longest-increasing-path-in-a-matrix/solutions/3686121/graph-dfs-traversal-c-simple/"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "you have to provide tip not the solution in English "
                    }
                ]
            },
            {
                "id": 2068306,
                "content": [
                    {
                        "username": "kenzgf",
                        "content": "More like medium. Much easier than some medium DP problems..."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**This problem was asked in the Accenture Coding Assessment 2024. It involved a slight modification[Easy Version]: \nIncreasing the subsequence by only 1. \nAdditionally, the matrix in this assessment had equal numbers of rows and columns.**"
                    },
                    {
                        "username": "BigDaddyO",
                        "content": "Why is the iterative dp approach used in the question 01 Matrix not applicable in here ??"
                    },
                    {
                        "username": "robert2189",
                        "content": "I\\'m surprised this was considered hard. Seemed like a medium question. "
                    },
                    {
                        "username": "mihirg42",
                        "content": "\\nclass Solution {\\n  public:\\n  int dp(vector<vector<int>>& matrix, int n, int m, int i, int j, vector<vector<int>> &t)\\n    {\\n        if(j >= m || i >= n || i < 0 || j < 0)\\n            return 0;\\n        if(t[i][j] != -1)\\n            return t[i][j];\\n        if(i > 0 && matrix[i][j] < matrix[i - 1][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i - 1, j, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(j > 0 && matrix[i][j] < matrix[i][j - 1])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i, j - 1, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(i < n - 1 && matrix[i + 1][j] > matrix[i][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i + 1, j, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(j < m - 1 && matrix[i][j + 1] > matrix[i][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i, j + 1, t), dp(matrix, n, m, i, j, t));\\n        }\\n        return 0;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> t(n, vector<int>(m, -1));\\n        int mx = -1;\\n        dp(matrix, n, m, 0, 0, t);\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n                mx = max(t[i][j], mx);\\n        }\\n        return mx;\\n    }\\n};"
                    },
                    {
                        "username": "mihirg42",
                        "content": "can someone help me debug this code? the matrix t(used for memoization) is not updating.\\n\\n\\nclass Solution {\\n  public:\\n  int dp(vector<vector<int>>& matrix, int n, int m, int i, int j, vector<vector<int>> &t)\\n    {\\n        if(j >= m || i >= n || i < 0 || j < 0)\\n            return 0;\\n        if(t[i][j] != -1)\\n            return t[i][j];\\n        if(i > 0 && matrix[i][j] < matrix[i - 1][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i - 1, j, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(j > 0 && matrix[i][j] < matrix[i][j - 1])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i, j - 1, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(i < n - 1 && matrix[i + 1][j] > matrix[i][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i + 1, j, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(j < m - 1 && matrix[i][j + 1] > matrix[i][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i, j + 1, t), dp(matrix, n, m, i, j, t));\\n        }\\n        return 0;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> t(n, vector<int>(m, -1));\\n        int mx = -1;\\n        dp(matrix, n, m, 0, 0, t);\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n                mx = max(t[i][j], mx);\\n        }\\n        return mx;\\n    }\\n};"
                    },
                    {
                        "username": "lookforlohith",
                        "content": " `class Solution:\\n\\n    def inbounds(self, index, size):\\n        return index >=0 and index < size\\n\\n    def longestIncreasingPathIndex(self, matrix, x, y, cache) -> int:\\n\\n        key=\"x=\"+str(x)+\"y=\"+str(y)\\n        if key in cache:\\n            return cache[key]\\n\\n        paths = [(0, 1),(1, 0), (0, -1),(-1, 0)]\\n        max_value=0\\n        for path in paths:\\n            new_x =x+path[0]\\n            new_y= y+path[1]\\n            left_inbound = self.inbounds(new_x, len(matrix))\\n            right_inbound = self.inbounds(new_y, len(matrix[0]))\\n            if left_inbound and right_inbound and (matrix[new_x][new_y] > matrix[x][y]):\\n                max_value = max(max_value, self.longestIncreasingPathIndex(matrix, new_x, new_y, cache))\\n        \\n        cache[key]=max_value+1\\n        return cache[key]\\n\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n\\n        cache = {}\\n        max_value=0\\n        for i in range(0, len(matrix)):\\n            for j in range(0, len(matrix[i])):\\n                result = self.longestIncreasingPathIndex(matrix, i, j, cache)\\n                max_value = max(max_value, result)\\n        \\n        return max_value`"
                    },
                    {
                        "username": "neergoel",
                        "content": "My JAVA solution\\nhttps://github.com/neerajgoel/LeetCode-Java/blob/1d8606a6a1c171cfadc3f0c2604e9dfc72ea5f24/src/com/questions/_329_Longest_Increasing_Path_in_a_Matrix_01.java"
                    },
                    {
                        "username": "lokie838",
                        "content": "I haven\\'t understood the solution. can anyone give a video explanation for this problem."
                    },
                    {
                        "username": "DeltaLF",
                        "content": "329:https://www.youtube.com/watch?v=wCc_nd-GiEc If you are familiar with dynamic programming questions, this one is not too hard. I suggest that you can try some simpler dynamic programming questions first. It will help you understand complicated questions."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nGraph DFS traversal C++... Simple\\n\\n# Approach\\n\\n1. Define two arrays: `rN` and `cN`, representing the row and column neighbors. These arrays store the relative positions of the neighboring cells in the matrix.\\n2. Create a recursive function called `rec` that takes the following parameters:\\n   - `row` and `col`: The current row and column indices.\\n   - `m` and `n`: The total number of rows and columns in the matrix.\\n   - `matrix`: The matrix containing integer values.\\n   - `dp`: A 2D vector representing a dynamic programming array used for memoization.\\n3. Check if the value for the current position `(row, col)` in the `dp` array is already calculated. If it is, return the stored value.\\n4. Initialize a variable `sum` to 1, representing the length of the current path starting from `(row, col)`.\\n5. Iterate through the four possible neighboring cells using a `for` loop:\\n   - Calculate the indices of the neighboring cell (`rV` and `cV`) by adding the corresponding values from the `rN` and `cN` arrays to the current position.\\n   - Check if the neighboring cell is within the bounds of the matrix and if the value in the neighboring cell is greater than the value in the current cell.\\n   - If the conditions are met, calculate the length of the longest increasing path starting from the neighboring cell by recursively calling the `rec` function with the updated indices.\\n   - Update the `sum` variable to the maximum value between the current `sum` and the length of the path starting from the neighboring cell.\\n6. Store the calculated `sum` in the `dp` array for the current position `(row, col)`.\\n7. Return the `sum` as the result of the `rec` function.\\n8. Implement the `longestIncreasingPath` function that takes the `matrix` as input.\\n9. Initialize variables `m` and `n` to store the number of rows and columns in the matrix, respectively.\\n10. Create a 2D vector `dp` of size `(m+1) x (n+1)` and initialize all values to -1.\\n11. Initialize a variable `ans` to store the maximum length of the increasing path found so far.\\n12. Iterate through each cell in the matrix using nested `for` loops:\\n    - Update the `ans` variable to the maximum value between the current `ans` and the result of the `rec` function called for each cell.\\n13. Return the `ans` as the final result of the `longestIncreasingPath` function.\\n---------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(m*n*4)\\n\\n- Space complexity:\\nS.C=O(m*n) \\n\\n------------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/longest-increasing-path-in-a-matrix/solutions/3686121/graph-dfs-traversal-c-simple/"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "you have to provide tip not the solution in English "
                    }
                ]
            },
            {
                "id": 2025043,
                "content": [
                    {
                        "username": "kenzgf",
                        "content": "More like medium. Much easier than some medium DP problems..."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**This problem was asked in the Accenture Coding Assessment 2024. It involved a slight modification[Easy Version]: \nIncreasing the subsequence by only 1. \nAdditionally, the matrix in this assessment had equal numbers of rows and columns.**"
                    },
                    {
                        "username": "BigDaddyO",
                        "content": "Why is the iterative dp approach used in the question 01 Matrix not applicable in here ??"
                    },
                    {
                        "username": "robert2189",
                        "content": "I\\'m surprised this was considered hard. Seemed like a medium question. "
                    },
                    {
                        "username": "mihirg42",
                        "content": "\\nclass Solution {\\n  public:\\n  int dp(vector<vector<int>>& matrix, int n, int m, int i, int j, vector<vector<int>> &t)\\n    {\\n        if(j >= m || i >= n || i < 0 || j < 0)\\n            return 0;\\n        if(t[i][j] != -1)\\n            return t[i][j];\\n        if(i > 0 && matrix[i][j] < matrix[i - 1][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i - 1, j, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(j > 0 && matrix[i][j] < matrix[i][j - 1])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i, j - 1, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(i < n - 1 && matrix[i + 1][j] > matrix[i][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i + 1, j, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(j < m - 1 && matrix[i][j + 1] > matrix[i][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i, j + 1, t), dp(matrix, n, m, i, j, t));\\n        }\\n        return 0;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> t(n, vector<int>(m, -1));\\n        int mx = -1;\\n        dp(matrix, n, m, 0, 0, t);\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n                mx = max(t[i][j], mx);\\n        }\\n        return mx;\\n    }\\n};"
                    },
                    {
                        "username": "mihirg42",
                        "content": "can someone help me debug this code? the matrix t(used for memoization) is not updating.\\n\\n\\nclass Solution {\\n  public:\\n  int dp(vector<vector<int>>& matrix, int n, int m, int i, int j, vector<vector<int>> &t)\\n    {\\n        if(j >= m || i >= n || i < 0 || j < 0)\\n            return 0;\\n        if(t[i][j] != -1)\\n            return t[i][j];\\n        if(i > 0 && matrix[i][j] < matrix[i - 1][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i - 1, j, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(j > 0 && matrix[i][j] < matrix[i][j - 1])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i, j - 1, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(i < n - 1 && matrix[i + 1][j] > matrix[i][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i + 1, j, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(j < m - 1 && matrix[i][j + 1] > matrix[i][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i, j + 1, t), dp(matrix, n, m, i, j, t));\\n        }\\n        return 0;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> t(n, vector<int>(m, -1));\\n        int mx = -1;\\n        dp(matrix, n, m, 0, 0, t);\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n                mx = max(t[i][j], mx);\\n        }\\n        return mx;\\n    }\\n};"
                    },
                    {
                        "username": "lookforlohith",
                        "content": " `class Solution:\\n\\n    def inbounds(self, index, size):\\n        return index >=0 and index < size\\n\\n    def longestIncreasingPathIndex(self, matrix, x, y, cache) -> int:\\n\\n        key=\"x=\"+str(x)+\"y=\"+str(y)\\n        if key in cache:\\n            return cache[key]\\n\\n        paths = [(0, 1),(1, 0), (0, -1),(-1, 0)]\\n        max_value=0\\n        for path in paths:\\n            new_x =x+path[0]\\n            new_y= y+path[1]\\n            left_inbound = self.inbounds(new_x, len(matrix))\\n            right_inbound = self.inbounds(new_y, len(matrix[0]))\\n            if left_inbound and right_inbound and (matrix[new_x][new_y] > matrix[x][y]):\\n                max_value = max(max_value, self.longestIncreasingPathIndex(matrix, new_x, new_y, cache))\\n        \\n        cache[key]=max_value+1\\n        return cache[key]\\n\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n\\n        cache = {}\\n        max_value=0\\n        for i in range(0, len(matrix)):\\n            for j in range(0, len(matrix[i])):\\n                result = self.longestIncreasingPathIndex(matrix, i, j, cache)\\n                max_value = max(max_value, result)\\n        \\n        return max_value`"
                    },
                    {
                        "username": "neergoel",
                        "content": "My JAVA solution\\nhttps://github.com/neerajgoel/LeetCode-Java/blob/1d8606a6a1c171cfadc3f0c2604e9dfc72ea5f24/src/com/questions/_329_Longest_Increasing_Path_in_a_Matrix_01.java"
                    },
                    {
                        "username": "lokie838",
                        "content": "I haven\\'t understood the solution. can anyone give a video explanation for this problem."
                    },
                    {
                        "username": "DeltaLF",
                        "content": "329:https://www.youtube.com/watch?v=wCc_nd-GiEc If you are familiar with dynamic programming questions, this one is not too hard. I suggest that you can try some simpler dynamic programming questions first. It will help you understand complicated questions."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nGraph DFS traversal C++... Simple\\n\\n# Approach\\n\\n1. Define two arrays: `rN` and `cN`, representing the row and column neighbors. These arrays store the relative positions of the neighboring cells in the matrix.\\n2. Create a recursive function called `rec` that takes the following parameters:\\n   - `row` and `col`: The current row and column indices.\\n   - `m` and `n`: The total number of rows and columns in the matrix.\\n   - `matrix`: The matrix containing integer values.\\n   - `dp`: A 2D vector representing a dynamic programming array used for memoization.\\n3. Check if the value for the current position `(row, col)` in the `dp` array is already calculated. If it is, return the stored value.\\n4. Initialize a variable `sum` to 1, representing the length of the current path starting from `(row, col)`.\\n5. Iterate through the four possible neighboring cells using a `for` loop:\\n   - Calculate the indices of the neighboring cell (`rV` and `cV`) by adding the corresponding values from the `rN` and `cN` arrays to the current position.\\n   - Check if the neighboring cell is within the bounds of the matrix and if the value in the neighboring cell is greater than the value in the current cell.\\n   - If the conditions are met, calculate the length of the longest increasing path starting from the neighboring cell by recursively calling the `rec` function with the updated indices.\\n   - Update the `sum` variable to the maximum value between the current `sum` and the length of the path starting from the neighboring cell.\\n6. Store the calculated `sum` in the `dp` array for the current position `(row, col)`.\\n7. Return the `sum` as the result of the `rec` function.\\n8. Implement the `longestIncreasingPath` function that takes the `matrix` as input.\\n9. Initialize variables `m` and `n` to store the number of rows and columns in the matrix, respectively.\\n10. Create a 2D vector `dp` of size `(m+1) x (n+1)` and initialize all values to -1.\\n11. Initialize a variable `ans` to store the maximum length of the increasing path found so far.\\n12. Iterate through each cell in the matrix using nested `for` loops:\\n    - Update the `ans` variable to the maximum value between the current `ans` and the result of the `rec` function called for each cell.\\n13. Return the `ans` as the final result of the `longestIncreasingPath` function.\\n---------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(m*n*4)\\n\\n- Space complexity:\\nS.C=O(m*n) \\n\\n------------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/longest-increasing-path-in-a-matrix/solutions/3686121/graph-dfs-traversal-c-simple/"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "you have to provide tip not the solution in English "
                    }
                ]
            },
            {
                "id": 2015950,
                "content": [
                    {
                        "username": "kenzgf",
                        "content": "More like medium. Much easier than some medium DP problems..."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**This problem was asked in the Accenture Coding Assessment 2024. It involved a slight modification[Easy Version]: \nIncreasing the subsequence by only 1. \nAdditionally, the matrix in this assessment had equal numbers of rows and columns.**"
                    },
                    {
                        "username": "BigDaddyO",
                        "content": "Why is the iterative dp approach used in the question 01 Matrix not applicable in here ??"
                    },
                    {
                        "username": "robert2189",
                        "content": "I\\'m surprised this was considered hard. Seemed like a medium question. "
                    },
                    {
                        "username": "mihirg42",
                        "content": "\\nclass Solution {\\n  public:\\n  int dp(vector<vector<int>>& matrix, int n, int m, int i, int j, vector<vector<int>> &t)\\n    {\\n        if(j >= m || i >= n || i < 0 || j < 0)\\n            return 0;\\n        if(t[i][j] != -1)\\n            return t[i][j];\\n        if(i > 0 && matrix[i][j] < matrix[i - 1][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i - 1, j, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(j > 0 && matrix[i][j] < matrix[i][j - 1])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i, j - 1, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(i < n - 1 && matrix[i + 1][j] > matrix[i][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i + 1, j, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(j < m - 1 && matrix[i][j + 1] > matrix[i][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i, j + 1, t), dp(matrix, n, m, i, j, t));\\n        }\\n        return 0;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> t(n, vector<int>(m, -1));\\n        int mx = -1;\\n        dp(matrix, n, m, 0, 0, t);\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n                mx = max(t[i][j], mx);\\n        }\\n        return mx;\\n    }\\n};"
                    },
                    {
                        "username": "mihirg42",
                        "content": "can someone help me debug this code? the matrix t(used for memoization) is not updating.\\n\\n\\nclass Solution {\\n  public:\\n  int dp(vector<vector<int>>& matrix, int n, int m, int i, int j, vector<vector<int>> &t)\\n    {\\n        if(j >= m || i >= n || i < 0 || j < 0)\\n            return 0;\\n        if(t[i][j] != -1)\\n            return t[i][j];\\n        if(i > 0 && matrix[i][j] < matrix[i - 1][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i - 1, j, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(j > 0 && matrix[i][j] < matrix[i][j - 1])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i, j - 1, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(i < n - 1 && matrix[i + 1][j] > matrix[i][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i + 1, j, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(j < m - 1 && matrix[i][j + 1] > matrix[i][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i, j + 1, t), dp(matrix, n, m, i, j, t));\\n        }\\n        return 0;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> t(n, vector<int>(m, -1));\\n        int mx = -1;\\n        dp(matrix, n, m, 0, 0, t);\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n                mx = max(t[i][j], mx);\\n        }\\n        return mx;\\n    }\\n};"
                    },
                    {
                        "username": "lookforlohith",
                        "content": " `class Solution:\\n\\n    def inbounds(self, index, size):\\n        return index >=0 and index < size\\n\\n    def longestIncreasingPathIndex(self, matrix, x, y, cache) -> int:\\n\\n        key=\"x=\"+str(x)+\"y=\"+str(y)\\n        if key in cache:\\n            return cache[key]\\n\\n        paths = [(0, 1),(1, 0), (0, -1),(-1, 0)]\\n        max_value=0\\n        for path in paths:\\n            new_x =x+path[0]\\n            new_y= y+path[1]\\n            left_inbound = self.inbounds(new_x, len(matrix))\\n            right_inbound = self.inbounds(new_y, len(matrix[0]))\\n            if left_inbound and right_inbound and (matrix[new_x][new_y] > matrix[x][y]):\\n                max_value = max(max_value, self.longestIncreasingPathIndex(matrix, new_x, new_y, cache))\\n        \\n        cache[key]=max_value+1\\n        return cache[key]\\n\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n\\n        cache = {}\\n        max_value=0\\n        for i in range(0, len(matrix)):\\n            for j in range(0, len(matrix[i])):\\n                result = self.longestIncreasingPathIndex(matrix, i, j, cache)\\n                max_value = max(max_value, result)\\n        \\n        return max_value`"
                    },
                    {
                        "username": "neergoel",
                        "content": "My JAVA solution\\nhttps://github.com/neerajgoel/LeetCode-Java/blob/1d8606a6a1c171cfadc3f0c2604e9dfc72ea5f24/src/com/questions/_329_Longest_Increasing_Path_in_a_Matrix_01.java"
                    },
                    {
                        "username": "lokie838",
                        "content": "I haven\\'t understood the solution. can anyone give a video explanation for this problem."
                    },
                    {
                        "username": "DeltaLF",
                        "content": "329:https://www.youtube.com/watch?v=wCc_nd-GiEc If you are familiar with dynamic programming questions, this one is not too hard. I suggest that you can try some simpler dynamic programming questions first. It will help you understand complicated questions."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nGraph DFS traversal C++... Simple\\n\\n# Approach\\n\\n1. Define two arrays: `rN` and `cN`, representing the row and column neighbors. These arrays store the relative positions of the neighboring cells in the matrix.\\n2. Create a recursive function called `rec` that takes the following parameters:\\n   - `row` and `col`: The current row and column indices.\\n   - `m` and `n`: The total number of rows and columns in the matrix.\\n   - `matrix`: The matrix containing integer values.\\n   - `dp`: A 2D vector representing a dynamic programming array used for memoization.\\n3. Check if the value for the current position `(row, col)` in the `dp` array is already calculated. If it is, return the stored value.\\n4. Initialize a variable `sum` to 1, representing the length of the current path starting from `(row, col)`.\\n5. Iterate through the four possible neighboring cells using a `for` loop:\\n   - Calculate the indices of the neighboring cell (`rV` and `cV`) by adding the corresponding values from the `rN` and `cN` arrays to the current position.\\n   - Check if the neighboring cell is within the bounds of the matrix and if the value in the neighboring cell is greater than the value in the current cell.\\n   - If the conditions are met, calculate the length of the longest increasing path starting from the neighboring cell by recursively calling the `rec` function with the updated indices.\\n   - Update the `sum` variable to the maximum value between the current `sum` and the length of the path starting from the neighboring cell.\\n6. Store the calculated `sum` in the `dp` array for the current position `(row, col)`.\\n7. Return the `sum` as the result of the `rec` function.\\n8. Implement the `longestIncreasingPath` function that takes the `matrix` as input.\\n9. Initialize variables `m` and `n` to store the number of rows and columns in the matrix, respectively.\\n10. Create a 2D vector `dp` of size `(m+1) x (n+1)` and initialize all values to -1.\\n11. Initialize a variable `ans` to store the maximum length of the increasing path found so far.\\n12. Iterate through each cell in the matrix using nested `for` loops:\\n    - Update the `ans` variable to the maximum value between the current `ans` and the result of the `rec` function called for each cell.\\n13. Return the `ans` as the final result of the `longestIncreasingPath` function.\\n---------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(m*n*4)\\n\\n- Space complexity:\\nS.C=O(m*n) \\n\\n------------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/longest-increasing-path-in-a-matrix/solutions/3686121/graph-dfs-traversal-c-simple/"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "you have to provide tip not the solution in English "
                    }
                ]
            },
            {
                "id": 1954841,
                "content": [
                    {
                        "username": "kenzgf",
                        "content": "More like medium. Much easier than some medium DP problems..."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**This problem was asked in the Accenture Coding Assessment 2024. It involved a slight modification[Easy Version]: \nIncreasing the subsequence by only 1. \nAdditionally, the matrix in this assessment had equal numbers of rows and columns.**"
                    },
                    {
                        "username": "BigDaddyO",
                        "content": "Why is the iterative dp approach used in the question 01 Matrix not applicable in here ??"
                    },
                    {
                        "username": "robert2189",
                        "content": "I\\'m surprised this was considered hard. Seemed like a medium question. "
                    },
                    {
                        "username": "mihirg42",
                        "content": "\\nclass Solution {\\n  public:\\n  int dp(vector<vector<int>>& matrix, int n, int m, int i, int j, vector<vector<int>> &t)\\n    {\\n        if(j >= m || i >= n || i < 0 || j < 0)\\n            return 0;\\n        if(t[i][j] != -1)\\n            return t[i][j];\\n        if(i > 0 && matrix[i][j] < matrix[i - 1][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i - 1, j, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(j > 0 && matrix[i][j] < matrix[i][j - 1])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i, j - 1, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(i < n - 1 && matrix[i + 1][j] > matrix[i][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i + 1, j, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(j < m - 1 && matrix[i][j + 1] > matrix[i][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i, j + 1, t), dp(matrix, n, m, i, j, t));\\n        }\\n        return 0;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> t(n, vector<int>(m, -1));\\n        int mx = -1;\\n        dp(matrix, n, m, 0, 0, t);\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n                mx = max(t[i][j], mx);\\n        }\\n        return mx;\\n    }\\n};"
                    },
                    {
                        "username": "mihirg42",
                        "content": "can someone help me debug this code? the matrix t(used for memoization) is not updating.\\n\\n\\nclass Solution {\\n  public:\\n  int dp(vector<vector<int>>& matrix, int n, int m, int i, int j, vector<vector<int>> &t)\\n    {\\n        if(j >= m || i >= n || i < 0 || j < 0)\\n            return 0;\\n        if(t[i][j] != -1)\\n            return t[i][j];\\n        if(i > 0 && matrix[i][j] < matrix[i - 1][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i - 1, j, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(j > 0 && matrix[i][j] < matrix[i][j - 1])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i, j - 1, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(i < n - 1 && matrix[i + 1][j] > matrix[i][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i + 1, j, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(j < m - 1 && matrix[i][j + 1] > matrix[i][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i, j + 1, t), dp(matrix, n, m, i, j, t));\\n        }\\n        return 0;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> t(n, vector<int>(m, -1));\\n        int mx = -1;\\n        dp(matrix, n, m, 0, 0, t);\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n                mx = max(t[i][j], mx);\\n        }\\n        return mx;\\n    }\\n};"
                    },
                    {
                        "username": "lookforlohith",
                        "content": " `class Solution:\\n\\n    def inbounds(self, index, size):\\n        return index >=0 and index < size\\n\\n    def longestIncreasingPathIndex(self, matrix, x, y, cache) -> int:\\n\\n        key=\"x=\"+str(x)+\"y=\"+str(y)\\n        if key in cache:\\n            return cache[key]\\n\\n        paths = [(0, 1),(1, 0), (0, -1),(-1, 0)]\\n        max_value=0\\n        for path in paths:\\n            new_x =x+path[0]\\n            new_y= y+path[1]\\n            left_inbound = self.inbounds(new_x, len(matrix))\\n            right_inbound = self.inbounds(new_y, len(matrix[0]))\\n            if left_inbound and right_inbound and (matrix[new_x][new_y] > matrix[x][y]):\\n                max_value = max(max_value, self.longestIncreasingPathIndex(matrix, new_x, new_y, cache))\\n        \\n        cache[key]=max_value+1\\n        return cache[key]\\n\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n\\n        cache = {}\\n        max_value=0\\n        for i in range(0, len(matrix)):\\n            for j in range(0, len(matrix[i])):\\n                result = self.longestIncreasingPathIndex(matrix, i, j, cache)\\n                max_value = max(max_value, result)\\n        \\n        return max_value`"
                    },
                    {
                        "username": "neergoel",
                        "content": "My JAVA solution\\nhttps://github.com/neerajgoel/LeetCode-Java/blob/1d8606a6a1c171cfadc3f0c2604e9dfc72ea5f24/src/com/questions/_329_Longest_Increasing_Path_in_a_Matrix_01.java"
                    },
                    {
                        "username": "lokie838",
                        "content": "I haven\\'t understood the solution. can anyone give a video explanation for this problem."
                    },
                    {
                        "username": "DeltaLF",
                        "content": "329:https://www.youtube.com/watch?v=wCc_nd-GiEc If you are familiar with dynamic programming questions, this one is not too hard. I suggest that you can try some simpler dynamic programming questions first. It will help you understand complicated questions."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nGraph DFS traversal C++... Simple\\n\\n# Approach\\n\\n1. Define two arrays: `rN` and `cN`, representing the row and column neighbors. These arrays store the relative positions of the neighboring cells in the matrix.\\n2. Create a recursive function called `rec` that takes the following parameters:\\n   - `row` and `col`: The current row and column indices.\\n   - `m` and `n`: The total number of rows and columns in the matrix.\\n   - `matrix`: The matrix containing integer values.\\n   - `dp`: A 2D vector representing a dynamic programming array used for memoization.\\n3. Check if the value for the current position `(row, col)` in the `dp` array is already calculated. If it is, return the stored value.\\n4. Initialize a variable `sum` to 1, representing the length of the current path starting from `(row, col)`.\\n5. Iterate through the four possible neighboring cells using a `for` loop:\\n   - Calculate the indices of the neighboring cell (`rV` and `cV`) by adding the corresponding values from the `rN` and `cN` arrays to the current position.\\n   - Check if the neighboring cell is within the bounds of the matrix and if the value in the neighboring cell is greater than the value in the current cell.\\n   - If the conditions are met, calculate the length of the longest increasing path starting from the neighboring cell by recursively calling the `rec` function with the updated indices.\\n   - Update the `sum` variable to the maximum value between the current `sum` and the length of the path starting from the neighboring cell.\\n6. Store the calculated `sum` in the `dp` array for the current position `(row, col)`.\\n7. Return the `sum` as the result of the `rec` function.\\n8. Implement the `longestIncreasingPath` function that takes the `matrix` as input.\\n9. Initialize variables `m` and `n` to store the number of rows and columns in the matrix, respectively.\\n10. Create a 2D vector `dp` of size `(m+1) x (n+1)` and initialize all values to -1.\\n11. Initialize a variable `ans` to store the maximum length of the increasing path found so far.\\n12. Iterate through each cell in the matrix using nested `for` loops:\\n    - Update the `ans` variable to the maximum value between the current `ans` and the result of the `rec` function called for each cell.\\n13. Return the `ans` as the final result of the `longestIncreasingPath` function.\\n---------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(m*n*4)\\n\\n- Space complexity:\\nS.C=O(m*n) \\n\\n------------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/longest-increasing-path-in-a-matrix/solutions/3686121/graph-dfs-traversal-c-simple/"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "you have to provide tip not the solution in English "
                    }
                ]
            },
            {
                "id": 1954833,
                "content": [
                    {
                        "username": "kenzgf",
                        "content": "More like medium. Much easier than some medium DP problems..."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**This problem was asked in the Accenture Coding Assessment 2024. It involved a slight modification[Easy Version]: \nIncreasing the subsequence by only 1. \nAdditionally, the matrix in this assessment had equal numbers of rows and columns.**"
                    },
                    {
                        "username": "BigDaddyO",
                        "content": "Why is the iterative dp approach used in the question 01 Matrix not applicable in here ??"
                    },
                    {
                        "username": "robert2189",
                        "content": "I\\'m surprised this was considered hard. Seemed like a medium question. "
                    },
                    {
                        "username": "mihirg42",
                        "content": "\\nclass Solution {\\n  public:\\n  int dp(vector<vector<int>>& matrix, int n, int m, int i, int j, vector<vector<int>> &t)\\n    {\\n        if(j >= m || i >= n || i < 0 || j < 0)\\n            return 0;\\n        if(t[i][j] != -1)\\n            return t[i][j];\\n        if(i > 0 && matrix[i][j] < matrix[i - 1][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i - 1, j, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(j > 0 && matrix[i][j] < matrix[i][j - 1])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i, j - 1, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(i < n - 1 && matrix[i + 1][j] > matrix[i][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i + 1, j, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(j < m - 1 && matrix[i][j + 1] > matrix[i][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i, j + 1, t), dp(matrix, n, m, i, j, t));\\n        }\\n        return 0;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> t(n, vector<int>(m, -1));\\n        int mx = -1;\\n        dp(matrix, n, m, 0, 0, t);\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n                mx = max(t[i][j], mx);\\n        }\\n        return mx;\\n    }\\n};"
                    },
                    {
                        "username": "mihirg42",
                        "content": "can someone help me debug this code? the matrix t(used for memoization) is not updating.\\n\\n\\nclass Solution {\\n  public:\\n  int dp(vector<vector<int>>& matrix, int n, int m, int i, int j, vector<vector<int>> &t)\\n    {\\n        if(j >= m || i >= n || i < 0 || j < 0)\\n            return 0;\\n        if(t[i][j] != -1)\\n            return t[i][j];\\n        if(i > 0 && matrix[i][j] < matrix[i - 1][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i - 1, j, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(j > 0 && matrix[i][j] < matrix[i][j - 1])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i, j - 1, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(i < n - 1 && matrix[i + 1][j] > matrix[i][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i + 1, j, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(j < m - 1 && matrix[i][j + 1] > matrix[i][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i, j + 1, t), dp(matrix, n, m, i, j, t));\\n        }\\n        return 0;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> t(n, vector<int>(m, -1));\\n        int mx = -1;\\n        dp(matrix, n, m, 0, 0, t);\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n                mx = max(t[i][j], mx);\\n        }\\n        return mx;\\n    }\\n};"
                    },
                    {
                        "username": "lookforlohith",
                        "content": " `class Solution:\\n\\n    def inbounds(self, index, size):\\n        return index >=0 and index < size\\n\\n    def longestIncreasingPathIndex(self, matrix, x, y, cache) -> int:\\n\\n        key=\"x=\"+str(x)+\"y=\"+str(y)\\n        if key in cache:\\n            return cache[key]\\n\\n        paths = [(0, 1),(1, 0), (0, -1),(-1, 0)]\\n        max_value=0\\n        for path in paths:\\n            new_x =x+path[0]\\n            new_y= y+path[1]\\n            left_inbound = self.inbounds(new_x, len(matrix))\\n            right_inbound = self.inbounds(new_y, len(matrix[0]))\\n            if left_inbound and right_inbound and (matrix[new_x][new_y] > matrix[x][y]):\\n                max_value = max(max_value, self.longestIncreasingPathIndex(matrix, new_x, new_y, cache))\\n        \\n        cache[key]=max_value+1\\n        return cache[key]\\n\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n\\n        cache = {}\\n        max_value=0\\n        for i in range(0, len(matrix)):\\n            for j in range(0, len(matrix[i])):\\n                result = self.longestIncreasingPathIndex(matrix, i, j, cache)\\n                max_value = max(max_value, result)\\n        \\n        return max_value`"
                    },
                    {
                        "username": "neergoel",
                        "content": "My JAVA solution\\nhttps://github.com/neerajgoel/LeetCode-Java/blob/1d8606a6a1c171cfadc3f0c2604e9dfc72ea5f24/src/com/questions/_329_Longest_Increasing_Path_in_a_Matrix_01.java"
                    },
                    {
                        "username": "lokie838",
                        "content": "I haven\\'t understood the solution. can anyone give a video explanation for this problem."
                    },
                    {
                        "username": "DeltaLF",
                        "content": "329:https://www.youtube.com/watch?v=wCc_nd-GiEc If you are familiar with dynamic programming questions, this one is not too hard. I suggest that you can try some simpler dynamic programming questions first. It will help you understand complicated questions."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nGraph DFS traversal C++... Simple\\n\\n# Approach\\n\\n1. Define two arrays: `rN` and `cN`, representing the row and column neighbors. These arrays store the relative positions of the neighboring cells in the matrix.\\n2. Create a recursive function called `rec` that takes the following parameters:\\n   - `row` and `col`: The current row and column indices.\\n   - `m` and `n`: The total number of rows and columns in the matrix.\\n   - `matrix`: The matrix containing integer values.\\n   - `dp`: A 2D vector representing a dynamic programming array used for memoization.\\n3. Check if the value for the current position `(row, col)` in the `dp` array is already calculated. If it is, return the stored value.\\n4. Initialize a variable `sum` to 1, representing the length of the current path starting from `(row, col)`.\\n5. Iterate through the four possible neighboring cells using a `for` loop:\\n   - Calculate the indices of the neighboring cell (`rV` and `cV`) by adding the corresponding values from the `rN` and `cN` arrays to the current position.\\n   - Check if the neighboring cell is within the bounds of the matrix and if the value in the neighboring cell is greater than the value in the current cell.\\n   - If the conditions are met, calculate the length of the longest increasing path starting from the neighboring cell by recursively calling the `rec` function with the updated indices.\\n   - Update the `sum` variable to the maximum value between the current `sum` and the length of the path starting from the neighboring cell.\\n6. Store the calculated `sum` in the `dp` array for the current position `(row, col)`.\\n7. Return the `sum` as the result of the `rec` function.\\n8. Implement the `longestIncreasingPath` function that takes the `matrix` as input.\\n9. Initialize variables `m` and `n` to store the number of rows and columns in the matrix, respectively.\\n10. Create a 2D vector `dp` of size `(m+1) x (n+1)` and initialize all values to -1.\\n11. Initialize a variable `ans` to store the maximum length of the increasing path found so far.\\n12. Iterate through each cell in the matrix using nested `for` loops:\\n    - Update the `ans` variable to the maximum value between the current `ans` and the result of the `rec` function called for each cell.\\n13. Return the `ans` as the final result of the `longestIncreasingPath` function.\\n---------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(m*n*4)\\n\\n- Space complexity:\\nS.C=O(m*n) \\n\\n------------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/longest-increasing-path-in-a-matrix/solutions/3686121/graph-dfs-traversal-c-simple/"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "you have to provide tip not the solution in English "
                    }
                ]
            },
            {
                "id": 1790370,
                "content": [
                    {
                        "username": "kenzgf",
                        "content": "More like medium. Much easier than some medium DP problems..."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**This problem was asked in the Accenture Coding Assessment 2024. It involved a slight modification[Easy Version]: \nIncreasing the subsequence by only 1. \nAdditionally, the matrix in this assessment had equal numbers of rows and columns.**"
                    },
                    {
                        "username": "BigDaddyO",
                        "content": "Why is the iterative dp approach used in the question 01 Matrix not applicable in here ??"
                    },
                    {
                        "username": "robert2189",
                        "content": "I\\'m surprised this was considered hard. Seemed like a medium question. "
                    },
                    {
                        "username": "mihirg42",
                        "content": "\\nclass Solution {\\n  public:\\n  int dp(vector<vector<int>>& matrix, int n, int m, int i, int j, vector<vector<int>> &t)\\n    {\\n        if(j >= m || i >= n || i < 0 || j < 0)\\n            return 0;\\n        if(t[i][j] != -1)\\n            return t[i][j];\\n        if(i > 0 && matrix[i][j] < matrix[i - 1][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i - 1, j, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(j > 0 && matrix[i][j] < matrix[i][j - 1])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i, j - 1, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(i < n - 1 && matrix[i + 1][j] > matrix[i][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i + 1, j, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(j < m - 1 && matrix[i][j + 1] > matrix[i][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i, j + 1, t), dp(matrix, n, m, i, j, t));\\n        }\\n        return 0;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> t(n, vector<int>(m, -1));\\n        int mx = -1;\\n        dp(matrix, n, m, 0, 0, t);\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n                mx = max(t[i][j], mx);\\n        }\\n        return mx;\\n    }\\n};"
                    },
                    {
                        "username": "mihirg42",
                        "content": "can someone help me debug this code? the matrix t(used for memoization) is not updating.\\n\\n\\nclass Solution {\\n  public:\\n  int dp(vector<vector<int>>& matrix, int n, int m, int i, int j, vector<vector<int>> &t)\\n    {\\n        if(j >= m || i >= n || i < 0 || j < 0)\\n            return 0;\\n        if(t[i][j] != -1)\\n            return t[i][j];\\n        if(i > 0 && matrix[i][j] < matrix[i - 1][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i - 1, j, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(j > 0 && matrix[i][j] < matrix[i][j - 1])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i, j - 1, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(i < n - 1 && matrix[i + 1][j] > matrix[i][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i + 1, j, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(j < m - 1 && matrix[i][j + 1] > matrix[i][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i, j + 1, t), dp(matrix, n, m, i, j, t));\\n        }\\n        return 0;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> t(n, vector<int>(m, -1));\\n        int mx = -1;\\n        dp(matrix, n, m, 0, 0, t);\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n                mx = max(t[i][j], mx);\\n        }\\n        return mx;\\n    }\\n};"
                    },
                    {
                        "username": "lookforlohith",
                        "content": " `class Solution:\\n\\n    def inbounds(self, index, size):\\n        return index >=0 and index < size\\n\\n    def longestIncreasingPathIndex(self, matrix, x, y, cache) -> int:\\n\\n        key=\"x=\"+str(x)+\"y=\"+str(y)\\n        if key in cache:\\n            return cache[key]\\n\\n        paths = [(0, 1),(1, 0), (0, -1),(-1, 0)]\\n        max_value=0\\n        for path in paths:\\n            new_x =x+path[0]\\n            new_y= y+path[1]\\n            left_inbound = self.inbounds(new_x, len(matrix))\\n            right_inbound = self.inbounds(new_y, len(matrix[0]))\\n            if left_inbound and right_inbound and (matrix[new_x][new_y] > matrix[x][y]):\\n                max_value = max(max_value, self.longestIncreasingPathIndex(matrix, new_x, new_y, cache))\\n        \\n        cache[key]=max_value+1\\n        return cache[key]\\n\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n\\n        cache = {}\\n        max_value=0\\n        for i in range(0, len(matrix)):\\n            for j in range(0, len(matrix[i])):\\n                result = self.longestIncreasingPathIndex(matrix, i, j, cache)\\n                max_value = max(max_value, result)\\n        \\n        return max_value`"
                    },
                    {
                        "username": "neergoel",
                        "content": "My JAVA solution\\nhttps://github.com/neerajgoel/LeetCode-Java/blob/1d8606a6a1c171cfadc3f0c2604e9dfc72ea5f24/src/com/questions/_329_Longest_Increasing_Path_in_a_Matrix_01.java"
                    },
                    {
                        "username": "lokie838",
                        "content": "I haven\\'t understood the solution. can anyone give a video explanation for this problem."
                    },
                    {
                        "username": "DeltaLF",
                        "content": "329:https://www.youtube.com/watch?v=wCc_nd-GiEc If you are familiar with dynamic programming questions, this one is not too hard. I suggest that you can try some simpler dynamic programming questions first. It will help you understand complicated questions."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nGraph DFS traversal C++... Simple\\n\\n# Approach\\n\\n1. Define two arrays: `rN` and `cN`, representing the row and column neighbors. These arrays store the relative positions of the neighboring cells in the matrix.\\n2. Create a recursive function called `rec` that takes the following parameters:\\n   - `row` and `col`: The current row and column indices.\\n   - `m` and `n`: The total number of rows and columns in the matrix.\\n   - `matrix`: The matrix containing integer values.\\n   - `dp`: A 2D vector representing a dynamic programming array used for memoization.\\n3. Check if the value for the current position `(row, col)` in the `dp` array is already calculated. If it is, return the stored value.\\n4. Initialize a variable `sum` to 1, representing the length of the current path starting from `(row, col)`.\\n5. Iterate through the four possible neighboring cells using a `for` loop:\\n   - Calculate the indices of the neighboring cell (`rV` and `cV`) by adding the corresponding values from the `rN` and `cN` arrays to the current position.\\n   - Check if the neighboring cell is within the bounds of the matrix and if the value in the neighboring cell is greater than the value in the current cell.\\n   - If the conditions are met, calculate the length of the longest increasing path starting from the neighboring cell by recursively calling the `rec` function with the updated indices.\\n   - Update the `sum` variable to the maximum value between the current `sum` and the length of the path starting from the neighboring cell.\\n6. Store the calculated `sum` in the `dp` array for the current position `(row, col)`.\\n7. Return the `sum` as the result of the `rec` function.\\n8. Implement the `longestIncreasingPath` function that takes the `matrix` as input.\\n9. Initialize variables `m` and `n` to store the number of rows and columns in the matrix, respectively.\\n10. Create a 2D vector `dp` of size `(m+1) x (n+1)` and initialize all values to -1.\\n11. Initialize a variable `ans` to store the maximum length of the increasing path found so far.\\n12. Iterate through each cell in the matrix using nested `for` loops:\\n    - Update the `ans` variable to the maximum value between the current `ans` and the result of the `rec` function called for each cell.\\n13. Return the `ans` as the final result of the `longestIncreasingPath` function.\\n---------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(m*n*4)\\n\\n- Space complexity:\\nS.C=O(m*n) \\n\\n------------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/longest-increasing-path-in-a-matrix/solutions/3686121/graph-dfs-traversal-c-simple/"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "you have to provide tip not the solution in English "
                    }
                ]
            },
            {
                "id": 1777039,
                "content": [
                    {
                        "username": "kenzgf",
                        "content": "More like medium. Much easier than some medium DP problems..."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**This problem was asked in the Accenture Coding Assessment 2024. It involved a slight modification[Easy Version]: \nIncreasing the subsequence by only 1. \nAdditionally, the matrix in this assessment had equal numbers of rows and columns.**"
                    },
                    {
                        "username": "BigDaddyO",
                        "content": "Why is the iterative dp approach used in the question 01 Matrix not applicable in here ??"
                    },
                    {
                        "username": "robert2189",
                        "content": "I\\'m surprised this was considered hard. Seemed like a medium question. "
                    },
                    {
                        "username": "mihirg42",
                        "content": "\\nclass Solution {\\n  public:\\n  int dp(vector<vector<int>>& matrix, int n, int m, int i, int j, vector<vector<int>> &t)\\n    {\\n        if(j >= m || i >= n || i < 0 || j < 0)\\n            return 0;\\n        if(t[i][j] != -1)\\n            return t[i][j];\\n        if(i > 0 && matrix[i][j] < matrix[i - 1][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i - 1, j, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(j > 0 && matrix[i][j] < matrix[i][j - 1])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i, j - 1, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(i < n - 1 && matrix[i + 1][j] > matrix[i][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i + 1, j, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(j < m - 1 && matrix[i][j + 1] > matrix[i][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i, j + 1, t), dp(matrix, n, m, i, j, t));\\n        }\\n        return 0;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> t(n, vector<int>(m, -1));\\n        int mx = -1;\\n        dp(matrix, n, m, 0, 0, t);\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n                mx = max(t[i][j], mx);\\n        }\\n        return mx;\\n    }\\n};"
                    },
                    {
                        "username": "mihirg42",
                        "content": "can someone help me debug this code? the matrix t(used for memoization) is not updating.\\n\\n\\nclass Solution {\\n  public:\\n  int dp(vector<vector<int>>& matrix, int n, int m, int i, int j, vector<vector<int>> &t)\\n    {\\n        if(j >= m || i >= n || i < 0 || j < 0)\\n            return 0;\\n        if(t[i][j] != -1)\\n            return t[i][j];\\n        if(i > 0 && matrix[i][j] < matrix[i - 1][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i - 1, j, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(j > 0 && matrix[i][j] < matrix[i][j - 1])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i, j - 1, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(i < n - 1 && matrix[i + 1][j] > matrix[i][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i + 1, j, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(j < m - 1 && matrix[i][j + 1] > matrix[i][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i, j + 1, t), dp(matrix, n, m, i, j, t));\\n        }\\n        return 0;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> t(n, vector<int>(m, -1));\\n        int mx = -1;\\n        dp(matrix, n, m, 0, 0, t);\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n                mx = max(t[i][j], mx);\\n        }\\n        return mx;\\n    }\\n};"
                    },
                    {
                        "username": "lookforlohith",
                        "content": " `class Solution:\\n\\n    def inbounds(self, index, size):\\n        return index >=0 and index < size\\n\\n    def longestIncreasingPathIndex(self, matrix, x, y, cache) -> int:\\n\\n        key=\"x=\"+str(x)+\"y=\"+str(y)\\n        if key in cache:\\n            return cache[key]\\n\\n        paths = [(0, 1),(1, 0), (0, -1),(-1, 0)]\\n        max_value=0\\n        for path in paths:\\n            new_x =x+path[0]\\n            new_y= y+path[1]\\n            left_inbound = self.inbounds(new_x, len(matrix))\\n            right_inbound = self.inbounds(new_y, len(matrix[0]))\\n            if left_inbound and right_inbound and (matrix[new_x][new_y] > matrix[x][y]):\\n                max_value = max(max_value, self.longestIncreasingPathIndex(matrix, new_x, new_y, cache))\\n        \\n        cache[key]=max_value+1\\n        return cache[key]\\n\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n\\n        cache = {}\\n        max_value=0\\n        for i in range(0, len(matrix)):\\n            for j in range(0, len(matrix[i])):\\n                result = self.longestIncreasingPathIndex(matrix, i, j, cache)\\n                max_value = max(max_value, result)\\n        \\n        return max_value`"
                    },
                    {
                        "username": "neergoel",
                        "content": "My JAVA solution\\nhttps://github.com/neerajgoel/LeetCode-Java/blob/1d8606a6a1c171cfadc3f0c2604e9dfc72ea5f24/src/com/questions/_329_Longest_Increasing_Path_in_a_Matrix_01.java"
                    },
                    {
                        "username": "lokie838",
                        "content": "I haven\\'t understood the solution. can anyone give a video explanation for this problem."
                    },
                    {
                        "username": "DeltaLF",
                        "content": "329:https://www.youtube.com/watch?v=wCc_nd-GiEc If you are familiar with dynamic programming questions, this one is not too hard. I suggest that you can try some simpler dynamic programming questions first. It will help you understand complicated questions."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nGraph DFS traversal C++... Simple\\n\\n# Approach\\n\\n1. Define two arrays: `rN` and `cN`, representing the row and column neighbors. These arrays store the relative positions of the neighboring cells in the matrix.\\n2. Create a recursive function called `rec` that takes the following parameters:\\n   - `row` and `col`: The current row and column indices.\\n   - `m` and `n`: The total number of rows and columns in the matrix.\\n   - `matrix`: The matrix containing integer values.\\n   - `dp`: A 2D vector representing a dynamic programming array used for memoization.\\n3. Check if the value for the current position `(row, col)` in the `dp` array is already calculated. If it is, return the stored value.\\n4. Initialize a variable `sum` to 1, representing the length of the current path starting from `(row, col)`.\\n5. Iterate through the four possible neighboring cells using a `for` loop:\\n   - Calculate the indices of the neighboring cell (`rV` and `cV`) by adding the corresponding values from the `rN` and `cN` arrays to the current position.\\n   - Check if the neighboring cell is within the bounds of the matrix and if the value in the neighboring cell is greater than the value in the current cell.\\n   - If the conditions are met, calculate the length of the longest increasing path starting from the neighboring cell by recursively calling the `rec` function with the updated indices.\\n   - Update the `sum` variable to the maximum value between the current `sum` and the length of the path starting from the neighboring cell.\\n6. Store the calculated `sum` in the `dp` array for the current position `(row, col)`.\\n7. Return the `sum` as the result of the `rec` function.\\n8. Implement the `longestIncreasingPath` function that takes the `matrix` as input.\\n9. Initialize variables `m` and `n` to store the number of rows and columns in the matrix, respectively.\\n10. Create a 2D vector `dp` of size `(m+1) x (n+1)` and initialize all values to -1.\\n11. Initialize a variable `ans` to store the maximum length of the increasing path found so far.\\n12. Iterate through each cell in the matrix using nested `for` loops:\\n    - Update the `ans` variable to the maximum value between the current `ans` and the result of the `rec` function called for each cell.\\n13. Return the `ans` as the final result of the `longestIncreasingPath` function.\\n---------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(m*n*4)\\n\\n- Space complexity:\\nS.C=O(m*n) \\n\\n------------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/longest-increasing-path-in-a-matrix/solutions/3686121/graph-dfs-traversal-c-simple/"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "you have to provide tip not the solution in English "
                    }
                ]
            },
            {
                "id": 1707707,
                "content": [
                    {
                        "username": "kenzgf",
                        "content": "More like medium. Much easier than some medium DP problems..."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**This problem was asked in the Accenture Coding Assessment 2024. It involved a slight modification[Easy Version]: \nIncreasing the subsequence by only 1. \nAdditionally, the matrix in this assessment had equal numbers of rows and columns.**"
                    },
                    {
                        "username": "BigDaddyO",
                        "content": "Why is the iterative dp approach used in the question 01 Matrix not applicable in here ??"
                    },
                    {
                        "username": "robert2189",
                        "content": "I\\'m surprised this was considered hard. Seemed like a medium question. "
                    },
                    {
                        "username": "mihirg42",
                        "content": "\\nclass Solution {\\n  public:\\n  int dp(vector<vector<int>>& matrix, int n, int m, int i, int j, vector<vector<int>> &t)\\n    {\\n        if(j >= m || i >= n || i < 0 || j < 0)\\n            return 0;\\n        if(t[i][j] != -1)\\n            return t[i][j];\\n        if(i > 0 && matrix[i][j] < matrix[i - 1][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i - 1, j, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(j > 0 && matrix[i][j] < matrix[i][j - 1])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i, j - 1, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(i < n - 1 && matrix[i + 1][j] > matrix[i][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i + 1, j, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(j < m - 1 && matrix[i][j + 1] > matrix[i][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i, j + 1, t), dp(matrix, n, m, i, j, t));\\n        }\\n        return 0;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> t(n, vector<int>(m, -1));\\n        int mx = -1;\\n        dp(matrix, n, m, 0, 0, t);\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n                mx = max(t[i][j], mx);\\n        }\\n        return mx;\\n    }\\n};"
                    },
                    {
                        "username": "mihirg42",
                        "content": "can someone help me debug this code? the matrix t(used for memoization) is not updating.\\n\\n\\nclass Solution {\\n  public:\\n  int dp(vector<vector<int>>& matrix, int n, int m, int i, int j, vector<vector<int>> &t)\\n    {\\n        if(j >= m || i >= n || i < 0 || j < 0)\\n            return 0;\\n        if(t[i][j] != -1)\\n            return t[i][j];\\n        if(i > 0 && matrix[i][j] < matrix[i - 1][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i - 1, j, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(j > 0 && matrix[i][j] < matrix[i][j - 1])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i, j - 1, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(i < n - 1 && matrix[i + 1][j] > matrix[i][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i + 1, j, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(j < m - 1 && matrix[i][j + 1] > matrix[i][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i, j + 1, t), dp(matrix, n, m, i, j, t));\\n        }\\n        return 0;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> t(n, vector<int>(m, -1));\\n        int mx = -1;\\n        dp(matrix, n, m, 0, 0, t);\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n                mx = max(t[i][j], mx);\\n        }\\n        return mx;\\n    }\\n};"
                    },
                    {
                        "username": "lookforlohith",
                        "content": " `class Solution:\\n\\n    def inbounds(self, index, size):\\n        return index >=0 and index < size\\n\\n    def longestIncreasingPathIndex(self, matrix, x, y, cache) -> int:\\n\\n        key=\"x=\"+str(x)+\"y=\"+str(y)\\n        if key in cache:\\n            return cache[key]\\n\\n        paths = [(0, 1),(1, 0), (0, -1),(-1, 0)]\\n        max_value=0\\n        for path in paths:\\n            new_x =x+path[0]\\n            new_y= y+path[1]\\n            left_inbound = self.inbounds(new_x, len(matrix))\\n            right_inbound = self.inbounds(new_y, len(matrix[0]))\\n            if left_inbound and right_inbound and (matrix[new_x][new_y] > matrix[x][y]):\\n                max_value = max(max_value, self.longestIncreasingPathIndex(matrix, new_x, new_y, cache))\\n        \\n        cache[key]=max_value+1\\n        return cache[key]\\n\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n\\n        cache = {}\\n        max_value=0\\n        for i in range(0, len(matrix)):\\n            for j in range(0, len(matrix[i])):\\n                result = self.longestIncreasingPathIndex(matrix, i, j, cache)\\n                max_value = max(max_value, result)\\n        \\n        return max_value`"
                    },
                    {
                        "username": "neergoel",
                        "content": "My JAVA solution\\nhttps://github.com/neerajgoel/LeetCode-Java/blob/1d8606a6a1c171cfadc3f0c2604e9dfc72ea5f24/src/com/questions/_329_Longest_Increasing_Path_in_a_Matrix_01.java"
                    },
                    {
                        "username": "lokie838",
                        "content": "I haven\\'t understood the solution. can anyone give a video explanation for this problem."
                    },
                    {
                        "username": "DeltaLF",
                        "content": "329:https://www.youtube.com/watch?v=wCc_nd-GiEc If you are familiar with dynamic programming questions, this one is not too hard. I suggest that you can try some simpler dynamic programming questions first. It will help you understand complicated questions."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nGraph DFS traversal C++... Simple\\n\\n# Approach\\n\\n1. Define two arrays: `rN` and `cN`, representing the row and column neighbors. These arrays store the relative positions of the neighboring cells in the matrix.\\n2. Create a recursive function called `rec` that takes the following parameters:\\n   - `row` and `col`: The current row and column indices.\\n   - `m` and `n`: The total number of rows and columns in the matrix.\\n   - `matrix`: The matrix containing integer values.\\n   - `dp`: A 2D vector representing a dynamic programming array used for memoization.\\n3. Check if the value for the current position `(row, col)` in the `dp` array is already calculated. If it is, return the stored value.\\n4. Initialize a variable `sum` to 1, representing the length of the current path starting from `(row, col)`.\\n5. Iterate through the four possible neighboring cells using a `for` loop:\\n   - Calculate the indices of the neighboring cell (`rV` and `cV`) by adding the corresponding values from the `rN` and `cN` arrays to the current position.\\n   - Check if the neighboring cell is within the bounds of the matrix and if the value in the neighboring cell is greater than the value in the current cell.\\n   - If the conditions are met, calculate the length of the longest increasing path starting from the neighboring cell by recursively calling the `rec` function with the updated indices.\\n   - Update the `sum` variable to the maximum value between the current `sum` and the length of the path starting from the neighboring cell.\\n6. Store the calculated `sum` in the `dp` array for the current position `(row, col)`.\\n7. Return the `sum` as the result of the `rec` function.\\n8. Implement the `longestIncreasingPath` function that takes the `matrix` as input.\\n9. Initialize variables `m` and `n` to store the number of rows and columns in the matrix, respectively.\\n10. Create a 2D vector `dp` of size `(m+1) x (n+1)` and initialize all values to -1.\\n11. Initialize a variable `ans` to store the maximum length of the increasing path found so far.\\n12. Iterate through each cell in the matrix using nested `for` loops:\\n    - Update the `ans` variable to the maximum value between the current `ans` and the result of the `rec` function called for each cell.\\n13. Return the `ans` as the final result of the `longestIncreasingPath` function.\\n---------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(m*n*4)\\n\\n- Space complexity:\\nS.C=O(m*n) \\n\\n------------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/longest-increasing-path-in-a-matrix/solutions/3686121/graph-dfs-traversal-c-simple/"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "you have to provide tip not the solution in English "
                    }
                ]
            },
            {
                "id": 1945737,
                "content": [
                    {
                        "username": "kenzgf",
                        "content": "More like medium. Much easier than some medium DP problems..."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**This problem was asked in the Accenture Coding Assessment 2024. It involved a slight modification[Easy Version]: \nIncreasing the subsequence by only 1. \nAdditionally, the matrix in this assessment had equal numbers of rows and columns.**"
                    },
                    {
                        "username": "BigDaddyO",
                        "content": "Why is the iterative dp approach used in the question 01 Matrix not applicable in here ??"
                    },
                    {
                        "username": "robert2189",
                        "content": "I\\'m surprised this was considered hard. Seemed like a medium question. "
                    },
                    {
                        "username": "mihirg42",
                        "content": "\\nclass Solution {\\n  public:\\n  int dp(vector<vector<int>>& matrix, int n, int m, int i, int j, vector<vector<int>> &t)\\n    {\\n        if(j >= m || i >= n || i < 0 || j < 0)\\n            return 0;\\n        if(t[i][j] != -1)\\n            return t[i][j];\\n        if(i > 0 && matrix[i][j] < matrix[i - 1][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i - 1, j, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(j > 0 && matrix[i][j] < matrix[i][j - 1])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i, j - 1, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(i < n - 1 && matrix[i + 1][j] > matrix[i][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i + 1, j, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(j < m - 1 && matrix[i][j + 1] > matrix[i][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i, j + 1, t), dp(matrix, n, m, i, j, t));\\n        }\\n        return 0;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> t(n, vector<int>(m, -1));\\n        int mx = -1;\\n        dp(matrix, n, m, 0, 0, t);\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n                mx = max(t[i][j], mx);\\n        }\\n        return mx;\\n    }\\n};"
                    },
                    {
                        "username": "mihirg42",
                        "content": "can someone help me debug this code? the matrix t(used for memoization) is not updating.\\n\\n\\nclass Solution {\\n  public:\\n  int dp(vector<vector<int>>& matrix, int n, int m, int i, int j, vector<vector<int>> &t)\\n    {\\n        if(j >= m || i >= n || i < 0 || j < 0)\\n            return 0;\\n        if(t[i][j] != -1)\\n            return t[i][j];\\n        if(i > 0 && matrix[i][j] < matrix[i - 1][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i - 1, j, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(j > 0 && matrix[i][j] < matrix[i][j - 1])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i, j - 1, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(i < n - 1 && matrix[i + 1][j] > matrix[i][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i + 1, j, t), dp(matrix, n, m, i, j, t));\\n        }\\n        if(j < m - 1 && matrix[i][j + 1] > matrix[i][j])\\n        {\\n            // sum+=matrix[i][j];\\n            return t[i][j] = max(1 + dp(matrix, n, m, i, j + 1, t), dp(matrix, n, m, i, j, t));\\n        }\\n        return 0;\\n    }\\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> t(n, vector<int>(m, -1));\\n        int mx = -1;\\n        dp(matrix, n, m, 0, 0, t);\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n                mx = max(t[i][j], mx);\\n        }\\n        return mx;\\n    }\\n};"
                    },
                    {
                        "username": "lookforlohith",
                        "content": " `class Solution:\\n\\n    def inbounds(self, index, size):\\n        return index >=0 and index < size\\n\\n    def longestIncreasingPathIndex(self, matrix, x, y, cache) -> int:\\n\\n        key=\"x=\"+str(x)+\"y=\"+str(y)\\n        if key in cache:\\n            return cache[key]\\n\\n        paths = [(0, 1),(1, 0), (0, -1),(-1, 0)]\\n        max_value=0\\n        for path in paths:\\n            new_x =x+path[0]\\n            new_y= y+path[1]\\n            left_inbound = self.inbounds(new_x, len(matrix))\\n            right_inbound = self.inbounds(new_y, len(matrix[0]))\\n            if left_inbound and right_inbound and (matrix[new_x][new_y] > matrix[x][y]):\\n                max_value = max(max_value, self.longestIncreasingPathIndex(matrix, new_x, new_y, cache))\\n        \\n        cache[key]=max_value+1\\n        return cache[key]\\n\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n\\n        cache = {}\\n        max_value=0\\n        for i in range(0, len(matrix)):\\n            for j in range(0, len(matrix[i])):\\n                result = self.longestIncreasingPathIndex(matrix, i, j, cache)\\n                max_value = max(max_value, result)\\n        \\n        return max_value`"
                    },
                    {
                        "username": "neergoel",
                        "content": "My JAVA solution\\nhttps://github.com/neerajgoel/LeetCode-Java/blob/1d8606a6a1c171cfadc3f0c2604e9dfc72ea5f24/src/com/questions/_329_Longest_Increasing_Path_in_a_Matrix_01.java"
                    },
                    {
                        "username": "lokie838",
                        "content": "I haven\\'t understood the solution. can anyone give a video explanation for this problem."
                    },
                    {
                        "username": "DeltaLF",
                        "content": "329:https://www.youtube.com/watch?v=wCc_nd-GiEc If you are familiar with dynamic programming questions, this one is not too hard. I suggest that you can try some simpler dynamic programming questions first. It will help you understand complicated questions."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nGraph DFS traversal C++... Simple\\n\\n# Approach\\n\\n1. Define two arrays: `rN` and `cN`, representing the row and column neighbors. These arrays store the relative positions of the neighboring cells in the matrix.\\n2. Create a recursive function called `rec` that takes the following parameters:\\n   - `row` and `col`: The current row and column indices.\\n   - `m` and `n`: The total number of rows and columns in the matrix.\\n   - `matrix`: The matrix containing integer values.\\n   - `dp`: A 2D vector representing a dynamic programming array used for memoization.\\n3. Check if the value for the current position `(row, col)` in the `dp` array is already calculated. If it is, return the stored value.\\n4. Initialize a variable `sum` to 1, representing the length of the current path starting from `(row, col)`.\\n5. Iterate through the four possible neighboring cells using a `for` loop:\\n   - Calculate the indices of the neighboring cell (`rV` and `cV`) by adding the corresponding values from the `rN` and `cN` arrays to the current position.\\n   - Check if the neighboring cell is within the bounds of the matrix and if the value in the neighboring cell is greater than the value in the current cell.\\n   - If the conditions are met, calculate the length of the longest increasing path starting from the neighboring cell by recursively calling the `rec` function with the updated indices.\\n   - Update the `sum` variable to the maximum value between the current `sum` and the length of the path starting from the neighboring cell.\\n6. Store the calculated `sum` in the `dp` array for the current position `(row, col)`.\\n7. Return the `sum` as the result of the `rec` function.\\n8. Implement the `longestIncreasingPath` function that takes the `matrix` as input.\\n9. Initialize variables `m` and `n` to store the number of rows and columns in the matrix, respectively.\\n10. Create a 2D vector `dp` of size `(m+1) x (n+1)` and initialize all values to -1.\\n11. Initialize a variable `ans` to store the maximum length of the increasing path found so far.\\n12. Iterate through each cell in the matrix using nested `for` loops:\\n    - Update the `ans` variable to the maximum value between the current `ans` and the result of the `rec` function called for each cell.\\n13. Return the `ans` as the final result of the `longestIncreasingPath` function.\\n---------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(m*n*4)\\n\\n- Space complexity:\\nS.C=O(m*n) \\n\\n------------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/longest-increasing-path-in-a-matrix/solutions/3686121/graph-dfs-traversal-c-simple/"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "you have to provide tip not the solution in English "
                    }
                ]
            }
        ]
    },
    {
        "title": "N-ary Tree Level Order Traversal",
        "question_content": "<p>Given an n-ary tree, return the <em>level order</em> traversal of its nodes&#39; values.</p>\n\n<p><em>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png\" style=\"width: 100%; max-width: 300px;\" /></p>\n\n<pre>\n<strong>Input:</strong> root = [1,null,3,2,4,null,5,6]\n<strong>Output:</strong> [[1],[3,2,4],[5,6]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png\" style=\"width: 296px; height: 241px;\" /></p>\n\n<pre>\n<strong>Input:</strong> root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n<strong>Output:</strong> [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The height of the n-ary tree is less than or equal to <code>1000</code></li>\n\t<li>The total number of nodes is between <code>[0, 10<sup>4</sup>]</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1386593,
                "title": "c-python-bfs-dfs-solutions-clean-concise",
                "content": "**\\u2714\\uFE0F  Solution 1: BFS Traverse Level by Level**\\n- This is the most intuitive solution, we just bfs level by level, we add all elements in the current level to the list, let say `level`.\\n- Then add push_back `level` to `ans`. \\n\\n<iframe src=\"https://leetcode.com/playground/8humNBUs/shared\" frameBorder=\"0\" width=\"100%\" height=\"400\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N)`, where `N <= 10^4` is number of nodes in the tree.\\n- Extra Space (without counting output as space): `O(N)`, this is the memory to store elements in the queue. At most, the queue will have 2 layers of the tree on it at any given time. \\n\\t- In the best case, each level has only 1 node.\\n\\t- In the worst case, for example in balanced tree, there is about N/2 nodes in the lowest level.\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: DFS & Add level on the road**\\n- Just simple `dfs` to traverse all the nodes in the Tree, when traverse we need to keep `level` of the current node.\\n- Instead of creating the HashMap (which is a pair of `[level, list of elements]`), we create a list, let say `ans` where `ans[i]` is the list of elements in the level `i`.\\n- The keypoint here is that we need to append new level when the current `level` reach to length of current `ans`, in other words when `level` is out of index from `ans`.\\n\\n<iframe src=\"https://leetcode.com/playground/SJBrfyRJ/shared\" frameBorder=\"0\" width=\"100%\" height=\"330\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N)`, where `N <= 10^4` is number of nodes in the tree.\\n- Extra Space (without counting output as space): `O(H)`, where `H <= 1000` is height of the tree. This is the memory for recursion stack.\\n\\t- In the best case, it\\'s a balanced tree, the height is `logN`.\\n\\t- In the worst case, each level has only 1 node, the height is `H`.\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "**\\u2714\\uFE0F  Solution 1: BFS Traverse Level by Level**\\n- This is the most intuitive solution, we just bfs level by level, we add all elements in the current level to the list, let say `level`.\\n- Then add push_back `level` to `ans`. \\n\\n<iframe src=\"https://leetcode.com/playground/8humNBUs/shared\" frameBorder=\"0\" width=\"100%\" height=\"400\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N)`, where `N <= 10^4` is number of nodes in the tree.\\n- Extra Space (without counting output as space): `O(N)`, this is the memory to store elements in the queue. At most, the queue will have 2 layers of the tree on it at any given time. \\n\\t- In the best case, each level has only 1 node.\\n\\t- In the worst case, for example in balanced tree, there is about N/2 nodes in the lowest level.\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: DFS & Add level on the road**\\n- Just simple `dfs` to traverse all the nodes in the Tree, when traverse we need to keep `level` of the current node.\\n- Instead of creating the HashMap (which is a pair of `[level, list of elements]`), we create a list, let say `ans` where `ans[i]` is the list of elements in the level `i`.\\n- The keypoint here is that we need to append new level when the current `level` reach to length of current `ans`, in other words when `level` is out of index from `ans`.\\n\\n<iframe src=\"https://leetcode.com/playground/SJBrfyRJ/shared\" frameBorder=\"0\" width=\"100%\" height=\"330\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N)`, where `N <= 10^4` is number of nodes in the tree.\\n- Extra Space (without counting output as space): `O(H)`, where `H <= 1000` is height of the tree. This is the memory for recursion stack.\\n\\t- In the best case, it\\'s a balanced tree, the height is `logN`.\\n\\t- In the worst case, each level has only 1 node, the height is `H`.\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "codeTag": "Unknown"
            },
            {
                "id": 148877,
                "title": "python-5-lines-bfs-solution",
                "content": "```\\nclass Solution(object):\\n    def levelOrder(self, root):\\n        q, ret = [root], []\\n        while any(q):\\n            ret.append([node.val for node in q])\\n            q = [child for node in q for child in node.children if child]\\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def levelOrder(self, root):\\n        q, ret = [root], []\\n        while any(q):\\n            ret.append([node.val for node in q])\\n            q = [child for node in q for child in node.children if child]\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 134911,
                "title": "java-solution",
                "content": "```\\npublic List<List<Integer>> levelOrder(Node root) {\\n        List<List<Integer>> ret = new LinkedList<>();\\n        \\n        if (root == null) return ret;\\n        \\n        Queue<Node> queue = new LinkedList<>();\\n        \\n        queue.offer(root);\\n        \\n        while (!queue.isEmpty()) {\\n            List<Integer> curLevel = new LinkedList<>();\\n            int len = queue.size();\\n            for (int i = 0; i < len; i++) {\\n                Node curr = queue.poll();\\n                curLevel.add(curr.val);\\n                for (Node c : curr.children)\\n                    queue.offer(c);\\n            }\\n            ret.add(curLevel);\\n        }\\n        \\n        return ret;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<List<Integer>> levelOrder(Node root) {\\n        List<List<Integer>> ret = new LinkedList<>();\\n        \\n        if (root == null) return ret;\\n        \\n        Queue<Node> queue = new LinkedList<>();\\n        \\n        queue.offer(root);\\n        \\n        while (!queue.isEmpty()) {\\n            List<Integer> curLevel = new LinkedList<>();\\n            int len = queue.size();\\n            for (int i = 0; i < len; i++) {\\n                Node curr = queue.poll();\\n                curLevel.add(curr.val);\\n                for (Node c : curr.children)\\n                    queue.offer(c);\\n            }\\n            ret.add(curLevel);\\n        }\\n        \\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 957281,
                "title": "easy-understanding-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        if (root == NULL) \\n\\t\\t\\treturn {};\\n        vector<vector<int>> res;\\n        queue<Node*> q;\\n        q.push(root); \\n        while (!q.empty())\\n        {\\n            int size = q.size(); \\n            vector<int> currlevel;\\n            for(int i=0;i<size;i++){\\n                Node* tmp=q.front();\\n                q.pop();\\n                currlevel.push_back(tmp->val);\\n                for (auto n : tmp -> children)\\n                     q.push(n); \\n            }\\n            res.push_back(currlevel);\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        if (root == NULL) \\n\\t\\t\\treturn {};\\n        vector<vector<int>> res;\\n        queue<Node*> q;\\n        q.push(root); \\n        while (!q.empty())\\n        {\\n            int size = q.size(); \\n            vector<int> currlevel;\\n            for(int i=0;i<size;i++){\\n                Node* tmp=q.front();\\n                q.pop();\\n                currlevel.push_back(tmp->val);\\n                for (auto n : tmp -> children)\\n                     q.push(n); \\n            }\\n            res.push_back(currlevel);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2532297,
                "title": "leetcode-the-hard-way-easy-bfs-explained-line-by-line",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. I\\'ll explain my solution line by line daily. \\nIf you like it, please give a star, watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post.\\n\\nYou may check out my recent BFS solutions on other problems.\\n\\nhttps://leetcode.com/problems/average-of-levels-in-binary-tree/discuss/2516577/leetcode-the-hard-way-bfs-explained-line-by-line\\nhttps://leetcode.com/problems/numbers-with-same-consecutive-differences/discuss/2521519/leetcode-the-hard-way-easy-bfs-100-explained-line-by-line\\n\\n**Someone keeps downvoting my posts recently for no reason. Instead of just downvoting, please leave a useful comment to let me know what I could make better. Thanks.**\\n\\n**C++**\\n\\n```cpp\\n// Time Complexity: O(N) where N is the number of nodes in the tree\\n// Space Complexity: O(M): where M is the maximum number in the tree at any level\\nclass Solution {\\npublic:\\n    // The idea is to use BFS, which is a common way to traverse the tree level by level\\n    // For a standard BFS, we can use queue to push the first root node into a queue\\n    // Then remove the front of the queue, add its children to back of the queue\\n    // Do the above steps until the queue is empty\\n    // In this question, we need to extra thing which is to push the each value of the nodes level by level\\n    // We can simply use `level` to store the values of the nodes at current level, \\n    // and add it back to `ans` once we\\'ve processed all nodes at that level\\n    vector<vector<int>> levelOrder(Node* root) {\\n        // the total number of nodes is between [0, 10 ^ 4]\\n        // check if root is nullptr to cover 0 node case\\n        if(!root)  return {};\\n        // init ans\\n        vector<vector<int>> ans;\\n        // standard bfs approach\\n        queue<Node*> q;\\n        // start with the root node\\n        q.push(root); \\n        // do the following logic when the queue is not empty\\n        while(!q.empty()) {\\n            // get the queue size\\n            int n = q.size(); \\n            // level is used to store all the node values at the current level\\n            vector<int> level;\\n            // for each element in the current queue\\n            for(int i = 0; i < n; i++){\\n                //get the first node from the queue\\n                Node* node = q.front();\\n                // pop it\\n                q.pop();\\n                // add it to level\\n                level.push_back(node->val);\\n                // this node may include other nodes, we add them all to the queue\\n                for(auto n : node->children) q.push(n); \\n            }\\n            // we\\'ve processed this level, add it to ans\\n            ans.push_back(level);\\n        }\\n        // return final ans\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n\\n```py\\n# Time Complexity: O(N) where N is the number of nodes in the tree\\n# Space Complexity: O(M): where M is the maximum number in the tree at any level\\nclass Solution:\\n    # The idea is to use BFS, which is a common way to traverse the tree level by level\\n    # For a standard BFS, we can use queue to push the first root node into a queue\\n    # Then remove the front of the queue, add its children to back of the queue\\n    # Do the above steps until the queue is empty\\n    # In this question, we need to extra thing which is to push the each value of the nodes level by level\\n    # We can simply use `level` to store the values of the nodes at current level, \\n    # and add it back to `ans` once we\\'ve processed all nodes at that level\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        # the total number of nodes is between [0, 10 ^ 4]\\n        # check if root is None to cover 0 node case\\n        if not root: return []\\n        # init ans\\n        ans = []\\n        # standard bfs approach\\n        # start with the root node\\n        q = deque([root])\\n        # do the following logic when the queue is not empty\\n        while q:\\n            # level is used to store all the node values at the current level\\n            level = []\\n            # for each element in the current queue\\n            for _ in range(len(q)):\\n                # get the first node from the queue and pop it\\n                node = q.popleft()\\n                # add it to level\\n                level += [node.val]\\n                # this node may include other nodes, we add them all to the queue\\n                for n in node.children: q.append(n)\\n            # we\\'ve processed this level, add it to ans\\n            ans += [level]\\n        # return final ans\\n        return ans\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```cpp\\n// Time Complexity: O(N) where N is the number of nodes in the tree\\n// Space Complexity: O(M): where M is the maximum number in the tree at any level\\nclass Solution {\\npublic:\\n    // The idea is to use BFS, which is a common way to traverse the tree level by level\\n    // For a standard BFS, we can use queue to push the first root node into a queue\\n    // Then remove the front of the queue, add its children to back of the queue\\n    // Do the above steps until the queue is empty\\n    // In this question, we need to extra thing which is to push the each value of the nodes level by level\\n    // We can simply use `level` to store the values of the nodes at current level, \\n    // and add it back to `ans` once we\\'ve processed all nodes at that level\\n    vector<vector<int>> levelOrder(Node* root) {\\n        // the total number of nodes is between [0, 10 ^ 4]\\n        // check if root is nullptr to cover 0 node case\\n        if(!root)  return {};\\n        // init ans\\n        vector<vector<int>> ans;\\n        // standard bfs approach\\n        queue<Node*> q;\\n        // start with the root node\\n        q.push(root); \\n        // do the following logic when the queue is not empty\\n        while(!q.empty()) {\\n            // get the queue size\\n            int n = q.size(); \\n            // level is used to store all the node values at the current level\\n            vector<int> level;\\n            // for each element in the current queue\\n            for(int i = 0; i < n; i++){\\n                //get the first node from the queue\\n                Node* node = q.front();\\n                // pop it\\n                q.pop();\\n                // add it to level\\n                level.push_back(node->val);\\n                // this node may include other nodes, we add them all to the queue\\n                for(auto n : node->children) q.push(n); \\n            }\\n            // we\\'ve processed this level, add it to ans\\n            ans.push_back(level);\\n        }\\n        // return final ans\\n        return ans;\\n    }\\n};\\n```\n```py\\n# Time Complexity: O(N) where N is the number of nodes in the tree\\n# Space Complexity: O(M): where M is the maximum number in the tree at any level\\nclass Solution:\\n    # The idea is to use BFS, which is a common way to traverse the tree level by level\\n    # For a standard BFS, we can use queue to push the first root node into a queue\\n    # Then remove the front of the queue, add its children to back of the queue\\n    # Do the above steps until the queue is empty\\n    # In this question, we need to extra thing which is to push the each value of the nodes level by level\\n    # We can simply use `level` to store the values of the nodes at current level, \\n    # and add it back to `ans` once we\\'ve processed all nodes at that level\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        # the total number of nodes is between [0, 10 ^ 4]\\n        # check if root is None to cover 0 node case\\n        if not root: return []\\n        # init ans\\n        ans = []\\n        # standard bfs approach\\n        # start with the root node\\n        q = deque([root])\\n        # do the following logic when the queue is not empty\\n        while q:\\n            # level is used to store all the node values at the current level\\n            level = []\\n            # for each element in the current queue\\n            for _ in range(len(q)):\\n                # get the first node from the queue and pop it\\n                node = q.popleft()\\n                # add it to level\\n                level += [node.val]\\n                # this node may include other nodes, we add them all to the queue\\n                for n in node.children: q.append(n)\\n            # we\\'ve processed this level, add it to ans\\n            ans += [level]\\n        # return final ans\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1386686,
                "title": "python-simple-bfs-solution-explained",
                "content": "Nothing very special about this problem, in fact it is very similar to problem **0102**. Binary Tree Level Order Traversal. The idea is to use any graph traversal, here I use bfs. We keep queue `Q` with value in current level. Then we do `len(Q)` extractions from the left and add all children to the right. Also we add all values fro this level to `ans`. Note that we always keep invariant: first we traverse full first layer, then it is fully removed and second layer added and so on.\\n\\n#### Complexity\\nTime complexity is `O(n)` to traverse our tree, space complexity is `O(n)` as well to return answer.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def levelOrder(self, root):\\n        if not root: return []\\n        Q, ans = deque([root]), []\\n        \\n        while Q:\\n            level = []\\n            for i in range(len(Q)):\\n                node = Q.popleft()\\n                for child in node.children:\\n                    Q.append(child)\\n                level += [node.val] \\n            ans += [level]\\n\\n        return ans\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def levelOrder(self, root):\\n        if not root: return []\\n        Q, ans = deque([root]), []\\n        \\n        while Q:\\n            level = []\\n            for i in range(len(Q)):\\n                node = Q.popleft()\\n                for child in node.children:\\n                    Q.append(child)\\n                level += [node.val] \\n            ans += [level]\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1387067,
                "title": "c-clean-and-short-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void rec(Node* root, int level) {\\n        if (!root) return;\\n        if (level == res.size()) res.push_back({});\\n        res[level].push_back(root->val);\\n        for (auto child : root->children)\\n            rec(child, level+1);\\n    }\\n    \\n    vector<vector<int>> levelOrder(Node* root) {\\n        rec(root, 0);\\n        return res;\\n    }\\n    \\nprivate:\\n    vector<vector<int>> res;\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rec(Node* root, int level) {\\n        if (!root) return;\\n        if (level == res.size()) res.push_back({});\\n        res[level].push_back(root->val);\\n        for (auto child : root->children)\\n            rec(child, level+1);\\n    }\\n    \\n    vector<vector<int>> levelOrder(Node* root) {\\n        rec(root, 0);\\n        return res;\\n    }\\n    \\nprivate:\\n    vector<vector<int>> res;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 162439,
                "title": "python-iterative-solution-beat-96",
                "content": "```\\nclass Solution(object):\\n    def levelOrder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not root:return []\\n        res = []\\n        stack = [root]\\n        while stack:\\n            temp = []\\n            next_stack = []\\n            for node in stack:\\n                temp.append(node.val)\\n                for child in node.children:\\n                    next_stack.append(child)\\n            stack = next_stack\\n            res.append(temp)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def levelOrder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not root:return []\\n        res = []\\n        stack = [root]\\n        while stack:\\n            temp = []\\n            next_stack = []\\n            for node in stack:\\n                temp.append(node.val)\\n                for child in node.children:\\n                    next_stack.append(child)\\n            stack = next_stack\\n            res.append(temp)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 155927,
                "title": "beat-100-of-java-dfs-recursive",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n        return levelOrder(root, 0, new ArrayList<>());\\n    }\\n    \\n    private List<List<Integer>> levelOrder(Node node, int level, List<List<Integer>> order){\\n        if (node == null){\\n            return order;\\n        }\\n        List<Integer> list = order.size() > level ?  order.get(level) : new ArrayList<>();\\n        list.add(node.val);\\n        if (order.size() <= level){\\n            order.add(list);\\n        }\\n        for (Node n : node.children){\\n            levelOrder(n, level + 1, order);\\n        }\\n        return order;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n        return levelOrder(root, 0, new ArrayList<>());\\n    }\\n    \\n    private List<List<Integer>> levelOrder(Node node, int level, List<List<Integer>> order){\\n        if (node == null){\\n            return order;\\n        }\\n        List<Integer> list = order.size() > level ?  order.get(level) : new ArrayList<>();\\n        list.add(node.val);\\n        if (order.size() <= level){\\n            order.add(list);\\n        }\\n        for (Node n : node.children){\\n            levelOrder(n, level + 1, order);\\n        }\\n        return order;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2533615,
                "title": "c-3-different-solutions-bfs-iterative-recursive-dfs-clean-code",
                "content": "I came up with 3 different ways to solve this problem, please let me know if you have other suggestions.\\n\\n### Solution 1: recursive DFS\\n\\nThis is straighforward.\\n\\n```\\n    vector<vector<int>> levelOrder(Node* root) {\\n        if (!root) return {};\\n\\n        vector<vector<int>> ans;\\n        levelOrder(root, 0, ans);\\n        return ans;\\n    }\\n    \\n    void levelOrder(Node* node, int level, vector<vector<int>>& ans) {\\n        if (level == size(ans)) {\\n            ans.push_back({node->val});\\n        } else {\\n            ans[level].push_back(node->val);\\n        }\\n        for (Node* child : node->children) {\\n            levelOrder(child, level + 1, ans);\\n        }\\n    }\\n```\\n\\nIt\\'s maybe a bit of question of taste, but we could also use the following code the add nodes (values) to ```ans```. It would be a bit shorter, performance wise does it likley not really make a difference:\\n\\n```\\n        if (level == size(ans)) ans.push_back({});\\n        ans[level].push_back(node->val);\\n```\\n\\n### Solution 2: iterative DFS\\n\\nPlease note that we need to push the children nodes in reverse order, because we are using a stack and if we would push the left most child first it would be the last one to pop off the stack again.\\n\\n```\\n    vector<vector<int>> levelOrder(Node* root) {\\n        if (!root) return {};\\n\\n        vector<vector<int>> ans;\\n        stack<pair<Node*, int>> st;\\n        st.push({root, 0});\\n        while (!empty(st)) {\\n            const auto [node, level] = st.top(); st.pop();\\n\\n            if (level == size(ans)) {\\n                ans.push_back({node->val});\\n            } else {\\n                ans[level].push_back(node->val);\\n            }\\n            // NB: We need to push them in reverse order.\\n            for (auto it = crbegin(node->children); it != crend(node->children); ++it) {\\n                st.push({*it, level + 1});\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\n### Solution 3: BFS\\n\\n```\\n    vector<vector<int>> levelOrder(Node* root) {\\n        if (!root) return {};\\n\\n        vector<vector<int>> ans;\\n        queue<Node*> q;\\n        q.push(root);\\n        while (!empty(q)) {\\n            int q_size = size(q);\\n            ans.push_back({});\\n            while (q_size--) {\\n                const Node* node = q.front(); q.pop();\\n                ans.back().push_back(node->val);\\n                for (Node* child : node->children) {\\n                    q.push(child);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\nWe could use ```std::for_each``` to add the children to the queue, but that doesn\\'t really look much better to me. Wdyt?\\n\\n```\\n                for_each(begin(node->children), end(node->children), [&](Node* node) {\\n                    q.push(node);\\n                });\\n```\\n\\nWe could sprinkle a few ```const``` into the code to make our intent clear that we are only reading the information:\\n\\n```\\n    static vector<vector<int>> levelOrder(const Node* root) {\\n        if (!root) return {};\\n\\n        vector<vector<int>> ans;\\n        queue<const Node*> q;\\n        q.push(root);\\n        while (!empty(q)) {\\n            int q_size = size(q);\\n            ans.push_back({});\\n            while (q_size--) {\\n                const Node* node = q.front(); q.pop();\\n                ans.back().push_back(node->val);\\n                for (const Node* child : node->children) {\\n                    q.push(child);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\n\\n**Complexity Analysis**\\n  * Time Complexity: O(n), where n is the number of nodes in the tree. We need to visit each node exactly once.\\n  * Space Complexity: O(n), with the same argument as for time complexity.\\n\\n</br>\\n\\n**Proceed at your own risk. The following approach is not recommended and is just a PoC. I hope this doesn\\'t violate any leetcode ToS. :)**\\n\\n### Bonus Solution: transform the input serialization directly to the output serialization format (3ms)\\n\\nThis approach was inspired by @rultimatrix, who pointed out that the input serialization format of N-ary trees is already in level order. We could more directly translate the input to the output format. Inorder to make this work we need to move the ```main()``` function provided by leetcode out of the way, a ```#define main old_main``` at the end does the trick. We also need to keep a stub implementation of the ```class Solution``` around to make this code compile with the rest. In our own ```main()``` we are just reading from STDIN and write the results to the file \"user.out\", which is where the leetcode framework expects the results. The ```transform``` function is just hacked together, and I am not sure I understand the specs for this format correctly. Had to hack around a bit to make this work.\\n\\nAny how, for your entertainment:\\n\\n```\\n// USE AT YOUR OWN RISK.\\n//\\n// We need this stub so the code compiles.\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        return {};\\n    }\\n};\\n\\nnamespace {\\n// Directly transform the input serialization format into the ouput serialization format.\\n// NB. This has no error checking what so ever and will crash and burn.\\nstring transform(const string& line) {\\n    string_view sv(line);\\n    sv = sv.substr(1, size(sv) - 2);\\n    if (empty(sv)) return \"[]\";\\n    \\n    string ans;\\n    ans.reserve(size(sv));\\n    ans += \"[[\";\\n\\n    size_t start = 0;\\n    size_t end = 0;\\n    int target = 1;\\n    int nulls = 0;\\n    int nodes = 0;\\n    int elems = 0;\\n    while ((start = sv.find_first_not_of(\\',\\', end)) != string_view::npos) {\\n        ++elems;\\n\\n        end = sv.find_first_of(\\',\\', start);\\n        const string_view node = sv.substr(start, end - start);\\n        \\n        // HACK: Not sure if I understand the seralization format correctly.\\n        if (elems == 2 && node != \"null\") {\\n            ans += \"],[\";\\n            ans += node;\\n            continue;\\n        }\\n        \\n        if (node == \"null\") {\\n            ++nulls;\\n            if (nulls == target) {\\n                ans += \"]\";\\n                target = nodes;\\n                nodes = 0;\\n                nulls = 0;\\n            }\\n        } else {\\n            if (ans.back() == \\']\\') {\\n                ans += \",[\";\\n            } else if (ans.back() != \\'[\\') {\\n                ans.push_back(\\',\\');\\n            }\\n            ans += node;\\n            ++nodes;\\n        }\\n    }\\n    \\n    ans += \"]]\";\\n    return ans;\\n}\\n}  // namespace\\n\\n// Our own main() replacing the one provided by leetcode.\\nint main(int argc, char* argv[]) {\\n    // For faster IO.\\n    std::ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n\\n    // TODO(heder): If we really care about performance, we should likely\\n    // not use iostreams.\\n    \\n    // \"user.out\" is where the leetcode framework expects the result.\\n    ofstream fuserout(\"user.out\");\\n    \\n    // Reading all the input from STDIN and transform them directly.\\n    string line;\\n    while (getline(cin, line)) {\\n        fuserout << transform(line) << \"\\\\n\";\\n    }\\n    \\n    return 0;\\n}\\n\\n// Move the leetcode standard main() out of the way.\\n#define main old_main\\n```\\n\\n_As always: Feedback is welcome and upvote if you like the post._\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\n    vector<vector<int>> levelOrder(Node* root) {\\n        if (!root) return {};\\n\\n        vector<vector<int>> ans;\\n        levelOrder(root, 0, ans);\\n        return ans;\\n    }\\n    \\n    void levelOrder(Node* node, int level, vector<vector<int>>& ans) {\\n        if (level == size(ans)) {\\n            ans.push_back({node->val});\\n        } else {\\n            ans[level].push_back(node->val);\\n        }\\n        for (Node* child : node->children) {\\n            levelOrder(child, level + 1, ans);\\n        }\\n    }\\n```\n```ans```\n```\\n        if (level == size(ans)) ans.push_back({});\\n        ans[level].push_back(node->val);\\n```\n```\\n    vector<vector<int>> levelOrder(Node* root) {\\n        if (!root) return {};\\n\\n        vector<vector<int>> ans;\\n        stack<pair<Node*, int>> st;\\n        st.push({root, 0});\\n        while (!empty(st)) {\\n            const auto [node, level] = st.top(); st.pop();\\n\\n            if (level == size(ans)) {\\n                ans.push_back({node->val});\\n            } else {\\n                ans[level].push_back(node->val);\\n            }\\n            // NB: We need to push them in reverse order.\\n            for (auto it = crbegin(node->children); it != crend(node->children); ++it) {\\n                st.push({*it, level + 1});\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```\\n    vector<vector<int>> levelOrder(Node* root) {\\n        if (!root) return {};\\n\\n        vector<vector<int>> ans;\\n        queue<Node*> q;\\n        q.push(root);\\n        while (!empty(q)) {\\n            int q_size = size(q);\\n            ans.push_back({});\\n            while (q_size--) {\\n                const Node* node = q.front(); q.pop();\\n                ans.back().push_back(node->val);\\n                for (Node* child : node->children) {\\n                    q.push(child);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```std::for_each```\n```\\n                for_each(begin(node->children), end(node->children), [&](Node* node) {\\n                    q.push(node);\\n                });\\n```\n```const```\n```\\n    static vector<vector<int>> levelOrder(const Node* root) {\\n        if (!root) return {};\\n\\n        vector<vector<int>> ans;\\n        queue<const Node*> q;\\n        q.push(root);\\n        while (!empty(q)) {\\n            int q_size = size(q);\\n            ans.push_back({});\\n            while (q_size--) {\\n                const Node* node = q.front(); q.pop();\\n                ans.back().push_back(node->val);\\n                for (const Node* child : node->children) {\\n                    q.push(child);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```main()```\n```#define main old_main```\n```class Solution```\n```main()```\n```transform```\n```\\n// USE AT YOUR OWN RISK.\\n//\\n// We need this stub so the code compiles.\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        return {};\\n    }\\n};\\n\\nnamespace {\\n// Directly transform the input serialization format into the ouput serialization format.\\n// NB. This has no error checking what so ever and will crash and burn.\\nstring transform(const string& line) {\\n    string_view sv(line);\\n    sv = sv.substr(1, size(sv) - 2);\\n    if (empty(sv)) return \"[]\";\\n    \\n    string ans;\\n    ans.reserve(size(sv));\\n    ans += \"[[\";\\n\\n    size_t start = 0;\\n    size_t end = 0;\\n    int target = 1;\\n    int nulls = 0;\\n    int nodes = 0;\\n    int elems = 0;\\n    while ((start = sv.find_first_not_of(\\',\\', end)) != string_view::npos) {\\n        ++elems;\\n\\n        end = sv.find_first_of(\\',\\', start);\\n        const string_view node = sv.substr(start, end - start);\\n        \\n        // HACK: Not sure if I understand the seralization format correctly.\\n        if (elems == 2 && node != \"null\") {\\n            ans += \"],[\";\\n            ans += node;\\n            continue;\\n        }\\n        \\n        if (node == \"null\") {\\n            ++nulls;\\n            if (nulls == target) {\\n                ans += \"]\";\\n                target = nodes;\\n                nodes = 0;\\n                nulls = 0;\\n            }\\n        } else {\\n            if (ans.back() == \\']\\') {\\n                ans += \",[\";\\n            } else if (ans.back() != \\'[\\') {\\n                ans.push_back(\\',\\');\\n            }\\n            ans += node;\\n            ++nodes;\\n        }\\n    }\\n    \\n    ans += \"]]\";\\n    return ans;\\n}\\n}  // namespace\\n\\n// Our own main() replacing the one provided by leetcode.\\nint main(int argc, char* argv[]) {\\n    // For faster IO.\\n    std::ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n\\n    // TODO(heder): If we really care about performance, we should likely\\n    // not use iostreams.\\n    \\n    // \"user.out\" is where the leetcode framework expects the result.\\n    ofstream fuserout(\"user.out\");\\n    \\n    // Reading all the input from STDIN and transform them directly.\\n    string line;\\n    while (getline(cin, line)) {\\n        fuserout << transform(line) << \"\\\\n\";\\n    }\\n    \\n    return 0;\\n}\\n\\n// Move the leetcode standard main() out of the way.\\n#define main old_main\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2532005,
                "title": "python-bfs",
                "content": "```\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        result = []        \\n        q = deque([root] if root else [])\\n        while q:\\n            result.append([])\\n            for _ in range(len(q)):\\n                node = q.popleft()\\n                result[-1].append(node.val)\\n                q.extend(node.children)\\n            \\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        result = []        \\n        q = deque([root] if root else [])\\n        while q:\\n            result.append([])\\n            for _ in range(len(q)):\\n                node = q.popleft()\\n                result[-1].append(node.val)\\n                q.extend(node.children)\\n            \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2532193,
                "title": "java-easy-solution-using-arraylist-90-faster-code",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n\\npublic List<List<Integer>> levelOrder(Node root) {\\n    List<List<Integer>> nm=new ArrayList<List<Integer>>();\\n    if(root==null)\\n        return nm;\\n    Queue<Node> kk=new LinkedList<>();\\n    kk.offer(root);\\n    while(!kk.isEmpty())\\n    {\\n        int p=kk.size();\\n        ArrayList<Integer> k=new ArrayList<>();\\n        for(int i=0;i<p;i++)\\n        {\\n            k.add(kk.peek().val);\\n            for(Node f:kk.peek().children)\\n            {\\n                kk.offer(f);\\n            }\\n            kk.poll();\\n        }\\n        nm.add(new ArrayList<>(k));\\n    }\\n    return nm;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n\\npublic List<List<Integer>> levelOrder(Node root) {\\n    List<List<Integer>> nm=new ArrayList<List<Integer>>();\\n    if(root==null)\\n        return nm;\\n    Queue<Node> kk=new LinkedList<>();\\n    kk.offer(root);\\n    while(!kk.isEmpty())\\n    {\\n        int p=kk.size();\\n        ArrayList<Integer> k=new ArrayList<>();\\n        for(int i=0;i<p;i++)\\n        {\\n            k.add(kk.peek().val);\\n            for(Node f:kk.peek().children)\\n            {\\n                kk.offer(f);\\n            }\\n            kk.poll();\\n        }\\n        nm.add(new ArrayList<>(k));\\n    }\\n    return nm;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2532685,
                "title": "c-bfs-short-simple-code",
                "content": "***DO UPVOTE IF IT HELPS !!!!!!***\\n\\nIdea is to perfrom BFS on the given n-ary tree.\\n**TC** = O(N), **SC** = O(N)\\n\\n\\t\\n\\tvector<vector<int>> levelOrder(Node* root) {\\n        \\n        vector<vector<int>> ans;\\n        if(!root) return ans;\\n        \\n        queue<Node*>q;\\n        q.push(root);\\n        \\n        while(!q.empty()){\\n            \\n            int sz=q.size();\\n            vector<int> v;\\n            \\n            while(sz--){\\n                auto curr=q.front();\\n                q.pop();       \\n                v.push_back(curr->val);\\n      \\n                for(auto it:curr->children){    //pushing curr node\\'s children in queue\\n                    q.push(it);\\n                }\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!!!!!***\\n\\nIdea is to perfrom BFS on the given n-ary tree.\\n**TC** = O(N), **SC** = O(N)\\n\\n\\t\\n\\tvector<vector<int>> levelOrder(Node* root) {\\n        \\n        vector<vector<int>> ans;\\n        if(!root) return ans;\\n        \\n        queue<Node*>q;\\n        q.push(root);\\n        \\n        while(!q.empty()){\\n            \\n            int sz=q.size();\\n            vector<int> v;\\n            \\n            while(sz--){\\n                auto curr=q.front();\\n                q.pop();       \\n                v.push_back(curr->val);\\n      \\n                for(auto it:curr->children){    //pushing curr node\\'s children in queue\\n                    q.push(it);\\n                }\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2532004,
                "title": "python-bfs-approach-beats-88-61-in-time-and-94-17-in-space-easy-solution",
                "content": "![image](https://assets.leetcode.com/users/images/e7625f10-45b3-4133-9820-fdd052a0d595_1662336738.3437436.png)\\n```\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n      if(root == None):\\n        return []\\n      \\n      op =[]\\n      nodeToTraverse= [root]\\n      \\n      while(len(nodeToTraverse)>0):\\n        n = len(nodeToTraverse)\\n        op.append([])\\n        \\n        for i in range(n):\\n          node = nodeToTraverse.pop(0)\\n          if(node != None):\\n            op[-1].append(node.val)\\n            \\n            for child in node.children:\\n              nodeToTraverse.append(child)\\n      return op\\n        # Please upvote if you like\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n      if(root == None):\\n        return []\\n      \\n      op =[]\\n      nodeToTraverse= [root]\\n      \\n      while(len(nodeToTraverse)>0):\\n        n = len(nodeToTraverse)\\n        op.append([])\\n        \\n        for i in range(n):\\n          node = nodeToTraverse.pop(0)\\n          if(node != None):\\n            op[-1].append(node.val)\\n            \\n            for child in node.children:\\n              nodeToTraverse.append(child)\\n      return op\\n        # Please upvote if you like\\n```",
                "codeTag": "Java"
            },
            {
                "id": 191189,
                "title": "java-classic-bfs-solution",
                "content": "Not too much to explain, seems everyone has the same idea since it's a really trival and classic problem.\n```\nclass Solution {\n    public List<List<Integer>> levelOrder(Node root) {\n        List<List<Integer>> res = new ArrayList<>();\n        if (root == null) return res;\n\t\tQueue<Node> queue = new LinkedList<>();\n\t\tqueue.add(root);\n\t\twhile (!queue.isEmpty()){\n\t\t\tint size = queue.size();\n\t\t\tList<Integer> temp = new ArrayList<>();\n\t\t\tfor (int i = 0; i < size; i++){\n\t\t\t\ttemp.add(queue.peek().val);\n\t\t\t\tqueue.addAll(queue.poll().children);\n\t\t\t}\n\t\t\tres.add(temp);\n\t\t}\n\t\treturn res;\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    public List<List<Integer>> levelOrder(Node root) {\n        List<List<Integer>> res = new ArrayList<>();\n        if (root == null) return res;\n\t\tQueue<Node> queue = new LinkedList<>();\n\t\tqueue.add(root);\n\t\twhile (!queue.isEmpty()){\n\t\t\tint size = queue.size();\n\t\t\tList<Integer> temp = new ArrayList<>();\n\t\t\tfor (int i = 0; i < size; i++){\n\t\t\t\ttemp.add(queue.peek().val);\n\t\t\t\tqueue.addAll(queue.poll().children);\n\t\t\t}\n\t\t\tres.add(temp);\n\t\t}\n\t\treturn res;\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 159133,
                "title": "easy-java-with-queue",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n        List<List<Integer>> res = new LinkedList();\\n        if (root == null) return res;\\n        Queue<Node> queue = new LinkedList();\\n        queue.add(root);\\n        while (!queue.isEmpty()) {\\n            List<Integer> li = new LinkedList();\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                Node node = queue.poll();\\n                li.add(node.val);\\n                queue.addAll(node.children);\\n            }\\n            res.add(li);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n        List<List<Integer>> res = new LinkedList();\\n        if (root == null) return res;\\n        Queue<Node> queue = new LinkedList();\\n        queue.add(root);\\n        while (!queue.isEmpty()) {\\n            List<Integer> li = new LinkedList();\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                Node node = queue.poll();\\n                li.add(node.val);\\n                queue.addAll(node.children);\\n            }\\n            res.add(li);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 364775,
                "title": "python3-level-order-traversal",
                "content": "* Version 1:\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val, children):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\nfrom collections import deque\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        if root == None:\\n            return []\\n        res = []\\n        mapping = {}\\n        q = deque([(root,0)])\\n        while q:\\n            n,l = q.popleft()\\n            if l not in mapping:\\n                mapping[l] = [n.val]\\n            else:\\n                mapping[l].append(n.val)\\n            if n.children:\\n                for i in n.children:\\n                    q.append((i,l+1))\\n        for i in sorted(mapping.keys()):\\n            res.append(mapping[i])\\n        return res\\n```\\n* Version 2:\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val, children):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\nfrom collections import deque\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        if root is None: return []\\n        res = []\\n        q = deque([(root,0)])\\n        while q:\\n            n,l = q.popleft()\\n            if len(res) < l +1:\\n                res.append([])\\n            for i in n.children:\\n                q.append((i,l+1))\\n            res[l].append(n.val)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val, children):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\nfrom collections import deque\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        if root == None:\\n            return []\\n        res = []\\n        mapping = {}\\n        q = deque([(root,0)])\\n        while q:\\n            n,l = q.popleft()\\n            if l not in mapping:\\n                mapping[l] = [n.val]\\n            else:\\n                mapping[l].append(n.val)\\n            if n.children:\\n                for i in n.children:\\n                    q.append((i,l+1))\\n        for i in sorted(mapping.keys()):\\n            res.append(mapping[i])\\n        return res\\n```\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val, children):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\nfrom collections import deque\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        if root is None: return []\\n        res = []\\n        q = deque([(root,0)])\\n        while q:\\n            n,l = q.popleft()\\n            if len(res) < l +1:\\n                res.append([])\\n            for i in n.children:\\n                q.append((i,l+1))\\n            res[l].append(n.val)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2532330,
                "title": "c-bfs-clean-concise-approach",
                "content": "**Intuition:** What is actually an **N-ary Tree**?\\n\\n**N-ary trees** are tree data structures that allow us to have up to **n** children nodes for each of the nodes, differing from the standard **binary** trees which allow only up to **2** children nodes for each node.\\n\\n**Approach:** BFS Traverse Level by Level - \\n* Just move level by level using **BFS** and then just add all elements in the **current** level to list **currlevel**, and at then end add all the **curlevel** in **res**.\\n\\n**Images:**\\n![image](https://i.stack.imgur.com/hlGN6.png)\\n**C++ Code:**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        if (root == NULL) \\n\\t\\t\\treturn {}; // Handle Corner Case\\n        vector<vector<int>> res;\\n        queue<Node*> q;\\n        q.push(root); \\n        while (!q.empty())\\n        {\\n            int size = q.size(); \\n            vector<int> currlevel;\\n            for(int i = 0 ; i < size ; i++)\\n            {\\n                Node* tmp=q.front() ;\\n                q.pop() ;\\n                currlevel.push_back(tmp->val) ;\\n                for (auto n : tmp -> children)\\n                     q.push(n); \\n            }\\n            res.push_back(currlevel) ;\\n        }\\n        return res ;\\n    }\\n};\\n```\\n****\\n**Time Complexity:** O(N)\\n**Space Complexity:** O(N) \\n****",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        if (root == NULL) \\n\\t\\t\\treturn {}; // Handle Corner Case\\n        vector<vector<int>> res;\\n        queue<Node*> q;\\n        q.push(root); \\n        while (!q.empty())\\n        {\\n            int size = q.size(); \\n            vector<int> currlevel;\\n            for(int i = 0 ; i < size ; i++)\\n            {\\n                Node* tmp=q.front() ;\\n                q.pop() ;\\n                currlevel.push_back(tmp->val) ;\\n                for (auto n : tmp -> children)\\n                     q.push(n); \\n            }\\n            res.push_back(currlevel) ;\\n        }\\n        return res ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2532277,
                "title": "beat-100-easy-understandable-explained",
                "content": "**Java**\\n```\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        solve(root, 0, res);\\n        return res;\\n    }\\n    \\n    private void solve(Node root, int level, List<List<Integer>> res){\\n        if(root == null) return;\\n        \\n        // When found a new level, add a new list\\n        if(level >= res.size())\\n            res.add(new ArrayList<>());\\n        \\n        // Add node in the list at the related level\\n        res.get(level).add(root.val);\\n        \\n        // Traverse all the children\\n        for(Node n : root.children)\\n            solve(n, level+1, res);\\n    }\\n}\\n```\\n\\n**Kotlin**\\n```\\nclass Solution {\\n    fun levelOrder(root: Node?): List<List<Int>> {\\n        val res : MutableList<MutableList<Int>> = mutableListOf()\\n        solve(root,0,res)\\n        return res\\n    }\\n    \\n    private fun solve(root:Node?, level:Int, res:MutableList<MutableList<Int>>){\\n        root?.let{\\n            \\n            // When found a new level, add a new list\\n            if(level>=res.size)\\n                res.add(mutableListOf<Int>())\\n            \\n            // Add node in the list at the related level\\n            res[level].add(it.`val`)\\n            \\n            // Traverse all the children\\n            it.children.forEach{ n ->\\n                solve(n,level+1,res)\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        solve(root, 0, res);\\n        return res;\\n    }\\n    \\n    private void solve(Node root, int level, List<List<Integer>> res){\\n        if(root == null) return;\\n        \\n        // When found a new level, add a new list\\n        if(level >= res.size())\\n            res.add(new ArrayList<>());\\n        \\n        // Add node in the list at the related level\\n        res.get(level).add(root.val);\\n        \\n        // Traverse all the children\\n        for(Node n : root.children)\\n            solve(n, level+1, res);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun levelOrder(root: Node?): List<List<Int>> {\\n        val res : MutableList<MutableList<Int>> = mutableListOf()\\n        solve(root,0,res)\\n        return res\\n    }\\n    \\n    private fun solve(root:Node?, level:Int, res:MutableList<MutableList<Int>>){\\n        root?.let{\\n            \\n            // When found a new level, add a new list\\n            if(level>=res.size)\\n                res.add(mutableListOf<Int>())\\n            \\n            // Add node in the list at the related level\\n            res[level].add(it.`val`)\\n            \\n            // Traverse all the children\\n            it.children.forEach{ n ->\\n                solve(n,level+1,res)\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1386597,
                "title": "n-ary-tree-level-order-traversal-basic-c-easy-to-understand",
                "content": "**Algorithm:**\\n* If root is null, return ans\\n* Else make one matrix ans\\n* Make one queue q and insert root\\n* While q is not empty\\n\\t* size := size of the queue\\n\\t* Make one array temp\\n\\t* while size is not 0\\n\\t\\t* curr := first element of q\\n\\t\\t* Insert value of curr into temp\\n\\t\\t* Delete element from queue\\n\\t\\t* For i in range 0 to size of the children of curr\\n\\t\\t\\t* insert ith children of curr\\n\\t\\t* Decrease size by 1\\n\\t* Insert temp into ans\\n* return ans\\n\\n**Solution:**\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        if (root == NULL) \\n\\t\\t\\treturn {}; // Handle Corner Case\\n        vector<vector<int>> res;\\n        queue<Node*> q;\\n        q.push(root); \\n        while (!q.empty())\\n        {\\n            int size = q.size(); \\n            vector<int> currlevel;\\n            for(int i = 0 ; i < size ; i++)\\n            {\\n                Node* tmp=q.front() ;\\n                q.pop() ;\\n                currlevel.push_back(tmp->val) ;\\n                for (auto n : tmp -> children)\\n                     q.push(n); \\n            }\\n            res.push_back(currlevel) ;\\n        }\\n        return res ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        if (root == NULL) \\n\\t\\t\\treturn {}; // Handle Corner Case\\n        vector<vector<int>> res;\\n        queue<Node*> q;\\n        q.push(root); \\n        while (!q.empty())\\n        {\\n            int size = q.size(); \\n            vector<int> currlevel;\\n            for(int i = 0 ; i < size ; i++)\\n            {\\n                Node* tmp=q.front() ;\\n                q.pop() ;\\n                currlevel.push_back(tmp->val) ;\\n                for (auto n : tmp -> children)\\n                     q.push(n); \\n            }\\n            res.push_back(currlevel) ;\\n        }\\n        return res ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 286174,
                "title": "python-bfs-simple-and-clear",
                "content": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val, children):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        \\n        queue = [root] if root else []\\n        ans = [] \\n        \\n        while queue:\\n            ans.append([node.val for node in queue])\\n            queue = [child for node in queue for child in node.children]    \\n            \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val, children):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        \\n        queue = [root] if root else []\\n        ans = [] \\n        \\n        while queue:\\n            ans.append([node.val for node in queue])\\n            queue = [child for node in queue for child in node.children]    \\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2532094,
                "title": "easy-solution-bfs-java-video-explaination-100",
                "content": "\\n**If this helped you please upvote!!**\\n\\nCheckout the video explanation on youtube: https://www.youtube.com/watch?v=oVlZJqcB98c&t=312s\\n\\n**SOLUTION: JAVA**\\n```java\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n        \\n        List<List<Integer>> output = new ArrayList<>();\\n        Queue<Node> queue = new LinkedList<>();\\n        \\n        if(root == null) return output;\\n        queue.add(root);\\n        \\n        while(!queue.isEmpty()){\\n            \\n            // stores the number of values in current row (we alter amount in queue later)\\n            int rowLen = queue.size();\\n            List<Integer> currRow = new ArrayList<>();\\n            for(int i = 0; i < rowLen; i++){\\n                \\n                // Add current value into row list values.\\n                Node curr = queue.poll();\\n                currRow.add(curr.val);\\n    \\n                // Add Children of current node into queue.\\n                int numChildren = curr.children.size();\\n                for(int c = 0; c < numChildren; c++) { \\n                    if(curr.children.get(c) != null) queue.add(curr.children.get(c));\\n                }\\n            }\\n            output.add(currRow);\\n        }\\n        return output;\\n    }\\n}\\n```\\n\\n<img width=300 src=\"https://assets.leetcode.com/users/images/ef3f10e0-755a-4d27-96e2-ae9599de1db6_1662343714.32972.png\">\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```java\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n        \\n        List<List<Integer>> output = new ArrayList<>();\\n        Queue<Node> queue = new LinkedList<>();\\n        \\n        if(root == null) return output;\\n        queue.add(root);\\n        \\n        while(!queue.isEmpty()){\\n            \\n            // stores the number of values in current row (we alter amount in queue later)\\n            int rowLen = queue.size();\\n            List<Integer> currRow = new ArrayList<>();\\n            for(int i = 0; i < rowLen; i++){\\n                \\n                // Add current value into row list values.\\n                Node curr = queue.poll();\\n                currRow.add(curr.val);\\n    \\n                // Add Children of current node into queue.\\n                int numChildren = curr.children.size();\\n                for(int c = 0; c < numChildren; c++) { \\n                    if(curr.children.get(c) != null) queue.add(curr.children.get(c));\\n                }\\n            }\\n            output.add(currRow);\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318438,
                "title": "easy-understanding-c-fast-solution",
                "content": "BFS solution for N-ary level order traversal. !!\\n```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> ans;\\n        if(!root)\\n        {\\n            return ans;\\n        }\\n        vector<int> vi;\\n        \\n        queue<Node* > q;\\n        q.push(root);\\n        \\n        \\n        while(!q.empty())\\n        {\\n            int n=q.size();\\n            \\n            \\n            for(int i=0;i<n;i++)\\n            {\\n                Node *temp=q.front();\\n                q.pop();\\n                \\n                vi.push_back(temp->val);  \\n                for(int j=0;j<temp->children.size();j++)\\n                {\\n                    \\n                    q.push(temp->children[j]); \\n                }\\n            }\\n\\n            ans.push_back(vi);\\n            vi.clear();\\n            \\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> ans;\\n        if(!root)\\n        {\\n            return ans;\\n        }\\n        vector<int> vi;\\n        \\n        queue<Node* > q;\\n        q.push(root);\\n        \\n        \\n        while(!q.empty())\\n        {\\n            int n=q.size();\\n            \\n            \\n            for(int i=0;i<n;i++)\\n            {\\n                Node *temp=q.front();\\n                q.pop();\\n                \\n                vi.push_back(temp->val);  \\n                for(int j=0;j<temp->children.size();j++)\\n                {\\n                    \\n                    q.push(temp->children[j]); \\n                }\\n            }\\n\\n            ans.push_back(vi);\\n            vi.clear();\\n            \\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 241645,
                "title": "c-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void bfs(Node* root, vector<vector<int>>& result, int level){\\n        if(!root)   return;\\n        if(result.size() == level)  result.push_back({});\\n        result[level].push_back(root->val);\\n        auto children = root->children;\\n        for(int i = 0; i < (root->children).size(); i++){\\n            bfs((root->children)[i], result, level + 1);\\n        }\\n    }\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> result;\\n        bfs(root, result, 0);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void bfs(Node* root, vector<vector<int>>& result, int level){\\n        if(!root)   return;\\n        if(result.size() == level)  result.push_back({});\\n        result[level].push_back(root->val);\\n        auto children = root->children;\\n        for(int i = 0; i < (root->children).size(); i++){\\n            bfs((root->children)[i], result, level + 1);\\n        }\\n    }\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> result;\\n        bfs(root, result, 0);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 881871,
                "title": "my-java-bfs-solution-with-comments",
                "content": "Ex: Give the following n-ary tree\\u2026\\n\\n    8\\n  / | \\\\\\n 2  3  29\\nreturn [[8], [2, 3, 29]]\\nEx: Given the following n-ary tree\\u2026\\n\\n     2\\n   / | \\\\\\n  1  6  9\\n /   |   \\\\\\n8    2    2\\n   / | \\\\\\n 19 12 90\\nreturn [[2], [1, 6, 9], [8, 2, 2], [19, 12, 90]]\\n\\n// here we can do a BFS search. But here we can\\'t deal with say node.left, node.right checking as there can be n children for a node.\\n// so a list of children will be provided and these children must be also added and considered\\n\\n     2\\n   / | \\\\\\n  1  6  9     -> At first we add 2, then we add all its children to the queue and pops out 2 -> [[2]]\\n /   |   \\\\    -> Next we take 1, 6, 9 , find their children and add them into the queue adn pops each 1, 6, 9 ->[[2],[1,6,9]]\\n8    2    2   -> Same way we do for 8, 2, 2 and also 19, 12, 90 and add them into the list and our final answer become [[2],[1,6,9],[8,2,2],[19,12,90]]\\n   / | \\\\\\n 19 12 90\\n\\n\\n// Since we are doing a BFS here and we are going through all the node time = O(nodes) and space = O(width)\\n\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n        // 1. initialise our result holding variable\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif (root == null)\\n\\t\\t\\treturn result;\\n\\t\\t// 2. Initialize queue for BFS\\n\\t\\tQueue<Node> queue = new LinkedList<>();\\n\\t\\tqueue.offer(root); //start by adding the root\\n\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\tList<Integer> current = new ArrayList<>(); // inorder to store the current level items\\n\\t\\t\\tint size = queue.size();\\n\\t\\t\\tfor (int i=0; i<size; i++) {\\n\\t\\t\\t\\tNode temp = queue.poll(); // pop out the first element from the queue.\\n\\t\\t\\t\\tcurrent.add(temp.val);   // add the element into current list.\\n\\t\\t\\t\\tqueue.addAll(temp.children); // add all the children of the node to the queue.\\n\\t\\t\\t}\\n\\t\\t\\tresult.add(current);  // we have all the elements of current level and add it into the final result\\n\\t\\t}\\n\\t\\treturn result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n        // 1. initialise our result holding variable\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif (root == null)\\n\\t\\t\\treturn result;\\n\\t\\t// 2. Initialize queue for BFS\\n\\t\\tQueue<Node> queue = new LinkedList<>();\\n\\t\\tqueue.offer(root); //start by adding the root\\n\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\tList<Integer> current = new ArrayList<>(); // inorder to store the current level items\\n\\t\\t\\tint size = queue.size();\\n\\t\\t\\tfor (int i=0; i<size; i++) {\\n\\t\\t\\t\\tNode temp = queue.poll(); // pop out the first element from the queue.\\n\\t\\t\\t\\tcurrent.add(temp.val);   // add the element into current list.\\n\\t\\t\\t\\tqueue.addAll(temp.children); // add all the children of the node to the queue.\\n\\t\\t\\t}\\n\\t\\t\\tresult.add(current);  // we have all the elements of current level and add it into the final result\\n\\t\\t}\\n\\t\\treturn result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2533750,
                "title": "c-solution-three-approaches-hashmap-based-bfs-based-98-faster",
                "content": "## __Approach 1, Using map__\\n\\n__1. Create a Map to tacks the node values at each level\\n2. Push the current parent in the current level\\n3. Traverse the children of the current node\\n4. Repeat steps 2 and 3 until the entire tree is traversed\\n5. Once the tree is traversed, Our map will be an ordered collection of the vector of nodes at each level in the tree\\n6. Now simply create an answer vector of vectors, and push all the vectors from the map into it\\n7. Return the answer vector__\\n\\n``Advantage of this approach is that it only requires a normal tree traversal and right pushing of the elements, while keeping the track of the current level\\nNO Need to store any nodes or perform BFS``\\n\\n__Below is the coding implementation for the same__\\n\\n```\\n// Runtime: 28 ms, faster than 78.21% of C++ online submissions for N-ary Tree Level Order Traversal.\\n// Memory Usage: 12.5 MB, less than 6.02% of C++ online submissions for N-ary Tree Level Order Traversal.\\nclass Solution\\n{\\npublic:\\n    // Map to tacks the node values at each level\\n    map<int, vector<int>> mp;\\n    void check(Node *r, int l)\\n    {\\n        // if null, return the control\\n        if (r == NULL)\\n            return;\\n        // Push the current node at the current level\\n        mp[l].push_back(r->val);\\n        // Check all the children of the current nodes and traverse them\\n        for (auto i : r->children)\\n            check(i, l + 1);\\n    }\\n    vector<vector<int>> levelOrder(Node *root)\\n    {\\n        ios_base::sync_with_stdio(0);\\n        check(root, 0);\\n        vector<vector<int>> ans;\\n        // Since the map is ordered, just push all the vectors stored in the map into the resultant vector\\n        for (auto i : mp)\\n            ans.push_back(i.second);\\n        return ans;\\n    }\\n};\\n```\\n__Time Complexity : O(N), N = Number of nodes in the tree \\nSpace Complexity : O(N)__\\n_____\\n\\n# __Approach 2, using BFS__\\n __Idea here is to use the breadth first search\\nStore the first node in the current queue\\nNow while Current is empty__\\n>Create a temporary queue to store the children nodes, and a vector to store the current parents\\n> Taverse the parent queue, till its empty\\n>> Store the current parent node in the current queue, in a temporary variable\\n>> Push its value in the parent vector\\n>> Now add all the children of this parent to the child queue\\n>> Pop the current parent\\n>> \\n>Push the current set of parents in the answer vector\\n>Set the current child queue as the new parent queue\\n\\n__Return the answer vector__\\n\\n__Below is the coding implementation for the same__\\n\\n```\\n// Runtime: 30 ms, faster than 71.32% of C++ online submissions for N-ary Tree Level Order Traversal.\\n// Memory Usage: 13 MB, less than 6.02% of C++ online submissions for N-ary Tree Level Order Traversal.\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> levelOrder(Node *root)\\n    {\\n        // BFS Finally\\n        ios_base::Sync_with_stdio(0);\\n        vector<vector<int>> ans;\\n        // if null, return the control\\n        if (r == NULL)\\n            return;\\n        // Node to store current set of parent nodes\\n        queue<Node *> parent;\\n        parent.push(r);\\n        while (!parent.empty())\\n        {\\n            // Queue to store the children of the next level\\n            queue<Node *> child;\\n            // Vector to store the values of the nodes in the current level\\n            vector<int> v;\\n            while (!parent.empty())\\n            {\\n                // Storing the current parent\\n                Node *t = parent.front();\\n                // Pushing its value in the vector\\n                v.push_back(t->val);\\n                // Storing all the children of this node in the child Queue\\n                for (Node *i : t->children)\\n                    child.push(i);\\n                // Removing the current parent from the curr Queue\\n                parent.pop();\\n            }\\n            // Pusshing the values of the currnet level in the ans vector\\n            ans.push_back(v);\\n            // Making the current children nodes as the next set of parent nodes\\n            parent = child;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n__Time Complexity : O(N), N = Number of nodes in the tree \\nSpace Complexity : O(N)__\\n____\\n# __Approach 3, using BFS with only one Queue__\\n__From 2 Queues to 1\\nImproving Upon the previous solution__\\n\\n__The approach is same as above\\nOnly changes are now we wont use the child queue__\\n\\n__Instead, we will store the length len of the parent queue, before looking for the child nodes\\nRun the loop len times, \\nPush the children nodes in the current queue\\npop the current parent__\\n\\n__Perform the above steps till the current queue is empty\\nReturn the answer vector__\\n\\n__Below is the coding implementation for the same__\\n\\n```\\n// Runtime: 19 ms, faster than 98.33% of C++ online submissions for N-ary Tree Level Order Traversal.\\n// Memory Usage: 11.7 MB, less than 65.30% of C++ online submissions for N-ary Tree Level Order Traversal.\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> levelOrder(Node *root)\\n    {\\n        // BFS Finally\\n        ios_base::sync_with_stdio(0);\\n        vector<vector<int>> ans;\\n        // if null, return the control\\n        if (root == NULL)\\n            return ans;\\n        // Node to store current set of parent nodes\\n        queue<Node *> curr;\\n        curr.push(root);\\n        while (!curr.empty())\\n        {\\n            // Get the length of the queue, so that only the current parents are traversed\\n            int len = curr.size();\\n            // Vector to store the values of the nodes in the current level\\n            vector<int> v;\\n            for (int i = 0; i < len; i++)\\n            {\\n                // Storing the current parent\\n                Node *t = curr.front();\\n                // Pushing its value in the vector\\n                v.push_back(t->val);\\n                // Storing all the children of this node in the Queue\\n                for (Node *i : t->children)\\n                    curr.push(i);\\n                // Removing the current parent from the curr Queue\\n                curr.pop();\\n            }\\n            // Pusshing the values of the currnet level in the ans vector\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n__Time Complexity : O(N), N = Number of nodes in the tree \\nSpace Complexity : O(N)__\\n____",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\n// Runtime: 28 ms, faster than 78.21% of C++ online submissions for N-ary Tree Level Order Traversal.\\n// Memory Usage: 12.5 MB, less than 6.02% of C++ online submissions for N-ary Tree Level Order Traversal.\\nclass Solution\\n{\\npublic:\\n    // Map to tacks the node values at each level\\n    map<int, vector<int>> mp;\\n    void check(Node *r, int l)\\n    {\\n        // if null, return the control\\n        if (r == NULL)\\n            return;\\n        // Push the current node at the current level\\n        mp[l].push_back(r->val);\\n        // Check all the children of the current nodes and traverse them\\n        for (auto i : r->children)\\n            check(i, l + 1);\\n    }\\n    vector<vector<int>> levelOrder(Node *root)\\n    {\\n        ios_base::sync_with_stdio(0);\\n        check(root, 0);\\n        vector<vector<int>> ans;\\n        // Since the map is ordered, just push all the vectors stored in the map into the resultant vector\\n        for (auto i : mp)\\n            ans.push_back(i.second);\\n        return ans;\\n    }\\n};\\n```\n```\\n// Runtime: 30 ms, faster than 71.32% of C++ online submissions for N-ary Tree Level Order Traversal.\\n// Memory Usage: 13 MB, less than 6.02% of C++ online submissions for N-ary Tree Level Order Traversal.\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> levelOrder(Node *root)\\n    {\\n        // BFS Finally\\n        ios_base::Sync_with_stdio(0);\\n        vector<vector<int>> ans;\\n        // if null, return the control\\n        if (r == NULL)\\n            return;\\n        // Node to store current set of parent nodes\\n        queue<Node *> parent;\\n        parent.push(r);\\n        while (!parent.empty())\\n        {\\n            // Queue to store the children of the next level\\n            queue<Node *> child;\\n            // Vector to store the values of the nodes in the current level\\n            vector<int> v;\\n            while (!parent.empty())\\n            {\\n                // Storing the current parent\\n                Node *t = parent.front();\\n                // Pushing its value in the vector\\n                v.push_back(t->val);\\n                // Storing all the children of this node in the child Queue\\n                for (Node *i : t->children)\\n                    child.push(i);\\n                // Removing the current parent from the curr Queue\\n                parent.pop();\\n            }\\n            // Pusshing the values of the currnet level in the ans vector\\n            ans.push_back(v);\\n            // Making the current children nodes as the next set of parent nodes\\n            parent = child;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n// Runtime: 19 ms, faster than 98.33% of C++ online submissions for N-ary Tree Level Order Traversal.\\n// Memory Usage: 11.7 MB, less than 65.30% of C++ online submissions for N-ary Tree Level Order Traversal.\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> levelOrder(Node *root)\\n    {\\n        // BFS Finally\\n        ios_base::sync_with_stdio(0);\\n        vector<vector<int>> ans;\\n        // if null, return the control\\n        if (root == NULL)\\n            return ans;\\n        // Node to store current set of parent nodes\\n        queue<Node *> curr;\\n        curr.push(root);\\n        while (!curr.empty())\\n        {\\n            // Get the length of the queue, so that only the current parents are traversed\\n            int len = curr.size();\\n            // Vector to store the values of the nodes in the current level\\n            vector<int> v;\\n            for (int i = 0; i < len; i++)\\n            {\\n                // Storing the current parent\\n                Node *t = curr.front();\\n                // Pushing its value in the vector\\n                v.push_back(t->val);\\n                // Storing all the children of this node in the Queue\\n                for (Node *i : t->children)\\n                    curr.push(i);\\n                // Removing the current parent from the curr Queue\\n                curr.pop();\\n            }\\n            // Pusshing the values of the currnet level in the ans vector\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2532797,
                "title": "java-bfs-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n        \\n         List<List<Integer>> res = new ArrayList<>();\\n        \\n        if(root == null) return res;\\n            \\n        Queue<Node> q = new LinkedList<>();\\n        q.add(root);\\n        \\n        while(!q.isEmpty()){\\n            \\n            int size = q.size(); // no. of nodes at current level\\n            List<Integer> curLvl = new ArrayList<>(); // list of current level node values\\n            \\n            while(size-- > 0){ \\n                Node cur = q.poll();\\n                curLvl.add(cur.val);\\n                \\n                for(Node child: cur.children){ // add current node\\'s child into queue\\n                    q.add(child);\\n                }\\n            }\\n            \\n            res.add(new ArrayList<>(curLvl));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n        \\n         List<List<Integer>> res = new ArrayList<>();\\n        \\n        if(root == null) return res;\\n            \\n        Queue<Node> q = new LinkedList<>();\\n        q.add(root);\\n        \\n        while(!q.isEmpty()){\\n            \\n            int size = q.size(); // no. of nodes at current level\\n            List<Integer> curLvl = new ArrayList<>(); // list of current level node values\\n            \\n            while(size-- > 0){ \\n                Node cur = q.poll();\\n                curLvl.add(cur.val);\\n                \\n                for(Node child: cur.children){ // add current node\\'s child into queue\\n                    q.add(child);\\n                }\\n            }\\n            \\n            res.add(new ArrayList<>(curLvl));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 529587,
                "title": "javascript-iterative-recursive",
                "content": "### Iterative Level-order Traverse\\n- Time Complexity: **O(N^2)** `consider .shift() takes linear`\\n- Space Complexity: **O(N)**\\n```JavaScript\\n/**\\n * @param {Node} root\\n * @return {number[][]}\\n */\\nvar levelOrder = function(root) {\\n    const res = [], queue = [];\\n    let depth = 0, num = 0;\\n    if (root) queue.push(root);\\n    while (queue.length) {\\n        res.push([]);\\n        num = queue.length;\\n        for (let i = 0; i < num; i++) {\\n            const curr = queue.shift();\\n            if (!curr) continue;\\n            res[depth].push(curr.val);\\n            queue.push(...curr.children);\\n        }\\n        depth++;\\n    }\\n    return res;\\n};\\n```\\n### Recursive Level-order Traverse\\n- Time Complexity: \\n  - **O(N)**\\n- Space Complexity:\\n    - **O(log N)** in average case.\\n    - **O(N)** in worst case, that there is an unbalanced tree.\\n```JavaScript\\n/**\\n * @param {Node} root\\n * @return {number[][]}\\n */\\nvar levelOrder = function(root) {\\n    const res = [];\\n    BFS(root, 0);\\n    return res;\\n    \\n    function BFS(node, depth) {\\n        if (!node) return;\\n        if (depth === res.length) {\\n            res.push([]);\\n        }\\n        res[depth].push(node.val);\\n        for (child of node.children) {\\n            BFS(child, depth + 1);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```JavaScript\\n/**\\n * @param {Node} root\\n * @return {number[][]}\\n */\\nvar levelOrder = function(root) {\\n    const res = [], queue = [];\\n    let depth = 0, num = 0;\\n    if (root) queue.push(root);\\n    while (queue.length) {\\n        res.push([]);\\n        num = queue.length;\\n        for (let i = 0; i < num; i++) {\\n            const curr = queue.shift();\\n            if (!curr) continue;\\n            res[depth].push(curr.val);\\n            queue.push(...curr.children);\\n        }\\n        depth++;\\n    }\\n    return res;\\n};\\n```\n```JavaScript\\n/**\\n * @param {Node} root\\n * @return {number[][]}\\n */\\nvar levelOrder = function(root) {\\n    const res = [];\\n    BFS(root, 0);\\n    return res;\\n    \\n    function BFS(node, depth) {\\n        if (!node) return;\\n        if (depth === res.length) {\\n            res.push([]);\\n        }\\n        res[depth].push(node.val);\\n        for (child of node.children) {\\n            BFS(child, depth + 1);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 506649,
                "title": "python3-bfs-solution",
                "content": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        ans = []\\n\\n        if not root:\\n            return\\n        \\n        def bsf(nodes):\\n            if not nodes:\\n                return\\n           \\n            children, nextNodes = [], []\\n            for node in nodes:\\n                children.append(node.val)\\n                nextNodes += node.children\\n            ans.append(children)\\n            bsf(nextNodes)\\n            \\n        ans.append([root.val])\\n        bsf(root.children)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        ans = []\\n\\n        if not root:\\n            return\\n        \\n        def bsf(nodes):\\n            if not nodes:\\n                return\\n           \\n            children, nextNodes = [], []\\n            for node in nodes:\\n                children.append(node.val)\\n                nextNodes += node.children\\n            ans.append(children)\\n            bsf(nextNodes)\\n            \\n        ans.append([root.val])\\n        bsf(root.children)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 391896,
                "title": "recursive-and-iterative-solutions-using-javascript",
                "content": "## Recursive Solution\\n\\n```javascript\\n/**\\n * // Definition for a Node.\\n * function Node(val,children) {\\n *    this.val = val;\\n *    this.children = children;\\n * };\\n */\\n/**\\n * @param {Node} root\\n * @return {number[][]}\\n */\\nvar levelOrder = function(root) {\\n  const result = []\\n  if (root != null) {\\n    traverseLevel(root, 0)\\n  }\\n  \\n  return result\\n  \\n  function traverseLevel(node, depth) {\\n    if (node != null) {\\n      if (result[depth] == null) { /* start of new level, init with new array */\\n        result[depth] = []\\n      }\\n      result[depth].push(node.val) /* level exists, push current node\\'s val */\\n    }\\n    \\n    depth++ /* previous level traversed completely so we increment depth to proceed to the next level */\\n    \\n    for (const child of node.children) {\\n      traverseLevel(child, depth) /* call traverse fn on each child of the current node */\\n    }\\n  }\\n};\\n```\\n\\n## Iterative Solution\\n\\n```javascript\\n/**\\n * // Definition for a Node.\\n * function Node(val,children) {\\n *    this.val = val;\\n *    this.children = children;\\n * };\\n */\\n/**\\n * @param {Node} root\\n * @return {number[][]}\\n */\\nvar levelOrder = function(root) {\\n  if (root == null) {\\n    return []\\n  }\\n  \\n  const result = [] /* this will hold the desired result */\\n  const queue = [root] /* init with root */\\n  \\n  while (queue.length > 0) {\\n    const levelSize = queue.length /* get the size of the queue at this point */\\n    const level = [] /* init empty array for the values of the current level */\\n    for (let i = 0; i < levelSize; i++) { /* loop over the values ONLY for this level */\\n      const head = queue.shift() /* remove the head element and retain in a variable */\\n      for (const child of head.children) {\\n        queue.push(child) /* enqueue each child so we can process their values */\\n      }\\n      level.push(head.val) /* process the current node\\'s value */\\n    }\\n    result.push(level) /* we are finished with this level */\\n  }\\n  return result\\n};\\n```\\n\\n\\nAs always, **THANK YOU** for reading and feedback is welcome! :)",
                "solutionTags": [
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```javascript\\n/**\\n * // Definition for a Node.\\n * function Node(val,children) {\\n *    this.val = val;\\n *    this.children = children;\\n * };\\n */\\n/**\\n * @param {Node} root\\n * @return {number[][]}\\n */\\nvar levelOrder = function(root) {\\n  const result = []\\n  if (root != null) {\\n    traverseLevel(root, 0)\\n  }\\n  \\n  return result\\n  \\n  function traverseLevel(node, depth) {\\n    if (node != null) {\\n      if (result[depth] == null) { /* start of new level, init with new array */\\n        result[depth] = []\\n      }\\n      result[depth].push(node.val) /* level exists, push current node\\'s val */\\n    }\\n    \\n    depth++ /* previous level traversed completely so we increment depth to proceed to the next level */\\n    \\n    for (const child of node.children) {\\n      traverseLevel(child, depth) /* call traverse fn on each child of the current node */\\n    }\\n  }\\n};\\n```\n```javascript\\n/**\\n * // Definition for a Node.\\n * function Node(val,children) {\\n *    this.val = val;\\n *    this.children = children;\\n * };\\n */\\n/**\\n * @param {Node} root\\n * @return {number[][]}\\n */\\nvar levelOrder = function(root) {\\n  if (root == null) {\\n    return []\\n  }\\n  \\n  const result = [] /* this will hold the desired result */\\n  const queue = [root] /* init with root */\\n  \\n  while (queue.length > 0) {\\n    const levelSize = queue.length /* get the size of the queue at this point */\\n    const level = [] /* init empty array for the values of the current level */\\n    for (let i = 0; i < levelSize; i++) { /* loop over the values ONLY for this level */\\n      const head = queue.shift() /* remove the head element and retain in a variable */\\n      for (const child of head.children) {\\n        queue.push(child) /* enqueue each child so we can process their values */\\n      }\\n      level.push(head.val) /* process the current node\\'s value */\\n    }\\n    result.push(level) /* we are finished with this level */\\n  }\\n  return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 262292,
                "title": "java-solution-beats-100-dfs",
                "content": "```\\npublic List<List<Integer>> levelOrder(Node root) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        dfs(root, 0, result);\\n        return result;\\n    }\\n    \\n    public void dfs(Node root, int depth, List<List<Integer>> result){\\n        if(root != null){\\n            if(result.size() < depth + 1)\\n                result.add(depth, new ArrayList<Integer>());\\n            result.get(depth).add(root.val);\\n            depth++;\\n            for(Node child: root.children)\\n                dfs(child, depth, result);\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<List<Integer>> levelOrder(Node root) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        dfs(root, 0, result);\\n        return result;\\n    }\\n    \\n    public void dfs(Node root, int depth, List<List<Integer>> result){\\n        if(root != null){\\n            if(result.size() < depth + 1)\\n                result.add(depth, new ArrayList<Integer>());\\n            result.get(depth).add(root.val);\\n            depth++;\\n            for(Node child: root.children)\\n                dfs(child, depth, result);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2533078,
                "title": "java-best-solution-queue-n-ary-tree",
                "content": "Create Queue nd keep on adding children of next level while in the same time we keep on adding values of current level to the Ans-List.\\n \\n ***CODE***\\n```\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n      List<List<Integer>> ans=new ArrayList<>();\\n        if(root==null){return ans;}\\n        Queue<Node> q=new LinkedList<>();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n         List<Integer> level=new ArrayList<>();\\n            int n=q.size();\\n           for(int i=0;i<n;i++){\\n         Node curr=q.poll();\\n         level.add(curr.val);\\n        for(int j=0;j<curr.children.size();j++ ){\\n             q.add(curr.children.get(j));}\\n            }\\n            ans.add(level);\\n        }\\n                \\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n      List<List<Integer>> ans=new ArrayList<>();\\n        if(root==null){return ans;}\\n        Queue<Node> q=new LinkedList<>();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n         List<Integer> level=new ArrayList<>();\\n            int n=q.size();\\n           for(int i=0;i<n;i++){\\n         Node curr=q.poll();\\n         level.add(curr.val);\\n        for(int j=0;j<curr.children.size();j++ ){\\n             q.add(curr.children.get(j));}\\n            }\\n            ans.add(level);\\n        }\\n                \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2532656,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "**Java**\\n```\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        lvls(root, list, 0);\\n        return list;\\n    }\\n    private void lvls(Node root, List<List<Integer>> list, int level){\\n        if(root == null)    return;\\n        if(list.size() <= level)    list.add(new ArrayList());\\n        list.get(level).add(root.val);\\n        root.children.forEach(child -> lvls(child, list, level+1));\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar levelOrder = function(root) {\\n    let list = []\\n    function lvls(root, level){\\n        if (!root) return\\n        if (level === list.length)  list.push([])\\n        list[level].push(root.val)\\n        root.children.forEach(child => lvls(child, level+1))\\n    }\\n    lvls(root, 0)\\n    return list\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def levelOrder(self, root):\\n        lst = []\\n        \\n        def lvls(root, level):\\n            if not root:\\n                return\\n            if level == len(lst):\\n                lst.append([])\\n            lst[level].append(root.val)\\n            for child in root.children:\\n                lvls(child, level+1)\\n                \\n        lvls(root, 0)\\n        return lst\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        lvls(root, list, 0);\\n        return list;\\n    }\\n    private void lvls(Node root, List<List<Integer>> list, int level){\\n        if(root == null)    return;\\n        if(list.size() <= level)    list.add(new ArrayList());\\n        list.get(level).add(root.val);\\n        root.children.forEach(child -> lvls(child, list, level+1));\\n    }\\n}\\n```\n```\\nvar levelOrder = function(root) {\\n    let list = []\\n    function lvls(root, level){\\n        if (!root) return\\n        if (level === list.length)  list.push([])\\n        list[level].push(root.val)\\n        root.children.forEach(child => lvls(child, level+1))\\n    }\\n    lvls(root, 0)\\n    return list\\n};\\n```\n```\\nclass Solution(object):\\n    def levelOrder(self, root):\\n        lst = []\\n        \\n        def lvls(root, level):\\n            if not root:\\n                return\\n            if level == len(lst):\\n                lst.append([])\\n            lst[level].append(root.val)\\n            for child in root.children:\\n                lvls(child, level+1)\\n                \\n        lvls(root, 0)\\n        return lst\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2532452,
                "title": "c-bfs-short-concise-soln",
                "content": "\\n```\\n        vector<vector<int>> res;\\n        if(!root)return res;\\n        \\n        queue<Node*> q;\\n        q.push(root);\\n        \\n        while(q.size()){\\n            vector<int> store;\\n            vector<Node*> v;                  // storing nodes of next level \\n            \\n            while(q.size()){                         //  At any moment ,all the nodes present in the queue will be of same level, so we take out all node of that level and store their children  \\n                 store.push_back(q.front()->val);\\n                 for(auto i : q.front()->children)v.push_back(i);\\n                 q.pop();  \\n            }\\n            \\n            for(auto i : v)q.push(i);                // when queue becomes empty , push in all nodes of the next level stored in v\\n            res.push_back(store);\\n            \\n        }\\n        \\n        \\n        return res;\\n```",
                "solutionTags": [],
                "code": "```\\n        vector<vector<int>> res;\\n        if(!root)return res;\\n        \\n        queue<Node*> q;\\n        q.push(root);\\n        \\n        while(q.size()){\\n            vector<int> store;\\n            vector<Node*> v;                  // storing nodes of next level \\n            \\n            while(q.size()){                         //  At any moment ,all the nodes present in the queue will be of same level, so we take out all node of that level and store their children  \\n                 store.push_back(q.front()->val);\\n                 for(auto i : q.front()->children)v.push_back(i);\\n                 q.pop();  \\n            }\\n            \\n            for(auto i : v)q.push(i);                // when queue becomes empty , push in all nodes of the next level stored in v\\n            res.push_back(store);\\n            \\n        }\\n        \\n        \\n        return res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3689012,
                "title": "java-python-c-easy",
                "content": "# N-ary Tree level Order Traversal \\n> ### *Try to understand the code line by line. Easy BFS solution.* \\n```java []\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n        Queue<Node> queue = new LinkedList<>();\\n        List<List<Integer>> result = new ArrayList<>();\\n        if(root == null)\\n            return result;\\n        queue.offer(root);\\n        while(queue.size() > 0)\\n        {\\n            List<Integer> arr = new ArrayList<>();\\n            int length = queue.size();\\n            for(int i = 0;i<length;i++)\\n            {\\n                Node curr = queue.poll();\\n                arr.add(curr.val);\\n                for(Node child : curr.children)\\n                {\\n                    queue.offer(child);\\n                }\\n            }\\n            result.add(arr);\\n        }\\n        return result;\\n    }\\n}\\n```\\n```python []\\nfrom collections import deque\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        queue = deque()\\n        result = []\\n        if not root:\\n            return result\\n        queue.append(root)\\n        while queue:\\n            arr = []\\n            length = len(queue)\\n            for i in range(length):\\n                curr = queue.popleft()\\n                arr.append(curr.val)\\n                for child in curr.children:\\n                    queue.append(child)\\n            result.append(arr)\\n        return result\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        queue<Node*> q;\\n        vector<vector<int>> res;\\n        if(root == NULL)\\n            return res;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            vector<int> arr;\\n            int length = q.size();\\n            for(int i = 0;i<length;i++)\\n            {\\n                Node* curr = q.front();\\n                q.pop();\\n                arr.push_back(curr->val);\\n                for(Node* child : curr->children)\\n                {\\n                    q.push(child);\\n                }\\n            }\\n            res.push_back(arr);\\n        }\\n        return res;\\n    }\\n};\\n```\\n---\\n#### *Please don\\'t forget to upvote if you\\'ve liked my solution.* \\u2B06\\uFE0F\\n---",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```java []\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n        Queue<Node> queue = new LinkedList<>();\\n        List<List<Integer>> result = new ArrayList<>();\\n        if(root == null)\\n            return result;\\n        queue.offer(root);\\n        while(queue.size() > 0)\\n        {\\n            List<Integer> arr = new ArrayList<>();\\n            int length = queue.size();\\n            for(int i = 0;i<length;i++)\\n            {\\n                Node curr = queue.poll();\\n                arr.add(curr.val);\\n                for(Node child : curr.children)\\n                {\\n                    queue.offer(child);\\n                }\\n            }\\n            result.add(arr);\\n        }\\n        return result;\\n    }\\n}\\n```\n```python []\\nfrom collections import deque\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        queue = deque()\\n        result = []\\n        if not root:\\n            return result\\n        queue.append(root)\\n        while queue:\\n            arr = []\\n            length = len(queue)\\n            for i in range(length):\\n                curr = queue.popleft()\\n                arr.append(curr.val)\\n                for child in curr.children:\\n                    queue.append(child)\\n            result.append(arr)\\n        return result\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        queue<Node*> q;\\n        vector<vector<int>> res;\\n        if(root == NULL)\\n            return res;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            vector<int> arr;\\n            int length = q.size();\\n            for(int i = 0;i<length;i++)\\n            {\\n                Node* curr = q.front();\\n                q.pop();\\n                arr.push_back(curr->val);\\n                for(Node* child : curr->children)\\n                {\\n                    q.push(child);\\n                }\\n            }\\n            res.push_back(arr);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205213,
                "title": "python3-57ms-easy-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple BFS can solve this problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- store nodes by level.\\n- traverse all children.\\n- if current node is None return.\\n- return answer\\n\\n# Approach for array\\n- here using array instade of dictionary is helpful.\\n- because if we use dictionary then insertion is easy but getting values at last is O(N).\\n- so we to save this time we can use something of this type.\\n\\n# Complexity\\n- Time complexity: O(H)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        ans = []\\n        def helper(curr = root, level = 0):\\n            nonlocal ans\\n            if curr:\\n                if len(ans) > level:\\n                    ans[level].append(curr.val)\\n                else:\\n                    ans.append([curr.val])\\n                for i in curr.children:\\n                    helper(i, level + 1)\\n            return\\n        helper()\\n        return ans\\n```\\n# Please like and comment below.\\n# (\\u3063\\uFF3E\\u25BF\\uFF3E)\\u06F6\\uD83C\\uDF78\\uD83C\\uDF1F\\uD83C\\uDF7A\\u0669(\\u02D8\\u25E1\\u02D8 )",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        ans = []\\n        def helper(curr = root, level = 0):\\n            nonlocal ans\\n            if curr:\\n                if len(ans) > level:\\n                    ans[level].append(curr.val)\\n                else:\\n                    ans.append([curr.val])\\n                for i in curr.children:\\n                    helper(i, level + 1)\\n            return\\n        helper()\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2531979,
                "title": "daily-leetcoding-challenge-september-day-5",
                "content": "This problem is the Daily LeetCoding Challenge for September, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-ary-tree-level-order-traversal/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search using a Queue\n\n  \n**Approach 2:** Simplified Breadth-first Search\n\n  \n**Approach 3:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-ary-tree-level-order-traversal/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1386843,
                "title": "python3-simple-soultion",
                "content": "```\\ndef levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        q = deque()\\n    \\n        if root is None:\\n            return []\\n        \\n        result = []\\n        q.append(root)\\n        \\n        while q:\\n            level = []\\n            size = len(q)\\n            while size:\\n                curr_node = q.popleft()\\n                level.append(curr_node.val)\\n                for child in curr_node.children:\\n                    q.append(child)\\n                size -= 1\\n            result.append(level)\\n            \\n        return result",
                "solutionTags": [],
                "code": "```\\ndef levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        q = deque()\\n    \\n        if root is None:\\n            return []\\n        \\n        result = []\\n        q.append(root)\\n        \\n        while q:\\n            level = []\\n            size = len(q)\\n            while size:\\n                curr_node = q.popleft()\\n                level.append(curr_node.val)\\n                for child in curr_node.children:\\n                    q.append(child)\\n                size -= 1\\n            result.append(level)\\n            \\n        return result",
                "codeTag": "Python3"
            },
            {
                "id": 727235,
                "title": "javascript-clean-5-liner-dfs",
                "content": "```javascript\\nvar levelOrder = function(root) {\\n    const result = [];\\n    callDFS(root, 0);\\n    return result;\\n    \\n    function callDFS(node, level) {\\n        if(!node) return;\\n        if(result[level] === undefined) result.push([node.val]);\\n        else result[level].push(node.val);\\n        \\n        for(let child of node.children) {\\n            callDFS(child, level+1);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar levelOrder = function(root) {\\n    const result = [];\\n    callDFS(root, 0);\\n    return result;\\n    \\n    function callDFS(node, level) {\\n        if(!node) return;\\n        if(result[level] === undefined) result.push([node.val]);\\n        else result[level].push(node.val);\\n        \\n        for(let child of node.children) {\\n            callDFS(child, level+1);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2532119,
                "title": "c-easy-solution-bfs-queue",
                "content": "```c#\\npublic class Solution {\\n    public IList<IList<int>> LevelOrder(Node root) {        \\n        if(root == null) return new List<IList<int>>();\\n        \\n        List<IList<int>> result = new List<IList<int>>();\\n        Queue<Node> queue = new Queue<Node>();\\n        queue.Enqueue(root);\\n        \\n        while(queue.Count != 0){\\n            int count = queue.Count;\\n            List<int> list = new List<int>();\\n            for(int i = 0; i < count; i++){\\n                Node q = queue.Dequeue();\\n                list.Add(q.val);\\n                foreach(var c in q.children){\\n                    queue.Enqueue(c);\\n                }                \\n            }\\n            \\n            result.Add(list);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```c#\\npublic class Solution {\\n    public IList<IList<int>> LevelOrder(Node root) {        \\n        if(root == null) return new List<IList<int>>();\\n        \\n        List<IList<int>> result = new List<IList<int>>();\\n        Queue<Node> queue = new Queue<Node>();\\n        queue.Enqueue(root);\\n        \\n        while(queue.Count != 0){\\n            int count = queue.Count;\\n            List<int> list = new List<int>();\\n            for(int i = 0; i < count; i++){\\n                Node q = queue.Dequeue();\\n                list.Add(q.val);\\n                foreach(var c in q.children){\\n                    queue.Enqueue(c);\\n                }                \\n            }\\n            \\n            result.Add(list);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1869515,
                "title": "java-dfs",
                "content": "```\\nprivate List<List<Integer>> levels;\\n    public List<List<Integer>> levelOrder(Node root) {\\n        levels = new ArrayList<>();\\n        search(root, 0);\\n        return levels;\\n    }\\n\\n    private void search(Node root, int currentLevel) {\\n        if (root == null) return;\\n\\n        if (levels.size() <= currentLevel) {\\n            List<Integer> newLevel = new ArrayList<>();\\n            newLevel.add(root.val);\\n            levels.add(newLevel);\\n        }\\n        else  {\\n            levels.get(currentLevel).add(root.val);\\n        }\\n\\n        for (Node child : root.children) {\\n            search(child, currentLevel + 1);\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nprivate List<List<Integer>> levels;\\n    public List<List<Integer>> levelOrder(Node root) {\\n        levels = new ArrayList<>();\\n        search(root, 0);\\n        return levels;\\n    }\\n\\n    private void search(Node root, int currentLevel) {\\n        if (root == null) return;\\n\\n        if (levels.size() <= currentLevel) {\\n            List<Integer> newLevel = new ArrayList<>();\\n            newLevel.add(root.val);\\n            levels.add(newLevel);\\n        }\\n        else  {\\n            levels.get(currentLevel).add(root.val);\\n        }\\n\\n        for (Node child : root.children) {\\n            search(child, currentLevel + 1);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1808487,
                "title": "c-queue-fast-mem-efficient-correct",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> ans;\\n        if (root == nullptr) return ans;\\n        vector<int> temp;\\n        queue<Node *> q;\\n        q.push(root);\\n        q.push(nullptr);\\n\\n        while(!q.empty()) {\\n            Node *p = q.front();\\n            q.pop();\\n\\n            if (p != nullptr) {\\n               temp.push_back(p->val);\\n                for (Node *n : p->children) {\\n                    q.push(n);\\n                }\\n            }\\n\\n            else {\\n                if (!q.empty()) {\\n                    q.push(nullptr);\\n                }\\n                ans.push_back(temp);\\n                temp.clear();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> ans;\\n        if (root == nullptr) return ans;\\n        vector<int> temp;\\n        queue<Node *> q;\\n        q.push(root);\\n        q.push(nullptr);\\n\\n        while(!q.empty()) {\\n            Node *p = q.front();\\n            q.pop();\\n\\n            if (p != nullptr) {\\n               temp.push_back(p->val);\\n                for (Node *n : p->children) {\\n                    q.push(n);\\n                }\\n            }\\n\\n            else {\\n                if (!q.empty()) {\\n                    q.push(nullptr);\\n                }\\n                ans.push_back(temp);\\n                temp.clear();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1387537,
                "title": "c-solution-using-queue-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) { \\n        vector<vector<int>>ans;\\n        if(root == NULL) return ans;\\n        queue<Node*>q;\\n        q.push(root);\\n        \\n        while(!q.empty()){\\n            int sz = q.size();\\n            vector<int>curr;\\n            while(sz--){\\n                curr.push_back(q.front()->val);\\n                for(Node* i : q.front()->children) q.push(i); \\n                q.pop();\\n            }\\n            ans.push_back(curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) { \\n        vector<vector<int>>ans;\\n        if(root == NULL) return ans;\\n        queue<Node*>q;\\n        q.push(root);\\n        \\n        while(!q.empty()){\\n            int sz = q.size();\\n            vector<int>curr;\\n            while(sz--){\\n                curr.push_back(q.front()->val);\\n                for(Node* i : q.front()->children) q.push(i); \\n                q.pop();\\n            }\\n            ans.push_back(curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1387376,
                "title": "easy-c-bfs-solution",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        if(root==NULL)return {};\\n        queue<pair<Node*,int>> q;\\n        q.push({root,0});\\n        vector<vector<int>> ans;\\n        while(!q.empty()){\\n            pair<Node*,int> curr = q.front();\\n            q.pop();\\n            if(curr.second==(int)ans.size()){\\n                ans.emplace_back();\\n            }\\n            ans[curr.second].push_back((curr.first)->val);\\n            vector<Node*> next = (curr.first)->children;\\n            for(auto it : next){\\n                    q.push({it,curr.second+1});\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n**Time Complexity :** O(N)\\n\\n**Feel free to share suggestions/improvements. Questions/Discussions are welcome.**",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        if(root==NULL)return {};\\n        queue<pair<Node*,int>> q;\\n        q.push({root,0});\\n        vector<vector<int>> ans;\\n        while(!q.empty()){\\n            pair<Node*,int> curr = q.front();\\n            q.pop();\\n            if(curr.second==(int)ans.size()){\\n                ans.emplace_back();\\n            }\\n            ans[curr.second].push_back((curr.first)->val);\\n            vector<Node*> next = (curr.first)->children;\\n            for(auto it : next){\\n                    q.push({it,curr.second+1});\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 560368,
                "title": "python3-dfs-short-32ms-beats-100-in-speed-memory",
                "content": "```\\ndef levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n\\tif not root: return\\n\\td=collections.defaultdict(list)\\n\\tdef dfs(node,height):\\n\\t\\td[height].append(node.val)\\n\\t\\tfor child in node.children:\\n\\t\\t\\tif child: dfs(child,height+1)\\n\\tdfs(root,0)\\n\\treturn [d[height] for height in range(max(d)+1)]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\ndef levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n\\tif not root: return\\n\\td=collections.defaultdict(list)\\n\\tdef dfs(node,height):\\n\\t\\td[height].append(node.val)\\n\\t\\tfor child in node.children:\\n\\t\\t\\tif child: dfs(child,height+1)\\n\\tdfs(root,0)\\n\\treturn [d[height] for height in range(max(d)+1)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 412619,
                "title": "simple-recursive-bfs-java",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n    \\n        List<List<Integer>> res= new ArrayList<>();\\n\\n        if(root != null){\\n                List<Node> l = new ArrayList<>();\\n                l.add(root);\\n                helper(res,l);\\n             }\\n        \\n        return res;\\n    }\\n    \\n    public void helper(List<List<Integer>> res,List<Node> l){\\n\\n        List<Integer> temp = new ArrayList<>();\\n        List<Node> tempNode = new ArrayList<>();\\n        \\n        for(Node i:l){\\n            temp.add(i.val);\\n            \\n            for(Node j:i.children)\\n                tempNode.add(j);\\n        }\\n        \\n        if(temp.size() == 0){\\n              return;  \\n        }else{\\n            res.add(temp);\\n            helper(res,tempNode);\\n            \\n        }\\n  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n    \\n        List<List<Integer>> res= new ArrayList<>();\\n\\n        if(root != null){\\n                List<Node> l = new ArrayList<>();\\n                l.add(root);\\n                helper(res,l);\\n             }\\n        \\n        return res;\\n    }\\n    \\n    public void helper(List<List<Integer>> res,List<Node> l){\\n\\n        List<Integer> temp = new ArrayList<>();\\n        List<Node> tempNode = new ArrayList<>();\\n        \\n        for(Node i:l){\\n            temp.add(i.val);\\n            \\n            for(Node j:i.children)\\n                tempNode.add(j);\\n        }\\n        \\n        if(temp.size() == 0){\\n              return;  \\n        }else{\\n            res.add(temp);\\n            helper(res,tempNode);\\n            \\n        }\\n  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2533608,
                "title": "python-bfs-concise",
                "content": "Just BFS...\\n\\n```\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        if not root: return []\\n        \\n        queue = deque([root])\\n        while queue:\\n            level = []\\n            for _ in range(len(queue)):\\n                node = queue.popleft()\\n                level.append(node.val)\\n                queue += node.children\\n            yield level\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        if not root: return []\\n        \\n        queue = deque([root])\\n        while queue:\\n            level = []\\n            for _ in range(len(queue)):\\n                node = queue.popleft()\\n                level.append(node.val)\\n                queue += node.children\\n            yield level\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2533029,
                "title": "javascript-solution",
                "content": "var levelOrder = function(root) {\\n    if (root === null) return [];\\n    \\n    let result = [];\\n    let queue = [];\\n    queue.push(root);\\n    \\n    while (queue.length > 0) {\\n        let length = queue.length;\\n        let arr = [];\\n        for (let i = 0; i < length; i++) {\\n            let dequeued = queue.shift();\\n            arr.push(dequeued.val);\\n            for (let child of dequeued.children) {\\n                if (child !== null) {\\n                    queue.push(child);\\n                }\\n            }\\n        }\\n        result.push(arr);\\n    }\\n    \\n    return result;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var levelOrder = function(root) {\\n    if (root === null) return [];\\n    \\n    let result = [];\\n    let queue = [];\\n    queue.push(root);\\n    \\n    while (queue.length > 0) {\\n        let length = queue.length;\\n        let arr = [];\\n        for (let i = 0; i < length; i++) {\\n            let dequeued = queue.shift();\\n            arr.push(dequeued.val);\\n            for (let child of dequeued.children) {\\n                if (child !== null) {\\n                    queue.push(child);\\n                }\\n            }\\n        }\\n        result.push(arr);\\n    }\\n    \\n    return result;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2532159,
                "title": "go-python-c-bfs-clean-solution",
                "content": "**Go solution**\\n\\n```\\nfunc levelOrder(root *Node) [][]int {\\n    var result [][]int\\n    \\n    if root == nil { \\n        return result \\n    }\\n    \\n    var queue []*Node\\n    queue = append(queue, root)\\n    \\n    for len(queue) > 0 {\\n        length := len(queue)\\n        \\n        var levelNodes []int\\n        \\n        for i := 0; i < length; i++ {\\n            levelNodes = append(levelNodes, queue[i].Val)\\n            \\n            for _, child := range queue[i].Children {\\n                if child != nil {\\n                    queue = append(queue, child)\\n                }\\n            }\\n        }\\n        \\n        result = append(result, levelNodes)\\n        \\n        if len(queue) == length {\\n            break\\n        }\\n        \\n        queue = queue[length:]\\n    }\\n\\n    return result\\n}\\n\\n```\\n\\n**C++ solution**\\n\\n```\\nclass Solution {\\npublic:\\n  vector<vector<int>> levelOrder(Node* root) {\\n    vector<vector<int>> result;\\n\\n    if (!root) {\\n        return result;\\n    }\\n      \\n    queue <Node *> q;\\n    q.push(root);\\n\\n    while(!q.empty()) {\\n        int size = q.size();\\n        vector<int> levelNodes;\\n\\n        while(size--) {      \\n            levelNodes.push_back(q.front()->val);\\n            \\n            for (int j = 0; j != q.front()->children.size(); j++) {\\n                q.push(q.front()->children[j]);\\n            }\\n            \\n            q.pop();\\n        }\\n        \\n        result.push_back(levelNodes);\\n    }\\n      \\n    return result;       \\n  }\\n};\\n```\\n\\n**Python solution**\\n\\n```\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        result = []\\n        \\n        if root is None:\\n            return result\\n        \\n        queue = collections.deque()\\n        queue.append(root)\\n        \\n        while queue:\\n            length = len(queue)\\n            levelNodes = [] \\n            \\n            for i in range(length):\\n                dequeuedItem = queue.popleft()\\n                \\n                levelNodes.append(dequeuedItem.val) \\n                \\n                for child in dequeuedItem.children:  \\n                    queue.append(child)\\n            \\n            result.append(levelNodes) \\n\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Go",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\nfunc levelOrder(root *Node) [][]int {\\n    var result [][]int\\n    \\n    if root == nil { \\n        return result \\n    }\\n    \\n    var queue []*Node\\n    queue = append(queue, root)\\n    \\n    for len(queue) > 0 {\\n        length := len(queue)\\n        \\n        var levelNodes []int\\n        \\n        for i := 0; i < length; i++ {\\n            levelNodes = append(levelNodes, queue[i].Val)\\n            \\n            for _, child := range queue[i].Children {\\n                if child != nil {\\n                    queue = append(queue, child)\\n                }\\n            }\\n        }\\n        \\n        result = append(result, levelNodes)\\n        \\n        if len(queue) == length {\\n            break\\n        }\\n        \\n        queue = queue[length:]\\n    }\\n\\n    return result\\n}\\n\\n```\n```\\nclass Solution {\\npublic:\\n  vector<vector<int>> levelOrder(Node* root) {\\n    vector<vector<int>> result;\\n\\n    if (!root) {\\n        return result;\\n    }\\n      \\n    queue <Node *> q;\\n    q.push(root);\\n\\n    while(!q.empty()) {\\n        int size = q.size();\\n        vector<int> levelNodes;\\n\\n        while(size--) {      \\n            levelNodes.push_back(q.front()->val);\\n            \\n            for (int j = 0; j != q.front()->children.size(); j++) {\\n                q.push(q.front()->children[j]);\\n            }\\n            \\n            q.pop();\\n        }\\n        \\n        result.push_back(levelNodes);\\n    }\\n      \\n    return result;       \\n  }\\n};\\n```\n```\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        result = []\\n        \\n        if root is None:\\n            return result\\n        \\n        queue = collections.deque()\\n        queue.append(root)\\n        \\n        while queue:\\n            length = len(queue)\\n            levelNodes = [] \\n            \\n            for i in range(length):\\n                dequeuedItem = queue.popleft()\\n                \\n                levelNodes.append(dequeuedItem.val) \\n                \\n                for child in dequeuedItem.children:  \\n                    queue.append(child)\\n            \\n            result.append(levelNodes) \\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2518288,
                "title": "c-dfs-code-100-fast-in-c-submissions",
                "content": "![image](https://assets.leetcode.com/users/images/a5282661-b3c7-4cd6-a922-2b792ce57942_1662110411.3940887.png)\\n```\\nvoid dfs_search(struct Node* root, int depth, int *size, int** arr,int **returnColumnSizes)\\n{\\n    int i;\\n    if(root==NULL) return ;\\n    \\n    if(depth>=(*size)) // when we encounter a new level we allocate the space for it\\n      {  \\n        arr[*size]=malloc(sizeof(int)*10001);\\n        (*returnColumnSizes)[*size]=0;\\n        (*size)++;    // updating the new size of no. of levels\\n      }\\n    arr[depth][(*returnColumnSizes)[depth]]=root->val;\\n    (*returnColumnSizes)[depth]++;\\n    \\n    for(i=0;i<root->numChildren;i++)\\n        dfs_search (root->children[i],depth+1,size,arr,returnColumnSizes);\\n    \\n}\\n\\nint** levelOrder(struct Node* root, int* returnSize, int** returnColumnSizes)\\n{\\n    int **arr;\\n    \\n    arr=malloc(sizeof(int*)*1001);\\n    (*returnColumnSizes)=malloc(sizeof(int)*1001);\\n    *returnSize=0;\\n    dfs_search(root,0,returnSize,arr,returnColumnSizes);\\n    return arr;\\n}\\n\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvoid dfs_search(struct Node* root, int depth, int *size, int** arr,int **returnColumnSizes)\\n{\\n    int i;\\n    if(root==NULL) return ;\\n    \\n    if(depth>=(*size)) // when we encounter a new level we allocate the space for it\\n      {  \\n        arr[*size]=malloc(sizeof(int)*10001);\\n        (*returnColumnSizes)[*size]=0;\\n        (*size)++;    // updating the new size of no. of levels\\n      }\\n    arr[depth][(*returnColumnSizes)[depth]]=root->val;\\n    (*returnColumnSizes)[depth]++;\\n    \\n    for(i=0;i<root->numChildren;i++)\\n        dfs_search (root->children[i],depth+1,size,arr,returnColumnSizes);\\n    \\n}\\n\\nint** levelOrder(struct Node* root, int* returnSize, int** returnColumnSizes)\\n{\\n    int **arr;\\n    \\n    arr=malloc(sizeof(int*)*1001);\\n    (*returnColumnSizes)=malloc(sizeof(int)*1001);\\n    *returnSize=0;\\n    dfs_search(root,0,returnSize,arr,returnColumnSizes);\\n    return arr;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1464859,
                "title": "c-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        \\n        vector<vector<int>> ans;\\n        \\n\\t\\t// If root is empty/null\\n        if(!root)\\n            return ans;\\n        \\n        queue<Node*> q;\\n        q.push(root);\\n        \\n        while(!q.empty()){\\n                        \\n            vector<int> add;\\n            int size = q.size();\\n            \\n            for(int idx = 0; idx < size; idx++){\\n                add.push_back(q.front()->val);\\n                \\n                Node* temp = q.front();\\n                q.pop();\\n                \\n                for(Node* child : temp->children)\\n                q.push(child);\\n            }\\n            ans.push_back(add);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        \\n        vector<vector<int>> ans;\\n        \\n\\t\\t// If root is empty/null\\n        if(!root)\\n            return ans;\\n        \\n        queue<Node*> q;\\n        q.push(root);\\n        \\n        while(!q.empty()){\\n                        \\n            vector<int> add;\\n            int size = q.size();\\n            \\n            for(int idx = 0; idx < size; idx++){\\n                add.push_back(q.front()->val);\\n                \\n                Node* temp = q.front();\\n                q.pop();\\n                \\n                for(Node* child : temp->children)\\n                q.push(child);\\n            }\\n            ans.push_back(add);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1387554,
                "title": "go-iterative-bfs-solution-beats-100",
                "content": "```\\nfunc levelOrder(root *Node) [][]int {\\n\\tif root == nil {\\n\\t\\treturn [][]int{}\\n\\t}\\n\\n\\tvar result [][]int\\n\\tqueue := []*Node{root}\\n\\n\\tfor len(queue) > 0 {\\n\\t\\tvar level []int\\n\\t\\tfor _, node := range queue {\\n\\t\\t\\tqueue = queue[1:]\\n\\t\\t\\tlevel = append(level, node.Val)\\n\\t\\t\\tqueue = append(queue, node.Children...)\\n\\t\\t}\\n\\t\\tresult = append(result, level)\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```\\nfunc levelOrder(root *Node) [][]int {\\n\\tif root == nil {\\n\\t\\treturn [][]int{}\\n\\t}\\n\\n\\tvar result [][]int\\n\\tqueue := []*Node{root}\\n\\n\\tfor len(queue) > 0 {\\n\\t\\tvar level []int\\n\\t\\tfor _, node := range queue {\\n\\t\\t\\tqueue = queue[1:]\\n\\t\\t\\tlevel = append(level, node.Val)\\n\\t\\t\\tqueue = append(queue, node.Children...)\\n\\t\\t}\\n\\t\\tresult = append(result, level)\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1387271,
                "title": "simple-c-solution-using-queue-beats-86",
                "content": "```\\nvector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> a;\\n        vector<int> b;\\n        if (root == NULL) {\\n            return a;\\n        }\\n        queue<Node*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        while(!q.empty()) {\\n            Node* node = q.front();\\n            q.pop();\\n            if (node != NULL) {\\n                b.push_back(node->val);\\n                for (int i=0; i<node->children.size(); i++) {\\n                    if (node->children[i] != NULL) {\\n                        q.push(node->children[i]);\\n                    }\\n                }\\n            }\\n            else if (!q.empty()) {\\n                q.push(NULL);\\n                a.push_back(b);\\n                b.clear();\\n            }\\n        }\\n        a.push_back(b);\\n        return a;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nvector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> a;\\n        vector<int> b;\\n        if (root == NULL) {\\n            return a;\\n        }\\n        queue<Node*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        while(!q.empty()) {\\n            Node* node = q.front();\\n            q.pop();\\n            if (node != NULL) {\\n                b.push_back(node->val);\\n                for (int i=0; i<node->children.size(); i++) {\\n                    if (node->children[i] != NULL) {\\n                        q.push(node->children[i]);\\n                    }\\n                }\\n            }\\n            else if (!q.empty()) {\\n                q.push(NULL);\\n                a.push_back(b);\\n                b.clear();\\n            }\\n        }\\n        a.push_back(b);\\n        return a;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1387160,
                "title": "c-bfs-using-queue-iterative",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        \\n        vector<vector<int>> res;\\n        queue<Node*> q;\\n        \\n        if(root)\\n            q.push(root);\\n        else\\n            return res;\\n        \\n        int level;\\n        while(!q.empty()){\\n            vector<int> temp;\\n            level = q.size();\\n            while(level--){\\n                Node* node = q.front();\\n                q.pop();\\n                temp.push_back(node->val);\\n                for(auto x : node->children){\\n                    q.push(x);\\n                }\\n            }\\n            res.push_back(temp);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        \\n        vector<vector<int>> res;\\n        queue<Node*> q;\\n        \\n        if(root)\\n            q.push(root);\\n        else\\n            return res;\\n        \\n        int level;\\n        while(!q.empty()){\\n            vector<int> temp;\\n            level = q.size();\\n            while(level--){\\n                Node* node = q.front();\\n                q.pop();\\n                temp.push_back(node->val);\\n                for(auto x : node->children){\\n                    q.push(x);\\n                }\\n            }\\n            res.push_back(temp);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1386784,
                "title": "standard-queue-like-normal-tree-100-40",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        queue<Node*>q;\\n        q.push(root);\\n        vector<vector<int>>r;\\n        if(root==NULL)return r;\\n        while(q.size())\\n        {vector<int>h;\\n            for(int i=0,n=q.size();i<n;i++)\\n            {\\n                auto temp=q.front();\\n                h.push_back(temp->val);\\n                q.pop();\\n                auto nums=temp->children;\\n                for(int j=0;j<nums.size();j++)\\n                {\\n                    q.push(nums[j]);\\n                }\\n                \\n            }\\n         r.push_back(h);\\n        }\\n    return r;}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        queue<Node*>q;\\n        q.push(root);\\n        vector<vector<int>>r;\\n        if(root==NULL)return r;\\n        while(q.size())\\n        {vector<int>h;\\n            for(int i=0,n=q.size();i<n;i++)\\n            {\\n                auto temp=q.front();\\n                h.push_back(temp->val);\\n                q.pop();\\n                auto nums=temp->children;\\n                for(int j=0;j<nums.size();j++)\\n                {\\n                    q.push(nums[j]);\\n                }\\n                \\n            }\\n         r.push_back(h);\\n        }\\n    return r;}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1386734,
                "title": "c-standard-bfs-like-normal-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        if(!root) return {};\\n        vector<vector<int>> result;\\n        queue<Node*> que;\\n        que.push(root);\\n        \\n        while(!que.empty()) {\\n            int n = que.size();\\n            vector<int> levelNodes;\\n            while(n--) {\\n                Node* curr = que.front();\\n                que.pop();\\n                levelNodes.push_back(curr->val);\\n                \\n                for(Node* node : curr->children) {\\n                    que.push(node);\\n                }\\n            }\\n            result.push_back(std::move(levelNodes));\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        if(!root) return {};\\n        vector<vector<int>> result;\\n        queue<Node*> que;\\n        que.push(root);\\n        \\n        while(!que.empty()) {\\n            int n = que.size();\\n            vector<int> levelNodes;\\n            while(n--) {\\n                Node* curr = que.front();\\n                que.pop();\\n                levelNodes.push_back(curr->val);\\n                \\n                for(Node* node : curr->children) {\\n                    que.push(node);\\n                }\\n            }\\n            result.push_back(std::move(levelNodes));\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 744830,
                "title": "scala-solution",
                "content": "```\\n/**\\n * Definition for a Node.\\n * class Node(var _value: Int) {\\n *   var value: Int = _value\\n *   var children: List[Node] = List()\\n * }\\n */\\n\\nobject Solution {\\n    def levelOrder(root: Node): List[List[Int]] = {\\n\\t   @annotation.tailrec\\n        def levelTraversal(listNodes: List[Node], values: List[List[Int]]): List[List[Int]] = {\\n            if(listNodes.isEmpty) values\\n            else {\\n                val levelValue = listNodes.map(node => node.value)\\n                val nextLevel = listNodes.foldLeft(List.empty[Node]){ (res, node) =>\\n                    res ++ node.children\\n                }\\n                levelTraversal(nextLevel, levelValue :: values)\\n            }\\n        }\\n        \\n        val initList = Option(root).fold(List.empty[Node])(_ :: List.empty[Node])\\n        levelTraversal(initList, List.empty[List[Int]]).reverse    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a Node.\\n * class Node(var _value: Int) {\\n *   var value: Int = _value\\n *   var children: List[Node] = List()\\n * }\\n */\\n\\nobject Solution {\\n    def levelOrder(root: Node): List[List[Int]] = {\\n\\t   @annotation.tailrec\\n        def levelTraversal(listNodes: List[Node], values: List[List[Int]]): List[List[Int]] = {\\n            if(listNodes.isEmpty) values\\n            else {\\n                val levelValue = listNodes.map(node => node.value)\\n                val nextLevel = listNodes.foldLeft(List.empty[Node]){ (res, node) =>\\n                    res ++ node.children\\n                }\\n                levelTraversal(nextLevel, levelValue :: values)\\n            }\\n        }\\n        \\n        val initList = Option(root).fold(List.empty[Node])(_ :: List.empty[Node])\\n        levelTraversal(initList, List.empty[List[Int]]).reverse    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 673557,
                "title": "ruby-solution-using-ruby-idioms",
                "content": "This performs a typical BFS traversal using a queue. The outer loop executes once per level. Hence, the queue can be replaced entirely at the end of each iteration of outer loop.\\n\\nThe code may be practically optimized further by combining the two inner loops: the one that _visits_ each node, and the one that populates the next queue.\\n\\n```ruby\\n# Definition for a Node.\\n# class Node\\n#     attr_accessor :val, :children\\n#     def initialize(val)\\n#         @val = val\\n#         @children = []\\n#     end\\n# end\\n\\n# @param [Node] root\\n# @return [Array<Array<Integer>>]\\ndef levelOrder(root)\\n  [].tap do |arr|\\n    queue = Array(root)\\n    until queue.empty?\\n      arr << queue.map(&:val)\\n      queue = queue.flat_map(&:children)\\n    end\\n  end\\nend\\n```\\n\\n**Time Complexity**: `O(n)` where `n` is the total number of nodes.\\n**Space Complexity**: `O(n)`",
                "solutionTags": [
                    "Ruby",
                    "Breadth-First Search"
                ],
                "code": "```ruby\\n# Definition for a Node.\\n# class Node\\n#     attr_accessor :val, :children\\n#     def initialize(val)\\n#         @val = val\\n#         @children = []\\n#     end\\n# end\\n\\n# @param [Node] root\\n# @return [Array<Array<Integer>>]\\ndef levelOrder(root)\\n  [].tap do |arr|\\n    queue = Array(root)\\n    until queue.empty?\\n      arr << queue.map(&:val)\\n      queue = queue.flat_map(&:children)\\n    end\\n  end\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 442962,
                "title": "python-99-65-100-36ms",
                "content": "\\'\\'\\'\\n\\n        if not root:\\n            return []\\n        emp = []\\n        tmp = deque()\\n        tmp.append(root)\\n        while tmp:\\n            l2 = []\\n            l1 = len(tmp)\\n            for i in range(l1):\\n                node = tmp.popleft()\\n                l2.append(node.val)\\n                if node.children:\\n                    for i in node.children:\\n                        tmp.append(i)\\n            emp.append(l2)\\n            \\n                    \\n            \\n        return(emp)",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\'\\'\\'\\n\\n        if not root:\\n            return []\\n        emp = []\\n        tmp = deque()\\n        tmp.append(root)\\n        while tmp:\\n            l2 = []\\n            l1 = len(tmp)\\n            for i in range(l1):\\n                node = tmp.popleft()\\n                l2.append(node.val)\\n                if node.children:\\n                    for i in node.children:\\n                        tmp.append(i)\\n            emp.append(l2)\\n            \\n                    \\n            \\n        return(emp)",
                "codeTag": "Unknown"
            },
            {
                "id": 334810,
                "title": "c-bfs",
                "content": "```\\npublic class Solution {\\n    public IList<IList<int>> LevelOrder(Node root) {\\n        var result = new List<IList<int>>();\\n        if (root == null) return result;\\n\\n        var queue = new Queue<Node>();\\n        queue.Enqueue(root);\\n\\n        while (queue.Any()) {\\n            var size = queue.Count;\\n\\n            var tempList = new List<int>();\\n            for (int s = 0; s < size; s++) {\\n                var cur = queue.Dequeue();\\n                tempList.Add(cur.val);\\n\\n                foreach (var child in cur.children) {\\n                    queue.Enqueue(child);\\n                }\\n            }\\n            result.Add(tempList);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> LevelOrder(Node root) {\\n        var result = new List<IList<int>>();\\n        if (root == null) return result;\\n\\n        var queue = new Queue<Node>();\\n        queue.Enqueue(root);\\n\\n        while (queue.Any()) {\\n            var size = queue.Count;\\n\\n            var tempList = new List<int>();\\n            for (int s = 0; s < size; s++) {\\n                var cur = queue.Dequeue();\\n                tempList.Add(cur.val);\\n\\n                foreach (var child in cur.children) {\\n                    queue.Enqueue(child);\\n                }\\n            }\\n            result.Add(tempList);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 261940,
                "title": "c-100-faster-328ms",
                "content": "```\\npublic class Solution {\\n    IList<IList<int>> result = new List<IList<int>>();\\n    public IList<IList<int>> LevelOrder(Node root) {\\n        traverseLevelOrder(root, 0);\\n        return result;\\n    }\\n    \\n    public void traverseLevelOrder(Node root, int level){\\n        if(root == null)\\n            return;\\n        if(result.Count <= level)\\n            result.Add(new List<int>());\\n        result[level].Add(root.val);\\n        foreach(var child in root.children)\\n            traverseLevelOrder(child, level + 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    IList<IList<int>> result = new List<IList<int>>();\\n    public IList<IList<int>> LevelOrder(Node root) {\\n        traverseLevelOrder(root, 0);\\n        return result;\\n    }\\n    \\n    public void traverseLevelOrder(Node root, int level){\\n        if(root == null)\\n            return;\\n        if(result.Count <= level)\\n            result.Add(new List<int>());\\n        result[level].Add(root.val);\\n        foreach(var child in root.children)\\n            traverseLevelOrder(child, level + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535435,
                "title": "429-n-ary-tree-level-order-traversal-java",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n        List<List<Integer>> ans=new ArrayList<>();\\n        if(root==null)\\n            return ans; \\n        Queue<Node> q=new LinkedList();\\n        q.offer(root);\\n        while(!q.isEmpty())\\n        {\\n            int n=q.size();\\n            List<Integer> help=new ArrayList();\\n            for(int i=0;i<n;i++)\\n            {\\n                Node temp=q.poll();\\n                for(Node child:temp.children)\\n                    q.offer(child);\\n                help.add(temp.val);\\n            }\\n            ans.add(help);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n        List<List<Integer>> ans=new ArrayList<>();\\n        if(root==null)\\n            return ans; \\n        Queue<Node> q=new LinkedList();\\n        q.offer(root);\\n        while(!q.isEmpty())\\n        {\\n            int n=q.size();\\n            List<Integer> help=new ArrayList();\\n            for(int i=0;i<n;i++)\\n            {\\n                Node temp=q.poll();\\n                for(Node child:temp.children)\\n                    q.offer(child);\\n                help.add(temp.val);\\n            }\\n            ans.add(help);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359673,
                "title": "simplest-python-code-just-do-level-order",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        a = []\\n\\n        def dfs(node, h):\\n            if not node: return\\n            if len(a) == h: a.append([])\\n\\n            a[h].append(node.val)\\n\\n            for child in node.children:\\n                dfs(child, h+1)\\n\\n        dfs(root, 0)\\n\\n        return a\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        a = []\\n\\n        def dfs(node, h):\\n            if not node: return\\n            if len(a) == h: a.append([])\\n\\n            a[h].append(node.val)\\n\\n            for child in node.children:\\n                dfs(child, h+1)\\n\\n        dfs(root, 0)\\n\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352284,
                "title": "c-iterative-bfs-easy-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> ans ; \\n        if (root == NULL)\\n        {\\n            return ans ; \\n        }\\n\\n        queue<Node*> q ; \\n        q.push(root) ; \\n        while (!q.empty())\\n        {\\n            int size = q.size() ;\\n            vector<int> level ; \\n            while (size --)\\n            {\\n                Node *temp = q.front() ;\\n                q.pop() ; \\n                level.push_back(temp -> val) ;\\n\\n                for (auto child : temp -> children)\\n                {\\n                    q.push(child) ; \\n                }\\n            }\\n            ans.push_back(level) ; \\n        }\\n        return ans ; \\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/7c2e02cf-d8e1-4f15-81eb-0cfe9a92d201_1680021327.119486.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```C++ []\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> ans ; \\n        if (root == NULL)\\n        {\\n            return ans ; \\n        }\\n\\n        queue<Node*> q ; \\n        q.push(root) ; \\n        while (!q.empty())\\n        {\\n            int size = q.size() ;\\n            vector<int> level ; \\n            while (size --)\\n            {\\n                Node *temp = q.front() ;\\n                q.pop() ; \\n                level.push_back(temp -> val) ;\\n\\n                for (auto child : temp -> children)\\n                {\\n                    q.push(child) ; \\n                }\\n            }\\n            ans.push_back(level) ; \\n        }\\n        return ans ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269749,
                "title": "429-space-92-13-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. We start by checking if the input root is empty. If it is, we return an empty list.\\n```\\n        if not root:\\n            return []\\n```\\n2. We initialize two lists, result and level. result will store the final level order traversal of the nodes\\' values, and level will store the current level of nodes we are traversing.\\n```\\n        result = []\\n        level = [root]\\n```\\n3. We enter a loop that will continue as long as there are nodes in level. At each iteration, we will add the values of the nodes in the current level to result, and add their children to next_level for the next iteration.\\n```\\n        while level:\\n            current_level = []\\n            next_level = []\\n            \\n            for node in level:\\n                current_level.append(node.val)\\n                next_level += node.children\\n                \\n            result.append(current_level)\\n            level = next_level\\n``` \\n4. Inside the loop, we initialize an empty list current_level to store the values of the nodes in the current level, and another empty list next_level to store the children of the nodes in the current level for the next iteration.\\n\\n5. We iterate over each node in level, append its value to current_level, and add its children to next_level.\\n\\n6. After iterating over all nodes in level, we append current_level to result.\\n\\n7. Finally, we update level to be next_level, which will contain all the children of the nodes in the current level for the next iteration.\\n\\n8. Once the loop has completed, we have successfully traversed all levels of the tree and stored the values of the nodes in result. We simply return result as the final output.\\n```\\n        return result\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        if not root:\\n            return []\\n        \\n        result = []\\n        level = [root]\\n        \\n        while level:\\n            current_level = []\\n            next_level = []\\n            \\n            for node in level:\\n                current_level.append(node.val)\\n                next_level += node.children\\n                \\n            result.append(current_level)\\n            level = next_level\\n        \\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n        if not root:\\n            return []\\n```\n```\\n        result = []\\n        level = [root]\\n```\n```\\n        while level:\\n            current_level = []\\n            next_level = []\\n            \\n            for node in level:\\n                current_level.append(node.val)\\n                next_level += node.children\\n                \\n            result.append(current_level)\\n            level = next_level\\n```\n```\\n        return result\\n```\n```\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        if not root:\\n            return []\\n        \\n        result = []\\n        level = [root]\\n        \\n        while level:\\n            current_level = []\\n            next_level = []\\n            \\n            for node in level:\\n                current_level.append(node.val)\\n                next_level += node.children\\n                \\n            result.append(current_level)\\n            level = next_level\\n        \\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194526,
                "title": "c-easy-and-fast-solution",
                "content": "# Intuition\\nThe level-order traversal could be recursively by pushing each level of the tree.\\n\\n# Approach\\nUse simple bfs with implementation of a stack of nodes.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    void levelOrderTraversal(Node* root,vector<int> &row,vector<vector<int> > &v){\\n    queue<Node*> q;\\n    q.push(root);\\n    q.push(NULL);\\n    while(!q.empty()){\\n        Node* temp= q.front();\\n        q.pop();\\n        if(temp==NULL){//previous level has been traversed\\n        v.push_back(row);\\n            row.clear();\\n        if(!q.empty()){//queue still has some child nodes\\n        q.push(NULL);\\n        }\\n        }\\n        else\\n        {\\n            row.push_back(temp->val);\\n            for(auto child:temp->children){\\n            if(child){\\n            q.push(child);\\n        }\\n        }\\n        }\\n    }\\n    }\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int> > v;\\n        vector<int> row;\\n        if(root==NULL)\\n            return v;\\n        levelOrderTraversal(root,row,v);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    void levelOrderTraversal(Node* root,vector<int> &row,vector<vector<int> > &v){\\n    queue<Node*> q;\\n    q.push(root);\\n    q.push(NULL);\\n    while(!q.empty()){\\n        Node* temp= q.front();\\n        q.pop();\\n        if(temp==NULL){//previous level has been traversed\\n        v.push_back(row);\\n            row.clear();\\n        if(!q.empty()){//queue still has some child nodes\\n        q.push(NULL);\\n        }\\n        }\\n        else\\n        {\\n            row.push_back(temp->val);\\n            for(auto child:temp->children){\\n            if(child){\\n            q.push(child);\\n        }\\n        }\\n        }\\n    }\\n    }\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int> > v;\\n        vector<int> row;\\n        if(root==NULL)\\n            return v;\\n        levelOrderTraversal(root,row,v);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104827,
                "title": "java-3ms",
                "content": "\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\n\\n\\n\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n           ArrayList<List<Integer>> ans=new ArrayList<>();\\n        Queue<Node> q = new LinkedList<>();\\n        \\n        if(root == null) return ans;\\n        q.offer(root);\\n\\n        while(!q.isEmpty()){\\n            ArrayList<Integer> list=new ArrayList<>();\\n            int size = q.size();\\n            for(int i=0;i<size;i++){\\n                Node cur=q.poll();\\n\\n                list.add(cur.val);\\n\\n                for (Node c : cur.children)\\n                    q.offer(c);\\n            }\\n            ans.add(list);\\n        }\\n        return ans;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\n\\n\\n\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n           ArrayList<List<Integer>> ans=new ArrayList<>();\\n        Queue<Node> q = new LinkedList<>();\\n        \\n        if(root == null) return ans;\\n        q.offer(root);\\n\\n        while(!q.isEmpty()){\\n            ArrayList<Integer> list=new ArrayList<>();\\n            int size = q.size();\\n            for(int i=0;i<size;i++){\\n                Node cur=q.poll();\\n\\n                list.add(cur.val);\\n\\n                for (Node c : cur.children)\\n                    q.offer(c);\\n            }\\n            ans.add(list);\\n        }\\n        return ans;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952631,
                "title": "easy-simple-c-solution-bfs-using-queue",
                "content": "## Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> ans;\\n        if (root==NULL)return ans;\\n        queue<Node*> q;\\n        q.push(root);\\n        while (!q.empty()){\\n            int sz= q.size();\\n            vector<int> lvl;\\n            for (int i=0; i<sz; i++){\\n                Node* element= q.front();\\n                q.pop();\\n                lvl.push_back(element->val);\\n                for (auto val: element->children){\\n                    q.push(val);\\n                }\\n            }\\n            ans.push_back(lvl);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Tree",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> ans;\\n        if (root==NULL)return ans;\\n        queue<Node*> q;\\n        q.push(root);\\n        while (!q.empty()){\\n            int sz= q.size();\\n            vector<int> lvl;\\n            for (int i=0; i<sz; i++){\\n                Node* element= q.front();\\n                q.pop();\\n                lvl.push_back(element->val);\\n                for (auto val: element->children){\\n                    q.push(val);\\n                }\\n            }\\n            ans.push_back(lvl);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2535979,
                "title": "java-easy-bfs",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n        \\n        Queue<Node> q= new ArrayDeque<>();\\n        \\n        List<List<Integer>> ans=new ArrayList<>();\\n        if(root==null)return ans;\\n        q.offer(root);\\n        List<Integer> list;\\n        while(q.size()>0)\\n        {\\n          list=new ArrayList<>();  \\n            int sz=q.size();\\n            for(int i=0;i<sz;i++){\\n                Node temp = q.poll();\\n                list.add(temp.val);\\n                for (Node c : temp.children)\\n                    q.offer(c);\\n            }\\n            ans.add(list);\\n            \\n        }   \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n        \\n        Queue<Node> q= new ArrayDeque<>();\\n        \\n        List<List<Integer>> ans=new ArrayList<>();\\n        if(root==null)return ans;\\n        q.offer(root);\\n        List<Integer> list;\\n        while(q.size()>0)\\n        {\\n          list=new ArrayList<>();  \\n            int sz=q.size();\\n            for(int i=0;i<sz;i++){\\n                Node temp = q.poll();\\n                list.add(temp.val);\\n                for (Node c : temp.children)\\n                    q.offer(c);\\n            }\\n            ans.add(list);\\n            \\n        }   \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2535182,
                "title": "easy-js-javascript-code-15-code-lines-written",
                "content": "every line is commented and self explaining with comment\\nplease upvote the solution.\\nThank you\\n\\n\\n```\\n/**\\n * // Definition for a Node.\\n * function Node(val,children) {\\n *    this.val = val;\\n *    this.children = children;\\n * };\\n */\\n\\n/**\\n * @param {Node|null} root\\n * @return {number[][]}\\n */\\n\\n//Array to store our final result\\nlet result=[];\\nvar levelOrder = function(root) {\\n    //reset final output variable to use it for multiple testcases\\n    result=[];\\n    \\n    //call to the recursive function to solve the tree\\n    recursiveTraversal(root,0);\\n    \\n    //return the result\\n    return result;\\n};\\n\\nfunction recursiveTraversal(root,level){\\n    //base case if current node is empty\\n    if(root===null)\\n        return;\\n    \\n    //if we have value already on this level or not\\n    if(result[level])\\n        //if we have value then it must be a Array then push the value into the array\\n        result[level].push(root.val);\\n    else\\n        //first time on this level so put a new Array with the current node value it it\\n        result[level]=[root.val];\\n    \\n    //looping to call all the children of the current node which is avaiable\\n    for(let i=0;i<root.children.length;i++){\\n        \\n        //recusive call for all the children with increasing the level by 1 value\\n        recursiveTraversal(root.children[i],level+1);\\n    }\\n    \\n    return;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * // Definition for a Node.\\n * function Node(val,children) {\\n *    this.val = val;\\n *    this.children = children;\\n * };\\n */\\n\\n/**\\n * @param {Node|null} root\\n * @return {number[][]}\\n */\\n\\n//Array to store our final result\\nlet result=[];\\nvar levelOrder = function(root) {\\n    //reset final output variable to use it for multiple testcases\\n    result=[];\\n    \\n    //call to the recursive function to solve the tree\\n    recursiveTraversal(root,0);\\n    \\n    //return the result\\n    return result;\\n};\\n\\nfunction recursiveTraversal(root,level){\\n    //base case if current node is empty\\n    if(root===null)\\n        return;\\n    \\n    //if we have value already on this level or not\\n    if(result[level])\\n        //if we have value then it must be a Array then push the value into the array\\n        result[level].push(root.val);\\n    else\\n        //first time on this level so put a new Array with the current node value it it\\n        result[level]=[root.val];\\n    \\n    //looping to call all the children of the current node which is avaiable\\n    for(let i=0;i<root.children.length;i++){\\n        \\n        //recusive call for all the children with increasing the level by 1 value\\n        recursiveTraversal(root.children[i],level+1);\\n    }\\n    \\n    return;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2533821,
                "title": "c-easy-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> ans;\\n        if(root == NULL) return ans;\\n        queue<Node*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size = q.size();\\n            vector<int> temp;\\n            for(int i=0;i<size;i++){\\n                Node* front = q.front();\\n                q.pop();\\n                for(auto child:front->children) q.push(child);\\n                temp.push_back(front->val);\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> ans;\\n        if(root == NULL) return ans;\\n        queue<Node*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size = q.size();\\n            vector<int> temp;\\n            for(int i=0;i<size;i++){\\n                Node* front = q.front();\\n                q.pop();\\n                for(auto child:front->children) q.push(child);\\n                temp.push_back(front->val);\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2533783,
                "title": "java-easy-dfs-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        levelOrder(root, res, 1);\\n        return res;\\n    }\\n    \\n    public void levelOrder(Node root, List<List<Integer>> res, int level){\\n        if (root!=null){\\n            while (res.size()<level) res.add(new ArrayList<>());\\n            res.get(level-1).add(root.val);\\n            if (root.children!=null){\\n                for (Node child:root.children) levelOrder(child, res, level+1);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        levelOrder(root, res, 1);\\n        return res;\\n    }\\n    \\n    public void levelOrder(Node root, List<List<Integer>> res, int level){\\n        if (root!=null){\\n            while (res.size()<level) res.add(new ArrayList<>());\\n            res.get(level-1).add(root.val);\\n            if (root.children!=null){\\n                for (Node child:root.children) levelOrder(child, res, level+1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2533492,
                "title": "python-elegant-short-bfs-dfs-generators",
                "content": "# BFS solution\\n\\n\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n)\\n\\t\\tMemory: O(n)\\n\\t\\t\"\"\"\\n\\n\\t\\tdef levelOrder(self, root: Optional[\\'Node\\']) -> List[List[int]]:\\n\\t\\t\\tif root is None:\\n\\t\\t\\t\\treturn []\\n\\n\\t\\t\\tqueue = deque([root])\\n\\t\\t\\tlevels = []\\n\\n\\t\\t\\twhile queue:\\n\\t\\t\\t\\tlevels.append([])\\n\\t\\t\\t\\tfor _ in range(len(queue)):\\n\\t\\t\\t\\t\\tnode = queue.popleft()\\n\\t\\t\\t\\t\\tlevels[-1].append(node.val)\\n\\t\\t\\t\\t\\tqueue.extend(node.children)\\n\\n\\t\\t\\treturn levels\\n# DFS solution\\n\\n\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n)\\n\\t\\tMemory: O(n)\\n\\t\\t\"\"\"\\n\\n\\t\\tdef levelOrder(self, root: Optional[\\'Node\\']) -> List[List[int]]:\\n\\t\\t\\tlevels = defaultdict(list)\\n\\n\\t\\t\\tfor node, depth in self._walk(root):\\n\\t\\t\\t\\tlevels[depth].append(node.val)\\n\\n\\t\\t\\treturn [levels[d] for d in sorted(levels)]\\n\\n\\t\\t@classmethod\\n\\t\\tdef _walk(cls, root: Optional[\\'Node\\'], depth: int = 0) -> Generator:\\n\\t\\t\\tif root is None:\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\tyield root, depth\\n\\t\\t\\tfor child in root.children:\\n\\t\\t\\t\\tyield from cls._walk(child, depth + 1)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "# BFS solution\\n\\n\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n)\\n\\t\\tMemory: O(n)\\n\\t\\t\"\"\"\\n\\n\\t\\tdef levelOrder(self, root: Optional[\\'Node\\']) -> List[List[int]]:\\n\\t\\t\\tif root is None:\\n\\t\\t\\t\\treturn []\\n\\n\\t\\t\\tqueue = deque([root])\\n\\t\\t\\tlevels = []\\n\\n\\t\\t\\twhile queue:\\n\\t\\t\\t\\tlevels.append([])\\n\\t\\t\\t\\tfor _ in range(len(queue)):\\n\\t\\t\\t\\t\\tnode = queue.popleft()\\n\\t\\t\\t\\t\\tlevels[-1].append(node.val)\\n\\t\\t\\t\\t\\tqueue.extend(node.children)\\n\\n\\t\\t\\treturn levels\\n# DFS solution\\n\\n\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n)\\n\\t\\tMemory: O(n)\\n\\t\\t\"\"\"\\n\\n\\t\\tdef levelOrder(self, root: Optional[\\'Node\\']) -> List[List[int]]:\\n\\t\\t\\tlevels = defaultdict(list)\\n\\n\\t\\t\\tfor node, depth in self._walk(root):\\n\\t\\t\\t\\tlevels[depth].append(node.val)\\n\\n\\t\\t\\treturn [levels[d] for d in sorted(levels)]\\n\\n\\t\\t@classmethod\\n\\t\\tdef _walk(cls, root: Optional[\\'Node\\'], depth: int = 0) -> Generator:\\n\\t\\t\\tif root is None:\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\tyield root, depth\\n\\t\\t\\tfor child in root.children:\\n\\t\\t\\t\\tyield from cls._walk(child, depth + 1)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2533280,
                "title": "easy-solution-n-ary-tree-level-order-traversal",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        if(!root)\\n            return {};\\n        \\n        \\n        vector<vector<int>>ans;\\n        queue<Node*>q;\\n        q.push(root);\\n        \\n        \\n        while(!q.empty()){ \\n            vector<int>v;\\n            int n=q.size();\\n            for(int i=0; i<n; i++){\\n                root=q.front();\\n                q.pop();\\n                v.push_back(root->val);\\n                for(auto node :root->children){\\n                    q.push(node);\\n                }\\n            }\\n          ans.push_back(v);\\n\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        if(!root)\\n            return {}",
                "codeTag": "Java"
            },
            {
                "id": 2532758,
                "title": "c-easy-bfs-solution-using-queue",
                "content": "## Please Upvote if Helpful\\n\\n**Approach:**\\n* First store the root node.\\n* Traverse its children, if any, start popping out elements from queue\\'s front and store all the children in the queue as well as in the vector of answer.\\n* Observe the code, it\\'s Easy BFS.\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        if(root==NULL)\\n            return {};\\n        vector<vector<int>>ans;\\n        queue<Node*> tree;\\n        tree.push(root);\\n        ans.push_back({root->val});\\n        while(!tree.empty())\\n        {\\n            int n=tree.size();\\n            vector<int>vec;\\n            while(n--)\\n            {\\n            Node* cur=tree.front(); // storing the current node\\n            tree.pop();\\n                for(int i=0;i<cur->children.size();i++) // traversing the children of current node\\n                {\\n                    tree.push(cur->children[i]); // storing all the children of current node in queue\\n                    vec.push_back(cur->children[i]->val);\\n                }\\n            }\\n            if(vec.size()>0)\\n            ans.push_back(vec);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        if(root==NULL)\\n            return {};\\n        vector<vector<int>>ans;\\n        queue<Node*> tree;\\n        tree.push(root);\\n        ans.push_back({root->val});\\n        while(!tree.empty())\\n        {\\n            int n=tree.size();\\n            vector<int>vec;\\n            while(n--)\\n            {\\n            Node* cur=tree.front(); // storing the current node\\n            tree.pop();\\n                for(int i=0;i<cur->children.size();i++) // traversing the children of current node\\n                {\\n                    tree.push(cur->children[i]); // storing all the children of current node in queue\\n                    vec.push_back(cur->children[i]->val);\\n                }\\n            }\\n            if(vec.size()>0)\\n            ans.push_back(vec);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2532671,
                "title": "bfs-java-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n        List<List<Integer>> nm=new ArrayList<List<Integer>>();\\n        if(root==null)\\n            return nm;\\n        Queue<Node> kk=new LinkedList<>();\\n        kk.offer(root);\\n        while(!kk.isEmpty())\\n        {\\n            int p=kk.size();\\n            ArrayList<Integer> k=new ArrayList<>();\\n            for(int i=0;i<p;i++)\\n            {\\n                k.add(kk.peek().val);\\n                for(Node f:kk.peek().children)\\n                {\\n                    kk.offer(f);\\n                }\\n                kk.poll();\\n            }\\n            nm.add(new ArrayList<>(k));\\n        }\\n        return nm;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n        List<List<Integer>> nm=new ArrayList<List<Integer>>();\\n        if(root==null)\\n            return nm;\\n        Queue<Node> kk=new LinkedList<>();\\n        kk.offer(root);\\n        while(!kk.isEmpty())\\n        {\\n            int p=kk.size();\\n            ArrayList<Integer> k=new ArrayList<>();\\n            for(int i=0;i<p;i++)\\n            {\\n                k.add(kk.peek().val);\\n                for(Node f:kk.peek().children)\\n                {\\n                    kk.offer(f);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2532600,
                "title": "ruby-1-liner",
                "content": "```\\ndef level_order(root, d=0, r=[]) \\n  r.tap{ root and (r[d]||=[]) << root.val and root.children.each{ level_order _1, d+1, r } }\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef level_order(root, d=0, r=[]) \\n  r.tap{ root and (r[d]||=[]) << root.val and root.children.each{ level_order _1, d+1, r } }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2532455,
                "title": "easy-java-solution-5ms-solution-beginner-friendly-with-comments",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```\\npublic List<List<Integer>> levelOrder(Node root) {\\n        Queue<Node> q = new LinkedList<>(); // in bfs we take queue to traverse one level completely\\n        List<List<Integer>> ll = new LinkedList<>();\\n        if (root == null) {\\n            return ll;\\n        }\\n        q.add(root);\\n        while (!q.isEmpty()) {\\n            int n = q.size(); // here n is the level size or number of elements in level\\n            List<Integer> current = new LinkedList<Integer>();\\n            for (int i = 0; i < n; i++) {\\n                Node node = q.poll();\\n                current.add(node.val); // add element value to linkedlist\\n                q.addAll(node.children); // add children to queue to for next level traversal\\n            }\\n            ll.add(current); // add current level list to ll or result linkedlist\\n        }\\n        return ll;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\npublic List<List<Integer>> levelOrder(Node root) {\\n        Queue<Node> q = new LinkedList<>(); // in bfs we take queue to traverse one level completely\\n        List<List<Integer>> ll = new LinkedList<>();\\n        if (root == null) {\\n            return ll;\\n        }\\n        q.add(root);\\n        while (!q.isEmpty()) {\\n            int n = q.size(); // here n is the level size or number of elements in level\\n            List<Integer> current = new LinkedList<Integer>();\\n            for (int i = 0; i < n; i++) {\\n                Node node = q.poll();\\n                current.add(node.val); // add element value to linkedlist\\n                q.addAll(node.children); // add children to queue to for next level traversal\\n            }\\n            ll.add(current); // add current level list to ll or result linkedlist\\n        }\\n        return ll;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2532416,
                "title": "python3-easy-understanding-dictionary-n-ary-tree",
                "content": "```\\n\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        self.d={}\\n        self.trav(root, 0)\\n        return self.d.values()\\n        \\n    def trav(self, root, l):\\n        if root:\\n            if self.d.get(l, False): self.d[l].append(root.val)\\n            else: self.d[l] = [root.val]\\n            for node in root.children: self.trav(node, l+1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        self.d={}\\n        self.trav(root, 0)\\n        return self.d.values()\\n        \\n    def trav(self, root, l):\\n        if root:\\n            if self.d.get(l, False): self.d[l].append(root.val)\\n            else: self.d[l] = [root.val]\\n            for node in root.children: self.trav(node, l+1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2532386,
                "title": "easy-understandable-java-code-bfs-linear-time",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n        Queue<Node> q = new LinkedList<Node>();\\n        Queue<Node> t;\\n        Node node;\\n        List<List<Integer>> list = new ArrayList<List<Integer>>();\\n        List<Integer> ls;\\n        if(root!=null) q.add(root);\\n        while(!q.isEmpty()){\\n            t = new LinkedList<Node>();\\n            ls = new ArrayList<Integer>();\\n            while(!q.isEmpty()){\\n                node = q.poll();\\n                ls.add(node.val);\\n                for(Node child: node.children)\\n                    t.add(child);\\n            }\\n            list.add(ls);\\n            q = t;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n        Queue<Node> q = new LinkedList<Node>();\\n        Queue<Node> t;\\n        Node node;\\n        List<List<Integer>> list = new ArrayList<List<Integer>>();\\n        List<Integer> ls;\\n        if(root!=null) q.add(root);\\n        while(!q.isEmpty()){\\n            t = new LinkedList<Node>();\\n            ls = new ArrayList<Integer>();\\n            while(!q.isEmpty()){\\n                node = q.poll();\\n                ls.add(node.val);\\n                for(Node child: node.children)\\n                    t.add(child);\\n            }\\n            list.add(ls);\\n            q = t;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2532301,
                "title": "simplest-c-solution-beginer-friendly-fully-explained-90-faster",
                "content": "``` \\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> answer;\\n        if(root == nullptr){\\n            return answer;\\n        }\\n        \\n        queue<Node*> q;\\n\\t\\t//standard bfs move to push the first element in the queue\\n        q.push(root);\\n        \\n        Node* current;\\n        while(!q.empty()){\\n            vector<int> thisLevel;\\n\\t\\t\\t//vector to store data at one current level\\n            int size = q.size(); \\n\\t\\t\\t//this tells us the size of the current level so we only pop out the elements of this level in one traversal of the while loop\\n            for(int i = 0; i < size; i++){\\n                current = q.front();\\n                q.pop();\\n                thisLevel.push_back(current->val);\\n\\t\\t\\t\\t//as a single node can have many children so we loop through to find all of them and push them in the queue;\\n                for(int j = 0; j < current->children.size(); j++){\\n                    q.push(current->children[j]);\\n                }\\n            }\\n            answer.push_back(thisLevel);\\n\\t\\t\\t//we push this level \\n        }\\n        \\n        return answer;\\n    }\\n};\\n\\n```\\n\\nIf you have any queries or suggestions please do let me know.\\nAlso upvote if this helps.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "``` \\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> answer;\\n        if(root == nullptr){\\n            return answer;\\n        }\\n        \\n        queue<Node*> q;\\n\\t\\t//standard bfs move to push the first element in the queue\\n        q.push(root);\\n        \\n        Node* current;\\n        while(!q.empty()){\\n            vector<int> thisLevel;\\n\\t\\t\\t//vector to store data at one current level\\n            int size = q.size(); \\n\\t\\t\\t//this tells us the size of the current level so we only pop out the elements of this level in one traversal of the while loop\\n            for(int i = 0; i < size; i++){\\n                current = q.front();\\n                q.pop();\\n                thisLevel.push_back(current->val);\\n\\t\\t\\t\\t//as a single node can have many children so we loop through to find all of them and push them in the queue;\\n                for(int j = 0; j < current->children.size(); j++){\\n                    q.push(current->children[j]);\\n                }\\n            }\\n            answer.push_back(thisLevel);\\n\\t\\t\\t//we push this level \\n        }\\n        \\n        return answer;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2532290,
                "title": "c-100-faster-bfs-easy-to-understand",
                "content": "The Level Order traversal of any tree takes into the fact that we want to print the nodes at a root level first, then move on to the next level and keep repeating this process until we are at the last level. We make use of the Queue data structure to store the nodes at a particular level.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> ans;\\n        if(!root) return ans;\\n        \\n        queue<Node*> q;\\n        q.push(root);\\n        \\n        while(!q.empty()){\\n            int len = q.size();\\n            vector<int>v;\\n            for(int i = 0 ; i < len ; i++){\\n                Node* n = q.front();\\n                v.push_back(n->val);\\n                q.pop();\\n                for(auto &it : n->children){\\n                    q.push(it);\\n                }\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**If found helpful -> Dont forget to upvote! - Thankyou**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Breadth-First Search",
                    "Queue",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> ans;\\n        if(!root) return ans;\\n        \\n        queue<Node*> q;\\n        q.push(root);\\n        \\n        while(!q.empty()){\\n            int len = q.size();\\n            vector<int>v;\\n            for(int i = 0 ; i < len ; i++){\\n                Node* n = q.front();\\n                v.push_back(n->val);\\n                q.pop();\\n                for(auto &it : n->children){\\n                    q.push(it);\\n                }\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2532232,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using BFS***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        \\n        // base case\\n        \\n        if(root == NULL)\\n            return {};\\n        \\n        // declare a queue\\n        \\n        queue<Node*> q;\\n        \\n        q.push(root);\\n        \\n        vector<vector<int>> res;\\n        \\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            \\n            // temp will store the nodes of one level\\n            \\n            vector<int> temp;\\n            \\n            for(int k = 0; k < size; k++)\\n            {\\n                // take out the front of the queue\\n                \\n                auto curr = q.front();\\n                \\n                q.pop();\\n                \\n                // push the curr -> val into temp\\n                \\n                temp.push_back(curr -> val);\\n                \\n                // find the childs of curr node\\n                \\n                vector<Node*> childs = curr -> children;\\n                \\n                // push all the childs of curr node into queue\\n                \\n                for(int i = 0; i < childs.size(); i++)\\n                {\\n                    q.push(childs[i]);\\n                }\\n            }\\n            \\n            // push the nodes of curr level into res\\n            \\n            res.push_back(temp);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        \\n        // base case\\n        \\n        if(root == NULL)\\n            return {};\\n        \\n        // declare a queue\\n        \\n        queue<Node*> q;\\n        \\n        q.push(root);\\n        \\n        vector<vector<int>> res;\\n        \\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            \\n            // temp will store the nodes of one level\\n            \\n            vector<int> temp;\\n            \\n            for(int k = 0; k < size; k++)\\n            {\\n                // take out the front of the queue\\n                \\n                auto curr = q.front();\\n                \\n                q.pop();\\n                \\n                // push the curr -> val into temp\\n                \\n                temp.push_back(curr -> val);\\n                \\n                // find the childs of curr node\\n                \\n                vector<Node*> childs = curr -> children;\\n                \\n                // push all the childs of curr node into queue\\n                \\n                for(int i = 0; i < childs.size(); i++)\\n                {\\n                    q.push(childs[i]);\\n                }\\n            }\\n            \\n            // push the nodes of curr level into res\\n            \\n            res.push_back(temp);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2532116,
                "title": "python-recursion-traversal",
                "content": "```\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        d={}        \\n        \\n        def trav(root, n):\\n            if(not root):\\n                return\\n            \\n            if(n not in d):\\n                d[n]=[root.val]\\n            else:\\n                d[n]+=[root.val]\\n            \\n            for x in root.children:\\n                trav(x, n+1)\\n        \\n        trav(root, 0)\\n        \\n        ans=list(d.values())\\n        \\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        d={}        \\n        \\n        def trav(root, n):\\n            if(not root):\\n                return\\n            \\n            if(n not in d):\\n                d[n]=[root.val]\\n            else:\\n                d[n]+=[root.val]\\n            \\n            for x in root.children:\\n                trav(x, n+1)\\n        \\n        trav(root, 0)\\n        \\n        ans=list(d.values())\\n        \\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2472722,
                "title": "beats-96-submission-runtime-easy-to-understand-with-simple-dfs-python-implementation",
                "content": "``` \"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        out=defaultdict(list)\\n        def dfs(node,level):\\n            if not node:\\n                return\\n            out[level].append(node.val)\\n            level+=1\\n            for child in node.children:\\n                dfs(child,level)    \\n        dfs(root,0)\\n        return out.values()\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "``` \"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        out=defaultdict(list)\\n        def dfs(node,level):\\n            if not node:\\n                return\\n            out[level].append(node.val)\\n            level+=1\\n            for child in node.children:\\n                dfs(child,level)    \\n        dfs(root,0)\\n        return out.values()\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2274913,
                "title": "c-simple-bfs-clean-code",
                "content": "```\\n  vector<vector<int>> ans;\\n        if(!root) return ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            vector<int> level;\\n            TreeNode* current;\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                current=q.front();\\n                q.pop();\\n                level.emplace_back(current->val);\\n                if(current->left) q.push(current->left);\\n                if(current->right) q.push(current->right);\\n            }\\n            ans.emplace_back(level);\\n        }\\n        return ans;\\n```",
                "solutionTags": [],
                "code": "```\\n  vector<vector<int>> ans;\\n        if(!root) return ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            vector<int> level;\\n            TreeNode* current;\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                current=q.front();\\n                q.pop();\\n                level.emplace_back(current->val);\\n                if(current->left) q.push(current->left);\\n                if(current->right) q.push(current->right);\\n            }\\n            ans.emplace_back(level);\\n        }\\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2245936,
                "title": "simple-c-solution",
                "content": "```\\n vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> ans;\\n        \\n        if(root==NULL)\\n            return ans;\\n        \\n        queue<Node*> q;\\n        q.push(root);\\n        \\n        while(!q.empty())\\n        {\\n            vector<int> level;\\n            int size= q.size();\\n            \\n            for(int i=0;i<size;i++)\\n            {\\n                Node *node= q.front();\\n                q.pop();\\n                \\n                int s= (node->children).size();\\n                \\n                for(int i=0;i<s;i++)\\n                {\\n                    if((node->children).at(i)!=NULL)\\n                        q.push((node->children).at(i));\\n                }\\n                \\n                level.push_back(node->val);\\n            }\\n            ans.push_back(level);\\n        }\\n        \\n        return ans;\\n        \\n    }",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\n vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> ans;\\n        \\n        if(root==NULL)\\n            return ans;\\n        \\n        queue<Node*> q;\\n        q.push(root);\\n        \\n        while(!q.empty())\\n        {\\n            vector<int> level;\\n            int size= q.size();\\n            \\n            for(int i=0;i<size;i++)\\n            {\\n                Node *node= q.front();\\n                q.pop();\\n                \\n                int s= (node->children).size();\\n                \\n                for(int i=0;i<s;i++)\\n                {\\n                    if((node->children).at(i)!=NULL)\\n                        q.push((node->children).at(i));\\n                }\\n                \\n                level.push_back(node->val);\\n            }\\n            ans.push_back(level);\\n        }\\n        \\n        return ans;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2200408,
                "title": "go-bfs-friendly-and-readable-hihi",
                "content": "```\\n/**\\n * Definition for a Node.\\n * type Node struct {\\n *     Val int\\n *     Children []*Node\\n * }\\n */\\n\\nfunc levelOrder(root *Node) [][]int {\\n    var result [][]int\\n    \\n    if root == nil { return result }\\n    \\n    var queue []*Node\\n    enqueue(&queue, root)\\n    \\n    for len(queue) > 0 {\\n        queueSize := len(queue)\\n        var levelNodes []int\\n        \\n        for i := 0; i < queueSize; i++ {\\n            dequeuedEle := dequeue(&queue)\\n            \\n            levelNodes = append(levelNodes, dequeuedEle.Val)\\n            \\n            for i := 0; i < len(dequeuedEle.Children); i++ {\\n                if dequeuedEle.Children[i] != nil {\\n                    enqueue(&queue, dequeuedEle.Children[i])\\n                }\\n            }\\n        }\\n        \\n        result = append(result, levelNodes)\\n    }\\n\\n    return result\\n}\\n\\nfunc enqueue(queue *[]*Node, item *Node) {\\n    if queue == nil { panic(\"nil pointer\") }\\n    \\n    *queue = append(*queue, item)\\n} \\n\\nfunc dequeue(queue *[]*Node) *Node {\\n    if queue == nil { panic(\"nil pointer\") }\\n    \\n    dequeuedElement := (*queue)[0]\\n    \\n    *queue = (*queue)[1:]\\n    \\n    return dequeuedElement\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a Node.\\n * type Node struct {\\n *     Val int\\n *     Children []*Node\\n * }\\n */\\n\\nfunc levelOrder(root *Node) [][]int {\\n    var result [][]int\\n    \\n    if root == nil { return result }\\n    \\n    var queue []*Node\\n    enqueue(&queue, root)\\n    \\n    for len(queue) > 0 {\\n        queueSize := len(queue)\\n        var levelNodes []int\\n        \\n        for i := 0; i < queueSize; i++ {\\n            dequeuedEle := dequeue(&queue)\\n            \\n            levelNodes = append(levelNodes, dequeuedEle.Val)\\n            \\n            for i := 0; i < len(dequeuedEle.Children); i++ {\\n                if dequeuedEle.Children[i] != nil {\\n                    enqueue(&queue, dequeuedEle.Children[i])\\n                }\\n            }\\n        }\\n        \\n        result = append(result, levelNodes)\\n    }\\n\\n    return result\\n}\\n\\nfunc enqueue(queue *[]*Node, item *Node) {\\n    if queue == nil { panic(\"nil pointer\") }\\n    \\n    *queue = append(*queue, item)\\n} \\n\\nfunc dequeue(queue *[]*Node) *Node {\\n    if queue == nil { panic(\"nil pointer\") }\\n    \\n    dequeuedElement := (*queue)[0]\\n    \\n    *queue = (*queue)[1:]\\n    \\n    return dequeuedElement\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1836874,
                "title": "c-bfs-approach-o-n",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\nprivate:\\n    vector<vector<int>>res;\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        \\n\\t\\t//Edge Case\\n        if(root==NULL){\\n            return res;\\n        }\\n        \\n        queue<Node*>q;\\n        q.push(root);\\n        \\n        while(!q.empty()){\\n            \\n            int n=q.size();\\n            vector<int>t;\\n            for(int i=0; i<n; ++i){\\n                \\n                auto k=q.front();\\n                q.pop();\\n                t.push_back(k->val);\\n                \\n                for(auto &x:k->children){\\n                    q.push(x);\\n                }\\n                \\n            }\\n            \\n            res.push_back(t);\\n            \\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\nprivate:\\n    vector<vector<int>>res;\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        \\n\\t\\t//Edge Case\\n        if(root==NULL){\\n            return res;\\n        }\\n        \\n        queue<Node*>q;\\n        q.push(root);\\n        \\n        while(!q.empty()){\\n            \\n            int n=q.size();\\n            vector<int>t;\\n            for(int i=0; i<n; ++i){\\n                \\n                auto k=q.front();\\n                q.pop();\\n                t.push_back(k->val);\\n                \\n                for(auto &x:k->children){\\n                    q.push(x);\\n                }\\n                \\n            }\\n            \\n            res.push_back(t);\\n            \\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766276,
                "title": "python-easy-to-read-and-understand-bfs",
                "content": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        if not root:\\n            return []\\n        q = [root]\\n        ans = []\\n        while q:\\n            temp = []\\n            for i in range(len(q)):\\n                node = q.pop(0)\\n                temp.append(node.val)\\n                for child in node.children:\\n                    if child:\\n                        q.append(child)\\n            ans.append(temp)\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        if not root:\\n            return []\\n        q = [root]\\n        ans = []\\n        while q:\\n            temp = []\\n            for i in range(len(q)):\\n                node = q.pop(0)\\n                temp.append(node.val)\\n                for child in node.children:\\n                    if child:\\n                        q.append(child)\\n            ans.append(temp)\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1734988,
                "title": "c-95-faster-using-bfs",
                "content": "```\\nclass Solution {\\n    vector<vector<int>>result;\\npublic:\\n    void bfs(Node* root)\\n    {\\n        vector<int>adj;\\n        queue<Node*>q;\\n        q.push(root);\\n        q.push(NULL);\\n        adj.push_back(root->val);\\n        result.push_back(adj);\\n        adj.clear();\\n        while(q.size()>1)\\n        {\\n            Node*curr=q.front();\\n            q.pop();\\n            if(curr==NULL)\\n            {\\n                 if(adj.size()!=0)\\n            result.push_back(adj);\\n            adj.clear();\\n                q.push(NULL);\\n                continue;\\n            }\\n             for(int i=0;i<curr->children.size();i++)\\n                {q.push(curr->children[i]);\\n                 adj.push_back(curr->children[i]->val);}\\n           \\n        }\\n    }\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>>res;\\n        if(root==NULL)\\n            return res;\\n        bfs(root);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int>>result;\\npublic:\\n    void bfs(Node* root)\\n    {\\n        vector<int>adj;\\n        queue<Node*>q;\\n        q.push(root);\\n        q.push(NULL);\\n        adj.push_back(root->val);\\n        result.push_back(adj);\\n        adj.clear();\\n        while(q.size()>1)\\n        {\\n            Node*curr=q.front();\\n            q.pop();\\n            if(curr==NULL)\\n            {\\n                 if(adj.size()!=0)\\n            result.push_back(adj);\\n            adj.clear();\\n                q.push(NULL);\\n                continue;\\n            }\\n             for(int i=0;i<curr->children.size();i++)\\n                {q.push(curr->children[i]);\\n                 adj.push_back(curr->children[i]->val);}\\n           \\n        }\\n    }\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>>res;\\n        if(root==NULL)\\n            return res;\\n        bfs(root);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617937,
                "title": "c-code-bfs",
                "content": "*Don\\'t forget to check the base condition (root==NULL )*\\n```\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        \\n     vector<vector<int>>tf;\\n        if(!root)return tf;\\n        queue<Node*>q;\\n        q.push(root);\\n        \\n        \\n        while(q.size())\\n        {\\n            int sz=q.size();\\n            vector<int>af;\\n         for(int ix=0;ix<sz;ix++){\\n             \\n            Node* x=q.front();\\n            q.pop();\\n\\n         af.push_back(x->val);\\n             \\n            for(auto &it: x->children)\\n            {\\n                q.push(it);\\n            }\\n\\n         }\\n            tf.push_back(af);\\n            \\n            \\n        }\\n        \\n        return tf;\\n        \\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        \\n     vector<vector<int>>tf;\\n        if(!root)return tf;\\n        queue<Node*>q;\\n        q.push(root);\\n        \\n        \\n        while(q.size())\\n        {\\n            int sz=q.size();\\n            vector<int>af;\\n         for(int ix=0;ix<sz;ix++){\\n             \\n            Node* x=q.front();\\n            q.pop();\\n\\n         af.push_back(x->val);\\n             \\n            for(auto &it: x->children)\\n            {\\n                q.push(it);\\n            }\\n\\n         }\\n            tf.push_back(af);\\n            \\n            \\n        }\\n        \\n        return tf;\\n        \\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1516126,
                "title": "java-bfs-solution",
                "content": "**Do vote up if you like it :)**\\n```\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n        if(root == null) return new ArrayList<>();\\n        \\n        List<List<Integer>> ans = new ArrayList<>();\\n        \\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(root);\\n            \\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            List<Integer> currLevelList = new ArrayList<>();\\n            while(size-- > 0){\\n                Node currRoot = queue.poll();\\n                currLevelList.add(currRoot.val);\\n                for(Node child : currRoot.children){\\n                    queue.add(child);\\n                }\\n            }\\n            ans.add(currLevelList);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n        if(root == null) return new ArrayList<>();\\n        \\n        List<List<Integer>> ans = new ArrayList<>();\\n        \\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(root);\\n            \\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            List<Integer> currLevelList = new ArrayList<>();\\n            while(size-- > 0){\\n                Node currRoot = queue.poll();\\n                currLevelList.add(currRoot.val);\\n                for(Node child : currRoot.children){\\n                    queue.add(child);\\n                }\\n            }\\n            ans.add(currLevelList);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1496020,
                "title": "java-solution-with-queue",
                "content": "class Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n\\t\\n\\t\\n        Queue <Node> q1=new LinkedList();\\n        Queue  <Node> q2=new LinkedList();\\n        List<List<Integer>> list=new LinkedList<List<Integer>>();\\n        if(root==null){\\n            return list;\\n        }\\n        List<Integer> list1=new ArrayList<>();\\n        q1.add(root);\\n        while(q1.size()!=0){\\n            Node a =q1.remove();\\n             // System.out.print(a.val+\" \");\\n            list1.add(a.val);\\n            for(Node child:a.children){\\n                q2.add(child);\\n            }\\n            if(q1.size()==0){\\n                q1=q2;\\n                q2=new LinkedList();\\n                list.add(list1);\\n                list1=new ArrayList<>();\\n                // System.out.println();\\n            }\\n            \\n            \\n        }\\n        return list;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Queue"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n\\t\\n\\t\\n        Queue <Node> q1=new LinkedList();\\n        Queue  <Node> q2=new LinkedList();\\n        List<List<Integer>> list=new LinkedList<List<Integer>>();\\n        if(root==null){\\n            return list;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1412093,
                "title": "python-simple-dfs-exaplained",
                "content": "What this code is doing is traveling through the tree while keeping track of a `level` counter. When our level becomes the length of our answer variable, we add a new level to hold the values for the next level. Otherwise, we append `root.val` to `ans[level]`. To traverse the tree, we call `dfs(child, level+1) for child in root.children`.  If you this helped, please **upvote.**\\n\\n```\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        ans = []\\n        def dfs(root, level):\\n            if root is None: return\\n            if level == len(ans):\\n                ans.append([]) # -> New level\\n            ans[level].append(root.val)\\n            for child in root.children:\\n                dfs(child, level+1)\\n        dfs(root, 0)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        ans = []\\n        def dfs(root, level):\\n            if root is None: return\\n            if level == len(ans):\\n                ans.append([]) # -> New level\\n            ans[level].append(root.val)\\n            for child in root.children:\\n                dfs(child, level+1)\\n        dfs(root, 0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1388437,
                "title": "c-bfs-queue-comments-for-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        //Initializing Result Vector\\n        vector<vector<int>> v;\\n        \\n        if(root == NULL) return v;\\n        \\n        //Iterative BFS, so using Queue\\n        queue<Node*> qu;\\n        qu.push(root);\\n        \\n        while(!qu.empty()){\\n            //Temporary vector to take the elements of current level\\n            vector<int> temp;\\n            //Basically number of elements at current level \\u2935\\n            int size = qu.size();\\n\\n            while(size--){ \\n                Node* current = qu.front();\\n                //Push the current element of current level\\n                temp.push_back(current->val);\\n                \\n                //if there are children of current element of current level, push them into queue\\n                if(current->children.size()){\\n                    for(int i=0; i < current->children.size(); i++){\\n                        qu.push(current->children[i]);\\n                    }\\n                }\\n                //Since we have recorded the current element in temp vector and it\\'s children in queue, pop it off!\\n                qu.pop();\\n            }\\n            //All elements recorded in temp, push it to result vector\\n            v.push_back(temp);\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        //Initializing Result Vector\\n        vector<vector<int>> v;\\n        \\n        if(root == NULL) return v;\\n        \\n        //Iterative BFS, so using Queue\\n        queue<Node*> qu;\\n        qu.push(root);\\n        \\n        while(!qu.empty()){\\n            //Temporary vector to take the elements of current level\\n            vector<int> temp;\\n            //Basically number of elements at current level \\u2935\\n            int size = qu.size();\\n\\n            while(size--){ \\n                Node* current = qu.front();\\n                //Push the current element of current level\\n                temp.push_back(current->val);\\n                \\n                //if there are children of current element of current level, push them into queue\\n                if(current->children.size()){\\n                    for(int i=0; i < current->children.size(); i++){\\n                        qu.push(current->children[i]);\\n                    }\\n                }\\n                //Since we have recorded the current element in temp vector and it\\'s children in queue, pop it off!\\n                qu.pop();\\n            }\\n            //All elements recorded in temp, push it to result vector\\n            v.push_back(temp);\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1387292,
                "title": "python-97-basic-queue-solution",
                "content": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        if not root: return []\\n        ans = []\\n        que = deque([root]) # start with the root node\\n        cnt = 1 # to count how many nodes are on a level\\n        while que:\\n            res, nextCnt = [], 0\\n            for i in range(cnt):\\n                pop = que.pop()\\n                res.append(pop.val)\\n                for child in pop.children:\\n                    if not child: continue\\n                    que.appendleft(child)\\n                    nextCnt += 1 # counting the number of nodes located on the next level\\n            ans.append(res)\\n            cnt = nextCnt # switch the value of cnt\\n        return ans",
                "solutionTags": [],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        if not root: return []\\n        ans = []\\n        que = deque([root]) # start with the root node\\n        cnt = 1 # to count how many nodes are on a level\\n        while que:\\n            res, nextCnt = [], 0\\n            for i in range(cnt):\\n                pop = que.pop()\\n                res.append(pop.val)\\n                for child in pop.children:\\n                    if not child: continue\\n                    que.appendleft(child)\\n                    nextCnt += 1 # counting the number of nodes located on the next level\\n            ans.append(res)\\n            cnt = nextCnt # switch the value of cnt\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1386946,
                "title": "c-python-bfs-solution",
                "content": "C++ Solution: \\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>>result;\\n        if(root == nullptr)\\n            return result;\\n        queue<Node*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            vector<int> level;\\n            int n = q.size();\\n            for(int i=0;i<n;i++){\\n                Node * tempNode = q.front();\\n                q.pop();\\n                level.push_back(tempNode->val);\\n                for(Node * next : tempNode->children)\\n                    q.push(next);\\n            }\\n            result.push_back(level);\\n        }\\n        return result;\\n    }\\n};\\n```\\nPython Solution:\\n```\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        result = []\\n        if(root == None):\\n            return result\\n        q = deque([root])\\n        while q:\\n            level = []\\n            n = len(q)\\n            for i in range(n):\\n                tempNode = q.popleft()\\n                level.append(tempNode.val)\\n                for nextNode in tempNode.children:\\n                    q.append(nextNode)    \\n            result.append(level)\\n        return result\\n            \\n                \\n        \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>>result;\\n        if(root == nullptr)\\n            return result;\\n        queue<Node*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            vector<int> level;\\n            int n = q.size();\\n            for(int i=0;i<n;i++){\\n                Node * tempNode = q.front();\\n                q.pop();\\n                level.push_back(tempNode->val);\\n                for(Node * next : tempNode->children)\\n                    q.push(next);\\n            }\\n            result.push_back(level);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1386803,
                "title": "simpl-java-solution-bfs",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if(root==null)\\n            return result;\\n        \\n        Queue<Node> queue = new LinkedList<>();\\n        queue.offer(root);\\n        \\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            List<Integer> listAtEachLevel = new ArrayList<>();\\n            \\n            while(size!=0){\\n                Node head = queue.poll();\\n                size--;\\n                listAtEachLevel.add(head.val);\\n                for(Node child: head.children){\\n                    queue.offer(child);\\n                }\\n            }\\n            result.add(listAtEachLevel);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if(root==null)\\n            return result;\\n        \\n        Queue<Node> queue = new LinkedList<>();\\n        queue.offer(root);\\n        \\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            List<Integer> listAtEachLevel = new ArrayList<>();\\n            \\n            while(size!=0){\\n                Node head = queue.poll();\\n                size--;\\n                listAtEachLevel.add(head.val);\\n                for(Node child: head.children){\\n                    queue.offer(child);\\n                }\\n            }\\n            result.add(listAtEachLevel);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1269434,
                "title": "100-ms-short-asked-by-amazon-juspay-paypal-explanation-complexities",
                "content": "* **LEVEL ORDER TRAVERSAL**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        // it\\'s just simple level order traversal, with just one change..\\n        vector<vector<int>> res;\\n        if(root == NULL)\\n            return res;\\n        \\n        queue<Node*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n                \\n            int size = q.size();\\n            vector<int> sub_res;\\n            for(int i =0; i < size; ++i){\\n                Node* curr = q.front();   // get the front element of the queue or we can say, pop the orderwise(left to right) elements \\n                q.pop();                  // of the particular level.. after getting the element push it into our sub_res array.... \\n                \\n                sub_res.push_back(curr->val);\\n                \\n                for(auto &v : curr->children){  // THIS IS THE ONLY CHANGE OVER THE SIMPLE LEVEL ORDER TRAVERSAL.. BUT WHY? \\n                    q.push(v);                  // Actually, after getting elements from the queue, we will push all of it\\'s childrens into the queue..\\n                }\\n            }\\n            res.push_back(sub_res);             // atlast, push all the elements(or nodes) of the same level into our solution space..\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**TIME COMPLEXITY : `O(N + E)`, where N :- total number of nodes in a N-ary tree & E :- total number of childrens one node has.. (like graphs).**\\n**SPACE COMPLEXITY :` O(N)`, (for using queue)**\\nif you find any mistakes pls, drop a comment\\nif it makes any sense don\\'t forget to `Upvote`",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        // it\\'s just simple level order traversal, with just one change..\\n        vector<vector<int>> res;\\n        if(root == NULL)\\n            return res;\\n        \\n        queue<Node*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n                \\n            int size = q.size();\\n            vector<int> sub_res;\\n            for(int i =0; i < size; ++i){\\n                Node* curr = q.front();   // get the front element of the queue or we can say, pop the orderwise(left to right) elements \\n                q.pop();                  // of the particular level.. after getting the element push it into our sub_res array.... \\n                \\n                sub_res.push_back(curr->val);\\n                \\n                for(auto &v : curr->children){  // THIS IS THE ONLY CHANGE OVER THE SIMPLE LEVEL ORDER TRAVERSAL.. BUT WHY? \\n                    q.push(v);                  // Actually, after getting elements from the queue, we will push all of it\\'s childrens into the queue..\\n                }\\n            }\\n            res.push_back(sub_res);             // atlast, push all the elements(or nodes) of the same level into our solution space..\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1255986,
                "title": "java-with-comments-bfs-beginner-friendly",
                "content": "```\\n\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n        \\n        // Creating list to store lists of different level\\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        // Return , if root is null\\n        if(root == null)\\n            return result;\\n        \\n        // Queue needed for BFS or LevelOrderTraversal\\n        Queue<Node> q = new LinkedList<>();\\n        q.add(root);\\n        \\n        while(!q.isEmpty())\\n        {\\n            \\n            // Storing size\\n            int sz = q.size();\\n            \\n            // List to add level-wise node value\\n            List<Integer> levelList = new ArrayList<>();\\n            \\n            // Loop for traversing current level of size sz\\n            while(sz > 0)\\n            {\\n                Node currNode = q.remove();\\n                \\n                // adding value\\n                levelList.add(currNode.val);\\n                \\n                // adding children into queue\\n                /*\\n                These children wont get processed in this loop as we will\\n                loop untill sz >0 that is the previous size of queue so it doesnt matter\\n                how much child we add to it.\\n                */\\n                for(Node child : currNode.children)\\n                    q.add(child);\\n                \\n                // Decrementing\\n                sz--;\\n            }\\n            \\n            // adding list to result list\\n            result.add(levelList);\\n            \\n        }\\n     // returning the list :)\\n        return result;\\n    }\\n}\\n```\\n\\nIf you have any doubt, let me know in the comment section.\\n**UPVOTE IF YOU LIKE IT.**\\n**DOWNVOTE IF YOU DON\\'T**",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n        \\n        // Creating list to store lists of different level\\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        // Return , if root is null\\n        if(root == null)\\n            return result;\\n        \\n        // Queue needed for BFS or LevelOrderTraversal\\n        Queue<Node> q = new LinkedList<>();\\n        q.add(root);\\n        \\n        while(!q.isEmpty())\\n        {\\n            \\n            // Storing size\\n            int sz = q.size();\\n            \\n            // List to add level-wise node value\\n            List<Integer> levelList = new ArrayList<>();\\n            \\n            // Loop for traversing current level of size sz\\n            while(sz > 0)\\n            {\\n                Node currNode = q.remove();\\n                \\n                // adding value\\n                levelList.add(currNode.val);\\n                \\n                // adding children into queue\\n                /*\\n                These children wont get processed in this loop as we will\\n                loop untill sz >0 that is the previous size of queue so it doesnt matter\\n                how much child we add to it.\\n                */\\n                for(Node child : currNode.children)\\n                    q.add(child);\\n                \\n                // Decrementing\\n                sz--;\\n            }\\n            \\n            // adding list to result list\\n            result.add(levelList);\\n            \\n        }\\n     // returning the list :)\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1095683,
                "title": "python-python3-n-ary-tree-level-order-traversal",
                "content": "***Shameless-Self-Promotion***: My other leetcode [solutions](https://leetcode.com/discuss/general-discussion/1112952/Collection-of-my-leetcode-solution-posts) to various questions can be found [here](https://leetcode.com/discuss/general-discussion/1112952/Collection-of-my-leetcode-solution-posts)\\n\\n```\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        \\n        if not root: return []\\n        \\n        ans = []\\n        level = [root]\\n        \\n        while level:\\n            ans.append([node.val for node in level])\\n            level = [kid for node in level for kid in node.children if kid]\\n        \\n        return ans\\n```\\n\\nTime: ```O(n)``` n is the number of nodes in the tree in total",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        \\n        if not root: return []\\n        \\n        ans = []\\n        level = [root]\\n        \\n        while level:\\n            ans.append([node.val for node in level])\\n            level = [kid for node in level for kid in node.children if kid]\\n        \\n        return ans\\n```\n```O(n)```",
                "codeTag": "Java"
            },
            {
                "id": 1000728,
                "title": "javascript-easy-beats-80-time-and-95-space",
                "content": "```/**\\n * // Definition for a Node.\\n * function Node(val,children) {\\n *    this.val = val;\\n *    this.children = children;\\n * };\\n */\\n\\n/**\\n * @param {Node} root\\n * @return {number[][]}\\n */\\nvar levelOrder = function(root) {\\n    if(!root) return [];\\n    let ret = [[root.val]];\\n    let hold = root.children;\\n    \\n    while(hold.length != 0){\\n        let children = [];\\n        let nums = [];\\n        for(let i = 0 ; i < hold.length; i++){\\n            children.push(...hold[i].children);\\n            nums.push(hold[i].val);\\n        }\\n        hold = children;\\n        ret.push(nums);\\n    }\\n    return ret;\\n};```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```/**\\n * // Definition for a Node.\\n * function Node(val,children) {\\n *    this.val = val;\\n *    this.children = children;\\n * };\\n */\\n\\n/**\\n * @param {Node} root\\n * @return {number[][]}\\n */\\nvar levelOrder = function(root) {\\n    if(!root) return [];\\n    let ret = [[root.val]];\\n    let hold = root.children;\\n    \\n    while(hold.length != 0){\\n        let children = [];\\n        let nums = [];\\n        for(let i = 0 ; i < hold.length; i++){\\n            children.push(...hold[i].children);\\n            nums.push(hold[i].val);\\n        }\\n        hold = children;\\n        ret.push(nums);\\n    }\\n    return ret;\\n};```",
                "codeTag": "Unknown"
            },
            {
                "id": 777218,
                "title": "javascript-easy-solution-bfs",
                "content": "```\\nvar levelOrder = function(root) {\\n    if(root === null) return [];\\n    let queue = [root];\\n    let res=[];\\n    while(queue.length > 0){\\n        let currentlevel = [];\\n        let len = queue.length;\\n        for(let i=0; i < len; i++){\\n            let tmp = queue.shift();\\n            currentlevel.push(tmp.val);\\n            queue.push(...tmp.children);\\n        }\\n        res.push(currentlevel);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar levelOrder = function(root) {\\n    if(root === null) return [];\\n    let queue = [root];\\n    let res=[];\\n    while(queue.length > 0){\\n        let currentlevel = [];\\n        let len = queue.length;\\n        for(let i=0; i < len; i++){\\n            let tmp = queue.shift();\\n            currentlevel.push(tmp.val);\\n            queue.push(...tmp.children);\\n        }\\n        res.push(currentlevel);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 721183,
                "title": "python-3-bfs-easy-to-read-solution",
                "content": "```\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        if not root: return []\\n        queue = [root]\\n        result = []\\n        while queue:\\n            curLevelNodes = []\\n            nextLevelNodes = []\\n            while queue:\\n                node = queue.pop(0)   \\n                curLevelNodes.append(node.val)\\n                nextLevelNodes += node.children\\n            queue = nextLevelNodes\\n            result.append(curLevelNodes)\\n        return result  \\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        if not root: return []\\n        queue = [root]\\n        result = []\\n        while queue:\\n            curLevelNodes = []\\n            nextLevelNodes = []\\n            while queue:\\n                node = queue.pop(0)   \\n                curLevelNodes.append(node.val)\\n                nextLevelNodes += node.children\\n            queue = nextLevelNodes\\n            result.append(curLevelNodes)\\n        return result  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 693161,
                "title": "c-98-68-faster-with-pre-order-traversal-and-one-global-vector",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> answer;\\n    vector<vector<int>> levelOrder(Node* root) {\\n        preOrder(root, 1);\\n        return answer;\\n    }\\n    \\n    void preOrder(Node* root, int level){\\n        \\n        if(root){\\n            \\n            if( answer.size() < level){\\n                vector<int> temp{root->val};\\n                answer.push_back(temp);\\n            }else{\\n                answer[level -1].push_back(root->val);\\n            }\\n            for(int i = 0;i <root->children.size();i++){\\n                preOrder(root->children[i], level + 1);\\n            }\\n            \\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> answer;\\n    vector<vector<int>> levelOrder(Node* root) {\\n        preOrder(root, 1);\\n        return answer;\\n    }\\n    \\n    void preOrder(Node* root, int level){\\n        \\n        if(root){\\n            \\n            if( answer.size() < level){\\n                vector<int> temp{root->val};\\n                answer.push_back(temp);\\n            }else{\\n                answer[level -1].push_back(root->val);\\n            }\\n            for(int i = 0;i <root->children.size();i++){\\n                preOrder(root->children[i], level + 1);\\n            }\\n            \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 588877,
                "title": "c",
                "content": "\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>>ans;\\n        if(root==NULL)\\n            return ans;\\n        queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int size= q.size();\\n            vector<int>v;\\n            while(size--)\\n            {\\n            Node* front = q.front();  \\n            v.push_back(front->val);\\n            q.pop();\\n            auto it = front->children.begin();\\n            while(it!=front->children.end())\\n            {\\n               q.push(*it);\\n               it++;\\n            }\\n            }\\n            ans.push_back(v);\\n        }\\n      return ans; \\n    }",
                "solutionTags": [],
                "code": "\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>>ans;\\n        if(root==NULL)\\n            return ans;\\n        queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int size= q.size();\\n            vector<int>v;\\n            while(size--)\\n            {\\n            Node* front = q.front();  \\n            v.push_back(front->val);\\n            q.pop();\\n            auto it = front->children.begin();\\n            while(it!=front->children.end())\\n            {\\n               q.push(*it);\\n               it++;\\n            }\\n            }\\n            ans.push_back(v);\\n        }\\n      return ans; \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 556259,
                "title": "easy-c-bfs-o-n-time-o-k-space",
                "content": "NOTE: k = maximum number of nodes at a particular level (as the size of our queue will never exceed this number)\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        std::vector<std::vector<int>> res;\\n        if (root == NULL) return res;\\n        std::queue<Node*> q;\\n        q.push(root);\\n        while (!q.empty()) {\\n            std::vector<int> currLvl;\\n            for (int i = q.size() - 1; i >= 0; i--) {\\n                Node* curr = q.front(); q.pop();\\n                currLvl.push_back(curr->val);\\n                for (Node* child: curr->children) q.push(child);\\n            }\\n            res.push_back(currLvl);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        std::vector<std::vector<int>> res;\\n        if (root == NULL) return res;\\n        std::queue<Node*> q;\\n        q.push(root);\\n        while (!q.empty()) {\\n            std::vector<int> currLvl;\\n            for (int i = q.size() - 1; i >= 0; i--) {\\n                Node* curr = q.front(); q.pop();\\n                currLvl.push_back(curr->val);\\n                for (Node* child: curr->children) q.push(child);\\n            }\\n            res.push_back(currLvl);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 543582,
                "title": "100-fast-and-memory",
                "content": "````\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        if(!root) return {};\\n        queue<Node *> q;\\n        q.push(root);\\n        vector<vector<int>> res;\\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            vector<int> temp;\\n            while(sz--)\\n            {\\n                auto front = q.front();\\n                q.pop();\\n                temp.push_back(front->val);\\n                for(auto n : front->children)\\n                {\\n                    q.push(n);\\n                }\\n            }\\n            res.push_back(temp);\\n        }\\n        return res;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "````\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        if(!root) return {};\\n        queue<Node *> q;\\n        q.push(root);\\n        vector<vector<int>> res;\\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            vector<int> temp;\\n            while(sz--)\\n            {\\n                auto front = q.front();\\n                q.pop();\\n                temp.push_back(front->val);\\n                for(auto n : front->children)\\n                {\\n                    q.push(n);\\n                }\\n            }\\n            res.push_back(temp);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 390276,
                "title": "java-simple-queue-solution",
                "content": "```\\nclass Solution {\\n\\n    public List<List<Integer>> levelOrder(Node root) {\\n\\t\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (root == null) return result;\\n\\t\\t\\n        Queue<Node> queue = new ArrayDeque<>();\\n        queue.add(root);\\n\\t\\t\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            List<Integer> currentList = new ArrayList<>();\\n            while (size > 0) {\\n                Node node = queue.poll();\\n                currentList.add(node.val);\\n                if (node.children != null) {\\n                    queue.addAll(node.children);\\n                }\\n                size--;\\n            }\\n            result.add(currentList);\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "class Solution {\\n\\n    public List<List<Integer>> levelOrder(Node root) {\\n\\t\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (root == null) return result;\\n\\t\\t\\n        Queue<Node> queue = new ArrayDeque<>();\\n        queue.add(root);\\n\\t\\t\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            List<Integer> currentList = new ArrayList<>();\\n            while (size > 0) {\\n                Node node = queue.poll();\\n                currentList.add(node.val);\\n                if (node.children != null) {\\n                    queue.addAll(node.children);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 356215,
                "title": "java-bfs-solution",
                "content": "```\\npublic List<List<Integer>> levelOrder(Node root) \\n    {\\n        if(root == null)\\n        {\\n           return new ArrayList<>();\\n        }\\n        \\n        List<List<Integer>> result = new ArrayList<>();\\n        Queue<Node> queue = new LinkedList<>();\\n        \\n        // add root to queue\\n        queue.add(root);\\n        \\n        while(!queue.isEmpty())\\n        {\\n            List<Integer> levelNodes = new ArrayList<>();\\n            \\n            int queueSize = queue.size();\\n            \\n            for(int i = 0 ; i < queueSize; i++)\\n            {\\n                Node levelRoot = queue.remove();\\n                levelNodes.add(levelRoot.val);\\n                \\n                for(Node n : levelRoot.children)\\n                {\\n                    queue.add(n);\\n                }\\n            }\\n            \\n            result.add(levelNodes);\\n        }\\n        \\n        return result;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic List<List<Integer>> levelOrder(Node root) \\n    {\\n        if(root == null)\\n        {\\n           return new ArrayList<>();\\n        }\\n        \\n        List<List<Integer>> result = new ArrayList<>();\\n        Queue<Node> queue = new LinkedList<>();\\n        \\n        // add root to queue\\n        queue.add(root);\\n        \\n        while(!queue.isEmpty())\\n        {\\n            List<Integer> levelNodes = new ArrayList<>();\\n            \\n            int queueSize = queue.size();\\n            \\n            for(int i = 0 ; i < queueSize; i++)\\n            {\\n                Node levelRoot = queue.remove();\\n                levelNodes.add(levelRoot.val);\\n                \\n                for(Node n : levelRoot.children)\\n                {\\n                    queue.add(n);\\n                }\\n            }\\n            \\n            result.add(levelNodes);\\n        }\\n        \\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 339274,
                "title": "help-needed",
                "content": "Can someoone please let me know what is the problem in my code. It\\'s failing one case:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> vect;\\n        if(!root) return vect;\\n        \\n        int i = 0;\\n        vector<int>res;\\n        res.push_back(root->val);\\n        vect.push_back(res);\\n        helper(root, vect);\\n        return vect;\\n    }\\n    \\n    void helper(Node *root, vector<vector<int>>&vect){\\n        if(!root) return ;\\n        vector<int>res;\\n        for(auto child: root->children){\\n                res.push_back(child->val);\\n        }\\n        if (!res.empty())\\n             vect.push_back(res);\\n        for(auto child: root->children){\\n            helper(child, vect);\\n        }\\n    }\\n};\\n```\\n\\nInput \\n\\n```\\n{\"$id\":\"1\",\"children\":[{\"$id\":\"2\",\"children\":[{\"$id\":\"3\",\"children\":[],\"val\":5},{\"$id\":\"4\",\"children\":[],\"val\":0}],\"val\":10},{\"$id\":\"5\",\"children\":[{\"$id\":\"6\",\"children\":[],\"val\":6}],\"val\":3}],\"val\":1}\\n```\\n\\nMy output:\\n\\n```\\n[[1],[10,3],[5,0],[6]]\\n```\\n\\nExpected:\\n\\n```\\n[[1],[10,3],[5,0,6]]\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> vect;\\n        if(!root) return vect;\\n        \\n        int i = 0;\\n        vector<int>res;\\n        res.push_back(root->val);\\n        vect.push_back(res);\\n        helper(root, vect);\\n        return vect;\\n    }\\n    \\n    void helper(Node *root, vector<vector<int>>&vect){\\n        if(!root) return ;\\n        vector<int>res;\\n        for(auto child: root->children){\\n                res.push_back(child->val);\\n        }\\n        if (!res.empty())\\n             vect.push_back(res);\\n        for(auto child: root->children){\\n            helper(child, vect);\\n        }\\n    }\\n};\\n```\n```\\n{\"$id\":\"1\",\"children\":[{\"$id\":\"2\",\"children\":[{\"$id\":\"3\",\"children\":[],\"val\":5},{\"$id\":\"4\",\"children\":[],\"val\":0}],\"val\":10},{\"$id\":\"5\",\"children\":[{\"$id\":\"6\",\"children\":[],\"val\":6}],\"val\":3}],\"val\":1}\\n```\n```\\n[[1],[10,3],[5,0],[6]]\\n```\n```\\n[[1],[10,3],[5,0,6]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 160718,
                "title": "java-simple-bfs-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.offer(root);\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            List<Integer> list = new ArrayList<>();\\n            for (int i = 0; i < size; i++) {\\n                Node node = queue.poll();\\n                list.add(node.val);\\n                for (Node nei : node.children) {\\n                    queue.offer(nei);\\n                }\\n            }\\n            ans.add(list);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.offer(root);\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            List<Integer> list = new ArrayList<>();\\n            for (int i = 0; i < size; i++) {\\n                Node node = queue.poll();\\n                list.add(node.val);\\n                for (Node nei : node.children) {\\n                    queue.offer(nei);\\n                }\\n            }\\n            ans.add(list);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 157521,
                "title": "c-easy-to-understand-recursive-solution-based-on-dfs-44-ms-beats-98-67",
                "content": "The idea is to use recursion. The key is to merge vectors `ret` and `r`:\\n\\n1. It is apparent that the `child` node is always **one** level lower than its parent node. Suppose `r = levelOrder(root->child)`, and `ret` a vector to store the final output for current level. Hence, `r[0]`, `r[1]`, `r[2]`,  ..., should be merged to `ret[1]`, `ret[2]`, `ret[3]`, ..., respectively.\\n2. If `ret[1]` does NOT exist, i.e., `ret.size() == 1`, then `ret.push_back(r[0])`. Otherwise, combine `ret[1]` with `r[0]` by `ret[1].insert(ret[1].end(), r[0].begin(), r[0].end());`. To illustrate this, see below:\\n\\n\\t```C++\\n\\tlevel   N   N+1  N+2  N+3  N+4  N+5\\n\\tret = [[1], [2], [3]]                              N    N+1    N+2   N+3  N+4  N+5\\n\\t                                      -->  ret = [[1], [2,4], [3,5], [6], [7], [8]]\\n\\tr   =      [[4], [5], [6], [7], [8]]\\n\\t```\\n3. Repeat the above until all nodes are traversed.\\n\\n```C++\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> ret;\\n        if (!root)\\n            return ret;\\n        ret.push_back(vector<int> {root->val});\\n        for (auto child : root->children) {\\n            vector<vector<int>> r = levelOrder(child);\\n            for (int i = 0; i < r.size(); ++i)\\n                if (i + 1 > ret.size() - 1)\\n                    ret.push_back(r[i]);\\n                else\\n                    ret[i + 1].insert(ret[i + 1].end(), r[i].begin(), r[i].end());\\n        }\\n        return ret;       \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\n\\tlevel   N   N+1  N+2  N+3  N+4  N+5\\n\\tret = [[1], [2], [3]]                              N    N+1    N+2   N+3  N+4  N+5\\n\\t                                      -->  ret = [[1], [2,4], [3,5], [6], [7], [8]]\\n\\tr   =      [[4], [5], [6], [7], [8]]\\n\\t```\n```C++\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> ret;\\n        if (!root)\\n            return ret;\\n        ret.push_back(vector<int> {root->val});\\n        for (auto child : root->children) {\\n            vector<vector<int>> r = levelOrder(child);\\n            for (int i = 0; i < r.size(); ++i)\\n                if (i + 1 > ret.size() - 1)\\n                    ret.push_back(r[i]);\\n                else\\n                    ret[i + 1].insert(ret[i + 1].end(), r[i].begin(), r[i].end());\\n        }\\n        return ret;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 154694,
                "title": "basic-bfs-solution-by-python",
                "content": "    def levelOrder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not root:\\n            return []\\n        queue = [root]\\n        res = []\\n        while queue:\\n            temp = []\\n            tempq = []\\n            for node in queue:\\n                temp.append(node.val)\\n                if node.children:\\n                    for child in node.children:\\n                        tempq.append(child)\\n            res.append(temp)\\n            queue = tempq\\n        return res\\n                ",
                "solutionTags": [],
                "code": "    def levelOrder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not root:\\n            return []\\n        queue = [root]\\n        res = []\\n        while queue:\\n            temp = []\\n            tempq = []\\n            for node in queue:\\n                temp.append(node.val)\\n                if node.children:\\n                    for child in node.children:\\n                        tempq.append(child)\\n            res.append(temp)\\n            queue = tempq\\n        return res\\n                ",
                "codeTag": "Python3"
            },
            {
                "id": 4027792,
                "title": "c-simple-bfs-solution",
                "content": "# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> ans;\\n\\n        if(root == NULL) return ans;\\n\\n        queue<Node*> q;\\n        q.push(root);\\n\\n        while(!q.empty()) {\\n            int x = q.size();\\n\\n            vector<int> temp;\\n            while(x--) {\\n                Node* top = q.front();\\n                q.pop();\\n                temp.push_back(top->val);\\n                for(auto ele : top->children) {\\n                    // cout << ele->val << \" \";\\n                    q.push(ele);\\n                }\\n            }\\n            if(!temp.empty())\\n                ans.push_back(temp);\\n            // cout << endl;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> ans;\\n\\n        if(root == NULL) return ans;\\n\\n        queue<Node*> q;\\n        q.push(root);\\n\\n        while(!q.empty()) {\\n            int x = q.size();\\n\\n            vector<int> temp;\\n            while(x--) {\\n                Node* top = q.front();\\n                q.pop();\\n                temp.push_back(top->val);\\n                for(auto ele : top->children) {\\n                    // cout << ele->val << \" \";\\n                    q.push(ele);\\n                }\\n            }\\n            if(!temp.empty())\\n                ans.push_back(temp);\\n            // cout << endl;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3967484,
                "title": "c-soln-why-is-this-a-medium",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> ans;\\n        if (!root) return ans;\\n        queue<Node*> q;\\n        q.push(root);\\n        while (!q.empty()) {\\n            vector<int> vec;\\n            int len = q.size();\\n            while (len--) {\\n                root = q.front();\\n                q.pop();\\n                vec.push_back(root->val);\\n                for (auto node: root->children) {\\n                    q.push(node);\\n                }\\n            }\\n            ans.push_back(vec);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> ans;\\n        if (!root) return ans;\\n        queue<Node*> q;\\n        q.push(root);\\n        while (!q.empty()) {\\n            vector<int> vec;\\n            int len = q.size();\\n            while (len--) {\\n                root = q.front();\\n                q.pop();\\n                vec.push_back(root->val);\\n                for (auto node: root->children) {\\n                    q.push(node);\\n                }\\n            }\\n            ans.push_back(vec);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838837,
                "title": "easy-basic-level-order-traversal",
                "content": "\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n    if(root==NULL){\\n        return {};\\n    }\\n        \\n    vector<vector<int>> levels;\\n    queue<Node*> queue;\\n    queue.push(root);\\n        while(queue.size()>0){\\n            int n=queue.size();\\n            vector<int> level;\\n            for(int i=0;i<n;i++){\\n\\n                Node* x=queue.front();\\n                queue.pop();\\n                level.push_back(x->val);\\n\\n                for(Node* i:x->children){\\n                    queue.push(i);\\n\\n\\n                }\\n\\n            }\\n            levels.push_back(level);\\n\\n           \\n\\n\\n        }\\n        return levels;\\n    }\\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n    if(root==NULL){\\n        return {};\\n    }\\n        \\n    vector<vector<int>> levels;\\n    queue<Node*> queue;\\n    queue.push(root);\\n        while(queue.size()>0){\\n            int n=queue.size();\\n            vector<int> level;\\n            for(int i=0;i<n;i++){\\n\\n                Node* x=queue.front();\\n                queue.pop();\\n                level.push_back(x->val);\\n\\n                for(Node* i:x->children){\\n                    queue.push(i);\\n\\n\\n                }\\n\\n            }\\n            levels.push_back(level);\\n\\n           \\n\\n\\n        }\\n        return levels;\\n    }\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811196,
                "title": "python3-beats-95-using-queue-and-none-method-space-and-time-o-n",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe can have a queue which holds the root node and then a None node,this None node being the point where a level ends\\nfrom here we attach the values of node to an array b \\n    for the children each child is similarly appended to the queue and it repeats till a None is found\\n    when this None is found,we can attach the b array to answer \\nthe loop ends when all elements are exhausted and only None is left in the q ,after popping q will be empty and we can return\\n#pop(0) acts similar to popleft() in deque\\nwe can use deque() can perform the same\\n\\n\\n\\n# Complexity\\nN being number of elements\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n______**O(N)**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n______**O(N)**\\n\\n# Code\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        if not root:return \\n        q=[root,None]\\n        ans=[]\\n        b=[]\\n        while q:\\n            node=q.pop(0)\\n            if not node:\\n                ans.append(b)\\n                b=[]\\n                if not q:\\n                    return ans\\n                q.append(None)\\n            else:\\n                b.append(node.val)\\n                for i in node.children:\\n                    q.append(i)\\n```",
                "solutionTags": [
                    "Python3",
                    "Queue"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        if not root:return \\n        q=[root,None]\\n        ans=[]\\n        b=[]\\n        while q:\\n            node=q.pop(0)\\n            if not node:\\n                ans.append(b)\\n                b=[]\\n                if not q:\\n                    return ans\\n                q.append(None)\\n            else:\\n                b.append(node.val)\\n                for i in node.children:\\n                    q.append(i)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793767,
                "title": "n-ary-tree-level-order-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/44594e3d-9a4b-4331-aaa4-94cf6a90c018_1689875480.2371283.png)\\n\\n# Code\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        l=defaultdict(list)\\n        def level(temp ,h):\\n            if temp is None:\\n                return\\n            l[h].append(temp.val)\\n            for i in temp.children:\\n                level(i,h+1)\\n        level(root,0)\\n        return l.values()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        l=defaultdict(list)\\n        def level(temp ,h):\\n            if temp is None:\\n                return\\n            l[h].append(temp.val)\\n            for i in temp.children:\\n                level(i,h+1)\\n        level(root,0)\\n        return l.values()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641690,
                "title": "c-bfs-clean-simple",
                "content": "# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> result;\\n        if (!root) return result;\\n\\n        queue<Node*> Q;\\n        Q.push(root);\\n\\n        while (!Q.empty()) {\\n            size_t size = Q.size();\\n            vector<int> level;\\n            for (int i = 0; i < size; i++) {\\n                Node* curr = Q.front(); Q.pop();\\n                level.emplace_back(curr->val);\\n                for (Node*& child: curr->children) {\\n                    Q.push(child);\\n                }\\n            }\\n            result.emplace_back(level);\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> result;\\n        if (!root) return result;\\n\\n        queue<Node*> Q;\\n        Q.push(root);\\n\\n        while (!Q.empty()) {\\n            size_t size = Q.size();\\n            vector<int> level;\\n            for (int i = 0; i < size; i++) {\\n                Node* curr = Q.front(); Q.pop();\\n                level.emplace_back(curr->val);\\n                for (Node*& child: curr->children) {\\n                    Q.push(child);\\n                }\\n            }\\n            result.emplace_back(level);\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458888,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        queue<Node*>q;\\n        vector<vector<int>> ans;\\n        if(!root) return ans;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size=q.size();\\n            vector<int>temp;\\n            while(size--){\\n                Node *curr=q.front();\\n                temp.push_back(curr->val);\\n                q.pop();\\n                for(int i=0;i<curr->children.size();i++){\\n                    q.push(curr->children[i]);\\n                }\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        if not root:\\n            return []\\n        result = collections.defaultdict(list)\\n        def helper(node, level):\\n            if not node:\\n                return\\n            result[level].append(node.val)\\n            for child in node.children:\\n                helper(child, level+1)\\n        helper(root, 0)\\n        return result.values()\\n```\\n\\n```Java []\\nclass Solution {\\n    List<List<Integer>> res;\\n    void solve(Node cur, int level){\\n        if(cur == null)\\n            return ;\\n        if(level >= res.size()){\\n            res.add(new ArrayList<Integer>());\\n        }\\n        res.get(level).add(cur.val);\\n        for(int i=0;i<cur.children.size();i++){\\n            solve(cur.children.get(i), level+1);\\n        }\\n    }\\n    public List<List<Integer>> levelOrder(Node root) {\\n        res = new ArrayList<>();\\n        solve(root, 0);\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        queue<Node*>q;\\n        vector<vector<int>> ans;\\n        if(!root) return ans;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size=q.size();\\n            vector<int>temp;\\n            while(size--){\\n                Node *curr=q.front();\\n                temp.push_back(curr->val);\\n                q.pop();\\n                for(int i=0;i<curr->children.size();i++){\\n                    q.push(curr->children[i]);\\n                }\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def levelOrder(self, root: \\'Node\\') -> List[List[int]]:\\n        if not root:\\n            return []\\n        result = collections.defaultdict(list)\\n        def helper(node, level):\\n            if not node:\\n                return\\n            result[level].append(node.val)\\n            for child in node.children:\\n                helper(child, level+1)\\n        helper(root, 0)\\n        return result.values()\\n```\n```Java []\\nclass Solution {\\n    List<List<Integer>> res;\\n    void solve(Node cur, int level){\\n        if(cur == null)\\n            return ;\\n        if(level >= res.size()){\\n            res.add(new ArrayList<Integer>());\\n        }\\n        res.get(level).add(cur.val);\\n        for(int i=0;i<cur.children.size();i++){\\n            solve(cur.children.get(i), level+1);\\n        }\\n    }\\n    public List<List<Integer>> levelOrder(Node root) {\\n        res = new ArrayList<>();\\n        solve(root, 0);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240303,
                "title": "c-accepted-easy-to-understand",
                "content": "```\\npublic class Solution {\\n    public IList<IList<int>> LevelOrder(Node root) {\\n        IList<IList<int>> ans=new List<IList<int>>();\\n        if(root==null)\\n            return ans;\\n        Queue<Node> q = new();\\n        q.Enqueue(root);\\n        while(q.Count != 0){\\n            List<int> tmp = new();\\n            int count = q.Count;\\n            while(count>0){\\n                Node node = q.Dequeue();\\n                foreach(var child in node.children)\\n                    q.Enqueue(child);\\n                tmp.Add(node.val);\\n                count--;\\n            }\\n            ans.Add(tmp);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> LevelOrder(Node root) {\\n        IList<IList<int>> ans=new List<IList<int>>();\\n        if(root==null)\\n            return ans;\\n        Queue<Node> q = new();\\n        q.Enqueue(root);\\n        while(q.Count != 0){\\n            List<int> tmp = new();\\n            int count = q.Count;\\n            while(count>0){\\n                Node node = q.Dequeue();\\n                foreach(var child in node.children)\\n                    q.Enqueue(child);\\n                tmp.Add(node.val);\\n                count--;\\n            }\\n            ans.Add(tmp);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160915,
                "title": "c-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\tvector<vector<int>> levelOrder(Node* root) {\\n\\t\\tvector<vector<int>> ans;\\n\\t\\tif(root == NULL) return ans;\\n\\t\\tqueue<Node*> q;                      \\n\\t\\tq.push(root);\\n\\t\\twhile(!q.empty()){\\n\\t\\t\\tint n = q.size();\\n\\t\\t\\tvector<int> temp;\\n\\t\\t\\twhile(n--){                                  \\n\\t\\t\\t\\tNode* nodeX = q.front();\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\ttemp.push_back(nodeX->val);\\n\\t\\t\\t\\tfor(auto it : nodeX->children){            \\n\\t\\t\\t\\t\\tif(it != NULL) q.push(it);\\n\\t\\t\\t\\t}   \\n\\t\\t\\t}\\n\\t\\t\\tans.push_back(temp);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tvector<vector<int>> levelOrder(Node* root) {\\n\\t\\tvector<vector<int>> ans;\\n\\t\\tif(root == NULL) return ans;\\n\\t\\tqueue<Node*> q;                      \\n\\t\\tq.push(root);\\n\\t\\twhile(!q.empty()){\\n\\t\\t\\tint n = q.size();\\n\\t\\t\\tvector<int> temp;\\n\\t\\t\\twhile(n--){                                  \\n\\t\\t\\t\\tNode* nodeX = q.front();\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\ttemp.push_back(nodeX->val);\\n\\t\\t\\t\\tfor(auto it : nodeX->children){            \\n\\t\\t\\t\\t\\tif(it != NULL) q.push(it);\\n\\t\\t\\t\\t}   \\n\\t\\t\\t}\\n\\t\\t\\tans.push_back(temp);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090526,
                "title": "simple-binary-tree-level-order-traversal",
                "content": "//Please Upvote if you like the approach \\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        if(!root){\\n            return {};\\n        }\\n        vector<vector<int>>result;\\n        queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            vector<int>temp;\\n            int n=q.size();\\n            for(int i=0;i<n;i++){\\n                Node *curr=q.front();\\n                q.pop();\\n                temp.push_back(curr->val);\\n                int len=curr->children.size();\\n                for(int i=0;i<len;i++){\\n                    q.push(curr->children[i]);\\n                }\\n            }\\n            result.push_back(temp);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        if(!root){\\n            return {};\\n        }\\n        vector<vector<int>>result;\\n        queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            vector<int>temp;\\n            int n=q.size();\\n            for(int i=0;i<n;i++){\\n                Node *curr=q.front();\\n                q.pop();\\n                temp.push_back(curr->val);\\n                int len=curr->children.size();\\n                for(int i=0;i<len;i++){\\n                    q.push(curr->children[i]);\\n                }\\n            }\\n            result.push_back(temp);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3063773,
                "title": "easy-beginner-friendly-c-approach-bfs-n-time",
                "content": "\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        if(!root)return {};\\n        vector<vector<int>>res;\\n        queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            vector<int>temp;\\n            int n=q.size();\\n            for(int i=0;i<n;i++){\\n                Node*curr=q.front();\\n                temp.push_back(curr->val);\\n                q.pop();\\n                int len=curr->children.size();\\n                for(int i=0;i<len;i++){\\n                    q.push(curr->children[i]);\\n                }\\n\\n            }\\n            res.push_back(temp);\\n\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        if(!root)return {};\\n        vector<vector<int>>res;\\n        queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            vector<int>temp;\\n            int n=q.size();\\n            for(int i=0;i<n;i++){\\n                Node*curr=q.front();\\n                temp.push_back(curr->val);\\n                q.pop();\\n                int len=curr->children.size();\\n                for(int i=0;i<len;i++){\\n                    q.push(curr->children[i]);\\n                }\\n\\n            }\\n            res.push_back(temp);\\n\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046450,
                "title": "fast-js-simple-iterative-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSimply iterate over queue and also maintain level starting with 0;\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ as we are storing result\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * // Definition for a Node.\\n * function Node(val,children) {\\n *    this.val = val;\\n *    this.children = children;\\n * };\\n */\\n\\n/**\\n * @param {Node|null} root\\n * @return {number[][]}\\n */\\nvar levelOrder = function(root) {\\n    if (!root) return [];\\n\\n    let queue = [[root, 0]];\\n    let currentLevel = 0;\\n    let out = [[]];\\n\\n    while (queue.length != 0) {\\n\\n        let [elem, level] = queue.shift();\\n        if (level == currentLevel) {\\n            out[currentLevel].push(elem.val);\\n        } else {\\n            currentLevel++;\\n            out.push([elem.val]);\\n        }\\n        elem.left != null ? queue.push([elem.left, level + 1]): null;\\n        elem.right != null ? queue.push([elem.right, level + 1]): null;\\n\\n        \\n        for (let i = 0; i < elem.children.length; i++) {\\n            queue.push([elem.children[i], level + 1]);\\n        }\\n    }\\n    return out;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * // Definition for a Node.\\n * function Node(val,children) {\\n *    this.val = val;\\n *    this.children = children;\\n * };\\n */\\n\\n/**\\n * @param {Node|null} root\\n * @return {number[][]}\\n */\\nvar levelOrder = function(root) {\\n    if (!root) return [];\\n\\n    let queue = [[root, 0]];\\n    let currentLevel = 0;\\n    let out = [[]];\\n\\n    while (queue.length != 0) {\\n\\n        let [elem, level] = queue.shift();\\n        if (level == currentLevel) {\\n            out[currentLevel].push(elem.val);\\n        } else {\\n            currentLevel++;\\n            out.push([elem.val]);\\n        }\\n        elem.left != null ? queue.push([elem.left, level + 1]): null;\\n        elem.right != null ? queue.push([elem.right, level + 1]): null;\\n\\n        \\n        for (let i = 0; i < elem.children.length; i++) {\\n            queue.push([elem.children[i], level + 1]);\\n        }\\n    }\\n    return out;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3006398,
                "title": "java-dfs-map-optimized-from-7-ms-to-4-ms",
                "content": "# Solution 1 | 7 ms\\n```\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node node) {\\n        if (node == null) return new ArrayList<>();\\n        Map<Integer, List<Integer>> map = new TreeMap<>();\\n        traverseTree(node, map, 0);\\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int key : map.keySet()) {\\n            res.add(map.get(key));\\n        }\\n        return res;\\n    }\\n\\n    private void traverseTree(Node node, Map<Integer, List<Integer>> map, int lvl) {\\n        if (node == null) return;\\n\\n        lvl++;\\n\\n        List<Integer> list = map.get(lvl);\\n        if (list == null) {\\n            list = new ArrayList<>();\\n            list.add(node.val);\\n            map.put(lvl, list);\\n        } else list.add(node.val);\\n\\n        for (int i = 0; i < node.children.size(); i++) {\\n            Node child = node.children.get(i);\\n            traverseTree(child, map, lvl);\\n        }\\n    }\\n}\\n```\\n\\n# Solution 2 | 4 ms\\n```\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node node) {\\n        if (node == null) return new ArrayList<>();\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        traverseTree(node, map, 0);\\n        List<Integer> keys = new ArrayList<>(map.keySet());\\n        Collections.sort(keys);\\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int key : keys) {\\n            res.add(map.get(key));\\n        }\\n        return res;\\n    }\\n\\n    private void traverseTree(Node node, Map<Integer, List<Integer>> map, int lvl) {\\n        if (node == null) return;\\n\\n        lvl++;\\n\\n        List<Integer> list = map.get(lvl);\\n        if (list == null) {\\n            list = new ArrayList<>();\\n            list.add(node.val);\\n            map.put(lvl, list);\\n        } else list.add(node.val);\\n\\n        for (int i = 0; i < node.children.size(); i++) {\\n            Node child = node.children.get(i);\\n            traverseTree(child, map, lvl);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node node) {\\n        if (node == null) return new ArrayList<>();\\n        Map<Integer, List<Integer>> map = new TreeMap<>();\\n        traverseTree(node, map, 0);\\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int key : map.keySet()) {\\n            res.add(map.get(key));\\n        }\\n        return res;\\n    }\\n\\n    private void traverseTree(Node node, Map<Integer, List<Integer>> map, int lvl) {\\n        if (node == null) return;\\n\\n        lvl++;\\n\\n        List<Integer> list = map.get(lvl);\\n        if (list == null) {\\n            list = new ArrayList<>();\\n            list.add(node.val);\\n            map.put(lvl, list);\\n        } else list.add(node.val);\\n\\n        for (int i = 0; i < node.children.size(); i++) {\\n            Node child = node.children.get(i);\\n            traverseTree(child, map, lvl);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node node) {\\n        if (node == null) return new ArrayList<>();\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        traverseTree(node, map, 0);\\n        List<Integer> keys = new ArrayList<>(map.keySet());\\n        Collections.sort(keys);\\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int key : keys) {\\n            res.add(map.get(key));\\n        }\\n        return res;\\n    }\\n\\n    private void traverseTree(Node node, Map<Integer, List<Integer>> map, int lvl) {\\n        if (node == null) return;\\n\\n        lvl++;\\n\\n        List<Integer> list = map.get(lvl);\\n        if (list == null) {\\n            list = new ArrayList<>();\\n            list.add(node.val);\\n            map.put(lvl, list);\\n        } else list.add(node.val);\\n\\n        for (int i = 0; i < node.children.size(); i++) {\\n            Node child = node.children.get(i);\\n            traverseTree(child, map, lvl);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2905579,
                "title": "java-o-n-solution-using-bfs",
                "content": "# Complexity\\n- Time complexity: O(n) where n is the number of nodes.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(root);\\n        List<List<Integer>> answer = new ArrayList<>();\\n        while(!queue.isEmpty()) {\\n            int level = queue.size();\\n            List<Integer> levelNodes = new ArrayList<>();\\n            for(int i = 0; i < level; i++) {\\n                Node node = queue.poll();\\n                if (node != null) {\\n                    levelNodes.add(node.val);\\n                    List<Node> children = node.children;\\n                    if (!children.isEmpty()) {\\n                        for(Node child: children) {\\n                            queue.add(child);\\n                        }\\n                    }\\n                }\\n            }\\n            if (!levelNodes.isEmpty()) {\\n                answer.add(levelNodes);\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(root);\\n        List<List<Integer>> answer = new ArrayList<>();\\n        while(!queue.isEmpty()) {\\n            int level = queue.size();\\n            List<Integer> levelNodes = new ArrayList<>();\\n            for(int i = 0; i < level; i++) {\\n                Node node = queue.poll();\\n                if (node != null) {\\n                    levelNodes.add(node.val);\\n                    List<Node> children = node.children;\\n                    if (!children.isEmpty()) {\\n                        for(Node child: children) {\\n                            queue.add(child);\\n                        }\\n                    }\\n                }\\n            }\\n            if (!levelNodes.isEmpty()) {\\n                answer.add(levelNodes);\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891350,
                "title": "java-easy-understanding-bfs-arraydeque",
                "content": "**Please Upvote if you found it helpful !\\nThanks in advance !**\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLevel by level by queue size\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBreadth first Search Using Array Deque\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n         List<List<Integer>> ret=new ArrayList<>();\\n        if(root==null)\\n        return ret;\\n        \\n\\n        ArrayDeque<Node> dq=new ArrayDeque<>();\\n        dq.add(root);\\n        \\n        while(!dq.isEmpty())\\n        {\\n            int size=dq.size();\\n            \\n            ArrayList<Integer> al=new ArrayList<>();\\n            for(int i=0;i<size;i++)\\n            {\\n                Node t=dq.removeFirst();\\n                for(int j=0;j<t.children.size();j++)\\n                {\\n                    dq.addLast(t.children.get(j));\\n                }\\n                al.add(t.val);\\n\\n            }\\n\\n            System.out.println(ret);\\n            if(al.size()!=0)\\n            ret.add(al);\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n         List<List<Integer>> ret=new ArrayList<>();\\n        if(root==null)\\n        return ret;\\n        \\n\\n        ArrayDeque<Node> dq=new ArrayDeque<>();\\n        dq.add(root);\\n        \\n        while(!dq.isEmpty())\\n        {\\n            int size=dq.size();\\n            \\n            ArrayList<Integer> al=new ArrayList<>();\\n            for(int i=0;i<size;i++)\\n            {\\n                Node t=dq.removeFirst();\\n                for(int j=0;j<t.children.size();j++)\\n                {\\n                    dq.addLast(t.children.get(j));\\n                }\\n                al.add(t.val);\\n\\n            }\\n\\n            System.out.println(ret);\\n            if(al.size()!=0)\\n            ret.add(al);\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816783,
                "title": "java-2-ms-faster-than-96-65",
                "content": "If you like it pls upvote\\n\\n![image](https://assets.leetcode.com/users/images/f4c2a782-7e75-4e3b-83f2-eb3e8d28d80f_1668506599.9274304.png)\\n\\n\\n```\\n\\n\\n  public List<List<Integer>> levelOrder(Node root) {\\n   List<List<Integer>> result = new ArrayList<>();\\n   if (root == null) return result;\\n   Queue<Node> queue = new LinkedList<>();\\n   queue.add(root);\\n\\n   int flour = 0;\\n\\n   while (!queue.isEmpty()) {\\n\\n     if (flour == 0) {\\n      Node node = queue.poll();\\n\\n      result.add(new ArrayList<>());\\n      result.get(flour).add(node.val);\\n\\n      for (int i = 0; i < node.children.size(); i++) {\\n        if (node.children.get(i) != null) {\\n         queue.add(node.children.get(i));\\n        }\\n      }\\n\\n     } else {\\n      result.add(new ArrayList<>());\\n      int size = queue.size();\\n\\n      for (int i = 0; i < size; i++) {\\n\\n       Node node = queue.poll();\\n       result.get(flour).add(node.val);\\n\\n       if (node.children != null) {\\n         for (int j = 0; j < node.children.size(); j++) {\\n          queue.add(node.children.get(j));\\n         }\\n       }\\n\\n      }\\n     }\\n     flour++;\\n   }\\n   return result;\\n  }\\n\\n```",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\n\\n\\n  public List<List<Integer>> levelOrder(Node root) {\\n   List<List<Integer>> result = new ArrayList<>();\\n   if (root == null) return result;\\n   Queue<Node> queue = new LinkedList<>();\\n   queue.add(root);\\n\\n   int flour = 0;\\n\\n   while (!queue.isEmpty()) {\\n\\n     if (flour == 0) {\\n      Node node = queue.poll();\\n\\n      result.add(new ArrayList<>());\\n      result.get(flour).add(node.val);\\n\\n      for (int i = 0; i < node.children.size(); i++) {\\n        if (node.children.get(i) != null) {\\n         queue.add(node.children.get(i));\\n        }\\n      }\\n\\n     } else {\\n      result.add(new ArrayList<>());\\n      int size = queue.size();\\n\\n      for (int i = 0; i < size; i++) {\\n\\n       Node node = queue.poll();\\n       result.get(flour).add(node.val);\\n\\n       if (node.children != null) {\\n         for (int j = 0; j < node.children.size(); j++) {\\n          queue.add(node.children.get(j));\\n         }\\n       }\\n\\n      }\\n     }\\n     flour++;\\n   }\\n   return result;\\n  }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2732069,
                "title": "c-queue-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> ans;\\n        if(!root) return ans;\\n        queue<Node*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        while(!q.empty()){\\n            vector<int> temp;\\n            while(q.front()){\\n                Node*curr = q.front();\\n                q.pop();\\n                temp.emplace_back(curr->val);\\n                for(auto it : curr->children){\\n                    q.push(it);\\n                }\\n            }\\n            ans.emplace_back(temp);\\n            q.pop();\\n            q.push(NULL);\\n            if(q.front() == NULL) break;\\n        }\\n        return ans;\\n        \\n    }\\n\\t/* If you like the solution then please upvote */\\n};\\n```\\nIf you like the solution then please upvote",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> ans;\\n        if(!root) return ans;\\n        queue<Node*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        while(!q.empty()){\\n            vector<int> temp;\\n            while(q.front()){\\n                Node*curr = q.front();\\n                q.pop();\\n                temp.emplace_back(curr->val);\\n                for(auto it : curr->children){\\n                    q.push(it);\\n                }\\n            }\\n            ans.emplace_back(temp);\\n            q.pop();\\n            q.push(NULL);\\n            if(q.front() == NULL) break;\\n        }\\n        return ans;\\n        \\n    }\\n\\t/* If you like the solution then please upvote */\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2582946,
                "title": "java-easy-solution",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        if (root==null){\\n            return res;\\n        }\\n        Queue<Node> q = new LinkedList<Node>();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            List<Integer> cur = new ArrayList<>();\\n            int size = q.size();\\n            for (int i = 0; i<size; i++){\\n                Node temp = q.poll();\\n                cur.add(temp.val);\\n                for (Node child : temp.children){\\n                    q.add(child);\\n                }\\n            }\\n            res.add(cur);\\n        }\\n        return res;\\n    }\\n}\\n```\\n# upvote if u found it useful",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public List<List<Integer>> levelOrder(Node root) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        if (root==null){\\n            return res;\\n        }\\n        Queue<Node> q = new LinkedList<Node>();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            List<Integer> cur = new ArrayList<>();\\n            int size = q.size();\\n            for (int i = 0; i<size; i++){\\n                Node temp = q.poll();\\n                cur.add(temp.val);\\n                for (Node child : temp.children){\\n                    q.add(child);\\n                }\\n            }\\n            res.add(cur);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2546410,
                "title": "n-ary-tree-level-order-traversal-easiest-js-solution-with-explanation",
                "content": "Here\\'s my approach to solve this problem, I hope that would help ! :)\\n\\n=> save node\\'s children in a temporary array and when the queue is empty, which means we iterated through all the nodes of the preceding level, at this time we could push these children nodes to the queue and add their values to the result array an so on...\\n\\n```\\nvar levelOrder = function(root) {\\n    if(root == null) return [];\\n    let queue = [root];\\n    let levelNodes = [];\\n    let result = [];\\n    result.push([root.val]);\\n    \\n    while(queue.length > 0) {\\n        let element = queue.shift();\\n        \\n        \\n        for(let i = 0; i < element.children.length; i++) {\\n            levelNodes.push(element.children[i]);\\n        }\\n        \\n        if(queue.length == 0) {\\n            if(levelNodes.length != 0) {\\n                let levels = levelNodes.map(element => element.val);\\n                queue = [...levelNodes];\\n                result.push(levels);\\n                levelNodes = [];\\n            }\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar levelOrder = function(root) {\\n    if(root == null) return [];\\n    let queue = [root];\\n    let levelNodes = [];\\n    let result = [];\\n    result.push([root.val]);\\n    \\n    while(queue.length > 0) {\\n        let element = queue.shift();\\n        \\n        \\n        for(let i = 0; i < element.children.length; i++) {\\n            levelNodes.push(element.children[i]);\\n        }\\n        \\n        if(queue.length == 0) {\\n            if(levelNodes.length != 0) {\\n                let levels = levelNodes.map(element => element.val);\\n                queue = [...levelNodes];\\n                result.push(levels);\\n                levelNodes = [];\\n            }\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2542980,
                "title": "n-ary-tree-level-order-traversal-go-bfs-time-o-n-space-o-n",
                "content": "```go\\nfunc levelOrder(root *Node) [][]int {\\n    \\n    if root == nil {\\n        return nil\\n    }\\n    \\n    var levels [][]int\\n    \\n    queue := list.New()\\n    queue.PushBack(root)\\n    \\n    for queue.Len() > 0 {\\n        \\n        level := make([]int, 0, queue.Len())\\n        \\n        for i := queue.Len(); i > 0; i-- {\\n            \\n            cur := queue.Remove(queue.Front()).(*Node)\\n            level = append(level, cur.Val)\\n            \\n            for _, child := range cur.Children {\\n                queue.PushBack(child)\\n            }\\n        }\\n        \\n        levels = append(levels, level)\\n    }\\n    \\n    return levels\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Breadth-First Search"
                ],
                "code": "```go\\nfunc levelOrder(root *Node) [][]int {\\n    \\n    if root == nil {\\n        return nil\\n    }\\n    \\n    var levels [][]int\\n    \\n    queue := list.New()\\n    queue.PushBack(root)\\n    \\n    for queue.Len() > 0 {\\n        \\n        level := make([]int, 0, queue.Len())\\n        \\n        for i := queue.Len(); i > 0; i-- {\\n            \\n            cur := queue.Remove(queue.Front()).(*Node)\\n            level = append(level, cur.Val)\\n            \\n            for _, child := range cur.Children {\\n                queue.PushBack(child)\\n            }\\n        }\\n        \\n        levels = append(levels, level)\\n    }\\n    \\n    return levels\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2537034,
                "title": "python-explained-beats-98-without-deque-but-with-the-same-idea",
                "content": "If you find my post helpful, please upvote. Thanks!\\n\\n```\\ndef levelOrder(self, root: Node) -> List[List[int]]:\\n\\t# create the queue and the resulting list\\n\\tqueue = [root] if root else None\\n\\tresult = []\\n\\t# now until the queue is empty\\n\\twhile queue:\\n\\t\\t# create the next level queue and list for this level values\\n\\t\\tq, level = [], []\\n\\t\\t# for every node in queue\\n\\t\\tfor node in queue:\\n\\t\\t\\t# append its value to the line list\\n\\t\\t\\tlevel.append(node.val)\\n\\t\\t\\t# and if the node have children\\n\\t\\t\\tif node.children:\\n\\t\\t\\t\\t# add them to the next queue\\n\\t\\t\\t\\tq.extend(node.children)\\n\\t\\t# add the line list to the resulting list\\n\\t\\tresult.append(level)\\n\\t\\t# and after we recursively perform the same operation for the next level queue\\n\\t\\tqueue = q\\n\\treturn result\\n```\\n\\nAnd if you like numbers, here it is:\\n![image](https://assets.leetcode.com/users/images/5b5c20d5-af81-44fd-ae27-b76e0afd3b26_1662420228.0288486.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef levelOrder(self, root: Node) -> List[List[int]]:\\n\\t# create the queue and the resulting list\\n\\tqueue = [root] if root else None\\n\\tresult = []\\n\\t# now until the queue is empty\\n\\twhile queue:\\n\\t\\t# create the next level queue and list for this level values\\n\\t\\tq, level = [], []\\n\\t\\t# for every node in queue\\n\\t\\tfor node in queue:\\n\\t\\t\\t# append its value to the line list\\n\\t\\t\\tlevel.append(node.val)\\n\\t\\t\\t# and if the node have children\\n\\t\\t\\tif node.children:\\n\\t\\t\\t\\t# add them to the next queue\\n\\t\\t\\t\\tq.extend(node.children)\\n\\t\\t# add the line list to the resulting list\\n\\t\\tresult.append(level)\\n\\t\\t# and after we recursively perform the same operation for the next level queue\\n\\t\\tqueue = q\\n\\treturn result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2536802,
                "title": "easy-solution-java-explaination-comments",
                "content": "### **If you find it helpfull please upvote**\\n\\n```\\nclass Solution {\\n\\n        //Simple BFS question..\\n        List<List<Integer>>result = new ArrayList<>();\\n    \\n    public List<List<Integer>> levelOrder(Node root) {\\n\\n        if(root == null) return result;\\n\\n        // WE need a Queue.\\n        \\n        Queue<Node>queue = new LinkedList<>();\\n\\n        queue.offer(root);\\n        \\n        while(!queue.isEmpty()){\\n            //list to store the temperary list..\\n       List<Integer>temp = new ArrayList<>();\\n //present length of the queue so that we need to traverse that length.\\n         int n = queue.size();   \\n            \\n            for(int i=0;i<n;i++){\\n                // adding value to the temp list..\\n                Node nod = queue.poll();\\n                int val = nod.val;\\n                temp.add(val);\\n                \\n                // adding children to the queue if present..\\n                \\n                for(Node it:nod.children){\\n                    queue.offer(it);\\n                }\\n                \\n            }\\n            \\n            result.add(temp);\\n            \\n            \\n        }\\n        \\n        \\n        return result;\\n        \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n\\n        //Simple BFS question..\\n        List<List<Integer>>result = new ArrayList<>();\\n    \\n    public List<List<Integer>> levelOrder(Node root) {\\n\\n        if(root == null) return result;\\n\\n        // WE need a Queue.\\n        \\n        Queue<Node>queue = new LinkedList<>();\\n\\n        queue.offer(root);\\n        \\n        while(!queue.isEmpty()){\\n            //list to store the temperary list..\\n       List<Integer>temp = new ArrayList<>();\\n //present length of the queue so that we need to traverse that length.\\n         int n = queue.size();   \\n            \\n            for(int i=0;i<n;i++){\\n                // adding value to the temp list..\\n                Node nod = queue.poll();\\n                int val = nod.val;\\n                temp.add(val);\\n                \\n                // adding children to the queue if present..\\n                \\n                for(Node it:nod.children){\\n                    queue.offer(it);\\n                }\\n                \\n            }\\n            \\n            result.add(temp);\\n            \\n            \\n        }\\n        \\n        \\n        return result;\\n        \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2536792,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> res;\\n\\n        if (root != nullptr) {\\n            queue<Node*> Q;\\n            Q.push(root);\\n            int i = 0;\\n            while (!Q.empty()) {\\n                int m = Q.size();\\n                vector<int> tmp;\\n                for (int j {0}; j < m; j++) {\\n                    auto *cur = Q.front();\\n                    Q.pop();\\n                    for (int t {0}; t < cur->children.size(); t++) {\\n                        if (cur->children[t] != nullptr)\\n                            Q.push(cur->children[t]);\\n                    }\\n                    tmp.push_back(cur->val);\\n                }\\n\\n                res.push_back(tmp);\\n\\n                i++;\\n            }            \\n        }\\n\\n        \\n        return (res);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> res;\\n\\n        if (root != nullptr) {\\n            queue<Node*> Q;\\n            Q.push(root);\\n            int i = 0;\\n            while (!Q.empty()) {\\n                int m = Q.size();\\n                vector<int> tmp;\\n                for (int j {0}; j < m; j++) {\\n                    auto *cur = Q.front();\\n                    Q.pop();\\n                    for (int t {0}; t < cur->children.size(); t++) {\\n                        if (cur->children[t] != nullptr)\\n                            Q.push(cur->children[t]);\\n                    }\\n                    tmp.push_back(cur->val);\\n                }\\n\\n                res.push_back(tmp);\\n\\n                i++;\\n            }            \\n        }\\n\\n        \\n        return (res);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2536653,
                "title": "c-short-bfs-pair-node-int",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node * root) {\\n        vector<vector<int>> levelOrder;\\n        queue<pair<Node *,int>> q;\\n        \\n        if(root) q.emplace(root, 0);\\n        \\n        while(!q.empty()) {\\n            auto front = q.front(); q.pop();\\n            auto node = front.first;\\n            auto lvl = front.second, value = node->val;\\n            auto children = node->children;\\n            \\n            if(levelOrder.size() <= lvl) levelOrder.emplace_back();\\n            \\n            levelOrder[lvl].push_back(value);\\n            \\n            for(auto child: children) q.emplace(child, lvl+1);\\n        }\\n        \\n        return levelOrder;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node * root) {\\n        vector<vector<int>> levelOrder;\\n        queue<pair<Node *,int>> q;\\n        \\n        if(root) q.emplace(root, 0);\\n        \\n        while(!q.empty()) {\\n            auto front = q.front(); q.pop();\\n            auto node = front.first;\\n            auto lvl = front.second, value = node->val;\\n            auto children = node->children;\\n            \\n            if(levelOrder.size() <= lvl) levelOrder.emplace_back();\\n            \\n            levelOrder[lvl].push_back(value);\\n            \\n            for(auto child: children) q.emplace(child, lvl+1);\\n        }\\n        \\n        return levelOrder;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2536579,
                "title": "easy-bfs-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n  \\n    vector<vector<int>> levelOrder(Node* root) {\\n        \\n        vector<vector<int>>ans;\\n        if(root==NULL) return ans;\\n        queue<Node* >q;\\n        q.push(root);\\n        int count;\\n        vector<int>temp;\\n        while(q.size()!=0)\\n        {\\n            count=q.size();\\n            temp.clear();\\n            for(int i=0;i<count;i++)\\n            {\\n                 Node* t=q.front();\\n                q.pop();\\n                for(int i=0;i<t->children.size();i++)\\n                {q.push(t->children[i]);}\\n                temp.push_back(t->val);\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n    vector<vector<int>> levelOrder(Node* root) {\\n        \\n        vector<vector<int>>ans;\\n        if(root==NULL) return ans;\\n        queue<Node* >q;\\n        q.push(root);\\n        int count;\\n        vector<int>temp;\\n        while(q.size()!=0)\\n        {\\n            count=q.size();\\n            temp.clear();\\n            for(int i=0;i<count;i++)\\n            {\\n                 Node* t=q.front();\\n                q.pop();\\n                for(int i=0;i<t->children.size();i++)\\n                {q.push(t->children[i]);}\\n                temp.push_back(t->val);\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2536548,
                "title": "go-with-queue",
                "content": "### 1. If you want to use queue\\n\\n**DIY Queue interface**\\n\\n```go\\ntype Queue []interface{}\\n\\nfunc (q *Queue) IsEmpty() bool {\\n\\treturn q.Size() == 0\\n}\\n\\nfunc (q *Queue) Size() int {\\n\\treturn len(*q)\\n}\\n\\nfunc (q *Queue) Enqueue(d interface{}) {\\n\\t*q = append(*q, d)\\n}\\n\\nfunc (q *Queue) Dequeue() interface{} {\\n\\tif len(*q) == 0 {\\n\\t\\treturn nil\\n\\t}\\n\\thead := (*q)[0]\\n\\t*q = (*q)[1:]\\n\\treturn head\\n}\\n\\nfunc (q *Queue) Front() interface{} {\\n\\treturn (*q)[0]\\n}\\n```\\n\\n**Solution**\\n```go\\ntype Node struct {\\n\\tVal     interface{}\\n\\tChildren []*Node\\n}\\n\\nfunc levelOrder(root *Node) [][]int {\\n\\t//Handle cases when root is nil\\n\\tif root == nil {\\n\\t\\treturn [][]int{}\\n\\t}\\n\\n\\tvar q Queue\\n\\t//to consolidate results from all levels\\n\\tvar out [][]int\\n\\n\\t//First, enqueue root since this is the first node we will be looking at\\n\\tq.Enqueue(root)\\n\\n\\t//Continue as long as queue is not empty\\n\\tfor !q.IsEmpty() {\\n\\t\\t//to save results from the current level\\n\\t\\tvar levelRes []int\\n\\n\\t\\t//size of queue is the number of nodes on this level\\n\\t\\t//queue can be much larger than this because it consists of nodes from other levels\\n\\t\\tsize := len(q)\\n\\n\\t\\tfor i := 0; i < size; i++ {\\n\\t\\t\\t//Start looking from the front of the queue\\n\\t\\t\\ttop := q.Front().(*Node)\\n\\n\\t\\t\\t//Immediately push the current node value into the current level response\\n\\t\\t\\tlevelRes = append(levelRes, top.Val.(int))\\n\\n\\t\\t\\t//Next, start to look for the nodes on the next level below, i.e. the children\\n\\t\\t\\tfor i := 0; i < len(top.Children); i++ {\\n\\t\\t\\t\\t//For each child, pushes into the queue\\n\\t\\t\\t\\tq.Enqueue(top.Children[i])\\n\\t\\t\\t}\\n\\n\\t\\t\\t//We are done here, dequeue the current node and move on\\n\\t\\t\\tq.Dequeue()\\n\\t\\t}\\n\\n\\t\\t//Lastly, push the result of this level to the overall result slice\\n\\t\\tout = append(out, levelRes)\\n\\t}\\n\\treturn out\\n}\\n```\\n\\n### 2. Use slice\\n\\n```go\\nfunc levelOrder(root *Node) [][]int {\\n    if root == nil {\\n\\t\\treturn [][]int{}\\n\\t}\\n    \\n\\tvar q []*Node\\n\\tvar out [][]int\\n\\n    q = append(q,root)\\n    \\n    for len(q) != 0 {\\n\\t\\tvar levelRes []int\\n\\t\\tsize := len(q)\\n\\n\\t\\tfor i := 0; i < size; i++ {\\n\\t\\t\\t//Equivalent of queue.front()\\n\\t\\t\\ttop := q[0]\\n\\t\\t\\tlevelRes = append(levelRes, top.Val)\\n\\n\\t\\t\\tfor i := 0; i < len(top.Children); i++ {\\n                q = append(q, top.Children[i])\\n\\t\\t\\t}\\n\\t\\t\\t//Equivalent of queue.dequeue()\\n            q = q[1:]\\n\\t\\t}\\n\\t\\tout = append(out, levelRes)\\n\\t}\\n\\treturn out\\n}\\n```\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\ntype Queue []interface{}\\n\\nfunc (q *Queue) IsEmpty() bool {\\n\\treturn q.Size() == 0\\n}\\n\\nfunc (q *Queue) Size() int {\\n\\treturn len(*q)\\n}\\n\\nfunc (q *Queue) Enqueue(d interface{}) {\\n\\t*q = append(*q, d)\\n}\\n\\nfunc (q *Queue) Dequeue() interface{} {\\n\\tif len(*q) == 0 {\\n\\t\\treturn nil\\n\\t}\\n\\thead := (*q)[0]\\n\\t*q = (*q)[1:]\\n\\treturn head\\n}\\n\\nfunc (q *Queue) Front() interface{} {\\n\\treturn (*q)[0]\\n}\\n```\n```go\\ntype Node struct {\\n\\tVal     interface{}\\n\\tChildren []*Node\\n}\\n\\nfunc levelOrder(root *Node) [][]int {\\n\\t//Handle cases when root is nil\\n\\tif root == nil {\\n\\t\\treturn [][]int{}\\n\\t}\\n\\n\\tvar q Queue\\n\\t//to consolidate results from all levels\\n\\tvar out [][]int\\n\\n\\t//First, enqueue root since this is the first node we will be looking at\\n\\tq.Enqueue(root)\\n\\n\\t//Continue as long as queue is not empty\\n\\tfor !q.IsEmpty() {\\n\\t\\t//to save results from the current level\\n\\t\\tvar levelRes []int\\n\\n\\t\\t//size of queue is the number of nodes on this level\\n\\t\\t//queue can be much larger than this because it consists of nodes from other levels\\n\\t\\tsize := len(q)\\n\\n\\t\\tfor i := 0; i < size; i++ {\\n\\t\\t\\t//Start looking from the front of the queue\\n\\t\\t\\ttop := q.Front().(*Node)\\n\\n\\t\\t\\t//Immediately push the current node value into the current level response\\n\\t\\t\\tlevelRes = append(levelRes, top.Val.(int))\\n\\n\\t\\t\\t//Next, start to look for the nodes on the next level below, i.e. the children\\n\\t\\t\\tfor i := 0; i < len(top.Children); i++ {\\n\\t\\t\\t\\t//For each child, pushes into the queue\\n\\t\\t\\t\\tq.Enqueue(top.Children[i])\\n\\t\\t\\t}\\n\\n\\t\\t\\t//We are done here, dequeue the current node and move on\\n\\t\\t\\tq.Dequeue()\\n\\t\\t}\\n\\n\\t\\t//Lastly, push the result of this level to the overall result slice\\n\\t\\tout = append(out, levelRes)\\n\\t}\\n\\treturn out\\n}\\n```\n```go\\nfunc levelOrder(root *Node) [][]int {\\n    if root == nil {\\n\\t\\treturn [][]int{}\\n\\t}\\n    \\n\\tvar q []*Node\\n\\tvar out [][]int\\n\\n    q = append(q,root)\\n    \\n    for len(q) != 0 {\\n\\t\\tvar levelRes []int\\n\\t\\tsize := len(q)\\n\\n\\t\\tfor i := 0; i < size; i++ {\\n\\t\\t\\t//Equivalent of queue.front()\\n\\t\\t\\ttop := q[0]\\n\\t\\t\\tlevelRes = append(levelRes, top.Val)\\n\\n\\t\\t\\tfor i := 0; i < len(top.Children); i++ {\\n                q = append(q, top.Children[i])\\n\\t\\t\\t}\\n\\t\\t\\t//Equivalent of queue.dequeue()\\n            q = q[1:]\\n\\t\\t}\\n\\t\\tout = append(out, levelRes)\\n\\t}\\n\\treturn out\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2536460,
                "title": "c-bfs-easy-and-faster-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n      vector<vector<int>> ans;\\n        if(!root)return ans;\\n      queue<Node*> q;\\n        q.push(root);\\n        int lvl=1;\\n        while(!q.empty())\\n        {\\n        int sz=q.size();\\n        vector<int> temp;\\n        for(int i=0;i<sz;i++)\\n         {\\n            auto k=q.front();\\n            q.pop();\\n            temp.push_back(k->val);\\n            for(auto it:k->children)q.push(it);      \\n         }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n      vector<vector<int>> ans;\\n        if(!root)return ans;\\n      queue<Node*> q;\\n        q.push(root);\\n        int lvl=1;\\n        while(!q.empty())\\n        {\\n        int sz=q.size();\\n        vector<int> temp;\\n        for(int i=0;i<sz;i++)\\n         {\\n            auto k=q.front();\\n            q.pop();\\n            temp.push_back(k->val);\\n            for(auto it:k->children)q.push(it);      \\n         }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2536217,
                "title": "c-quick-and-simple-solution-using-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> ans;\\n        queue<Node* > q;\\n        if(root!=NULL)\\n        {\\n            q.push(root);    \\n        }\\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n            vector<int> temp;\\n            while(n--)\\n            {\\n                Node* curr = q.front();\\n                q.pop();\\n                temp.push_back(curr->val);\\n                for(int i=0;i<curr->children.size();i++)\\n                {\\n                    q.push(curr->children[i]);\\n                }\\n    \\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**PS: Kindly upvote if you like the solution.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> ans;\\n        queue<Node* > q;\\n        if(root!=NULL)\\n        {\\n            q.push(root);    \\n        }\\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n            vector<int> temp;\\n            while(n--)\\n            {\\n                Node* curr = q.front();\\n                q.pop();\\n                temp.push_back(curr->val);\\n                for(int i=0;i<curr->children.size();i++)\\n                {\\n                    q.push(curr->children[i]);\\n                }\\n    \\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2535710,
                "title": "cpp-solution-easy",
                "content": "~~~\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>>v;\\n        if(root==NULL)\\n        {\\n            return v;\\n        }\\n        \\n        queue<Node*>q;\\n        q.push(root);\\n        \\n        while(!q.empty())\\n        {\\n            int n=q.size();\\n            \\n            vector<int>temp;\\n            \\n            for(int i=0;i<n;i++)\\n            {\\n                Node * node = q.front();\\n                q.pop();\\n                temp.push_back(node->val);\\n                \\n                for(auto it: node->children)\\n                {\\n                    q.push(it);\\n                }\\n            }\\n            v.push_back(temp);\\n        }\\n        return v;\\n    }\\n};\\n~~~\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>>v;\\n        if(root==NULL)\\n        {\\n            return v;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2535586,
                "title": "super-simple-wicked-fast",
                "content": "***Logic?***\\n\\n*Well the question is pretty similar to normal Level Order Traversal of a tree. The only difference is that, instead of each Node having an attribute left and right for pointing to its children, they are rather stored in an **array named children**. So, we will simply use BFS with recursion until the children array has elements in it.*\\n\\n***The visual structure is as:***\\n\\n![image](https://assets.leetcode.com/users/images/0f95ab4a-872f-4c2a-aa6d-01257766bde6_1662395025.0755715.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        \\n        queue<Node*> que;\\n        \\n        vector<vector<int>> result;\\n        \\n        if(root == NULL) return result;\\n        \\n        que.push(root);\\n        \\n        while(!que.empty()){\\n            \\n            vector<int> level;\\n            int size = que.size();\\n            \\n            for(int i=0; i<size; i++){\\n                \\n                Node* temp = que.front();\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tque.pop();\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tlevel.push_back(temp->val);\\n\\t\\t\\t\\t\\n\\t\\t\\t    for(auto i : temp->children) que.push(i);\\n            \\n            }\\n            \\n            result.push_back(level);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/32b68407-02c8-4049-ad2c-90fc1931195b_1662394583.1446757.jpeg)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        \\n        queue<Node*> que;\\n        \\n        vector<vector<int>> result;\\n        \\n        if(root == NULL) return result;\\n        \\n        que.push(root);\\n        \\n        while(!que.empty()){\\n            \\n            vector<int> level;\\n            int size = que.size();\\n            \\n            for(int i=0; i<size; i++){\\n                \\n                Node* temp = que.front();\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tque.pop();\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tlevel.push_back(temp->val);\\n\\t\\t\\t\\t\\n\\t\\t\\t    for(auto i : temp->children) que.push(i);\\n            \\n            }\\n            \\n            result.push_back(level);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2535466,
                "title": "c-easy-solution-faster",
                "content": "please upvote if helpfull\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> res;\\n        if(!root)return res;\\n        \\n        queue<Node*> q;\\n        q.push(root);\\n        \\n        while(q.size()){\\n            vector<int> store;\\n            vector<Node*> v;                  // storing nodes of next level \\n            \\n            while(q.size()){                         //  At any moment ,all the nodes present in the queue will be of same level, so we take out all node of that level and store their children  \\n                 store.push_back(q.front()->val);\\n                 for(auto i : q.front()->children)v.push_back(i);\\n                 q.pop();  \\n            }\\n            \\n            for(auto i : v)q.push(i);                // when queue becomes empty , push in all nodes of the next level stored in v\\n            res.push_back(store);\\n            \\n        }\\n        \\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> res;\\n        if(!root)return res;\\n        \\n        queue<Node*> q;\\n        q.push(root);\\n        \\n        while(q.size()){\\n            vector<int> store;\\n            vector<Node*> v;                  // storing nodes of next level \\n            \\n            while(q.size()){                         //  At any moment ,all the nodes present in the queue will be of same level, so we take out all node of that level and store their children  \\n                 store.push_back(q.front()->val);\\n                 for(auto i : q.front()->children)v.push_back(i);\\n                 q.pop();  \\n            }\\n            \\n            for(auto i : v)q.push(i);                // when queue becomes empty , push in all nodes of the next level stored in v\\n            res.push_back(store);\\n            \\n        }\\n        \\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2535239,
                "title": "easy-solution-using-2-queues-and-using-1-queue",
                "content": "**2 Queues**\\n\\n\\'\\'\\'\\nclass Solution {\\n\\n    public List<List<Integer>> levelOrder(Node root) {\\n        \\n        List<List<Integer>> ans=new ArrayList<>();\\n        \\n        if(root==null)\\n            return ans;\\n        \\n        Queue<Node> q1=new LinkedList<>();\\n        Queue<Node> q2=new LinkedList<>();\\n        \\n        q1.add(root);\\n        \\n        while(!q1.isEmpty() || !q2.isEmpty()){\\n            List<Integer> sol=new ArrayList<>();\\n            \\n            while(!q1.isEmpty()){\\n                Node popped=q1.remove();\\n                sol.add(popped.val);\\n                int i=0;\\n                while(i<popped.children.size()){\\n                    q2.add(popped.children.get(i));\\n                    i++;\\n                }\\n            }\\n            \\n            if(sol.size()!=0){\\n                ans.add(sol);\\n                sol=new ArrayList<>();\\n            }\\n            \\n            while(!q2.isEmpty()){\\n                \\n                Node popped=q2.remove();\\n                sol.add(popped.val);\\n                int i=0;\\n                while(i<popped.children.size()){\\n                    q1.add(popped.children.get(i));\\n                    i++;\\n                }\\n            }\\n            if(sol.size()!=0)\\n                ans.add(sol);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\'\\'\\'\\n\\n**1 Queue**\\n\\nclass Solution {\\n\\n    public List<List<Integer>> levelOrder(Node root) {\\n        \\n        List<List<Integer>> ans=new ArrayList<>();\\n        \\n        if(root==null)\\n            return ans;\\n        \\n        Queue<Node> q=new LinkedList<>();\\n        \\n        q.add(root);\\n        \\n        while(!q.isEmpty()){\\n            List<Integer> sol=new ArrayList<>();\\n            \\n            int n=q.size();\\n            int i=0;\\n                    \\n            while(i<n){\\n                \\n                Node popped=q.remove();\\n                sol.add(popped.val);\\n                int j=0;\\n                while(j<popped.children.size()){\\n                    q.add(popped.children.get(j));\\n                    j++;\\n                }\\n                i++;\\n            }\\n            \\n            ans.add(sol);\\n        }\\n        \\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public List<List<Integer>> levelOrder(Node root) {\\n        \\n        List<List<Integer>> ans=new ArrayList<>();\\n        \\n        if(root==null)\\n            return ans;\\n        \\n        Queue<Node> q1=new LinkedList<>();\\n        Queue<Node> q2=new LinkedList<>();\\n        \\n        q1.add(root);\\n        \\n        while(!q1.isEmpty() || !q2.isEmpty()){\\n            List<Integer> sol=new ArrayList<>();\\n            \\n            while(!q1.isEmpty()){\\n                Node popped=q1.remove();\\n                sol.add(popped.val);\\n                int i=0;\\n                while(i<popped.children.size()){\\n                    q2.add(popped.children.get(i));\\n                    i++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2535232,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        \\n        vector<vector<int>> res;\\n        \\n        if(root==NULL)\\n            return res;\\n        \\n        queue<Node*> q;\\n        \\n        q.push(root);\\n        \\n        while(!q.empty()){\\n            int n=q.size();\\n            \\n            vector<int> tempRes;\\n            \\n            for(int i=0;i<n;i++){\\n                Node* temp=q.front();\\n                q.pop();\\n                tempRes.push_back(temp->val);\\n                for(auto child:temp->children){\\n                    if(child==NULL)\\n                        continue;\\n                    q.push(child);\\n                }\\n                \\n            }\\n            \\n            res.push_back(tempRes);\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n        \\n        vector<vector<int>> res;\\n        \\n        if(root==NULL)\\n            return res;\\n        \\n        queue<Node*> q;\\n        \\n        q.push(root);\\n        \\n        while(!q.empty()){\\n            int n=q.size();\\n            \\n            vector<int> tempRes;\\n            \\n            for(int i=0;i<n;i++){\\n                Node* temp=q.front();\\n                q.pop();\\n                tempRes.push_back(temp->val);\\n                for(auto child:temp->children){\\n                    if(child==NULL)\\n                        continue;\\n                    q.push(child);\\n                }\\n                \\n            }\\n            \\n            res.push_back(tempRes);\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2535142,
                "title": "c-bfs-solution-clean-concise",
                "content": "**Runtime: 23 ms, faster than 92.65% of C++ online submissions for N-ary Tree Level Order Traversal.\\nMemory Usage: 11.8 MB, less than 65.30% of C++ online submissions for N-ary Tree Level Order Traversal.**\\n```\\nvector<vector<int>> levelOrder(Node* root) {\\n\\tif(!root)return {};\\n\\tvector<vector<int>> res;\\n\\tqueue<Node*> q;\\n\\tq.push(root);\\n\\twhile(q.size()){\\n\\t\\tint sz=q.size();\\n\\t\\tvector<int> level;\\n\\t\\tfor(int i=0;i<sz;i++){\\n\\t\\t\\tNode* node=q.front();q.pop();\\n\\t\\t\\tlevel.push_back(node->val);\\n\\t\\t\\tfor(int i=0;i<node->children.size();i++){\\n\\t\\t\\t\\tq.push(node->children[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tres.push_back(level);\\n\\t}\\n\\treturn res;\\n}\\n```\\nKeep Coding and Please Do Upvote.",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nvector<vector<int>> levelOrder(Node* root) {\\n\\tif(!root)return {};\\n\\tvector<vector<int>> res;\\n\\tqueue<Node*> q;\\n\\tq.push(root);\\n\\twhile(q.size()){\\n\\t\\tint sz=q.size();\\n\\t\\tvector<int> level;\\n\\t\\tfor(int i=0;i<sz;i++){\\n\\t\\t\\tNode* node=q.front();q.pop();\\n\\t\\t\\tlevel.push_back(node->val);\\n\\t\\t\\tfor(int i=0;i<node->children.size();i++){\\n\\t\\t\\t\\tq.push(node->children[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tres.push_back(level);\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2535104,
                "title": "c-easy-to-understand",
                "content": "\\'\\'\\'\\t\\n\\t\\t\\t\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\t#include<queue>\\n\\t\\tvector<vector<int>> levelOrder(Node* root) {\\n\\t\\tvector<vector<int>> ans;\\n\\t\\tif(root==NULL) {\\n\\t\\t\\treturn ans;\\n\\t\\t}\\t\\t\\n        queue<Node*> q;\\n        \\n        q.push(root);\\n        \\n        vector<int> a;\\n        a.push_back(root->val);\\n        ans.push_back(a);\\n        \\n        while(!q.empty()) {\\n            int size=q.size();\\n            vector<int> a;\\n            while(size!=0) {\\n                Node* cur=q.front();\\n                q.pop();\\n                size--;\\n\\n                vector<Node*> c=cur->children;\\n                \\n                for(int i=0;i<c.size();i++) {\\n                    q.push(c[i]);\\n                    a.push_back(c[i]->val);\\n                }\\n            }\\n            if(a.size()!=0) {\\n                ans.push_back(a);\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n\\t};\\n\\n\\n\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\t#include<queue>\\n\\t\\tvector<vector<int>> levelOrder(Node* root) {\\n\\t\\tvector<vector<int>> ans;\\n\\t\\tif(root==NULL) {\\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "codeTag": "C++"
            }
        ],
        "discussions": [
            {
                "id": 1976474,
                "content": [
                    {
                        "username": "gpersonnat",
                        "content": "Should be an easy question"
                    },
                    {
                        "username": "lavlesh_15",
                        "content": "Think of BFS Binary Tree Level Order Traversal just slight change while putting Nodes in Queue.\\n\\nHappy Coding!!"
                    },
                    {
                        "username": "pyush98",
                        "content": "node.children is a list where node.children[0] is the first child."
                    },
                    {
                        "username": "ayushshuklas",
                        "content": "in c++ beats 92%\\n\\nclass Solution {\\npublic:\\nvector<vector<int>> vv;\\nvector<int> v;\\nqueue<Node*> s;\\nvoid f(Node* root)\\n{\\n     if(root == NULL)\\n         return;\\n         s.push(root);\\n        \\n           \\n         \\n         while(!s.empty())\\n         {\\n            \\n            int n = s.size();\\n         for(int i=0;i<n;i++)\\n         {\\n             \\n            \\n            v.push_back(s.front() -> val);\\n            \\n\\n            for(int i=0;i<(s.front() -> children.size());i++)\\n            s.push(s.front() -> children[i]);\\n            s.pop();\\n            \\n         }\\n         if(v.size() > 0)\\n         vv.push_back(v);\\n         v.clear();\\n         }\\n         \\n\\n}\\n    vector<vector<int>> levelOrder(Node* root)\\n     {\\n         f(root);\\n         return vv;\\n\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "kmukul0057",
                        "content": "hello !\\nIn my code I am getting error  \\ncan anyone please help me with this \\nclass Solution {\\npublic:\\n    void helper(Node * root, vector<int> &ds , vector<vector<int>> &ans)\\n    {\\n        if(root == NULL){\\n            return;\\n        }\\n\\n\\n        queue< Node* > pendingnode;\\n        pendingnode.push(root);\\n        ds.push_back(root->val);\\n        ans.push_back(ds);\\n        while( pendingnode.size() != 0){\\n            Node* front = pendingnode.front();\\n            pendingnode.pop();\\n            vector<int> temp;\\n            for(int i=0; i < front->children.size(); i++){\\n                pendingnode.push(front->children[i]);\\n                temp.push_back(front->children[i]->val);\\n            }\\n            if(temp.size()!= 0){\\n                ans.push_back(temp);\\n            }\\n            \\n        }\\n    }\\n\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        helper(root, ds, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Hkishan_ydv",
                        "content": "In your code,  which nodes at same level you are creating different vector for storing the children of each node .\\nbut u have to create only one vector ."
                    }
                ]
            },
            {
                "id": 1701760,
                "content": [
                    {
                        "username": "gpersonnat",
                        "content": "Should be an easy question"
                    },
                    {
                        "username": "lavlesh_15",
                        "content": "Think of BFS Binary Tree Level Order Traversal just slight change while putting Nodes in Queue.\\n\\nHappy Coding!!"
                    },
                    {
                        "username": "pyush98",
                        "content": "node.children is a list where node.children[0] is the first child."
                    },
                    {
                        "username": "ayushshuklas",
                        "content": "in c++ beats 92%\\n\\nclass Solution {\\npublic:\\nvector<vector<int>> vv;\\nvector<int> v;\\nqueue<Node*> s;\\nvoid f(Node* root)\\n{\\n     if(root == NULL)\\n         return;\\n         s.push(root);\\n        \\n           \\n         \\n         while(!s.empty())\\n         {\\n            \\n            int n = s.size();\\n         for(int i=0;i<n;i++)\\n         {\\n             \\n            \\n            v.push_back(s.front() -> val);\\n            \\n\\n            for(int i=0;i<(s.front() -> children.size());i++)\\n            s.push(s.front() -> children[i]);\\n            s.pop();\\n            \\n         }\\n         if(v.size() > 0)\\n         vv.push_back(v);\\n         v.clear();\\n         }\\n         \\n\\n}\\n    vector<vector<int>> levelOrder(Node* root)\\n     {\\n         f(root);\\n         return vv;\\n\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "kmukul0057",
                        "content": "hello !\\nIn my code I am getting error  \\ncan anyone please help me with this \\nclass Solution {\\npublic:\\n    void helper(Node * root, vector<int> &ds , vector<vector<int>> &ans)\\n    {\\n        if(root == NULL){\\n            return;\\n        }\\n\\n\\n        queue< Node* > pendingnode;\\n        pendingnode.push(root);\\n        ds.push_back(root->val);\\n        ans.push_back(ds);\\n        while( pendingnode.size() != 0){\\n            Node* front = pendingnode.front();\\n            pendingnode.pop();\\n            vector<int> temp;\\n            for(int i=0; i < front->children.size(); i++){\\n                pendingnode.push(front->children[i]);\\n                temp.push_back(front->children[i]->val);\\n            }\\n            if(temp.size()!= 0){\\n                ans.push_back(temp);\\n            }\\n            \\n        }\\n    }\\n\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        helper(root, ds, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Hkishan_ydv",
                        "content": "In your code,  which nodes at same level you are creating different vector for storing the children of each node .\\nbut u have to create only one vector ."
                    }
                ]
            },
            {
                "id": 1955772,
                "content": [
                    {
                        "username": "gpersonnat",
                        "content": "Should be an easy question"
                    },
                    {
                        "username": "lavlesh_15",
                        "content": "Think of BFS Binary Tree Level Order Traversal just slight change while putting Nodes in Queue.\\n\\nHappy Coding!!"
                    },
                    {
                        "username": "pyush98",
                        "content": "node.children is a list where node.children[0] is the first child."
                    },
                    {
                        "username": "ayushshuklas",
                        "content": "in c++ beats 92%\\n\\nclass Solution {\\npublic:\\nvector<vector<int>> vv;\\nvector<int> v;\\nqueue<Node*> s;\\nvoid f(Node* root)\\n{\\n     if(root == NULL)\\n         return;\\n         s.push(root);\\n        \\n           \\n         \\n         while(!s.empty())\\n         {\\n            \\n            int n = s.size();\\n         for(int i=0;i<n;i++)\\n         {\\n             \\n            \\n            v.push_back(s.front() -> val);\\n            \\n\\n            for(int i=0;i<(s.front() -> children.size());i++)\\n            s.push(s.front() -> children[i]);\\n            s.pop();\\n            \\n         }\\n         if(v.size() > 0)\\n         vv.push_back(v);\\n         v.clear();\\n         }\\n         \\n\\n}\\n    vector<vector<int>> levelOrder(Node* root)\\n     {\\n         f(root);\\n         return vv;\\n\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "kmukul0057",
                        "content": "hello !\\nIn my code I am getting error  \\ncan anyone please help me with this \\nclass Solution {\\npublic:\\n    void helper(Node * root, vector<int> &ds , vector<vector<int>> &ans)\\n    {\\n        if(root == NULL){\\n            return;\\n        }\\n\\n\\n        queue< Node* > pendingnode;\\n        pendingnode.push(root);\\n        ds.push_back(root->val);\\n        ans.push_back(ds);\\n        while( pendingnode.size() != 0){\\n            Node* front = pendingnode.front();\\n            pendingnode.pop();\\n            vector<int> temp;\\n            for(int i=0; i < front->children.size(); i++){\\n                pendingnode.push(front->children[i]);\\n                temp.push_back(front->children[i]->val);\\n            }\\n            if(temp.size()!= 0){\\n                ans.push_back(temp);\\n            }\\n            \\n        }\\n    }\\n\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        helper(root, ds, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Hkishan_ydv",
                        "content": "In your code,  which nodes at same level you are creating different vector for storing the children of each node .\\nbut u have to create only one vector ."
                    }
                ]
            },
            {
                "id": 1675453,
                "content": [
                    {
                        "username": "gpersonnat",
                        "content": "Should be an easy question"
                    },
                    {
                        "username": "lavlesh_15",
                        "content": "Think of BFS Binary Tree Level Order Traversal just slight change while putting Nodes in Queue.\\n\\nHappy Coding!!"
                    },
                    {
                        "username": "pyush98",
                        "content": "node.children is a list where node.children[0] is the first child."
                    },
                    {
                        "username": "ayushshuklas",
                        "content": "in c++ beats 92%\\n\\nclass Solution {\\npublic:\\nvector<vector<int>> vv;\\nvector<int> v;\\nqueue<Node*> s;\\nvoid f(Node* root)\\n{\\n     if(root == NULL)\\n         return;\\n         s.push(root);\\n        \\n           \\n         \\n         while(!s.empty())\\n         {\\n            \\n            int n = s.size();\\n         for(int i=0;i<n;i++)\\n         {\\n             \\n            \\n            v.push_back(s.front() -> val);\\n            \\n\\n            for(int i=0;i<(s.front() -> children.size());i++)\\n            s.push(s.front() -> children[i]);\\n            s.pop();\\n            \\n         }\\n         if(v.size() > 0)\\n         vv.push_back(v);\\n         v.clear();\\n         }\\n         \\n\\n}\\n    vector<vector<int>> levelOrder(Node* root)\\n     {\\n         f(root);\\n         return vv;\\n\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "kmukul0057",
                        "content": "hello !\\nIn my code I am getting error  \\ncan anyone please help me with this \\nclass Solution {\\npublic:\\n    void helper(Node * root, vector<int> &ds , vector<vector<int>> &ans)\\n    {\\n        if(root == NULL){\\n            return;\\n        }\\n\\n\\n        queue< Node* > pendingnode;\\n        pendingnode.push(root);\\n        ds.push_back(root->val);\\n        ans.push_back(ds);\\n        while( pendingnode.size() != 0){\\n            Node* front = pendingnode.front();\\n            pendingnode.pop();\\n            vector<int> temp;\\n            for(int i=0; i < front->children.size(); i++){\\n                pendingnode.push(front->children[i]);\\n                temp.push_back(front->children[i]->val);\\n            }\\n            if(temp.size()!= 0){\\n                ans.push_back(temp);\\n            }\\n            \\n        }\\n    }\\n\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        helper(root, ds, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Hkishan_ydv",
                        "content": "In your code,  which nodes at same level you are creating different vector for storing the children of each node .\\nbut u have to create only one vector ."
                    }
                ]
            },
            {
                "id": 1803935,
                "content": [
                    {
                        "username": "gpersonnat",
                        "content": "Should be an easy question"
                    },
                    {
                        "username": "lavlesh_15",
                        "content": "Think of BFS Binary Tree Level Order Traversal just slight change while putting Nodes in Queue.\\n\\nHappy Coding!!"
                    },
                    {
                        "username": "pyush98",
                        "content": "node.children is a list where node.children[0] is the first child."
                    },
                    {
                        "username": "ayushshuklas",
                        "content": "in c++ beats 92%\\n\\nclass Solution {\\npublic:\\nvector<vector<int>> vv;\\nvector<int> v;\\nqueue<Node*> s;\\nvoid f(Node* root)\\n{\\n     if(root == NULL)\\n         return;\\n         s.push(root);\\n        \\n           \\n         \\n         while(!s.empty())\\n         {\\n            \\n            int n = s.size();\\n         for(int i=0;i<n;i++)\\n         {\\n             \\n            \\n            v.push_back(s.front() -> val);\\n            \\n\\n            for(int i=0;i<(s.front() -> children.size());i++)\\n            s.push(s.front() -> children[i]);\\n            s.pop();\\n            \\n         }\\n         if(v.size() > 0)\\n         vv.push_back(v);\\n         v.clear();\\n         }\\n         \\n\\n}\\n    vector<vector<int>> levelOrder(Node* root)\\n     {\\n         f(root);\\n         return vv;\\n\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "kmukul0057",
                        "content": "hello !\\nIn my code I am getting error  \\ncan anyone please help me with this \\nclass Solution {\\npublic:\\n    void helper(Node * root, vector<int> &ds , vector<vector<int>> &ans)\\n    {\\n        if(root == NULL){\\n            return;\\n        }\\n\\n\\n        queue< Node* > pendingnode;\\n        pendingnode.push(root);\\n        ds.push_back(root->val);\\n        ans.push_back(ds);\\n        while( pendingnode.size() != 0){\\n            Node* front = pendingnode.front();\\n            pendingnode.pop();\\n            vector<int> temp;\\n            for(int i=0; i < front->children.size(); i++){\\n                pendingnode.push(front->children[i]);\\n                temp.push_back(front->children[i]->val);\\n            }\\n            if(temp.size()!= 0){\\n                ans.push_back(temp);\\n            }\\n            \\n        }\\n    }\\n\\n    vector<vector<int>> levelOrder(Node* root) {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        helper(root, ds, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Hkishan_ydv",
                        "content": "In your code,  which nodes at same level you are creating different vector for storing the children of each node .\\nbut u have to create only one vector ."
                    }
                ]
            }
        ]
    }
]