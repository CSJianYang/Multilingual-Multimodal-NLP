[
    {
        "title": "Binary Tree Inorder Traversal",
        "question_content": "Given the root of a binary tree, return the inorder traversal of its nodes' values.\n&nbsp;\nExample 1:\n\nInput: root = [1,null,2,3]\nOutput: [1,3,2]\n\nExample 2:\n\nInput: root = []\nOutput: []\n\nExample 3:\n\nInput: root = [1]\nOutput: [1]\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is in the range [0, 100].\n\t-100 <= Node.val <= 100\n\n&nbsp;\nFollow up: Recursive solution is trivial, could you do it iteratively?",
        "solutions": [
            {
                "id": 283746,
                "title": "all-dfs-traversals-preorder-inorder-postorder-in-python-in-1-line",
                "content": "![image](https://assets.leetcode.com/users/andvary/image_1556551007.png)\\n\\n```\\ndef preorder(root):\\n  return [root.val] + preorder(root.left) + preorder(root.right) if root else []\\n```\\n\\n```\\ndef inorder(root):\\n  return  inorder(root.left) + [root.val] + inorder(root.right) if root else []\\n```\\n\\n```\\ndef postorder(root):\\n  return  postorder(root.left) + postorder(root.right) + [root.val] if root else []\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ndef preorder(root):\\n  return [root.val] + preorder(root.left) + preorder(root.right) if root else []\\n```\n```\\ndef inorder(root):\\n  return  inorder(root.left) + [root.val] + inorder(root.right) if root else []\\n```\n```\\ndef postorder(root):\\n  return  postorder(root.left) + postorder(root.right) + [root.val] if root else []\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 31213,
                "title": "iterative-solution-in-java-simple-and-readable",
                "content": "    \\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<Integer>();\\n\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode cur = root;\\n\\n        while(cur!=null || !stack.empty()){\\n            while(cur!=null){\\n                stack.add(cur);\\n                cur = cur.left;\\n            }\\n            cur = stack.pop();\\n            list.add(cur.val);\\n            cur = cur.right;\\n        }\\n\\n        return list;\\n    }",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Iterator"
                ],
                "code": "    \\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<Integer>();\\n\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode cur = root;\\n\\n        while(cur!=null || !stack.empty()){\\n            while(cur!=null){\\n                stack.add(cur);\\n                cur = cur.left;\\n            }\\n            cur = stack.pop();\\n            list.add(cur.val);\\n            cur = cur.right;\\n        }\\n\\n        return list;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 31381,
                "title": "python-recursive-and-iterative-solutions",
                "content": "        \\n    # recursively\\n    def inorderTraversal1(self, root):\\n        res = []\\n        self.helper(root, res)\\n        return res\\n        \\n    def helper(self, root, res):\\n        if root:\\n            self.helper(root.left, res)\\n            res.append(root.val)\\n            self.helper(root.right, res)\\n     \\n    # iteratively       \\n    def inorderTraversal(self, root):\\n        res, stack = [], []\\n        while True:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            if not stack:\\n                return res\\n            node = stack.pop()\\n            res.append(node.val)\\n            root = node.right",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "        \\n    # recursively\\n    def inorderTraversal1(self, root):\\n        res = []\\n        self.helper(root, res)\\n        return res\\n        \\n    def helper(self, root, res):\\n        if root:\\n            self.helper(root.left, res)\\n            res.append(root.val)\\n            self.helper(root.right, res)\\n     \\n    # iteratively       \\n    def inorderTraversal(self, root):\\n        res, stack = [], []\\n        while True:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            if not stack:\\n                return res\\n            node = stack.pop()\\n            res.append(node.val)\\n            root = node.right",
                "codeTag": "Python3"
            },
            {
                "id": 3169549,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n    vector<int> ans;\\n    if (root == NULL) return ans;\\n    vector<int> left = inorderTraversal(root->left);\\n    ans.insert(ans.end(), left.begin(), left.end());\\n    ans.push_back(root->val);\\n    vector<int> right = inorderTraversal(root->right);\\n    ans.insert(ans.end(), right.begin(), right.end());\\n    return ans;\\n}\\n\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        st = []\\n        res = []\\n\\n        while root or st:\\n            while root:\\n                st.append(root)\\n                root = root.left\\n            \\n            root = st.pop()\\n            res.append(root.val)\\n\\n            root = root.right\\n        \\n        return res   \\n```\\n\\n```Java []\\nclass Solution {\\n    private List<Integer> res = new ArrayList<>();\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        traverse(root);\\n        return res;\\n    }\\n    \\n    private void traverse(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        traverse(root.left);\\n        res.add(root.val);\\n        traverse(root.right);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n    vector<int> ans;\\n    if (root == NULL) return ans;\\n    vector<int> left = inorderTraversal(root->left);\\n    ans.insert(ans.end(), left.begin(), left.end());\\n    ans.push_back(root->val);\\n    vector<int> right = inorderTraversal(root->right);\\n    ans.insert(ans.end(), right.begin(), right.end());\\n    return ans;\\n}\\n\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        st = []\\n        res = []\\n\\n        while root or st:\\n            while root:\\n                st.append(root)\\n                root = root.left\\n            \\n            root = st.pop()\\n            res.append(root.val)\\n\\n            root = root.right\\n        \\n        return res   \\n```\n```Java []\\nclass Solution {\\n    private List<Integer> res = new ArrayList<>();\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        traverse(root);\\n        return res;\\n    }\\n    \\n    private void traverse(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        traverse(root.left);\\n        res.add(root.val);\\n        traverse(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31231,
                "title": "c-iterative-recursive-and-morris",
                "content": "There are three solutions to this problem.\\n\\n 1. Iterative solution using stack: `O(n)` time and `O(n)` space;\\n 2. Recursive solution: `O(n)` time and `O(n)` space (function call stack);\\n 3. Morris traversal: `O(n)` time and `O(1)` space.\\n\\n**Iterative solution using stack**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        stack<TreeNode*> todo;\\n        while (root || !todo.empty()) {\\n            while (root) {\\n                todo.push(root);\\n                root = root -> left;\\n            }\\n            root = todo.top();\\n            todo.pop();\\n            nodes.push_back(root -> val);\\n            root = root -> right;\\n        }\\n        return nodes;\\n    }\\n};\\n```\\n\\n**Recursive solution**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        inorder(root, nodes);\\n        return nodes;\\n    }\\nprivate:\\n    void inorder(TreeNode* root, vector<int>& nodes) {\\n        if (!root) {\\n            return;\\n        }\\n        inorder(root -> left, nodes);\\n        nodes.push_back(root -> val);\\n        inorder(root -> right, nodes);\\n    }\\n};\\n```\\n\\n**Morris traversal**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        while (root) {\\n            if (root -> left) {\\n                TreeNode* pre = root -> left;\\n                while (pre -> right && pre -> right != root) {\\n                    pre = pre -> right;\\n                }\\n                if (!pre -> right) {\\n                    pre -> right = root;\\n                    root = root -> left;\\n                } else {\\n                    pre -> right = NULL;\\n                    nodes.push_back(root -> val);\\n                    root = root -> right;\\n                }\\n            } else {\\n                nodes.push_back(root -> val);\\n                root = root -> right;\\n            }\\n        }\\n        return nodes;\\n    }\\n};\\n```\\t\\t",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        stack<TreeNode*> todo;\\n        while (root || !todo.empty()) {\\n            while (root) {\\n                todo.push(root);\\n                root = root -> left;\\n            }\\n            root = todo.top();\\n            todo.pop();\\n            nodes.push_back(root -> val);\\n            root = root -> right;\\n        }\\n        return nodes;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        inorder(root, nodes);\\n        return nodes;\\n    }\\nprivate:\\n    void inorder(TreeNode* root, vector<int>& nodes) {\\n        if (!root) {\\n            return;\\n        }\\n        inorder(root -> left, nodes);\\n        nodes.push_back(root -> val);\\n        inorder(root -> right, nodes);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        while (root) {\\n            if (root -> left) {\\n                TreeNode* pre = root -> left;\\n                while (pre -> right && pre -> right != root) {\\n                    pre = pre -> right;\\n                }\\n                if (!pre -> right) {\\n                    pre -> right = root;\\n                    root = root -> left;\\n                } else {\\n                    pre -> right = NULL;\\n                    nodes.push_back(root -> val);\\n                    root = root -> right;\\n                }\\n            } else {\\n                nodes.push_back(root -> val);\\n                root = root -> right;\\n            }\\n        }\\n        return nodes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 713539,
                "title": "python-3-all-iterative-traversals-inorder-preorder-postorder-similar-solutions",
                "content": "[Python3] Pre, In, Post Iteratively Summarization\\nIn preorder, the order should be\\n\\nroot -> left -> right\\n\\nBut when we use stack, the order should be reversed:\\n\\nright -> left -> root\\n\\nPre\\n```\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        res, stack = [], [(root, False)]\\n        while stack:\\n            node, visited = stack.pop()  # the last element\\n            if node:\\n                if visited:  \\n                    res.append(node.val)\\n                else:  # preorder: root -> left -> right\\n                    stack.append((node.right, False))\\n                    stack.append((node.left, False))\\n                    stack.append((node, True))\\n        return res\\n```\\n\\n\\nIn inorder, the order should be\\nleft -> root -> right\\n\\nBut when we use stack, the order should be reversed:\\n\\nright -> root -> left\\n\\nIn\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        res, stack = [], [(root, False)]\\n        while stack:\\n            node, visited = stack.pop()  # the last element\\n            if node:\\n                if visited:\\n                    res.append(node.val)\\n                else:  # inorder: left -> root -> right\\n                    stack.append((node.right, False))\\n                    stack.append((node, True))\\n                    stack.append((node.left, False))\\n        return res\\n```\\t\\n\\n\\nIn postorder, the order should be\\nleft -> right -> root\\n\\nBut when we use stack, the order should be reversed:\\n\\nroot -> right -> left\\n\\nPost\\n```\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        res, stack = [], [(root, False)]\\n        while stack:\\n            node, visited = stack.pop()  # the last element\\n            if node:\\n                if visited:\\n                    res.append(node.val)\\n                else:  # postorder: left -> right -> root\\n                    stack.append((node, True))\\n                    stack.append((node.right, False))\\n                    stack.append((node.left, False))\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        res, stack = [], [(root, False)]\\n        while stack:\\n            node, visited = stack.pop()  # the last element\\n            if node:\\n                if visited:  \\n                    res.append(node.val)\\n                else:  # preorder: root -> left -> right\\n                    stack.append((node.right, False))\\n                    stack.append((node.left, False))\\n                    stack.append((node, True))\\n        return res\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        res, stack = [], [(root, False)]\\n        while stack:\\n            node, visited = stack.pop()  # the last element\\n            if node:\\n                if visited:\\n                    res.append(node.val)\\n                else:  # inorder: left -> root -> right\\n                    stack.append((node.right, False))\\n                    stack.append((node, True))\\n                    stack.append((node.left, False))\\n        return res\\n```\n```\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        res, stack = [], [(root, False)]\\n        while stack:\\n            node, visited = stack.pop()  # the last element\\n            if node:\\n                if visited:\\n                    res.append(node.val)\\n                else:  # postorder: left -> right -> root\\n                    stack.append((node, True))\\n                    stack.append((node.right, False))\\n                    stack.append((node.left, False))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328601,
                "title": "all-dfs-traversals-preorder-postorder-inorder-in-java-in-5-lines",
                "content": "![image](https://assets.leetcode.com/users/andvary/image_1556551007.png)\\n\\nPreorder: Node -> Left -> Right\\n\\n```\\npublic void preorder(TreeNode root, List<Integer> nums) {\\n  if (root == null) return;\\n  nums.add(root.val);\\n  preorder(root.left, nums);\\n  preorder(root.right, nums);\\n}\\n```\\n\\nInorder : Left -> Node -> Right\\n\\n```\\npublic void inorder(TreeNode root, List<Integer> nums) {\\n  if (root == null) return;\\n  inorder(root.left, nums);\\n  nums.add(root.val);\\n  inorder(root.right, nums);\\n}\\n```\\n\\nPostorder : Left -> Right -> Node\\n\\n```\\npublic void postorder(TreeNode root, List<Integer> nums) {\\n  if (root == null) return;\\n  postorder(root.left, nums);\\n  postorder(root.right, nums);\\n  nums.add(root.val);\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\npublic void preorder(TreeNode root, List<Integer> nums) {\\n  if (root == null) return;\\n  nums.add(root.val);\\n  preorder(root.left, nums);\\n  preorder(root.right, nums);\\n}\\n```\n```\\npublic void inorder(TreeNode root, List<Integer> nums) {\\n  if (root == null) return;\\n  inorder(root.left, nums);\\n  nums.add(root.val);\\n  inorder(root.right, nums);\\n}\\n```\n```\\npublic void postorder(TreeNode root, List<Integer> nums) {\\n  if (root == null) return;\\n  postorder(root.left, nums);\\n  postorder(root.right, nums);\\n  nums.add(root.val);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31232,
                "title": "three-methods-to-solve-c",
                "content": "Method 1: Using one stack and the binary tree node will be changed. Easy ,not Practical\\n\\n    class Solution {\\n    public:\\n        vector<int> inorderTraversal(TreeNode *root) {\\n            vector<int> vector;\\n            if(!root)\\n            return vector;\\n            stack<TreeNode *> stack;\\n            stack.push(root);\\n            while(!stack.empty())\\n            {\\n                TreeNode *pNode = stack.top();\\n                if(pNode->left)\\n                {\\n                    stack.push(pNode->left);\\n                    pNode->left = NULL;\\n                }\\n                else\\n                {\\n                    vector.push_back(pNode->val);\\n                    stack.pop();\\n                    if(pNode->right)\\n                    stack.push(pNode->right);\\n                }\\n            }\\n            return vector;\\n        }\\n    };\\n\\nMethod 2: Using one stack and one unordered_map, this will not changed the node. Better\\n\\n    class Solution {\\n    public:\\n        vector<int> inorderTraversal(TreeNode *root) {\\n            vector<int> vector;\\n            if(!root)\\n            return vector;\\n            unordered_map<TreeNode *, bool> map;//left child has been visited:true.\\n            stack<TreeNode *> stack;\\n            stack.push(root);\\n            while(!stack.empty())\\n            {\\n                TreeNode *pNode = stack.top();\\n                if(pNode->left && !map[pNode])\\n                {\\n                    stack.push(pNode->left);\\n                    map[pNode] = true;\\n                }\\n                else\\n                {\\n                    vector.push_back(pNode->val);\\n                    stack.pop();\\n                    if(pNode->right)\\n                    stack.push(pNode->right);\\n                }\\n            }\\n            return vector;\\n        }\\n    };\\n\\nMethod 3: Using one stack  and will not changed the node. Best(at least in this three solutions)\\n\\n    class Solution {\\n    public:\\n        vector<int> inorderTraversal(TreeNode *root) {\\n            vector<int> vector;\\n            stack<TreeNode *> stack;\\n            TreeNode *pCurrent = root;\\n            \\n            while(!stack.empty() || pCurrent)\\n            {\\n                if(pCurrent)\\n                {\\n                    stack.push(pCurrent);\\n                    pCurrent = pCurrent->left;\\n                }\\n                else\\n                {\\n                    TreeNode *pNode = stack.top();\\n                    vector.push_back(pNode->val);\\n                    stack.pop();\\n                    pCurrent = pNode->right;\\n                }\\n            }\\n            return vector;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> inorderTraversal(TreeNode *root) {\\n            vector<int> vector;\\n            if(!root)\\n            return vector;\\n            stack<TreeNode *> stack;\\n            stack.push(root);\\n            while(!stack.empty())\\n            {\\n                TreeNode *pNode = stack.top();\\n                if(pNode->left)\\n                {\\n                    stack.push(pNode->left);\\n                    pNode->left = NULL;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 31228,
                "title": "simple-python-iterative-solution-by-using-a-visited-flag-o-n-56ms",
                "content": "    # Definition for a binary tree node.\\n    # class TreeNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution:\\n        # @param {TreeNode} root\\n        # @return {integer[]}\\n        def inorderTraversal(self, root):\\n            result, stack = [], [(root, False)]\\n    \\n            while stack:\\n                cur, visited = stack.pop()\\n                if cur:\\n                    if visited:\\n                        result.append(cur.val)\\n                    else:\\n                        stack.append((cur.right, False))\\n                        stack.append((cur, True))\\n                        stack.append((cur.left, False))\\n    \\n            return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {TreeNode}",
                "codeTag": "Java"
            },
            {
                "id": 31394,
                "title": "javascript-solution-with-iteration",
                "content": "```js\\nfunction inorderTraversal(root) {\\n  const stack = [];\\n  const res = [];\\n\\n  while (root || stack.length) {\\n    if (root) {\\n      stack.push(root);\\n      root = root.left;\\n    } else {\\n      root = stack.pop();\\n      res.push(root.val);\\n      root = root.right;\\n    }\\n  }\\n\\n  return res;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nfunction inorderTraversal(root) {\\n  const stack = [];\\n  const res = [];\\n\\n  while (root || stack.length) {\\n    if (root) {\\n      stack.push(root);\\n      root = root.left;\\n    } else {\\n      root = stack.pop();\\n      res.push(root.val);\\n      root = root.right;\\n    }\\n  }\\n\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1377500,
                "title": "3-solutions-1-recursive-2-iterative-o-1-space-complexity-morris-traversal-explained-code",
                "content": "We can solve this problem in three ways lets 1st talk about he recursive method :\\n\\n**1st approach recursive**\\n\\n```\\nvoid helper(TreeNode* root,vector<int>& ans)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        helper(root->left,ans);\\n        ans.push_back(root->val);\\n        helper(root->right,ans);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        helper(root,ans);\\n        return ans;\\n            \\n    }\\n```\\n\\n\\nthis approach is pretty self explanitory and i don\\'t think it needs any explanation. \\n\\n\\n**2nd approach**\\n\\n\\nJust use a stack\\n\\n```\\n vector<int> v;\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> s;\\n        while(root||!s.empty()){\\n            if(root!=NULL){\\n                s.push(root);\\n                root=root->left;\\n            }\\n            else{\\n                root=s.top();\\n                s.pop();\\n                v.push_back(root->val);\\n                root=root->right;\\n            }\\n          }\\n         return v;\\n    }\\n```\\n\\nand keep the nodes in the stack and just perform the left and the right operation and then just pop the stack.\\n\\n\\n**3rd approach and the most optimised approach with T.C. O(n) and S.C O(1)**\\n\\nI have just used the morris-traversal technique.\\nIn this approach we don\\'t need to make any stack or vector we can just manipulate the leaf node and get the desired result.\\n\\nAfter a successful Morris approach your tree will look something like this\\n\\n**Before morris algorithm**\\n![image](https://assets.leetcode.com/users/images/92e256e9-9f11-42a8-bec7-5cfd020a5b7a_1627858941.954608.jpeg)\\n\\n**After morris algorithm**\\n![image](https://assets.leetcode.com/users/images/c91d5981-e57e-4cac-8a38-b8278b447f82_1627858986.5674217.jpeg)\\n\\n\\nso now we can just iterate our root which is at **4** and go till we get a null.\\n\\n\\n```\\nvector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        TreeNode* temp;\\n        while(root)\\n        {\\n            if(root->left)\\n            {\\n                temp=root->left;\\n                while(temp->right)\\n                {\\n                    temp=temp->right;\\n                }\\n                temp->right=root;\\n                temp=root->left;\\n                root->left=NULL;\\n                root=temp;\\n            }\\n            else\\n            {\\n                ans.push_back(root->val);\\n                root=root->right;\\n                \\n            }\\n        }\\n        return ans;\\n```\\n\\nThis is the code to implement this approach. Please comment down if you have any confusions.\\n\\n**Please consider upvoting if you liked my effort of explaining this problem this will give me motivation to upload more such solutions.**\\n\\n**#happy_coding**\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nvoid helper(TreeNode* root,vector<int>& ans)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        helper(root->left,ans);\\n        ans.push_back(root->val);\\n        helper(root->right,ans);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        helper(root,ans);\\n        return ans;\\n            \\n    }\\n```\n```\\n vector<int> v;\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> s;\\n        while(root||!s.empty()){\\n            if(root!=NULL){\\n                s.push(root);\\n                root=root->left;\\n            }\\n            else{\\n                root=s.top();\\n                s.pop();\\n                v.push_back(root->val);\\n                root=root->right;\\n            }\\n          }\\n         return v;\\n    }\\n```\n```\\nvector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        TreeNode* temp;\\n        while(root)\\n        {\\n            if(root->left)\\n            {\\n                temp=root->left;\\n                while(temp->right)\\n                {\\n                    temp=temp->right;\\n                }\\n                temp->right=root;\\n                temp=root->left;\\n                root->left=NULL;\\n                root=temp;\\n            }\\n            else\\n            {\\n                ans.push_back(root->val);\\n                root=root->right;\\n                \\n            }\\n        }\\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 148939,
                "title": "cpp-morris-traversal",
                "content": "# Morris Traversal ( Using Threaded Tree for Inorder Traversal)\\n> O(n) Time | O(1) Space\\n\\n## Definition Threaded Tree\\n\"A binary tree is threaded by making all right child pointers that would normally be null point to the inorder successor of the node (if it exists), and all left child pointers that would normally be null point to the inorder predecessor of the node.\\n\\n![Img](https://upload.wikimedia.org/wikipedia/commons/7/7a/Threaded_tree.svg)\\n\\n\\n## Links\\nMorris Traversal : https://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/\\nThreaded Binary Tree: https://en.wikipedia.org/wiki/Threaded_binary_tree\\n\\n## Note\\nWe are not caring about the predecessor link (C -> B in diagram) here to print inorder. Hence not entirely a threaded tree is made\\n\\n## Pseudo Code\\n```\\n1. Initialize current as root \\n2. While current is not NULL\\n   If current hs a left child\\n      ifa) Make current as right child of the rightmost \\n         node in current\\'s left subtree\\n      ifb) Go to this left child, i.e., current = current->left\\n   Else\\n      ea) Print current\\u2019s data\\n      eb) Go to the right, i.e., current = current->right\\n```\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        TreeNode* curNode = root;\\n        vector<int> nodes;\\n        \\n        while (curNode != NULL) \\n        {\\n            if (curNode -> left) \\n            {\\n\\t\\t\\t\\t\\t\\t   //Find the inorder predecessor of current\\n               //ifa) Make current as right child of the rightmost node in current\\'s left subtree\\n                TreeNode* predecessor = curNode -> left;\\n                while (predecessor -> right && predecessor -> right != curNode) //second condition used when reverting\\n                    predecessor = predecessor -> right;\\n                \\n                if ((predecessor -> right)==NULL) \\n                {\\n                    predecessor -> right = curNode;\\n                    curNode = curNode -> left; //ifb) Go to this left child\\n                }\\n                else \\n                {\\n                    //Revert back the changes\\n                    predecessor -> right = NULL;\\n                    nodes.push_back(curNode -> val);\\n                    curNode = curNode -> right;\\n                }\\n            }\\n            else \\n            {\\n                nodes.push_back(curNode -> val);  //ea)\\n                curNode = curNode -> right;  //eb)\\n            }\\n        }\\n        \\n        return nodes;\\n    }\\n};\\n```\\n\\n## References \\nhttps://leetcode.com/problems/binary-tree-inorder-traversal/discuss/31231/Clear-C++-solutions-iterative-recursive-and-Morris-traversal-(3-different-solutions!)\\nhttps://leetcode.com/problems/binary-tree-inorder-traversal/discuss/31232/Three-Methods-to-Solve-(C++)\\n\\n\\n # Other Solutions\\n ## Recursive\\n \\n ```\\n class Solution {\\npublic:\\n    vector<int> v;\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        find(root);\\n        return v;\\n    }\\n    \\n    void find(TreeNode* root){\\n        if(!root) return;\\n        inorderTraversal(root->left);\\n        v.push_back(root->val);\\n        inorderTraversal(root->right);\\n    }\\n};\\n```\\n\\n## Stack Based Solution\\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode *root) {\\n        vector<int> vector;\\n        if(!root)\\n        return vector;\\n        unordered_map<TreeNode *, bool> map;//left child has been visited:true.\\n        stack<TreeNode *> stack;\\n        stack.push(root);\\n        while(!stack.empty())\\n        {\\n            TreeNode *pNode = stack.top();\\n            if(pNode->left && !map[pNode])\\n            {\\n                stack.push(pNode->left);\\n                map[pNode] = true;\\n            }\\n            else\\n            {\\n                vector.push_back(pNode->val);\\n                stack.pop();\\n                if(pNode->right)\\n                stack.push(pNode->right);\\n            }\\n        }\\n        return vector;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n1. Initialize current as root \\n2. While current is not NULL\\n   If current hs a left child\\n      ifa) Make current as right child of the rightmost \\n         node in current\\'s left subtree\\n      ifb) Go to this left child, i.e., current = current->left\\n   Else\\n      ea) Print current\\u2019s data\\n      eb) Go to the right, i.e., current = current->right\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        TreeNode* curNode = root;\\n        vector<int> nodes;\\n        \\n        while (curNode != NULL) \\n        {\\n            if (curNode -> left) \\n            {\\n\\t\\t\\t\\t\\t\\t   //Find the inorder predecessor of current\\n               //ifa) Make current as right child of the rightmost node in current\\'s left subtree\\n                TreeNode* predecessor = curNode -> left;\\n                while (predecessor -> right && predecessor -> right != curNode) //second condition used when reverting\\n                    predecessor = predecessor -> right;\\n                \\n                if ((predecessor -> right)==NULL) \\n                {\\n                    predecessor -> right = curNode;\\n                    curNode = curNode -> left; //ifb) Go to this left child\\n                }\\n                else \\n                {\\n                    //Revert back the changes\\n                    predecessor -> right = NULL;\\n                    nodes.push_back(curNode -> val);\\n                    curNode = curNode -> right;\\n                }\\n            }\\n            else \\n            {\\n                nodes.push_back(curNode -> val);  //ea)\\n                curNode = curNode -> right;  //eb)\\n            }\\n        }\\n        \\n        return nodes;\\n    }\\n};\\n```\n```\\n class Solution {\\npublic:\\n    vector<int> v;\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        find(root);\\n        return v;\\n    }\\n    \\n    void find(TreeNode* root){\\n        if(!root) return;\\n        inorderTraversal(root->left);\\n        v.push_back(root->val);\\n        inorderTraversal(root->right);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode *root) {\\n        vector<int> vector;\\n        if(!root)\\n        return vector;\\n        unordered_map<TreeNode *, bool> map;//left child has been visited:true.\\n        stack<TreeNode *> stack;\\n        stack.push(root);\\n        while(!stack.empty())\\n        {\\n            TreeNode *pNode = stack.top();\\n            if(pNode->left && !map[pNode])\\n            {\\n                stack.push(pNode->left);\\n                map[pNode] = true;\\n            }\\n            else\\n            {\\n                vector.push_back(pNode->val);\\n                stack.pop();\\n                if(pNode->right)\\n                stack.push(pNode->right);\\n            }\\n        }\\n        return vector;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31404,
                "title": "concise-java-solution-based-on-stack",
                "content": "**Explanation**\\n\\nThe basic idea is referred from [here][1]: using stack to simulate the recursion procedure: for each node, travel to its left child until it's left leaf, then pop to left leaf's higher level node A, and switch to A's right branch. Keep the above steps until cur is null and stack is empty. As the following:\\n\\n**Runtime = O(n)**: As each node is visited once\\n\\n**Space = O(n)**\\n\\n\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n    \\tList<Integer> res = new LinkedList<Integer>();\\n    \\tif (root == null) return res;\\n    \\t\\n    \\tStack<TreeNode> stack = new Stack<TreeNode>();\\n    \\tTreeNode cur = root;\\n    \\twhile (cur != null || !stack.isEmpty()) { \\n    \\t\\twhile (cur != null) {// Travel to each node's left child, till reach the left leaf\\n    \\t\\t\\tstack.push(cur);\\n    \\t\\t\\tcur = cur.left;\\t\\t\\t\\t\\n    \\t\\t}\\t\\t \\n    \\t\\tcur = stack.pop(); // Backtrack to higher level node A\\n    \\t\\tres.add(cur.val);  // Add the node to the result list\\n    \\t\\tcur = cur.right;   // Switch to A'right branch\\n    \\t}\\n    \\treturn res;\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/19765/iterative-solution-in-java-simple-and-readable",
                "solutionTags": [],
                "code": "**Explanation**\\n\\nThe basic idea is referred from [here][1]: using stack to simulate the recursion procedure: for each node, travel to its left child until it's left leaf, then pop to left leaf's higher level node A, and switch to A's right branch. Keep the above steps until cur is null and stack is empty. As the following:\\n\\n**Runtime = O(n)**: As each node is visited once\\n\\n**Space = O(n)**\\n\\n\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n    \\tList<Integer> res = new LinkedList<Integer>();\\n    \\tif (root == null) return res;\\n    \\t\\n    \\tStack<TreeNode> stack = new Stack<TreeNode>();\\n    \\tTreeNode cur = root;\\n    \\twhile (cur != null || !stack.isEmpty()) { \\n    \\t\\twhile (cur != null) {// Travel to each node's left child, till reach the left leaf\\n    \\t\\t\\tstack.push(cur);\\n    \\t\\t\\tcur = cur.left;\\t\\t\\t\\t\\n    \\t\\t}\\t\\t \\n    \\t\\tcur = stack.pop(); // Backtrack to higher level node A\\n    \\t\\tres.add(cur.val);  // Add the node to the result list\\n    \\t\\tcur = cur.right;   // Switch to A'right branch\\n    \\t}\\n    \\treturn res;\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/19765/iterative-solution-in-java-simple-and-readable",
                "codeTag": "Unknown"
            },
            {
                "id": 1374069,
                "title": "iterative-solution-stack-in-python-easy-and-fast-99-89",
                "content": "The rule of Inorder Traversal is simple : For each sub tree, you need **visit left child** of current root, then **save root value**, then **visit right child** of current root, for example:\\n![image](https://assets.leetcode.com/users/images/18b11daa-0a08-4215-9713-c59e5e507abb_1627725926.9611049.png)\\n\\nand you MUST always follow this order\\n\\nWhen you visit each children node (here is node 2 or node 4), \\n* if it\\'s a parent of others children, then apply our rule again\\n* if it\\'s empty- which mean it\\'s a leaf- then add it to the Result_list\\n\\nSo, when the tree is bigger, we can notice the pattern of the job and using Stack for our job:\\n* We always visit until the end of left tree, each time visit, you append children to stack. Why ? Imagine we are saving a checkpoint for later to visit the right part of each root\\n```\\n while root:\\n      stack.append(root)\\n      root = root.left\\n```\\n* Each time finish the loop,  comeback and visit parent value, which is the last value of the stack. So just pop it and add value to the Result_list \\n```\\nroot = stack.pop()\\nresult.append(root.val)\\n```\\nNow the last thing in our rule is visit the right \\n```\\nroot = root.right\\n```\\n\\n![image](https://assets.leetcode.com/users/images/c602e413-e193-4710-9127-10c91c86f7e4_1627726325.61519.png)\\nSo here is the code:\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        stack = []\\n        result = []\\n        \\n        while root or stack:\\n          while root:\\n            stack.append(root)\\n            root = root.left\\n          root = stack.pop()\\n          result.append(root.val)\\n          root = root.right\\n        return result\\n```\\nUpvote if you find it useful =))",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\n while root:\\n      stack.append(root)\\n      root = root.left\\n```\n```\\nroot = stack.pop()\\nresult.append(root.val)\\n```\n```\\nroot = root.right\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        stack = []\\n        result = []\\n        \\n        while root or stack:\\n          while root:\\n            stack.append(root)\\n            root = root.left\\n          root = stack.pop()\\n          result.append(root.val)\\n          root = root.right\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31467,
                "title": "morris-traversal-no-recursion-no-stack",
                "content": "\\tpublic class TreeNode {\\n\\t    int val;\\n\\t    TreeNode left;\\n\\t    TreeNode right;\\n\\t    TreeNode(int x) { val = x; }\\n\\t}\\n\\t\\n\\tpublic class Solution {\\n\\t    public List<Integer> inorderTraversal(TreeNode root) {\\n\\t        if(root == null) return new ArrayList<Integer>();\\n\\t        List<Integer> res = new ArrayList<Integer>();\\n\\t        TreeNode pre = null;\\n\\t        while(root != null){\\n\\t        \\tif(root.left == null){\\n\\t        \\t\\tres.add(root.val);\\n\\t        \\t\\troot = root.right;\\n\\t        \\t}else{\\n\\t        \\t\\tpre = root.left;\\n\\t        \\t\\twhile(pre.right != null && pre.right != root){\\n\\t        \\t\\t\\tpre = pre.right;\\n\\t        \\t\\t}\\n\\t        \\t\\tif(pre.right == null){\\n\\t        \\t\\t\\tpre.right = root;\\n\\t        \\t\\t\\troot = root.left;\\n\\t        \\t\\t}else{\\n\\t        \\t\\t\\tpre.right = null;\\n\\t        \\t\\t\\tres.add(root.val);\\n\\t        \\t\\t\\troot = root.right;\\n\\t        \\t\\t}\\n\\t        \\t}\\n\\t        }\\n\\t        return res;\\n\\t    }\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t    public List<Integer> inorderTraversal(TreeNode root) {\\n\\t        if(root == null) return new ArrayList<Integer>();\\n\\t        List<Integer> res = new ArrayList<Integer>();\\n\\t        TreeNode pre = null;\\n\\t        while(root != null){\\n\\t        \\tif(root.left == null){\\n\\t        \\t\\tres.add(root.val);\\n\\t        \\t\\troot = root.right;\\n\\t        \\t}",
                "codeTag": "Java"
            },
            {
                "id": 31372,
                "title": "java-solution-both-recursion-and-iteration",
                "content": "\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        // method 1: recursion\\n\\n        helper(root, res);\\n        return res;\\n\\n        //helper function for method 1\\n        private void helper(TreeNode root, List<Integer> res) {\\n            if (root != null) {\\n                if (root.left != null) {\\n                    helper(root.left, res);\\n                }\\n                res.add(root.val);\\n                if (root.right != null) {\\n                    helper(root.right, res);\\n               }\\n           }\\n       }\\n\\n\\n----------\\n\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        // method 2: iteration\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode cur = root;\\n        while (cur != null || !stack.isEmpty()) {\\n            while (cur != null) {\\n                stack.push(cur);\\n                cur = cur.left;\\n            }\\n            cur = stack.pop();\\n            res.add(cur.val);\\n            cur = cur.right;\\n        }\\n        return res;        \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        // method 1: recursion\\n\\n        helper(root, res);\\n        return res;\\n\\n        //helper function for method 1\\n        private void helper(TreeNode root, List<Integer> res) {\\n            if (root != null) {\\n                if (root.left != null) {\\n                    helper(root.left, res);\\n                }\\n                res.add(root.val);\\n                if (root.right != null) {\\n                    helper(root.right, res);\\n               }\\n           }\\n       }\\n\\n\\n----------\\n\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        // method 2: iteration\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode cur = root;\\n        while (cur != null || !stack.isEmpty()) {\\n            while (cur != null) {\\n                stack.push(cur);\\n                cur = cur.left;\\n            }\\n            cur = stack.pop();\\n            res.add(cur.val);\\n            cur = cur.right;\\n        }\\n        return res;        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 603442,
                "title": "intuitive-javascript-solution-with-stack",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar inorderTraversal = function(root) {\\n  const output = [];\\n  \\n  if (root === null) {\\n    return output;\\n  }\\n  \\n  /**\\n   * The goal is to maintain a stack of nodes to visit as we traverse \\n   * down the tree. As we traverse down, We go left and push all the \\n   * left nodes first in the stack. Once we reach to the bottom, we \\n   * store the node value and traverse right.\\n   *           1\\n   *         /   \\\\\\n   *        2     3    preorder traversal: 4 -> 2 -> 5 -> 1 -> 6 -> 3\\n   *       / \\\\   /     (left -> root -> right)\\n   *      4   5 6\\n   */\\n  const stack = [];\\n  let curr = root;\\n  \\n  while (curr !== null || stack.length !== 0) {\\n    if (curr !== null) {\\n      stack.push(curr);\\n      curr = curr.left;\\n    } else {\\n      curr = stack.pop();\\n      output.push(curr.val);\\n      curr = curr.right;  \\n    }  \\n  }\\n  \\n  return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar inorderTraversal = function(root) {\\n  const output = [];\\n  \\n  if (root === null) {\\n    return output;\\n  }\\n  \\n  /**\\n   * The goal is to maintain a stack of nodes to visit as we traverse \\n   * down the tree. As we traverse down, We go left and push all the \\n   * left nodes first in the stack. Once we reach to the bottom, we \\n   * store the node value and traverse right.\\n   *           1\\n   *         /   \\\\\\n   *        2     3    preorder traversal: 4 -> 2 -> 5 -> 1 -> 6 -> 3\\n   *       / \\\\   /     (left -> root -> right)\\n   *      4   5 6\\n   */\\n  const stack = [];\\n  let curr = root;\\n  \\n  while (curr !== null || stack.length !== 0) {\\n    if (curr !== null) {\\n      stack.push(curr);\\n      curr = curr.left;\\n    } else {\\n      curr = stack.pop();\\n      output.push(curr.val);\\n      curr = curr.right;  \\n    }  \\n  }\\n  \\n  return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 691488,
                "title": "javascript-clean-solution",
                "content": "```javascript\\nvar inorderTraversal = function(root) {\\n    const result = [];\\n    \\n    function traverse(node) {\\n        if(!node) return;\\n        \\n        traverse(node.left);\\n        result.push(node.val);\\n        traverse(node.right);\\n    }\\n    traverse(root);\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar inorderTraversal = function(root) {\\n    const result = [];\\n    \\n    function traverse(node) {\\n        if(!node) return;\\n        \\n        traverse(node.left);\\n        result.push(node.val);\\n        traverse(node.right);\\n    }\\n    traverse(root);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 332283,
                "title": "python-recursive-and-iterative-solutions",
                "content": "Please see and vote for my solutions for these similar problems.\\n[94. Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/discuss/332283/Python-recursive-and-iterative-solutions)\\n[144. Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/discuss/332277/Python-recursive-and-iterative-solutions)\\n[145. Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/discuss/332286/Python-recursive-and-iterative-solutions)\\n\\nRecursive solution:\\n```\\n    def inorderTraversal(self, root):\\n        def dfs(node):\\n            if not node:\\n                return\\n            dfs(node.left)\\n            in_order.append(node.val)\\n            dfs(node.right)\\n        \\n        in_order = []\\n        dfs(root)\\n        return in_order\\n```\\n\\nIterative solution 1: use a stack and a hashset visited\\n```\\n    def inorderTraversal(self, root):\\n        if not root:\\n            return []\\n        in_order = []\\n        stack = [root]\\n        visited = {root}\\n        while stack:\\n            top = stack[-1]\\n            no_left = True\\n            if top.left and top.left not in visited:\\n                stack.append(top.left)\\n                visited.add(top.left)\\n                no_left = False\\n            if no_left:\\n                stack.pop()\\n                in_order.append(top.val)\\n                if top.right and top.right not in visited:\\n                    stack.append(top.right)\\n                    visited.add(top.right)\\n        return in_order\\n```\\n\\nIterative solution 2: use a stack and a pointer\\n```\\n    def inorderTraversal(self, root):\\n        in_order = []\\n        stack, p = [], root\\n        while stack or p:\\n            if p:\\n                stack.append(p)\\n                p = p.left\\n            else:\\n                p = stack.pop()\\n                in_order.append(p.val)\\n                p = p.right\\n        return in_order\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def inorderTraversal(self, root):\\n        def dfs(node):\\n            if not node:\\n                return\\n            dfs(node.left)\\n            in_order.append(node.val)\\n            dfs(node.right)\\n        \\n        in_order = []\\n        dfs(root)\\n        return in_order\\n```\n```\\n    def inorderTraversal(self, root):\\n        if not root:\\n            return []\\n        in_order = []\\n        stack = [root]\\n        visited = {root}\\n        while stack:\\n            top = stack[-1]\\n            no_left = True\\n            if top.left and top.left not in visited:\\n                stack.append(top.left)\\n                visited.add(top.left)\\n                no_left = False\\n            if no_left:\\n                stack.pop()\\n                in_order.append(top.val)\\n                if top.right and top.right not in visited:\\n                    stack.append(top.right)\\n                    visited.add(top.right)\\n        return in_order\\n```\n```\\n    def inorderTraversal(self, root):\\n        in_order = []\\n        stack, p = [], root\\n        while stack or p:\\n            if p:\\n                stack.append(p)\\n                p = p.left\\n            else:\\n                p = stack.pop()\\n                in_order.append(p.val)\\n                p = p.right\\n        return in_order\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1319978,
                "title": "c-clean-concise-code-recursive-faster-than-100-0ms-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void in(TreeNode* root, vector<int> &v){\\n        if(root==NULL){\\n            return;\\n        }\\n        else{\\n            in(root->left,v);\\n            v.push_back(root->val);\\n            in(root->right,v);\\n        }\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        in(root,v);\\n        return v;\\n    }\\n};\\n```\\n**Please help to UPVOTE if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\nHAPPY CODING :)\\nLOVE CODING :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void in(TreeNode* root, vector<int> &v){\\n        if(root==NULL){\\n            return;\\n        }\\n        else{\\n            in(root->left,v);\\n            v.push_back(root->val);\\n            in(root->right,v);\\n        }\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        in(root,v);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 702291,
                "title": "python-iterative-recursive-and-morris-traversal-o-1-space-and-o-n-time-complexity",
                "content": "**Iterative :**\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        output, stack =[],[]\\n        while(stack or root):\\n            if root:\\n                # Go to the left most and push the parent into the stack\\n                # We need this parent node once we are done with left child and need to go to the right child\\n                stack.append(root)\\n                root = root.left\\n            elif stack and root == None:\\n                #We are done with left , so pop out the parent\\n                root = stack.pop()\\n                output.append(root.val)\\n                # Go to the right child\\n                root = root.right\\n        return output\\n```\\nSpace : O(n) , Time : O(n)\\n\\n**Recursive**: \\n\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        output =[]\\n        def inorderTraversalHelper(root):\\n            if not root:\\n                return None\\n            inorderTraversalHelper(root.left)\\n            output.append(root.val)\\n            inorderTraversalHelper(root.right)\\n        inorderTraversalHelper(root)\\n        return output\\n```\\n\\n**Morris Traversal** : This can be done in constant space using Morris Traversal. Main aim of using a stack is to be able to go to right child of node once you have traverse the left child of a node. Instead of using a stack for that we can create a link between the inorder predecessor of the node and the node. Inorder predecessor of a node is the rightmost child of a left subtree and when you do a inorder traversal the node will come immediately after its inorder predecessor. \\n![image](https://assets.leetcode.com/users/images/9586323c-3a72-4e7a-a23c-27aa97795520_1592941100.20095.png)\\n\\nIf not using stack , create a link between 5 and 1. Now we don\\'t need a stack , we can go to 1 directly via 5. \\n![image](https://assets.leetcode.com/users/images/1793fa7e-e90f-4c74-8a60-7cc04bef6788_1592941130.8812513.png)\\n\\n![image](https://assets.leetcode.com/users/images/daad333c-010d-4a23-a998-1eb1c1102a08_1593026461.844386.png)\\n\\n\\n\\n\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        # Morris Traversal\\n        curr = root\\n        output =[]\\n        while(curr):\\n            #if no left child, we can directly go the right child\\n            if not curr.left:\\n                output.append(curr.val)\\n                curr = curr.right\\n            else:\\n            # find the inorder predecessor of the current node\\n                predecessor = curr.left\\n                # predecessor.right = curr will occur when we have already explored the left subtree of current \\n                # and reached the curr via its predecessor link and now again checking this else condition.\\n                # We have to break out of this loop.\\n                while predecessor.right !=None and predecessor.right != curr:\\n                    predecessor = predecessor.right # go as right as possible\\n\\n                # Now check which out of 2 above condition it reached\\n                if predecessor.right == None:\\n                    # No link created till now, so create one and go to the left child of current.\\n                    predecessor.right = curr\\n                    curr = curr.left\\n                else:\\n                    # left subtree is already visited , so delete the link and then go to right subtree\\n                    predecessor.right = None\\n                    output.append(curr.val)\\n                    curr = curr.right\\n        return output \\n```\\n\\nCode Walk through with the example :\\n1. Curr is 1 and before moving to its left , you have to create a link between 1 and its predecessor.\\n2. Predecessor is 5. Before creating the link , check if the predecessor already contains the link or not. Create a link between 5 and 1 and go to the left of 1 . **It is like putting the curr value to the stack and going to its left.**\\n3. Repeat the same process for curr node 2.  Before moving to its left , create a link between 2 and its predecessor \"4\"\\n![image](https://assets.leetcode.com/users/images/8867ccd2-686b-4ba4-a88e-9de48e65089b_1593704192.85518.png)\\n4. Now there is no curr.left. Add it to the output. Usually in inorder traversal with stack => you pop out from the stack , get the parent , add it to the output and go to left.Here to get the parent , you go to the right and followed the parent using the link created before.\\n![image](https://assets.leetcode.com/users/images/1e30590a-4c94-4d1b-b0ca-5d79d9428e81_1593704211.958061.png)\\n5. Now you are at 2 and **you don\\'t know if you are coming to this 2 for the first time or you have already explored its left**. One way to find it out is to check its predecessor and if link already exist , it means you have already explored the left of 2 and have utlised the link created before to come to 2. Now you can safely delete this link as you will not need it again . Now go to the curr.right. ( Left is done , parent is done)\\n![image](https://assets.leetcode.com/users/images/7ad9a3e5-5a8c-4761-9d23-488b2989d88b_1593704218.4761784.png)\\n6. Now you are at 5. There is no left so append it to the output and go to its right. 5.right = 1(the link we created before). Now repeat the same process of deleting the link as we did before and go to curr right which is 3. ( left is explored , parent is explored)\\n![image](https://assets.leetcode.com/users/images/9c63e1ae-7d79-4f21-af05-4c385bd55443_1593704224.371424.png)\\n7. You are at 3 and there is no left , so add it to the output.\\n![image](https://assets.leetcode.com/users/images/e89a7026-4060-4d7c-a922-70c3f30dafc2_1593704228.9838285.png)\\n",
                "solutionTags": [
                    "Python3",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        output, stack =[],[]\\n        while(stack or root):\\n            if root:\\n                # Go to the left most and push the parent into the stack\\n                # We need this parent node once we are done with left child and need to go to the right child\\n                stack.append(root)\\n                root = root.left\\n            elif stack and root == None:\\n                #We are done with left , so pop out the parent\\n                root = stack.pop()\\n                output.append(root.val)\\n                # Go to the right child\\n                root = root.right\\n        return output\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        output =[]\\n        def inorderTraversalHelper(root):\\n            if not root:\\n                return None\\n            inorderTraversalHelper(root.left)\\n            output.append(root.val)\\n            inorderTraversalHelper(root.right)\\n        inorderTraversalHelper(root)\\n        return output\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        # Morris Traversal\\n        curr = root\\n        output =[]\\n        while(curr):\\n            #if no left child, we can directly go the right child\\n            if not curr.left:\\n                output.append(curr.val)\\n                curr = curr.right\\n            else:\\n            # find the inorder predecessor of the current node\\n                predecessor = curr.left\\n                # predecessor.right = curr will occur when we have already explored the left subtree of current \\n                # and reached the curr via its predecessor link and now again checking this else condition.\\n                # We have to break out of this loop.\\n                while predecessor.right !=None and predecessor.right != curr:\\n                    predecessor = predecessor.right # go as right as possible\\n\\n                # Now check which out of 2 above condition it reached\\n                if predecessor.right == None:\\n                    # No link created till now, so create one and go to the left child of current.\\n                    predecessor.right = curr\\n                    curr = curr.left\\n                else:\\n                    # left subtree is already visited , so delete the link and then go to right subtree\\n                    predecessor.right = None\\n                    output.append(curr.val)\\n                    curr = curr.right\\n        return output \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724058,
                "title": "recursive-and-iterative-approach",
                "content": "# 1. Recursive Approach\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans=[]\\n        def inorder(root,ans):\\n            if not root:\\n                return None\\n            inorder(root.left,ans)\\n            ans.append(root.val)\\n            inorder(root.right,ans)\\n        inorder(root,ans)\\n        return ans\\n```\\n# 2. Iterative Approach\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans=[]\\n        stack=[]\\n        cur=root\\n        while stack or cur:\\n            if cur:\\n                stack.append(cur)\\n                cur=cur.left\\n            else:\\n                cur=stack.pop()\\n                ans.append(cur.val)\\n                cur=cur.right\\n        return ans\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans=[]\\n        def inorder(root,ans):\\n            if not root:\\n                return None\\n            inorder(root.left,ans)\\n            ans.append(root.val)\\n            inorder(root.right,ans)\\n        inorder(root,ans)\\n        return ans\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans=[]\\n        stack=[]\\n        cur=root\\n        while stack or cur:\\n            if cur:\\n                stack.append(cur)\\n                cur=cur.left\\n            else:\\n                cur=stack.pop()\\n                ans.append(cur.val)\\n                cur=cur.right\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31463,
                "title": "non-recursive-python-solution",
                "content": "Simple, understandable solution. In the loop: If we get a node with flag false, we add children in correct order and set them to false. because they have to be processed (for their children). And we set flag of current node to true. \\n\\nIf we get node with flag set to true we simply print its value (add to acc).\\nCan be modified to do post and pre order too.\\n\\n    class Solution:\\n        def inorderTraversal(self, root):\\n            stack = [ (False, root) ]\\n            acc = []\\n            \\n            while stack:\\n                flag, val = stack.pop()\\n                if val:\\n                    if not flag:\\n                        stack.append( (False, val.right) )\\n                        stack.append( (True, val) )\\n                        stack.append( (False, val.left) )\\n                    else:\\n                        acc.append( val.val )\\n            return acc",
                "solutionTags": [
                    "Python"
                ],
                "code": "Simple, understandable solution. In the loop: If we get a node with flag false, we add children in correct order and set them to false. because they have to be processed (for their children). And we set flag of current node to true. \\n\\nIf we get node with flag set to true we simply print its value (add to acc).\\nCan be modified to do post and pre order too.\\n\\n    class Solution:\\n        def inorderTraversal(self, root):\\n            stack = [ (False, root) ]\\n            acc = []\\n            \\n            while stack:\\n                flag, val = stack.pop()\\n                if val:\\n                    if not flag:\\n                        stack.append( (False, val.right) )\\n                        stack.append( (True, val) )\\n                        stack.append( (False, val.left) )\\n                    else:\\n                        acc.append( val.val )\\n            return acc",
                "codeTag": "Java"
            },
            {
                "id": 1860290,
                "title": "tree-traversal-algorithms-preorder-inorder-and-postorder-traverse-algorithms-all-in-one",
                "content": "[Leetcode](https://leetcode.com/) [94. Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/).\\n\\n\\n***By Frank Luo***\\n\\nThe **Tree Traversal Algorithms** are used to traversal the tree including **Binary Tree** and **N-ary Tree**. \\n\\n1. Binary Tree Traversal\\n\\n[94. Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/)\\n[144. Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/)\\n[145. Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/)\\n\\n2. N-ary Tree Traversal\\n\\n[589. N-ary Tree Preorder Traversal](https://leetcode.com/problems/n-ary-tree-preorder-traversal/)\\n[590. N-ary Tree Postorder Traversal](https://leetcode.com/problems/n-ary-tree-postorder-traversal/)\\n\\n\\n# Binary Tree\\n\\n## PreOrder\\n\\nAlgorithm Preorder(tree)\\n1. Visit the root;\\n2. Traverse the left subtree, i.e., call Preorder(left-subtree);\\n3. Traverse the right subtree, i.e., call Preorder(right-subtree). \\n\\n### Recursive\\n\\n```java\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        preOrder(root, ans);\\n        return ans;\\n    }\\n    \\n    public void preOrder(TreeNode root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        \\n        list.add(root.val);\\n        preOrder(root.left, list);\\n        preOrder(root.right, list);\\n    }\\n```\\n\\n#### Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n\\n### Iteration\\n\\n```java\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        while (root != null || !stack.empty()) {\\n            while (root != null) {\\n                stack.push(root);\\n                ans.add(root.val);\\n                root = root.left;\\n            }\\n            \\n            root = stack.pop();\\n            root = root.right;\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\n#### Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n<!-- more -->\\n\\n## InOrder\\n\\nAlgorithm Inorder(tree)\\n\\n1. Traverse the left subtree, i.e., call Inorder(left-subtree);\\n2. Visit the root;\\n3. Traverse the right subtree, i.e., call Inorder(right-subtree).\\n\\n### Recursive\\n\\n```java\\n    public List<Integer> inorderTraversal_rec(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        inOrder(root, ans);\\n        return ans;\\n    }\\n    \\n    public void inOrder(TreeNode root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        if (root.left != null) {\\n            inOrder(root.left, list);\\n        }\\n        list.add(root.val);\\n        if (root.right != null) {\\n            inOrder(root.right, list);\\n        }\\n    }\\n```\\n\\n#### Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n### Iteration\\n\\n```java\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        \\n        while (root != null || !stack.empty()) {\\n            while (root != null) {\\n                stack.push(root);\\n                root = root.left;\\n            }\\n            \\n            root = stack.pop();\\n            ans.add(root.val);\\n            root = root.right;\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\n#### Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n\\n## PostOrder\\n\\nAlgorithm Postorder(tree)\\n1. Traverse the left subtree, i.e., call Postorder(left-subtree);\\n2. Traverse the right subtree, i.e., call Postorder(right-subtree);\\n3. Visit the root.\\n\\n\\n### Recursive\\n\\n```java\\n    public List<Integer> postorderTraversal_rec(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        postOrder(root, ans);\\n        return ans;\\n    }\\n    \\n    public void postOrder(TreeNode root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        \\n        postOrder(root.left, list);\\n        postOrder(root.right, list);\\n        list.add(root.val);\\n    }\\n```\\n\\n#### Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n### Iteration\\n\\n```java\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        \\n        TreeNode prev = null;\\n        while (root != null || !stack.empty()) {\\n            while (root != null) {\\n                stack.push(root);\\n                root = root.left;\\n            }\\n\\n            root = stack.pop();\\n            if (root.right == null || root.right == prev) {\\n                ans.add(root.val);\\n                prev = root;\\n                root = null;\\n            } else {\\n                stack.push(root);\\n                root = root.right;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```\\n\\n#### Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n\\n# N-ary Tree Traversal\\n\\n## PreOrder\\n\\n### Recursive\\n\\n```java\\n    public List<Integer> preorder(Node root) {\\n        List<Integer> ans = new ArrayList<>();\\n        preOrderTraversal(root, ans);\\n        return ans;\\n    }\\n    \\n    public void preOrderTraversal(Node root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        list.add(root.val);\\n        List<Node> children = root.children;\\n        for (Node child : children) {\\n            preOrderTraversal(child, list);\\n        }\\n    }\\n```\\n\\n#### Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n\\n### Iteration\\n\\n```java\\n    public List<Integer> preorder(Node root) {\\n        List<Integer> ans = new ArrayList<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        \\n        Stack<Node> stack = new Stack<>();\\n        stack.push(root);\\n        while (!stack.empty()) {\\n            Node node = stack.pop();\\n            ans.add(node.val);\\n            List<Node> children = node.children;\\n            int size = children.size();\\n            for (int i = size - 1; i >= 0; i--) {\\n                stack.push(children.get(i));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\n#### Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n\\n## PostOrder\\n\\n### Recursive\\n\\n```java\\n    public List<Integer> postorder_rec(Node root) {\\n        List<Integer> ans = new ArrayList<>();\\n        postOrderTraversal(root, ans);\\n        return ans;\\n    }\\n    \\n    public void postOrderTraversal(Node root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        List<Node> children = root.children;\\n        for (Node child : children) {\\n            postOrderTraversal(child, list);\\n        }\\n        list.add(root.val);\\n    }\\n```\\n\\n#### Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n\\n### Iteration\\n\\n```java\\n    public List<Integer> postorder(Node root) {\\n        List<Integer> ans = new ArrayList<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        \\n        Stack<Node> stack = new Stack<>();\\n        stack.push(root);\\n        while (!stack.empty()) {\\n            Node node = stack.pop();\\n            ans.add(node.val);\\n            List<Node> children = node.children;\\n            int size = children.size();\\n            for (int i = 0; i < size; i++) {\\n                stack.push(children.get(i));\\n            }\\n        }\\n        \\n        Collections.reverse(ans);\\n        return ans;\\n    }\\n```\\n\\n#### Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n-------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "Stack",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```java\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        preOrder(root, ans);\\n        return ans;\\n    }\\n    \\n    public void preOrder(TreeNode root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        \\n        list.add(root.val);\\n        preOrder(root.left, list);\\n        preOrder(root.right, list);\\n    }\\n```\n```java\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        while (root != null || !stack.empty()) {\\n            while (root != null) {\\n                stack.push(root);\\n                ans.add(root.val);\\n                root = root.left;\\n            }\\n            \\n            root = stack.pop();\\n            root = root.right;\\n        }\\n        \\n        return ans;\\n    }\\n```\n```java\\n    public List<Integer> inorderTraversal_rec(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        inOrder(root, ans);\\n        return ans;\\n    }\\n    \\n    public void inOrder(TreeNode root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        if (root.left != null) {\\n            inOrder(root.left, list);\\n        }\\n        list.add(root.val);\\n        if (root.right != null) {\\n            inOrder(root.right, list);\\n        }\\n    }\\n```\n```java\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        \\n        while (root != null || !stack.empty()) {\\n            while (root != null) {\\n                stack.push(root);\\n                root = root.left;\\n            }\\n            \\n            root = stack.pop();\\n            ans.add(root.val);\\n            root = root.right;\\n        }\\n        \\n        return ans;\\n    }\\n```\n```java\\n    public List<Integer> postorderTraversal_rec(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        postOrder(root, ans);\\n        return ans;\\n    }\\n    \\n    public void postOrder(TreeNode root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        \\n        postOrder(root.left, list);\\n        postOrder(root.right, list);\\n        list.add(root.val);\\n    }\\n```\n```java\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        \\n        TreeNode prev = null;\\n        while (root != null || !stack.empty()) {\\n            while (root != null) {\\n                stack.push(root);\\n                root = root.left;\\n            }\\n\\n            root = stack.pop();\\n            if (root.right == null || root.right == prev) {\\n                ans.add(root.val);\\n                prev = root;\\n                root = null;\\n            } else {\\n                stack.push(root);\\n                root = root.right;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```\n```java\\n    public List<Integer> preorder(Node root) {\\n        List<Integer> ans = new ArrayList<>();\\n        preOrderTraversal(root, ans);\\n        return ans;\\n    }\\n    \\n    public void preOrderTraversal(Node root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        list.add(root.val);\\n        List<Node> children = root.children;\\n        for (Node child : children) {\\n            preOrderTraversal(child, list);\\n        }\\n    }\\n```\n```java\\n    public List<Integer> preorder(Node root) {\\n        List<Integer> ans = new ArrayList<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        \\n        Stack<Node> stack = new Stack<>();\\n        stack.push(root);\\n        while (!stack.empty()) {\\n            Node node = stack.pop();\\n            ans.add(node.val);\\n            List<Node> children = node.children;\\n            int size = children.size();\\n            for (int i = size - 1; i >= 0; i--) {\\n                stack.push(children.get(i));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```\n```java\\n    public List<Integer> postorder_rec(Node root) {\\n        List<Integer> ans = new ArrayList<>();\\n        postOrderTraversal(root, ans);\\n        return ans;\\n    }\\n    \\n    public void postOrderTraversal(Node root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        List<Node> children = root.children;\\n        for (Node child : children) {\\n            postOrderTraversal(child, list);\\n        }\\n        list.add(root.val);\\n    }\\n```\n```java\\n    public List<Integer> postorder(Node root) {\\n        List<Integer> ans = new ArrayList<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        \\n        Stack<Node> stack = new Stack<>();\\n        stack.push(root);\\n        while (!stack.empty()) {\\n            Node node = stack.pop();\\n            ans.add(node.val);\\n            List<Node> children = node.children;\\n            int size = children.size();\\n            for (int i = 0; i < size; i++) {\\n                stack.push(children.get(i));\\n            }\\n        }\\n        \\n        Collections.reverse(ans);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31407,
                "title": "my-3-solutions-in-c",
                "content": "\\n    // recursive, it's trivial...\\n    vector<int> v;\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(!root) return v;\\n        inorderTraversal(root->left);\\n        v.push_back(root->val);\\n        inorderTraversal(root->right);\\n        return v;\\n    }\\n    \\n    \\n    // iterate, use stack\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        if(!root) return v;\\n        TreeNode* temp = root;\\n        stack<TreeNode*> s;\\n        while(true){\\n            while(temp){\\n                s.push(temp);\\n                temp = temp->left;\\n            }\\n            if(s.empty()) break;\\n            temp = s.top();\\n            s.pop();\\n            v.push_back(temp->val);\\n            temp = temp->right;\\n        }\\n        return v;\\n    }\\n    \\n    \\n    // iterate, morris traversal, without stack\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        if(!root) return v;\\n        TreeNode* temp = root, *prev;\\n        while(temp){\\n            if(!temp->left){\\n                v.push_back(temp->val);\\n                temp = temp->right;\\n            }else{\\n                prev = temp->left;\\n                while(prev->right&&(prev->right != temp))\\n                    prev = prev->right;\\n                if(!prev->right){\\n                    prev->right = temp;\\n                    temp = temp->left;\\n                }else{\\n                    v.push_back(temp->val);\\n                    prev->right = NULL;\\n                    temp = temp->right;\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n    // recursive, it's trivial...\\n    vector<int> v;\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(!root) return v;\\n        inorderTraversal(root->left);\\n        v.push_back(root->val);\\n        inorderTraversal(root->right);\\n        return v;\\n    }\\n    \\n    \\n    // iterate, use stack\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        if(!root) return v;\\n        TreeNode* temp = root;\\n        stack<TreeNode*> s;\\n        while(true){\\n            while(temp){\\n                s.push(temp);\\n                temp = temp->left;\\n            }\\n            if(s.empty()) break;\\n            temp = s.top();\\n            s.pop();\\n            v.push_back(temp->val);\\n            temp = temp->right;\\n        }\\n        return v;\\n    }\\n    \\n    \\n    // iterate, morris traversal, without stack\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        if(!root) return v;\\n        TreeNode* temp = root, *prev;\\n        while(temp){\\n            if(!temp->left){\\n                v.push_back(temp->val);\\n                temp = temp->right;\\n            }else{\\n                prev = temp->left;\\n                while(prev->right&&(prev->right != temp))\\n                    prev = prev->right;\\n                if(!prev->right){\\n                    prev->right = temp;\\n                    temp = temp->left;\\n                }else{\\n                    v.push_back(temp->val);\\n                    prev->right = NULL;\\n                    temp = temp->right;\\n                }\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 434091,
                "title": "js-recursive-clean-code",
                "content": "```\\nconst inorderTraversal = root => {\\n    if (!root) {\\n        return []\\n    }\\n    \\n    return [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)]\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst inorderTraversal = root => {\\n    if (!root) {\\n        return []\\n    }\\n    \\n    return [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3348653,
                "title": "java-fastest-dfs-solution-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(H) h is height of the tree\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/4501697a-bbba-4d67-89cb-f285873536ec_1679937247.5252385.png)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        \\n        // Check if the root is null\\n        if(root == null){\\n            // If the root is null, return an empty ArrayList\\n            return new ArrayList<Integer>();\\n        }\\n\\n        // Create a new ArrayList to store the values obtained in an in-order traversal\\n        ArrayList<Integer> ans = new ArrayList<>();\\n\\n        // Recursively perform an in-order traversal on the left subtree and add the obtained values to the ArrayList\\n        ans.addAll(inorderTraversal(root.left));\\n\\n        // Add the value of the root to the ArrayList\\n        ans.add(root.val);\\n\\n        // Recursively perform an in-order traversal on the right subtree and add the obtained values to the ArrayList\\n        ans.addAll(inorderTraversal(root.right));\\n\\n        // Return the ArrayList containing all the values obtained in the in-order traversal\\n    return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        \\n        // Check if the root is null\\n        if(root == null){\\n            // If the root is null, return an empty ArrayList\\n            return new ArrayList<Integer>();\\n        }\\n\\n        // Create a new ArrayList to store the values obtained in an in-order traversal\\n        ArrayList<Integer> ans = new ArrayList<>();\\n\\n        // Recursively perform an in-order traversal on the left subtree and add the obtained values to the ArrayList\\n        ans.addAll(inorderTraversal(root.left));\\n\\n        // Add the value of the root to the ArrayList\\n        ans.add(root.val);\\n\\n        // Recursively perform an in-order traversal on the right subtree and add the obtained values to the ArrayList\\n        ans.addAll(inorderTraversal(root.right));\\n\\n        // Return the ArrayList containing all the values obtained in the in-order traversal\\n    return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1019265,
                "title": "stack-c-inorder-beginner-friendly",
                "content": "**Runtime: 0 ms, faster than 100.00% of C++ online submissions \\nMemory Usage: 9.4 MB, less than 11.18% of C++ online submissions**\\n```\\nclass Solution {\\npublic:\\n    vector<int> vec;\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(root==nullptr) return {};\\n        inorderTraversal(root->left);\\n        vec.push_back(root->val);\\n        inorderTraversal(root->right);\\n        return vec;\\n    }\\n};\\n```\\n**Runtime: 0 ms, faster than 100.00% of C++ online submissions \\nMemory Usage: 8.6 MB, less than 11.18% of C++ online submissions**\\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root){ \\n        if(root==NULL)\\n           return {};\\n        vector<int> vec;\\n        stack<TreeNode*> s;\\n        while(true){\\n            if(root!=NULL){\\n               s.push(root);\\n               root=root->left; \\n            }\\n            else{\\n                if(s.empty())\\n                    break;\\n                root=s.top();\\n                s.pop();\\n                vec.push_back(root->val);\\n                root=root->right;\\n            }\\n        }\\n        return vec;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vec;\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(root==nullptr) return {};\\n        inorderTraversal(root->left);\\n        vec.push_back(root->val);\\n        inorderTraversal(root->right);\\n        return vec;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root){ \\n        if(root==NULL)\\n           return {};\\n        vector<int> vec;\\n        stack<TreeNode*> s;\\n        while(true){\\n            if(root!=NULL){\\n               s.push(root);\\n               root=root->left; \\n            }\\n            else{\\n                if(s.empty())\\n                    break;\\n                root=s.top();\\n                s.pop();\\n                vec.push_back(root->val);\\n                root=root->right;\\n            }\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 158278,
                "title": "python-stack-dfs",
                "content": "### 94. Binary Tree Inorder Traversal\\n```\\n> \\u7C7B\\u578B\\uFF1A\\n> Time Complexity O(n)\\n> Space Complexity O(1)\\n```\\n\\n#### DFS Recursive\\n```python\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        self.res = []\\n        self.dfs(root)\\n        return self.res\\n        \\n    def dfs(self, root):\\n        if not root:\\n            return\\n        self.dfs(root.left)\\n        self.res.append(root.val)\\n        self.dfs(root.right)\\n```\\n\\n#### Stack\\n\\n\\u5148\\u628A\\u8FED\\u4EE3\\u5230\\u6700\\u5DE6\\u8FB9\\u7684\\u53F6\\u5B50\\u8282\\u70B9\\uFF0C\\u628A\\u6240\\u6709\\u9014\\u4E2D\\u7684`root`\\u653E\\u8FDBstack\\uFF0C\\u5F53\\u5DE6\\u8FB9\\u8D70\\u4E0D\\u901A\\u4E86\\uFF0C\\u5F00\\u59CB\\u5F80`res`\\u91CC\\u9762\\u5B58\\u6570\\uFF0C\\u5E76\\u5F80\\u53F3\\u8FB9\\u8D70\\u3002\\n\\n```python\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        res, stack = [], []\\n        while stack or root:\\n            if root:\\n                stack.append(root)\\n                root = root.left\\n            else:\\n                node = stack.pop()\\n                res.append(node.val)\\n                root = node.right\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n> \\u7C7B\\u578B\\uFF1A\\n> Time Complexity O(n)\\n> Space Complexity O(1)\\n```\n```python\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        self.res = []\\n        self.dfs(root)\\n        return self.res\\n        \\n    def dfs(self, root):\\n        if not root:\\n            return\\n        self.dfs(root.left)\\n        self.res.append(root.val)\\n        self.dfs(root.right)\\n```\n```python\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        res, stack = [], []\\n        while stack or root:\\n            if root:\\n                stack.append(root)\\n                root = root.left\\n            else:\\n                node = stack.pop()\\n                res.append(node.val)\\n                root = node.right\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1073216,
                "title": "python-3-solutions-recursive-iterative",
                "content": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        #\\n        ## recursive\\n        if not root: return []\\n        else: return self.inorderTraversal(root.left)+[root.val]+self.inorderTraversal(root.right)\\n```\\n\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        #\\n        ## iteration\\n        stack,res = [],[]\\n        node = root\\n        # why we need to judge the node or the stack at the same time?\\n        # Because we will stop the first while loop when it reach the far-right leaf.\\n        # However, the stack will be empty when the node reaches the root.\\n        # And the node will be None when we reach the left leaf.\\n        # To make sure the node reaches the far-right leaf, we need to check the node and stack\\n        # in the first while loop.\\n        while node or stack:\\n            while node: # put all left nodes in the stack\\n                stack.append(node)\\n                node = node.left\\n            node = stack.pop()\\n            res.append(node.val)\\n            # change the direction to the right direction after the left.children\\n            # and parent are taken care of, which the inorder means.\\n            node = node.right\\n        return res\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        #\\n        ## recursive\\n        if not root: return []\\n        else: return self.inorderTraversal(root.left)+[root.val]+self.inorderTraversal(root.right)\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        #\\n        ## iteration\\n        stack,res = [],[]\\n        node = root\\n        # why we need to judge the node or the stack at the same time?\\n        # Because we will stop the first while loop when it reach the far-right leaf.\\n        # However, the stack will be empty when the node reaches the root.\\n        # And the node will be None when we reach the left leaf.\\n        # To make sure the node reaches the far-right leaf, we need to check the node and stack\\n        # in the first while loop.\\n        while node or stack:\\n            while node: # put all left nodes in the stack\\n                stack.append(node)\\n                node = node.left\\n            node = stack.pop()\\n            res.append(node.val)\\n            # change the direction to the right direction after the left.children\\n            # and parent are taken care of, which the inorder means.\\n            node = node.right\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1338663,
                "title": "python-inorder-iterative-stack-t-f-explanation",
                "content": "InOrder Traversal:\\n\\t- Traverse the left side\\n\\t- hit the root\\n\\t- traverse the right side \\n\\nW/ recursive go -> left,root,right\\nW/iterative stack go -> right,root,left\\n\\t - stack follows LIFO(last-in-first-out)\\n\\t - so you\\'ll iterate through the right side first, but you\\'ll pop OUT the left side first\\n\\t - aka its backwards traversal to get the proper answer \\n\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        res = []\\n        # root starts out False because you haven\\'t visited it yet\\n        stack = [(root, False)]\\n        \\n        while stack:\\n            # pop the last element\\n            node, visited = stack.pop() \\n            if node:\\n                if visited:\\n                    res.append(node.val)\\n                else:  \\n                    # inorder: left -> root -> right\\n                    # switch because stacks work backwards\\n                    stack.append((node.right, False)) # has not been visited before\\n                    stack.append((node, True)) # has been visited before\\n                    stack.append((node.left, False)) # has not been visited before \\n        return res\\n```\\n\\nNow to the fun part... True or False?\\n- False = you have appended to stack once\\n- True = you have popped the False, second appending is True\\n\\n```\\n# True vs. False\\n\\n         1\\n        / \\\\\\n       2   3\\n      / \\\\\\n     4   5\\n\\nroot  = 1\\nstack = [(root,False)]\\nFalse = not yet visited \\n\\n\\n# While stack:\\n    node, visited = stack.pop([(1,False)])\\n    \\n    if node: node = (1)\\n        if visited: FALSE\\n        \\n        else:   stack.append(node = 3, False) # hasn\\'t been visited yet \\n                stack.append(node = 1, True) # has been visited once before\\n                stack.append(node = 2, False) # hasn\\'t been visited yet\\nstack = [(3,False),(1, True),(2,False)]\\n\\n# while stack:\\n    node, visited = stack.pop(2,False)\\n    \\n    if node: node = 2\\n        if visited: FALSE\\n        \\n        else:   stack.append(node = 5, False) # hasn\\'t been visited yet   \\n                stack.append(node = 2, True) # has been visited once before\\n                stack.append(node = 4, False) # hasn\\'t been visited yet         \\nstack = [(3,False),(1, True),(5,False),(2,True),(4,False)]\\n\\n# while stack:\\n    node, visited = stack.pop(4,False)\\n    \\n    if node: node = 4\\n        if visited: False\\n\\n        else:   stack.append(NA) # leaf   \\n                stack.append(node = 4, True) # has been visited once before\\n                stack.append(NA) # leaf         \\nstack = [(3,False),(1, True),(5,False),(2,True),(4,True)]\\n\\n# while stack:\\n    node, visited = stack.pop(4,True)\\n    \\n    if node: node = 4\\n        if visited: True\\n            res.append(node.4)\\nres = [4]\\nstack = [(3,False),(1, True),(5,False),(2,True)]\\n\\n# while stack:\\n    node, visited = stack.pop(2,True)\\n    \\n    if node: node = 2\\n        if visited: True \\n            res.append(node.2)\\nres = [4,2]\\nstack = [(3,False),(1, True),(5,False)]\\n\\n# while stack:\\n    node, visited = stack.pop(5,False)\\n    \\n    if node: node = 5\\n        if visited: False\\n            \\n        else:   stack.append(NA) # leaf   \\n                stack.append(node = 5, True) # has been visited once before\\n                stack.append(NA) # leaf              \\nres = [4,2]\\nstack = [(3,False),(1, True),(5,True)]        \\n\\n# while stack:\\n    node, visited = stack.pop(5,True)\\n    \\n    if node: node = 5\\n        if visited: True \\n            res.append(node.5)\\nres = [4,2,5]\\nstack = [(3,False),(1, True)]  \\n\\n# while stack:\\n    node, visited = stack.pop(1,True)\\n    \\n    if node: node = 1\\n        if visited: True \\n            res.append(node.1)\\nres = [4,2,5,1]\\nstack = [(3,False)]  \\n\\n# while stack:\\n    node, visited = stack.pop(3,False)\\n    \\n    if node: node = 3\\n        if visited: False\\n\\n        else:   stack.append(NA) # leaf   \\n                stack.append(node = 3, True) # has been visited once before\\n                stack.append(NA) # leaf   \\nres = [4,2,5,1]\\nstack = [(3,True)] \\n\\n# while stack:\\n    node, visited = stack.pop(3,True)\\n    if node: node = 3\\n        if visited: True \\n            res.append(node.3)\\nres = [4,2,5,1,3]\\nstack = []  \\n```\\n\\nHope that helps :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        res = []\\n        # root starts out False because you haven\\'t visited it yet\\n        stack = [(root, False)]\\n        \\n        while stack:\\n            # pop the last element\\n            node, visited = stack.pop() \\n            if node:\\n                if visited:\\n                    res.append(node.val)\\n                else:  \\n                    # inorder: left -> root -> right\\n                    # switch because stacks work backwards\\n                    stack.append((node.right, False)) # has not been visited before\\n                    stack.append((node, True)) # has been visited before\\n                    stack.append((node.left, False)) # has not been visited before \\n        return res\\n```\n```\\n# True vs. False\\n\\n         1\\n        / \\\\\\n       2   3\\n      / \\\\\\n     4   5\\n\\nroot  = 1\\nstack = [(root,False)]\\nFalse = not yet visited \\n\\n\\n# While stack:\\n    node, visited = stack.pop([(1,False)])\\n    \\n    if node: node = (1)\\n        if visited: FALSE\\n        \\n        else:   stack.append(node = 3, False) # hasn\\'t been visited yet \\n                stack.append(node = 1, True) # has been visited once before\\n                stack.append(node = 2, False) # hasn\\'t been visited yet\\nstack = [(3,False),(1, True),(2,False)]\\n\\n# while stack:\\n    node, visited = stack.pop(2,False)\\n    \\n    if node: node = 2\\n        if visited: FALSE\\n        \\n        else:   stack.append(node = 5, False) # hasn\\'t been visited yet   \\n                stack.append(node = 2, True) # has been visited once before\\n                stack.append(node = 4, False) # hasn\\'t been visited yet         \\nstack = [(3,False),(1, True),(5,False),(2,True),(4,False)]\\n\\n# while stack:\\n    node, visited = stack.pop(4,False)\\n    \\n    if node: node = 4\\n        if visited: False\\n\\n        else:   stack.append(NA) # leaf   \\n                stack.append(node = 4, True) # has been visited once before\\n                stack.append(NA) # leaf         \\nstack = [(3,False),(1, True),(5,False),(2,True),(4,True)]\\n\\n# while stack:\\n    node, visited = stack.pop(4,True)\\n    \\n    if node: node = 4\\n        if visited: True\\n            res.append(node.4)\\nres = [4]\\nstack = [(3,False),(1, True),(5,False),(2,True)]\\n\\n# while stack:\\n    node, visited = stack.pop(2,True)\\n    \\n    if node: node = 2\\n        if visited: True \\n            res.append(node.2)\\nres = [4,2]\\nstack = [(3,False),(1, True),(5,False)]\\n\\n# while stack:\\n    node, visited = stack.pop(5,False)\\n    \\n    if node: node = 5\\n        if visited: False\\n            \\n        else:   stack.append(NA) # leaf   \\n                stack.append(node = 5, True) # has been visited once before\\n                stack.append(NA) # leaf              \\nres = [4,2]\\nstack = [(3,False),(1, True),(5,True)]        \\n\\n# while stack:\\n    node, visited = stack.pop(5,True)\\n    \\n    if node: node = 5\\n        if visited: True \\n            res.append(node.5)\\nres = [4,2,5]\\nstack = [(3,False),(1, True)]  \\n\\n# while stack:\\n    node, visited = stack.pop(1,True)\\n    \\n    if node: node = 1\\n        if visited: True \\n            res.append(node.1)\\nres = [4,2,5,1]\\nstack = [(3,False)]  \\n\\n# while stack:\\n    node, visited = stack.pop(3,False)\\n    \\n    if node: node = 3\\n        if visited: False\\n\\n        else:   stack.append(NA) # leaf   \\n                stack.append(node = 3, True) # has been visited once before\\n                stack.append(NA) # leaf   \\nres = [4,2,5,1]\\nstack = [(3,True)] \\n\\n# while stack:\\n    node, visited = stack.pop(3,True)\\n    if node: node = 3\\n        if visited: True \\n            res.append(node.3)\\nres = [4,2,5,1,3]\\nstack = []  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1287690,
                "title": "c-solution-100-faster-iterative-and-recursive-version",
                "content": "Both iterative and recursive solutions are equally fast(0ms, 100% faster).\\n\\n```\\n//iterative solution using stack\\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    int*ans=malloc(100*sizeof(int));\\n    *returnSize=0;\\n    struct TreeNode**stack=malloc(100*sizeof(struct TreeNode*));\\n    int top=0;\\n    while(top||root){\\n        if(root){\\n            stack[top++]=root;\\n            root=root->left;\\n        }\\n        else{\\n            root=stack[--top];\\n            ans[(*returnSize)++]=root->val;\\n            root=root->right;\\n        }\\n    }\\n    free(stack);\\n    ans=realloc(ans,(*returnSize)*sizeof(int));\\n    return ans;\\n}\\n```\\n\\n```\\n//recursive solution\\nvoid traverse(struct TreeNode* root, int* arr, int* returnSize){\\n    if(root->left)\\n        traverse(root->left,arr,returnSize);\\n    arr[(*returnSize)++]=root->val;\\n    if(root->right)\\n        traverse(root->right,arr,returnSize);\\n}\\n\\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    int*arr=malloc(100*sizeof(int));\\n    *returnSize=0;\\n    if(root)\\n        traverse(root,arr,returnSize);\\n    arr=realloc(arr,(*returnSize)*sizeof(int));\\n    return arr;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//iterative solution using stack\\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    int*ans=malloc(100*sizeof(int));\\n    *returnSize=0;\\n    struct TreeNode**stack=malloc(100*sizeof(struct TreeNode*));\\n    int top=0;\\n    while(top||root){\\n        if(root){\\n            stack[top++]=root;\\n            root=root->left;\\n        }\\n        else{\\n            root=stack[--top];\\n            ans[(*returnSize)++]=root->val;\\n            root=root->right;\\n        }\\n    }\\n    free(stack);\\n    ans=realloc(ans,(*returnSize)*sizeof(int));\\n    return ans;\\n}\\n```\n```\\n//recursive solution\\nvoid traverse(struct TreeNode* root, int* arr, int* returnSize){\\n    if(root->left)\\n        traverse(root->left,arr,returnSize);\\n    arr[(*returnSize)++]=root->val;\\n    if(root->right)\\n        traverse(root->right,arr,returnSize);\\n}\\n\\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    int*arr=malloc(100*sizeof(int));\\n    *returnSize=0;\\n    if(root)\\n        traverse(root,arr,returnSize);\\n    arr=realloc(arr,(*returnSize)*sizeof(int));\\n    return arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2547065,
                "title": "leetcode-the-hard-way-dfs-in-order-explained-line-by-line",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\nI\\'ll explain my solution line by line daily and you can find the full list in my [Discord](https://discord.gg/Nqm4jJcyBf).\\nIf you like it, please give a star, watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post.\\n\\nYou may also check out my recent DFS solutions on other tree problems.\\n\\n- [987. Vertical Order Traversal of a Binary Tree](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/discuss/2527028/leetcode-the-hard-way-easy-dfs-explained-line-by-line)\\n- [1448. Count Good Nodes in Binary Tree](https://leetcode.com/problems/count-good-nodes-in-binary-tree/discuss/2511705/leetcode-the-hard-way-dfs-explained-line-by-line)\\n- [814. Binary Tree Pruning](https://leetcode.com/problems/binary-tree-pruning/discuss/2537510/leetcode-the-hard-way-easy-dfs-explained-line-by-line)\\n- [606. Construct String from Binary Tree](https://leetcode.com/problems/construct-string-from-binary-tree/discuss/2542523/leetcode-the-hard-way-dfs-5-cases-explained-line-by-line)\\n\\nThe steps for in-order is \\n- traverse left subtree \\n- do something with root value\\n-  traverse right sub tree. \\n\\nFor example 1, starting the root node 1.\\n \\n- At node 1 now, traverse left node first, however, there is no left node, hence return.\\n- At node 1 now, add root value which is 1. answer = [1]\\n- At node 1 now, traverse right node.\\n- At node 2 now, traverse left node first.\\n- At node 3 now,  traverse left node first, however, there is no left node, hence return.\\n- At node 3 now, add root value which is 3. answer = [1, 3]\\n- At node 3 now,  traverse right node, however, there is no right node, hence return.\\n- At node 2 now, add root value which is 2. answer = [1, 3, 2]\\n- At node 2 now, traverse right node, however, there is no right node, hence return.\\n\\n**C++**\\n\\n```cpp\\n// Time Complexity: O(N)\\n// Space Complexity: O(N)\\n\\n// This is a standard in-order traversal problem, I\\'d suggest to learn pre-order and post-order as well.\\n// Here\\'s a short tutorial if you\\'re interested.\\n// https://wingkwong.github.io/leetcode-the-hard-way/tutorials/graph-theory/binary-tree\\n// then you may try the following problems \\n// 144. Binary Tree Preorder Traversal: https://leetcode.com/problems/binary-tree-preorder-traversal/\\n// 145. Binary Tree Postorder Traversal: https://leetcode.com/problems/binary-tree-postorder-traversal/\\n\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void inorder(TreeNode* node) {\\n        if (node == NULL) return;\\n        // traverse the left node\\n        inorder(node->left);\\n        // do something with node value here\\n        ans.push_back(node->val);\\n        // traverse the right node\\n        inorder(node->right);\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        inorder(root);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n\\n```py\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n# This is a standard in-order traversal problem, I\\'d suggest to learn pre-order and post-order as well.\\n# Here\\'s a short tutorial if you\\'re interested.\\n# https://wingkwong.github.io/leetcode-the-hard-way/tutorials/graph-theory/binary-tree\\n# then you may try the following problems \\n# 144. Binary Tree Preorder Traversal: https://leetcode.com/problems/binary-tree-preorder-traversal/\\n# 145. Binary Tree Postorder Traversal: https://leetcode.com/problems/binary-tree-postorder-traversal/\\n\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\t\\t# left -> root -> right\\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) if root else []\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```cpp\\n// Time Complexity: O(N)\\n// Space Complexity: O(N)\\n\\n// This is a standard in-order traversal problem, I\\'d suggest to learn pre-order and post-order as well.\\n// Here\\'s a short tutorial if you\\'re interested.\\n// https://wingkwong.github.io/leetcode-the-hard-way/tutorials/graph-theory/binary-tree\\n// then you may try the following problems \\n// 144. Binary Tree Preorder Traversal: https://leetcode.com/problems/binary-tree-preorder-traversal/\\n// 145. Binary Tree Postorder Traversal: https://leetcode.com/problems/binary-tree-postorder-traversal/\\n\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void inorder(TreeNode* node) {\\n        if (node == NULL) return;\\n        // traverse the left node\\n        inorder(node->left);\\n        // do something with node value here\\n        ans.push_back(node->val);\\n        // traverse the right node\\n        inorder(node->right);\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        inorder(root);\\n        return ans;\\n    }\\n};\\n```\n```py\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n# This is a standard in-order traversal problem, I\\'d suggest to learn pre-order and post-order as well.\\n# Here\\'s a short tutorial if you\\'re interested.\\n# https://wingkwong.github.io/leetcode-the-hard-way/tutorials/graph-theory/binary-tree\\n# then you may try the following problems \\n# 144. Binary Tree Preorder Traversal: https://leetcode.com/problems/binary-tree-preorder-traversal/\\n# 145. Binary Tree Postorder Traversal: https://leetcode.com/problems/binary-tree-postorder-traversal/\\n\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\t\\t# left -> root -> right\\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) if root else []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1508286,
                "title": "c-simple-recursive-solution",
                "content": "**C++ :**\\n\\n```\\nvoid inorderTraversalHelper(TreeNode* root, vector<int> &res) {\\n\\tif(root)\\n\\t{\\n\\t\\tif(root -> left)\\n\\t\\t\\tinorderTraversalHelper(root -> left, res);\\n\\n\\t\\tres.push_back(root -> val);\\n\\n\\t\\tif(root -> right)\\n\\t\\t\\tinorderTraversalHelper(root -> right, res);\\n\\t}\\n\\n\\treturn;\\n}\\n\\n\\nvector<int> inorderTraversal(TreeNode* root) \\n{   \\n\\tvector<int> res;\\n\\tinorderTraversalHelper(root, res) ;\\n\\treturn res;\\n}\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvoid inorderTraversalHelper(TreeNode* root, vector<int> &res) {\\n\\tif(root)\\n\\t{\\n\\t\\tif(root -> left)\\n\\t\\t\\tinorderTraversalHelper(root -> left, res);\\n\\n\\t\\tres.push_back(root -> val);\\n\\n\\t\\tif(root -> right)\\n\\t\\t\\tinorderTraversalHelper(root -> right, res);\\n\\t}\\n\\n\\treturn;\\n}\\n\\n\\nvector<int> inorderTraversal(TreeNode* root) \\n{   \\n\\tvector<int> res;\\n\\tinorderTraversalHelper(root, res) ;\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31313,
                "title": "three-ways-of-iterative-inorder-traversing-easy-explanation",
                "content": "Three types of Iterative Inorder Traversals. \\n\\n1) **Using 1 Stack.** O(n) Time & O(n) Space\\n\\t* Push all `left` nodes into the `stack` till it hits `NULL`.\\n\\t* Then `Pop` the top element from the stack, print it and make the `root` point to its `right`.\\n\\t* Keep iterating till `both` the below conditions are met -\\n\\t\\t* Stack is empty `and`\\n        * Root is NULL.\\n\\t\\n```\\n \\npublic List<Integer> inorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> out = new ArrayList<Integer>();\\n\\t\\tif(root==null)\\n\\t\\t\\treturn out;\\n\\t\\tStack<TreeNode> s = new Stack();      \\n\\t\\twhile(root!=null || !s.empty()){\\n\\t\\t\\tif(root!=null){\\t\\t\\t\\t\\n\\t\\t\\t\\ts.push(root);\\n\\t\\t\\t\\troot = root.left;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\troot = s.pop();\\n\\t\\t\\t\\tout.add(root.val);\\n\\t\\t\\t\\troot = root.right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn out;\\n\\t}\\n\\t\\n```\\n\\n2) **Using 2 Stacks.** O(n) Time & O(n) Space\\nWe use two stacks. Stack `s` is used to find and traverse the child nodes, and `path` stack keeps track of the path from the `root` to the current node. (This is usefull in certain problems like [Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/) and [Path Sum](https://leetcode.com/problems/path-sum/) ). \\nThe logic is similar to [Preorder using 2 Stacks](https://discuss.leetcode.com/topic/64675/three-ways-of-iterative-preorder-traversing-easy-explanation) . The difference is on every iteration we first pop `s`. Then push it back in when we push the children. Make sure the order of pushing is right child -> root -> left child. Also, we print the element only on our way back.\\n    * Initially we push the `root` into `s`.\\n\\t* Keep iterating with below logic till `s` is `empty`.\\n\\t\\t* `root` = `s.pop()`\\n\\t\\t* If the top elements of both the stacks are not the same :\\t\\t\\n\\t\\t\\t* Push `root` into `path`.\\n\\t\\t\\t* Push `right child` into `s` if it exists.\\n\\t\\t\\t* Push `root` back into `s`.\\n\\t\\t\\t* Now, push `left child` into `s` if it exists.\\n\\t\\t* When top elements of both stacks are equal. (Which means we hit a deadend, and need to turn back)\\n\\t\\t\\t* Pop from `path`.\\n\\t\\t\\t* Print the root.\\n\\t\\n```\\n\\n\\tpublic List<Integer> inorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> out = new ArrayList<Integer>();\\n        if(root == null)\\n            return out; \\n        Stack<TreeNode> s = new Stack(), path = new Stack();\\n        s.push(root);\\n        while(!s.empty()){\\n            root = s.pop();\\n            if(!path.empty() && path.peek()==root){                \\n                path.pop();\\n\\t\\t    out.add(root.val);\\n            }\\n            else{                \\n                path.push(root);\\n                if(root.right != null)\\n                    s.push(root.right);\\n\\t\\t    s.push(root);\\n                if(root.left != null)\\n                    s.push(root.left);\\n            }\\n        }\\n\\t    return out;\\n    }\\n\\t\\n```\\n\\n3) **Using No Stacks (Morris Traversal).** O(n) Time & O(1) Space\\nInstead of using stacks to remember our way back up the tree, we are going to modify the tree to create upwards links. The idea is based on [Threaded Binary Tree](https://en.wikipedia.org/wiki/Threaded_binary_tree). \\n\\t* Iterate till `root` is null.\\n\\t\\t* If `root` has a left child.\\n\\t\\t\\t* Find the `inorder predecessor`. (Inorder predecessor of root is the right most child of its left child)\\n\\t\\t\\t\\t* Make it point to root.\\n\\t\\t\\t\\t* `root` = `root.left`.\\n\\t\\t\\t* If its already pointing to root (which means we have traversed it already and are on our way up.)\\n\\t\\t\\t\\t* Make the `inorder predecessor` point to `null` (Reverting our structural changes)\\n\\t\\t\\t\\t* `root` = `root.right`.\\n\\t\\t* If left child is `null`\\n\\t\\t\\t* `root` = `root.right`. (We are climbing up our link.)\\n\\t\\t\\t\\n```\\n\\n\\tpublic List<Integer> inorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> out = new ArrayList<Integer>();\\n\\t\\t\\tif(root == null)\\n\\t\\t\\t\\treturn out;\\n\\t\\t\\tTreeNode pre = null;\\n\\t\\t\\twhile(root!=null){\\n\\t\\t\\t\\tif(root.left !=null){\\n\\t\\t\\t\\t\\tpre = root.left;\\n\\t\\t\\t\\t\\twhile(pre.right!=null && pre.right!=root)\\n\\t\\t\\t\\t\\t\\tpre=pre.right;\\n\\t\\t\\t\\t\\tif(pre.right==null){\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tpre.right=root;\\n\\t\\t\\t\\t\\t\\troot=root.left;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t    out.add(root.val);\\n\\t\\t\\t\\t\\t\\tpre.right=null;\\n\\t\\t\\t\\t\\t\\troot=root.right;\\n\\t\\t\\t\\t\\t}                   \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tout.add(root.val);\\n\\t\\t\\t\\t\\troot=root.right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn out;\\n\\t\\t}\\n\\t\\t\\n```\\n\\nAlso checkout [PostOrder](https://discuss.leetcode.com/topic/64689/three-ways-of-iterative-postorder-traversing-easy-explanation)  & [PreOrder](https://discuss.leetcode.com/topic/64675/three-ways-of-iterative-preorder-traversing-easy-explanation)  :))",
                "solutionTags": [],
                "code": "```\\n \\npublic List<Integer> inorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> out = new ArrayList<Integer>();\\n\\t\\tif(root==null)\\n\\t\\t\\treturn out;\\n\\t\\tStack<TreeNode> s = new Stack();      \\n\\t\\twhile(root!=null || !s.empty()){\\n\\t\\t\\tif(root!=null){\\t\\t\\t\\t\\n\\t\\t\\t\\ts.push(root);\\n\\t\\t\\t\\troot = root.left;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\troot = s.pop();\\n\\t\\t\\t\\tout.add(root.val);\\n\\t\\t\\t\\troot = root.right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn out;\\n\\t}\\n\\t\\n```\n```\\n\\n\\tpublic List<Integer> inorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> out = new ArrayList<Integer>();\\n        if(root == null)\\n            return out; \\n        Stack<TreeNode> s = new Stack(), path = new Stack();\\n        s.push(root);\\n        while(!s.empty()){\\n            root = s.pop();\\n            if(!path.empty() && path.peek()==root){                \\n                path.pop();\\n\\t\\t    out.add(root.val);\\n            }\\n            else{                \\n                path.push(root);\\n                if(root.right != null)\\n                    s.push(root.right);\\n\\t\\t    s.push(root);\\n                if(root.left != null)\\n                    s.push(root.left);\\n            }\\n        }\\n\\t    return out;\\n    }\\n\\t\\n```\n```\\n\\n\\tpublic List<Integer> inorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> out = new ArrayList<Integer>();\\n\\t\\t\\tif(root == null)\\n\\t\\t\\t\\treturn out;\\n\\t\\t\\tTreeNode pre = null;\\n\\t\\t\\twhile(root!=null){\\n\\t\\t\\t\\tif(root.left !=null){\\n\\t\\t\\t\\t\\tpre = root.left;\\n\\t\\t\\t\\t\\twhile(pre.right!=null && pre.right!=root)\\n\\t\\t\\t\\t\\t\\tpre=pre.right;\\n\\t\\t\\t\\t\\tif(pre.right==null){\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tpre.right=root;\\n\\t\\t\\t\\t\\t\\troot=root.left;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t    out.add(root.val);\\n\\t\\t\\t\\t\\t\\tpre.right=null;\\n\\t\\t\\t\\t\\t\\troot=root.right;\\n\\t\\t\\t\\t\\t}                   \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tout.add(root.val);\\n\\t\\t\\t\\t\\troot=root.right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn out;\\n\\t\\t}\\n\\t\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 890237,
                "title": "go-solution",
                "content": "```go\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc inorderTraversal(root *TreeNode) []int {\\n    \\n    ans := []int{}\\n    \\n    var inorder func(*TreeNode) \\n    \\n    inorder = func(root *TreeNode) {\\n        if root == nil {return}\\n        \\n        inorder(root.Left)\\n        ans = append(ans, root.Val)\\n        inorder(root.Right)\\n        \\n    }\\n    inorder(root)\\n    \\n    return ans;   \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc inorderTraversal(root *TreeNode) []int {\\n    \\n    ans := []int{}\\n    \\n    var inorder func(*TreeNode) \\n    \\n    inorder = func(root *TreeNode) {\\n        if root == nil {return}\\n        \\n        inorder(root.Left)\\n        ans = append(ans, root.Val)\\n        inorder(root.Right)\\n        \\n    }\\n    inorder(root)\\n    \\n    return ans;   \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31409,
                "title": "share-my-solution-in-c",
                "content": "///// iterative solution\\n\\n    int* inorderTraversal(struct TreeNode* root, int* returnSize) {\\n    int *result = NULL;\\n    *returnSize = 0;\\n    \\n    struct TreeNode **stack = (struct TreeNode **)malloc(sizeof(struct TreeNode *));\\n    struct TreeNode *pop;\\n    int length = 0, state = 1;\\n    //stack[length++] = root;\\n    \\n    while (length>0 || root != NULL) {\\n        if (root) {\\n            stack = (struct TreeNode **)realloc(stack, sizeof(struct TreeNode *)*length+1);\\n            stack[length++] = root;\\n            root = root->left;\\n        }\\n        else {\\n            root = stack[--length];\\n            result = (int *)realloc(result, sizeof(int)*(*returnSize+1));\\n            result[*returnSize] = root->val;\\n            *returnSize += 1;\\n            root = root->right;\\n        }\\n    }\\n    \\n    return result;\\n}\\n\\n//// recursive solution\\n\\n    int* inorderTraversal(struct TreeNode* root, int* returnSize) {\\n    int *result = NULL;\\n    if (!root)\\n        return result;\\n    \\n    int *leftarr=NULL, *rightarr=NULL, leftsize=0, rightsize=0;\\n    if (root->left)\\n        leftarr = inorderTraversal(root->left, &leftsize);\\n    if (root->right)\\n        rightarr = inorderTraversal(root->right, &rightsize);\\n    \\n    *returnSize = 1 + leftsize + rightsize;\\n    result = (int *)malloc(sizeof(int)*(*returnSize));\\n    \\n    int i, j;\\n    for (i=0; i<leftsize; i++)\\n        result[i] = leftarr[i];\\n    result[i++] = root->val;\\n    for (j=0; j<rightsize; j++)\\n        result[i+j] = rightarr[j];\\n    free(leftarr); free(rightarr);\\n    \\n    return result;\\n}",
                "solutionTags": [],
                "code": "///// iterative solution\\n\\n    int* inorderTraversal(struct TreeNode* root, int* returnSize) {\\n    int *result = NULL;\\n    *returnSize = 0;\\n    \\n    struct TreeNode **stack = (struct TreeNode **)malloc(sizeof(struct TreeNode *));\\n    struct TreeNode *pop;\\n    int length = 0, state = 1;\\n    //stack[length++] = root;\\n    \\n    while (length>0 || root != NULL) {\\n        if (root) {\\n            stack = (struct TreeNode **)realloc(stack, sizeof(struct TreeNode *)*length+1);\\n            stack[length++] = root;\\n            root = root->left;\\n        }\\n        else {\\n            root = stack[--length];\\n            result = (int *)realloc(result, sizeof(int)*(*returnSize+1));\\n            result[*returnSize] = root->val;\\n            *returnSize += 1;\\n            root = root->right;\\n        }\\n    }\\n    \\n    return result;\\n}\\n\\n//// recursive solution\\n\\n    int* inorderTraversal(struct TreeNode* root, int* returnSize) {\\n    int *result = NULL;\\n    if (!root)\\n        return result;\\n    \\n    int *leftarr=NULL, *rightarr=NULL, leftsize=0, rightsize=0;\\n    if (root->left)\\n        leftarr = inorderTraversal(root->left, &leftsize);\\n    if (root->right)\\n        rightarr = inorderTraversal(root->right, &rightsize);\\n    \\n    *returnSize = 1 + leftsize + rightsize;\\n    result = (int *)malloc(sizeof(int)*(*returnSize));\\n    \\n    int i, j;\\n    for (i=0; i<leftsize; i++)\\n        result[i] = leftarr[i];\\n    result[i++] = root->val;\\n    for (j=0; j<rightsize; j++)\\n        result[i+j] = rightarr[j];\\n    free(leftarr); free(rightarr);\\n    \\n    return result;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 160386,
                "title": "python-solution",
                "content": "Recursive:\\n```\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if root == None:\\n            return []\\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\\n```\\nIterative:\\n```\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if root == None:\\n            return []\\n        trav = root\\n        res = []\\n        stack = []\\n        while stack or trav:\\n            while trav:\\n                stack.append(trav)\\n                trav = trav.left\\n            u = stack.pop()\\n            res.append(u.val)\\n            trav = u.right\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if root == None:\\n            return []\\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\\n```\n```\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if root == None:\\n            return []\\n        trav = root\\n        res = []\\n        stack = []\\n        while stack or trav:\\n            while trav:\\n                stack.append(trav)\\n                trav = trav.left\\n            u = stack.pop()\\n            res.append(u.val)\\n            trav = u.right\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107203,
                "title": "java-recursive-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDFS in order traversal\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    private List<Integer> res = new ArrayList<>();\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        traverse(root);\\n        return res;\\n    }\\n    \\n    private void traverse(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        traverse(root.left);\\n        res.add(root.val);\\n        traverse(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    private List<Integer> res = new ArrayList<>();\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        traverse(root);\\n        return res;\\n    }\\n    \\n    private void traverse(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        traverse(root.left);\\n        res.add(root.val);\\n        traverse(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547003,
                "title": "easy-python-3-line-solution",
                "content": "```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return []\\n        return self.inorderTraversal(root.left)+[root.val]+self.inorderTraversal(root.right)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return []\\n        return self.inorderTraversal(root.left)+[root.val]+self.inorderTraversal(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418125,
                "title": "simple-python-solution-recursive",
                "content": "```\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if not root:\\n            return []\\n        else:\\n            return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if not root:\\n            return []\\n        else:\\n            return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 307460,
                "title": "c-simple-solution",
                "content": "```\\nvoid travel(struct TreeNode* root,int *ret,int *size)\\n{\\n    if(root==NULL)return;\\n    travel(root->left,ret,size);\\n    ret[(*size)++]=root->val;\\n    travel(root->right,ret,size);\\n}\\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    *returnSize=0;\\n    int *ret=malloc(sizeof(int)*100);\\n    travel(root,ret,returnSize);\\n    return ret;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nvoid travel(struct TreeNode* root,int *ret,int *size)\\n{\\n    if(root==NULL)return;\\n    travel(root->left,ret,size);\\n    ret[(*size)++]=root->val;\\n    travel(root->right,ret,size);\\n}\\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    *returnSize=0;\\n    int *ret=malloc(sizeof(int)*100);\\n    travel(root,ret,returnSize);\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31375,
                "title": "java-two-solutions-recursive-1-ms-and-non-recursive-2-ms",
                "content": "Recursive:`\\n\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list =new ArrayList();\\n        addNode(list,root);\\n        return list;\\n    }\\n    public void addNode(List<Integer> list,TreeNode root){\\n        if(root==null) return;\\n        addNode(list,root.left);\\n        list.add(root.val);\\n        addNode(list,root.right); \\n    }\\n\\nNon-recursive :`\\n\\n        List<Integer> list =new ArrayList();\\n        Stack<TreeNode> stack=new Stack();\\n        if(root==null) return list;\\n        while(root!=null){\\n            stack.push(root);\\n            root=root.left;\\n            while(root==null){\\n                if(stack.empty()) return list;\\n                root=stack.pop();\\n                list.add(root.val);\\n                root=root.right;\\n            }\\n        }\\n        return list;\\n `",
                "solutionTags": [],
                "code": "Recursive:`\\n\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list =new ArrayList();\\n        addNode(list,root);\\n        return list;\\n    }\\n    public void addNode(List<Integer> list,TreeNode root){\\n        if(root==null) return;\\n        addNode(list,root.left);\\n        list.add(root.val);\\n        addNode(list,root.right); \\n    }\\n\\nNon-recursive :`\\n\\n        List<Integer> list =new ArrayList();\\n        Stack<TreeNode> stack=new Stack();\\n        if(root==null) return list;\\n        while(root!=null){\\n            stack.push(root);\\n            root=root.left;\\n            while(root==null){\\n                if(stack.empty()) return list;\\n                root=stack.pop();\\n                list.add(root.val);\\n                root=root.right;\\n            }\\n        }\\n        return list;\\n `",
                "codeTag": "Unknown"
            },
            {
                "id": 31464,
                "title": "4ms-iterative-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<int> inorderTraversal(TreeNode *root) {\\n            stack<TreeNode*> s;\\n            pushAllLeft(s, root);\\n            vector<int> result;\\n            while(!s.empty()) {\\n                TreeNode* p = s.top();\\n                s.pop();\\n                result.push_back(p->val);\\n                pushAllLeft(s,p->right);\\n            }\\n            return result;\\n        }\\n        \\n        void pushAllLeft(stack<TreeNode*>& s, TreeNode* root) {\\n            while(root) {\\n                s.push(root);\\n                root = root->left;\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> inorderTraversal(TreeNode *root) {\\n            stack<TreeNode*> s;\\n            pushAllLeft(s, root);\\n            vector<int> result;\\n            while(!s.empty()) {\\n                TreeNode* p = s.top();\\n                s.pop();\\n                result.push_back(p->val);\\n                pushAllLeft(s,p->right);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3673822,
                "title": "simplest-3-line-sol-with-explaination",
                "content": "# Intuition\\nThis code performs a inorder traversal on a binary tree and returns a list of integers containing the values of the nodes visited in the traversal.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Create an instance variable `ans` of type `List<Integer>` to store the values of the nodes in the inorder traversal.\\n2. Define the `inorderTraversal` function that takes a `TreeNode` called `root` as input and returns a list of integers.\\n3. Check if the `root` is null. If it is, return the `ans` list.\\n4. Recursively call the `inorderTraversal` function on the left child of the current `root` node.\\n5. Add the value of the current `root` node to the `ans` list using the `add` method.\\n6. Recursively call the `inorderTraversal` function on the right child of the current `root` node.\\n7. Finally, return the `ans` list containing the values of the nodes visited in the inorder traversal.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    List<Integer> ans = new ArrayList<>();\\n\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n   if (root == null) return ans;\\n   inorderTraversal(root.left);\\n   ans.add(root.val);\\n   inorderTraversal(root.right);\\n   return ans;\\n}\\n}\\n```\\n![images.jpeg](https://assets.leetcode.com/users/images/34562f78-5f5b-4e2e-a154-2df98ad56ee8_1687528905.3259234.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    List<Integer> ans = new ArrayList<>();\\n\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n   if (root == null) return ans;\\n   inorderTraversal(root.left);\\n   ans.add(root.val);\\n   inorderTraversal(root.right);\\n   return ans;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926144,
                "title": "100-fastest-swift-solution-time-o-n-space-o-n",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the tree.\\n    //   - space: O(n), where n is the number of nodes in the tree.\\n    \\n    func inorderTraversal(_ root: TreeNode?) -> [Int] {\\n        var ans = [Int]()\\n        var stack = [TreeNode?]()\\n        var curr = root\\n\\n        while curr != nil || !stack.isEmpty {\\n            while curr != nil {\\n                stack.append(curr)\\n                curr = curr?.left\\n            }\\n            curr = stack.removeLast()\\n            if let val = curr?.val {\\n                ans.append(val)\\n            }\\n            curr = curr?.right\\n        }\\n\\n        return ans\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the tree.\\n    //   - space: O(n), where n is the number of nodes in the tree.\\n    \\n    func inorderTraversal(_ root: TreeNode?) -> [Int] {\\n        var ans = [Int]()\\n        var stack = [TreeNode?]()\\n        var curr = root\\n\\n        while curr != nil || !stack.isEmpty {\\n            while curr != nil {\\n                stack.append(curr)\\n                curr = curr?.left\\n            }\\n            curr = stack.removeLast()\\n            if let val = curr?.val {\\n                ans.append(val)\\n            }\\n            curr = curr?.right\\n        }\\n\\n        return ans\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533303,
                "title": "iterative-inorder-traversal-with-full-explanation",
                "content": "**Inorder tree traversal** is a type of *depth first search* (DFS) where we explore tree nodes in a particular order: left, root, right. \\n\\nTypically DFS is done recursively but I could also implement it with a *stack* (an abstract data type). To solve this problem, I\\'m going to implement a stack with a Python `list`.\\n\\nA more thorough explanation can be found on my [GitHub](https://github.com/sanoke/leetcode/blob/master/tree%20traversal/0094-binary-tree-inorder-traversal.ipynb), where I also do an inorder traversal of an example tree to demonstrate some intuition behind the process.\\n\\n```python\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode):\\n        # initialize the stack\\n        stack = []\\n        # initialize the traveral list\\n        traversal = []\\n        \\n        # while we\\'re at a valid node or there are\\n        # still nodes to traverse... \\n        while stack or root:\\n            \\n            if root:\\n                # if we\\'re at a valid node,\\n                # remember where we\\'ve been and keep moving left\\n                stack.append(root)\\n                root = root.left\\n            \\n            else:\\n                # otherwise we\\'ve hit a dead end so\\n                # -- pop the most recent value\\n                # -- report out\\n                # -- move right\\n                root = stack.pop()\\n                traversal.append(root.val)\\n                root = root.right\\n        \\n        return traversal\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```python\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode):\\n        # initialize the stack\\n        stack = []\\n        # initialize the traveral list\\n        traversal = []\\n        \\n        # while we\\'re at a valid node or there are\\n        # still nodes to traverse... \\n        while stack or root:\\n            \\n            if root:\\n                # if we\\'re at a valid node,\\n                # remember where we\\'ve been and keep moving left\\n                stack.append(root)\\n                root = root.left\\n            \\n            else:\\n                # otherwise we\\'ve hit a dead end so\\n                # -- pop the most recent value\\n                # -- report out\\n                # -- move right\\n                root = stack.pop()\\n                traversal.append(root.val)\\n                root = root.right\\n        \\n        return traversal\\n```",
                "codeTag": "Java"
            },
            {
                "id": 527791,
                "title": "javascript-10-lines-iterative-and-recursive",
                "content": "### Iterative In-order Traverse\\n- Time Complexity: O(N)\\n- Space Complexity: O(H)\\n```JavaScript\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nconst inorderTraversal = (root) => {\\n    let curr = root,  res = [], stack = [];\\n    while (curr || stack.length) {\\n        while (curr) {\\n            stack.push(curr);\\n            curr = curr.left;\\n        }\\n        curr = stack.pop();\\n        res.push(curr.val);\\n        curr = curr.right;\\n    }\\n    return res;\\n};\\n```\\n### Recursive In-order Traverse\\n\\n- Time Complexity: O(N)\\n- Space Complexity: O(H)\\n```JavaScript\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nconst inorderTraversal = (root) => {\\n    const res = [];\\n    traverse(root);\\n    return res;\\n    \\n    function traverse(node) {\\n        if (!node) return;\\n        traverse(node.left);\\n        res.push(node.val);\\n        traverse(node.right);\\n    }\\n};\\n```\\n\\n- Time Complexity:\\n    - `an spread syntax takes linear time and it takes T(n/2) in this implementation`\\n    - average: O(N log N)\\n    - worst: O(N^2) `unbalanced tree`\\n- Space Complexity: O(H)\\n```JavaScript\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nconst inorderTraversal = (root) => {\\n    if (!root) return [];\\n    const res = [];\\n    res.push(...inorderTraversal(root.left));\\n    res.push(root.val);\\n    res.push(...inorderTraversal(root.right));\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```JavaScript\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nconst inorderTraversal = (root) => {\\n    let curr = root,  res = [], stack = [];\\n    while (curr || stack.length) {\\n        while (curr) {\\n            stack.push(curr);\\n            curr = curr.left;\\n        }\\n        curr = stack.pop();\\n        res.push(curr.val);\\n        curr = curr.right;\\n    }\\n    return res;\\n};\\n```\n```JavaScript\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nconst inorderTraversal = (root) => {\\n    const res = [];\\n    traverse(root);\\n    return res;\\n    \\n    function traverse(node) {\\n        if (!node) return;\\n        traverse(node.left);\\n        res.push(node.val);\\n        traverse(node.right);\\n    }\\n};\\n```\n```JavaScript\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nconst inorderTraversal = (root) => {\\n    if (!root) return [];\\n    const res = [];\\n    res.push(...inorderTraversal(root.left));\\n    res.push(root.val);\\n    res.push(...inorderTraversal(root.right));\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31364,
                "title": "java-recursive-and-iterative-solutions",
                "content": "        \\n    // recursively\\n    public List<Integer> inorderTraversal1(TreeNode root) {\\n        List<Integer> ret = new ArrayList<>();\\n        dfs(root, ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(TreeNode node, List<Integer> ret) {\\n        if (node != null) {\\n            dfs(node.left, ret);\\n            ret.add(node.val);\\n            dfs(node.right, ret);\\n        }\\n    }\\n    \\n    // iteratively\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n       Stack<TreeNode> stack = new Stack<>();\\n       List<Integer> ret = new ArrayList<>();\\n       while (true) {\\n           while (root != null) {\\n               stack.push(root);\\n               root = root.left;\\n           }\\n           if (stack.isEmpty()) {\\n               break;  // no node left\\n           }\\n           TreeNode node = stack.pop();\\n           ret.add(node.val);\\n           root = node.right;\\n       }\\n       return ret;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "        \\n    // recursively\\n    public List<Integer> inorderTraversal1(TreeNode root) {\\n        List<Integer> ret = new ArrayList<>();\\n        dfs(root, ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(TreeNode node, List<Integer> ret) {\\n        if (node != null) {\\n            dfs(node.left, ret);\\n            ret.add(node.val);\\n            dfs(node.right, ret);\\n        }\\n    }\\n    \\n    // iteratively\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n       Stack<TreeNode> stack = new Stack<>();\\n       List<Integer> ret = new ArrayList<>();\\n       while (true) {\\n           while (root != null) {\\n               stack.push(root);\\n               root = root.left;\\n           }\\n           if (stack.isEmpty()) {\\n               break;  // no node left\\n           }\\n           TreeNode node = stack.pop();\\n           ret.add(node.val);\\n           root = node.right;\\n       }\\n       return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2967362,
                "title": "javascript-recursive-and-iterative-explained",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar inorderTraversal = function(root) {\\n    let result = [];\\n\\n    /*\\n    RECURSIVE SOLUTION\\n\\n    function inorder(root) {\\n        // if node null, return back to the prenode (works like that with recursive functions)\\n        if (!root) {\\n            return;\\n        }\\n\\n        inorder(root.left);    // recursive call for left nodes\\n        result.push(root.val); // push to result   \\n        inorder(root.right);   // when its done with left, start right\\n\\n    }\\n    // call recursive function\\n    inorder(root);\\n    return result;\\n    */\\n\\n\\n    // ITERATIVE SOLUTION \\n\\n    // The call stack, which we can return to the parent node and decide if there is something to do left\\n    let stack = [];\\n    // The pointer on the current node\\n    let currentNode = root;\\n\\n    while (currentNode || stack.length) {\\n        // this loop is going down the left nodes and exits if there is no left node anymore. Also adds all nodes to Stack\\n        if(currentNode) {\\n            stack.push(currentNode);\\n            currentNode = currentNode.left;\\n        } else {\\n// finishing the above loop, it means we are at the deepest left node we could get and all ar added, so now we need to point the currentNode to the parentNode. We do this by popping the last item in our callstack, which was the parentNode. pop returns the last item, currentNode is now the last Item (Parent)\\n        currentNode = stack.pop()\\n// We add currentNode to the result, because inorder traversal is \"\"left-root-right\"-order\", so we always add the most left node which is left (and has no left children)\\n        result.push(currentNode.val);\\n// then we point the pointer to the right node (even if its null)\\n        currentNode = currentNode.right;\\n        \\n// After we were at the deepest left, a new outer while loop is started, where is checked if currentNode exists, if yes, add to stack, move left. if not, set currentNode/pointer to parent, push it to result and set to right child node.\\n        }\\n            \\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar inorderTraversal = function(root) {\\n    let result = [];\\n\\n    /*\\n    RECURSIVE SOLUTION\\n\\n    function inorder(root) {\\n        // if node null, return back to the prenode (works like that with recursive functions)\\n        if (!root) {\\n            return;\\n        }\\n\\n        inorder(root.left);    // recursive call for left nodes\\n        result.push(root.val); // push to result   \\n        inorder(root.right);   // when its done with left, start right\\n\\n    }\\n    // call recursive function\\n    inorder(root);\\n    return result;\\n    */\\n\\n\\n    // ITERATIVE SOLUTION \\n\\n    // The call stack, which we can return to the parent node and decide if there is something to do left\\n    let stack = [];\\n    // The pointer on the current node\\n    let currentNode = root;\\n\\n    while (currentNode || stack.length) {\\n        // this loop is going down the left nodes and exits if there is no left node anymore. Also adds all nodes to Stack\\n        if(currentNode) {\\n            stack.push(currentNode);\\n            currentNode = currentNode.left;\\n        } else {\\n// finishing the above loop, it means we are at the deepest left node we could get and all ar added, so now we need to point the currentNode to the parentNode. We do this by popping the last item in our callstack, which was the parentNode. pop returns the last item, currentNode is now the last Item (Parent)\\n        currentNode = stack.pop()\\n// We add currentNode to the result, because inorder traversal is \"\"left-root-right\"-order\", so we always add the most left node which is left (and has no left children)\\n        result.push(currentNode.val);\\n// then we point the pointer to the right node (even if its null)\\n        currentNode = currentNode.right;\\n        \\n// After we were at the deepest left, a new outer while loop is started, where is checked if currentNode exists, if yes, add to stack, move left. if not, set currentNode/pointer to parent, push it to result and set to right child node.\\n        }\\n            \\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2555429,
                "title": "binary-tree-inorder-traversal",
                "content": "1. ITERATIVE APPROACH\\nIn iterative approach, the stack data structure is used. We need to store the current or parent node so that after processing the left subtree we can process the node so we push the node in the stack data structure. After processing the node, we pop that respective node.\\n\\n```\\nvector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n        stack<TreeNode*>st;\\n        while(1){\\n            if(root!=NULL){\\n                st.push(root);\\n                root=root->left;\\n            }\\n            else{\\n                if(st.empty()==true) break;\\n                root=st.top();\\n                st.pop();\\n                ans.push_back(root->val);\\n                root=root->right;\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\t\\n2. RECURSIVE APPROACH\\nThe first call recursively left child node until getting NULL value then get node value and then call recursively right child node until getting NULL. So now print the value of all nodes inorder traversing.\\n\\n```\\n\\tclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        inorder(root, nodes);\\n        return nodes;\\n    }\\nprivate:\\n    void inorder(TreeNode* root, vector<int>& nodes) {\\n        if (!root) {\\n            return;\\n        }\\n        inorder(root -> left, nodes);\\n        nodes.push_back(root -> val);\\n        inorder(root -> right, nodes);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nvector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n        stack<TreeNode*>st;\\n        while(1){\\n            if(root!=NULL){\\n                st.push(root);\\n                root=root->left;\\n            }\\n            else{\\n                if(st.empty()==true) break;\\n                root=st.top();\\n                st.pop();\\n                ans.push_back(root->val);\\n                root=root->right;\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```\\n\\tclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        inorder(root, nodes);\\n        return nodes;\\n    }\\nprivate:\\n    void inorder(TreeNode* root, vector<int>& nodes) {\\n        if (!root) {\\n            return;\\n        }\\n        inorder(root -> left, nodes);\\n        nodes.push_back(root -> val);\\n        inorder(root -> right, nodes);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547292,
                "title": "c-recursive-morris-traversal-approach",
                "content": "**Please upvote if you like the post :)**\\n\\n**Intuition:**\\nSeeing tree problems, first thing that hit\\'s your brain is? what is it? Yessss its **Recursion.**\\n\\n**Approach: (DFS Traversal)**\\n* **Inorder** Traversal follows - **Left Root Right**\\n* If `root==NULL` we can simply return `{}`;\\n* we declare a vector **vec** and simply push all the `root->val` after every **left** traversal and after that **right** traversal happens.\\n \\n**Visualization: (DFS)**\\n![image](https://assets.leetcode.com/users/images/910dc845-947f-4f49-806c-dec5f90fd9f4_1662608198.1349866.gif)\\n\\n\\n\\n\\n\\n**C++:(DFS Traversal)**\\n```\\nclass Solution {\\npublic:\\n    vector<int> vec; \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(root==NULL)\\n            return {};\\n        inorderTraversal(root->left);\\n        vec.push_back(root->val);\\n        inorderTraversal(root->right);\\n        return vec;\\n    }\\n};\\n```\\n****\\n**Time Complexity:** **O(N)**, where N is the number of nodes in the Binary Tree.\\n**Space Complexity:** **O(N)**, where N is the number of node in the Binary Tree (Recursion stack space)\\n****\\n**Approach 2: (Optimized - Morris Traversal)**\\n* So the idea is that at a `node` whether we have to move `left` or `right` is determined whether the node has a **left** subtree. \\n* If it doesn\\u2019t we move to the **right**. \\n* If there is a `left` subtree then we see its `rightmost` child. If the `rightmost` child is pointing to `NULL`, we move the **current** node to its **left**. \\n* If the **rightmost** child is already pointing towards the **current** node, we remove that link and move to the **right** of the **current** node. \\n* We will **stop** the execution when the **current** points to `null` and we have traversed the whole tree.\\n \\n**Visualization: (Optimized - Morris Traversal)**\\n![image](https://assets.leetcode.com/users/images/27affd71-dfea-4a3f-9755-d5648c86ccf5_1662608543.0316582.png)\\n\\n\\n\\n**C++:(Optimized - Morris Traversal)** \\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> inOrder;\\n        TreeNode* cur = root;\\n        while(cur!=NULL){\\n            if(cur->left==NULL){\\n                inOrder.push_back(cur->val);\\n                cur=cur->right;\\n            }\\n            else{\\n                TreeNode* prev = cur->left;\\n                while(prev->right!=NULL && prev->right!=cur){\\n                    prev=prev->right;\\n                }\\n                if(prev->right==NULL){\\n                    prev->right=cur;\\n                    cur=cur->left;\\n                }\\n                else if(prev->right==cur){\\n                    prev->right=NULL;\\n                    inOrder.push_back(cur->val);\\n                    cur=cur->right;\\n                }\\n            }\\n        }\\n        return inOrder;\\n    }\\n};\\n```\\n****\\n**Time Complexity:** **O(N)**, where N is the number of nodes in the Binary Tree.\\n**Space Complexity:** **O(1)**, constant space\\n****",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vec; \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(root==NULL)\\n            return {};\\n        inorderTraversal(root->left);\\n        vec.push_back(root->val);\\n        inorderTraversal(root->right);\\n        return vec;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> inOrder;\\n        TreeNode* cur = root;\\n        while(cur!=NULL){\\n            if(cur->left==NULL){\\n                inOrder.push_back(cur->val);\\n                cur=cur->right;\\n            }\\n            else{\\n                TreeNode* prev = cur->left;\\n                while(prev->right!=NULL && prev->right!=cur){\\n                    prev=prev->right;\\n                }\\n                if(prev->right==NULL){\\n                    prev->right=cur;\\n                    cur=cur->left;\\n                }\\n                else if(prev->right==cur){\\n                    prev->right=NULL;\\n                    inOrder.push_back(cur->val);\\n                    cur=cur->right;\\n                }\\n            }\\n        }\\n        return inOrder;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2385969,
                "title": "easiest-traversal-without-stack-queue-100-inorder",
                "content": "##  **Using This Solution We Can Make Inorder Traversal In Binary Tree Without Using Stack And Queue.**\\n\\n##### Global Declaration Of Ans Vector.\\n```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(root == NULL){\\n            return v;\\n        }\\n        inorderTraversal(root->left);\\n        v.push_back(root->val);\\n        inorderTraversal(root->right);\\n        return v;\\n    }\\n};\\n```\\n\\n\\n##### Pass By Reference Ans Vector.\\n\\n```\\nclass Solution {\\npublic:\\n    void helper(TreeNode *root, vector<int> &ans){\\n        if(root == NULL) return ;\\n        helper(root->left,ans);\\n        ans.push_back(root->val);\\n        helper(root->right,ans);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans; helper(root,ans);\\n        return ans;\\n    }\\n};\\n```\\n**Like & UpVote If You Get My Intuition Also Comment If You Have Any Query..**\\n\\n",
                "solutionTags": [
                    "Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(root == NULL){\\n            return v;\\n        }\\n        inorderTraversal(root->left);\\n        v.push_back(root->val);\\n        inorderTraversal(root->right);\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void helper(TreeNode *root, vector<int> &ans){\\n        if(root == NULL) return ;\\n        helper(root->left,ans);\\n        ans.push_back(root->val);\\n        helper(root->right,ans);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans; helper(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2294202,
                "title": "golang-recursive-100-faster-0-ms",
                "content": "```\\nfunc inorderTraversal(root *TreeNode) []int {\\n    var nums = []int{}\\n    if root == nil {\\n        return nums\\n    }\\n    \\n    nums = append(nums, inorderTraversal(root.Left)...)\\n    nums = append(nums, root.Val)\\n    nums = append(nums, inorderTraversal(root.Right)...)\\n    return nums\\n}\\nPlease upvote if you like\\n```",
                "solutionTags": [
                    "Go",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nfunc inorderTraversal(root *TreeNode) []int {\\n    var nums = []int{}\\n    if root == nil {\\n        return nums\\n    }\\n    \\n    nums = append(nums, inorderTraversal(root.Left)...)\\n    nums = append(nums, root.Val)\\n    nums = append(nums, inorderTraversal(root.Right)...)\\n    return nums\\n}\\nPlease upvote if you like\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1251231,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(root==NULL)\\n            return {};\\n        inorderTraversal(root->left);\\n        ans.push_back(root->val);\\n        inorderTraversal(root->right);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(root==NULL)\\n            return {};\\n        inorderTraversal(root->left);\\n        ans.push_back(root->val);\\n        inorderTraversal(root->right);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 668448,
                "title": "morris-traversal",
                "content": "I wanted to share an example of in-place Morris traversal. Didn\\'t see many Python examples out there. This example is based off Tushar\\'s morris traversal video: https://youtu.be/wGXB9OWhPTg and various sources I found: \\n\\nhttps://www.***.org/inorder-tree-traversal-without-recursion-and-without-stack/\\n\\nhttps://leetcode.com/problems/binary-tree-inorder-traversal/discuss/148939/CPP-Morris-Traversal\\n\\n```python\\n\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        res = []\\n\\n        while root:\\n            if not root.left: # if we don\\'t have a left, this is our best in-order value at the moment. add it to the list and move right.\\n                res.append(root.val)\\n                root = root.right\\n            else:\\n                pred = self.findPredecessor(root) # find the predecessor for the given node. This is the farthest right of the first left we see.\\n\\n\\t\\t\\t\\t# if we have a right we have move on to explore this sub tree. The pred.right != root check is to ensure that we\\'re not ex\\n                if pred.right != root:\\n                    pred.right = root\\n                    root = root.left\\n                else: \\n\\t\\t\\t\\t# otherwise, we have found a pointer back to the current root and we need to rewrite the tree structure. This is basically a form of \"have we seen this before?\".\\n                    root.left = None\\n\\n        return res\\n\\n    def findPredecessor(self, root: TreeNode) -> TreeNode:\\n        curr = root.left\\n\\n        while curr.right and curr.right != root:\\n            curr = curr.right\\n\\n        return curr\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\n\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        res = []\\n\\n        while root:\\n            if not root.left: # if we don\\'t have a left, this is our best in-order value at the moment. add it to the list and move right.\\n                res.append(root.val)\\n                root = root.right\\n            else:\\n                pred = self.findPredecessor(root) # find the predecessor for the given node. This is the farthest right of the first left we see.\\n\\n\\t\\t\\t\\t# if we have a right we have move on to explore this sub tree. The pred.right != root check is to ensure that we\\'re not ex\\n                if pred.right != root:\\n                    pred.right = root\\n                    root = root.left\\n                else: \\n\\t\\t\\t\\t# otherwise, we have found a pointer back to the current root and we need to rewrite the tree structure. This is basically a form of \"have we seen this before?\".\\n                    root.left = None\\n\\n        return res\\n\\n    def findPredecessor(self, root: TreeNode) -> TreeNode:\\n        curr = root.left\\n\\n        while curr.right and curr.right != root:\\n            curr = curr.right\\n\\n        return curr\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 31261,
                "title": "c-solution",
                "content": "```\\n    public IList<int> InorderTraversal(TreeNode root) {\\n        List<int> result = new List<int>();\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode currentNode = root;\\n\\n        while (currentNode != null || stack.Count != 0)\\n        {\\n            while (currentNode != null)\\n            {\\n                stack.Push(currentNode);\\n                currentNode = currentNode.left;\\n            }\\n            \\n            if (stack.Count != 0)\\n            {\\n                currentNode = stack.Pop();\\n                result.Add(currentNode.val);\\n                currentNode = currentNode.right;\\n            }\\n        }\\n            \\n        return result;\\n    }",
                "solutionTags": [],
                "code": "```\\n    public IList<int> InorderTraversal(TreeNode root) {\\n        List<int> result = new List<int>();\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode currentNode = root;\\n\\n        while (currentNode != null || stack.Count != 0)\\n        {\\n            while (currentNode != null)\\n            {\\n                stack.Push(currentNode);\\n                currentNode = currentNode.left;\\n            }\\n            \\n            if (stack.Count != 0)\\n            {\\n                currentNode = stack.Pop();\\n                result.Add(currentNode.val);\\n                currentNode = currentNode.right;\\n            }\\n        }\\n            \\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 31422,
                "title": "java-simple-and-clean",
                "content": "No1:\\n\\n     List<Integer> ans = new ArrayList<>();\\n    \\n    public List<Integer> inorderTraversal(TreeNode root) {\\n       if (root == null) return ans;\\n       inorderTraversal(root.left);\\n       ans.add(root.val);\\n       return inorderTraversal(root.right);\\n    }\\n\\n\\nNo2:\\n\\n       public List<Integer> inorderTraversal(TreeNode root) {\\n    \\tStack<TreeNode> stack = new Stack<>();\\n    \\tTreeNode cur = root;\\n    \\twhile (!stack.isEmpty() || cur != null) {\\n    \\t\\twhile (cur != null) {\\n        \\t\\tstack.push(cur);\\n        \\t\\tcur = cur.left;\\n        \\t}\\n    \\t\\tcur = stack.pop();\\n    \\t\\tans.add(cur.val);\\n    \\t\\tcur = cur.right;\\n     \\t}\\n    \\treturn ans;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "No1:\\n\\n     List<Integer> ans = new ArrayList<>();\\n    \\n    public List<Integer> inorderTraversal(TreeNode root) {\\n       if (root == null) return ans;\\n       inorderTraversal(root.left);\\n       ans.add(root.val);\\n       return inorderTraversal(root.right);\\n    }\\n\\n\\nNo2:\\n\\n       public List<Integer> inorderTraversal(TreeNode root) {\\n    \\tStack<TreeNode> stack = new Stack<>();\\n    \\tTreeNode cur = root;\\n    \\twhile (!stack.isEmpty() || cur != null) {\\n    \\t\\twhile (cur != null) {\\n        \\t\\tstack.push(cur);\\n        \\t\\tcur = cur.left;\\n        \\t}\\n    \\t\\tcur = stack.pop();\\n    \\t\\tans.add(cur.val);\\n    \\t\\tcur = cur.right;\\n     \\t}\\n    \\treturn ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 31411,
                "title": "iterative-0ms-c-solution-with-o-1-space",
                "content": "    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n    \\tTreeNode *buf;\\n    \\twhile (root) {\\n    \\t\\tif (root->left) {\\n    \\t\\t\\tbuf = root->left;\\n    \\t\\t\\twhile (buf->right){\\n    \\t\\t\\t\\tbuf = buf->right;\\n    \\t\\t\\t}\\n    \\t\\t\\tbuf->right = root;\\n    \\t\\t\\tbuf = root->left;\\n    \\t\\t\\troot->left = NULL;\\n    \\t\\t\\troot = buf;\\n    \\t\\t}\\n    \\t\\telse {\\n    \\t\\t\\tans.push_back(root->val);\\n    \\t\\t\\troot = root->right;\\n    \\t\\t}\\n    \\t}\\n    \\treturn ans;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n    \\tTreeNode *buf;\\n    \\twhile (root) {\\n    \\t\\tif (root->left) {\\n    \\t\\t\\tbuf = root->left;\\n    \\t\\t\\twhile (buf->right){\\n    \\t\\t\\t\\tbuf = buf->right;\\n    \\t\\t\\t}\\n    \\t\\t\\tbuf->right = root;\\n    \\t\\t\\tbuf = root->left;\\n    \\t\\t\\troot->left = NULL;\\n    \\t\\t\\troot = buf;\\n    \\t\\t}\\n    \\t\\telse {\\n    \\t\\t\\tans.push_back(root->val);\\n    \\t\\t\\troot = root->right;\\n    \\t\\t}\\n    \\t}\\n    \\treturn ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3198212,
                "title": "c-recursive-iterative-all",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple three steps in Inorder Traversal :\\n- Left Traversal\\n- Push The ROOT \\n- Right Traversal\\n<--------**LPR**------->\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Recusrive : Do left recursion then push  then Do right recursion\\n- Iterative : Use a stack (just like recursion stack is internally used ,same is here) .So just start from root and go left upto left !=null and keep pushing them in stack and then  store the topof stack  in answer vector and pop that  and then  for that top go for its right . (L->P->R strategy)\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**Recusrive INorder**\\n```\\nvector<int>ans;\\n    void Inorder(TreeNode * root){\\n        if(!root)return;\\n        Inorder(root->left);\\n        ans.push_back(root->val);\\n        Inorder(root->right);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        Inorder(root);\\n        return ans;\\n    }\\n```\\n**Iterative Inorder**\\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n        if(!root)return {};\\n         stack<TreeNode*>st;\\n         TreeNode* temp=root;\\n         while(!st.empty() or temp){\\n             while(temp){\\n                 st.push(temp);\\n                 temp=temp->left;\\n             }\\n             temp=st.top();\\n             ans.push_back(st.top()->val);\\n             st.pop();\\n             temp=temp->right;\\n         }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nvector<int>ans;\\n    void Inorder(TreeNode * root){\\n        if(!root)return;\\n        Inorder(root->left);\\n        ans.push_back(root->val);\\n        Inorder(root->right);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        Inorder(root);\\n        return ans;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n        if(!root)return {};\\n         stack<TreeNode*>st;\\n         TreeNode* temp=root;\\n         while(!st.empty() or temp){\\n             while(temp){\\n                 st.push(temp);\\n                 temp=temp->left;\\n             }\\n             temp=st.top();\\n             ans.push_back(st.top()->val);\\n             st.pop();\\n             temp=temp->right;\\n         }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547358,
                "title": "java-easy-solution-100-faster-code-minimum-lines-codes",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n    List<Integer> res = new ArrayList<Integer>();\\n    in(root,res);\\n    return res;\\n}\\n\\npublic void in(TreeNode root,List<Integer> res){\\n    if(root==null)\\n        return;\\n    in(root.left,res);\\n    res.add(root.val);\\n    in(root.right,res);\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n    List<Integer> res = new ArrayList<Integer>();\\n    in(root,res);\\n    return res;\\n}\\n\\npublic void in(TreeNode root,List<Integer> res){\\n    if(root==null)\\n        return;\\n    in(root.left,res);\\n    res.add(root.val);\\n    in(root.right,res);\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1414598,
                "title": "rust-solution",
                "content": "```Rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn inorder_traversal(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {\\n        let mut res = vec![];\\n        \\n        fn traversal(node: Option<Rc<RefCell<TreeNode>>>, res: &mut Vec<i32>) {\\n            if let Some(n) = node {\\n                traversal(n.borrow().left.clone(), res);\\n                res.push(n.borrow().val);\\n                traversal(n.borrow().right.clone(), res);\\n            }\\n        }\\n        \\n        traversal(root, &mut res);\\n        \\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```Rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn inorder_traversal(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {\\n        let mut res = vec![];\\n        \\n        fn traversal(node: Option<Rc<RefCell<TreeNode>>>, res: &mut Vec<i32>) {\\n            if let Some(n) = node {\\n                traversal(n.borrow().left.clone(), res);\\n                res.push(n.borrow().val);\\n                traversal(n.borrow().right.clone(), res);\\n            }\\n        }\\n        \\n        traversal(root, &mut res);\\n        \\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1329494,
                "title": "0-ms-swift-binary-tree-inorder-traversal-test-cases",
                "content": "```swift\\nclass Solution {\\n    func inorderTraversal(_ root: TreeNode?) -> [Int] {\\n        var result = [Int](), array = [TreeNode](), head = root\\n        while head != nil || !(array.isEmpty) {\\n            switch head {\\n            case .some(let node):\\n                array.append(node)\\n                head = node.left\\n            default:\\n                let prev = array.removeLast()\\n                result.append(prev.val)\\n                head = prev.right\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\\n\\n```swift\\nimport XCTest\\n\\n// Executed 5 tests, with 0 failures (0 unexpected) in 0.046 (0.048) seconds\\n\\nclass Tests: XCTestCase {\\n    let s = Solution()\\n    func test0() {\\n        let res = s.inorderTraversal(.init([1,nil,2,3]))\\n        XCTAssertEqual(res, [1,3,2])\\n    }\\n    func test1() {\\n        let res = s.inorderTraversal(.init([]))\\n        XCTAssertEqual(res, [])\\n    }\\n    func test2() {\\n        let res = s.inorderTraversal(.init([1]))\\n        XCTAssertEqual(res, [1])\\n    }\\n    func test3() {\\n        let res = s.inorderTraversal(.init([1,2]))\\n        XCTAssertEqual(res, [2,1])\\n    }\\n    func test4() {\\n        let res = s.inorderTraversal(.init([1,nil,2]))\\n        XCTAssertEqual(res, [1,2])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n```swift\\npublic class TreeNode {\\n    public var val: Int\\n    public var left: TreeNode?\\n    public var right: TreeNode?\\n    public init() { self.val = 0; self.left = nil; self.right = nil; }\\n    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n    }\\n    public init?(_ array: [Int?]) {\\n        var values = array\\n        guard !values.isEmpty, let head = values.removeFirst() else { return nil }\\n        val = head; left = nil; right = nil\\n        var queue = [self]\\n        while !queue.isEmpty {\\n            let node = queue.removeFirst()\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.left = TreeNode(val)\\n                queue.append(node.left!)\\n            }\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.right = TreeNode(val)\\n                queue.append(node.right!)\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func inorderTraversal(_ root: TreeNode?) -> [Int] {\\n        var result = [Int](), array = [TreeNode](), head = root\\n        while head != nil || !(array.isEmpty) {\\n            switch head {\\n            case .some(let node):\\n                array.append(node)\\n                head = node.left\\n            default:\\n                let prev = array.removeLast()\\n                result.append(prev.val)\\n                head = prev.right\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 5 tests, with 0 failures (0 unexpected) in 0.046 (0.048) seconds\\n\\nclass Tests: XCTestCase {\\n    let s = Solution()\\n    func test0() {\\n        let res = s.inorderTraversal(.init([1,nil,2,3]))\\n        XCTAssertEqual(res, [1,3,2])\\n    }\\n    func test1() {\\n        let res = s.inorderTraversal(.init([]))\\n        XCTAssertEqual(res, [])\\n    }\\n    func test2() {\\n        let res = s.inorderTraversal(.init([1]))\\n        XCTAssertEqual(res, [1])\\n    }\\n    func test3() {\\n        let res = s.inorderTraversal(.init([1,2]))\\n        XCTAssertEqual(res, [2,1])\\n    }\\n    func test4() {\\n        let res = s.inorderTraversal(.init([1,nil,2]))\\n        XCTAssertEqual(res, [1,2])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\n```swift\\npublic class TreeNode {\\n    public var val: Int\\n    public var left: TreeNode?\\n    public var right: TreeNode?\\n    public init() { self.val = 0; self.left = nil; self.right = nil; }\\n    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n    }\\n    public init?(_ array: [Int?]) {\\n        var values = array\\n        guard !values.isEmpty, let head = values.removeFirst() else { return nil }\\n        val = head; left = nil; right = nil\\n        var queue = [self]\\n        while !queue.isEmpty {\\n            let node = queue.removeFirst()\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.left = TreeNode(val)\\n                queue.append(node.left!)\\n            }\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.right = TreeNode(val)\\n                queue.append(node.right!)\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3197245,
                "title": "python3-31ms-easy-explanation",
                "content": "# Approach\\n- first traverse till last node in left branch of every next node.\\n- now return when None node found\\n- append current element to inorder list\\n- at this point this means we traversed all left possible nodes.\\n- now go to right branch and do the same.\\n- return inord.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        inord = []\\n        def inorder(curr=root):\\n            nonlocal inord\\n            if curr:\\n                inorder(curr.left)\\n                inord.append(curr.val)\\n                inorder(curr.right)\\n            return\\n        inorder()\\n        return inord\\n```\\n# Please like and comment below.\\n# ( \\u0361\\u1D54\\u202F\\u035C\\u0296 \\u0361\\u1D54)\\u270C",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        inord = []\\n        def inorder(curr=root):\\n            nonlocal inord\\n            if curr:\\n                inorder(curr.left)\\n                inord.append(curr.val)\\n                inorder(curr.right)\\n            return\\n        inorder()\\n        return inord\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830795,
                "title": "c-easy-solution-100-fast",
                "content": "```\\nint i=0;\\nint arr[101]={0};\\nvoid inorder(struct TreeNode* s)\\n{\\n    if(s!=NULL)\\n    {\\n        inorder(s->left);\\n        arr[i++]=s->val;\\n        inorder(s->right);\\n    }\\n}\\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    inorder(root);\\n    int* ans=malloc(i*sizeof(int));\\n    for(int j=0;j<i;j++) ans[j]=arr[j];\\n    *(returnSize)=i;\\n    i=0;\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint i=0;\\nint arr[101]={0};\\nvoid inorder(struct TreeNode* s)\\n{\\n    if(s!=NULL)\\n    {\\n        inorder(s->left);\\n        arr[i++]=s->val;\\n        inorder(s->right);\\n    }\\n}\\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    inorder(root);\\n    int* ans=malloc(i*sizeof(int));\\n    for(int j=0;j<i;j++) ans[j]=arr[j];\\n    *(returnSize)=i;\\n    i=0;\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1803478,
                "title": "python-simple-python-solution-using-recursion-faster-than-90-84",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 33 ms, faster than 90.84% of Python3 online submissions for Binary Tree Inorder Traversal.\\n# Memory Usage: 13.8 MB, less than 60.15% of Python3 online submissions for Binary Tree Inorder Traversal.\\n\\n\\tclass Solution:\\n\\t\\tdef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\n\\t\\t\\tself.result = []\\n\\n\\t\\t\\tdef InOrderTraversal(node):\\n\\n\\t\\t\\t\\tif node == None:\\n\\t\\t\\t\\t\\treturn None\\n\\n\\t\\t\\t\\tInOrderTraversal(node.left)\\n\\t\\t\\t\\tself.result.append(node.val)\\n\\t\\t\\t\\tInOrderTraversal(node.right)\\n\\n\\t\\t\\tInOrderTraversal(root)\\n\\n\\t\\t\\treturn self.result\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 33 ms, faster than 90.84% of Python3 online submissions for Binary Tree Inorder Traversal.\\n# Memory Usage: 13.8 MB, less than 60.15% of Python3 online submissions for Binary Tree Inorder Traversal.\\n\\n\\tclass Solution:\\n\\t\\tdef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\n\\t\\t\\tself.result = []\\n\\n\\t\\t\\tdef InOrderTraversal(node):\\n\\n\\t\\t\\t\\tif node == None:\\n\\t\\t\\t\\t\\treturn None\\n\\n\\t\\t\\t\\tInOrderTraversal(node.left)\\n\\t\\t\\t\\tself.result.append(node.val)\\n\\t\\t\\t\\tInOrderTraversal(node.right)\\n\\n\\t\\t\\tInOrderTraversal(root)\\n\\n\\t\\t\\treturn self.result\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 1743165,
                "title": "javascript-typescript-simple-2-line-recursive-solution-time-97-faster-memory-5-less",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode {\\n *     val: number\\n *     left: TreeNode | null\\n *     right: TreeNode | null\\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.left = (left===undefined ? null : left)\\n *         this.right = (right===undefined ? null : right)\\n *     }\\n * }\\n */\\n\\nfunction inorderTraversal(root: TreeNode | null): number[] {\\n    if (root === null) return [];\\n    return [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode {\\n *     val: number\\n *     left: TreeNode | null\\n *     right: TreeNode | null\\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.left = (left===undefined ? null : left)\\n *         this.right = (right===undefined ? null : right)\\n *     }\\n * }\\n */\\n\\nfunction inorderTraversal(root: TreeNode | null): number[] {\\n    if (root === null) return [];\\n    return [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)];\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486984,
                "title": "single-iterative-solution-for-preorder-inorder-and-postorder-traversals-in-one-go",
                "content": "```\\nclass Solution:\\n\\tdef inorderTraversal(self, root):\\n\\n\\t\\tpreo,ino,posto,stack=[],[],[],[[root,1]]\\n\\t\\tif not root:\\n\\t\\t\\treturn\\n\\t\\twhile stack:\\n\\t\\t\\tn=stack.pop()\\n\\n\\t\\t\\t#Preorder Traversal\\n\\t\\t\\tif n[1]==1:\\n\\t\\t\\t\\tpreo.append(n[0].val)\\n\\t\\t\\t\\tn[1]+=1\\n\\t\\t\\t\\tstack.append(n)\\n\\t\\t\\t\\tif n[0].left:\\n\\t\\t\\t\\t\\tstack.append([n[0].left,1])\\n\\n\\t\\t\\t#Inorder Traversal\\n\\t\\t\\telif n[1]==2:\\n\\t\\t\\t\\tino.append(n[0].val)\\n\\t\\t\\t\\tn[1]+=1\\n\\t\\t\\t\\tstack.append(n)\\n\\t\\t\\t\\tif n[0].right:\\n\\t\\t\\t\\t\\tstack.append([n[0].right,1])\\n\\n\\t\\t\\t#Postorder Traversal\\n\\t\\t\\telse:\\n\\t\\t\\t\\tposto.append(n[0].val)\\n\\t\\treturn ino",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\tdef inorderTraversal(self, root):\\n\\n\\t\\tpreo,ino,posto,stack=[],[],[],[[root,1]]\\n\\t\\tif not root:\\n\\t\\t\\treturn\\n\\t\\twhile stack:\\n\\t\\t\\tn=stack.pop()\\n\\n\\t\\t\\t#Preorder Traversal\\n\\t\\t\\tif n[1]==1:\\n\\t\\t\\t\\tpreo.append(n[0].val)\\n\\t\\t\\t\\tn[1]+=1\\n\\t\\t\\t\\tstack.append(n)\\n\\t\\t\\t\\tif n[0].left:\\n\\t\\t\\t\\t\\tstack.append([n[0].left,1])\\n\\n\\t\\t\\t#Inorder Traversal\\n\\t\\t\\telif n[1]==2:\\n\\t\\t\\t\\tino.append(n[0].val)\\n\\t\\t\\t\\tn[1]+=1\\n\\t\\t\\t\\tstack.append(n)\\n\\t\\t\\t\\tif n[0].right:\\n\\t\\t\\t\\t\\tstack.append([n[0].right,1])\\n\\n\\t\\t\\t#Postorder Traversal\\n\\t\\t\\telse:\\n\\t\\t\\t\\tposto.append(n[0].val)\\n\\t\\treturn ino",
                "codeTag": "Java"
            },
            {
                "id": 286620,
                "title": "java-morris-traversal-with-detailed-explanation",
                "content": "```\\nclass Solution {\\n\\t/**\\n\\t * Morris inorder traversal\\n\\t * \\n\\t * @param root\\n\\t * @return\\n\\t * @see <a href=\\n\\t *      \"https://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/\">Inorder\\n\\t *      Tree Traversal without recursion and without stack</a>\\n\\t * @see <a href=\"https://en.wikipedia.org/wiki/Threaded_binary_tree\">Threaded\\n\\t *      binary tree</a>\\n\\t */\\n\\tpublic List<Integer> inorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> r = new ArrayList<>();\\n\\t\\tif (root == null)\\n\\t\\t\\treturn r;\\n\\n\\t\\t// Start from root\\n\\t\\tTreeNode cur = root;\\n\\n\\t\\t// Define a cursor that will be used to find predecessor, link and unlink nodes\\n\\t\\tTreeNode traverseCursor = null;\\n\\t\\twhile (cur != null) {\\n\\t\\t\\t/*\\n\\t\\t\\t * Check current node\\'s left child, if the left child node exist, then traverse\\n\\t\\t\\t * through left child\\'s right branch to the bottom, the rightmost leaf node will\\n\\t\\t\\t * be the predecessor of current node, once we find it, we \\'link\\' the\\n\\t\\t\\t * predecessor to current node, i.e., we make current node the right child of\\n\\t\\t\\t * the predecessor\\n\\t\\t\\t */\\n\\t\\t\\tif (cur.left != null) {\\n\\t\\t\\t\\ttraverseCursor = cur.left;\\n\\t\\t\\t\\twhile (traverseCursor.right != null && traverseCursor.right != cur) {\\n\\t\\t\\t\\t\\ttraverseCursor = traverseCursor.right;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (traverseCursor.right == null) {\\n\\t\\t\\t\\t\\t// We found the leaf node, now create the link\\n\\t\\t\\t\\t\\ttraverseCursor.right = cur;\\n\\t\\t\\t\\t\\t// Now move the cursor of current node to its left child\\n\\t\\t\\t\\t\\tcur = cur.left;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (traverseCursor.right == cur) {\\n\\t\\t\\t\\t\\t// This case is indicating we have already visited current node\\'s predecessor by\\n\\t\\t\\t\\t\\t// linking, we need to unlink the nodes to restore the original tree\\n\\t\\t\\t\\t\\ttraverseCursor.right = null;\\n\\t\\t\\t\\t\\t// This case is also indicating we are visiting the successor of the predecessor\\n\\t\\t\\t\\t\\t// i.e., the root\\n\\t\\t\\t\\t\\tr.add(cur.val);\\n\\t\\t\\t\\t\\t// Now visit the right branch\\n\\t\\t\\t\\t\\tcur = cur.right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// We reached the node we want to visit\\n\\t\\t\\t\\tr.add(cur.val);\\n\\t\\t\\t\\t// Now we move the cursor to its \\'right\\' child, which was linked to its\\n\\t\\t\\t\\t// successor\\n\\t\\t\\t\\t// by traverseCursor\\n\\t\\t\\t\\tcur = cur.right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn r;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t/**\\n\\t * Morris inorder traversal\\n\\t * \\n\\t * @param root\\n\\t * @return\\n\\t * @see <a href=\\n\\t *      \"https://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/\">Inorder\\n\\t *      Tree Traversal without recursion and without stack</a>\\n\\t * @see <a href=\"https://en.wikipedia.org/wiki/Threaded_binary_tree\">Threaded\\n\\t *      binary tree</a>\\n\\t */\\n\\tpublic List<Integer> inorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> r = new ArrayList<>();\\n\\t\\tif (root == null)\\n\\t\\t\\treturn r;\\n\\n\\t\\t// Start from root\\n\\t\\tTreeNode cur = root;\\n\\n\\t\\t// Define a cursor that will be used to find predecessor, link and unlink nodes\\n\\t\\tTreeNode traverseCursor = null;\\n\\t\\twhile (cur != null) {\\n\\t\\t\\t/*\\n\\t\\t\\t * Check current node\\'s left child, if the left child node exist, then traverse\\n\\t\\t\\t * through left child\\'s right branch to the bottom, the rightmost leaf node will\\n\\t\\t\\t * be the predecessor of current node, once we find it, we \\'link\\' the\\n\\t\\t\\t * predecessor to current node, i.e., we make current node the right child of\\n\\t\\t\\t * the predecessor\\n\\t\\t\\t */\\n\\t\\t\\tif (cur.left != null) {\\n\\t\\t\\t\\ttraverseCursor = cur.left;\\n\\t\\t\\t\\twhile (traverseCursor.right != null && traverseCursor.right != cur) {\\n\\t\\t\\t\\t\\ttraverseCursor = traverseCursor.right;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (traverseCursor.right == null) {\\n\\t\\t\\t\\t\\t// We found the leaf node, now create the link\\n\\t\\t\\t\\t\\ttraverseCursor.right = cur;\\n\\t\\t\\t\\t\\t// Now move the cursor of current node to its left child\\n\\t\\t\\t\\t\\tcur = cur.left;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (traverseCursor.right == cur) {\\n\\t\\t\\t\\t\\t// This case is indicating we have already visited current node\\'s predecessor by\\n\\t\\t\\t\\t\\t// linking, we need to unlink the nodes to restore the original tree\\n\\t\\t\\t\\t\\ttraverseCursor.right = null;\\n\\t\\t\\t\\t\\t// This case is also indicating we are visiting the successor of the predecessor\\n\\t\\t\\t\\t\\t// i.e., the root\\n\\t\\t\\t\\t\\tr.add(cur.val);\\n\\t\\t\\t\\t\\t// Now visit the right branch\\n\\t\\t\\t\\t\\tcur = cur.right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// We reached the node we want to visit\\n\\t\\t\\t\\tr.add(cur.val);\\n\\t\\t\\t\\t// Now we move the cursor to its \\'right\\' child, which was linked to its\\n\\t\\t\\t\\t// successor\\n\\t\\t\\t\\t// by traverseCursor\\n\\t\\t\\t\\tcur = cur.right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn r;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2548362,
                "title": "python-recursive-and-iterative-solutions",
                "content": "# Recursive Solution\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        A = []\\n        def inorder(node):\\n            if not node: return\\n            inorder(node.left)\\n            A.append(node.val)\\n            inorder(node.right)\\n        inorder(root)\\n        return A\\n```\\n\\n# Iterative solution\\nSame idea, exhaust left sub trees, then pop the current, add to the answer and repeat the logic for right subtree (in order)\\n\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        A = []\\n        stack = []\\n        cur_node = root\\n        \\n        while stack or cur_node:\\n            \\n            # Exhausted left nodes. Pop current and go right\\n            if not cur_node:\\n                node = stack.pop()\\n                A.append(node.val)\\n                cur_node = node.right\\n            \\n            # Otherwise go left\\n            else:\\n                stack.append(cur_node)\\n                cur_node = cur_node.left\\n        \\n        return A\\n```\\n\\n# Generator function\\nNote that you can turn the iterative solution into a generator function by yielding the result.\\n\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        stack = []\\n        cur_node = root\\n        \\n        while stack or cur_node:\\n            # Exhausted left nodes. Pop current and go right\\n            if not cur_node:\\n                node = stack.pop()\\n                yield node.val\\n                cur_node = node.right\\n            \\n            # Otherwise go left\\n            else:\\n                stack.append(cur_node)\\n                cur_node = cur_node.left\\n```\\n\\n# Appendix\\nOne could solve the problem in constant space O(1) using morris traversal.\\nRefer to this link for more info: https://stackoverflow.com/questions/5502916/explain-morris-inorder-tree-traversal-without-using-stacks-or-recursion",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        A = []\\n        def inorder(node):\\n            if not node: return\\n            inorder(node.left)\\n            A.append(node.val)\\n            inorder(node.right)\\n        inorder(root)\\n        return A\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        A = []\\n        stack = []\\n        cur_node = root\\n        \\n        while stack or cur_node:\\n            \\n            # Exhausted left nodes. Pop current and go right\\n            if not cur_node:\\n                node = stack.pop()\\n                A.append(node.val)\\n                cur_node = node.right\\n            \\n            # Otherwise go left\\n            else:\\n                stack.append(cur_node)\\n                cur_node = cur_node.left\\n        \\n        return A\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        stack = []\\n        cur_node = root\\n        \\n        while stack or cur_node:\\n            # Exhausted left nodes. Pop current and go right\\n            if not cur_node:\\n                node = stack.pop()\\n                yield node.val\\n                cur_node = node.right\\n            \\n            # Otherwise go left\\n            else:\\n                stack.append(cur_node)\\n                cur_node = cur_node.left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547698,
                "title": "2-ways-of-0ms-java-solution",
                "content": "**Recursion**\\n```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        solve(res,root);\\n        return res;\\n    }\\n    \\n    private void solve(List<Integer> res, TreeNode root){\\n        if(root == null) return;\\n        \\n\\t\\t// Traverse left node\\n        solve(res, root.left);\\n\\t\\t\\n\\t\\t// Traverse parent node\\n        res.add(root.val);\\n\\t\\t\\n\\t\\t// Traverse right node\\n        solve(res, root.right);\\n    }\\n}\\n```\\n\\n**Using Stack**\\n```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        \\n        TreeNode curr = root;\\n        Stack<TreeNode> stack = new Stack<>();\\n        while(curr != null || stack.size() != 0){\\n            \\n            // Move to the left-most node of the tree and push them in stack for future traversal\\n            while(curr != null){\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n            \\n            // Left node\\n            curr = stack.pop();\\n            \\n            // Parent node\\n            res.add(curr.val);\\n            \\n            // Right node\\n            curr = curr.right;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n<br/>\\n\\n**Kotlin Version**\\n\\n```\\nclass Solution {\\n    fun inorderTraversal(root: TreeNode?): List<Int> {\\n        val res = mutableListOf<Int>()\\n        inorder(root,res)\\n        return res\\n    }\\n    \\n    private fun inorder(node:TreeNode?, res : MutableList<Int>){\\n        node?.let{\\n            inorder(node.left,res)\\n            res.add(node.`val`)\\n            inorder(node.right,res)\\n        }\\n    }\\n}\\n```\\n\\n**Using Stack**\\n```\\nclass Solution {\\n    fun inorderTraversal(root: TreeNode?): List<Int> {\\n        val res = mutableListOf<Int>()\\n        \\n        var curr = root\\n        val stack = Stack<TreeNode>()\\n        \\n        while(curr != null || stack.size != 0){\\n            while(curr!=null){\\n                stack.push(curr)\\n                curr = curr.left\\n            }\\n            curr = stack.pop()\\n            res.add(curr.`val`)\\n            curr = curr.right\\n        }   \\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Kotlin",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        solve(res,root);\\n        return res;\\n    }\\n    \\n    private void solve(List<Integer> res, TreeNode root){\\n        if(root == null) return;\\n        \\n\\t\\t// Traverse left node\\n        solve(res, root.left);\\n\\t\\t\\n\\t\\t// Traverse parent node\\n        res.add(root.val);\\n\\t\\t\\n\\t\\t// Traverse right node\\n        solve(res, root.right);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        \\n        TreeNode curr = root;\\n        Stack<TreeNode> stack = new Stack<>();\\n        while(curr != null || stack.size() != 0){\\n            \\n            // Move to the left-most node of the tree and push them in stack for future traversal\\n            while(curr != null){\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n            \\n            // Left node\\n            curr = stack.pop();\\n            \\n            // Parent node\\n            res.add(curr.val);\\n            \\n            // Right node\\n            curr = curr.right;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun inorderTraversal(root: TreeNode?): List<Int> {\\n        val res = mutableListOf<Int>()\\n        inorder(root,res)\\n        return res\\n    }\\n    \\n    private fun inorder(node:TreeNode?, res : MutableList<Int>){\\n        node?.let{\\n            inorder(node.left,res)\\n            res.add(node.`val`)\\n            inorder(node.right,res)\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun inorderTraversal(root: TreeNode?): List<Int> {\\n        val res = mutableListOf<Int>()\\n        \\n        var curr = root\\n        val stack = Stack<TreeNode>()\\n        \\n        while(curr != null || stack.size != 0){\\n            while(curr!=null){\\n                stack.push(curr)\\n                curr = curr.left\\n            }\\n            curr = stack.pop()\\n            res.add(curr.`val`)\\n            curr = curr.right\\n        }   \\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1986517,
                "title": "swift-0-ms-2-lines-recursive",
                "content": "```\\nclass Solution {\\n    func inorderTraversal(_ root: TreeNode?) -> [Int] {\\n        guard let root = root else { return [] }\\n        return inorderTraversal(root.left) + [root.val] + inorderTraversal(root.right)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func inorderTraversal(_ root: TreeNode?) -> [Int] {\\n        guard let root = root else { return [] }\\n        return inorderTraversal(root.left) + [root.val] + inorderTraversal(root.right)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1969561,
                "title": "c-3-method-recursive-iterative-using-stack-morris-traversal-threaded-binary-tree",
                "content": "Recall: Inorder= Left, Root Node, Right\\n\\n**1st Approach:** Using recursion\\nWe use a helper function to traverse recursively \\n\\n```\\nclass Solution {\\npublic:\\n        void inorder(TreeNode* root, vector<int>& res){\\n        if (root){\\n            inorder (root->left, res);\\n            res.push_back(root->val);\\n            inorder (root->right, res);\\n        }\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> p;\\n        inorder (root, p);\\n        return p;\\n    }\\n};\\n```\\nTime Complexity: O(N)\\nSpace Complexity: O(N)\\n\\n**2nd Approach:** Iteratively using Stack\\nUnlike recursively which used the internal stack, we would explicitly use a stack to keep a track of nodes\\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector < int > inOrder;\\n        stack < TreeNode* > s;\\n        TreeNode* curr = root;\\n        while (true) {\\n            if (curr != NULL) {\\n                s.push(curr);\\n                curr = curr -> left;\\n            } else\\n            {\\n                if (s.empty()) break;\\n                curr = s.top();\\n                inOrder.push_back(curr -> val);\\n                s.pop();\\n                curr = curr -> right;\\n            }\\n        }\\n        return inOrder;\\n    }\\n};\\n```\\nTime Complexity: O(N)\\nSpace Complexity: O(N)\\n\\n**3rd Approach:** Using morris traversal i.e, applying the concept of threaded binary tree.\\n\\nExplanation: Here we are wisely creating a thread between the current node and its inorder predecessor so that we can visit back the current node, as there are no parent pointer in the binary tree strucure nor recursion stack which did this task in previous approaches.\\n\\n![image](https://assets.leetcode.com/users/images/0f962cd3-ceb9-43ef-91ec-b79acbe9394d_1650542250.3279028.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        TreeNode *cur = root;\\n        vector<int> inorder;\\n        while (cur != NULL)\\n        {\\n            if (cur->left == NULL)//no left node then directly push in inorder and go right\\n            {\\n                inorder.push_back(cur->val);\\n                cur = cur->right;\\n            }\\n            else//there is a left node\\n            {\\n                //find inorder predecessor\\n                TreeNode* predecessor = cur->left;//predecessor will be the rightmost of left until it reaches null or back to the current node (as we might have already created thread from it.\\n                while (predecessor->right != cur && predecessor->right != NULL)\\n                    predecessor = predecessor->right;\\n                if (predecessor->right == NULL)//thread creation as visiting first time\\n                {\\n                    predecessor->right = cur;\\n                    cur = cur-> left;\\n                }\\n                else//thread deletion to avoid cycle and pushing node in inorder\\n                {\\n                    predecessor->right = NULL;\\n                    inorder.push_back(cur->val);\\n                    cur = cur->right;\\n                }\\n            }\\n        }\\n        return inorder;\\n    }\\n};\\n```\\nTime Complexity: O(N)\\nSpace Complexity: **O(1)**\\n\\n",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        void inorder(TreeNode* root, vector<int>& res){\\n        if (root){\\n            inorder (root->left, res);\\n            res.push_back(root->val);\\n            inorder (root->right, res);\\n        }\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> p;\\n        inorder (root, p);\\n        return p;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector < int > inOrder;\\n        stack < TreeNode* > s;\\n        TreeNode* curr = root;\\n        while (true) {\\n            if (curr != NULL) {\\n                s.push(curr);\\n                curr = curr -> left;\\n            } else\\n            {\\n                if (s.empty()) break;\\n                curr = s.top();\\n                inOrder.push_back(curr -> val);\\n                s.pop();\\n                curr = curr -> right;\\n            }\\n        }\\n        return inOrder;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        TreeNode *cur = root;\\n        vector<int> inorder;\\n        while (cur != NULL)\\n        {\\n            if (cur->left == NULL)//no left node then directly push in inorder and go right\\n            {\\n                inorder.push_back(cur->val);\\n                cur = cur->right;\\n            }\\n            else//there is a left node\\n            {\\n                //find inorder predecessor\\n                TreeNode* predecessor = cur->left;//predecessor will be the rightmost of left until it reaches null or back to the current node (as we might have already created thread from it.\\n                while (predecessor->right != cur && predecessor->right != NULL)\\n                    predecessor = predecessor->right;\\n                if (predecessor->right == NULL)//thread creation as visiting first time\\n                {\\n                    predecessor->right = cur;\\n                    cur = cur-> left;\\n                }\\n                else//thread deletion to avoid cycle and pushing node in inorder\\n                {\\n                    predecessor->right = NULL;\\n                    inorder.push_back(cur->val);\\n                    cur = cur->right;\\n                }\\n            }\\n        }\\n        return inorder;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548841,
                "title": "c-solution",
                "content": "****Runtime: 0 ms, faster than 100.00% of C online submissions for Binary Tree Inorder Traversal.\\nMemory Usage: 5.9 MB, less than 68.48% of C online submissions for Binary Tree Inorder Traversal.\\n```\\nvoid travel(struct TreeNode* root,int*ret,int*size){\\n    if(root==NULL)\\n        return 0 ;\\n    travel(root->left,ret,size);\\n    ret[(*size)++]=root->val;\\n    travel(root->right,ret,size);\\n}\\n\\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    *returnSize=0;\\n    int *ret=malloc(sizeof(int)*100);\\n    travel(root,ret,returnSize);\\n        return ret;\\n\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvoid travel(struct TreeNode* root,int*ret,int*size){\\n    if(root==NULL)\\n        return 0 ;\\n    travel(root->left,ret,size);\\n    ret[(*size)++]=root->val;\\n    travel(root->right,ret,size);\\n}\\n\\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    *returnSize=0;\\n    int *ret=malloc(sizeof(int)*100);\\n    travel(root,ret,returnSize);\\n        return ret;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1359114,
                "title": "recursive-python-3-lines-of-code",
                "content": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not(root):\\n            return []\\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not(root):\\n            return []\\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1259828,
                "title": "2-line-javascript-solution-faster-than-81",
                "content": "```\\nvar inorderTraversal = function(root) {\\n    if (!root) return []\\n    return [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)]\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar inorderTraversal = function(root) {\\n    if (!root) return []\\n    return [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 960715,
                "title": "python-iterative",
                "content": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        traversal = []\\n\\n        node = root\\n        stack = []\\n        while node or stack:\\n            if node:\\n                stack.append(node)\\n                node = node.left\\n            else:\\n                node = stack.pop()\\n                traversal.append(node.val)\\n                node = node.right\\n                \\n        return traversal\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        traversal = []\\n\\n        node = root\\n        stack = []\\n        while node or stack:\\n            if node:\\n                stack.append(node)\\n                node = node.left\\n            else:\\n                node = stack.pop()\\n                traversal.append(node.val)\\n                node = node.right\\n                \\n        return traversal\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31380,
                "title": "recommend-by-rainbow-morris-traversal-and-time-complexity-analysis-why-o-n",
                "content": "**Update : 2016/02/26**\\n\\nabout why the time complexity of the Morris traversal is O(n) maybe confusing !\\n\\nHere is the details you need to understand the time complexity is O(N) as each edge is traversed for 3 times at most.\\n\\n       Each edge is traversed at most 3 times and there are n-1 edges in a tree,\\n       hence the O(n).\\n\\nI think the part that is confusing you is the predecessor finding loop because it goes down the tree following the rightmost node.\\n\\n            /* Find the inorder predecessor of current */\\n          pre = current->left;\\n          while (pre->right != NULL && pre->right != current)\\n          pre = pre->right;\\n\\n\\nThis full path is only processed twice: \\nwhen the current pointer reaches the node\\nwhen we have processed its left subtree\\n\\nAlso, the key is that this path is not processed again while we're on the left subtree.\\n\\nYou can see a simple example here .\\n\\n[https://www.quora.com/Why-does-the-Morris-in-order-traversal-algorithm-have-O-n-time-complexity][1]\\n\\nMorris traversal is a cheap way to do the traversal of the tree with no Space cost and non-recursive way.\\n\\nBut at first, it may seem hard for you to understand.\\n\\nThe key idea is to traversal as in-order, when meet the node with left child, then we will\\n\\ntraverse to find the pre-node of the current node and link it to the current node. \\n\\nSo after push back the in-order first node,  it will back track by the previous setting \"right link\"!\\n\\nSo when we meet the \"right link\"  for the next time, we will reset it and push back the value.\\n\\nSo we link the tree value and get the final vector result.\\n\\n         1. Initialize current as root \\n         2. While current is not NULL\\n                   If current does not have left child\\n                         a) Print current\\u2019s data\\n                         b) Go to the right, i.e., current = current->right\\n                   Else\\n                         a) Make current as right child of the rightmost node in current's left subtree\\n                         b) Go to this left child, i.e., current = current->left\\n\\nAC C++  implementation .\\n\\n\\n    class Solution {\\n    public:\\n        vector<int> inorderTraversal(TreeNode* root) {\\n            TreeNode* cur, *pre;\\n            vector<int> result;\\n            if(!root)  return  result;\\n            \\n            cur=root;\\n            while(cur){\\n                /** move left **/\\n                if(cur->left){\\n                    /** find the previous node of the cur **/\\n                   pre=cur->left;\\n                   while(pre->right && pre->right!=cur)  pre=pre->right;\\n                   /** if not set, keep traversal **/\\n                   if(!pre->right){\\n                       pre->right=cur;\\n                       cur=cur->left;\\n                   }\\n                   /** if set, push back the value, and keep traversal **/\\n                   else{\\n                       pre->right=NULL;\\n                       result.push_back(cur->val);\\n                       cur=cur->right;\\n                   }\\n                }\\n                /** push_back the root value move right (previous set right link will point \\n                    to the in-order-next node)**/\\n                else{\\n                    result.push_back(cur->val);\\n                    cur=cur->right;\\n                }\\n            }\\n        }\\n    };\\n\\n\\n  [1]: https://www.quora.com/Why-does-the-Morris-in-order-traversal-algorithm-have-O-n-time-complexity",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> inorderTraversal(TreeNode* root) {\\n            TreeNode* cur, *pre;\\n            vector<int> result;\\n            if(!root)  return  result;\\n            \\n            cur=root;\\n            while(cur){\\n                /** move left **/\\n                if(cur->left){\\n                    /** find the previous node of the cur **/\\n                   pre=cur->left;\\n                   while(pre->right && pre->right!=cur)  pre=pre->right;\\n                   /** if not set, keep traversal **/\\n                   if(!pre->right){\\n                       pre->right=cur;\\n                       cur=cur->left;\\n                   }",
                "codeTag": "Java"
            },
            {
                "id": 3931235,
                "title": "easy-c-solution-dfs-bfs-and-morris-traversal-beats-100",
                "content": "# Code\\n```\\n// Recursive approach\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<int> &ans){\\n        //base case\\n        if(root == NULL)\\n            return;\\n\\n        inorder(root->left, ans);\\n        ans.push_back(root->val);\\n        inorder(root->right, ans);\\n    }\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        inorder(root, ans);\\n        return ans;\\n    }\\n};\\n\\n// Iterative approach\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        stack<TreeNode*> s;\\n        TreeNode *curr = root;\\n\\n        while(true){\\n            if(curr != NULL){\\n                s.push(curr);\\n                curr = curr->left;\\n            }\\n            else if(s.empty())\\n                break;\\n            else{\\n                ans.push_back(s.top()->val);\\n                curr = s.top()->right;\\n                s.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Morris traversal - Space O(1)\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(root == NULL)\\n            return {};\\n        \\n        vector<int> ans;\\n        TreeNode *curr = root, *pre;\\n        while(curr != NULL){\\n            if(curr->left == NULL){\\n                ans.push_back(curr->val);\\n                curr = curr->right;\\n            }\\n            else{\\n                pre = curr->left;\\n                while(pre->right != NULL && pre->right != curr)\\n                    pre = pre->right;\\n                \\n                if(pre->right == NULL){\\n                    pre->right = curr;\\n                    curr = curr->left;\\n                }\\n                else{   // pre->right == curr\\n                    pre->right = NULL;\\n                    ans.push_back(curr->val);\\n                    curr = curr->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n// Recursive approach\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<int> &ans){\\n        //base case\\n        if(root == NULL)\\n            return;\\n\\n        inorder(root->left, ans);\\n        ans.push_back(root->val);\\n        inorder(root->right, ans);\\n    }\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        inorder(root, ans);\\n        return ans;\\n    }\\n};\\n\\n// Iterative approach\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        stack<TreeNode*> s;\\n        TreeNode *curr = root;\\n\\n        while(true){\\n            if(curr != NULL){\\n                s.push(curr);\\n                curr = curr->left;\\n            }\\n            else if(s.empty())\\n                break;\\n            else{\\n                ans.push_back(s.top()->val);\\n                curr = s.top()->right;\\n                s.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Morris traversal - Space O(1)\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(root == NULL)\\n            return {};\\n        \\n        vector<int> ans;\\n        TreeNode *curr = root, *pre;\\n        while(curr != NULL){\\n            if(curr->left == NULL){\\n                ans.push_back(curr->val);\\n                curr = curr->right;\\n            }\\n            else{\\n                pre = curr->left;\\n                while(pre->right != NULL && pre->right != curr)\\n                    pre = pre->right;\\n                \\n                if(pre->right == NULL){\\n                    pre->right = curr;\\n                    curr = curr->left;\\n                }\\n                else{   // pre->right == curr\\n                    pre->right = NULL;\\n                    ans.push_back(curr->val);\\n                    curr = curr->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3431301,
                "title": "in-order-traversing-in-python-python3",
                "content": "# Approach\\nAs Inorder traversing a Binary tree, first we have to travse the left tree nodes than root node and than at the last right tree nodes.\\nUsing recursive model for this solution.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) if root else []\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Binary Search",
                    "Binary Search Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) if root else []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053456,
                "title": "c-short-simple-recursion",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    \\n    void inorder(TreeNode* root){\\n        if(root==nullptr){return;}\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n    }\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        inorder(root);\\n        return v;    \\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    \\n    void inorder(TreeNode* root){\\n        if(root==nullptr){return;}\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n    }\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        inorder(root);\\n        return v;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827145,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* cur_node = head;\\n        while (cur_node && cur_node->next) {\\n            ListNode* next_node = cur_node->next;\\n            if (cur_node->val == next_node->val)\\n                cur_node->next = next_node->next;\\n            else\\n                cur_node = next_node;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* cur_node = head;\\n        while (cur_node && cur_node->next) {\\n            ListNode* next_node = cur_node->next;\\n            if (cur_node->val == next_node->val)\\n                cur_node->next = next_node->next;\\n            else\\n                cur_node = next_node;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2035548,
                "title": "java-script-solution-using-recursion",
                "content": "```\\nvar inorderTraversal = function(root) {\\n    if(root === null) return [];\\n    return [...inorderTraversal(root.left),root.val,...inorderTraversal(root.right)];\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar inorderTraversal = function(root) {\\n    if(root === null) return [];\\n    return [...inorderTraversal(root.left),root.val,...inorderTraversal(root.right)];\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1778180,
                "title": "python-recursive-one-liner",
                "content": "```\\nclass Solution:\\n  def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n    return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) if root else []\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n  def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n    return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) if root else []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437870,
                "title": "js-heavily-commented-recursive-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar inorderTraversal = function(root) {\\n    // In-Order Traversal ->\\n    //  1. Recursively traverse through the left subtree\\n    //  2. Visit current node\\n    //  3. Recursively traverse through the right subtree\\n    \\n    // Initialize array of values\\n    let result = [];\\n    \\n    // Recursive function to traverse through subtrees\\n    inorder(root, result);\\n    \\n    return result;\\n};\\n\\nconst inorder = (node, result) => {\\n    if (!node) return null;\\n    inorder(node.left, result); // Traverse through left subtree\\n    result.push(node.val); // Visit node\\n    inorder(node.right, result); // Traverse through right subtree\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar inorderTraversal = function(root) {\\n    // In-Order Traversal ->\\n    //  1. Recursively traverse through the left subtree\\n    //  2. Visit current node\\n    //  3. Recursively traverse through the right subtree\\n    \\n    // Initialize array of values\\n    let result = [];\\n    \\n    // Recursive function to traverse through subtrees\\n    inorder(root, result);\\n    \\n    return result;\\n};\\n\\nconst inorder = (node, result) => {\\n    if (!node) return null;\\n    inorder(node.left, result); // Traverse through left subtree\\n    result.push(node.val); // Visit node\\n    inorder(node.right, result); // Traverse through right subtree\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 706892,
                "title": "python-morris-traversal",
                "content": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        curr = root\\n        res = []\\n        while curr:\\n            if curr.left:\\n                pre = curr.left\\n                while pre.right and pre.right!=curr:\\n                    pre = pre.right\\n                if pre.right == curr:\\n                    pre.right = None\\n                    res.append(curr.val)\\n                    curr = curr.right\\n                else:\\n                    pre.right = curr\\n                    curr = curr.left\\n            else:\\n                res.append(curr.val)\\n                curr = curr.right\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        curr = root\\n        res = []\\n        while curr:\\n            if curr.left:\\n                pre = curr.left\\n                while pre.right and pre.right!=curr:\\n                    pre = pre.right\\n                if pre.right == curr:\\n                    pre.right = None\\n                    res.append(curr.val)\\n                    curr = curr.right\\n                else:\\n                    pre.right = curr\\n                    curr = curr.left\\n            else:\\n                res.append(curr.val)\\n                curr = curr.right\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 546002,
                "title": "easy-to-understand-iterative-and-recursive-faster-simple-python-solution",
                "content": "```\\ndef iterative(self, root):\\n        out = []\\n        stack = []\\n        top = root\\n        while top or len(stack):\\n            while top:\\n                stack.append(top)\\n                top = top.left\\n            top = stack.pop()\\n            out.append(top.val)\\n            top = top.right\\n        return out\\n    \\n    def recursive(self, root):\\n        def rec(root):\\n            if root:\\n                rec(root.left)\\n                out.append(root.val)\\n                rec(root.right)\\n        \\n        out = []\\n        rec(root)\\n        return out\\n```\\n\\n**I hope that you\\'ve found them useful.**\\n\\t*In that case, please do upvote. It motivates me to write more such post\\uD83D\\uDE03*",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\ndef iterative(self, root):\\n        out = []\\n        stack = []\\n        top = root\\n        while top or len(stack):\\n            while top:\\n                stack.append(top)\\n                top = top.left\\n            top = stack.pop()\\n            out.append(top.val)\\n            top = top.right\\n        return out\\n    \\n    def recursive(self, root):\\n        def rec(root):\\n            if root:\\n                rec(root.left)\\n                out.append(root.val)\\n                rec(root.right)\\n        \\n        out = []\\n        rec(root)\\n        return out\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 31386,
                "title": "c-0ms-stack-based-solution",
                "content": "    class Solution {\\n    public:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> res;\\n        vector<TreeNode*> stack;\\n        TreeNode *cur=root;\\n        while (cur!=NULL || !stack.empty()){\\n            if (cur){\\n                stack.push_back(cur);\\n                cur = cur->left;\\n            }\\n            else {\\n                cur = stack.back();\\n                stack.pop_back();\\n                res.push_back(cur->val);\\n                cur = cur->right;\\n            }\\n        }\\n        return res;\\n    } \\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> res;\\n        vector<TreeNode*> stack;\\n        TreeNode *cur=root;\\n        while (cur!=NULL || !stack.empty()){\\n            if (cur){\\n                stack.push_back(cur);\\n                cur = cur->left;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 31402,
                "title": "java-1ms-both-iterative-and-recursive",
                "content": "The recursive solution is trivial, yet the iterative solution with an explicit stack helps us better understand what is going on with the stack in the recursive solution.\\n\\n    public class Solution {\\n        public List<Integer> inorderTraversal(TreeNode root) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            inorderTraversalRecursive(root, result);\\n            //inorderTraversalIterative(root, result);\\n            return result;\\n        }\\n        \\n        private void inorderTraversalIterative(TreeNode root, List<Integer> result) {\\n            LinkedList<TreeNode> stack = new LinkedList<TreeNode>();\\n            TreeNode curr = root;\\n            while (curr != null || !stack.isEmpty()) {\\n                if (curr != null) {\\n                    stack.offerLast(curr);\\n                    curr = curr.left;\\n                } else {\\n                    result.add(stack.getLast().val);\\n                    curr = stack.getLast().right;\\n                    stack.pollLast();\\n                }\\n            }\\n        }\\n        \\n        private void inorderTraversalRecursive(TreeNode root, List<Integer> result) {\\n            if (root == null) {\\n                return;\\n            }\\n            inorderTraversalRecursive(root.left, result);\\n            result.add(root.val);\\n            inorderTraversalRecursive(root.right, result);        \\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> inorderTraversal(TreeNode root) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            inorderTraversalRecursive(root, result);\\n            //inorderTraversalIterative(root, result);\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 31478,
                "title": "my-accepted-solution-in-python",
                "content": "    class Solution:\\n        def inorderTraversal(self, root):\\n            stack = []\\n            output = []\\n            while True:\\n                while root:\\n                    stack.append(root)\\n                    root = root.left\\n                if stack == []:\\n                    break\\n                node = stack.pop()\\n                output.append(node.val)\\n                root = node.right\\n            return output",
                "solutionTags": [],
                "code": "    class Solution:\\n        def inorderTraversal(self, root):\\n            stack = []\\n            output = []\\n            while True:\\n                while root:\\n                    stack.append(root)\\n                    root = root.left\\n                if stack == []:\\n                    break\\n                node = stack.pop()\\n                output.append(node.val)\\n                root = node.right\\n            return output",
                "codeTag": "Java"
            },
            {
                "id": 3202461,
                "title": "c-recursive-easy-solution-beats-100",
                "content": "# Intuition\\nRecursive Solution\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<int> &vct){\\n        if(root == NULL){\\n            return;\\n        }\\n\\n        inorder(root->left,vct);\\n        vct.push_back(root->val);\\n        inorder(root->right,vct);\\n    }\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> vct;\\n        inorder(root,vct);\\n        return vct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<int> &vct){\\n        if(root == NULL){\\n            return;\\n        }\\n\\n        inorder(root->left,vct);\\n        vct.push_back(root->val);\\n        inorder(root->right,vct);\\n    }\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> vct;\\n        inorder(root,vct);\\n        return vct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3187656,
                "title": "91-35-binary-tree-inorder-traversal-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe idea is to traverse the binary tree in an inorder fashion using a stack. We start with the root node and keep going to the left child until we reach a leaf node. Then, we backtrack and process the node by popping it from the stack, appending its value to the result, and moving to its right child. We repeat this process until the stack is empty and we have processed all the nodes in the tree.\\n\\n# Complexity\\n- Time complexity:\\nBeats\\n91.35%\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        # Initialize an empty stack to store the nodes\\n        stack = []\\n        # Initialize an empty list to store the result\\n        result = []\\n        # Start with the root node\\n        curr = root\\n        # Loop until the stack is empty or curr is None\\n        while stack or curr:\\n            # If curr is not None, push it onto the stack and move to its left child\\n            if curr:\\n                stack.append(curr)\\n                curr = curr.left\\n            # If curr is None, pop a node from the stack, append its value to the result, and move to its right child\\n            else:\\n                curr = stack.pop()\\n                result.append(curr.val)\\n                curr = curr.right\\n        # Return the result\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        # Initialize an empty stack to store the nodes\\n        stack = []\\n        # Initialize an empty list to store the result\\n        result = []\\n        # Start with the root node\\n        curr = root\\n        # Loop until the stack is empty or curr is None\\n        while stack or curr:\\n            # If curr is not None, push it onto the stack and move to its left child\\n            if curr:\\n                stack.append(curr)\\n                curr = curr.left\\n            # If curr is None, pop a node from the stack, append its value to the result, and move to its right child\\n            else:\\n                curr = stack.pop()\\n                result.append(curr.val)\\n                curr = curr.right\\n        # Return the result\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185647,
                "title": "c-easy-solution-using-recursion-explained",
                "content": "# Intuition\\nIn-Order Traversal is a Depth First Search Algorithm of traversal in Binary Trees. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# DFS Traversal Algorithms \\n- [In-Order Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/post-solution/3185647/) \\n- [Post-Order Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/solutions/3185653/c-easy-solution-using-recursion-explained/)\\n- [Pre-Order Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3185665/c-easy-solution-using-recursion-explained/)\\n\\n# Approach\\nIn-Order Traversal -> L N R\\n1. Traverse the left subtree\\n2. Print/Store the node \\n3. Traverse the right subtree\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n// InOrder Traversal -> L N R \\n// Traverse the left subtree till NULL (Base Case), print/store the node, traverse the right subtree(till NULL - Base Case)\\n    void inOrder (TreeNode *node, vector<int> &result)\\n    {\\n        if (node == NULL)\\n        {\\n            return ;\\n        }\\n\\n        inOrder (node -> left, result) ; \\n        result.push_back(node -> val) ; \\n        inOrder (node -> right, result) ;\\n\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> result ; \\n\\n        inOrder (root, result) ; \\n        return result ; \\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/a558e75a-a201-4602-887b-3d5314b6875f_1676391339.7404554.png)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n// InOrder Traversal -> L N R \\n// Traverse the left subtree till NULL (Base Case), print/store the node, traverse the right subtree(till NULL - Base Case)\\n    void inOrder (TreeNode *node, vector<int> &result)\\n    {\\n        if (node == NULL)\\n        {\\n            return ;\\n        }\\n\\n        inOrder (node -> left, result) ; \\n        result.push_back(node -> val) ; \\n        inOrder (node -> right, result) ;\\n\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> result ; \\n\\n        inOrder (root, result) ; \\n        return result ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163094,
                "title": "simple-java-100-easy-comments-readable-beginners-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode curr = root;\\n        while (curr != null || !stack.isEmpty()) {\\n            while (curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n            curr = stack.pop();\\n            res.add(curr.val);\\n            curr = curr.right;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode curr = root;\\n        while (curr != null || !stack.isEmpty()) {\\n            while (curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n            curr = stack.pop();\\n            res.add(curr.val);\\n            curr = curr.right;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976367,
                "title": "best-c-code-out-there-memory-100-optimized",
                "content": "class Solution {\\n     private : vector<int>res;\\n    void inorder(TreeNode *root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n            return;\\n        \\n        inorder(root->left,res);\\n        res.push_back(root->val);\\n        inorder(root->right,res);\\n        return;\\n    }\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        inorder(root,res);\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n     private : vector<int>res;\\n    void inorder(TreeNode *root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n            return;\\n        \\n        inorder(root->left,res);\\n        res.push_back(root->val);\\n        inorder(root->right,res);\\n        return;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1724132,
                "title": "python-3-25ms-perfect-pythonic-recursive-one-liner-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return []\\n        return  self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return []\\n        return  self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588635,
                "title": "javascript-one-liner",
                "content": "```javascript\\nvar inorderTraversal = function(root) {\\n    return !root ? [] : [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```javascript\\nvar inorderTraversal = function(root) {\\n    return !root ? [] : [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1348586,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) if root else []\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) if root else []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1300339,
                "title": "c-recursive-solution-in-o-n-time",
                "content": "#Trees - **Binary Tree Inorder Traversal**\\n\\n\\uD83D\\uDC49 Recursive solution: `O(n)` time and `O(n)` space (function call stack);\\n\\nHere, We just traverse in such a way that after making left call we push the value at that point in the the vector and then make the right call. \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void traverse(TreeNode* root, vector<int> &ans)\\n    {\\n        if(!root)\\n            return;\\n        \\n        if(root->left) \\n            traverse(root->left, ans);\\n        \\n        ans.push_back(root->val);  \\n        \\n        if(root->right)\\n            traverse(root->right, ans);\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) \\n    {\\n        vector<int> ans;\\n        \\n            traverse(root, ans);\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n\\u2728 Alternate Approach : Try solving Iteratively using stack: `O(n)` time and `O(n)` space",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void traverse(TreeNode* root, vector<int> &ans)\\n    {\\n        if(!root)\\n            return;\\n        \\n        if(root->left) \\n            traverse(root->left, ans);\\n        \\n        ans.push_back(root->val);  \\n        \\n        if(root->right)\\n            traverse(root->right, ans);\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) \\n    {\\n        vector<int> ans;\\n        \\n            traverse(root, ans);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1048556,
                "title": "java-3-solutions-with-explanation-recursive-iterative-using-stack-iterative-without-stack",
                "content": "The idea is simple for in-order traversal -\\n1. traverse the left sub-tree\\n2. visit the node\\n3. traverse the right sub-tree\\n\\nThis process is done recursively for each node in the tree.\\n\\n#### Recursive\\n\\n```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> inOrderList = new ArrayList<>();\\n        inOrder(root, inOrderList);\\n        return inOrderList;\\n    }\\n    \\n    private void inOrder(TreeNode node, List<Integer> list){\\n        if(node != null){\\n            inOrder(node.left, list);\\n            list.add(node.val);\\n            inOrder(node.right, list);\\n        }\\n    }\\n}\\n```\\n\\nThe same idea of recursion can be implemented using stack as well.\\n\\n#### Iterative using Stack\\n\\n```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> listInOrder = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode curr = root;\\n        \\n        while(curr != null || !stack.isEmpty()){\\n            if(curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            } else{\\n                curr = stack.pop();\\n                listInOrder.add(curr.val);\\n                curr = curr.right;                    \\n            }\\n        }\\n        return listInOrder;\\n    }\\n}\\n```\\n\\n#### Iterative (Without Stack) - Morris Traversal in Threaded BST\\n\\nThis idea is slightly different than the other two but is relatively simple. Instead of using a stack (or recursion) for revisiting the current node again to traverse the right subtree, we update the right pointer of the in-order predecessor to point to the current node even before we start doing the in-order traversal on a node. Later we get rid of this pointer when all nodes of the left sub-tree is completely visited to leave the tree back in its original state.\\n\\n```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        \\n        TreeNode curr = root;\\n        \\n        while(curr != null){\\n            if(curr.left == null){\\n                list.add(curr.val);\\n                curr = curr.right;\\n            } else {\\n                TreeNode predecessor = curr.left;\\n                while(predecessor.right != null && predecessor.right != curr)\\n                    predecessor = predecessor.right;\\n                if(predecessor.right == null){\\n                    predecessor.right = curr;\\n                    curr = curr.left;\\n                } else {\\n                    predecessor.right = null;\\n                    list.add(curr.val);\\n                    curr = curr.right;\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> inOrderList = new ArrayList<>();\\n        inOrder(root, inOrderList);\\n        return inOrderList;\\n    }\\n    \\n    private void inOrder(TreeNode node, List<Integer> list){\\n        if(node != null){\\n            inOrder(node.left, list);\\n            list.add(node.val);\\n            inOrder(node.right, list);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> listInOrder = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode curr = root;\\n        \\n        while(curr != null || !stack.isEmpty()){\\n            if(curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            } else{\\n                curr = stack.pop();\\n                listInOrder.add(curr.val);\\n                curr = curr.right;                    \\n            }\\n        }\\n        return listInOrder;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        \\n        TreeNode curr = root;\\n        \\n        while(curr != null){\\n            if(curr.left == null){\\n                list.add(curr.val);\\n                curr = curr.right;\\n            } else {\\n                TreeNode predecessor = curr.left;\\n                while(predecessor.right != null && predecessor.right != curr)\\n                    predecessor = predecessor.right;\\n                if(predecessor.right == null){\\n                    predecessor.right = curr;\\n                    curr = curr.left;\\n                } else {\\n                    predecessor.right = null;\\n                    list.add(curr.val);\\n                    curr = curr.right;\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 847780,
                "title": "c-recursive",
                "content": "```\\nint cnt(struct TreeNode* root)\\n{\\n    if(root)\\n        return 1 + cnt(root->left) + cnt(root->right);\\n    return 0;\\n}\\n\\nvoid inorder(struct TreeNode* root, int** res)\\n{\\n    if(root)\\n    {\\n        inorder(root->left, res);\\n        *((*res)++) = root->val;\\n        inorder(root->right, res);\\n    }\\n}\\n\\n\\nint* inorderTraversal(struct TreeNode* root, int* returnSize)\\n{\\n    \\n    *returnSize = cnt(root);\\n    int* res = (int*)malloc(((*returnSize)) * sizeof(int));\\n    memset(res, 0, (*returnSize) * sizeof(int));   \\n    int *cpy = res;\\n    inorder(root, &cpy);\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint cnt(struct TreeNode* root)\\n{\\n    if(root)\\n        return 1 + cnt(root->left) + cnt(root->right);\\n    return 0;\\n}\\n\\nvoid inorder(struct TreeNode* root, int** res)\\n{\\n    if(root)\\n    {\\n        inorder(root->left, res);\\n        *((*res)++) = root->val;\\n        inorder(root->right, res);\\n    }\\n}\\n\\n\\nint* inorderTraversal(struct TreeNode* root, int* returnSize)\\n{\\n    \\n    *returnSize = cnt(root);\\n    int* res = (int*)malloc(((*returnSize)) * sizeof(int));\\n    memset(res, 0, (*returnSize) * sizeof(int));   \\n    int *cpy = res;\\n    inorder(root, &cpy);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 632114,
                "title": "c-easy-iterative-and-recurive-solution-with-explanation",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    // Recursive Method\\n    \\n    vector <int> ans;\\n    void inorder(TreeNode *root)\\n    {\\n        if(root == NULL)\\n            return;\\n        \\n        inorder(root->left);\\n        ans.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root)\\n    {\\n        inorder(root);\\n        return ans;\\n    }\\n    \\n    \\n    // Iterative method\\n    \\n    vector<int> inorderTraversal(TreeNode* root)\\n    {\\n        TreeNode *ptr = root;\\n        vector <int> ans;\\n        stack <TreeNode*> address;\\n        \\n        if(root == NULL)\\n            return ans;\\n        \\n        // until address stack is empty and ptr points to NULL i.e. Traversal is over\\n        while( !address.empty() || ptr != NULL )\\n        {\\n            // if ptr points to a child\\n            if(ptr != NULL)\\n            {\\n                // pushing the address to the stack\\n                address.push(ptr);\\n                // moving left\\n                ptr = ptr->left;                    // LEFT\\n            }\\n            else\\n            {\\n                // popping the address and making ptr point to it, kinda backtrack a step\\n                ptr = address.top();\\n                address.pop();\\n                // printing or pushing the value of node to array\\n                ans.push_back(ptr->val);            // PRINT\\n                // movinf left\\n                ptr= ptr->right;                    // RIGHT\\n            }\\n        }  \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    // Recursive Method\\n    \\n    vector <int> ans;\\n    void inorder(TreeNode *root)\\n    {\\n        if(root == NULL)\\n            return;\\n        \\n        inorder(root->left);\\n        ans.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root)\\n    {\\n        inorder(root);\\n        return ans;\\n    }\\n    \\n    \\n    // Iterative method\\n    \\n    vector<int> inorderTraversal(TreeNode* root)\\n    {\\n        TreeNode *ptr = root;\\n        vector <int> ans;\\n        stack <TreeNode*> address;\\n        \\n        if(root == NULL)\\n            return ans;\\n        \\n        // until address stack is empty and ptr points to NULL i.e. Traversal is over\\n        while( !address.empty() || ptr != NULL )\\n        {\\n            // if ptr points to a child\\n            if(ptr != NULL)\\n            {\\n                // pushing the address to the stack\\n                address.push(ptr);\\n                // moving left\\n                ptr = ptr->left;                    // LEFT\\n            }\\n            else\\n            {\\n                // popping the address and making ptr point to it, kinda backtrack a step\\n                ptr = address.top();\\n                address.pop();\\n                // printing or pushing the value of node to array\\n                ans.push_back(ptr->val);            // PRINT\\n                // movinf left\\n                ptr= ptr->right;                    // RIGHT\\n            }\\n        }  \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 467789,
                "title": "one-code-pattern-for-3-leetcode-questions-c",
                "content": "**The In-Order code pattern below can be used to solve three different Leetcode problems. The othe**r **questions also require In-Order Traversal**\\n\\n**IN-ORDER TRAVERSAL - USING STACKS**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root)\\n    {\\n        vector<int> ans;\\n        if(root==NULL) return ans;\\n        stack<TreeNode*> s;\\n        while(root!=NULL || !s.empty())\\n        {\\n            while(root!=NULL)\\n            {\\n                s.push(root);\\n                root=root->left;\\n            }\\n            root=s.top();\\n            s.pop();\\n            ans.push_back(root->val);\\n            root=root->right;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n*TIME = O(N) \\nSPACE = O(N)*\\n\\n**VALIDATE A BINARY TREE**\\n\\n```class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root)\\n    {\\n        if(root==NULL) return true;\\n        stack<TreeNode*> s;\\n        TreeNode *prev=NULL;\\n        while(root!=NULL || !s.empty())\\n        {\\n            while(root!=NULL)\\n            {\\n                s.push(root);\\n                root=root->left;\\n            }\\n            root=s.top();  s.pop();\\n            if(prev!=NULL && root->val <= prev->val) \\n                return false;\\n            prev=root;\\n            root=root->right;\\n        }\\n        return true;\\n    }\\n};\\n```\\n*TIME = O(N)\\nWhen bad element is in the rightmost leaf*\\n*SPACE = O(N)*\\n\\n**FIND THE K-th SMALLEST ELEMENT IN A BT**\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int k) \\n    {\\n        stack<TreeNode*> s;\\n        while(root!=NULL || !s.empty())\\n        {\\n            while(root!=NULL)\\n            {\\n                s.push(root);\\n                root=root->left;\\n            }\\n            root=s.top(); s.pop();\\n            if(--k ==0) \\n                break;\\n            root=root->right;\\n        }        \\n        return root->val;\\n    }\\n};\\n```\\n\\n*TIME = O(H+k)*\\n*where H is a tree height. This complexity is defined by the stack, which contains at least H + k elements, since* *before starting to pop out one has to go down to a leaf. This results in O(logN+k) for the balanced tree and O(N+k) for completely unbalanced tree with all the nodes in the left subtree.*\\n\\n*SPACE = O(H+k)\\nworst case (space) = O(N+k)\\nAverage case (space)= O(logn +k)*\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root)\\n    {\\n        vector<int> ans;\\n        if(root==NULL) return ans;\\n        stack<TreeNode*> s;\\n        while(root!=NULL || !s.empty())\\n        {\\n            while(root!=NULL)\\n            {\\n                s.push(root);\\n                root=root->left;\\n            }\\n            root=s.top();\\n            s.pop();\\n            ans.push_back(root->val);\\n            root=root->right;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root)\\n    {\\n        if(root==NULL) return true;\\n        stack<TreeNode*> s;\\n        TreeNode *prev=NULL;\\n        while(root!=NULL || !s.empty())\\n        {\\n            while(root!=NULL)\\n            {\\n                s.push(root);\\n                root=root->left;\\n            }\\n            root=s.top();  s.pop();\\n            if(prev!=NULL && root->val <= prev->val) \\n                return false;\\n            prev=root;\\n            root=root->right;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int k) \\n    {\\n        stack<TreeNode*> s;\\n        while(root!=NULL || !s.empty())\\n        {\\n            while(root!=NULL)\\n            {\\n                s.push(root);\\n                root=root->left;\\n            }\\n            root=s.top(); s.pop();\\n            if(--k ==0) \\n                break;\\n            root=root->right;\\n        }        \\n        return root->val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234471,
                "title": "python3-100-using-iteration-readable",
                "content": "```\\nclass Solution:\\n    def inorderTraversal(self, root: \\'TreeNode\\') -> \\'List[int]\\':\\n        if not root:\\n            return []\\n        stack = list()\\n        output = list()\\n        while stack or root:\\n            if root:\\n                stack.append(root)\\n                root = root.left\\n            else:\\n                node = stack.pop()\\n                output.append(node.val)\\n                root = node.right\\n        return output\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: \\'TreeNode\\') -> \\'List[int]\\':\\n        if not root:\\n            return []\\n        stack = list()\\n        output = list()\\n        while stack or root:\\n            if root:\\n                stack.append(root)\\n                root = root.left\\n            else:\\n                node = stack.pop()\\n                output.append(node.val)\\n                root = node.right\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31332,
                "title": "why-every-solution-is-using-2-while-loops-the-standard-iterative-solution-shoule-only-has-one-while-loop",
                "content": "```\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<Integer> ();\\n        if (root == null) return res;\\n        \\n        Stack<TreeNode> s = new Stack<TreeNode>();\\n        TreeNode n = root;\\n        \\n        while (n != null || !s.isEmpty()) {\\n            if  (n != null) {\\n                s.push(n);\\n                n = n.left;\\n            }\\n            else {\\n                TreeNode l = s.pop();\\n                res.add(l.val);\\n                n = l.right;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<Integer> ();\\n        if (root == null) return res;\\n        \\n        Stack<TreeNode> s = new Stack<TreeNode>();\\n        TreeNode n = root;\\n        \\n        while (n != null || !s.isEmpty()) {\\n            if  (n != null) {\\n                s.push(n);\\n                n = n.left;\\n            }\\n            else {\\n                TreeNode l = s.pop();\\n                res.add(l.val);\\n                n = l.right;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31344,
                "title": "javascript-solution",
                "content": "`````\\nvar inorderTraversal = function(root) {\\n    var stack = [],\\n        res = [];\\n    \\n    while(true){\\n        if(root !== null){\\n            stack.push(root);\\n            root = root.left;\\n        }else{\\n            if(stack.length === 0) break;\\n            root = stack.pop();\\n            res.push(root.val);\\n            root = root.right;\\n        }\\n    }\\n    \\n    return res;\\n};",
                "solutionTags": [],
                "code": "`````\\nvar inorderTraversal = function(root) {\\n    var stack = [],\\n        res = [];\\n    \\n    while(true){\\n        if(root !== null){\\n            stack.push(root);\\n            root = root.left;\\n        }else{\\n            if(stack.length === 0) break;\\n            root = stack.pop();\\n            res.push(root.val);\\n            root = root.right;\\n        }\\n    }\\n    \\n    return res;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3626483,
                "title": "1-line-solution-python",
                "content": "# Approach\\n1. The function begins with a base case check: `[] if not root`. If the `root` node is `None` (i.e., there is no tree), an empty list `[]` is returned.\\n\\n2. If the `root` node is not `None`, the function recursively calls itself to perform an inorder traversal on the left subtree: `self.inorderTraversal(root.left)`. This step visits all the nodes in the left subtree in the inorder sequence.\\n\\n3. After the recursive call for the left subtree, the value of the `root` node is appended to the result list using `[root.val]`.\\n\\n4. Finally, the function recursively calls itself to perform an inorder traversal on the right subtree: `self.inorderTraversal(root.right)`. This step visits all the nodes in the right subtree in the inorder sequence.\\n\\n5. The function returns the concatenation of the left subtree traversal, the `root` value, and the right subtree traversal: `self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)`.\\n\\nThis approach utilizes the recursive nature of the inorder traversal. It recursively traverses the left subtree, visits the current node, and then recursively traverses the right subtree. The base case handles the empty tree, and the concatenation of the traversal results builds the final inorder traversal list.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        return [] if not root else self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)                       \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        return [] if not root else self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)                       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436598,
                "title": "simple-c-solution",
                "content": "# Inorder -> Left Node Right\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n```\\n# Iterative\\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> res;\\n        stack<TreeNode *> st;\\n        while(true){\\n            if(root!=NULL){\\n                st.push(root);\\n                root=root->left;\\n            }\\n            else{\\n                if(st.empty()){\\n                    break;\\n                }\\n                root=st.top();\\n                res.push_back(root->val);\\n                st.pop();\\n                root=root->right;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n# Recursive\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<int> &res, TreeNode *root){\\n        if(root==NULL){\\n            return ;\\n        }\\n        helper(res,root->left);\\n        res.push_back(root->val);\\n        helper(res,root->right);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> res;\\n        helper(res,root);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> res;\\n        stack<TreeNode *> st;\\n        while(true){\\n            if(root!=NULL){\\n                st.push(root);\\n                root=root->left;\\n            }\\n            else{\\n                if(st.empty()){\\n                    break;\\n                }\\n                root=st.top();\\n                res.push_back(root->val);\\n                st.pop();\\n                root=root->right;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void helper(vector<int> &res, TreeNode *root){\\n        if(root==NULL){\\n            return ;\\n        }\\n        helper(res,root->left);\\n        res.push_back(root->val);\\n        helper(res,root->right);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> res;\\n        helper(res,root);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300936,
                "title": "easiest-solution-out-there-in-5-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nPlsssss Up vote -> \\uD83D\\uDE2D\\n# Code\\n```\\n\\nclass Solution {\\n    List<Integer> list = new ArrayList<>();\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        if (root!=null) {\\n            inorderTraversal(root.left);\\n            list.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    List<Integer> list = new ArrayList<>();\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        if (root!=null) {\\n            inorderTraversal(root.left);\\n            list.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268031,
                "title": "beats-100-use-of-recursion-in-java",
                "content": "\\n\\n# Approach\\nThis is a Java program that solves the problem of traversing a binary tree in an inorder manner. The input to the program is a binary tree, represented using the TreeNode class. The TreeNode class has three fields: val, left, and right. The val field stores the value of the node, while the left and right fields store references to the left and right subtrees, respectively. The program returns a list of integers representing the inorder traversal of the binary tree.\\n\\nThe solution implements the inorder traversal recursively using the helper function func. The function takes two arguments: the current node being traversed (root) and the list to which the values are to be added (ans). The traversal is done as follows:\\n\\n1. If the current node is null, return.\\n2. Recursively traverse the left subtree.\\n3. Add the value of the current node to the list.\\n4. Recursively traverse the right subtree.\\n\\n\\n\\nThe main function, inorderTraversal, initializes an empty list ans and calls the helper function func with the root node and the list. Finally, the function returns the list containing the inorder traversal of the binary tree.\\n\\nOverall, the program is an implementation of the classic inorder traversal algorithm for binary trees\\n# Complexity\\n- Time complexity: \\nO(N), where N is the number of nodes in the binary tree. This is because the function visits each node exactly once.\\n\\n\\n- Space complexity:\\nO(N), where N is the number of nodes in the binary tree. This is because the maximum depth of the recursion is equal to the height of the binary tree, and in the worst case, the binary tree can be a degenerate tree, which means that it has N nodes and a height of N. In this case, the recursion would use O(N) space.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        func(root,ans);\\n        return ans;\\n    }\\n    public void func(TreeNode root,List<Integer> ans){\\n        if(root==null){\\n            return;\\n        }\\n        func(root.left,ans);\\n        ans.add(root.val);\\n        func(root.right,ans);\\n    }\\n}\\n```\\n![upvote.jpeg](https://assets.leetcode.com/users/images/2c79ad82-a411-4e0d-9b03-481e726b3c16_1678181469.338393.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        func(root,ans);\\n        return ans;\\n    }\\n    public void func(TreeNode root,List<Integer> ans){\\n        if(root==null){\\n            return;\\n        }\\n        func(root.left,ans);\\n        ans.add(root.val);\\n        func(root.right,ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168608,
                "title": "best-o-n-solution",
                "content": "# Approach 1\\nRecurive Solution\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector <int> nodes;\\n        inorder(root, nodes);\\n        return nodes;\\n    }\\nprivate:\\n    void inorder(TreeNode* root, vector <int>& nodes) {\\n        if (root == NULL) \\n            return;\\n        inorder(root->left, nodes);\\n        nodes.push_back(root->val);\\n        inorder(root->right, nodes);    \\n    }    \\n};\\n```\\n\\n# Approach 2\\nIterative Solution\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector <int> inorder;\\n        if (root == NULL)\\n            return inorder;\\n        stack <TreeNode* > st;\\n        TreeNode* curr = root;\\n        while (true) {\\n            if (curr != NULL) {\\n                st.push(curr);\\n                curr = curr->left;\\n            } else {\\n                if (st.empty() == true)\\n                    break;\\n                curr = st.top();\\n                st.pop();\\n                inorder.push_back(curr->val);\\n                curr = curr->right;    \\n            }\\n        }    \\n        return inorder;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector <int> nodes;\\n        inorder(root, nodes);\\n        return nodes;\\n    }\\nprivate:\\n    void inorder(TreeNode* root, vector <int>& nodes) {\\n        if (root == NULL) \\n            return;\\n        inorder(root->left, nodes);\\n        nodes.push_back(root->val);\\n        inorder(root->right, nodes);    \\n    }    \\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector <int> inorder;\\n        if (root == NULL)\\n            return inorder;\\n        stack <TreeNode* > st;\\n        TreeNode* curr = root;\\n        while (true) {\\n            if (curr != NULL) {\\n                st.push(curr);\\n                curr = curr->left;\\n            } else {\\n                if (st.empty() == true)\\n                    break;\\n                curr = st.top();\\n                st.pop();\\n                inorder.push_back(curr->val);\\n                curr = curr->right;    \\n            }\\n        }    \\n        return inorder;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070108,
                "title": "morris-inorder-traversal",
                "content": "My Python approach for Morris Inorder Traversal.\\nBased on [this](https://www.youtube.com/watch?v=80Zug6D1_r4) video.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans = []\\n        cur = root\\n        while cur != None:\\n            #printing the leftmost node\\n            if not cur.left:\\n                ans.append(cur.val)\\n                cur = cur.right\\n            else:\\n                temp = cur\\n                temp = temp.left\\n                #going to the rightmost node in the left subtree (lets call it temp)\\n                while temp.right and temp.right != cur:\\n                    temp = temp.right\\n                \\n                #2 conditions arise:\\n                \\n                #i. the right child of temp doesn\\'t exist (The thread to the cur node has not been made)\\n                #in this case, point the right child of temp to cur and move cur to its left child\\n                if not temp.right:\\n                    temp.right = cur\\n                    cur = cur.left\\n\\n                #ii. the thread has already been created so we break the thread\\n                #(pointing the temp\\'s right child back to None)and print cur.\\n                #Finally, move cur to its right child      \\n                else:\\n                    ans.append(cur.val)\\n                    temp.right = None\\n                    cur = cur.right\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans = []\\n        cur = root\\n        while cur != None:\\n            #printing the leftmost node\\n            if not cur.left:\\n                ans.append(cur.val)\\n                cur = cur.right\\n            else:\\n                temp = cur\\n                temp = temp.left\\n                #going to the rightmost node in the left subtree (lets call it temp)\\n                while temp.right and temp.right != cur:\\n                    temp = temp.right\\n                \\n                #2 conditions arise:\\n                \\n                #i. the right child of temp doesn\\'t exist (The thread to the cur node has not been made)\\n                #in this case, point the right child of temp to cur and move cur to its left child\\n                if not temp.right:\\n                    temp.right = cur\\n                    cur = cur.left\\n\\n                #ii. the thread has already been created so we break the thread\\n                #(pointing the temp\\'s right child back to None)and print cur.\\n                #Finally, move cur to its right child      \\n                else:\\n                    ans.append(cur.val)\\n                    temp.right = None\\n                    cur = cur.right\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2550488,
                "title": "96-05-senior-developer-javascript-js-2022",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar inorderTraversal = function(root) {\\n    let res = [];\\n    \\n    const fn = (node) => {\\n        if (!node) return;\\n        fn(node.left);  \\n        res.push(node.val)\\n        fn(node.right);\\n    }\\n    \\n    fn(root);\\n    \\n    return res;\\n    \\n};\\n\\n\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar inorderTraversal = function(root) {\\n    let res = [];\\n    \\n    const fn = (node) => {\\n        if (!node) return;\\n        fn(node.left);  \\n        res.push(node.val)\\n        fn(node.right);\\n    }\\n    \\n    fn(root);\\n    \\n    return res;\\n    \\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2549705,
                "title": "simplest-approach-c-9ms-iterative-inorder-traversal",
                "content": "Just move to the left most node and then go on pushing the node values. \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void dfs(TreeNode* node){\\n        if(!node)\\n            return;\\n        dfs(node->left);\\n        ans.push_back(node->val);\\n        dfs(node->right);        \\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        dfs(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void dfs(TreeNode* node){\\n        if(!node)\\n            return;\\n        dfs(node->left);\\n        ans.push_back(node->val);\\n        dfs(node->right);        \\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        dfs(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2546965,
                "title": "daily-leetcoding-challenge-september-day-8",
                "content": "This problem is the Daily LeetCoding Challenge for September, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-inorder-traversal/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterating method using Stack\n\n  \n**Approach 3:** Morris Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-inorder-traversal/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2286560,
                "title": "3-approach-in-c-recursive-iterative-morris-traversal",
                "content": "**Recursive Approach:**\\n````\\n void inordert(TreeNode* root, vector<int>& ans)\\n    {\\n        if(root == NULL) return;\\n        inordert(root->left, ans);\\n        ans.push_back(root->val);\\n        inordert(root->right, ans);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        inordert(root, ans);\\n        return ans;\\n    }\\n````\\n\\n-------------------------------------------------------------------------------------------------------\\n**Iterative Approach:**\\n````\\nvector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        TreeNode* node = root;\\n        stack<TreeNode*> st;\\n        while(true)\\n        {\\n            if(node != NULL)\\n            {\\n                st.push(node);\\n                node = node->left;\\n            }\\n            else\\n            {\\n                if(st.empty() == true) break;\\n                else\\n                {\\n                    node = st.top();\\n                    st.pop();\\n                    ans.push_back(node->val);\\n                    node = node->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n````\\n\\n-------------------------------------------------------------------------------------------------------\\n**Morris Traversal:**\\n````\\nvector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        TreeNode *node = root;\\n        while(node != NULL)\\n        {\\n            if(node->left == NULL) \\n            {\\n                ans.push_back(node->val);\\n                node = node->right;\\n            }\\n            else\\n            {\\n                TreeNode *prev = node->left;\\n                while(prev->right && prev->right != node)\\n                {\\n                    prev = prev->right;\\n                }\\n                if(prev->right == NULL)\\n                {\\n                    prev->right = node;\\n                    node = node->left;\\n                }\\n                else\\n                {\\n                    prev->right = NULL;\\n                    ans.push_back(node->val);\\n                    node = node->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n````\\n\\n**One Request: Please do upvote if you found these approaches helpful, as it motivates me to post such useful content to help our leetcode community. Thanks in Advance!**",
                "solutionTags": [],
                "code": "````\\n void inordert(TreeNode* root, vector<int>& ans)\\n    {\\n        if(root == NULL) return;\\n        inordert(root->left, ans);\\n        ans.push_back(root->val);\\n        inordert(root->right, ans);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        inordert(root, ans);\\n        return ans;\\n    }\\n```\n````\\nvector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        TreeNode* node = root;\\n        stack<TreeNode*> st;\\n        while(true)\\n        {\\n            if(node != NULL)\\n            {\\n                st.push(node);\\n                node = node->left;\\n            }\\n            else\\n            {\\n                if(st.empty() == true) break;\\n                else\\n                {\\n                    node = st.top();\\n                    st.pop();\\n                    ans.push_back(node->val);\\n                    node = node->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\n````\\nvector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        TreeNode *node = root;\\n        while(node != NULL)\\n        {\\n            if(node->left == NULL) \\n            {\\n                ans.push_back(node->val);\\n                node = node->right;\\n            }\\n            else\\n            {\\n                TreeNode *prev = node->left;\\n                while(prev->right && prev->right != node)\\n                {\\n                    prev = prev->right;\\n                }\\n                if(prev->right == NULL)\\n                {\\n                    prev->right = node;\\n                    node = node->left;\\n                }\\n                else\\n                {\\n                    prev->right = NULL;\\n                    ans.push_back(node->val);\\n                    node = node->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2248076,
                "title": "java-easy-standard-solution-0ms",
                "content": "```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n      \\n       ArrayList<Integer> ans = new ArrayList<Integer>();\\n      if(root == null) return ans; // base condition\\n      \\n      Stack<TreeNode> st = new Stack<>();\\n      \\n      TreeNode cur = root;\\n        while(cur != null || !st.isEmpty()) {\\n          while(cur != null) {\\n            st.add(cur);\\n            cur = cur.left;\\n          }\\n          cur = st.pop();\\n          ans.add(cur.val);\\n          cur = cur.right;\\n        }\\n      return ans;\\n    }\\n}\\n```\\n# KINDLY UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n      \\n       ArrayList<Integer> ans = new ArrayList<Integer>();\\n      if(root == null) return ans; // base condition\\n      \\n      Stack<TreeNode> st = new Stack<>();\\n      \\n      TreeNode cur = root;\\n        while(cur != null || !st.isEmpty()) {\\n          while(cur != null) {\\n            st.add(cur);\\n            cur = cur.left;\\n          }\\n          cur = st.pop();\\n          ans.add(cur.val);\\n          cur = cur.right;\\n        }\\n      return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2161133,
                "title": "python-simple-and-easy-solution-using-recursion",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        #Approach - Using Recursion\\n        in_list=[]\\n        if not root:\\n            return\\n        if root.left:\\n            in_list+=self.inorderTraversal(root.left)\\n        in_list.append(root.val)\\n        if root.right:\\n            in_list+=self.inorderTraversal(root.right)\\n        return in_list\\n        \\n```\\n**Please Upvote if it was Helpful. :)**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        #Approach - Using Recursion\\n        in_list=[]\\n        if not root:\\n            return\\n        if root.left:\\n            in_list+=self.inorderTraversal(root.left)\\n        in_list.append(root.val)\\n        if root.right:\\n            in_list+=self.inorderTraversal(root.right)\\n        return in_list\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1663643,
                "title": "c-iterative-and-recursive",
                "content": "Both recursive and iterative solutions use stack.\\nFor iterative solution it uses a user defined stack.\\n\\nIterative Solution\\n\\n1) Intitialize a stack.\\n2) While loop with OR conditions if stack is empty or node is null\\n3) First we traverse through all the left child. Push all the left child nodes in the stack to refer again.\\n4) If node is null, Pop the last element, print the value and visit its right child.\\n\\n```\\n\\t\\tstack <TreeNode*> S;\\n        vector <int> res;\\n        TreeNode* temp = root;\\n        \\n        while((!S.empty())||(temp != NULL)){\\n            if(temp != NULL){\\n                S.push(temp);\\n                temp = temp->left;                \\n            }\\n            else{\\n                temp = S.top();\\n                S.pop();\\n                res.push_back(temp->val);\\n                temp = temp->right;\\n            }\\n        }\\n        return res;        \\n```\\n\\n\\nIterative Solution\\n1) Visit and store All left child\\n2) Print the value\\n3) Visit all Right child\\n```\\n\\tvoid inorder(TreeNode* root,vector <int> &res){\\n        if(root){\\n        inorder(root->left,res);\\n        res.push_back(root->val);\\n        inorder(root->right,res);\\n        }\\n        //return res\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector <int> res;\\n        inorder(root,res);\\n        return res;\\n    }\\n```\\n\\nHope it helps!\\nPlease up vote.\\nFor more detailed explanation please refer https://www.techiedelight.com/inorder-tree-traversal-iterative-recursive/",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree"
                ],
                "code": "```\\n\\t\\tstack <TreeNode*> S;\\n        vector <int> res;\\n        TreeNode* temp = root;\\n        \\n        while((!S.empty())||(temp != NULL)){\\n            if(temp != NULL){\\n                S.push(temp);\\n                temp = temp->left;                \\n            }\\n            else{\\n                temp = S.top();\\n                S.pop();\\n                res.push_back(temp->val);\\n                temp = temp->right;\\n            }\\n        }\\n        return res;        \\n```\n```\\n\\tvoid inorder(TreeNode* root,vector <int> &res){\\n        if(root){\\n        inorder(root->left,res);\\n        res.push_back(root->val);\\n        inorder(root->right,res);\\n        }\\n        //return res\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector <int> res;\\n        inorder(root,res);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1570071,
                "title": "recursion-time-complexity-space-complexity-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector <int> nodeVec;\\n        doTraversal(nodeVec,root);\\n        return nodeVec;\\n    }\\n\\t\\n    void doTraversal(vector<int> &nodeVec, TreeNode* temp)\\n    {\\n        if(temp==nullptr)\\n            return;\\n        doTraversal(nodeVec,temp->left);\\n        nodeVec.push_back(temp->val);\\n        doTraversal(nodeVec,temp->right);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector <int> nodeVec;\\n        doTraversal(nodeVec,root);\\n        return nodeVec;\\n    }\\n\\t\\n    void doTraversal(vector<int> &nodeVec, TreeNode* temp)\\n    {\\n        if(temp==nullptr)\\n            return;\\n        doTraversal(nodeVec,temp->left);\\n        nodeVec.push_back(temp->val);\\n        doTraversal(nodeVec,temp->right);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540039,
                "title": "c-inorder-preorder-postorder-all-3-solution-0ms-faster-than-100",
                "content": "You can observe there is just a minimal diffrence in all 3 ,i.e, it\\'s just the way of filling vector while calling fill function.  \\n***Inorder Traversal :*** \\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void fill(TreeNode* root){\\n        if(!root)\\n            return;\\n        fill(root->left);\\n        ans.push_back(root->val);  // Inorder\\n        fill(root->right);\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        fill(root);\\n        return ans;\\n    }\\n};\\n```\\n\\n***Preorder Traversal :***\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void fill(TreeNode* root){\\n        if(!root)\\n            return;\\n        ans.push_back(root->val);  // Preoder\\n        fill(root->left);\\n        fill(root->right);\\n    }\\n    \\n    vector<int> preorderTraversal(TreeNode* root) {\\n        fill(root);\\n        return ans;\\n    }\\n};\\n```\\n\\n***Postorder Traversal :***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void fill(TreeNode* root){\\n        if(!root)\\n            return;\\n        fill(root->left);\\n        fill(root->right);\\n        ans.push_back(root->val);  /// Postorder\\n    }\\n    \\n    vector<int> postorderTraversal(TreeNode* root) {\\n        fill(root);\\n        return ans;\\n    }\\n};\\n```\\nHope you liked it , kindly upvote !!\\n\\nHappy Coding \\uD83E\\uDD17",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void fill(TreeNode* root){\\n        if(!root)\\n            return;\\n        fill(root->left);\\n        ans.push_back(root->val);  // Inorder\\n        fill(root->right);\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        fill(root);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void fill(TreeNode* root){\\n        if(!root)\\n            return;\\n        ans.push_back(root->val);  // Preoder\\n        fill(root->left);\\n        fill(root->right);\\n    }\\n    \\n    vector<int> preorderTraversal(TreeNode* root) {\\n        fill(root);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void fill(TreeNode* root){\\n        if(!root)\\n            return;\\n        fill(root->left);\\n        fill(root->right);\\n        ans.push_back(root->val);  /// Postorder\\n    }\\n    \\n    vector<int> postorderTraversal(TreeNode* root) {\\n        fill(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 907247,
                "title": "simple-javascript-solution-recursive",
                "content": "Simple Javascript solution using spread operator:\\n\\n```javascript \\nvar inorderTraversal = function(root) {\\n    if (!root) {\\n      return [];\\n    }\\n    let left = inorderTraversal(root.left);\\n    let mid = root.val;\\n    let right = inorderTraversal(root.right);\\n    return [...left, mid, ...right];\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```javascript \\nvar inorderTraversal = function(root) {\\n    if (!root) {\\n      return [];\\n    }\\n    let left = inorderTraversal(root.left);\\n    let mid = root.val;\\n    let right = inorderTraversal(root.right);\\n    return [...left, mid, ...right];\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 600732,
                "title": "javascript-iterative-solution-stack-93-56",
                "content": "Very simpe iterative solution which uses stack.\\n\\nRuntime: 48 ms, faster than 93.31% of JavaScript online submissions for Binary Tree Inorder Traversal.\\nMemory Usage: 33.8 MB, less than 56.25% of JavaScript online submissions for Binary Tree Inorder Traversal.\\n\\n```\\nfunction inorderTraversal(root) {\\n  const stack = [], ret = [];\\n  root && stack.push(root);\\n  while (stack.length) {\\n    const item = stack.pop();\\n    if (item.left) {\\n      stack.push(item);\\n      stack.push(item.left);\\n      item.left = null;\\n    }\\n    else {\\n      ret.push(item.val);\\n      item.right && stack.push(item.right);\\n    }\\n  }\\n  return ret;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\nfunction inorderTraversal(root) {\\n  const stack = [], ret = [];\\n  root && stack.push(root);\\n  while (stack.length) {\\n    const item = stack.pop();\\n    if (item.left) {\\n      stack.push(item);\\n      stack.push(item.left);\\n      item.left = null;\\n    }\\n    else {\\n      ret.push(item.val);\\n      item.right && stack.push(item.right);\\n    }\\n  }\\n  return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 516768,
                "title": "c-iterative-lnr-using-stack",
                "content": "```\\npublic class Solution {\\n    public IList<int> InorderTraversal(TreeNode root) {\\n        List<int> result = new List<int>();\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        while (stack.Count != 0 || root != null) {\\n            if (root != null) {\\n                stack.Push(root);\\n                root = root.left;\\n            } else {\\n                root = stack.Pop();\\n                result.Add(root.val);\\n                root = root.right;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<int> InorderTraversal(TreeNode root) {\\n        List<int> result = new List<int>();\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        while (stack.Count != 0 || root != null) {\\n            if (root != null) {\\n                stack.Push(root);\\n                root = root.left;\\n            } else {\\n                root = stack.Pop();\\n                result.Add(root.val);\\n                root = root.right;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 458464,
                "title": "python-simple-iterative-and-recursive-solutions-98-faster-100-less-memory",
                "content": "```\\n\\n#recursive\\nclass Solution:\\n    def __init__(self):\\n        self.return_list = []\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        \\n        if root:\\n            self.inorderTraversal(root.left)\\n            \\n            self.return_list.append(root.val)\\n            \\n            self.inorderTraversal(root.right)\\n            \\n        return self.return_list\\n```\\n```\\n#ITERATIVE\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:        \\n        return_list = []\\n        stack = []\\n        node = root\\n        \\n        while True:\\n            \\n            if node is not None:\\n                stack.append(node)\\n                node = node.left\\n                \\n            elif(stack):\\n                node = stack.pop()\\n                return_list.append(node.val)\\n                node = node.right\\n            else:\\n                break\\n        return return_list",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\n#recursive\\nclass Solution:\\n    def __init__(self):\\n        self.return_list = []\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        \\n        if root:\\n            self.inorderTraversal(root.left)\\n            \\n            self.return_list.append(root.val)\\n            \\n            self.inorderTraversal(root.right)\\n            \\n        return self.return_list\\n```",
                "codeTag": "Java"
            },
            {
                "id": 455535,
                "title": "javascript-1-line-solution",
                "content": "```js\\nconst inorderTraversal = root => root ? [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)] : [];",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst inorderTraversal = root => root ? [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)] : [];",
                "codeTag": "Unknown"
            },
            {
                "id": 180116,
                "title": "javascript",
                "content": "```\\nvar inorderTraversal = function(root) {\\n    let result = [];\\n    dfs(root);\\n    \\n    function dfs(root) {\\n        if(root != null) {\\n            dfs(root.left);\\n            result.push(root.val);\\n            dfs(root.right);\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar inorderTraversal = function(root) {\\n    let result = [];\\n    dfs(root);\\n    \\n    function dfs(root) {\\n        if(root != null) {\\n            dfs(root.left);\\n            result.push(root.val);\\n            dfs(root.right);\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 166659,
                "title": "javascript-100-iterative-and-recursive",
                "content": "Recursive:\\n\\n```js\\nconst inorderTraversal = root => {\\n  if (!root) return [];\\n  \\n  return [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)]\\n};\\n```\\n\\nIterative (using a stack):\\n```js\\nconst inorderTraversal = root => {\\n  const traversed = [];\\n  \\n  if (!root) {\\n    return traversed;\\n  }\\n  \\n  const nodes = [root];\\n  let currentNode = root.left;\\n  \\n  while (currentNode || nodes.length) {\\n    while (currentNode) {\\n      nodes.push(currentNode);\\n      currentNode = currentNode.left;\\n    }\\n    \\n    currentNode = nodes.pop();\\n    traversed.push(currentNode.val);\\n    currentNode = currentNode.right;\\n  }\\n  \\n  return traversed;\\n}\\n```\\n\\nBoth have 52ms runtime.",
                "solutionTags": [],
                "code": "```js\\nconst inorderTraversal = root => {\\n  if (!root) return [];\\n  \\n  return [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)]\\n};\\n```\n```js\\nconst inorderTraversal = root => {\\n  const traversed = [];\\n  \\n  if (!root) {\\n    return traversed;\\n  }\\n  \\n  const nodes = [root];\\n  let currentNode = root.left;\\n  \\n  while (currentNode || nodes.length) {\\n    while (currentNode) {\\n      nodes.push(currentNode);\\n      currentNode = currentNode.left;\\n    }\\n    \\n    currentNode = nodes.pop();\\n    traversed.push(currentNode.val);\\n    currentNode = currentNode.right;\\n  }\\n  \\n  return traversed;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 152061,
                "title": "recursive-and-iterative-approaches-using-ruby",
                "content": "### Recursive approach\\n```ruby\\ndef inorder_traversal_recursive(root)\\n  response = []\\n  traverse(root, response)\\n  return response\\nend\\n\\ndef traverse(node, response)\\n  return if node.nil?\\n  \\n  traverse(node.left, response) if node.left\\n  response << node.val\\n  traverse(node.right, response) if node.right\\nend\\n```\\n\\n### Iterative approach\\n```ruby\\ndef inorder_traversal(root)\\n  curr = root\\n  stack, res = [], []\\n  \\n  while !(curr.nil? and stack.empty?)\\n    while curr\\n      stack.push(curr)\\n      curr = curr.left\\n    end\\n    curr = stack.pop\\n    res << curr.val\\n    curr = curr.right\\n  end\\n  \\n  return res\\nend\\n````\\n",
                "solutionTags": [],
                "code": "```ruby\\ndef inorder_traversal_recursive(root)\\n  response = []\\n  traverse(root, response)\\n  return response\\nend\\n\\ndef traverse(node, response)\\n  return if node.nil?\\n  \\n  traverse(node.left, response) if node.left\\n  response << node.val\\n  traverse(node.right, response) if node.right\\nend\\n```\n```ruby\\ndef inorder_traversal(root)\\n  curr = root\\n  stack, res = [], []\\n  \\n  while !(curr.nil? and stack.empty?)\\n    while curr\\n      stack.push(curr)\\n      curr = curr.left\\n    end\\n    curr = stack.pop\\n    res << curr.val\\n    curr = curr.right\\n  end\\n  \\n  return res\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 31378,
                "title": "share-my-c-solution-very-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        vector<int> inorderTraversal(TreeNode* root) {\\n            vector<int> ret;\\n            stack<TreeNode *> s;\\n            TreeNode *temp = root;\\n            \\n            while (!s.empty() || temp != NULL)\\n            {\\n                while (temp != NULL)\\n                {\\n                    s.push(temp);\\n                    temp = temp->left;\\n                }\\n                \\n                temp = s.top();\\n                ret.push_back(temp->val);\\n                s.pop();\\n                temp = temp->right;\\n            }\\n            \\n            return ret;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> inorderTraversal(TreeNode* root) {\\n            vector<int> ret;\\n            stack<TreeNode *> s;\\n            TreeNode *temp = root;\\n            \\n            while (!s.empty() || temp != NULL)\\n            {\\n                while (temp != NULL)\\n                {\\n                    s.push(temp);\\n                    temp = temp->left;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3509959,
                "title": "python-easy-recursive-iterative-both-solutions",
                "content": "**Iterative Solution:**\\n```\\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return\\n        t=root\\n        a=[]\\n        ans=[]\\n        while True:\\n            if t:\\n                a.append(t)\\n                t=t.left\\n            else:\\n                if len(a)==0:\\n                    break\\n                t=a.pop()\\n                ans.append(t.val)\\n                t=t.right \\n        return ans\\n```\\n**Recursive Solution:**\\n```\\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        self.ans=[]\\n        self.Traversal(root)\\n        return self.ans\\n    def Traversal(self,root):\\n        if root is None:\\n            return\\n        self.Traversal(root.left)\\n        self.ans.append(root.val)\\n        self.Traversal(root.right)\\n```\\n**An  upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return\\n        t=root\\n        a=[]\\n        ans=[]\\n        while True:\\n            if t:\\n                a.append(t)\\n                t=t.left\\n            else:\\n                if len(a)==0:\\n                    break\\n                t=a.pop()\\n                ans.append(t.val)\\n                t=t.right \\n        return ans\\n```\n```\\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        self.ans=[]\\n        self.Traversal(root)\\n        return self.ans\\n    def Traversal(self,root):\\n        if root is None:\\n            return\\n        self.Traversal(root.left)\\n        self.ans.append(root.val)\\n        self.Traversal(root.right)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3408869,
                "title": "very-easy-o-n-intutive-recursive-code-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nVery Easy and understandable c++ code\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void solve(TreeNode* root,vector<int>&v){\\n        if(!root)\\n        return;\\n\\n        solve(root->left,v);\\n        v.push_back(root->val);\\n        solve(root->right,v);\\n    }\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        \\n        solve(root,v);\\n        return v;\\n        \\n    }\\n};         \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void solve(TreeNode* root,vector<int>&v){\\n        if(!root)\\n        return;\\n\\n        solve(root->left,v);\\n        v.push_back(root->val);\\n        solve(root->right,v);\\n    }\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        \\n        solve(root,v);\\n        return v;\\n        \\n    }\\n};         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399456,
                "title": "simple-go-solution",
                "content": "\\n```\\n\\nfunc inorderTraversal(root *TreeNode) []int {\\n\\tres := make([]int, 0, 101)\\n\\tif root != nil {\\n\\t\\tres = help(root, res)\\n\\t}\\n\\t\\n\\treturn res\\n}\\n\\nfunc help(root *TreeNode, res []int) []int {\\n\\tif root.Left != nil {\\n\\t\\tres = help(root.Left, res)\\n\\t}\\n\\tres = append(res, root.Val)\\n\\tif root.Right != nil {\\n\\t\\tres = help(root.Right, res)\\n\\t}\\n\\treturn res\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n\\nfunc inorderTraversal(root *TreeNode) []int {\\n\\tres := make([]int, 0, 101)\\n\\tif root != nil {\\n\\t\\tres = help(root, res)\\n\\t}\\n\\t\\n\\treturn res\\n}\\n\\nfunc help(root *TreeNode, res []int) []int {\\n\\tif root.Left != nil {\\n\\t\\tres = help(root.Left, res)\\n\\t}\\n\\tres = append(res, root.Val)\\n\\tif root.Right != nil {\\n\\t\\tres = help(root.Right, res)\\n\\t}\\n\\treturn res\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3203062,
                "title": "java-easy-iterative-solution-using-stack",
                "content": "```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        if(root==null)  return list;\\n        TreeNode curr = root;\\n        Stack<TreeNode> st = new Stack<>();\\n        while(!st.isEmpty() || curr!=null){\\n            while(curr!=null){\\n                st.push(curr);\\n                curr = curr.left;\\n            }\\n            curr = st.pop();\\n            list.add(curr.val);\\n            curr = curr.right;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        if(root==null)  return list;\\n        TreeNode curr = root;\\n        Stack<TreeNode> st = new Stack<>();\\n        while(!st.isEmpty() || curr!=null){\\n            while(curr!=null){\\n                st.push(curr);\\n                curr = curr.left;\\n            }\\n            curr = st.pop();\\n            list.add(curr.val);\\n            curr = curr.right;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3195780,
                "title": "python-4-solutions-dfs-bfs-morris-1-morris-2",
                "content": "# Approach 1: DFS.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\nwhere, `n is the number of nodes in the tree`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def inorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        def inorder(root: TreeNode | None) -> Iterator[TreeNode]:\\n            yield from chain(inorder(root.left), (root,), inorder(root.right)) if root else tuple()\\n        \\n        return [node.val for node in inorder(root_)]\\n\\n\\n```\\n\\n---\\n\\n# Approach 2: BFS.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\nwhere, `n is the number of nodes in the tree`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def inorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        def inorder(root: TreeNode | None) -> Iterator[TreeNode]:\\n            stack = [root] if root else []\\n            \\n            while stack:\\n                node = stack.pop()\\n                if not node.left and not node.right: yield node; continue\\n                \\n                if node.right: stack.append(node.right)\\n                stack.append(TreeNode(node.val))\\n                if node.left: stack.append(node.left)\\n                \\n        return [node.val for node in inorder(root_)]\\n\\n\\n```\\n\\n---\\n\\n# Approach 3: Morris traversal. (Destroys the tree.)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\nwhere, `n is the number of nodes in the tree`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def inorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        # Morris (Destroys the tree)\\n        def inorder(root: TreeNode | None) -> Iterator[TreeNode]:\\n            node = root\\n            while node:\\n                if node.left:\\n                    last = node.left\\n                    while last.right: last = last.right\\n                    \\n                    last.right = node\\n                    node = node.left\\n                    last.right.left = None\\n                else:\\n                    yield node\\n                    node = node.right\\n                \\n        return [node.val for node in inorder(root_)]\\n\\n\\n```\\n\\n---\\n\\n# Approach 4: Morris traversal. (Destroys and recovers the tree.)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\nwhere, `n is the number of nodes in the tree`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def inorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        # Morris (Destroys and recovers the tree)\\n        def inorder(root: TreeNode | None) -> Iterator[TreeNode]:\\n            node = root\\n            while node:\\n                if node.left:\\n                    last = node.left\\n                    while last.right and last.right != node:\\n                        last = last.right\\n                    \\n                    if last.right:\\n                        last.right = None\\n                        yield node\\n                        node = node.right\\n                    else:\\n                        last.right = node\\n                        node = node.left\\n                else:\\n                    yield node\\n                    node = node.right\\n                \\n        return [node.val for node in inorder(root_)]\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```python\\nclass Solution:\\n    def inorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        def inorder(root: TreeNode | None) -> Iterator[TreeNode]:\\n            yield from chain(inorder(root.left), (root,), inorder(root.right)) if root else tuple()\\n        \\n        return [node.val for node in inorder(root_)]\\n\\n\\n```\n```python\\nclass Solution:\\n    def inorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        def inorder(root: TreeNode | None) -> Iterator[TreeNode]:\\n            stack = [root] if root else []\\n            \\n            while stack:\\n                node = stack.pop()\\n                if not node.left and not node.right: yield node; continue\\n                \\n                if node.right: stack.append(node.right)\\n                stack.append(TreeNode(node.val))\\n                if node.left: stack.append(node.left)\\n                \\n        return [node.val for node in inorder(root_)]\\n\\n\\n```\n```python\\nclass Solution:\\n    def inorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        # Morris (Destroys the tree)\\n        def inorder(root: TreeNode | None) -> Iterator[TreeNode]:\\n            node = root\\n            while node:\\n                if node.left:\\n                    last = node.left\\n                    while last.right: last = last.right\\n                    \\n                    last.right = node\\n                    node = node.left\\n                    last.right.left = None\\n                else:\\n                    yield node\\n                    node = node.right\\n                \\n        return [node.val for node in inorder(root_)]\\n\\n\\n```\n```python\\nclass Solution:\\n    def inorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        # Morris (Destroys and recovers the tree)\\n        def inorder(root: TreeNode | None) -> Iterator[TreeNode]:\\n            node = root\\n            while node:\\n                if node.left:\\n                    last = node.left\\n                    while last.right and last.right != node:\\n                        last = last.right\\n                    \\n                    if last.right:\\n                        last.right = None\\n                        yield node\\n                        node = node.right\\n                    else:\\n                        last.right = node\\n                        node = node.left\\n                else:\\n                    yield node\\n                    node = node.right\\n                \\n        return [node.val for node in inorder(root_)]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087159,
                "title": "java-recursive-way-easy-solution-with-comments",
                "content": "# Approach\\nUsing recursive way, travsere the tree and keep adding the value to the list. Another way is by using the stack\\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution \\n{\\n    //creating an instance\\n    List<Integer> list = new ArrayList<Integer>();\\n\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        //if empty tree\\n        if(root == null)\\n            return list;\\n\\n        TreeNode ptr = root;\\n\\n        traversal(ptr);\\n\\n        return list;\\n    }\\n\\n    //inorder traversal\\n    public void traversal (TreeNode root)\\n    {\\n        //return on reaching end\\n        if(root == null)\\n            return;\\n\\n        // recur on the left node\\n        traversal(root.left);\\n\\n        //get the data of the node\\n        list.add(root.val);\\n\\n        //now recur on the right node\\n        traversal(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution \\n{\\n    //creating an instance\\n    List<Integer> list = new ArrayList<Integer>();\\n\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        //if empty tree\\n        if(root == null)\\n            return list;\\n\\n        TreeNode ptr = root;\\n\\n        traversal(ptr);\\n\\n        return list;\\n    }\\n\\n    //inorder traversal\\n    public void traversal (TreeNode root)\\n    {\\n        //return on reaching end\\n        if(root == null)\\n            return;\\n\\n        // recur on the left node\\n        traversal(root.left);\\n\\n        //get the data of the node\\n        list.add(root.val);\\n\\n        //now recur on the right node\\n        traversal(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026386,
                "title": "beats-100-3-methods-morris-iterative-recursion-c-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Using simple recursion.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) (recursive call stack)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void inorderHelper(TreeNode* root, vector<int>& ans){\\n        if(root==NULL)return;\\n        inorderHelper(root->left,ans); \\n        ans.push_back(root->val);\\n        inorderHelper(root->right,ans);      \\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        inorderHelper(root,ans);\\n        return ans;\\n    }\\n};\\n```\\n---\\n# Method #2 : Morris Traversal\\n\\n# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf current does not have left child\\n\\n    a. Add current\\u2019s value\\n\\n    b. Go to the right, i.e., current = current.right\\n\\nElse\\n\\n    a. In current\\'s left subtree, make current the right child of the rightmost node\\n\\n    b. Go to this left child, i.e., current = current.left\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        TreeNode* curNode = root;\\n        vector<int> nodes;\\n        \\n        while (curNode != NULL) \\n        {\\n            if (curNode -> left) \\n            {\\n\\t\\t\\t\\t//Find the inorder predecessor of current\\n               //ifa) Make current as right child of the rightmost node in current\\'s left subtree\\n                TreeNode* predecessor = curNode -> left;\\n                while (predecessor -> right && predecessor -> right != curNode) //second condition used when reverting\\n                    predecessor = predecessor -> right;\\n                \\n                if ((predecessor -> right)==NULL) \\n                {\\n                    predecessor -> right = curNode;\\n                    curNode = curNode -> left; //ifb) Go to this left child\\n                }\\n                else \\n                {\\n                    //Revert back the changes\\n                    predecessor -> right = NULL;\\n                    nodes.push_back(curNode -> val);\\n                    curNode = curNode -> right;\\n                }\\n            }\\n            else \\n            {\\n                nodes.push_back(curNode -> val);  //ea)\\n                curNode = curNode -> right;  //eb)\\n            }\\n        }\\n        \\n        return nodes;\\n    }\\n};\\n```\\n---\\n# Method #3 : Iterative(Important)\\n\\n# Intution \\n- we\\'ll use a stack for that , to store addresses of elements and there state.\\n- state 0 = inorder(root->left);\\n- state 1 = cout<<data;\\n- state 2 = inorder(root->right);\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) (stack)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        stack<pair<TreeNode*,int>> st;\\n        vector<int> v;\\n        if(root == NULL) return {};\\n        st.push({root,0});\\n        while(!st.empty()){\\n            TreeNode* cur = st.top().first;\\n            int state = st.top().second;\\n            st.pop();\\n            \\n            if(cur == NULL){\\n                continue;\\n            }\\n            if(state == 0){\\n                st.push({cur,1});\\n                st.push({cur->left,0});\\n            }else if(state == 1){\\n                v.push_back(cur->val);\\n                st.push({cur,2});\\n            }else{\\n                st.push({cur->right,0});\\n            }\\n        }\\n        return v;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void inorderHelper(TreeNode* root, vector<int>& ans){\\n        if(root==NULL)return;\\n        inorderHelper(root->left,ans); \\n        ans.push_back(root->val);\\n        inorderHelper(root->right,ans);      \\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        inorderHelper(root,ans);\\n        return ans;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        TreeNode* curNode = root;\\n        vector<int> nodes;\\n        \\n        while (curNode != NULL) \\n        {\\n            if (curNode -> left) \\n            {\\n\\t\\t\\t\\t//Find the inorder predecessor of current\\n               //ifa) Make current as right child of the rightmost node in current\\'s left subtree\\n                TreeNode* predecessor = curNode -> left;\\n                while (predecessor -> right && predecessor -> right != curNode) //second condition used when reverting\\n                    predecessor = predecessor -> right;\\n                \\n                if ((predecessor -> right)==NULL) \\n                {\\n                    predecessor -> right = curNode;\\n                    curNode = curNode -> left; //ifb) Go to this left child\\n                }\\n                else \\n                {\\n                    //Revert back the changes\\n                    predecessor -> right = NULL;\\n                    nodes.push_back(curNode -> val);\\n                    curNode = curNode -> right;\\n                }\\n            }\\n            else \\n            {\\n                nodes.push_back(curNode -> val);  //ea)\\n                curNode = curNode -> right;  //eb)\\n            }\\n        }\\n        \\n        return nodes;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        stack<pair<TreeNode*,int>> st;\\n        vector<int> v;\\n        if(root == NULL) return {};\\n        st.push({root,0});\\n        while(!st.empty()){\\n            TreeNode* cur = st.top().first;\\n            int state = st.top().second;\\n            st.pop();\\n            \\n            if(cur == NULL){\\n                continue;\\n            }\\n            if(state == 0){\\n                st.push({cur,1});\\n                st.push({cur->left,0});\\n            }else if(state == 1){\\n                v.push_back(cur->val);\\n                st.push({cur,2});\\n            }else{\\n                st.push({cur->right,0});\\n            }\\n        }\\n        return v;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3024178,
                "title": "94-fast-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ll=[]\\n        def tr(root):\\n            if root==None:\\n                return \\n            \\n            tr(root.left)\\n            ll.append(root.val)\\n            tr(root.right)\\n            return ll\\n        return tr(root)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ll=[]\\n        def tr(root):\\n            if root==None:\\n                return \\n            \\n            tr(root.left)\\n            ll.append(root.val)\\n            tr(root.right)\\n            return ll\\n        return tr(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006595,
                "title": "beats-100-golang",
                "content": "\\n\\n# Code\\n```\\nfunc inorderTraversal(root *TreeNode) []int {\\n\\tif root == nil {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tvar values []int\\n\\tvalues = append(values, inorderTraversal(root.Left)...)\\n\\tvalues = append(values, root.Val)\\n\\tvalues = append(values, inorderTraversal(root.Right)...)\\n\\n\\treturn values\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc inorderTraversal(root *TreeNode) []int {\\n\\tif root == nil {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tvar values []int\\n\\tvalues = append(values, inorderTraversal(root.Left)...)\\n\\tvalues = append(values, root.Val)\\n\\tvalues = append(values, inorderTraversal(root.Right)...)\\n\\n\\treturn values\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2927089,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void f(TreeNode* root, vector<int> &ans)\\n    {\\n        if(root==NULL)\\n            return;\\n        f(root->left, ans);\\n        ans.push_back(root->val);\\n        f(root->right, ans);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        f(root, ans);\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void f(TreeNode* root, vector<int> &ans)\\n    {\\n        if(root==NULL)\\n            return;\\n        f(root->left, ans);\\n        ans.push_back(root->val);\\n        f(root->right, ans);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        f(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765181,
                "title": "c-traversal",
                "content": "```\\npublic:\\n    bool is_same(TreeNode *root1, TreeNode *root2){\\n        if(!root1 && !root2) return true;\\n        if((!root1 && root2) || (root1 && !root2)) return false;\\n        \\n        if(root1->val == root2->val) return is_same(root1->left , root2->right) && is_same(root1->right , root2->left);\\n        else return false;\\n    }\\n    \\n    bool isSymmetric(TreeNode* root) {\\n        return is_same(root->left, root->right);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\npublic:\\n    bool is_same(TreeNode *root1, TreeNode *root2){\\n        if(!root1 && !root2) return true;\\n        if((!root1 && root2) || (root1 && !root2)) return false;\\n        \\n        if(root1->val == root2->val) return is_same(root1->left , root2->right) && is_same(root1->right , root2->left);\\n        else return false;\\n    }\\n    \\n    bool isSymmetric(TreeNode* root) {\\n        return is_same(root->left, root->right);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2628733,
                "title": "typescript-javascript-solution-that-doesn-t-push-arrays-around",
                "content": "If you simply use an array outer to the function, subsequent test cases will fail, because Leetcode will run your function repeatedly but won\\'t clear the array. So the array needs to be cleared on the first invocation of the function, but the function is called recursively, so you don\\'t know when the first invocation is.\\nOne solution would be to return the arrays of numbers and concatenate them, but that needlessly moved data in the stack.\\nA faster solution is to use a closure, and initialize the array in it.\\n```\\nfunction inorderTraversal(root: TreeNode | null): number[] {\\n    const result = [];\\n    function traverse(root: TreeNode | null): number[] {\\n        if (root) {\\n            traverse(root.left);\\n            result.push(root.val);\\n            traverse(root.right);\\n        }\\n        return result;\\n    }\\n    return traverse(root);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction inorderTraversal(root: TreeNode | null): number[] {\\n    const result = [];\\n    function traverse(root: TreeNode | null): number[] {\\n        if (root) {\\n            traverse(root.left);\\n            result.push(root.val);\\n            traverse(root.right);\\n        }\\n        return result;\\n    }\\n    return traverse(root);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2564385,
                "title": "python-all-in-one-morris-with-notes-iterative-recursive-solutions",
                "content": "**Morris Traversal**\\nEven Recursive takes Auxiliary stack space so Time O(n) and sapce O(n) , But Morris takes O(n) and O(1)\\nMorris Uses treaded BT (Contains predecessor and successor information in NULL pointers)\\n**Algorithm Cases:**\\n\\t1. If left null, print curr and move right\\n\\t2. before going left, make right most node on left subtree connected to current node, then go left\\n\\t3. if thread is already pointed to current node, then remove the thread\\n```\\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\tres = []\\n\\t\\t\\tcurr = root\\n\\n\\t\\t\\twhile curr:\\n\\t\\t\\t\\t# If left null, print curr and move right\\n\\t\\t\\t\\tif not curr.left:\\n\\t\\t\\t\\t\\tres.append(curr.val)\\n\\t\\t\\t\\t\\tcurr = curr.right\\n\\t\\t\\t\\t# before going left, make right most node on left subtree connected to current node, then go left\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tprev = curr.left\\n\\t\\t\\t\\t\\twhile prev.right and prev.right!=curr:\\n\\t\\t\\t\\t\\t\\tprev = prev.right\\n\\t\\t\\t\\t\\t# make thread\\n\\t\\t\\t\\t\\tif not prev.right:\\n\\t\\t\\t\\t\\t\\tprev.right = curr\\n\\t\\t\\t\\t\\t\\tcurr = curr.left\\n\\t\\t\\t\\t\\t# if thread is already pointed to current node, means You have visited the node, cut the thread, print the root and  move to the right\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tprev.right = None\\n\\t\\t\\t\\t\\t\\tres.append(curr.val)\\n\\t\\t\\t\\t\\t\\tcurr = curr.right\\n\\t\\t\\treturn res\\n```\\n\\n**Iterative**\\n```\\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\tstack, res = [], []      \\n        while True:\\n            while root:\\n                stack.append(root)\\n                root=root.left\\n            if not stack: return res\\n            node = stack.pop()\\n            res.append(node.val)\\n            root=node.right\\n```\\n**Recursive**\\n```\\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\treturn self.inorderTraversal(root.left)+[root.val]+self.inorderTraversal(root.right) if root else []\\n```\\n\\n**PLEASE UPVOTE IF YOU LIKED!**\\n",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\tres = []\\n\\t\\t\\tcurr = root\\n\\n\\t\\t\\twhile curr:\\n\\t\\t\\t\\t# If left null, print curr and move right\\n\\t\\t\\t\\tif not curr.left:\\n\\t\\t\\t\\t\\tres.append(curr.val)\\n\\t\\t\\t\\t\\tcurr = curr.right\\n\\t\\t\\t\\t# before going left, make right most node on left subtree connected to current node, then go left\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tprev = curr.left\\n\\t\\t\\t\\t\\twhile prev.right and prev.right!=curr:\\n\\t\\t\\t\\t\\t\\tprev = prev.right\\n\\t\\t\\t\\t\\t# make thread\\n\\t\\t\\t\\t\\tif not prev.right:\\n\\t\\t\\t\\t\\t\\tprev.right = curr\\n\\t\\t\\t\\t\\t\\tcurr = curr.left\\n\\t\\t\\t\\t\\t# if thread is already pointed to current node, means You have visited the node, cut the thread, print the root and  move to the right\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tprev.right = None\\n\\t\\t\\t\\t\\t\\tres.append(curr.val)\\n\\t\\t\\t\\t\\t\\tcurr = curr.right\\n\\t\\t\\treturn res\\n```\n```\\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\tstack, res = [], []      \\n        while True:\\n            while root:\\n                stack.append(root)\\n                root=root.left\\n            if not stack: return res\\n            node = stack.pop()\\n            res.append(node.val)\\n            root=node.right\\n```\n```\\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\treturn self.inorderTraversal(root.left)+[root.val]+self.inorderTraversal(root.right) if root else []\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2547396,
                "title": "c-0ms-short-simple-code",
                "content": "***DO UPVOTE IF IT HELPS !!!!***\\n\\t\\n**TC** = O(N)\\n\\t\\n\\tvoid solve(TreeNode *root, vector<int>&v){\\n        if(!root) return;\\n        \\n        solve(root->left,v);         //root->left\\n        v.push_back(root->val);      //store root->val\\n        solve(root->right,v);        //root->right\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        solve(root,v);\\n        return v;\\n    }",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!!!***\\n\\t\\n**TC** = O(N)\\n\\t\\n\\tvoid solve(TreeNode *root, vector<int>&v){\\n        if(!root) return;\\n        \\n        solve(root->left,v);         //root->left\\n        v.push_back(root->val);      //store root->val\\n        solve(root->right,v);        //root->right\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        solve(root,v);\\n        return v;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2229713,
                "title": "c-solution-faster-than-100-solutions-currently",
                "content": "**The below code is faster than 100% of the solutions currently on LeetCode. Happy Leetcoding !!\\nDo Upvote \\u270C\\uD83C\\uDFFB**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> inorder (TreeNode* root,vector<int>&v)\\n    {\\n       if(root!=NULL)\\n       {\\n            inorder(root->left,v);\\n            v.push_back(root->val);\\n            inorder(root->right,v);\\n       }\\n        return v;\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        \\n        inorder(root,v);\\n        \\n        return v;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Tree",
                    "Recursion",
                    "Binary Tree",
                    "Interactive"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> inorder (TreeNode* root,vector<int>&v)\\n    {\\n       if(root!=NULL)\\n       {\\n            inorder(root->left,v);\\n            v.push_back(root->val);\\n            inorder(root->right,v);\\n       }\\n        return v;\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        \\n        inorder(root,v);\\n        \\n        return v;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147819,
                "title": "two-lines-solution-in-kotlin",
                "content": "Simple solution using recursion in Kotlin\\n\\n```\\nclass Solution {\\n    \\n    fun inorderTraversal(root: TreeNode?): List<Int> {\\n       root ?: return listOf<Int>()\\n       return  inorderTraversal(root.left) + listOf(root.`val`) + inorderTraversal(root.right)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    \\n    fun inorderTraversal(root: TreeNode?): List<Int> {\\n       root ?: return listOf<Int>()\\n       return  inorderTraversal(root.left) + listOf(root.`val`) + inorderTraversal(root.right)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2050074,
                "title": "python-100-easy-solution",
                "content": "\\n\\tresult = []\\n        return self.dfs(root, result)\\n    \\n    def dfs(self, node, res):\\n        if node is not None:\\n            self.dfs(node.left, res)\\n            res.append(node.val)\\n            self.dfs(node.right, res)\\n        return res",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "\\n\\tresult = []\\n        return self.dfs(root, result)\\n    \\n    def dfs(self, node, res):\\n        if node is not None:\\n            self.dfs(node.left, res)\\n            res.append(node.val)\\n            self.dfs(node.right, res)\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 1978409,
                "title": "c-iterative-solution-stack-with-comments",
                "content": "```\\nclass Solution {\\n\\t// Inorder - Left Subtree -> Root -> Right Subtree\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> st;\\n        vector<int> ans;\\n        \\n\\t\\t// 1. Make root as the starting node, that is currNode\\n        TreeNode* currNode = root;\\n        while (currNode or !st.empty()) {\\n\\t\\t// 2. Now add all the left subtree nodes to the stack\\n            while (currNode) {\\n                st.push(currNode);\\n                currNode = currNode->left;\\n            }   \\n        // 3. Pick out the top node, put it in answer array\\n            currNode = st.top();\\n            st.pop();\\n            \\n            ans.push_back(currNode->val);\\n\\t\\t// 4. Update currNode as below, this will take care of the right subtree\\n            currNode = currNode->right;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n\\t// Inorder - Left Subtree -> Root -> Right Subtree\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> st;\\n        vector<int> ans;\\n        \\n\\t\\t// 1. Make root as the starting node, that is currNode\\n        TreeNode* currNode = root;\\n        while (currNode or !st.empty()) {\\n\\t\\t// 2. Now add all the left subtree nodes to the stack\\n            while (currNode) {\\n                st.push(currNode);\\n                currNode = currNode->left;\\n            }   \\n        // 3. Pick out the top node, put it in answer array\\n            currNode = st.top();\\n            st.pop();\\n            \\n            ans.push_back(currNode->val);\\n\\t\\t// 4. Update currNode as below, this will take care of the right subtree\\n            currNode = currNode->right;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958957,
                "title": "scala-solution",
                "content": "```\\nobject Solution {\\n    def inorderTraversal(root: TreeNode): List[Int] = {\\n        if(root == null) List()\\n        else inorderTraversal(root.left) ++ List(root.value) ++ inorderTraversal(root.right)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def inorderTraversal(root: TreeNode): List[Int] = {\\n        if(root == null) List()\\n        else inorderTraversal(root.left) ++ List(root.value) ++ inorderTraversal(root.right)\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1777345,
                "title": "python-solution-iterative-recursive-easy-to-understand",
                "content": "```python\\n# Recursive and Iterative Solutions to inOrder, preOrder, and postOrder traversal\\n# ------------------------------------------- recursive\\n# recursive\\ndef BSTTraversal(root):\\n    res = []\\n    def inOrder(root):\\n        if root:\\n            inOrder(root.left)\\n            res.append(root.val)\\n            inOrder(root.right)\\n    \\n    def preOrder(root):\\n        if root:\\n            res.append(root.val)\\n            inOrder(root.left)\\n            inOrder(root.right)\\n    \\n    def postOrder(root):\\n        if root:\\n            inOrder(root.left)\\n            inOrder(root.right)\\n            res.append(root.val)\\n    \\n    inOrder(root)\\n    return res\\n\\n# one-liner recursive\\ndef traverse(root):\\n    return self.postorderTraversal(root.left)+self.postorderTraversal(root.right)+[root.val] if root else [] #post order\\n    # return self.postorderTraversal(root.left)+[root.val]+self.postorderTraversal(root.right) if root else [] #in order\\n    # return [root.val]+self.postorderTraversal(root.left)+self.postorderTraversal(root.right) if root else [] #pre order\\n\\n# ------------------------------------------- Iterative\\ndef inorderTraversal(self, root):\\n    stack, result = [], []   \\n    curr = root\\n    while curr or stack:\\n        while curr:\\n            stack.append(curr)\\n            curr = curr.left\\n        node = stack.pop()\\n        result.append(node.val)\\n        curr = node.right\\n        \\n    return result\\n\\ndef preorderTraversal(self, root):\\n    stack, result = [root], []   \\n    while stack:\\n        curr = stack.pop()\\n        if curr:\\n            result.append(curr.val)\\n            stack.append(curr.right)\\n            stack.append(curr.left)\\n        \\n    return result\\n\\ndef postorderTraversal(root):\\n    stack, result = [root], []   \\n    while stack:\\n        curr = stack.pop()\\n        if curr:\\n            result.append(curr.val)\\n            stack.append(curr.left)\\n            stack.append(curr.right)\\n    return result[::-1]",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```python\\n# Recursive and Iterative Solutions to inOrder, preOrder, and postOrder traversal\\n# ------------------------------------------- recursive\\n# recursive\\ndef BSTTraversal(root):\\n    res = []\\n    def inOrder(root):\\n        if root:\\n            inOrder(root.left)\\n            res.append(root.val)\\n            inOrder(root.right)\\n    \\n    def preOrder(root):\\n        if root:\\n            res.append(root.val)\\n            inOrder(root.left)\\n            inOrder(root.right)\\n    \\n    def postOrder(root):\\n        if root:\\n            inOrder(root.left)\\n            inOrder(root.right)\\n            res.append(root.val)\\n    \\n    inOrder(root)\\n    return res\\n\\n# one-liner recursive\\ndef traverse(root):\\n    return self.postorderTraversal(root.left)+self.postorderTraversal(root.right)+[root.val] if root else [] #post order\\n    # return self.postorderTraversal(root.left)+[root.val]+self.postorderTraversal(root.right) if root else [] #in order\\n    # return [root.val]+self.postorderTraversal(root.left)+self.postorderTraversal(root.right) if root else [] #pre order\\n\\n# ------------------------------------------- Iterative\\ndef inorderTraversal(self, root):\\n    stack, result = [], []   \\n    curr = root\\n    while curr or stack:\\n        while curr:\\n            stack.append(curr)\\n            curr = curr.left\\n        node = stack.pop()\\n        result.append(node.val)\\n        curr = node.right\\n        \\n    return result\\n\\ndef preorderTraversal(self, root):\\n    stack, result = [root], []   \\n    while stack:\\n        curr = stack.pop()\\n        if curr:\\n            result.append(curr.val)\\n            stack.append(curr.right)\\n            stack.append(curr.left)\\n        \\n    return result\\n\\ndef postorderTraversal(root):\\n    stack, result = [root], []   \\n    while stack:\\n        curr = stack.pop()\\n        if curr:\\n            result.append(curr.val)\\n            stack.append(curr.left)\\n            stack.append(curr.right)\\n    return result[::-1]",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1567642,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1567706,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1576752,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1571206,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1862741,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1750273,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1820685,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1566744,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1569462,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1565404,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1567642,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1567706,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1576752,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1571206,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1862741,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1750273,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1820685,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1566744,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1569462,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1565404,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1570174,
                "content": [
                    {
                        "username": "user7277Op",
                        "content": "Take a look at my screen shot:\\n\\n![image](https://assets.leetcode.com/users/images/e05e7857-c795-4382-abbc-3abb991abe14_1600663307.1254942.png)\\n"
                    },
                    {
                        "username": "mehtapreet404",
                        "content": "Hi. So this issue is due to the usage of a common class variable `ll`.\\nAll the test cases are run in a sequence. \\nHence, the output of the first test case (then the value of `ll` after running the first test case) becomes the starting state in the second test case."
                    },
                    {
                        "username": "KensaySato",
                        "content": "did you figure out why this is happening? having the same issue"
                    },
                    {
                        "username": "b27022602",
                        "content": "Am I the only one who cant not even understand the description of the question?\\nI feel the problem is easy, but some concept are not. "
                    },
                    {
                        "username": "strmrdr123",
                        "content": "Why are the examples for this question so bad...? Maybe give a larger example so people can understand what is required?"
                    },
                    {
                        "username": "yopyop1007",
                        "content": "Hey everyone,\\nI was confused what the question means by \"inorder travel\"? The example shown, and its respective output do not really get the question across. Sorry if this is answered in one of the solutions, I would like to understand and try it out before checking out a solution. Thanks"
                    },
                    {
                        "username": "RamakantB",
                        "content": "About test cases - Why would an input with root = null, expect an output of [] (basically new ArrayList<Integer>()) & not null?\\n"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "function should return a value of the same type, so it would be strange to expect it to return null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "A Tree with no nodes does not imply there is no Traversal. There is a Traversal with no nodes."
                    },
                    {
                        "username": "mokotozett",
                        "content": "Concepts needed to answer this question:\\nBinary Tree\\nRoot\\nNodes\\nInorder Traversal\\n\\nI recommend go brush up on these and come back to this problem later."
                    },
                    {
                        "username": "mokotozett",
                        "content": "This one requires some knowledge about trees and nodes. \\nWith that knowledge, the logic of the problem becomes clear. Check each Node, if it has a subtree under, check the left and then the right subrtee nodes. If the right or left have subtrees themselves, check the left and then the right of their nodes, and so on.\\n\\nIn the given sample problem: [1, 2, 3]\\nBefore you put \"1\" down, does it have a subtree? Yeah, no left, but it has a right \"2\" subtree. Since there is no left, clear \"1\"  and we put \"1\" down. [1].\\nBefore you put subtree \"2\" down, does \"2\" have a subtree? Yes, it has a left but no right subtree. So we go to the left subtree of \"2\" which is \"3\". \\nBefore we put \"3\" down, does it have a subtree? No left or right. Clear \"3\" and put it down. [1, 3]\\nWe are back in \"2\". We cleared its left node. There is no right node for \"2\" so now we put down \"2\". [1, 3, 2]\\nIf \"2\" had 2 nodes, once we cleared the left, we put down \"2\" and we go to the right node of \"2\", Does the right node of \"2\" have a subtree? If it does? Is it a left or right node? And so on...\\nSummary: Start at a node, check for subtrees. Check the left node of the subtree for other nodes under it. Clear the left nodes. Then put down the parent node and move to start clearing the right nodes. Something like that.\\n"
                    },
                    {
                        "username": "DanielQiao",
                        "content": "BST traversals are apprantly very important topics and I find most times the recursion or iteration + stack approach is enough to tackle most questions I\\'ve see. However, is the morris traversal method applied a good range of questions/asked in interviews? I find it a bit trickey to understand."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "Need more examples"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "If you\\'re able to solve it using recursion/stack then try to do it using Morris traversal algorithm. It uses O(1) space and amortized O(n) time"
                    }
                ]
            },
            {
                "id": 1905416,
                "content": [
                    {
                        "username": "user7277Op",
                        "content": "Take a look at my screen shot:\\n\\n![image](https://assets.leetcode.com/users/images/e05e7857-c795-4382-abbc-3abb991abe14_1600663307.1254942.png)\\n"
                    },
                    {
                        "username": "mehtapreet404",
                        "content": "Hi. So this issue is due to the usage of a common class variable `ll`.\\nAll the test cases are run in a sequence. \\nHence, the output of the first test case (then the value of `ll` after running the first test case) becomes the starting state in the second test case."
                    },
                    {
                        "username": "KensaySato",
                        "content": "did you figure out why this is happening? having the same issue"
                    },
                    {
                        "username": "b27022602",
                        "content": "Am I the only one who cant not even understand the description of the question?\\nI feel the problem is easy, but some concept are not. "
                    },
                    {
                        "username": "strmrdr123",
                        "content": "Why are the examples for this question so bad...? Maybe give a larger example so people can understand what is required?"
                    },
                    {
                        "username": "yopyop1007",
                        "content": "Hey everyone,\\nI was confused what the question means by \"inorder travel\"? The example shown, and its respective output do not really get the question across. Sorry if this is answered in one of the solutions, I would like to understand and try it out before checking out a solution. Thanks"
                    },
                    {
                        "username": "RamakantB",
                        "content": "About test cases - Why would an input with root = null, expect an output of [] (basically new ArrayList<Integer>()) & not null?\\n"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "function should return a value of the same type, so it would be strange to expect it to return null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "A Tree with no nodes does not imply there is no Traversal. There is a Traversal with no nodes."
                    },
                    {
                        "username": "mokotozett",
                        "content": "Concepts needed to answer this question:\\nBinary Tree\\nRoot\\nNodes\\nInorder Traversal\\n\\nI recommend go brush up on these and come back to this problem later."
                    },
                    {
                        "username": "mokotozett",
                        "content": "This one requires some knowledge about trees and nodes. \\nWith that knowledge, the logic of the problem becomes clear. Check each Node, if it has a subtree under, check the left and then the right subrtee nodes. If the right or left have subtrees themselves, check the left and then the right of their nodes, and so on.\\n\\nIn the given sample problem: [1, 2, 3]\\nBefore you put \"1\" down, does it have a subtree? Yeah, no left, but it has a right \"2\" subtree. Since there is no left, clear \"1\"  and we put \"1\" down. [1].\\nBefore you put subtree \"2\" down, does \"2\" have a subtree? Yes, it has a left but no right subtree. So we go to the left subtree of \"2\" which is \"3\". \\nBefore we put \"3\" down, does it have a subtree? No left or right. Clear \"3\" and put it down. [1, 3]\\nWe are back in \"2\". We cleared its left node. There is no right node for \"2\" so now we put down \"2\". [1, 3, 2]\\nIf \"2\" had 2 nodes, once we cleared the left, we put down \"2\" and we go to the right node of \"2\", Does the right node of \"2\" have a subtree? If it does? Is it a left or right node? And so on...\\nSummary: Start at a node, check for subtrees. Check the left node of the subtree for other nodes under it. Clear the left nodes. Then put down the parent node and move to start clearing the right nodes. Something like that.\\n"
                    },
                    {
                        "username": "DanielQiao",
                        "content": "BST traversals are apprantly very important topics and I find most times the recursion or iteration + stack approach is enough to tackle most questions I\\'ve see. However, is the morris traversal method applied a good range of questions/asked in interviews? I find it a bit trickey to understand."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "Need more examples"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "If you\\'re able to solve it using recursion/stack then try to do it using Morris traversal algorithm. It uses O(1) space and amortized O(n) time"
                    }
                ]
            },
            {
                "id": 1816158,
                "content": [
                    {
                        "username": "user7277Op",
                        "content": "Take a look at my screen shot:\\n\\n![image](https://assets.leetcode.com/users/images/e05e7857-c795-4382-abbc-3abb991abe14_1600663307.1254942.png)\\n"
                    },
                    {
                        "username": "mehtapreet404",
                        "content": "Hi. So this issue is due to the usage of a common class variable `ll`.\\nAll the test cases are run in a sequence. \\nHence, the output of the first test case (then the value of `ll` after running the first test case) becomes the starting state in the second test case."
                    },
                    {
                        "username": "KensaySato",
                        "content": "did you figure out why this is happening? having the same issue"
                    },
                    {
                        "username": "b27022602",
                        "content": "Am I the only one who cant not even understand the description of the question?\\nI feel the problem is easy, but some concept are not. "
                    },
                    {
                        "username": "strmrdr123",
                        "content": "Why are the examples for this question so bad...? Maybe give a larger example so people can understand what is required?"
                    },
                    {
                        "username": "yopyop1007",
                        "content": "Hey everyone,\\nI was confused what the question means by \"inorder travel\"? The example shown, and its respective output do not really get the question across. Sorry if this is answered in one of the solutions, I would like to understand and try it out before checking out a solution. Thanks"
                    },
                    {
                        "username": "RamakantB",
                        "content": "About test cases - Why would an input with root = null, expect an output of [] (basically new ArrayList<Integer>()) & not null?\\n"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "function should return a value of the same type, so it would be strange to expect it to return null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "A Tree with no nodes does not imply there is no Traversal. There is a Traversal with no nodes."
                    },
                    {
                        "username": "mokotozett",
                        "content": "Concepts needed to answer this question:\\nBinary Tree\\nRoot\\nNodes\\nInorder Traversal\\n\\nI recommend go brush up on these and come back to this problem later."
                    },
                    {
                        "username": "mokotozett",
                        "content": "This one requires some knowledge about trees and nodes. \\nWith that knowledge, the logic of the problem becomes clear. Check each Node, if it has a subtree under, check the left and then the right subrtee nodes. If the right or left have subtrees themselves, check the left and then the right of their nodes, and so on.\\n\\nIn the given sample problem: [1, 2, 3]\\nBefore you put \"1\" down, does it have a subtree? Yeah, no left, but it has a right \"2\" subtree. Since there is no left, clear \"1\"  and we put \"1\" down. [1].\\nBefore you put subtree \"2\" down, does \"2\" have a subtree? Yes, it has a left but no right subtree. So we go to the left subtree of \"2\" which is \"3\". \\nBefore we put \"3\" down, does it have a subtree? No left or right. Clear \"3\" and put it down. [1, 3]\\nWe are back in \"2\". We cleared its left node. There is no right node for \"2\" so now we put down \"2\". [1, 3, 2]\\nIf \"2\" had 2 nodes, once we cleared the left, we put down \"2\" and we go to the right node of \"2\", Does the right node of \"2\" have a subtree? If it does? Is it a left or right node? And so on...\\nSummary: Start at a node, check for subtrees. Check the left node of the subtree for other nodes under it. Clear the left nodes. Then put down the parent node and move to start clearing the right nodes. Something like that.\\n"
                    },
                    {
                        "username": "DanielQiao",
                        "content": "BST traversals are apprantly very important topics and I find most times the recursion or iteration + stack approach is enough to tackle most questions I\\'ve see. However, is the morris traversal method applied a good range of questions/asked in interviews? I find it a bit trickey to understand."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "Need more examples"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "If you\\'re able to solve it using recursion/stack then try to do it using Morris traversal algorithm. It uses O(1) space and amortized O(n) time"
                    }
                ]
            },
            {
                "id": 1574193,
                "content": [
                    {
                        "username": "user7277Op",
                        "content": "Take a look at my screen shot:\\n\\n![image](https://assets.leetcode.com/users/images/e05e7857-c795-4382-abbc-3abb991abe14_1600663307.1254942.png)\\n"
                    },
                    {
                        "username": "mehtapreet404",
                        "content": "Hi. So this issue is due to the usage of a common class variable `ll`.\\nAll the test cases are run in a sequence. \\nHence, the output of the first test case (then the value of `ll` after running the first test case) becomes the starting state in the second test case."
                    },
                    {
                        "username": "KensaySato",
                        "content": "did you figure out why this is happening? having the same issue"
                    },
                    {
                        "username": "b27022602",
                        "content": "Am I the only one who cant not even understand the description of the question?\\nI feel the problem is easy, but some concept are not. "
                    },
                    {
                        "username": "strmrdr123",
                        "content": "Why are the examples for this question so bad...? Maybe give a larger example so people can understand what is required?"
                    },
                    {
                        "username": "yopyop1007",
                        "content": "Hey everyone,\\nI was confused what the question means by \"inorder travel\"? The example shown, and its respective output do not really get the question across. Sorry if this is answered in one of the solutions, I would like to understand and try it out before checking out a solution. Thanks"
                    },
                    {
                        "username": "RamakantB",
                        "content": "About test cases - Why would an input with root = null, expect an output of [] (basically new ArrayList<Integer>()) & not null?\\n"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "function should return a value of the same type, so it would be strange to expect it to return null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "A Tree with no nodes does not imply there is no Traversal. There is a Traversal with no nodes."
                    },
                    {
                        "username": "mokotozett",
                        "content": "Concepts needed to answer this question:\\nBinary Tree\\nRoot\\nNodes\\nInorder Traversal\\n\\nI recommend go brush up on these and come back to this problem later."
                    },
                    {
                        "username": "mokotozett",
                        "content": "This one requires some knowledge about trees and nodes. \\nWith that knowledge, the logic of the problem becomes clear. Check each Node, if it has a subtree under, check the left and then the right subrtee nodes. If the right or left have subtrees themselves, check the left and then the right of their nodes, and so on.\\n\\nIn the given sample problem: [1, 2, 3]\\nBefore you put \"1\" down, does it have a subtree? Yeah, no left, but it has a right \"2\" subtree. Since there is no left, clear \"1\"  and we put \"1\" down. [1].\\nBefore you put subtree \"2\" down, does \"2\" have a subtree? Yes, it has a left but no right subtree. So we go to the left subtree of \"2\" which is \"3\". \\nBefore we put \"3\" down, does it have a subtree? No left or right. Clear \"3\" and put it down. [1, 3]\\nWe are back in \"2\". We cleared its left node. There is no right node for \"2\" so now we put down \"2\". [1, 3, 2]\\nIf \"2\" had 2 nodes, once we cleared the left, we put down \"2\" and we go to the right node of \"2\", Does the right node of \"2\" have a subtree? If it does? Is it a left or right node? And so on...\\nSummary: Start at a node, check for subtrees. Check the left node of the subtree for other nodes under it. Clear the left nodes. Then put down the parent node and move to start clearing the right nodes. Something like that.\\n"
                    },
                    {
                        "username": "DanielQiao",
                        "content": "BST traversals are apprantly very important topics and I find most times the recursion or iteration + stack approach is enough to tackle most questions I\\'ve see. However, is the morris traversal method applied a good range of questions/asked in interviews? I find it a bit trickey to understand."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "Need more examples"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "If you\\'re able to solve it using recursion/stack then try to do it using Morris traversal algorithm. It uses O(1) space and amortized O(n) time"
                    }
                ]
            },
            {
                "id": 1572684,
                "content": [
                    {
                        "username": "user7277Op",
                        "content": "Take a look at my screen shot:\\n\\n![image](https://assets.leetcode.com/users/images/e05e7857-c795-4382-abbc-3abb991abe14_1600663307.1254942.png)\\n"
                    },
                    {
                        "username": "mehtapreet404",
                        "content": "Hi. So this issue is due to the usage of a common class variable `ll`.\\nAll the test cases are run in a sequence. \\nHence, the output of the first test case (then the value of `ll` after running the first test case) becomes the starting state in the second test case."
                    },
                    {
                        "username": "KensaySato",
                        "content": "did you figure out why this is happening? having the same issue"
                    },
                    {
                        "username": "b27022602",
                        "content": "Am I the only one who cant not even understand the description of the question?\\nI feel the problem is easy, but some concept are not. "
                    },
                    {
                        "username": "strmrdr123",
                        "content": "Why are the examples for this question so bad...? Maybe give a larger example so people can understand what is required?"
                    },
                    {
                        "username": "yopyop1007",
                        "content": "Hey everyone,\\nI was confused what the question means by \"inorder travel\"? The example shown, and its respective output do not really get the question across. Sorry if this is answered in one of the solutions, I would like to understand and try it out before checking out a solution. Thanks"
                    },
                    {
                        "username": "RamakantB",
                        "content": "About test cases - Why would an input with root = null, expect an output of [] (basically new ArrayList<Integer>()) & not null?\\n"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "function should return a value of the same type, so it would be strange to expect it to return null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "A Tree with no nodes does not imply there is no Traversal. There is a Traversal with no nodes."
                    },
                    {
                        "username": "mokotozett",
                        "content": "Concepts needed to answer this question:\\nBinary Tree\\nRoot\\nNodes\\nInorder Traversal\\n\\nI recommend go brush up on these and come back to this problem later."
                    },
                    {
                        "username": "mokotozett",
                        "content": "This one requires some knowledge about trees and nodes. \\nWith that knowledge, the logic of the problem becomes clear. Check each Node, if it has a subtree under, check the left and then the right subrtee nodes. If the right or left have subtrees themselves, check the left and then the right of their nodes, and so on.\\n\\nIn the given sample problem: [1, 2, 3]\\nBefore you put \"1\" down, does it have a subtree? Yeah, no left, but it has a right \"2\" subtree. Since there is no left, clear \"1\"  and we put \"1\" down. [1].\\nBefore you put subtree \"2\" down, does \"2\" have a subtree? Yes, it has a left but no right subtree. So we go to the left subtree of \"2\" which is \"3\". \\nBefore we put \"3\" down, does it have a subtree? No left or right. Clear \"3\" and put it down. [1, 3]\\nWe are back in \"2\". We cleared its left node. There is no right node for \"2\" so now we put down \"2\". [1, 3, 2]\\nIf \"2\" had 2 nodes, once we cleared the left, we put down \"2\" and we go to the right node of \"2\", Does the right node of \"2\" have a subtree? If it does? Is it a left or right node? And so on...\\nSummary: Start at a node, check for subtrees. Check the left node of the subtree for other nodes under it. Clear the left nodes. Then put down the parent node and move to start clearing the right nodes. Something like that.\\n"
                    },
                    {
                        "username": "DanielQiao",
                        "content": "BST traversals are apprantly very important topics and I find most times the recursion or iteration + stack approach is enough to tackle most questions I\\'ve see. However, is the morris traversal method applied a good range of questions/asked in interviews? I find it a bit trickey to understand."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "Need more examples"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "If you\\'re able to solve it using recursion/stack then try to do it using Morris traversal algorithm. It uses O(1) space and amortized O(n) time"
                    }
                ]
            },
            {
                "id": 1869599,
                "content": [
                    {
                        "username": "user7277Op",
                        "content": "Take a look at my screen shot:\\n\\n![image](https://assets.leetcode.com/users/images/e05e7857-c795-4382-abbc-3abb991abe14_1600663307.1254942.png)\\n"
                    },
                    {
                        "username": "mehtapreet404",
                        "content": "Hi. So this issue is due to the usage of a common class variable `ll`.\\nAll the test cases are run in a sequence. \\nHence, the output of the first test case (then the value of `ll` after running the first test case) becomes the starting state in the second test case."
                    },
                    {
                        "username": "KensaySato",
                        "content": "did you figure out why this is happening? having the same issue"
                    },
                    {
                        "username": "b27022602",
                        "content": "Am I the only one who cant not even understand the description of the question?\\nI feel the problem is easy, but some concept are not. "
                    },
                    {
                        "username": "strmrdr123",
                        "content": "Why are the examples for this question so bad...? Maybe give a larger example so people can understand what is required?"
                    },
                    {
                        "username": "yopyop1007",
                        "content": "Hey everyone,\\nI was confused what the question means by \"inorder travel\"? The example shown, and its respective output do not really get the question across. Sorry if this is answered in one of the solutions, I would like to understand and try it out before checking out a solution. Thanks"
                    },
                    {
                        "username": "RamakantB",
                        "content": "About test cases - Why would an input with root = null, expect an output of [] (basically new ArrayList<Integer>()) & not null?\\n"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "function should return a value of the same type, so it would be strange to expect it to return null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "A Tree with no nodes does not imply there is no Traversal. There is a Traversal with no nodes."
                    },
                    {
                        "username": "mokotozett",
                        "content": "Concepts needed to answer this question:\\nBinary Tree\\nRoot\\nNodes\\nInorder Traversal\\n\\nI recommend go brush up on these and come back to this problem later."
                    },
                    {
                        "username": "mokotozett",
                        "content": "This one requires some knowledge about trees and nodes. \\nWith that knowledge, the logic of the problem becomes clear. Check each Node, if it has a subtree under, check the left and then the right subrtee nodes. If the right or left have subtrees themselves, check the left and then the right of their nodes, and so on.\\n\\nIn the given sample problem: [1, 2, 3]\\nBefore you put \"1\" down, does it have a subtree? Yeah, no left, but it has a right \"2\" subtree. Since there is no left, clear \"1\"  and we put \"1\" down. [1].\\nBefore you put subtree \"2\" down, does \"2\" have a subtree? Yes, it has a left but no right subtree. So we go to the left subtree of \"2\" which is \"3\". \\nBefore we put \"3\" down, does it have a subtree? No left or right. Clear \"3\" and put it down. [1, 3]\\nWe are back in \"2\". We cleared its left node. There is no right node for \"2\" so now we put down \"2\". [1, 3, 2]\\nIf \"2\" had 2 nodes, once we cleared the left, we put down \"2\" and we go to the right node of \"2\", Does the right node of \"2\" have a subtree? If it does? Is it a left or right node? And so on...\\nSummary: Start at a node, check for subtrees. Check the left node of the subtree for other nodes under it. Clear the left nodes. Then put down the parent node and move to start clearing the right nodes. Something like that.\\n"
                    },
                    {
                        "username": "DanielQiao",
                        "content": "BST traversals are apprantly very important topics and I find most times the recursion or iteration + stack approach is enough to tackle most questions I\\'ve see. However, is the morris traversal method applied a good range of questions/asked in interviews? I find it a bit trickey to understand."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "Need more examples"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "If you\\'re able to solve it using recursion/stack then try to do it using Morris traversal algorithm. It uses O(1) space and amortized O(n) time"
                    }
                ]
            },
            {
                "id": 1869367,
                "content": [
                    {
                        "username": "user7277Op",
                        "content": "Take a look at my screen shot:\\n\\n![image](https://assets.leetcode.com/users/images/e05e7857-c795-4382-abbc-3abb991abe14_1600663307.1254942.png)\\n"
                    },
                    {
                        "username": "mehtapreet404",
                        "content": "Hi. So this issue is due to the usage of a common class variable `ll`.\\nAll the test cases are run in a sequence. \\nHence, the output of the first test case (then the value of `ll` after running the first test case) becomes the starting state in the second test case."
                    },
                    {
                        "username": "KensaySato",
                        "content": "did you figure out why this is happening? having the same issue"
                    },
                    {
                        "username": "b27022602",
                        "content": "Am I the only one who cant not even understand the description of the question?\\nI feel the problem is easy, but some concept are not. "
                    },
                    {
                        "username": "strmrdr123",
                        "content": "Why are the examples for this question so bad...? Maybe give a larger example so people can understand what is required?"
                    },
                    {
                        "username": "yopyop1007",
                        "content": "Hey everyone,\\nI was confused what the question means by \"inorder travel\"? The example shown, and its respective output do not really get the question across. Sorry if this is answered in one of the solutions, I would like to understand and try it out before checking out a solution. Thanks"
                    },
                    {
                        "username": "RamakantB",
                        "content": "About test cases - Why would an input with root = null, expect an output of [] (basically new ArrayList<Integer>()) & not null?\\n"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "function should return a value of the same type, so it would be strange to expect it to return null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "A Tree with no nodes does not imply there is no Traversal. There is a Traversal with no nodes."
                    },
                    {
                        "username": "mokotozett",
                        "content": "Concepts needed to answer this question:\\nBinary Tree\\nRoot\\nNodes\\nInorder Traversal\\n\\nI recommend go brush up on these and come back to this problem later."
                    },
                    {
                        "username": "mokotozett",
                        "content": "This one requires some knowledge about trees and nodes. \\nWith that knowledge, the logic of the problem becomes clear. Check each Node, if it has a subtree under, check the left and then the right subrtee nodes. If the right or left have subtrees themselves, check the left and then the right of their nodes, and so on.\\n\\nIn the given sample problem: [1, 2, 3]\\nBefore you put \"1\" down, does it have a subtree? Yeah, no left, but it has a right \"2\" subtree. Since there is no left, clear \"1\"  and we put \"1\" down. [1].\\nBefore you put subtree \"2\" down, does \"2\" have a subtree? Yes, it has a left but no right subtree. So we go to the left subtree of \"2\" which is \"3\". \\nBefore we put \"3\" down, does it have a subtree? No left or right. Clear \"3\" and put it down. [1, 3]\\nWe are back in \"2\". We cleared its left node. There is no right node for \"2\" so now we put down \"2\". [1, 3, 2]\\nIf \"2\" had 2 nodes, once we cleared the left, we put down \"2\" and we go to the right node of \"2\", Does the right node of \"2\" have a subtree? If it does? Is it a left or right node? And so on...\\nSummary: Start at a node, check for subtrees. Check the left node of the subtree for other nodes under it. Clear the left nodes. Then put down the parent node and move to start clearing the right nodes. Something like that.\\n"
                    },
                    {
                        "username": "DanielQiao",
                        "content": "BST traversals are apprantly very important topics and I find most times the recursion or iteration + stack approach is enough to tackle most questions I\\'ve see. However, is the morris traversal method applied a good range of questions/asked in interviews? I find it a bit trickey to understand."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "Need more examples"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "If you\\'re able to solve it using recursion/stack then try to do it using Morris traversal algorithm. It uses O(1) space and amortized O(n) time"
                    }
                ]
            },
            {
                "id": 1570515,
                "content": [
                    {
                        "username": "user7277Op",
                        "content": "Take a look at my screen shot:\\n\\n![image](https://assets.leetcode.com/users/images/e05e7857-c795-4382-abbc-3abb991abe14_1600663307.1254942.png)\\n"
                    },
                    {
                        "username": "mehtapreet404",
                        "content": "Hi. So this issue is due to the usage of a common class variable `ll`.\\nAll the test cases are run in a sequence. \\nHence, the output of the first test case (then the value of `ll` after running the first test case) becomes the starting state in the second test case."
                    },
                    {
                        "username": "KensaySato",
                        "content": "did you figure out why this is happening? having the same issue"
                    },
                    {
                        "username": "b27022602",
                        "content": "Am I the only one who cant not even understand the description of the question?\\nI feel the problem is easy, but some concept are not. "
                    },
                    {
                        "username": "strmrdr123",
                        "content": "Why are the examples for this question so bad...? Maybe give a larger example so people can understand what is required?"
                    },
                    {
                        "username": "yopyop1007",
                        "content": "Hey everyone,\\nI was confused what the question means by \"inorder travel\"? The example shown, and its respective output do not really get the question across. Sorry if this is answered in one of the solutions, I would like to understand and try it out before checking out a solution. Thanks"
                    },
                    {
                        "username": "RamakantB",
                        "content": "About test cases - Why would an input with root = null, expect an output of [] (basically new ArrayList<Integer>()) & not null?\\n"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "function should return a value of the same type, so it would be strange to expect it to return null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "A Tree with no nodes does not imply there is no Traversal. There is a Traversal with no nodes."
                    },
                    {
                        "username": "mokotozett",
                        "content": "Concepts needed to answer this question:\\nBinary Tree\\nRoot\\nNodes\\nInorder Traversal\\n\\nI recommend go brush up on these and come back to this problem later."
                    },
                    {
                        "username": "mokotozett",
                        "content": "This one requires some knowledge about trees and nodes. \\nWith that knowledge, the logic of the problem becomes clear. Check each Node, if it has a subtree under, check the left and then the right subrtee nodes. If the right or left have subtrees themselves, check the left and then the right of their nodes, and so on.\\n\\nIn the given sample problem: [1, 2, 3]\\nBefore you put \"1\" down, does it have a subtree? Yeah, no left, but it has a right \"2\" subtree. Since there is no left, clear \"1\"  and we put \"1\" down. [1].\\nBefore you put subtree \"2\" down, does \"2\" have a subtree? Yes, it has a left but no right subtree. So we go to the left subtree of \"2\" which is \"3\". \\nBefore we put \"3\" down, does it have a subtree? No left or right. Clear \"3\" and put it down. [1, 3]\\nWe are back in \"2\". We cleared its left node. There is no right node for \"2\" so now we put down \"2\". [1, 3, 2]\\nIf \"2\" had 2 nodes, once we cleared the left, we put down \"2\" and we go to the right node of \"2\", Does the right node of \"2\" have a subtree? If it does? Is it a left or right node? And so on...\\nSummary: Start at a node, check for subtrees. Check the left node of the subtree for other nodes under it. Clear the left nodes. Then put down the parent node and move to start clearing the right nodes. Something like that.\\n"
                    },
                    {
                        "username": "DanielQiao",
                        "content": "BST traversals are apprantly very important topics and I find most times the recursion or iteration + stack approach is enough to tackle most questions I\\'ve see. However, is the morris traversal method applied a good range of questions/asked in interviews? I find it a bit trickey to understand."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "Need more examples"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "If you\\'re able to solve it using recursion/stack then try to do it using Morris traversal algorithm. It uses O(1) space and amortized O(n) time"
                    }
                ]
            },
            {
                "id": 2026019,
                "content": [
                    {
                        "username": "user7277Op",
                        "content": "Take a look at my screen shot:\\n\\n![image](https://assets.leetcode.com/users/images/e05e7857-c795-4382-abbc-3abb991abe14_1600663307.1254942.png)\\n"
                    },
                    {
                        "username": "mehtapreet404",
                        "content": "Hi. So this issue is due to the usage of a common class variable `ll`.\\nAll the test cases are run in a sequence. \\nHence, the output of the first test case (then the value of `ll` after running the first test case) becomes the starting state in the second test case."
                    },
                    {
                        "username": "KensaySato",
                        "content": "did you figure out why this is happening? having the same issue"
                    },
                    {
                        "username": "b27022602",
                        "content": "Am I the only one who cant not even understand the description of the question?\\nI feel the problem is easy, but some concept are not. "
                    },
                    {
                        "username": "strmrdr123",
                        "content": "Why are the examples for this question so bad...? Maybe give a larger example so people can understand what is required?"
                    },
                    {
                        "username": "yopyop1007",
                        "content": "Hey everyone,\\nI was confused what the question means by \"inorder travel\"? The example shown, and its respective output do not really get the question across. Sorry if this is answered in one of the solutions, I would like to understand and try it out before checking out a solution. Thanks"
                    },
                    {
                        "username": "RamakantB",
                        "content": "About test cases - Why would an input with root = null, expect an output of [] (basically new ArrayList<Integer>()) & not null?\\n"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "function should return a value of the same type, so it would be strange to expect it to return null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "A Tree with no nodes does not imply there is no Traversal. There is a Traversal with no nodes."
                    },
                    {
                        "username": "mokotozett",
                        "content": "Concepts needed to answer this question:\\nBinary Tree\\nRoot\\nNodes\\nInorder Traversal\\n\\nI recommend go brush up on these and come back to this problem later."
                    },
                    {
                        "username": "mokotozett",
                        "content": "This one requires some knowledge about trees and nodes. \\nWith that knowledge, the logic of the problem becomes clear. Check each Node, if it has a subtree under, check the left and then the right subrtee nodes. If the right or left have subtrees themselves, check the left and then the right of their nodes, and so on.\\n\\nIn the given sample problem: [1, 2, 3]\\nBefore you put \"1\" down, does it have a subtree? Yeah, no left, but it has a right \"2\" subtree. Since there is no left, clear \"1\"  and we put \"1\" down. [1].\\nBefore you put subtree \"2\" down, does \"2\" have a subtree? Yes, it has a left but no right subtree. So we go to the left subtree of \"2\" which is \"3\". \\nBefore we put \"3\" down, does it have a subtree? No left or right. Clear \"3\" and put it down. [1, 3]\\nWe are back in \"2\". We cleared its left node. There is no right node for \"2\" so now we put down \"2\". [1, 3, 2]\\nIf \"2\" had 2 nodes, once we cleared the left, we put down \"2\" and we go to the right node of \"2\", Does the right node of \"2\" have a subtree? If it does? Is it a left or right node? And so on...\\nSummary: Start at a node, check for subtrees. Check the left node of the subtree for other nodes under it. Clear the left nodes. Then put down the parent node and move to start clearing the right nodes. Something like that.\\n"
                    },
                    {
                        "username": "DanielQiao",
                        "content": "BST traversals are apprantly very important topics and I find most times the recursion or iteration + stack approach is enough to tackle most questions I\\'ve see. However, is the morris traversal method applied a good range of questions/asked in interviews? I find it a bit trickey to understand."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "Need more examples"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "If you\\'re able to solve it using recursion/stack then try to do it using Morris traversal algorithm. It uses O(1) space and amortized O(n) time"
                    }
                ]
            },
            {
                "id": 1949066,
                "content": [
                    {
                        "username": "user7277Op",
                        "content": "Take a look at my screen shot:\\n\\n![image](https://assets.leetcode.com/users/images/e05e7857-c795-4382-abbc-3abb991abe14_1600663307.1254942.png)\\n"
                    },
                    {
                        "username": "mehtapreet404",
                        "content": "Hi. So this issue is due to the usage of a common class variable `ll`.\\nAll the test cases are run in a sequence. \\nHence, the output of the first test case (then the value of `ll` after running the first test case) becomes the starting state in the second test case."
                    },
                    {
                        "username": "KensaySato",
                        "content": "did you figure out why this is happening? having the same issue"
                    },
                    {
                        "username": "b27022602",
                        "content": "Am I the only one who cant not even understand the description of the question?\\nI feel the problem is easy, but some concept are not. "
                    },
                    {
                        "username": "strmrdr123",
                        "content": "Why are the examples for this question so bad...? Maybe give a larger example so people can understand what is required?"
                    },
                    {
                        "username": "yopyop1007",
                        "content": "Hey everyone,\\nI was confused what the question means by \"inorder travel\"? The example shown, and its respective output do not really get the question across. Sorry if this is answered in one of the solutions, I would like to understand and try it out before checking out a solution. Thanks"
                    },
                    {
                        "username": "RamakantB",
                        "content": "About test cases - Why would an input with root = null, expect an output of [] (basically new ArrayList<Integer>()) & not null?\\n"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "function should return a value of the same type, so it would be strange to expect it to return null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "A Tree with no nodes does not imply there is no Traversal. There is a Traversal with no nodes."
                    },
                    {
                        "username": "mokotozett",
                        "content": "Concepts needed to answer this question:\\nBinary Tree\\nRoot\\nNodes\\nInorder Traversal\\n\\nI recommend go brush up on these and come back to this problem later."
                    },
                    {
                        "username": "mokotozett",
                        "content": "This one requires some knowledge about trees and nodes. \\nWith that knowledge, the logic of the problem becomes clear. Check each Node, if it has a subtree under, check the left and then the right subrtee nodes. If the right or left have subtrees themselves, check the left and then the right of their nodes, and so on.\\n\\nIn the given sample problem: [1, 2, 3]\\nBefore you put \"1\" down, does it have a subtree? Yeah, no left, but it has a right \"2\" subtree. Since there is no left, clear \"1\"  and we put \"1\" down. [1].\\nBefore you put subtree \"2\" down, does \"2\" have a subtree? Yes, it has a left but no right subtree. So we go to the left subtree of \"2\" which is \"3\". \\nBefore we put \"3\" down, does it have a subtree? No left or right. Clear \"3\" and put it down. [1, 3]\\nWe are back in \"2\". We cleared its left node. There is no right node for \"2\" so now we put down \"2\". [1, 3, 2]\\nIf \"2\" had 2 nodes, once we cleared the left, we put down \"2\" and we go to the right node of \"2\", Does the right node of \"2\" have a subtree? If it does? Is it a left or right node? And so on...\\nSummary: Start at a node, check for subtrees. Check the left node of the subtree for other nodes under it. Clear the left nodes. Then put down the parent node and move to start clearing the right nodes. Something like that.\\n"
                    },
                    {
                        "username": "DanielQiao",
                        "content": "BST traversals are apprantly very important topics and I find most times the recursion or iteration + stack approach is enough to tackle most questions I\\'ve see. However, is the morris traversal method applied a good range of questions/asked in interviews? I find it a bit trickey to understand."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "Need more examples"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "If you\\'re able to solve it using recursion/stack then try to do it using Morris traversal algorithm. It uses O(1) space and amortized O(n) time"
                    }
                ]
            },
            {
                "id": 1809614,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I love how in leetcode testcases are the edge cases.\\nLike what is this [] and [1] testcase..  I am assuming now that 1 3 2. Is root - left leave and going back up.\\nI mean this question is for beginners, no need to make it difficult for no reason. Hard and Medium questions can be as twisted as you want since they come close to that 100k salary, if you can solve them"
                    },
                    {
                        "username": "zkerner1",
                        "content": "why is their such an insistence - across leetcode - of giving trivial test cases. frankly I find this infuriating. Each problem should come with 3 - 4 non-trivial test cases."
                    },
                    {
                        "username": "fancypantsbob",
                        "content": "How could the average case be O(log(n))? Since the solution maintains an output list of each value from each node it should always be O(n) shouldn\\'t it?"
                    },
                    {
                        "username": "cannellajs2",
                        "content": "Oddly if I don\\'t make any modifications to my solution and repeatedly submit the memory usage will change while the speed remains the same. Maybe different test conditions on each submission?"
                    },
                    {
                        "username": "GeraldRyan",
                        "content": "I learned what Inorder traversal is, but how do they map an array/list into a tree? It doesn\\'t seem from the graphic representation that it\\'s doing an in-order or it would hit the node in the middle after hitting the leftmost. I-e. 123 not 132"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Is it just me or is an iterative inorder traversal algorithm substantially harder than an iterative preorder traversal?\\n\\nI was hoping I could find a template, like you get for recursive solutions, to do dfs + stack. However, this doesnt seem like the case. Am I right?"
                    },
                    {
                        "username": "bashyal",
                        "content": "whoever wrote these testcases can go ft"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "Easiest C++ solution ::\\n\\nvoid solution(TreeNode*root,vector<int>&v){\\n    if(root==NULL)\\n    return ;\\n    solution(root->left,v);\\n    v.push_back(root->val);\\n    solution(root->right,v);\\n}\\n    vector<int> inorderTraversal(TreeNode* root) {\\n       vector<int>v;\\n       solution(root,v);\\n       return v;\\n\\n        \\n    }"
                    },
                    {
                        "username": "peregudov",
                        "content": "Am I the only one who finds example tree confusing? Why is 3 on the left side of the 2. 3>2, shouldn\\'t 3 be on the right of 2?"
                    },
                    {
                        "username": "0x49D1",
                        "content": "I have not studied programming in the university, so the description of the problem was not enough for me. Took some time to find the explanation elsewhere and applied the recursive traversal solution after that. I think that would have been beneficial for the problem to add more wide explanation for people without specific background, because this is not \"rocket science\", but from 1 sentence it was not clear, sorry.   "
                    }
                ]
            },
            {
                "id": 1751467,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I love how in leetcode testcases are the edge cases.\\nLike what is this [] and [1] testcase..  I am assuming now that 1 3 2. Is root - left leave and going back up.\\nI mean this question is for beginners, no need to make it difficult for no reason. Hard and Medium questions can be as twisted as you want since they come close to that 100k salary, if you can solve them"
                    },
                    {
                        "username": "zkerner1",
                        "content": "why is their such an insistence - across leetcode - of giving trivial test cases. frankly I find this infuriating. Each problem should come with 3 - 4 non-trivial test cases."
                    },
                    {
                        "username": "fancypantsbob",
                        "content": "How could the average case be O(log(n))? Since the solution maintains an output list of each value from each node it should always be O(n) shouldn\\'t it?"
                    },
                    {
                        "username": "cannellajs2",
                        "content": "Oddly if I don\\'t make any modifications to my solution and repeatedly submit the memory usage will change while the speed remains the same. Maybe different test conditions on each submission?"
                    },
                    {
                        "username": "GeraldRyan",
                        "content": "I learned what Inorder traversal is, but how do they map an array/list into a tree? It doesn\\'t seem from the graphic representation that it\\'s doing an in-order or it would hit the node in the middle after hitting the leftmost. I-e. 123 not 132"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Is it just me or is an iterative inorder traversal algorithm substantially harder than an iterative preorder traversal?\\n\\nI was hoping I could find a template, like you get for recursive solutions, to do dfs + stack. However, this doesnt seem like the case. Am I right?"
                    },
                    {
                        "username": "bashyal",
                        "content": "whoever wrote these testcases can go ft"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "Easiest C++ solution ::\\n\\nvoid solution(TreeNode*root,vector<int>&v){\\n    if(root==NULL)\\n    return ;\\n    solution(root->left,v);\\n    v.push_back(root->val);\\n    solution(root->right,v);\\n}\\n    vector<int> inorderTraversal(TreeNode* root) {\\n       vector<int>v;\\n       solution(root,v);\\n       return v;\\n\\n        \\n    }"
                    },
                    {
                        "username": "peregudov",
                        "content": "Am I the only one who finds example tree confusing? Why is 3 on the left side of the 2. 3>2, shouldn\\'t 3 be on the right of 2?"
                    },
                    {
                        "username": "0x49D1",
                        "content": "I have not studied programming in the university, so the description of the problem was not enough for me. Took some time to find the explanation elsewhere and applied the recursive traversal solution after that. I think that would have been beneficial for the problem to add more wide explanation for people without specific background, because this is not \"rocket science\", but from 1 sentence it was not clear, sorry.   "
                    }
                ]
            },
            {
                "id": 1574233,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I love how in leetcode testcases are the edge cases.\\nLike what is this [] and [1] testcase..  I am assuming now that 1 3 2. Is root - left leave and going back up.\\nI mean this question is for beginners, no need to make it difficult for no reason. Hard and Medium questions can be as twisted as you want since they come close to that 100k salary, if you can solve them"
                    },
                    {
                        "username": "zkerner1",
                        "content": "why is their such an insistence - across leetcode - of giving trivial test cases. frankly I find this infuriating. Each problem should come with 3 - 4 non-trivial test cases."
                    },
                    {
                        "username": "fancypantsbob",
                        "content": "How could the average case be O(log(n))? Since the solution maintains an output list of each value from each node it should always be O(n) shouldn\\'t it?"
                    },
                    {
                        "username": "cannellajs2",
                        "content": "Oddly if I don\\'t make any modifications to my solution and repeatedly submit the memory usage will change while the speed remains the same. Maybe different test conditions on each submission?"
                    },
                    {
                        "username": "GeraldRyan",
                        "content": "I learned what Inorder traversal is, but how do they map an array/list into a tree? It doesn\\'t seem from the graphic representation that it\\'s doing an in-order or it would hit the node in the middle after hitting the leftmost. I-e. 123 not 132"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Is it just me or is an iterative inorder traversal algorithm substantially harder than an iterative preorder traversal?\\n\\nI was hoping I could find a template, like you get for recursive solutions, to do dfs + stack. However, this doesnt seem like the case. Am I right?"
                    },
                    {
                        "username": "bashyal",
                        "content": "whoever wrote these testcases can go ft"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "Easiest C++ solution ::\\n\\nvoid solution(TreeNode*root,vector<int>&v){\\n    if(root==NULL)\\n    return ;\\n    solution(root->left,v);\\n    v.push_back(root->val);\\n    solution(root->right,v);\\n}\\n    vector<int> inorderTraversal(TreeNode* root) {\\n       vector<int>v;\\n       solution(root,v);\\n       return v;\\n\\n        \\n    }"
                    },
                    {
                        "username": "peregudov",
                        "content": "Am I the only one who finds example tree confusing? Why is 3 on the left side of the 2. 3>2, shouldn\\'t 3 be on the right of 2?"
                    },
                    {
                        "username": "0x49D1",
                        "content": "I have not studied programming in the university, so the description of the problem was not enough for me. Took some time to find the explanation elsewhere and applied the recursive traversal solution after that. I think that would have been beneficial for the problem to add more wide explanation for people without specific background, because this is not \"rocket science\", but from 1 sentence it was not clear, sorry.   "
                    }
                ]
            },
            {
                "id": 1572593,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I love how in leetcode testcases are the edge cases.\\nLike what is this [] and [1] testcase..  I am assuming now that 1 3 2. Is root - left leave and going back up.\\nI mean this question is for beginners, no need to make it difficult for no reason. Hard and Medium questions can be as twisted as you want since they come close to that 100k salary, if you can solve them"
                    },
                    {
                        "username": "zkerner1",
                        "content": "why is their such an insistence - across leetcode - of giving trivial test cases. frankly I find this infuriating. Each problem should come with 3 - 4 non-trivial test cases."
                    },
                    {
                        "username": "fancypantsbob",
                        "content": "How could the average case be O(log(n))? Since the solution maintains an output list of each value from each node it should always be O(n) shouldn\\'t it?"
                    },
                    {
                        "username": "cannellajs2",
                        "content": "Oddly if I don\\'t make any modifications to my solution and repeatedly submit the memory usage will change while the speed remains the same. Maybe different test conditions on each submission?"
                    },
                    {
                        "username": "GeraldRyan",
                        "content": "I learned what Inorder traversal is, but how do they map an array/list into a tree? It doesn\\'t seem from the graphic representation that it\\'s doing an in-order or it would hit the node in the middle after hitting the leftmost. I-e. 123 not 132"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Is it just me or is an iterative inorder traversal algorithm substantially harder than an iterative preorder traversal?\\n\\nI was hoping I could find a template, like you get for recursive solutions, to do dfs + stack. However, this doesnt seem like the case. Am I right?"
                    },
                    {
                        "username": "bashyal",
                        "content": "whoever wrote these testcases can go ft"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "Easiest C++ solution ::\\n\\nvoid solution(TreeNode*root,vector<int>&v){\\n    if(root==NULL)\\n    return ;\\n    solution(root->left,v);\\n    v.push_back(root->val);\\n    solution(root->right,v);\\n}\\n    vector<int> inorderTraversal(TreeNode* root) {\\n       vector<int>v;\\n       solution(root,v);\\n       return v;\\n\\n        \\n    }"
                    },
                    {
                        "username": "peregudov",
                        "content": "Am I the only one who finds example tree confusing? Why is 3 on the left side of the 2. 3>2, shouldn\\'t 3 be on the right of 2?"
                    },
                    {
                        "username": "0x49D1",
                        "content": "I have not studied programming in the university, so the description of the problem was not enough for me. Took some time to find the explanation elsewhere and applied the recursive traversal solution after that. I think that would have been beneficial for the problem to add more wide explanation for people without specific background, because this is not \"rocket science\", but from 1 sentence it was not clear, sorry.   "
                    }
                ]
            },
            {
                "id": 1574123,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I love how in leetcode testcases are the edge cases.\\nLike what is this [] and [1] testcase..  I am assuming now that 1 3 2. Is root - left leave and going back up.\\nI mean this question is for beginners, no need to make it difficult for no reason. Hard and Medium questions can be as twisted as you want since they come close to that 100k salary, if you can solve them"
                    },
                    {
                        "username": "zkerner1",
                        "content": "why is their such an insistence - across leetcode - of giving trivial test cases. frankly I find this infuriating. Each problem should come with 3 - 4 non-trivial test cases."
                    },
                    {
                        "username": "fancypantsbob",
                        "content": "How could the average case be O(log(n))? Since the solution maintains an output list of each value from each node it should always be O(n) shouldn\\'t it?"
                    },
                    {
                        "username": "cannellajs2",
                        "content": "Oddly if I don\\'t make any modifications to my solution and repeatedly submit the memory usage will change while the speed remains the same. Maybe different test conditions on each submission?"
                    },
                    {
                        "username": "GeraldRyan",
                        "content": "I learned what Inorder traversal is, but how do they map an array/list into a tree? It doesn\\'t seem from the graphic representation that it\\'s doing an in-order or it would hit the node in the middle after hitting the leftmost. I-e. 123 not 132"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Is it just me or is an iterative inorder traversal algorithm substantially harder than an iterative preorder traversal?\\n\\nI was hoping I could find a template, like you get for recursive solutions, to do dfs + stack. However, this doesnt seem like the case. Am I right?"
                    },
                    {
                        "username": "bashyal",
                        "content": "whoever wrote these testcases can go ft"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "Easiest C++ solution ::\\n\\nvoid solution(TreeNode*root,vector<int>&v){\\n    if(root==NULL)\\n    return ;\\n    solution(root->left,v);\\n    v.push_back(root->val);\\n    solution(root->right,v);\\n}\\n    vector<int> inorderTraversal(TreeNode* root) {\\n       vector<int>v;\\n       solution(root,v);\\n       return v;\\n\\n        \\n    }"
                    },
                    {
                        "username": "peregudov",
                        "content": "Am I the only one who finds example tree confusing? Why is 3 on the left side of the 2. 3>2, shouldn\\'t 3 be on the right of 2?"
                    },
                    {
                        "username": "0x49D1",
                        "content": "I have not studied programming in the university, so the description of the problem was not enough for me. Took some time to find the explanation elsewhere and applied the recursive traversal solution after that. I think that would have been beneficial for the problem to add more wide explanation for people without specific background, because this is not \"rocket science\", but from 1 sentence it was not clear, sorry.   "
                    }
                ]
            },
            {
                "id": 1573707,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I love how in leetcode testcases are the edge cases.\\nLike what is this [] and [1] testcase..  I am assuming now that 1 3 2. Is root - left leave and going back up.\\nI mean this question is for beginners, no need to make it difficult for no reason. Hard and Medium questions can be as twisted as you want since they come close to that 100k salary, if you can solve them"
                    },
                    {
                        "username": "zkerner1",
                        "content": "why is their such an insistence - across leetcode - of giving trivial test cases. frankly I find this infuriating. Each problem should come with 3 - 4 non-trivial test cases."
                    },
                    {
                        "username": "fancypantsbob",
                        "content": "How could the average case be O(log(n))? Since the solution maintains an output list of each value from each node it should always be O(n) shouldn\\'t it?"
                    },
                    {
                        "username": "cannellajs2",
                        "content": "Oddly if I don\\'t make any modifications to my solution and repeatedly submit the memory usage will change while the speed remains the same. Maybe different test conditions on each submission?"
                    },
                    {
                        "username": "GeraldRyan",
                        "content": "I learned what Inorder traversal is, but how do they map an array/list into a tree? It doesn\\'t seem from the graphic representation that it\\'s doing an in-order or it would hit the node in the middle after hitting the leftmost. I-e. 123 not 132"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Is it just me or is an iterative inorder traversal algorithm substantially harder than an iterative preorder traversal?\\n\\nI was hoping I could find a template, like you get for recursive solutions, to do dfs + stack. However, this doesnt seem like the case. Am I right?"
                    },
                    {
                        "username": "bashyal",
                        "content": "whoever wrote these testcases can go ft"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "Easiest C++ solution ::\\n\\nvoid solution(TreeNode*root,vector<int>&v){\\n    if(root==NULL)\\n    return ;\\n    solution(root->left,v);\\n    v.push_back(root->val);\\n    solution(root->right,v);\\n}\\n    vector<int> inorderTraversal(TreeNode* root) {\\n       vector<int>v;\\n       solution(root,v);\\n       return v;\\n\\n        \\n    }"
                    },
                    {
                        "username": "peregudov",
                        "content": "Am I the only one who finds example tree confusing? Why is 3 on the left side of the 2. 3>2, shouldn\\'t 3 be on the right of 2?"
                    },
                    {
                        "username": "0x49D1",
                        "content": "I have not studied programming in the university, so the description of the problem was not enough for me. Took some time to find the explanation elsewhere and applied the recursive traversal solution after that. I think that would have been beneficial for the problem to add more wide explanation for people without specific background, because this is not \"rocket science\", but from 1 sentence it was not clear, sorry.   "
                    }
                ]
            },
            {
                "id": 2068958,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I love how in leetcode testcases are the edge cases.\\nLike what is this [] and [1] testcase..  I am assuming now that 1 3 2. Is root - left leave and going back up.\\nI mean this question is for beginners, no need to make it difficult for no reason. Hard and Medium questions can be as twisted as you want since they come close to that 100k salary, if you can solve them"
                    },
                    {
                        "username": "zkerner1",
                        "content": "why is their such an insistence - across leetcode - of giving trivial test cases. frankly I find this infuriating. Each problem should come with 3 - 4 non-trivial test cases."
                    },
                    {
                        "username": "fancypantsbob",
                        "content": "How could the average case be O(log(n))? Since the solution maintains an output list of each value from each node it should always be O(n) shouldn\\'t it?"
                    },
                    {
                        "username": "cannellajs2",
                        "content": "Oddly if I don\\'t make any modifications to my solution and repeatedly submit the memory usage will change while the speed remains the same. Maybe different test conditions on each submission?"
                    },
                    {
                        "username": "GeraldRyan",
                        "content": "I learned what Inorder traversal is, but how do they map an array/list into a tree? It doesn\\'t seem from the graphic representation that it\\'s doing an in-order or it would hit the node in the middle after hitting the leftmost. I-e. 123 not 132"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Is it just me or is an iterative inorder traversal algorithm substantially harder than an iterative preorder traversal?\\n\\nI was hoping I could find a template, like you get for recursive solutions, to do dfs + stack. However, this doesnt seem like the case. Am I right?"
                    },
                    {
                        "username": "bashyal",
                        "content": "whoever wrote these testcases can go ft"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "Easiest C++ solution ::\\n\\nvoid solution(TreeNode*root,vector<int>&v){\\n    if(root==NULL)\\n    return ;\\n    solution(root->left,v);\\n    v.push_back(root->val);\\n    solution(root->right,v);\\n}\\n    vector<int> inorderTraversal(TreeNode* root) {\\n       vector<int>v;\\n       solution(root,v);\\n       return v;\\n\\n        \\n    }"
                    },
                    {
                        "username": "peregudov",
                        "content": "Am I the only one who finds example tree confusing? Why is 3 on the left side of the 2. 3>2, shouldn\\'t 3 be on the right of 2?"
                    },
                    {
                        "username": "0x49D1",
                        "content": "I have not studied programming in the university, so the description of the problem was not enough for me. Took some time to find the explanation elsewhere and applied the recursive traversal solution after that. I think that would have been beneficial for the problem to add more wide explanation for people without specific background, because this is not \"rocket science\", but from 1 sentence it was not clear, sorry.   "
                    }
                ]
            },
            {
                "id": 2049898,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I love how in leetcode testcases are the edge cases.\\nLike what is this [] and [1] testcase..  I am assuming now that 1 3 2. Is root - left leave and going back up.\\nI mean this question is for beginners, no need to make it difficult for no reason. Hard and Medium questions can be as twisted as you want since they come close to that 100k salary, if you can solve them"
                    },
                    {
                        "username": "zkerner1",
                        "content": "why is their such an insistence - across leetcode - of giving trivial test cases. frankly I find this infuriating. Each problem should come with 3 - 4 non-trivial test cases."
                    },
                    {
                        "username": "fancypantsbob",
                        "content": "How could the average case be O(log(n))? Since the solution maintains an output list of each value from each node it should always be O(n) shouldn\\'t it?"
                    },
                    {
                        "username": "cannellajs2",
                        "content": "Oddly if I don\\'t make any modifications to my solution and repeatedly submit the memory usage will change while the speed remains the same. Maybe different test conditions on each submission?"
                    },
                    {
                        "username": "GeraldRyan",
                        "content": "I learned what Inorder traversal is, but how do they map an array/list into a tree? It doesn\\'t seem from the graphic representation that it\\'s doing an in-order or it would hit the node in the middle after hitting the leftmost. I-e. 123 not 132"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Is it just me or is an iterative inorder traversal algorithm substantially harder than an iterative preorder traversal?\\n\\nI was hoping I could find a template, like you get for recursive solutions, to do dfs + stack. However, this doesnt seem like the case. Am I right?"
                    },
                    {
                        "username": "bashyal",
                        "content": "whoever wrote these testcases can go ft"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "Easiest C++ solution ::\\n\\nvoid solution(TreeNode*root,vector<int>&v){\\n    if(root==NULL)\\n    return ;\\n    solution(root->left,v);\\n    v.push_back(root->val);\\n    solution(root->right,v);\\n}\\n    vector<int> inorderTraversal(TreeNode* root) {\\n       vector<int>v;\\n       solution(root,v);\\n       return v;\\n\\n        \\n    }"
                    },
                    {
                        "username": "peregudov",
                        "content": "Am I the only one who finds example tree confusing? Why is 3 on the left side of the 2. 3>2, shouldn\\'t 3 be on the right of 2?"
                    },
                    {
                        "username": "0x49D1",
                        "content": "I have not studied programming in the university, so the description of the problem was not enough for me. Took some time to find the explanation elsewhere and applied the recursive traversal solution after that. I think that would have been beneficial for the problem to add more wide explanation for people without specific background, because this is not \"rocket science\", but from 1 sentence it was not clear, sorry.   "
                    }
                ]
            },
            {
                "id": 2033340,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I love how in leetcode testcases are the edge cases.\\nLike what is this [] and [1] testcase..  I am assuming now that 1 3 2. Is root - left leave and going back up.\\nI mean this question is for beginners, no need to make it difficult for no reason. Hard and Medium questions can be as twisted as you want since they come close to that 100k salary, if you can solve them"
                    },
                    {
                        "username": "zkerner1",
                        "content": "why is their such an insistence - across leetcode - of giving trivial test cases. frankly I find this infuriating. Each problem should come with 3 - 4 non-trivial test cases."
                    },
                    {
                        "username": "fancypantsbob",
                        "content": "How could the average case be O(log(n))? Since the solution maintains an output list of each value from each node it should always be O(n) shouldn\\'t it?"
                    },
                    {
                        "username": "cannellajs2",
                        "content": "Oddly if I don\\'t make any modifications to my solution and repeatedly submit the memory usage will change while the speed remains the same. Maybe different test conditions on each submission?"
                    },
                    {
                        "username": "GeraldRyan",
                        "content": "I learned what Inorder traversal is, but how do they map an array/list into a tree? It doesn\\'t seem from the graphic representation that it\\'s doing an in-order or it would hit the node in the middle after hitting the leftmost. I-e. 123 not 132"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Is it just me or is an iterative inorder traversal algorithm substantially harder than an iterative preorder traversal?\\n\\nI was hoping I could find a template, like you get for recursive solutions, to do dfs + stack. However, this doesnt seem like the case. Am I right?"
                    },
                    {
                        "username": "bashyal",
                        "content": "whoever wrote these testcases can go ft"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "Easiest C++ solution ::\\n\\nvoid solution(TreeNode*root,vector<int>&v){\\n    if(root==NULL)\\n    return ;\\n    solution(root->left,v);\\n    v.push_back(root->val);\\n    solution(root->right,v);\\n}\\n    vector<int> inorderTraversal(TreeNode* root) {\\n       vector<int>v;\\n       solution(root,v);\\n       return v;\\n\\n        \\n    }"
                    },
                    {
                        "username": "peregudov",
                        "content": "Am I the only one who finds example tree confusing? Why is 3 on the left side of the 2. 3>2, shouldn\\'t 3 be on the right of 2?"
                    },
                    {
                        "username": "0x49D1",
                        "content": "I have not studied programming in the university, so the description of the problem was not enough for me. Took some time to find the explanation elsewhere and applied the recursive traversal solution after that. I think that would have been beneficial for the problem to add more wide explanation for people without specific background, because this is not \"rocket science\", but from 1 sentence it was not clear, sorry.   "
                    }
                ]
            },
            {
                "id": 2013454,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I love how in leetcode testcases are the edge cases.\\nLike what is this [] and [1] testcase..  I am assuming now that 1 3 2. Is root - left leave and going back up.\\nI mean this question is for beginners, no need to make it difficult for no reason. Hard and Medium questions can be as twisted as you want since they come close to that 100k salary, if you can solve them"
                    },
                    {
                        "username": "zkerner1",
                        "content": "why is their such an insistence - across leetcode - of giving trivial test cases. frankly I find this infuriating. Each problem should come with 3 - 4 non-trivial test cases."
                    },
                    {
                        "username": "fancypantsbob",
                        "content": "How could the average case be O(log(n))? Since the solution maintains an output list of each value from each node it should always be O(n) shouldn\\'t it?"
                    },
                    {
                        "username": "cannellajs2",
                        "content": "Oddly if I don\\'t make any modifications to my solution and repeatedly submit the memory usage will change while the speed remains the same. Maybe different test conditions on each submission?"
                    },
                    {
                        "username": "GeraldRyan",
                        "content": "I learned what Inorder traversal is, but how do they map an array/list into a tree? It doesn\\'t seem from the graphic representation that it\\'s doing an in-order or it would hit the node in the middle after hitting the leftmost. I-e. 123 not 132"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Is it just me or is an iterative inorder traversal algorithm substantially harder than an iterative preorder traversal?\\n\\nI was hoping I could find a template, like you get for recursive solutions, to do dfs + stack. However, this doesnt seem like the case. Am I right?"
                    },
                    {
                        "username": "bashyal",
                        "content": "whoever wrote these testcases can go ft"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "Easiest C++ solution ::\\n\\nvoid solution(TreeNode*root,vector<int>&v){\\n    if(root==NULL)\\n    return ;\\n    solution(root->left,v);\\n    v.push_back(root->val);\\n    solution(root->right,v);\\n}\\n    vector<int> inorderTraversal(TreeNode* root) {\\n       vector<int>v;\\n       solution(root,v);\\n       return v;\\n\\n        \\n    }"
                    },
                    {
                        "username": "peregudov",
                        "content": "Am I the only one who finds example tree confusing? Why is 3 on the left side of the 2. 3>2, shouldn\\'t 3 be on the right of 2?"
                    },
                    {
                        "username": "0x49D1",
                        "content": "I have not studied programming in the university, so the description of the problem was not enough for me. Took some time to find the explanation elsewhere and applied the recursive traversal solution after that. I think that would have been beneficial for the problem to add more wide explanation for people without specific background, because this is not \"rocket science\", but from 1 sentence it was not clear, sorry.   "
                    }
                ]
            },
            {
                "id": 2007717,
                "content": [
                    {
                        "username": "lucasan2300",
                        "content": "in the example 1:\\nthe array for Input: root = [1,null,2,3]\\nis wrong or not well defined\\n\\nIts supposed that is by levels\\nthen the precise and correct input.root is:\\n[1,null,2, null, null, 3]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This challenge is a good opportunity to practice recursive calls and understand binary trees."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I have solved this problem in Python, Typescript and C++ using stack. Every time I visit it, it feels like a new problem."
                    },
                    {
                        "username": "THINKIT",
                        "content": "vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        TreeNode *curr=root;\\n        while(curr!=NULL)\\n        {\\n            //1st case\\n            if(curr->left==NULL)\\n            {\\n                v.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode *node=curr->left;\\n                //second case go to right most node then make thread to current node \\n                // if it not already made\\n                while(node->right && node->right!=curr)\\n                node=node->right;\\n               //make thread\\n                if(node->right==NULL)\\n                {\\n                    node->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    //remove thread;\\n                    node->right=NULL;\\n                    v.push_back(curr->val);\\n                    curr=curr->right;\\n                }    \\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "i don\\'t understand.. i know binary trees so well but how am i supposed to assign an array (root = [1,null,2,3] )  to a TreeNode? \\n i expected more attention to be put in the question description when it is marked as \"easy\"..."
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "You wont get array as input. you will the root node you need to return the inorder traversal in form of array."
                    },
                    {
                        "username": "thewickeffect",
                        "content": "I think that the diagram in example one misrepresents how a binary tree works. the node with .val of 3 should be to the right of the second node. "
                    },
                    {
                        "username": "drgIv",
                        "content": "Oh,this examples la classic usles"
                    },
                    {
                        "username": "peterroth124",
                        "content": "If this is meant to test our coding/problem solving ability it should tell us what inorder traversal is. I looked it up: \\nleft node, node, right node: so the the farthest down to the left will be the first in the result list."
                    },
                    {
                        "username": "leonid-lovsky",
                        "content": "Testcase:\\nInput: root = [6,2,7,1,4,null,9,null,null,3,5,8]\\nOutput: [1,2,3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n` class Solution(object):\n\n    def inorderTraversal(self, root):\n        results = []\n        def traverse(root):\n            if root.left is not None:\n                traverse(root.left)\n            results.append(root.val)\n            if root.right is not None:\n                traverse(root.right)\n        traverse(root)\n        return results`\n\nI get \"NoneType\" object has no attribute \"left\". Why?\n"
                    }
                ]
            },
            {
                "id": 1997329,
                "content": [
                    {
                        "username": "lucasan2300",
                        "content": "in the example 1:\\nthe array for Input: root = [1,null,2,3]\\nis wrong or not well defined\\n\\nIts supposed that is by levels\\nthen the precise and correct input.root is:\\n[1,null,2, null, null, 3]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This challenge is a good opportunity to practice recursive calls and understand binary trees."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I have solved this problem in Python, Typescript and C++ using stack. Every time I visit it, it feels like a new problem."
                    },
                    {
                        "username": "THINKIT",
                        "content": "vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        TreeNode *curr=root;\\n        while(curr!=NULL)\\n        {\\n            //1st case\\n            if(curr->left==NULL)\\n            {\\n                v.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode *node=curr->left;\\n                //second case go to right most node then make thread to current node \\n                // if it not already made\\n                while(node->right && node->right!=curr)\\n                node=node->right;\\n               //make thread\\n                if(node->right==NULL)\\n                {\\n                    node->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    //remove thread;\\n                    node->right=NULL;\\n                    v.push_back(curr->val);\\n                    curr=curr->right;\\n                }    \\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "i don\\'t understand.. i know binary trees so well but how am i supposed to assign an array (root = [1,null,2,3] )  to a TreeNode? \\n i expected more attention to be put in the question description when it is marked as \"easy\"..."
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "You wont get array as input. you will the root node you need to return the inorder traversal in form of array."
                    },
                    {
                        "username": "thewickeffect",
                        "content": "I think that the diagram in example one misrepresents how a binary tree works. the node with .val of 3 should be to the right of the second node. "
                    },
                    {
                        "username": "drgIv",
                        "content": "Oh,this examples la classic usles"
                    },
                    {
                        "username": "peterroth124",
                        "content": "If this is meant to test our coding/problem solving ability it should tell us what inorder traversal is. I looked it up: \\nleft node, node, right node: so the the farthest down to the left will be the first in the result list."
                    },
                    {
                        "username": "leonid-lovsky",
                        "content": "Testcase:\\nInput: root = [6,2,7,1,4,null,9,null,null,3,5,8]\\nOutput: [1,2,3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n` class Solution(object):\n\n    def inorderTraversal(self, root):\n        results = []\n        def traverse(root):\n            if root.left is not None:\n                traverse(root.left)\n            results.append(root.val)\n            if root.right is not None:\n                traverse(root.right)\n        traverse(root)\n        return results`\n\nI get \"NoneType\" object has no attribute \"left\". Why?\n"
                    }
                ]
            },
            {
                "id": 1977346,
                "content": [
                    {
                        "username": "lucasan2300",
                        "content": "in the example 1:\\nthe array for Input: root = [1,null,2,3]\\nis wrong or not well defined\\n\\nIts supposed that is by levels\\nthen the precise and correct input.root is:\\n[1,null,2, null, null, 3]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This challenge is a good opportunity to practice recursive calls and understand binary trees."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I have solved this problem in Python, Typescript and C++ using stack. Every time I visit it, it feels like a new problem."
                    },
                    {
                        "username": "THINKIT",
                        "content": "vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        TreeNode *curr=root;\\n        while(curr!=NULL)\\n        {\\n            //1st case\\n            if(curr->left==NULL)\\n            {\\n                v.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode *node=curr->left;\\n                //second case go to right most node then make thread to current node \\n                // if it not already made\\n                while(node->right && node->right!=curr)\\n                node=node->right;\\n               //make thread\\n                if(node->right==NULL)\\n                {\\n                    node->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    //remove thread;\\n                    node->right=NULL;\\n                    v.push_back(curr->val);\\n                    curr=curr->right;\\n                }    \\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "i don\\'t understand.. i know binary trees so well but how am i supposed to assign an array (root = [1,null,2,3] )  to a TreeNode? \\n i expected more attention to be put in the question description when it is marked as \"easy\"..."
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "You wont get array as input. you will the root node you need to return the inorder traversal in form of array."
                    },
                    {
                        "username": "thewickeffect",
                        "content": "I think that the diagram in example one misrepresents how a binary tree works. the node with .val of 3 should be to the right of the second node. "
                    },
                    {
                        "username": "drgIv",
                        "content": "Oh,this examples la classic usles"
                    },
                    {
                        "username": "peterroth124",
                        "content": "If this is meant to test our coding/problem solving ability it should tell us what inorder traversal is. I looked it up: \\nleft node, node, right node: so the the farthest down to the left will be the first in the result list."
                    },
                    {
                        "username": "leonid-lovsky",
                        "content": "Testcase:\\nInput: root = [6,2,7,1,4,null,9,null,null,3,5,8]\\nOutput: [1,2,3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n` class Solution(object):\n\n    def inorderTraversal(self, root):\n        results = []\n        def traverse(root):\n            if root.left is not None:\n                traverse(root.left)\n            results.append(root.val)\n            if root.right is not None:\n                traverse(root.right)\n        traverse(root)\n        return results`\n\nI get \"NoneType\" object has no attribute \"left\". Why?\n"
                    }
                ]
            },
            {
                "id": 1940711,
                "content": [
                    {
                        "username": "lucasan2300",
                        "content": "in the example 1:\\nthe array for Input: root = [1,null,2,3]\\nis wrong or not well defined\\n\\nIts supposed that is by levels\\nthen the precise and correct input.root is:\\n[1,null,2, null, null, 3]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This challenge is a good opportunity to practice recursive calls and understand binary trees."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I have solved this problem in Python, Typescript and C++ using stack. Every time I visit it, it feels like a new problem."
                    },
                    {
                        "username": "THINKIT",
                        "content": "vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        TreeNode *curr=root;\\n        while(curr!=NULL)\\n        {\\n            //1st case\\n            if(curr->left==NULL)\\n            {\\n                v.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode *node=curr->left;\\n                //second case go to right most node then make thread to current node \\n                // if it not already made\\n                while(node->right && node->right!=curr)\\n                node=node->right;\\n               //make thread\\n                if(node->right==NULL)\\n                {\\n                    node->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    //remove thread;\\n                    node->right=NULL;\\n                    v.push_back(curr->val);\\n                    curr=curr->right;\\n                }    \\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "i don\\'t understand.. i know binary trees so well but how am i supposed to assign an array (root = [1,null,2,3] )  to a TreeNode? \\n i expected more attention to be put in the question description when it is marked as \"easy\"..."
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "You wont get array as input. you will the root node you need to return the inorder traversal in form of array."
                    },
                    {
                        "username": "thewickeffect",
                        "content": "I think that the diagram in example one misrepresents how a binary tree works. the node with .val of 3 should be to the right of the second node. "
                    },
                    {
                        "username": "drgIv",
                        "content": "Oh,this examples la classic usles"
                    },
                    {
                        "username": "peterroth124",
                        "content": "If this is meant to test our coding/problem solving ability it should tell us what inorder traversal is. I looked it up: \\nleft node, node, right node: so the the farthest down to the left will be the first in the result list."
                    },
                    {
                        "username": "leonid-lovsky",
                        "content": "Testcase:\\nInput: root = [6,2,7,1,4,null,9,null,null,3,5,8]\\nOutput: [1,2,3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n` class Solution(object):\n\n    def inorderTraversal(self, root):\n        results = []\n        def traverse(root):\n            if root.left is not None:\n                traverse(root.left)\n            results.append(root.val)\n            if root.right is not None:\n                traverse(root.right)\n        traverse(root)\n        return results`\n\nI get \"NoneType\" object has no attribute \"left\". Why?\n"
                    }
                ]
            },
            {
                "id": 1919780,
                "content": [
                    {
                        "username": "lucasan2300",
                        "content": "in the example 1:\\nthe array for Input: root = [1,null,2,3]\\nis wrong or not well defined\\n\\nIts supposed that is by levels\\nthen the precise and correct input.root is:\\n[1,null,2, null, null, 3]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This challenge is a good opportunity to practice recursive calls and understand binary trees."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I have solved this problem in Python, Typescript and C++ using stack. Every time I visit it, it feels like a new problem."
                    },
                    {
                        "username": "THINKIT",
                        "content": "vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        TreeNode *curr=root;\\n        while(curr!=NULL)\\n        {\\n            //1st case\\n            if(curr->left==NULL)\\n            {\\n                v.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode *node=curr->left;\\n                //second case go to right most node then make thread to current node \\n                // if it not already made\\n                while(node->right && node->right!=curr)\\n                node=node->right;\\n               //make thread\\n                if(node->right==NULL)\\n                {\\n                    node->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    //remove thread;\\n                    node->right=NULL;\\n                    v.push_back(curr->val);\\n                    curr=curr->right;\\n                }    \\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "i don\\'t understand.. i know binary trees so well but how am i supposed to assign an array (root = [1,null,2,3] )  to a TreeNode? \\n i expected more attention to be put in the question description when it is marked as \"easy\"..."
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "You wont get array as input. you will the root node you need to return the inorder traversal in form of array."
                    },
                    {
                        "username": "thewickeffect",
                        "content": "I think that the diagram in example one misrepresents how a binary tree works. the node with .val of 3 should be to the right of the second node. "
                    },
                    {
                        "username": "drgIv",
                        "content": "Oh,this examples la classic usles"
                    },
                    {
                        "username": "peterroth124",
                        "content": "If this is meant to test our coding/problem solving ability it should tell us what inorder traversal is. I looked it up: \\nleft node, node, right node: so the the farthest down to the left will be the first in the result list."
                    },
                    {
                        "username": "leonid-lovsky",
                        "content": "Testcase:\\nInput: root = [6,2,7,1,4,null,9,null,null,3,5,8]\\nOutput: [1,2,3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n` class Solution(object):\n\n    def inorderTraversal(self, root):\n        results = []\n        def traverse(root):\n            if root.left is not None:\n                traverse(root.left)\n            results.append(root.val)\n            if root.right is not None:\n                traverse(root.right)\n        traverse(root)\n        return results`\n\nI get \"NoneType\" object has no attribute \"left\". Why?\n"
                    }
                ]
            },
            {
                "id": 1886680,
                "content": [
                    {
                        "username": "lucasan2300",
                        "content": "in the example 1:\\nthe array for Input: root = [1,null,2,3]\\nis wrong or not well defined\\n\\nIts supposed that is by levels\\nthen the precise and correct input.root is:\\n[1,null,2, null, null, 3]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This challenge is a good opportunity to practice recursive calls and understand binary trees."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I have solved this problem in Python, Typescript and C++ using stack. Every time I visit it, it feels like a new problem."
                    },
                    {
                        "username": "THINKIT",
                        "content": "vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        TreeNode *curr=root;\\n        while(curr!=NULL)\\n        {\\n            //1st case\\n            if(curr->left==NULL)\\n            {\\n                v.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode *node=curr->left;\\n                //second case go to right most node then make thread to current node \\n                // if it not already made\\n                while(node->right && node->right!=curr)\\n                node=node->right;\\n               //make thread\\n                if(node->right==NULL)\\n                {\\n                    node->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    //remove thread;\\n                    node->right=NULL;\\n                    v.push_back(curr->val);\\n                    curr=curr->right;\\n                }    \\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "i don\\'t understand.. i know binary trees so well but how am i supposed to assign an array (root = [1,null,2,3] )  to a TreeNode? \\n i expected more attention to be put in the question description when it is marked as \"easy\"..."
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "You wont get array as input. you will the root node you need to return the inorder traversal in form of array."
                    },
                    {
                        "username": "thewickeffect",
                        "content": "I think that the diagram in example one misrepresents how a binary tree works. the node with .val of 3 should be to the right of the second node. "
                    },
                    {
                        "username": "drgIv",
                        "content": "Oh,this examples la classic usles"
                    },
                    {
                        "username": "peterroth124",
                        "content": "If this is meant to test our coding/problem solving ability it should tell us what inorder traversal is. I looked it up: \\nleft node, node, right node: so the the farthest down to the left will be the first in the result list."
                    },
                    {
                        "username": "leonid-lovsky",
                        "content": "Testcase:\\nInput: root = [6,2,7,1,4,null,9,null,null,3,5,8]\\nOutput: [1,2,3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n` class Solution(object):\n\n    def inorderTraversal(self, root):\n        results = []\n        def traverse(root):\n            if root.left is not None:\n                traverse(root.left)\n            results.append(root.val)\n            if root.right is not None:\n                traverse(root.right)\n        traverse(root)\n        return results`\n\nI get \"NoneType\" object has no attribute \"left\". Why?\n"
                    }
                ]
            },
            {
                "id": 1879007,
                "content": [
                    {
                        "username": "lucasan2300",
                        "content": "in the example 1:\\nthe array for Input: root = [1,null,2,3]\\nis wrong or not well defined\\n\\nIts supposed that is by levels\\nthen the precise and correct input.root is:\\n[1,null,2, null, null, 3]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This challenge is a good opportunity to practice recursive calls and understand binary trees."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I have solved this problem in Python, Typescript and C++ using stack. Every time I visit it, it feels like a new problem."
                    },
                    {
                        "username": "THINKIT",
                        "content": "vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        TreeNode *curr=root;\\n        while(curr!=NULL)\\n        {\\n            //1st case\\n            if(curr->left==NULL)\\n            {\\n                v.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode *node=curr->left;\\n                //second case go to right most node then make thread to current node \\n                // if it not already made\\n                while(node->right && node->right!=curr)\\n                node=node->right;\\n               //make thread\\n                if(node->right==NULL)\\n                {\\n                    node->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    //remove thread;\\n                    node->right=NULL;\\n                    v.push_back(curr->val);\\n                    curr=curr->right;\\n                }    \\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "i don\\'t understand.. i know binary trees so well but how am i supposed to assign an array (root = [1,null,2,3] )  to a TreeNode? \\n i expected more attention to be put in the question description when it is marked as \"easy\"..."
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "You wont get array as input. you will the root node you need to return the inorder traversal in form of array."
                    },
                    {
                        "username": "thewickeffect",
                        "content": "I think that the diagram in example one misrepresents how a binary tree works. the node with .val of 3 should be to the right of the second node. "
                    },
                    {
                        "username": "drgIv",
                        "content": "Oh,this examples la classic usles"
                    },
                    {
                        "username": "peterroth124",
                        "content": "If this is meant to test our coding/problem solving ability it should tell us what inorder traversal is. I looked it up: \\nleft node, node, right node: so the the farthest down to the left will be the first in the result list."
                    },
                    {
                        "username": "leonid-lovsky",
                        "content": "Testcase:\\nInput: root = [6,2,7,1,4,null,9,null,null,3,5,8]\\nOutput: [1,2,3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n` class Solution(object):\n\n    def inorderTraversal(self, root):\n        results = []\n        def traverse(root):\n            if root.left is not None:\n                traverse(root.left)\n            results.append(root.val)\n            if root.right is not None:\n                traverse(root.right)\n        traverse(root)\n        return results`\n\nI get \"NoneType\" object has no attribute \"left\". Why?\n"
                    }
                ]
            },
            {
                "id": 1873868,
                "content": [
                    {
                        "username": "lucasan2300",
                        "content": "in the example 1:\\nthe array for Input: root = [1,null,2,3]\\nis wrong or not well defined\\n\\nIts supposed that is by levels\\nthen the precise and correct input.root is:\\n[1,null,2, null, null, 3]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This challenge is a good opportunity to practice recursive calls and understand binary trees."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I have solved this problem in Python, Typescript and C++ using stack. Every time I visit it, it feels like a new problem."
                    },
                    {
                        "username": "THINKIT",
                        "content": "vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        TreeNode *curr=root;\\n        while(curr!=NULL)\\n        {\\n            //1st case\\n            if(curr->left==NULL)\\n            {\\n                v.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode *node=curr->left;\\n                //second case go to right most node then make thread to current node \\n                // if it not already made\\n                while(node->right && node->right!=curr)\\n                node=node->right;\\n               //make thread\\n                if(node->right==NULL)\\n                {\\n                    node->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    //remove thread;\\n                    node->right=NULL;\\n                    v.push_back(curr->val);\\n                    curr=curr->right;\\n                }    \\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "i don\\'t understand.. i know binary trees so well but how am i supposed to assign an array (root = [1,null,2,3] )  to a TreeNode? \\n i expected more attention to be put in the question description when it is marked as \"easy\"..."
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "You wont get array as input. you will the root node you need to return the inorder traversal in form of array."
                    },
                    {
                        "username": "thewickeffect",
                        "content": "I think that the diagram in example one misrepresents how a binary tree works. the node with .val of 3 should be to the right of the second node. "
                    },
                    {
                        "username": "drgIv",
                        "content": "Oh,this examples la classic usles"
                    },
                    {
                        "username": "peterroth124",
                        "content": "If this is meant to test our coding/problem solving ability it should tell us what inorder traversal is. I looked it up: \\nleft node, node, right node: so the the farthest down to the left will be the first in the result list."
                    },
                    {
                        "username": "leonid-lovsky",
                        "content": "Testcase:\\nInput: root = [6,2,7,1,4,null,9,null,null,3,5,8]\\nOutput: [1,2,3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n` class Solution(object):\n\n    def inorderTraversal(self, root):\n        results = []\n        def traverse(root):\n            if root.left is not None:\n                traverse(root.left)\n            results.append(root.val)\n            if root.right is not None:\n                traverse(root.right)\n        traverse(root)\n        return results`\n\nI get \"NoneType\" object has no attribute \"left\". Why?\n"
                    }
                ]
            },
            {
                "id": 1863953,
                "content": [
                    {
                        "username": "lucasan2300",
                        "content": "in the example 1:\\nthe array for Input: root = [1,null,2,3]\\nis wrong or not well defined\\n\\nIts supposed that is by levels\\nthen the precise and correct input.root is:\\n[1,null,2, null, null, 3]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This challenge is a good opportunity to practice recursive calls and understand binary trees."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I have solved this problem in Python, Typescript and C++ using stack. Every time I visit it, it feels like a new problem."
                    },
                    {
                        "username": "THINKIT",
                        "content": "vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        TreeNode *curr=root;\\n        while(curr!=NULL)\\n        {\\n            //1st case\\n            if(curr->left==NULL)\\n            {\\n                v.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode *node=curr->left;\\n                //second case go to right most node then make thread to current node \\n                // if it not already made\\n                while(node->right && node->right!=curr)\\n                node=node->right;\\n               //make thread\\n                if(node->right==NULL)\\n                {\\n                    node->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    //remove thread;\\n                    node->right=NULL;\\n                    v.push_back(curr->val);\\n                    curr=curr->right;\\n                }    \\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "i don\\'t understand.. i know binary trees so well but how am i supposed to assign an array (root = [1,null,2,3] )  to a TreeNode? \\n i expected more attention to be put in the question description when it is marked as \"easy\"..."
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "You wont get array as input. you will the root node you need to return the inorder traversal in form of array."
                    },
                    {
                        "username": "thewickeffect",
                        "content": "I think that the diagram in example one misrepresents how a binary tree works. the node with .val of 3 should be to the right of the second node. "
                    },
                    {
                        "username": "drgIv",
                        "content": "Oh,this examples la classic usles"
                    },
                    {
                        "username": "peterroth124",
                        "content": "If this is meant to test our coding/problem solving ability it should tell us what inorder traversal is. I looked it up: \\nleft node, node, right node: so the the farthest down to the left will be the first in the result list."
                    },
                    {
                        "username": "leonid-lovsky",
                        "content": "Testcase:\\nInput: root = [6,2,7,1,4,null,9,null,null,3,5,8]\\nOutput: [1,2,3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n` class Solution(object):\n\n    def inorderTraversal(self, root):\n        results = []\n        def traverse(root):\n            if root.left is not None:\n                traverse(root.left)\n            results.append(root.val)\n            if root.right is not None:\n                traverse(root.right)\n        traverse(root)\n        return results`\n\nI get \"NoneType\" object has no attribute \"left\". Why?\n"
                    }
                ]
            },
            {
                "id": 1833518,
                "content": [
                    {
                        "username": "lucasan2300",
                        "content": "in the example 1:\\nthe array for Input: root = [1,null,2,3]\\nis wrong or not well defined\\n\\nIts supposed that is by levels\\nthen the precise and correct input.root is:\\n[1,null,2, null, null, 3]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This challenge is a good opportunity to practice recursive calls and understand binary trees."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I have solved this problem in Python, Typescript and C++ using stack. Every time I visit it, it feels like a new problem."
                    },
                    {
                        "username": "THINKIT",
                        "content": "vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        TreeNode *curr=root;\\n        while(curr!=NULL)\\n        {\\n            //1st case\\n            if(curr->left==NULL)\\n            {\\n                v.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode *node=curr->left;\\n                //second case go to right most node then make thread to current node \\n                // if it not already made\\n                while(node->right && node->right!=curr)\\n                node=node->right;\\n               //make thread\\n                if(node->right==NULL)\\n                {\\n                    node->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    //remove thread;\\n                    node->right=NULL;\\n                    v.push_back(curr->val);\\n                    curr=curr->right;\\n                }    \\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "i don\\'t understand.. i know binary trees so well but how am i supposed to assign an array (root = [1,null,2,3] )  to a TreeNode? \\n i expected more attention to be put in the question description when it is marked as \"easy\"..."
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "You wont get array as input. you will the root node you need to return the inorder traversal in form of array."
                    },
                    {
                        "username": "thewickeffect",
                        "content": "I think that the diagram in example one misrepresents how a binary tree works. the node with .val of 3 should be to the right of the second node. "
                    },
                    {
                        "username": "drgIv",
                        "content": "Oh,this examples la classic usles"
                    },
                    {
                        "username": "peterroth124",
                        "content": "If this is meant to test our coding/problem solving ability it should tell us what inorder traversal is. I looked it up: \\nleft node, node, right node: so the the farthest down to the left will be the first in the result list."
                    },
                    {
                        "username": "leonid-lovsky",
                        "content": "Testcase:\\nInput: root = [6,2,7,1,4,null,9,null,null,3,5,8]\\nOutput: [1,2,3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n` class Solution(object):\n\n    def inorderTraversal(self, root):\n        results = []\n        def traverse(root):\n            if root.left is not None:\n                traverse(root.left)\n            results.append(root.val)\n            if root.right is not None:\n                traverse(root.right)\n        traverse(root)\n        return results`\n\nI get \"NoneType\" object has no attribute \"left\". Why?\n"
                    }
                ]
            },
            {
                "id": 1799574,
                "content": [
                    {
                        "username": "abhiabhishek9347",
                        "content": "What\\'s wrong on this?\\nWhy can\\'t we create List in function.\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        private List<Integer> l = new ArrayList<>();\\n        if(root!=NULL)\\n        {\\n            inorderTraversal(root.left);\\n            l.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return l;\\n    }"
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "Traversal is one of the first topic you start with for TREE data structure, which is very easy considering recursion . Here I would like to focus on Morris Inorder Traversal.\n      \n    `vector<int> inorderTraversal(TreeNode* root) {\n\n        vector<int> ans;\n        \n        while(root != NULL){\n                    if(root->left == NULL){\n                        ans.push_back(root->val);\n                        root= root->right;\n                    }\n                    else{\n                        TreeNode* temp = root;\n                        temp= temp->left;\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                         if(temp->right == NULL){\n                         temp->right = root;\n                         root= root->left;\n                         }\n                         else {\n                         temp->right = NULL;\n                         ans.push_back(root->val);\n                         root= root->right;\n                         }\n        }.  return ans;    }`\n\nWhat are we doing we are using iterative method without stack. Now, benifits is time is slightly more than O(n) but can be compared to O(n*h) only in general terms{h is height of binary tree) . Talking of space complexity it is O(1)\n\nWe are making the rightmost node in left subtree to point the root "
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<Integer> inorderTraversal(TreeNode root) {\\n List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n        return result;\\n    }\\n    private void inorderTraversal(TreeNode root, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, result);\\n        result.add(root.val);\\n        inorderTraversal(root.right, result);\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/94_binary_tree_inorder_treversal.cpp"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tips:\\nInorder Traversal \\n(Left Root Right)"
                    },
                    {
                        "username": "Voralagas",
                        "content": "why is [1,null,2,3] expecting [1, 3, 2] should not it be [1, 3, 2] ?\\n"
                    },
                    {
                        "username": "TobyLeet",
                        "content": "because it is expecting the left most result first, not necessarily the smallest number. Imagine you are reaching the leftmost pointing branch first, working your way to the rightmost facing branch. So technically the parent node is to the right of the left child node, and to the left of it\\'s right child node."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Why the tree in the Example 1 is described as Input: root = [1,null,2,3]?\nShouldn't it be like this:\nInput: root = [1,null,2, null, null, 3] ? (as it is shown in internet resourses about binary tree array representation)\nAnd how can we traverse the tree if 2k, 2k + 1 formulas doesn't work?\nPlease, help me with this."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Got it. After debugging, actual representation of root for [1, null, 2, 3] is:\\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\\nSo, this object passed in inorderTraversal function as the argument, not the array."
                    },
                    {
                        "username": "noneal",
                        "content": "What is returnSize supposed to be? I assumed that if I dereferenced it, I would get the size of the array to be returned, but I got -1"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-inorder-traversal-leet-code-94/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to perform an inorder traversal of a binary tree in Swift is O(n), where n is the number of nodes in the tree. This is because the function visits each node exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores the recursive calls on the call stack. The space complexity is not affected by the structure of the tree, only by the number of nodes.\\n\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion. In the worst case, when the tree is a linked list, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    }
                ]
            },
            {
                "id": 1783048,
                "content": [
                    {
                        "username": "abhiabhishek9347",
                        "content": "What\\'s wrong on this?\\nWhy can\\'t we create List in function.\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        private List<Integer> l = new ArrayList<>();\\n        if(root!=NULL)\\n        {\\n            inorderTraversal(root.left);\\n            l.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return l;\\n    }"
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "Traversal is one of the first topic you start with for TREE data structure, which is very easy considering recursion . Here I would like to focus on Morris Inorder Traversal.\n      \n    `vector<int> inorderTraversal(TreeNode* root) {\n\n        vector<int> ans;\n        \n        while(root != NULL){\n                    if(root->left == NULL){\n                        ans.push_back(root->val);\n                        root= root->right;\n                    }\n                    else{\n                        TreeNode* temp = root;\n                        temp= temp->left;\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                         if(temp->right == NULL){\n                         temp->right = root;\n                         root= root->left;\n                         }\n                         else {\n                         temp->right = NULL;\n                         ans.push_back(root->val);\n                         root= root->right;\n                         }\n        }.  return ans;    }`\n\nWhat are we doing we are using iterative method without stack. Now, benifits is time is slightly more than O(n) but can be compared to O(n*h) only in general terms{h is height of binary tree) . Talking of space complexity it is O(1)\n\nWe are making the rightmost node in left subtree to point the root "
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<Integer> inorderTraversal(TreeNode root) {\\n List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n        return result;\\n    }\\n    private void inorderTraversal(TreeNode root, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, result);\\n        result.add(root.val);\\n        inorderTraversal(root.right, result);\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/94_binary_tree_inorder_treversal.cpp"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tips:\\nInorder Traversal \\n(Left Root Right)"
                    },
                    {
                        "username": "Voralagas",
                        "content": "why is [1,null,2,3] expecting [1, 3, 2] should not it be [1, 3, 2] ?\\n"
                    },
                    {
                        "username": "TobyLeet",
                        "content": "because it is expecting the left most result first, not necessarily the smallest number. Imagine you are reaching the leftmost pointing branch first, working your way to the rightmost facing branch. So technically the parent node is to the right of the left child node, and to the left of it\\'s right child node."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Why the tree in the Example 1 is described as Input: root = [1,null,2,3]?\nShouldn't it be like this:\nInput: root = [1,null,2, null, null, 3] ? (as it is shown in internet resourses about binary tree array representation)\nAnd how can we traverse the tree if 2k, 2k + 1 formulas doesn't work?\nPlease, help me with this."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Got it. After debugging, actual representation of root for [1, null, 2, 3] is:\\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\\nSo, this object passed in inorderTraversal function as the argument, not the array."
                    },
                    {
                        "username": "noneal",
                        "content": "What is returnSize supposed to be? I assumed that if I dereferenced it, I would get the size of the array to be returned, but I got -1"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-inorder-traversal-leet-code-94/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to perform an inorder traversal of a binary tree in Swift is O(n), where n is the number of nodes in the tree. This is because the function visits each node exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores the recursive calls on the call stack. The space complexity is not affected by the structure of the tree, only by the number of nodes.\\n\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion. In the worst case, when the tree is a linked list, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    }
                ]
            },
            {
                "id": 1767924,
                "content": [
                    {
                        "username": "abhiabhishek9347",
                        "content": "What\\'s wrong on this?\\nWhy can\\'t we create List in function.\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        private List<Integer> l = new ArrayList<>();\\n        if(root!=NULL)\\n        {\\n            inorderTraversal(root.left);\\n            l.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return l;\\n    }"
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "Traversal is one of the first topic you start with for TREE data structure, which is very easy considering recursion . Here I would like to focus on Morris Inorder Traversal.\n      \n    `vector<int> inorderTraversal(TreeNode* root) {\n\n        vector<int> ans;\n        \n        while(root != NULL){\n                    if(root->left == NULL){\n                        ans.push_back(root->val);\n                        root= root->right;\n                    }\n                    else{\n                        TreeNode* temp = root;\n                        temp= temp->left;\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                         if(temp->right == NULL){\n                         temp->right = root;\n                         root= root->left;\n                         }\n                         else {\n                         temp->right = NULL;\n                         ans.push_back(root->val);\n                         root= root->right;\n                         }\n        }.  return ans;    }`\n\nWhat are we doing we are using iterative method without stack. Now, benifits is time is slightly more than O(n) but can be compared to O(n*h) only in general terms{h is height of binary tree) . Talking of space complexity it is O(1)\n\nWe are making the rightmost node in left subtree to point the root "
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<Integer> inorderTraversal(TreeNode root) {\\n List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n        return result;\\n    }\\n    private void inorderTraversal(TreeNode root, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, result);\\n        result.add(root.val);\\n        inorderTraversal(root.right, result);\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/94_binary_tree_inorder_treversal.cpp"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tips:\\nInorder Traversal \\n(Left Root Right)"
                    },
                    {
                        "username": "Voralagas",
                        "content": "why is [1,null,2,3] expecting [1, 3, 2] should not it be [1, 3, 2] ?\\n"
                    },
                    {
                        "username": "TobyLeet",
                        "content": "because it is expecting the left most result first, not necessarily the smallest number. Imagine you are reaching the leftmost pointing branch first, working your way to the rightmost facing branch. So technically the parent node is to the right of the left child node, and to the left of it\\'s right child node."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Why the tree in the Example 1 is described as Input: root = [1,null,2,3]?\nShouldn't it be like this:\nInput: root = [1,null,2, null, null, 3] ? (as it is shown in internet resourses about binary tree array representation)\nAnd how can we traverse the tree if 2k, 2k + 1 formulas doesn't work?\nPlease, help me with this."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Got it. After debugging, actual representation of root for [1, null, 2, 3] is:\\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\\nSo, this object passed in inorderTraversal function as the argument, not the array."
                    },
                    {
                        "username": "noneal",
                        "content": "What is returnSize supposed to be? I assumed that if I dereferenced it, I would get the size of the array to be returned, but I got -1"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-inorder-traversal-leet-code-94/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to perform an inorder traversal of a binary tree in Swift is O(n), where n is the number of nodes in the tree. This is because the function visits each node exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores the recursive calls on the call stack. The space complexity is not affected by the structure of the tree, only by the number of nodes.\\n\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion. In the worst case, when the tree is a linked list, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    }
                ]
            },
            {
                "id": 1767523,
                "content": [
                    {
                        "username": "abhiabhishek9347",
                        "content": "What\\'s wrong on this?\\nWhy can\\'t we create List in function.\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        private List<Integer> l = new ArrayList<>();\\n        if(root!=NULL)\\n        {\\n            inorderTraversal(root.left);\\n            l.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return l;\\n    }"
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "Traversal is one of the first topic you start with for TREE data structure, which is very easy considering recursion . Here I would like to focus on Morris Inorder Traversal.\n      \n    `vector<int> inorderTraversal(TreeNode* root) {\n\n        vector<int> ans;\n        \n        while(root != NULL){\n                    if(root->left == NULL){\n                        ans.push_back(root->val);\n                        root= root->right;\n                    }\n                    else{\n                        TreeNode* temp = root;\n                        temp= temp->left;\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                         if(temp->right == NULL){\n                         temp->right = root;\n                         root= root->left;\n                         }\n                         else {\n                         temp->right = NULL;\n                         ans.push_back(root->val);\n                         root= root->right;\n                         }\n        }.  return ans;    }`\n\nWhat are we doing we are using iterative method without stack. Now, benifits is time is slightly more than O(n) but can be compared to O(n*h) only in general terms{h is height of binary tree) . Talking of space complexity it is O(1)\n\nWe are making the rightmost node in left subtree to point the root "
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<Integer> inorderTraversal(TreeNode root) {\\n List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n        return result;\\n    }\\n    private void inorderTraversal(TreeNode root, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, result);\\n        result.add(root.val);\\n        inorderTraversal(root.right, result);\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/94_binary_tree_inorder_treversal.cpp"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tips:\\nInorder Traversal \\n(Left Root Right)"
                    },
                    {
                        "username": "Voralagas",
                        "content": "why is [1,null,2,3] expecting [1, 3, 2] should not it be [1, 3, 2] ?\\n"
                    },
                    {
                        "username": "TobyLeet",
                        "content": "because it is expecting the left most result first, not necessarily the smallest number. Imagine you are reaching the leftmost pointing branch first, working your way to the rightmost facing branch. So technically the parent node is to the right of the left child node, and to the left of it\\'s right child node."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Why the tree in the Example 1 is described as Input: root = [1,null,2,3]?\nShouldn't it be like this:\nInput: root = [1,null,2, null, null, 3] ? (as it is shown in internet resourses about binary tree array representation)\nAnd how can we traverse the tree if 2k, 2k + 1 formulas doesn't work?\nPlease, help me with this."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Got it. After debugging, actual representation of root for [1, null, 2, 3] is:\\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\\nSo, this object passed in inorderTraversal function as the argument, not the array."
                    },
                    {
                        "username": "noneal",
                        "content": "What is returnSize supposed to be? I assumed that if I dereferenced it, I would get the size of the array to be returned, but I got -1"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-inorder-traversal-leet-code-94/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to perform an inorder traversal of a binary tree in Swift is O(n), where n is the number of nodes in the tree. This is because the function visits each node exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores the recursive calls on the call stack. The space complexity is not affected by the structure of the tree, only by the number of nodes.\\n\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion. In the worst case, when the tree is a linked list, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    }
                ]
            },
            {
                "id": 1762359,
                "content": [
                    {
                        "username": "abhiabhishek9347",
                        "content": "What\\'s wrong on this?\\nWhy can\\'t we create List in function.\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        private List<Integer> l = new ArrayList<>();\\n        if(root!=NULL)\\n        {\\n            inorderTraversal(root.left);\\n            l.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return l;\\n    }"
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "Traversal is one of the first topic you start with for TREE data structure, which is very easy considering recursion . Here I would like to focus on Morris Inorder Traversal.\n      \n    `vector<int> inorderTraversal(TreeNode* root) {\n\n        vector<int> ans;\n        \n        while(root != NULL){\n                    if(root->left == NULL){\n                        ans.push_back(root->val);\n                        root= root->right;\n                    }\n                    else{\n                        TreeNode* temp = root;\n                        temp= temp->left;\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                         if(temp->right == NULL){\n                         temp->right = root;\n                         root= root->left;\n                         }\n                         else {\n                         temp->right = NULL;\n                         ans.push_back(root->val);\n                         root= root->right;\n                         }\n        }.  return ans;    }`\n\nWhat are we doing we are using iterative method without stack. Now, benifits is time is slightly more than O(n) but can be compared to O(n*h) only in general terms{h is height of binary tree) . Talking of space complexity it is O(1)\n\nWe are making the rightmost node in left subtree to point the root "
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<Integer> inorderTraversal(TreeNode root) {\\n List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n        return result;\\n    }\\n    private void inorderTraversal(TreeNode root, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, result);\\n        result.add(root.val);\\n        inorderTraversal(root.right, result);\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/94_binary_tree_inorder_treversal.cpp"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tips:\\nInorder Traversal \\n(Left Root Right)"
                    },
                    {
                        "username": "Voralagas",
                        "content": "why is [1,null,2,3] expecting [1, 3, 2] should not it be [1, 3, 2] ?\\n"
                    },
                    {
                        "username": "TobyLeet",
                        "content": "because it is expecting the left most result first, not necessarily the smallest number. Imagine you are reaching the leftmost pointing branch first, working your way to the rightmost facing branch. So technically the parent node is to the right of the left child node, and to the left of it\\'s right child node."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Why the tree in the Example 1 is described as Input: root = [1,null,2,3]?\nShouldn't it be like this:\nInput: root = [1,null,2, null, null, 3] ? (as it is shown in internet resourses about binary tree array representation)\nAnd how can we traverse the tree if 2k, 2k + 1 formulas doesn't work?\nPlease, help me with this."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Got it. After debugging, actual representation of root for [1, null, 2, 3] is:\\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\\nSo, this object passed in inorderTraversal function as the argument, not the array."
                    },
                    {
                        "username": "noneal",
                        "content": "What is returnSize supposed to be? I assumed that if I dereferenced it, I would get the size of the array to be returned, but I got -1"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-inorder-traversal-leet-code-94/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to perform an inorder traversal of a binary tree in Swift is O(n), where n is the number of nodes in the tree. This is because the function visits each node exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores the recursive calls on the call stack. The space complexity is not affected by the structure of the tree, only by the number of nodes.\\n\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion. In the worst case, when the tree is a linked list, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    }
                ]
            },
            {
                "id": 1758368,
                "content": [
                    {
                        "username": "abhiabhishek9347",
                        "content": "What\\'s wrong on this?\\nWhy can\\'t we create List in function.\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        private List<Integer> l = new ArrayList<>();\\n        if(root!=NULL)\\n        {\\n            inorderTraversal(root.left);\\n            l.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return l;\\n    }"
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "Traversal is one of the first topic you start with for TREE data structure, which is very easy considering recursion . Here I would like to focus on Morris Inorder Traversal.\n      \n    `vector<int> inorderTraversal(TreeNode* root) {\n\n        vector<int> ans;\n        \n        while(root != NULL){\n                    if(root->left == NULL){\n                        ans.push_back(root->val);\n                        root= root->right;\n                    }\n                    else{\n                        TreeNode* temp = root;\n                        temp= temp->left;\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                         if(temp->right == NULL){\n                         temp->right = root;\n                         root= root->left;\n                         }\n                         else {\n                         temp->right = NULL;\n                         ans.push_back(root->val);\n                         root= root->right;\n                         }\n        }.  return ans;    }`\n\nWhat are we doing we are using iterative method without stack. Now, benifits is time is slightly more than O(n) but can be compared to O(n*h) only in general terms{h is height of binary tree) . Talking of space complexity it is O(1)\n\nWe are making the rightmost node in left subtree to point the root "
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<Integer> inorderTraversal(TreeNode root) {\\n List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n        return result;\\n    }\\n    private void inorderTraversal(TreeNode root, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, result);\\n        result.add(root.val);\\n        inorderTraversal(root.right, result);\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/94_binary_tree_inorder_treversal.cpp"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tips:\\nInorder Traversal \\n(Left Root Right)"
                    },
                    {
                        "username": "Voralagas",
                        "content": "why is [1,null,2,3] expecting [1, 3, 2] should not it be [1, 3, 2] ?\\n"
                    },
                    {
                        "username": "TobyLeet",
                        "content": "because it is expecting the left most result first, not necessarily the smallest number. Imagine you are reaching the leftmost pointing branch first, working your way to the rightmost facing branch. So technically the parent node is to the right of the left child node, and to the left of it\\'s right child node."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Why the tree in the Example 1 is described as Input: root = [1,null,2,3]?\nShouldn't it be like this:\nInput: root = [1,null,2, null, null, 3] ? (as it is shown in internet resourses about binary tree array representation)\nAnd how can we traverse the tree if 2k, 2k + 1 formulas doesn't work?\nPlease, help me with this."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Got it. After debugging, actual representation of root for [1, null, 2, 3] is:\\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\\nSo, this object passed in inorderTraversal function as the argument, not the array."
                    },
                    {
                        "username": "noneal",
                        "content": "What is returnSize supposed to be? I assumed that if I dereferenced it, I would get the size of the array to be returned, but I got -1"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-inorder-traversal-leet-code-94/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to perform an inorder traversal of a binary tree in Swift is O(n), where n is the number of nodes in the tree. This is because the function visits each node exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores the recursive calls on the call stack. The space complexity is not affected by the structure of the tree, only by the number of nodes.\\n\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion. In the worst case, when the tree is a linked list, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    }
                ]
            },
            {
                "id": 1757633,
                "content": [
                    {
                        "username": "abhiabhishek9347",
                        "content": "What\\'s wrong on this?\\nWhy can\\'t we create List in function.\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        private List<Integer> l = new ArrayList<>();\\n        if(root!=NULL)\\n        {\\n            inorderTraversal(root.left);\\n            l.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return l;\\n    }"
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "Traversal is one of the first topic you start with for TREE data structure, which is very easy considering recursion . Here I would like to focus on Morris Inorder Traversal.\n      \n    `vector<int> inorderTraversal(TreeNode* root) {\n\n        vector<int> ans;\n        \n        while(root != NULL){\n                    if(root->left == NULL){\n                        ans.push_back(root->val);\n                        root= root->right;\n                    }\n                    else{\n                        TreeNode* temp = root;\n                        temp= temp->left;\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                         if(temp->right == NULL){\n                         temp->right = root;\n                         root= root->left;\n                         }\n                         else {\n                         temp->right = NULL;\n                         ans.push_back(root->val);\n                         root= root->right;\n                         }\n        }.  return ans;    }`\n\nWhat are we doing we are using iterative method without stack. Now, benifits is time is slightly more than O(n) but can be compared to O(n*h) only in general terms{h is height of binary tree) . Talking of space complexity it is O(1)\n\nWe are making the rightmost node in left subtree to point the root "
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<Integer> inorderTraversal(TreeNode root) {\\n List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n        return result;\\n    }\\n    private void inorderTraversal(TreeNode root, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, result);\\n        result.add(root.val);\\n        inorderTraversal(root.right, result);\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/94_binary_tree_inorder_treversal.cpp"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tips:\\nInorder Traversal \\n(Left Root Right)"
                    },
                    {
                        "username": "Voralagas",
                        "content": "why is [1,null,2,3] expecting [1, 3, 2] should not it be [1, 3, 2] ?\\n"
                    },
                    {
                        "username": "TobyLeet",
                        "content": "because it is expecting the left most result first, not necessarily the smallest number. Imagine you are reaching the leftmost pointing branch first, working your way to the rightmost facing branch. So technically the parent node is to the right of the left child node, and to the left of it\\'s right child node."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Why the tree in the Example 1 is described as Input: root = [1,null,2,3]?\nShouldn't it be like this:\nInput: root = [1,null,2, null, null, 3] ? (as it is shown in internet resourses about binary tree array representation)\nAnd how can we traverse the tree if 2k, 2k + 1 formulas doesn't work?\nPlease, help me with this."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Got it. After debugging, actual representation of root for [1, null, 2, 3] is:\\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\\nSo, this object passed in inorderTraversal function as the argument, not the array."
                    },
                    {
                        "username": "noneal",
                        "content": "What is returnSize supposed to be? I assumed that if I dereferenced it, I would get the size of the array to be returned, but I got -1"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-inorder-traversal-leet-code-94/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to perform an inorder traversal of a binary tree in Swift is O(n), where n is the number of nodes in the tree. This is because the function visits each node exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores the recursive calls on the call stack. The space complexity is not affected by the structure of the tree, only by the number of nodes.\\n\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion. In the worst case, when the tree is a linked list, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    }
                ]
            },
            {
                "id": 1739648,
                "content": [
                    {
                        "username": "abhiabhishek9347",
                        "content": "What\\'s wrong on this?\\nWhy can\\'t we create List in function.\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        private List<Integer> l = new ArrayList<>();\\n        if(root!=NULL)\\n        {\\n            inorderTraversal(root.left);\\n            l.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return l;\\n    }"
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "Traversal is one of the first topic you start with for TREE data structure, which is very easy considering recursion . Here I would like to focus on Morris Inorder Traversal.\n      \n    `vector<int> inorderTraversal(TreeNode* root) {\n\n        vector<int> ans;\n        \n        while(root != NULL){\n                    if(root->left == NULL){\n                        ans.push_back(root->val);\n                        root= root->right;\n                    }\n                    else{\n                        TreeNode* temp = root;\n                        temp= temp->left;\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                         if(temp->right == NULL){\n                         temp->right = root;\n                         root= root->left;\n                         }\n                         else {\n                         temp->right = NULL;\n                         ans.push_back(root->val);\n                         root= root->right;\n                         }\n        }.  return ans;    }`\n\nWhat are we doing we are using iterative method without stack. Now, benifits is time is slightly more than O(n) but can be compared to O(n*h) only in general terms{h is height of binary tree) . Talking of space complexity it is O(1)\n\nWe are making the rightmost node in left subtree to point the root "
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<Integer> inorderTraversal(TreeNode root) {\\n List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n        return result;\\n    }\\n    private void inorderTraversal(TreeNode root, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, result);\\n        result.add(root.val);\\n        inorderTraversal(root.right, result);\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/94_binary_tree_inorder_treversal.cpp"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tips:\\nInorder Traversal \\n(Left Root Right)"
                    },
                    {
                        "username": "Voralagas",
                        "content": "why is [1,null,2,3] expecting [1, 3, 2] should not it be [1, 3, 2] ?\\n"
                    },
                    {
                        "username": "TobyLeet",
                        "content": "because it is expecting the left most result first, not necessarily the smallest number. Imagine you are reaching the leftmost pointing branch first, working your way to the rightmost facing branch. So technically the parent node is to the right of the left child node, and to the left of it\\'s right child node."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Why the tree in the Example 1 is described as Input: root = [1,null,2,3]?\nShouldn't it be like this:\nInput: root = [1,null,2, null, null, 3] ? (as it is shown in internet resourses about binary tree array representation)\nAnd how can we traverse the tree if 2k, 2k + 1 formulas doesn't work?\nPlease, help me with this."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Got it. After debugging, actual representation of root for [1, null, 2, 3] is:\\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\\nSo, this object passed in inorderTraversal function as the argument, not the array."
                    },
                    {
                        "username": "noneal",
                        "content": "What is returnSize supposed to be? I assumed that if I dereferenced it, I would get the size of the array to be returned, but I got -1"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-inorder-traversal-leet-code-94/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to perform an inorder traversal of a binary tree in Swift is O(n), where n is the number of nodes in the tree. This is because the function visits each node exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores the recursive calls on the call stack. The space complexity is not affected by the structure of the tree, only by the number of nodes.\\n\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion. In the worst case, when the tree is a linked list, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    }
                ]
            },
            {
                "id": 1735530,
                "content": [
                    {
                        "username": "abhiabhishek9347",
                        "content": "What\\'s wrong on this?\\nWhy can\\'t we create List in function.\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        private List<Integer> l = new ArrayList<>();\\n        if(root!=NULL)\\n        {\\n            inorderTraversal(root.left);\\n            l.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return l;\\n    }"
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "Traversal is one of the first topic you start with for TREE data structure, which is very easy considering recursion . Here I would like to focus on Morris Inorder Traversal.\n      \n    `vector<int> inorderTraversal(TreeNode* root) {\n\n        vector<int> ans;\n        \n        while(root != NULL){\n                    if(root->left == NULL){\n                        ans.push_back(root->val);\n                        root= root->right;\n                    }\n                    else{\n                        TreeNode* temp = root;\n                        temp= temp->left;\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                         if(temp->right == NULL){\n                         temp->right = root;\n                         root= root->left;\n                         }\n                         else {\n                         temp->right = NULL;\n                         ans.push_back(root->val);\n                         root= root->right;\n                         }\n        }.  return ans;    }`\n\nWhat are we doing we are using iterative method without stack. Now, benifits is time is slightly more than O(n) but can be compared to O(n*h) only in general terms{h is height of binary tree) . Talking of space complexity it is O(1)\n\nWe are making the rightmost node in left subtree to point the root "
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<Integer> inorderTraversal(TreeNode root) {\\n List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n        return result;\\n    }\\n    private void inorderTraversal(TreeNode root, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, result);\\n        result.add(root.val);\\n        inorderTraversal(root.right, result);\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/94_binary_tree_inorder_treversal.cpp"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tips:\\nInorder Traversal \\n(Left Root Right)"
                    },
                    {
                        "username": "Voralagas",
                        "content": "why is [1,null,2,3] expecting [1, 3, 2] should not it be [1, 3, 2] ?\\n"
                    },
                    {
                        "username": "TobyLeet",
                        "content": "because it is expecting the left most result first, not necessarily the smallest number. Imagine you are reaching the leftmost pointing branch first, working your way to the rightmost facing branch. So technically the parent node is to the right of the left child node, and to the left of it\\'s right child node."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Why the tree in the Example 1 is described as Input: root = [1,null,2,3]?\nShouldn't it be like this:\nInput: root = [1,null,2, null, null, 3] ? (as it is shown in internet resourses about binary tree array representation)\nAnd how can we traverse the tree if 2k, 2k + 1 formulas doesn't work?\nPlease, help me with this."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Got it. After debugging, actual representation of root for [1, null, 2, 3] is:\\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\\nSo, this object passed in inorderTraversal function as the argument, not the array."
                    },
                    {
                        "username": "noneal",
                        "content": "What is returnSize supposed to be? I assumed that if I dereferenced it, I would get the size of the array to be returned, but I got -1"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-inorder-traversal-leet-code-94/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to perform an inorder traversal of a binary tree in Swift is O(n), where n is the number of nodes in the tree. This is because the function visits each node exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores the recursive calls on the call stack. The space complexity is not affected by the structure of the tree, only by the number of nodes.\\n\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion. In the worst case, when the tree is a linked list, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    }
                ]
            },
            {
                "id": 1733493,
                "content": [
                    {
                        "username": "abhiabhishek9347",
                        "content": "What\\'s wrong on this?\\nWhy can\\'t we create List in function.\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        private List<Integer> l = new ArrayList<>();\\n        if(root!=NULL)\\n        {\\n            inorderTraversal(root.left);\\n            l.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return l;\\n    }"
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "Traversal is one of the first topic you start with for TREE data structure, which is very easy considering recursion . Here I would like to focus on Morris Inorder Traversal.\n      \n    `vector<int> inorderTraversal(TreeNode* root) {\n\n        vector<int> ans;\n        \n        while(root != NULL){\n                    if(root->left == NULL){\n                        ans.push_back(root->val);\n                        root= root->right;\n                    }\n                    else{\n                        TreeNode* temp = root;\n                        temp= temp->left;\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                         if(temp->right == NULL){\n                         temp->right = root;\n                         root= root->left;\n                         }\n                         else {\n                         temp->right = NULL;\n                         ans.push_back(root->val);\n                         root= root->right;\n                         }\n        }.  return ans;    }`\n\nWhat are we doing we are using iterative method without stack. Now, benifits is time is slightly more than O(n) but can be compared to O(n*h) only in general terms{h is height of binary tree) . Talking of space complexity it is O(1)\n\nWe are making the rightmost node in left subtree to point the root "
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<Integer> inorderTraversal(TreeNode root) {\\n List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n        return result;\\n    }\\n    private void inorderTraversal(TreeNode root, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, result);\\n        result.add(root.val);\\n        inorderTraversal(root.right, result);\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/94_binary_tree_inorder_treversal.cpp"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tips:\\nInorder Traversal \\n(Left Root Right)"
                    },
                    {
                        "username": "Voralagas",
                        "content": "why is [1,null,2,3] expecting [1, 3, 2] should not it be [1, 3, 2] ?\\n"
                    },
                    {
                        "username": "TobyLeet",
                        "content": "because it is expecting the left most result first, not necessarily the smallest number. Imagine you are reaching the leftmost pointing branch first, working your way to the rightmost facing branch. So technically the parent node is to the right of the left child node, and to the left of it\\'s right child node."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Why the tree in the Example 1 is described as Input: root = [1,null,2,3]?\nShouldn't it be like this:\nInput: root = [1,null,2, null, null, 3] ? (as it is shown in internet resourses about binary tree array representation)\nAnd how can we traverse the tree if 2k, 2k + 1 formulas doesn't work?\nPlease, help me with this."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Got it. After debugging, actual representation of root for [1, null, 2, 3] is:\\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\\nSo, this object passed in inorderTraversal function as the argument, not the array."
                    },
                    {
                        "username": "noneal",
                        "content": "What is returnSize supposed to be? I assumed that if I dereferenced it, I would get the size of the array to be returned, but I got -1"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-inorder-traversal-leet-code-94/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to perform an inorder traversal of a binary tree in Swift is O(n), where n is the number of nodes in the tree. This is because the function visits each node exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores the recursive calls on the call stack. The space complexity is not affected by the structure of the tree, only by the number of nodes.\\n\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion. In the worst case, when the tree is a linked list, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    }
                ]
            },
            {
                "id": 1728201,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user3422UL",
                        "content": "https://algotree.org/algorithms/tree_graph_traversal/pre_in_post_order/\\n\\nHope this helps anyone else who may be having a hard time with some of these concepts.\\nVery helpful website"
                    },
                    {
                        "username": "Mayank_Sardana",
                        "content": "Hope u find it easy to understand  \\n\\n\\n\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list  = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return list;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        TreeNode curr = root;\\n        while(stack.size()!=0)\\n        {\\n              if(curr!=null && curr.left!=null)\\n              {\\n                  stack.push(curr.left);\\n                  curr = stack.peek();\\n              }\\n              else \\n              {\\n                  list.add(stack.peek().val);\\n                  curr = null;\\n                  TreeNode pp = stack.pop();\\n                  if(pp.right!=null)\\n                  {\\n                       stack.push(pp.right);\\n                       curr = pp.right;\\n                  }\\n              }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "i am facing problem like --error: non-void function \\'inorderTraversal\\' should return a value i.e, i m not able to use return keyword...any soln\\n"
                    },
                    {
                        "username": "jingchizhang001",
                        "content": "Can anyone help explain why I cannot do root.val or root.left? \nIt says:\nAttributeError: 'NoneType' object has no attribute 'val'\n    print(root.val)\nLine 13 in inorderTraversal (Solution.py)\n    ret = Solution().inorderTraversal(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)"
                    },
                    {
                        "username": "marxmaler",
                        "content": "Oh, that\\'s because test case2\\'s root is actually \"None\" -  try print(root) if you still don\\'t get it. So you should handle that exception separately. Sorry if you figured it out already."
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "is there any approach with complexity O(nlogn) ??"
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "I'm having a hard time getting LeetCode's inorder variant, with root, followed by inorder. The first problem is figuring out why the hell it says `root` is null.\n\nTestcase: `[1,null,2,3]`\n\n```\nTypeError: Cannot read properties of null (reading 'val')\n```\n\n```\nfunction inorderTraversal(root, result = []) {\n    console.log(\"root = \\n\"+JSON.stringify(root))\n    result.push(root.val);\n\n};\n```\n\nStdout:\n```\nroot = \n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\nnull\n```"
                    },
                    {
                        "username": "rahulranjancusb",
                        "content": "// We can solve this using 2 ways: Recursive and Iterative.\\n //Approach 1: Recursive\\nclass Solution {\\npublic:\\n    vector<int> inOrder;\\n    vector<int> inorderTraversal(TreeNode* root) {  \\n        //Approach 1: Recursive\\n        // if(root)\\n        // {\\n        //     inorderTraversal(root->left);\\n        //     inOrder.push_back(root->val);\\n        //     inorderTraversal(root->right);\\n        // }\\n        // return inOrder;\\n\\n        //Approach 2: Iterative\\n        stack<TreeNode*> st;\\n        while(root != nullptr || !(st.empty()))\\n        {\\n            if(root != nullptr){\\n                st.push(root);\\n                root = root->left;\\n            }\\n            else\\n            {\\n                root = st.top(); st.pop();\\n                inOrder.push_back(root->val);\\n                root = root->right;   \\n            }\\n        }\\n        return inOrder;\\n    }\\n};"
                    },
                    {
                        "username": "bhaghatsingh",
                        "content": " `your inline code...your inline code...`\\n  void inordT(TreeNode *root,vector<int> &v1)\\n    {\\n        if(root==NULL)return ;\\n        inord(root->left,v1);\\n        v1.push_back(root->val);\\n        inord(root->right,v1);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v1;\\n        inordT(root,v1);\\n        return v1;\\n        \\n    }"
                    }
                ]
            },
            {
                "id": 1725903,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user3422UL",
                        "content": "https://algotree.org/algorithms/tree_graph_traversal/pre_in_post_order/\\n\\nHope this helps anyone else who may be having a hard time with some of these concepts.\\nVery helpful website"
                    },
                    {
                        "username": "Mayank_Sardana",
                        "content": "Hope u find it easy to understand  \\n\\n\\n\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list  = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return list;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        TreeNode curr = root;\\n        while(stack.size()!=0)\\n        {\\n              if(curr!=null && curr.left!=null)\\n              {\\n                  stack.push(curr.left);\\n                  curr = stack.peek();\\n              }\\n              else \\n              {\\n                  list.add(stack.peek().val);\\n                  curr = null;\\n                  TreeNode pp = stack.pop();\\n                  if(pp.right!=null)\\n                  {\\n                       stack.push(pp.right);\\n                       curr = pp.right;\\n                  }\\n              }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "i am facing problem like --error: non-void function \\'inorderTraversal\\' should return a value i.e, i m not able to use return keyword...any soln\\n"
                    },
                    {
                        "username": "jingchizhang001",
                        "content": "Can anyone help explain why I cannot do root.val or root.left? \nIt says:\nAttributeError: 'NoneType' object has no attribute 'val'\n    print(root.val)\nLine 13 in inorderTraversal (Solution.py)\n    ret = Solution().inorderTraversal(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)"
                    },
                    {
                        "username": "marxmaler",
                        "content": "Oh, that\\'s because test case2\\'s root is actually \"None\" -  try print(root) if you still don\\'t get it. So you should handle that exception separately. Sorry if you figured it out already."
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "is there any approach with complexity O(nlogn) ??"
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "I'm having a hard time getting LeetCode's inorder variant, with root, followed by inorder. The first problem is figuring out why the hell it says `root` is null.\n\nTestcase: `[1,null,2,3]`\n\n```\nTypeError: Cannot read properties of null (reading 'val')\n```\n\n```\nfunction inorderTraversal(root, result = []) {\n    console.log(\"root = \\n\"+JSON.stringify(root))\n    result.push(root.val);\n\n};\n```\n\nStdout:\n```\nroot = \n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\nnull\n```"
                    },
                    {
                        "username": "rahulranjancusb",
                        "content": "// We can solve this using 2 ways: Recursive and Iterative.\\n //Approach 1: Recursive\\nclass Solution {\\npublic:\\n    vector<int> inOrder;\\n    vector<int> inorderTraversal(TreeNode* root) {  \\n        //Approach 1: Recursive\\n        // if(root)\\n        // {\\n        //     inorderTraversal(root->left);\\n        //     inOrder.push_back(root->val);\\n        //     inorderTraversal(root->right);\\n        // }\\n        // return inOrder;\\n\\n        //Approach 2: Iterative\\n        stack<TreeNode*> st;\\n        while(root != nullptr || !(st.empty()))\\n        {\\n            if(root != nullptr){\\n                st.push(root);\\n                root = root->left;\\n            }\\n            else\\n            {\\n                root = st.top(); st.pop();\\n                inOrder.push_back(root->val);\\n                root = root->right;   \\n            }\\n        }\\n        return inOrder;\\n    }\\n};"
                    },
                    {
                        "username": "bhaghatsingh",
                        "content": " `your inline code...your inline code...`\\n  void inordT(TreeNode *root,vector<int> &v1)\\n    {\\n        if(root==NULL)return ;\\n        inord(root->left,v1);\\n        v1.push_back(root->val);\\n        inord(root->right,v1);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v1;\\n        inordT(root,v1);\\n        return v1;\\n        \\n    }"
                    }
                ]
            },
            {
                "id": 1719384,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user3422UL",
                        "content": "https://algotree.org/algorithms/tree_graph_traversal/pre_in_post_order/\\n\\nHope this helps anyone else who may be having a hard time with some of these concepts.\\nVery helpful website"
                    },
                    {
                        "username": "Mayank_Sardana",
                        "content": "Hope u find it easy to understand  \\n\\n\\n\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list  = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return list;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        TreeNode curr = root;\\n        while(stack.size()!=0)\\n        {\\n              if(curr!=null && curr.left!=null)\\n              {\\n                  stack.push(curr.left);\\n                  curr = stack.peek();\\n              }\\n              else \\n              {\\n                  list.add(stack.peek().val);\\n                  curr = null;\\n                  TreeNode pp = stack.pop();\\n                  if(pp.right!=null)\\n                  {\\n                       stack.push(pp.right);\\n                       curr = pp.right;\\n                  }\\n              }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "i am facing problem like --error: non-void function \\'inorderTraversal\\' should return a value i.e, i m not able to use return keyword...any soln\\n"
                    },
                    {
                        "username": "jingchizhang001",
                        "content": "Can anyone help explain why I cannot do root.val or root.left? \nIt says:\nAttributeError: 'NoneType' object has no attribute 'val'\n    print(root.val)\nLine 13 in inorderTraversal (Solution.py)\n    ret = Solution().inorderTraversal(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)"
                    },
                    {
                        "username": "marxmaler",
                        "content": "Oh, that\\'s because test case2\\'s root is actually \"None\" -  try print(root) if you still don\\'t get it. So you should handle that exception separately. Sorry if you figured it out already."
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "is there any approach with complexity O(nlogn) ??"
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "I'm having a hard time getting LeetCode's inorder variant, with root, followed by inorder. The first problem is figuring out why the hell it says `root` is null.\n\nTestcase: `[1,null,2,3]`\n\n```\nTypeError: Cannot read properties of null (reading 'val')\n```\n\n```\nfunction inorderTraversal(root, result = []) {\n    console.log(\"root = \\n\"+JSON.stringify(root))\n    result.push(root.val);\n\n};\n```\n\nStdout:\n```\nroot = \n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\nnull\n```"
                    },
                    {
                        "username": "rahulranjancusb",
                        "content": "// We can solve this using 2 ways: Recursive and Iterative.\\n //Approach 1: Recursive\\nclass Solution {\\npublic:\\n    vector<int> inOrder;\\n    vector<int> inorderTraversal(TreeNode* root) {  \\n        //Approach 1: Recursive\\n        // if(root)\\n        // {\\n        //     inorderTraversal(root->left);\\n        //     inOrder.push_back(root->val);\\n        //     inorderTraversal(root->right);\\n        // }\\n        // return inOrder;\\n\\n        //Approach 2: Iterative\\n        stack<TreeNode*> st;\\n        while(root != nullptr || !(st.empty()))\\n        {\\n            if(root != nullptr){\\n                st.push(root);\\n                root = root->left;\\n            }\\n            else\\n            {\\n                root = st.top(); st.pop();\\n                inOrder.push_back(root->val);\\n                root = root->right;   \\n            }\\n        }\\n        return inOrder;\\n    }\\n};"
                    },
                    {
                        "username": "bhaghatsingh",
                        "content": " `your inline code...your inline code...`\\n  void inordT(TreeNode *root,vector<int> &v1)\\n    {\\n        if(root==NULL)return ;\\n        inord(root->left,v1);\\n        v1.push_back(root->val);\\n        inord(root->right,v1);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v1;\\n        inordT(root,v1);\\n        return v1;\\n        \\n    }"
                    }
                ]
            },
            {
                "id": 1708956,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user3422UL",
                        "content": "https://algotree.org/algorithms/tree_graph_traversal/pre_in_post_order/\\n\\nHope this helps anyone else who may be having a hard time with some of these concepts.\\nVery helpful website"
                    },
                    {
                        "username": "Mayank_Sardana",
                        "content": "Hope u find it easy to understand  \\n\\n\\n\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list  = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return list;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        TreeNode curr = root;\\n        while(stack.size()!=0)\\n        {\\n              if(curr!=null && curr.left!=null)\\n              {\\n                  stack.push(curr.left);\\n                  curr = stack.peek();\\n              }\\n              else \\n              {\\n                  list.add(stack.peek().val);\\n                  curr = null;\\n                  TreeNode pp = stack.pop();\\n                  if(pp.right!=null)\\n                  {\\n                       stack.push(pp.right);\\n                       curr = pp.right;\\n                  }\\n              }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "i am facing problem like --error: non-void function \\'inorderTraversal\\' should return a value i.e, i m not able to use return keyword...any soln\\n"
                    },
                    {
                        "username": "jingchizhang001",
                        "content": "Can anyone help explain why I cannot do root.val or root.left? \nIt says:\nAttributeError: 'NoneType' object has no attribute 'val'\n    print(root.val)\nLine 13 in inorderTraversal (Solution.py)\n    ret = Solution().inorderTraversal(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)"
                    },
                    {
                        "username": "marxmaler",
                        "content": "Oh, that\\'s because test case2\\'s root is actually \"None\" -  try print(root) if you still don\\'t get it. So you should handle that exception separately. Sorry if you figured it out already."
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "is there any approach with complexity O(nlogn) ??"
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "I'm having a hard time getting LeetCode's inorder variant, with root, followed by inorder. The first problem is figuring out why the hell it says `root` is null.\n\nTestcase: `[1,null,2,3]`\n\n```\nTypeError: Cannot read properties of null (reading 'val')\n```\n\n```\nfunction inorderTraversal(root, result = []) {\n    console.log(\"root = \\n\"+JSON.stringify(root))\n    result.push(root.val);\n\n};\n```\n\nStdout:\n```\nroot = \n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\nnull\n```"
                    },
                    {
                        "username": "rahulranjancusb",
                        "content": "// We can solve this using 2 ways: Recursive and Iterative.\\n //Approach 1: Recursive\\nclass Solution {\\npublic:\\n    vector<int> inOrder;\\n    vector<int> inorderTraversal(TreeNode* root) {  \\n        //Approach 1: Recursive\\n        // if(root)\\n        // {\\n        //     inorderTraversal(root->left);\\n        //     inOrder.push_back(root->val);\\n        //     inorderTraversal(root->right);\\n        // }\\n        // return inOrder;\\n\\n        //Approach 2: Iterative\\n        stack<TreeNode*> st;\\n        while(root != nullptr || !(st.empty()))\\n        {\\n            if(root != nullptr){\\n                st.push(root);\\n                root = root->left;\\n            }\\n            else\\n            {\\n                root = st.top(); st.pop();\\n                inOrder.push_back(root->val);\\n                root = root->right;   \\n            }\\n        }\\n        return inOrder;\\n    }\\n};"
                    },
                    {
                        "username": "bhaghatsingh",
                        "content": " `your inline code...your inline code...`\\n  void inordT(TreeNode *root,vector<int> &v1)\\n    {\\n        if(root==NULL)return ;\\n        inord(root->left,v1);\\n        v1.push_back(root->val);\\n        inord(root->right,v1);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v1;\\n        inordT(root,v1);\\n        return v1;\\n        \\n    }"
                    }
                ]
            },
            {
                "id": 1706983,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user3422UL",
                        "content": "https://algotree.org/algorithms/tree_graph_traversal/pre_in_post_order/\\n\\nHope this helps anyone else who may be having a hard time with some of these concepts.\\nVery helpful website"
                    },
                    {
                        "username": "Mayank_Sardana",
                        "content": "Hope u find it easy to understand  \\n\\n\\n\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list  = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return list;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        TreeNode curr = root;\\n        while(stack.size()!=0)\\n        {\\n              if(curr!=null && curr.left!=null)\\n              {\\n                  stack.push(curr.left);\\n                  curr = stack.peek();\\n              }\\n              else \\n              {\\n                  list.add(stack.peek().val);\\n                  curr = null;\\n                  TreeNode pp = stack.pop();\\n                  if(pp.right!=null)\\n                  {\\n                       stack.push(pp.right);\\n                       curr = pp.right;\\n                  }\\n              }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "i am facing problem like --error: non-void function \\'inorderTraversal\\' should return a value i.e, i m not able to use return keyword...any soln\\n"
                    },
                    {
                        "username": "jingchizhang001",
                        "content": "Can anyone help explain why I cannot do root.val or root.left? \nIt says:\nAttributeError: 'NoneType' object has no attribute 'val'\n    print(root.val)\nLine 13 in inorderTraversal (Solution.py)\n    ret = Solution().inorderTraversal(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)"
                    },
                    {
                        "username": "marxmaler",
                        "content": "Oh, that\\'s because test case2\\'s root is actually \"None\" -  try print(root) if you still don\\'t get it. So you should handle that exception separately. Sorry if you figured it out already."
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "is there any approach with complexity O(nlogn) ??"
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "I'm having a hard time getting LeetCode's inorder variant, with root, followed by inorder. The first problem is figuring out why the hell it says `root` is null.\n\nTestcase: `[1,null,2,3]`\n\n```\nTypeError: Cannot read properties of null (reading 'val')\n```\n\n```\nfunction inorderTraversal(root, result = []) {\n    console.log(\"root = \\n\"+JSON.stringify(root))\n    result.push(root.val);\n\n};\n```\n\nStdout:\n```\nroot = \n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\nnull\n```"
                    },
                    {
                        "username": "rahulranjancusb",
                        "content": "// We can solve this using 2 ways: Recursive and Iterative.\\n //Approach 1: Recursive\\nclass Solution {\\npublic:\\n    vector<int> inOrder;\\n    vector<int> inorderTraversal(TreeNode* root) {  \\n        //Approach 1: Recursive\\n        // if(root)\\n        // {\\n        //     inorderTraversal(root->left);\\n        //     inOrder.push_back(root->val);\\n        //     inorderTraversal(root->right);\\n        // }\\n        // return inOrder;\\n\\n        //Approach 2: Iterative\\n        stack<TreeNode*> st;\\n        while(root != nullptr || !(st.empty()))\\n        {\\n            if(root != nullptr){\\n                st.push(root);\\n                root = root->left;\\n            }\\n            else\\n            {\\n                root = st.top(); st.pop();\\n                inOrder.push_back(root->val);\\n                root = root->right;   \\n            }\\n        }\\n        return inOrder;\\n    }\\n};"
                    },
                    {
                        "username": "bhaghatsingh",
                        "content": " `your inline code...your inline code...`\\n  void inordT(TreeNode *root,vector<int> &v1)\\n    {\\n        if(root==NULL)return ;\\n        inord(root->left,v1);\\n        v1.push_back(root->val);\\n        inord(root->right,v1);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v1;\\n        inordT(root,v1);\\n        return v1;\\n        \\n    }"
                    }
                ]
            },
            {
                "id": 1691789,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user3422UL",
                        "content": "https://algotree.org/algorithms/tree_graph_traversal/pre_in_post_order/\\n\\nHope this helps anyone else who may be having a hard time with some of these concepts.\\nVery helpful website"
                    },
                    {
                        "username": "Mayank_Sardana",
                        "content": "Hope u find it easy to understand  \\n\\n\\n\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list  = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return list;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        TreeNode curr = root;\\n        while(stack.size()!=0)\\n        {\\n              if(curr!=null && curr.left!=null)\\n              {\\n                  stack.push(curr.left);\\n                  curr = stack.peek();\\n              }\\n              else \\n              {\\n                  list.add(stack.peek().val);\\n                  curr = null;\\n                  TreeNode pp = stack.pop();\\n                  if(pp.right!=null)\\n                  {\\n                       stack.push(pp.right);\\n                       curr = pp.right;\\n                  }\\n              }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "i am facing problem like --error: non-void function \\'inorderTraversal\\' should return a value i.e, i m not able to use return keyword...any soln\\n"
                    },
                    {
                        "username": "jingchizhang001",
                        "content": "Can anyone help explain why I cannot do root.val or root.left? \nIt says:\nAttributeError: 'NoneType' object has no attribute 'val'\n    print(root.val)\nLine 13 in inorderTraversal (Solution.py)\n    ret = Solution().inorderTraversal(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)"
                    },
                    {
                        "username": "marxmaler",
                        "content": "Oh, that\\'s because test case2\\'s root is actually \"None\" -  try print(root) if you still don\\'t get it. So you should handle that exception separately. Sorry if you figured it out already."
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "is there any approach with complexity O(nlogn) ??"
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "I'm having a hard time getting LeetCode's inorder variant, with root, followed by inorder. The first problem is figuring out why the hell it says `root` is null.\n\nTestcase: `[1,null,2,3]`\n\n```\nTypeError: Cannot read properties of null (reading 'val')\n```\n\n```\nfunction inorderTraversal(root, result = []) {\n    console.log(\"root = \\n\"+JSON.stringify(root))\n    result.push(root.val);\n\n};\n```\n\nStdout:\n```\nroot = \n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\nnull\n```"
                    },
                    {
                        "username": "rahulranjancusb",
                        "content": "// We can solve this using 2 ways: Recursive and Iterative.\\n //Approach 1: Recursive\\nclass Solution {\\npublic:\\n    vector<int> inOrder;\\n    vector<int> inorderTraversal(TreeNode* root) {  \\n        //Approach 1: Recursive\\n        // if(root)\\n        // {\\n        //     inorderTraversal(root->left);\\n        //     inOrder.push_back(root->val);\\n        //     inorderTraversal(root->right);\\n        // }\\n        // return inOrder;\\n\\n        //Approach 2: Iterative\\n        stack<TreeNode*> st;\\n        while(root != nullptr || !(st.empty()))\\n        {\\n            if(root != nullptr){\\n                st.push(root);\\n                root = root->left;\\n            }\\n            else\\n            {\\n                root = st.top(); st.pop();\\n                inOrder.push_back(root->val);\\n                root = root->right;   \\n            }\\n        }\\n        return inOrder;\\n    }\\n};"
                    },
                    {
                        "username": "bhaghatsingh",
                        "content": " `your inline code...your inline code...`\\n  void inordT(TreeNode *root,vector<int> &v1)\\n    {\\n        if(root==NULL)return ;\\n        inord(root->left,v1);\\n        v1.push_back(root->val);\\n        inord(root->right,v1);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v1;\\n        inordT(root,v1);\\n        return v1;\\n        \\n    }"
                    }
                ]
            },
            {
                "id": 1691788,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user3422UL",
                        "content": "https://algotree.org/algorithms/tree_graph_traversal/pre_in_post_order/\\n\\nHope this helps anyone else who may be having a hard time with some of these concepts.\\nVery helpful website"
                    },
                    {
                        "username": "Mayank_Sardana",
                        "content": "Hope u find it easy to understand  \\n\\n\\n\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list  = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return list;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        TreeNode curr = root;\\n        while(stack.size()!=0)\\n        {\\n              if(curr!=null && curr.left!=null)\\n              {\\n                  stack.push(curr.left);\\n                  curr = stack.peek();\\n              }\\n              else \\n              {\\n                  list.add(stack.peek().val);\\n                  curr = null;\\n                  TreeNode pp = stack.pop();\\n                  if(pp.right!=null)\\n                  {\\n                       stack.push(pp.right);\\n                       curr = pp.right;\\n                  }\\n              }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "i am facing problem like --error: non-void function \\'inorderTraversal\\' should return a value i.e, i m not able to use return keyword...any soln\\n"
                    },
                    {
                        "username": "jingchizhang001",
                        "content": "Can anyone help explain why I cannot do root.val or root.left? \nIt says:\nAttributeError: 'NoneType' object has no attribute 'val'\n    print(root.val)\nLine 13 in inorderTraversal (Solution.py)\n    ret = Solution().inorderTraversal(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)"
                    },
                    {
                        "username": "marxmaler",
                        "content": "Oh, that\\'s because test case2\\'s root is actually \"None\" -  try print(root) if you still don\\'t get it. So you should handle that exception separately. Sorry if you figured it out already."
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "is there any approach with complexity O(nlogn) ??"
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "I'm having a hard time getting LeetCode's inorder variant, with root, followed by inorder. The first problem is figuring out why the hell it says `root` is null.\n\nTestcase: `[1,null,2,3]`\n\n```\nTypeError: Cannot read properties of null (reading 'val')\n```\n\n```\nfunction inorderTraversal(root, result = []) {\n    console.log(\"root = \\n\"+JSON.stringify(root))\n    result.push(root.val);\n\n};\n```\n\nStdout:\n```\nroot = \n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\nnull\n```"
                    },
                    {
                        "username": "rahulranjancusb",
                        "content": "// We can solve this using 2 ways: Recursive and Iterative.\\n //Approach 1: Recursive\\nclass Solution {\\npublic:\\n    vector<int> inOrder;\\n    vector<int> inorderTraversal(TreeNode* root) {  \\n        //Approach 1: Recursive\\n        // if(root)\\n        // {\\n        //     inorderTraversal(root->left);\\n        //     inOrder.push_back(root->val);\\n        //     inorderTraversal(root->right);\\n        // }\\n        // return inOrder;\\n\\n        //Approach 2: Iterative\\n        stack<TreeNode*> st;\\n        while(root != nullptr || !(st.empty()))\\n        {\\n            if(root != nullptr){\\n                st.push(root);\\n                root = root->left;\\n            }\\n            else\\n            {\\n                root = st.top(); st.pop();\\n                inOrder.push_back(root->val);\\n                root = root->right;   \\n            }\\n        }\\n        return inOrder;\\n    }\\n};"
                    },
                    {
                        "username": "bhaghatsingh",
                        "content": " `your inline code...your inline code...`\\n  void inordT(TreeNode *root,vector<int> &v1)\\n    {\\n        if(root==NULL)return ;\\n        inord(root->left,v1);\\n        v1.push_back(root->val);\\n        inord(root->right,v1);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v1;\\n        inordT(root,v1);\\n        return v1;\\n        \\n    }"
                    }
                ]
            },
            {
                "id": 1691142,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user3422UL",
                        "content": "https://algotree.org/algorithms/tree_graph_traversal/pre_in_post_order/\\n\\nHope this helps anyone else who may be having a hard time with some of these concepts.\\nVery helpful website"
                    },
                    {
                        "username": "Mayank_Sardana",
                        "content": "Hope u find it easy to understand  \\n\\n\\n\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list  = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return list;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        TreeNode curr = root;\\n        while(stack.size()!=0)\\n        {\\n              if(curr!=null && curr.left!=null)\\n              {\\n                  stack.push(curr.left);\\n                  curr = stack.peek();\\n              }\\n              else \\n              {\\n                  list.add(stack.peek().val);\\n                  curr = null;\\n                  TreeNode pp = stack.pop();\\n                  if(pp.right!=null)\\n                  {\\n                       stack.push(pp.right);\\n                       curr = pp.right;\\n                  }\\n              }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "i am facing problem like --error: non-void function \\'inorderTraversal\\' should return a value i.e, i m not able to use return keyword...any soln\\n"
                    },
                    {
                        "username": "jingchizhang001",
                        "content": "Can anyone help explain why I cannot do root.val or root.left? \nIt says:\nAttributeError: 'NoneType' object has no attribute 'val'\n    print(root.val)\nLine 13 in inorderTraversal (Solution.py)\n    ret = Solution().inorderTraversal(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)"
                    },
                    {
                        "username": "marxmaler",
                        "content": "Oh, that\\'s because test case2\\'s root is actually \"None\" -  try print(root) if you still don\\'t get it. So you should handle that exception separately. Sorry if you figured it out already."
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "is there any approach with complexity O(nlogn) ??"
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "I'm having a hard time getting LeetCode's inorder variant, with root, followed by inorder. The first problem is figuring out why the hell it says `root` is null.\n\nTestcase: `[1,null,2,3]`\n\n```\nTypeError: Cannot read properties of null (reading 'val')\n```\n\n```\nfunction inorderTraversal(root, result = []) {\n    console.log(\"root = \\n\"+JSON.stringify(root))\n    result.push(root.val);\n\n};\n```\n\nStdout:\n```\nroot = \n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\nnull\n```"
                    },
                    {
                        "username": "rahulranjancusb",
                        "content": "// We can solve this using 2 ways: Recursive and Iterative.\\n //Approach 1: Recursive\\nclass Solution {\\npublic:\\n    vector<int> inOrder;\\n    vector<int> inorderTraversal(TreeNode* root) {  \\n        //Approach 1: Recursive\\n        // if(root)\\n        // {\\n        //     inorderTraversal(root->left);\\n        //     inOrder.push_back(root->val);\\n        //     inorderTraversal(root->right);\\n        // }\\n        // return inOrder;\\n\\n        //Approach 2: Iterative\\n        stack<TreeNode*> st;\\n        while(root != nullptr || !(st.empty()))\\n        {\\n            if(root != nullptr){\\n                st.push(root);\\n                root = root->left;\\n            }\\n            else\\n            {\\n                root = st.top(); st.pop();\\n                inOrder.push_back(root->val);\\n                root = root->right;   \\n            }\\n        }\\n        return inOrder;\\n    }\\n};"
                    },
                    {
                        "username": "bhaghatsingh",
                        "content": " `your inline code...your inline code...`\\n  void inordT(TreeNode *root,vector<int> &v1)\\n    {\\n        if(root==NULL)return ;\\n        inord(root->left,v1);\\n        v1.push_back(root->val);\\n        inord(root->right,v1);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v1;\\n        inordT(root,v1);\\n        return v1;\\n        \\n    }"
                    }
                ]
            },
            {
                "id": 1672383,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user3422UL",
                        "content": "https://algotree.org/algorithms/tree_graph_traversal/pre_in_post_order/\\n\\nHope this helps anyone else who may be having a hard time with some of these concepts.\\nVery helpful website"
                    },
                    {
                        "username": "Mayank_Sardana",
                        "content": "Hope u find it easy to understand  \\n\\n\\n\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list  = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return list;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        TreeNode curr = root;\\n        while(stack.size()!=0)\\n        {\\n              if(curr!=null && curr.left!=null)\\n              {\\n                  stack.push(curr.left);\\n                  curr = stack.peek();\\n              }\\n              else \\n              {\\n                  list.add(stack.peek().val);\\n                  curr = null;\\n                  TreeNode pp = stack.pop();\\n                  if(pp.right!=null)\\n                  {\\n                       stack.push(pp.right);\\n                       curr = pp.right;\\n                  }\\n              }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "i am facing problem like --error: non-void function \\'inorderTraversal\\' should return a value i.e, i m not able to use return keyword...any soln\\n"
                    },
                    {
                        "username": "jingchizhang001",
                        "content": "Can anyone help explain why I cannot do root.val or root.left? \nIt says:\nAttributeError: 'NoneType' object has no attribute 'val'\n    print(root.val)\nLine 13 in inorderTraversal (Solution.py)\n    ret = Solution().inorderTraversal(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)"
                    },
                    {
                        "username": "marxmaler",
                        "content": "Oh, that\\'s because test case2\\'s root is actually \"None\" -  try print(root) if you still don\\'t get it. So you should handle that exception separately. Sorry if you figured it out already."
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "is there any approach with complexity O(nlogn) ??"
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "I'm having a hard time getting LeetCode's inorder variant, with root, followed by inorder. The first problem is figuring out why the hell it says `root` is null.\n\nTestcase: `[1,null,2,3]`\n\n```\nTypeError: Cannot read properties of null (reading 'val')\n```\n\n```\nfunction inorderTraversal(root, result = []) {\n    console.log(\"root = \\n\"+JSON.stringify(root))\n    result.push(root.val);\n\n};\n```\n\nStdout:\n```\nroot = \n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\nnull\n```"
                    },
                    {
                        "username": "rahulranjancusb",
                        "content": "// We can solve this using 2 ways: Recursive and Iterative.\\n //Approach 1: Recursive\\nclass Solution {\\npublic:\\n    vector<int> inOrder;\\n    vector<int> inorderTraversal(TreeNode* root) {  \\n        //Approach 1: Recursive\\n        // if(root)\\n        // {\\n        //     inorderTraversal(root->left);\\n        //     inOrder.push_back(root->val);\\n        //     inorderTraversal(root->right);\\n        // }\\n        // return inOrder;\\n\\n        //Approach 2: Iterative\\n        stack<TreeNode*> st;\\n        while(root != nullptr || !(st.empty()))\\n        {\\n            if(root != nullptr){\\n                st.push(root);\\n                root = root->left;\\n            }\\n            else\\n            {\\n                root = st.top(); st.pop();\\n                inOrder.push_back(root->val);\\n                root = root->right;   \\n            }\\n        }\\n        return inOrder;\\n    }\\n};"
                    },
                    {
                        "username": "bhaghatsingh",
                        "content": " `your inline code...your inline code...`\\n  void inordT(TreeNode *root,vector<int> &v1)\\n    {\\n        if(root==NULL)return ;\\n        inord(root->left,v1);\\n        v1.push_back(root->val);\\n        inord(root->right,v1);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v1;\\n        inordT(root,v1);\\n        return v1;\\n        \\n    }"
                    }
                ]
            },
            {
                "id": 1669371,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user3422UL",
                        "content": "https://algotree.org/algorithms/tree_graph_traversal/pre_in_post_order/\\n\\nHope this helps anyone else who may be having a hard time with some of these concepts.\\nVery helpful website"
                    },
                    {
                        "username": "Mayank_Sardana",
                        "content": "Hope u find it easy to understand  \\n\\n\\n\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list  = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return list;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        TreeNode curr = root;\\n        while(stack.size()!=0)\\n        {\\n              if(curr!=null && curr.left!=null)\\n              {\\n                  stack.push(curr.left);\\n                  curr = stack.peek();\\n              }\\n              else \\n              {\\n                  list.add(stack.peek().val);\\n                  curr = null;\\n                  TreeNode pp = stack.pop();\\n                  if(pp.right!=null)\\n                  {\\n                       stack.push(pp.right);\\n                       curr = pp.right;\\n                  }\\n              }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "i am facing problem like --error: non-void function \\'inorderTraversal\\' should return a value i.e, i m not able to use return keyword...any soln\\n"
                    },
                    {
                        "username": "jingchizhang001",
                        "content": "Can anyone help explain why I cannot do root.val or root.left? \nIt says:\nAttributeError: 'NoneType' object has no attribute 'val'\n    print(root.val)\nLine 13 in inorderTraversal (Solution.py)\n    ret = Solution().inorderTraversal(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)"
                    },
                    {
                        "username": "marxmaler",
                        "content": "Oh, that\\'s because test case2\\'s root is actually \"None\" -  try print(root) if you still don\\'t get it. So you should handle that exception separately. Sorry if you figured it out already."
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "is there any approach with complexity O(nlogn) ??"
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "I'm having a hard time getting LeetCode's inorder variant, with root, followed by inorder. The first problem is figuring out why the hell it says `root` is null.\n\nTestcase: `[1,null,2,3]`\n\n```\nTypeError: Cannot read properties of null (reading 'val')\n```\n\n```\nfunction inorderTraversal(root, result = []) {\n    console.log(\"root = \\n\"+JSON.stringify(root))\n    result.push(root.val);\n\n};\n```\n\nStdout:\n```\nroot = \n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\nnull\n```"
                    },
                    {
                        "username": "rahulranjancusb",
                        "content": "// We can solve this using 2 ways: Recursive and Iterative.\\n //Approach 1: Recursive\\nclass Solution {\\npublic:\\n    vector<int> inOrder;\\n    vector<int> inorderTraversal(TreeNode* root) {  \\n        //Approach 1: Recursive\\n        // if(root)\\n        // {\\n        //     inorderTraversal(root->left);\\n        //     inOrder.push_back(root->val);\\n        //     inorderTraversal(root->right);\\n        // }\\n        // return inOrder;\\n\\n        //Approach 2: Iterative\\n        stack<TreeNode*> st;\\n        while(root != nullptr || !(st.empty()))\\n        {\\n            if(root != nullptr){\\n                st.push(root);\\n                root = root->left;\\n            }\\n            else\\n            {\\n                root = st.top(); st.pop();\\n                inOrder.push_back(root->val);\\n                root = root->right;   \\n            }\\n        }\\n        return inOrder;\\n    }\\n};"
                    },
                    {
                        "username": "bhaghatsingh",
                        "content": " `your inline code...your inline code...`\\n  void inordT(TreeNode *root,vector<int> &v1)\\n    {\\n        if(root==NULL)return ;\\n        inord(root->left,v1);\\n        v1.push_back(root->val);\\n        inord(root->right,v1);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v1;\\n        inordT(root,v1);\\n        return v1;\\n        \\n    }"
                    }
                ]
            }
        ]
    },
    {
        "title": "Transpose File",
        "question_content": "<p>Given a text file <code>file.txt</code>, transpose its content.</p>\n\n<p>You may assume that each row has the same number of columns, and each field is separated by the <code>&#39; &#39;</code> character.</p>\n\n<p><strong class=\"example\">Example:</strong></p>\n\n<p>If <code>file.txt</code> has the following content:</p>\n\n<pre>\nname age\nalice 21\nryan 30\n</pre>\n\n<p>Output the following:</p>\n\n<pre>\nname alice ryan\nage 21 30\n</pre>\n",
        "solutions": [
            {
                "id": 55502,
                "title": "ac-solution-using-awk-and-statement-just-like-c",
                "content": "Just feel free to use `for` and `if`.  \\nYou can append string easily, for example, `s = s a` to append `a` with `s`. \\n\\n\\n    awk '\\n    {\\n        for (i = 1; i <= NF; i++) {\\n            if(NR == 1) {\\n                s[i] = $i;\\n            } else {\\n                s[i] = s[i] \" \" $i;\\n            }\\n        }\\n    }\\n    END {\\n        for (i = 1; s[i] != \"\"; i++) {\\n            print s[i];\\n        }\\n    }' file.txt",
                "solutionTags": [],
                "code": "Just feel free to use `for` and `if`.  \\nYou can append string easily, for example, `s = s a` to append `a` with `s`. \\n\\n\\n    awk '\\n    {\\n        for (i = 1; i <= NF; i++) {\\n            if(NR == 1) {\\n                s[i] = $i;\\n            } else {\\n                s[i] = s[i] \" \" $i;\\n            }\\n        }\\n    }\\n    END {\\n        for (i = 1; s[i] != \"\"; i++) {\\n            print s[i];\\n        }\\n    }' file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 111382,
                "title": "solution-using-awk-with-explanations",
                "content": "I would definitely recommend this tutorial: http://www.grymoire.com/Unix/Awk.html if you'd like to know more about GAWK/NAWK. Similar to `sed`, `awk` is used to perform complex editing tasks to streams of text. The main difference is that `awk` is more suitable for larger editing tasks (those that may need some programming language features).\\n\\nYou may have already seen `awk` solutions similar to the one presented below:\\n\\n```bash\\nawk '\\n{\\n    for (i = 1; i <= NF; i++) {\\n        if (FNR == 1) {\\n            t[i] = $i;\\n        } else {\\n            t[i] = t[i] \" \" $i\\n        }\\n    }\\n}\\nEND {\\n    for (i = 1; t[i] != \"\"; i++) {\\n        print t[i]\\n    }\\n}\\n' file.txt\\n```\\n\\nHere're some quick notes to help you understand:\\n\\n1. The code block with an \"END\" prefix is only executed after the last line is read; similarly, a code block with a \"BEGIN\" prefix will be executed before any line reads.\\n\\n2. AWK is line-based: the main code block (the code block without prefix) processes one line of input at a time.\\n\\n3. `NR`: a variable indicating the number of records (i.e. current line number) that's accumulated across multiple files read. `FNR` is similar to `NR`, but is reset for each file read. Since we only need to deal with one file in this question, either is fine to use.\\n\\n4. `NF`: a variable indicating the number of fields (i.e. number of \"columns\") on an input line.\\n\\n5. `$i`: the i-th field of the input line.\\n\\n6. `t[]`: an array for saving the transposed table. More on awk arrays here: http://www.grymoire.com/Unix/Awk.html#uh-22",
                "solutionTags": [],
                "code": "```bash\\nawk '\\n{\\n    for (i = 1; i <= NF; i++) {\\n        if (FNR == 1) {\\n            t[i] = $i;\\n        } else {\\n            t[i] = t[i] \" \" $i\\n        }\\n    }\\n}\\nEND {\\n    for (i = 1; t[i] != \"\"; i++) {\\n        print t[i]\\n    }\\n}\\n' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 657470,
                "title": "simple-0ms-no-awk-no-scripting-in-bash",
                "content": "```bash\\nhead -1 file.txt | wc -w | xargs seq 1 | xargs -I{} -n 1 sh -c \"cut -d \\' \\' -f{} file.txt | paste -sd \\' \\' -\"\\n```",
                "solutionTags": [],
                "code": "```bash\\nhead -1 file.txt | wc -w | xargs seq 1 | xargs -I{} -n 1 sh -c \"cut -d \\' \\' -f{} file.txt | paste -sd \\' \\' -\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 607685,
                "title": "the-real-intended-solution-using-pure-bash",
                "content": "```\\n#!/bin/bash\\npython3 -c \\'print(\"\\\\n\".join(map(\" \".join, zip(*(l.split() for l in open(\"file.txt\"))))))\\'",
                "solutionTags": [],
                "code": "```\\n#!/bin/bash\\npython3 -c \\'print(\"\\\\n\".join(map(\" \".join, zip(*(l.split() for l in open(\"file.txt\"))))))\\'",
                "codeTag": "Python3"
            },
            {
                "id": 55501,
                "title": "simple-bash-solution-that-oj-hates",
                "content": "My solution in BASH. It works fine on my computer and I think it's conceptually straightforward. OJ complains exceeding memory.\\n\\n    ncol=`head -n1 file.txt | wc -w`\\n    \\n    for i in `seq 1 $ncol`\\n    do\\n        echo `cut -d' ' -f$i file.txt`\\n    done",
                "solutionTags": [],
                "code": "My solution in BASH. It works fine on my computer and I think it's conceptually straightforward. OJ complains exceeding memory.\\n\\n    ncol=`head -n1 file.txt | wc -w`\\n    \\n    for i in `seq 1 $ncol`\\n    do\\n        echo `cut -d' ' -f$i file.txt`\\n    done",
                "codeTag": "Unknown"
            },
            {
                "id": 373961,
                "title": "beat-99-4ms-single-line-awk-with-explain-pure-shell-ver-no-cat-awk-sed-etc",
                "content": "```\\nawk \\'{for(i=0;++i<=NF;)a[i]=a[i]?a[i] FS $i:$i}END{for(i=0;i++<NF;)print a[i]}\\' file.txt\\n```\\n\\nExplain:\\n```\\nfor(i=0;++i<=NF;)a[i]=a[i]?a[i] FS $i:$i\\n```\\n\\nLet\\'s talk it in C\\'s perspective.\\n* In `awk` ,`$i` is the i-th column of the line segmented by `Field Separator`(`FS`), \\n\\t\\twhich is internally defined as `FS=\" \"`.\\n\\t\\t`NF` = Number of Fields, how many pieces of the line we got after segmentation\\n* the expression in first `for` statement: \\n\\t\\t1) `?` is ternary operator as it does in C.\\n\\t\\t2) `a[i] FS $i` concatenates string `a[i]` and `FS` and `$i`\\n\\t\\t3) strings in array `a` *DO NOT* need to be declared, they\\'re `NULL` by default.\\n\\t\\t4) `NULL` logically equals to `FALSE`\\n\\t\\t5) obviously ternary operator has higher priority than variable assignment/concatenation\\n* So the whole expresion just transposed the content of input.\\n\\n`END` tells what to do after previous expression. As you see, `{for(i=0;i++<NF;)print a[i]}` just print them out.\\n\\nPure shell version:\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\nfile=\"file.txt\"\\ndeclare -a tranctx\\nwhile read line; do\\n        IFS=\" \"\\n        j=0\\n        p=($line)\\n        while [ ! -z \"${p[$j]}\" ]; do\\n                tranctx[$j]=${tranctx[$j]}${p[$j]}$\\'\\\\n\\'\\n                ((++j))\\n        done\\n        IFS=$\\'\\\\n\\'\\ndone <$file\\n\\ni=0\\nwhile [ ! -z \"${tranctx[${i}]}\" ]; do\\n        echo ${tranctx[${i}]}\\n        ((++i))\\ndone\\n```\\nIt basically does same thing, but much more slower (**150ms**).",
                "solutionTags": [],
                "code": "```\\nawk \\'{for(i=0;++i<=NF;)a[i]=a[i]?a[i] FS $i:$i}END{for(i=0;i++<NF;)print a[i]}\\' file.txt\\n```\n```\\nfor(i=0;++i<=NF;)a[i]=a[i]?a[i] FS $i:$i\\n```\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\nfile=\"file.txt\"\\ndeclare -a tranctx\\nwhile read line; do\\n        IFS=\" \"\\n        j=0\\n        p=($line)\\n        while [ ! -z \"${p[$j]}\" ]; do\\n                tranctx[$j]=${tranctx[$j]}${p[$j]}$\\'\\\\n\\'\\n                ((++j))\\n        done\\n        IFS=$\\'\\\\n\\'\\ndone <$file\\n\\ni=0\\nwhile [ ! -z \"${tranctx[${i}]}\" ]; do\\n        echo ${tranctx[${i}]}\\n        ((++i))\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55510,
                "title": "bash-sort-no-array-matrix",
                "content": "I print the words with coordinates `i` and `j`, then sort by `j` and `i`, then print in that order.\\n\\nInput:\\n```\\nname age\\nalice 21\\nryan 30\\n```\\nThe words with coordinates:\\n```\\n1 1 name\\n1 2 age\\n2 1 alice\\n2 2 21\\n3 1 ryan\\n3 2 30\\n```\\nSorted by `j` and `i`:\\n```\\n1 1 name\\n2 1 alice\\n3 1 ryan\\n1 2 age\\n2 2 21\\n3 2 30\\n```\\nFinal output:\\n```\\nname alice ryan\\nage 21 30\\n```\\nThe code:\\n```\\nm=`wc -l file.txt | cut -d' ' -f1`\\ni=0\\nwhile read line\\ndo\\n    let i++\\n    j=0\\n    for a in $line\\n    do\\n        let j++\\n        echo $i $j $a\\n    done\\ndone < file.txt | sort -n -k2 -k1 | while read i j a\\ndo\\n    if [ \"$i\" == \"$m\" ]\\n    then\\n        echo $a\\n    else\\n        echo -n \"$a \"\\n    fi\\ndone\\n```\\nIt's very slow, though, takes about 750 ms.",
                "solutionTags": [],
                "code": "```\\nname age\\nalice 21\\nryan 30\\n```\n```\\n1 1 name\\n1 2 age\\n2 1 alice\\n2 2 21\\n3 1 ryan\\n3 2 30\\n```\n```\\n1 1 name\\n2 1 alice\\n3 1 ryan\\n1 2 age\\n2 2 21\\n3 2 30\\n```\n```\\nname alice ryan\\nage 21 30\\n```\n```\\nm=`wc -l file.txt | cut -d' ' -f1`\\ni=0\\nwhile read line\\ndo\\n    let i++\\n    j=0\\n    for a in $line\\n    do\\n        let j++\\n        echo $i $j $a\\n    done\\ndone < file.txt | sort -n -k2 -k1 | while read i j a\\ndo\\n    if [ \"$i\" == \"$m\" ]\\n    then\\n        echo $a\\n    else\\n        echo -n \"$a \"\\n    fi\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55514,
                "title": "my-28ms-awk-solution",
                "content": "    # Read from the file file.txt and print its transposed content to stdout.\\n    \\n    # using awk for this purpose\\n    awk '\\n        {\\n            for(i=1; i<=NF; i++)\\n            {   \\n                if(line[i] == \"\")\\n                {\\n                    line[i] = $i\\n                }\\n                else\\n                {\\n                    line[i] = line[i]\" \"$i\\n                }\\n            }\\n        }\\n        END{\\n             for(i=1; i<=NF; i++)\\n             {\\n                 print line[i]\\n             }\\n           }\\n        ' file.txt",
                "solutionTags": [],
                "code": "    # Read from the file file.txt and print its transposed content to stdout.\\n    \\n    # using awk for this purpose\\n    awk '\\n        {\\n            for(i=1; i<=NF; i++)\\n            {   \\n                if(line[i] == \"\")\\n                {\\n                    line[i] = $i\\n                }\\n                else\\n                {\\n                    line[i] = line[i]\" \"$i\\n                }\\n            }\\n        }\\n        END{\\n             for(i=1; i<=NF; i++)\\n             {\\n                 print line[i]\\n             }\\n           }\\n        ' file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 3218902,
                "title": "194-solution-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe problem is asking to transpose the content of a text file. The transpose operation is performed by converting rows to columns. For example, if we have a matrix, the transpose of the matrix is the operation of changing the rows of the matrix to columns.\\n\\nIn this case, we need to transpose the content of a text file, which means to swap the rows with columns, and print the resulting output.\\n\\nTo solve this problem, we can use the awk command in Unix. The awk command is a powerful tool for text processing, and it can be used to perform various operations on text files.\\n\\nLet\\'s break down the solution step by step:\\n\\n1. awk is a command for text processing, and it is used to extract and manipulate data from text files. We are using awk to perform the transpose operation on the content of a text file.\\n\\n2. We start with a for loop that reads the input file and stores the data in an array a. The NF variable in awk is the number of fields in the current record (or row), and the NR variable is the number of records (or rows) in the input file. The for loop reads each field in the row and stores it in the array a. The array a has two dimensions, where the first dimension is the column number, and the second dimension is the row number.\\n\\n3. After storing the data in the array a, we use another for loop to print the transposed data. We use the printf function to print the data in a formatted way. The printf function prints the data without adding a newline at the end, which is important for printing the transposed data.\\n\\n4. In the second for loop, we print the data in the transposed form. The loop iterates over each column first and then over each row. The printf function prints the data from the array a in a transposed form.\\n\\n5. The output of the one-liner is the transposed data of the input file.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nawk \\'{for (i=1; i<=NF; i++) {a[i,NR]=$i}} END {for (i=1; i<=NF; i++) {for (j=1; j<=NR; j++) {printf a[i,j]; if (j<NR) printf \" \"} printf \"\\\\n\"}}\\' file.txt\\n\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```\\nawk \\'{for (i=1; i<=NF; i++) {a[i,NR]=$i}} END {for (i=1; i<=NF; i++) {for (j=1; j<=NR; j++) {printf a[i,j]; if (j<NR) printf \" \"} printf \"\\\\n\"}}\\' file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55522,
                "title": "ac-solution-8-lines-only-in-pure-bash",
                "content": "    while read -a line; do\\n        for ((i=0; i < \"${#line[@]}\"; i++)); do\\n            a[$i]=\"${a[$i]} ${line[$i]}\"\\n        done\\n    done < file.txt\\n    for ((i=0; i < ${#a[@]}; i++)); do\\n        echo ${a[i]}\\n    done",
                "solutionTags": [],
                "code": "    while read -a line; do\\n        for ((i=0; i < \"${#line[@]}\"; i++)); do\\n            a[$i]=\"${a[$i]} ${line[$i]}\"\\n        done\\n    done < file.txt\\n    for ((i=0; i < ${#a[@]}; i++)); do\\n        echo ${a[i]}\\n    done",
                "codeTag": "Unknown"
            },
            {
                "id": 55520,
                "title": "simple-solution-with-awk",
                "content": "Simple solution with awk using associative array\\n\\nawk '{ for(i=1; i<=NF; ++i) {if (word[i] == \"\") {word[i] = $i} else{word[i] = word[i]\" \"$i}}} END{for(i=1; i<=NF; ++i) {print word[i]}}' file.txt",
                "solutionTags": [],
                "code": "Simple solution with awk using associative array\\n\\nawk '{ for(i=1; i<=NF; ++i) {if (word[i] == \"\") {word[i] = $i} else{word[i] = word[i]\" \"$i}}} END{for(i=1; i<=NF; ++i) {print word[i]}}' file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 55511,
                "title": "memory-limit-exceeded",
                "content": "    # Read from the file file.txt and print its transposed content to stdout.\\n    A=$(head -1 file.txt | tr ' ' '\\\\n' | wc -l)\\n    COUNTER=1\\n    while [  $COUNTER -le $A ]; do\\n    \\tawk -v temp=$COUNTER '{ printf(\"%s \", $temp) }' file.txt\\n    \\techo \"\"\\n    \\tlet COUNTER=COUNTER+1 \\n    done",
                "solutionTags": [],
                "code": "    # Read from the file file.txt and print its transposed content to stdout.\\n    A=$(head -1 file.txt | tr ' ' '\\\\n' | wc -l)\\n    COUNTER=1\\n    while [  $COUNTER -le $A ]; do\\n    \\tawk -v temp=$COUNTER '{ printf(\"%s \", $temp) }' file.txt\\n    \\techo \"\"\\n    \\tlet COUNTER=COUNTER+1 \\n    done",
                "codeTag": "Unknown"
            },
            {
                "id": 55524,
                "title": "building-matrix-with-awk",
                "content": "\\nI had to use \\n\\n - NF!=0 to remove any blank lines and  save rows and \\n - cols=NF to be used in END{} block.\\n\\n    awk 'NF!=0 {for(c=1;c<=NF;c++) mtx[NR,c]=$c; rows++; cols=NF;} END{for(c=1;c<=cols;c++) { line=mtx[1,c]; for(r=2;r<=rows;r++) { line=line\" \"mtx[r,c]}; print line; }}' file.txt",
                "solutionTags": [],
                "code": "\\nI had to use \\n\\n - NF!=0 to remove any blank lines and  save rows and \\n - cols=NF to be used in END{} block.\\n\\n    awk 'NF!=0 {for(c=1;c<=NF;c++) mtx[NR,c]=$c; rows++; cols=NF;} END{for(c=1;c<=cols;c++) { line=mtx[1,c]; for(r=2;r<=rows;r++) { line=line\" \"mtx[r,c]}; print line; }}' file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 2722028,
                "title": "easy-solution",
                "content": "```\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        if (FNR == 1) {\\n            t[i] = $i;\\n        } else {\\n            t[i] = t[i] \" \" $i\\n        }\\n    }\\n}\\nEND {\\n    for (i = 1; t[i] != \"\"; i++) {\\n        print t[i]\\n    }\\n}\\n\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        if (FNR == 1) {\\n            t[i] = $i;\\n        } else {\\n            t[i] = t[i] \" \" $i\\n        }\\n    }\\n}\\nEND {\\n    for (i = 1; t[i] != \"\"; i++) {\\n        print t[i]\\n    }\\n}\\n\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1399773,
                "title": "one-simple-solution",
                "content": "```\\nfor ((i = 1; ; i++)); do\\n    line=$(awk -vn=$i \\'{print $n}\\' file.txt)\\n    [[ $line ]] || break\\n    echo $line\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\nfor ((i = 1; ; i++)); do\\n    line=$(awk -vn=$i \\'{print $n}\\' file.txt)\\n    [[ $line ]] || break\\n    echo $line\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 261053,
                "title": "16ms-use-2-dimensions-array-of-awk-so-easy-to-understand",
                "content": "awk \\'{for(j=1;j<=NF;j++){data[NR,j]=$j;}} END {for(ii=1;ii<=NF;ii++){for(jj=1;jj<=NR;jj++){printf \"%s%c\", data[jj,ii],jj==NR?\"\\\\n\":\" \";}}}\\' file.txt",
                "solutionTags": [],
                "code": "awk \\'{for(j=1;j<=NF;j++){data[NR,j]=$j;}} END {for(ii=1;ii<=NF;ii++){for(jj=1;jj<=NR;jj++){printf \"%s%c\", data[jj,ii],jj==NR?\"\\\\n\":\" \";}}}\\' file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 1482122,
                "title": "one-liner-4ms",
                "content": "Using xargs, one liner (kinda),\\n**awk**ward shell substitution to avoid creating a variable.\\n\\n```\\nseq \"$(awk \\'{print NF}\\' file.txt | head -n 1)\" |\\n\\txargs -r -I {} sh -c \"awk \\'{print \\\\${}}\\' file.txt | xargs -r\"\\n```",
                "solutionTags": [],
                "code": "```\\nseq \"$(awk \\'{print NF}\\' file.txt | head -n 1)\" |\\n\\txargs -r -I {} sh -c \"awk \\'{print \\\\${}}\\' file.txt | xargs -r\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1185158,
                "title": "solution-using-awk-beats-100-of-submissions-0ms-solution",
                "content": "I would definitely recommend this tutorial: http://www.grymoire.com/Unix/Awk.html if you\\'d like to know more about GAWK/NAWK. Similar to sed, awk is used to perform complex editing tasks to streams of text. The main difference is that awk is more suitable for larger editing tasks (those that may need some programming language features).\\n\\nSolution :\\n```\\nwordcount=$(head -1 file.txt | wc -w)\\ncol_n=1\\nwhile [[ $col_n -le $wordcount ]]; do\\n\\tawk \"{ print \\\\$$col_n }\" file.txt | paste -sd \" \"\\n\\tcol_n=$((col_n + 1))\\ndone\\n```\\n\\nHere\\'re some quick notes to help you understand:\\n\\nThe code block with an \"END\" prefix is only executed after the last line is read; similarly, a code block with a \"BEGIN\" prefix will be executed before any line reads.\\n\\nAWK is line-based: the main code block (the code block without prefix) processes one line of input at a time.",
                "solutionTags": [],
                "code": "```\\nwordcount=$(head -1 file.txt | wc -w)\\ncol_n=1\\nwhile [[ $col_n -le $wordcount ]]; do\\n\\tawk \"{ print \\\\$$col_n }\" file.txt | paste -sd \" \"\\n\\tcol_n=$((col_n + 1))\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1014550,
                "title": "here-is-my-simple-solution",
                "content": "```\\nnum_row=$(head -1 file.txt | wc -w)\\ni=1;\\nwhile [[ $i -le $num_row ]] ; do\\n#Print the ith column of each row and join together\\nawk \"{print \\\\$$i}\" file.txt | paste -s -d \\' \\';\\n((i=$i+1))\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\nnum_row=$(head -1 file.txt | wc -w)\\ni=1;\\nwhile [[ $i -le $num_row ]] ; do\\n#Print the ith column of each row and join together\\nawk \"{print \\\\$$i}\" file.txt | paste -s -d \\' \\';\\n((i=$i+1))\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 816087,
                "title": "simple-4-line-answer",
                "content": "```\\nncols=`head -n1 file.txt | wc -w`\\nfor i in `seq 1 $ncols`; do\\n    cat file.txt | awk \"{ print \\\\$$i }\" | xargs\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\nncols=`head -n1 file.txt | wc -w`\\nfor i in `seq 1 $ncols`; do\\n    cat file.txt | awk \"{ print \\\\$$i }\" | xargs\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55512,
                "title": "solution-using-associative-array-transpose-file",
                "content": "    # Read from the file file.txt and print its transposed content to stdout.\\n    #!/bin/bash\\n    \\n    declare -A matrix\\n    col=1\\n    row=1\\n    \\n    while read line; do\\n        col=1\\n        for word in $line; do\\n                matrix[$row,$col]=$word\\n                ((col++))\\n        done\\n        ((row++))\\n    done < file.txt\\n    \\n    for ((i=1;i<col;i++)) do\\n        echo -n ${matrix[1,$i]} \\n        for((j=2;j<row;j++)) do\\n                echo -n ' '${matrix[$j,$i]}\\n        done\\n        echo\\n    done",
                "solutionTags": [],
                "code": "    # Read from the file file.txt and print its transposed content to stdout.\\n    #!/bin/bash\\n    \\n    declare -A matrix\\n    col=1\\n    row=1\\n    \\n    while read line; do\\n        col=1\\n        for word in $line; do\\n                matrix[$row,$col]=$word\\n                ((col++))\\n        done\\n        ((row++))\\n    done < file.txt\\n    \\n    for ((i=1;i<col;i++)) do\\n        echo -n ${matrix[1,$i]} \\n        for((j=2;j<row;j++)) do\\n                echo -n ' '${matrix[$j,$i]}\\n        done\\n        echo\\n    done",
                "codeTag": "Unknown"
            },
            {
                "id": 2729918,
                "title": "cut-tr",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAll lines have same number of columns. So we may iterate  by columns.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGet number of columns and itterate over it, by getting coumn via `cut`\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfor i in $(seq $(head -1 file.txt | tr \\' \\' \\'\\\\n\\' | wc -l) ); do\\n  line=$(cut -f $i -d \\' \\' file.txt | tr \\'\\\\n\\' \\' \\')\\n  echo ${line%% }\\ndone \\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nfor i in $(seq $(head -1 file.txt | tr \\' \\' \\'\\\\n\\' | wc -l) ); do\\n  line=$(cut -f $i -d \\' \\' file.txt | tr \\'\\\\n\\' \\' \\')\\n  echo ${line%% }\\ndone \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2184394,
                "title": "for-loop-one-liner-with-cut",
                "content": "Using word count to return number of columns, and printing each column with cut.\\n```\\nfor i in $(seq 1 $(head -n1 file.txt | wc -w)); do echo $(cut -d\\' \\' -f$i file.txt); done\\n```",
                "solutionTags": [],
                "code": "```\\nfor i in $(seq 1 $(head -n1 file.txt | wc -w)); do echo $(cut -d\\' \\' -f$i file.txt); done\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 747876,
                "title": "very-simple-count-columns-and-awk-4-lines",
                "content": "```\\nnum_columns=$(head -n 1 file.txt | wc | awk \\'{print $2}\\')\\nfor i in `seq 1 $num_columns`; do\\n  awk -v i=$i \\'{print $i}\\' file.txt | xargs echo\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\nnum_columns=$(head -n 1 file.txt | wc | awk \\'{print $2}\\')\\nfor i in `seq 1 $num_columns`; do\\n  awk -v i=$i \\'{print $i}\\' file.txt | xargs echo\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 559802,
                "title": "bash-two-solutions-awk-bash",
                "content": "The first solution is to use `awk` in which we define an arrary whose `i`th element represents the `i`th column of the input. \\n\\nImplementation (8ms, 81.24%): \\n```\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        s[i] = s[i]?s[i] FS $i:$i\\n    }\\n}\\nEND {\\n    for (i in s) {\\n        print s[i]\\n    }\\n}\\' file.txt\\n```\\n\\nThe 2nd solution is to use pure bash in which we define array `arr` whose `i`th element stores the `i`th column of input. \\n\\nImplementation (144ms, 5.16%): \\n```\\ndeclare -a arr\\n\\nwhile IFS= read -r line\\ndo\\n    i=0\\n    for word in $line\\n    do\\n        [[ ${arr[$i]} ]] && arr[$i]=\"${arr[$i]} $word\" || arr[$i]=$word\\n        ((i++))\\n    done\\ndone < file.txt\\n\\nfor ((i=0; i < ${#arr[@]}; i++))\\ndo\\n    echo ${arr[i]}\\ndone\\n```\\n\\nClearly the 1st solution is superior since it is dramtically faster and shorter. Here, bash has an unpleasant fact that in range-based for loop an element with more than one word would be displayed in many lines, e.g.  \\n\\n```\\narr=(apple \"passion fruit\" banana)\\n\\nfor ele in ${arr[@]}\\ndo\\n    echo $ele\\ndone\\n```\\noutputs below in which `passion` and `fruit` are on two lines. \\n```\\napple\\npassion\\nfruit\\nbanana\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        s[i] = s[i]?s[i] FS $i:$i\\n    }\\n}\\nEND {\\n    for (i in s) {\\n        print s[i]\\n    }\\n}\\' file.txt\\n```\n```\\ndeclare -a arr\\n\\nwhile IFS= read -r line\\ndo\\n    i=0\\n    for word in $line\\n    do\\n        [[ ${arr[$i]} ]] && arr[$i]=\"${arr[$i]} $word\" || arr[$i]=$word\\n        ((i++))\\n    done\\ndone < file.txt\\n\\nfor ((i=0; i < ${#arr[@]}; i++))\\ndo\\n    echo ${arr[i]}\\ndone\\n```\n```\\narr=(apple \"passion fruit\" banana)\\n\\nfor ele in ${arr[@]}\\ndo\\n    echo $ele\\ndone\\n```\n```\\napple\\npassion\\nfruit\\nbanana\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 257710,
                "title": "one-line-ac-bash-but-runs-slow",
                "content": "\\n```\\ni=0 && for item in `head -1 file.txt `; do let i++; cut -d \\' \\' -f $i file.txt | xargs; done\\n```",
                "solutionTags": [],
                "code": "```\\ni=0 && for item in `head -1 file.txt `; do let i++; cut -d \\' \\' -f $i file.txt | xargs; done\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55515,
                "title": "my-24ms-unreadable-solution",
                "content": "    #! /bin/bash\\n    export LC_ALL=C\\n    col_num=$(awk -F' ' 'NR==1{print NF}' file.txt)\\n    awk -F' ' -v n_col=$col_num 'BEGIN{for(i=1;i<=n_col;++i) line[i]=\"\"}{for(i=1;i<=NF;++i){line[i]=sprintf(\"%s %s\", line[i], $i)}}END{for(i=1;i<=n_col;++i) print line[i]}'  file.txt | sed \"s;^ ;;g\"",
                "solutionTags": [],
                "code": "    #! /bin/bash\\n    export LC_ALL=C\\n    col_num=$(awk -F' ' 'NR==1{print NF}' file.txt)\\n    awk -F' ' -v n_col=$col_num 'BEGIN{for(i=1;i<=n_col;++i) line[i]=\"\"}{for(i=1;i<=NF;++i){line[i]=sprintf(\"%s %s\", line[i], $i)}}END{for(i=1;i<=n_col;++i) print line[i]}'  file.txt | sed \"s;^ ;;g\"",
                "codeTag": "Unknown"
            },
            {
                "id": 3006832,
                "title": "awk-command",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem can be solved by reading the input file line by line, and storing the values in each column in an array. Then, the transposed content can be printed by iterating through the array and printing the values stored in each element.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOne approach to this problem is to use the awk command to read the input file and store the values in an array. awk is a programming language designed for text processing, which makes it well-suited for this task.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThis will depend on the implementation of awk and the size of the file. In general, the time complexity of awk is linear with respect to the size of the input.\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThis will also depend on the implementation of awk and the size of the file. In general, the space complexity of awk is linear with respect to the size of the input.\\n# Code\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        if (NR == 1) {\\n            s[i] = $i;\\n        } else {\\n            s[i] = s[i] \" \" $i;\\n        }\\n    }\\n}\\nEND {\\n    for (i = 1; s[i] != \"\"; i++) {\\n        print s[i];\\n    }\\n}\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        if (NR == 1) {\\n            s[i] = $i;\\n        } else {\\n            s[i] = s[i] \" \" $i;\\n        }\\n    }\\n}\\nEND {\\n    for (i = 1; s[i] != \"\"; i++) {\\n        print s[i];\\n    }\\n}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1363331,
                "title": "easy-solution-use-awk-and-cut",
                "content": "```\\n#!/bin/bash\\n\\nc=$(cat file.txt | awk -F\\' \\' END\\'{print NF}\\');\\n\\nfor i in $(seq 1 $c);\\ndo\\n        k=$(cut -d\\' \\' -f $i file.txt);\\n        echo $k;\\ndone\\n```\\n",
                "solutionTags": [],
                "code": "```\\n#!/bin/bash\\n\\nc=$(cat file.txt | awk -F\\' \\' END\\'{print NF}\\');\\n\\nfor i in $(seq 1 $c);\\ndo\\n        k=$(cut -d\\' \\' -f $i file.txt);\\n        echo $k;\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1269297,
                "title": "pure-bash-solution",
                "content": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\ndeclare -A transposed\\nnrows=0\\nncols=0\\nwhile read -r -a row; do\\n    for ((i = 0; i < ${#row[@]}; i++)); do\\n        transposed[$i,$nrows]=${row[i]}\\n    done\\n    ((nrows++))\\n    ncols=${#row[@]}\\ndone < file.txt\\n\\nfor ((r = 0; r < ncols; r++)); do\\n    sep=\\n    for ((c = 0; c < nrows; c++)); do\\n        printf \\'%s%s\\' \"$sep\" \"${transposed[$r,$c]}\"\\n        sep=\" \"\\n    done\\n    printf \\'\\\\n\\'\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\ndeclare -A transposed\\nnrows=0\\nncols=0\\nwhile read -r -a row; do\\n    for ((i = 0; i < ${#row[@]}; i++)); do\\n        transposed[$i,$nrows]=${row[i]}\\n    done\\n    ((nrows++))\\n    ncols=${#row[@]}\\ndone < file.txt\\n\\nfor ((r = 0; r < ncols; r++)); do\\n    sep=\\n    for ((c = 0; c < nrows; c++)); do\\n        printf \\'%s%s\\' \"$sep\" \"${transposed[$r,$c]}\"\\n        sep=\" \"\\n    done\\n    printf \\'\\\\n\\'\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1187882,
                "title": "awk-using-nf-and-nr",
                "content": "```\\nawk \\'{\\n    for (i=1; i<=NF; ++i) {\\n        if (NR==1) s[i] = $i;\\n        else s[i] = s[i] \" \" $i;}\\n} \\nEND {\\n    for (i=1; i<=NF ; ++i)\\n        print s[i];\\n}\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'{\\n    for (i=1; i<=NF; ++i) {\\n        if (NR==1) s[i] = $i;\\n        else s[i] = s[i] \" \" $i;}\\n} \\nEND {\\n    for (i=1; i<=NF ; ++i)\\n        print s[i];\\n}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 699640,
                "title": "awk-simple-solution",
                "content": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\nNUM_FIELDS=`cat file.txt | head -1 | awk \\'{ print NF}\\'`\\n\\nlet count=1\\nwhile [ $count -le $NUM_FIELDS ]; do\\n    result=`cat file.txt | awk -v x=$count \\'{print $x}\\'`\\n    echo $result\\n\\nlet count+=1\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\nNUM_FIELDS=`cat file.txt | head -1 | awk \\'{ print NF}\\'`\\n\\nlet count=1\\nwhile [ $count -le $NUM_FIELDS ]; do\\n    result=`cat file.txt | awk -v x=$count \\'{print $x}\\'`\\n    echo $result\\n\\nlet count+=1\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 697637,
                "title": "horrible-perl-solution-nice-ruby-solution",
                "content": "I originally tried to solve this with a ruby oneliner, but ruby\\'s not on the system. Here\\'s my perl solution (I am not a perl coder, this is basically my best attempt to translate my ruby version below):\\n\\n```\\ncat file.txt | perl -ne \\'\\n    BEGIN {\\n        use strict;\\n        use warnings;\\n        my @in_lines = [];\\n    };\\n    push(@in_lines, [split(\" \", $_)]);\\n    END {\\n        $outer_len = @in_lines;\\n        $inner_len = @{$in_lines[0]};\\n        for (my $inner_index = 0; $inner_index < $inner_len; $inner_index++) {\\n            $first = 1;\\n            for (my $outer_index = 0; $outer_index < $outer_len; $outer_index++) {\\n                if ($first) { $first = 0; } else { print(\" \"); }\\n                print($in_lines[$outer_index]->[$inner_index]);\\n            }\\n            print(\"\\\\n\");\\n        }\\n    }\\'\\n```\\n\\nHere\\'s my ruby solution (which I think is nice):\\n```\\ncat file.txt | ruby -ne \\'\\n    BEGIN { lines = []; }\\n    lines << $_.split(\" \");\\n    END { puts lines.transpose.map { |sub| sub.join(\" \")}; }\\'\\n```",
                "solutionTags": [],
                "code": "```\\ncat file.txt | perl -ne \\'\\n    BEGIN {\\n        use strict;\\n        use warnings;\\n        my @in_lines = [];\\n    };\\n    push(@in_lines, [split(\" \", $_)]);\\n    END {\\n        $outer_len = @in_lines;\\n        $inner_len = @{$in_lines[0]};\\n        for (my $inner_index = 0; $inner_index < $inner_len; $inner_index++) {\\n            $first = 1;\\n            for (my $outer_index = 0; $outer_index < $outer_len; $outer_index++) {\\n                if ($first) { $first = 0; } else { print(\" \"); }\\n                print($in_lines[$outer_index]->[$inner_index]);\\n            }\\n            print(\"\\\\n\");\\n        }\\n    }\\'\\n```\n```\\ncat file.txt | ruby -ne \\'\\n    BEGIN { lines = []; }\\n    lines << $_.split(\" \");\\n    END { puts lines.transpose.map { |sub| sub.join(\" \")}; }\\'\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 634826,
                "title": "similar-to-solution-using-awk-jut-the-for-loop-is-simple",
                "content": "```\\nawk \\'{ for (i=1; i<=NF; i++) {\\n            if (NR==1) s[i]=$i; \\n            else s[i] = s[i] \" \" $i;\\n        }\\n     } END { for (i in s) print s[i] }\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'{ for (i=1; i<=NF; i++) {\\n            if (NR==1) s[i]=$i; \\n            else s[i] = s[i] \" \" $i;\\n        }\\n     } END { for (i in s) print s[i] }\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 604975,
                "title": "script-using-awk",
                "content": "```\\nnumColumns=`head -1 file.txt | awk \\'{print NF}\\'`\\ni=1\\nwhile [ $i -le $numColumns ]\\ndo\\nawk -v ind=$i \\'{print $ind}\\' file.txt | xargs\\ni=`expr $i + 1`\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\nnumColumns=`head -1 file.txt | awk \\'{print NF}\\'`\\ni=1\\nwhile [ $i -le $numColumns ]\\ndo\\nawk -v ind=$i \\'{print $ind}\\' file.txt | xargs\\ni=`expr $i + 1`\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 561434,
                "title": "simple-fast-readable-awk-solution-4ms-3-5mb",
                "content": "I spent way too long getting the hang of `awk` to make this happen.\\n\\nopted for concatenating each column into its own string, separated by a space.\\n\\n```\\ncat file.txt | awk \\'\\n{\\n    for(i=1; i <= NF; i++){\\n        data[i] = ((i in data) ? data[i] \" \" : \"\") $i\\n    }\\n} END {\\n    for(i in data){\\n        print data[i]\\n    }\\n}\\'\\n```\\n\\nI think this should work even on variable number of columns.",
                "solutionTags": [],
                "code": "```\\ncat file.txt | awk \\'\\n{\\n    for(i=1; i <= NF; i++){\\n        data[i] = ((i in data) ? data[i] \" \" : \"\") $i\\n    }\\n} END {\\n    for(i in data){\\n        print data[i]\\n    }\\n}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 520760,
                "title": "awk-solution-use-array",
                "content": "```\\ncat file.txt | awk \\'BEGIN{fs=ofs=\" \";dic[0] = 0;count=0}{for(i=1;i<=NF;i+=1){if(length(dic[i])==0){dic[i]=$i}else{dic[i]=dic[i]\" \"$i}}; count=NF}END{for(i=1;i<=count;i+=1){print dic[i]}}\\'\\n```",
                "solutionTags": [],
                "code": "```\\ncat file.txt | awk \\'BEGIN{fs=ofs=\" \";dic[0] = 0;count=0}{for(i=1;i<=NF;i+=1){if(length(dic[i])==0){dic[i]=$i}else{dic[i]=dic[i]\" \"$i}}; count=NF}END{for(i=1;i<=count;i+=1){print dic[i]}}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 417403,
                "title": "nice-and-easy",
                "content": "```\\ncol=\"$(head -1 file.txt | wc -w)\"\\n\\nfor i in $(seq 1 $col);do awk \\'{ print $\\'$i\\' }\\' file.txt | paste -s -d\" \";done\\n```",
                "solutionTags": [],
                "code": "```\\ncol=\"$(head -1 file.txt | wc -w)\"\\n\\nfor i in $(seq 1 $col);do awk \\'{ print $\\'$i\\' }\\' file.txt | paste -s -d\" \";done\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 316934,
                "title": "simple-awk-solution",
                "content": "```\\nawk \\' { for (i = 1; i <= NF; ++i)  if (NR == 1) cols[i] = $i;  else  cols[i] =  cols[i] \" \" $i } END { for (i in cols) print cols[i]}\\' file.txt \\n```",
                "solutionTags": [],
                "code": "```\\nawk \\' { for (i = 1; i <= NF; ++i)  if (NR == 1) cols[i] = $i;  else  cols[i] =  cols[i] \" \" $i } END { for (i in cols) print cols[i]}\\' file.txt \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 227458,
                "title": "using-awk",
                "content": "```\\nawk \\'\\n{ \\n    for (i=1; i<=NF; i++)  {\\n        a[NR,i] = $i\\n    }\\n}\\nNF>p { p = NF }\\nEND {    \\n    for(j=1; j<=p; j++) {\\n        str=a[1,j]\\n        for(i=2; i<=NR; i++){\\n            str=str\" \"a[i,j];\\n        }\\n        print str\\n    }\\n}\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'\\n{ \\n    for (i=1; i<=NF; i++)  {\\n        a[NR,i] = $i\\n    }\\n}\\nNF>p { p = NF }\\nEND {    \\n    for(j=1; j<=p; j++) {\\n        str=a[1,j]\\n        for(i=2; i<=NR; i++){\\n            str=str\" \"a[i,j];\\n        }\\n        print str\\n    }\\n}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 193762,
                "title": "solution-with-perl",
                "content": "Actually Perl is allowed.\\n```\\nperl -e \\'$i=0;while(<>){$j=0;foreach(split){$file[$i][$j]=$_;$j++;}$i++;}foreach $jj (0..$j-1){\\nforeach $ii (0..$i-1){$output.=$file[$ii][$jj];$output.=$ii==$i-1?\"\":\" \";}$output.=\"\\\\n\";}\\nprint $output;\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nperl -e \\'$i=0;while(<>){$j=0;foreach(split){$file[$i][$j]=$_;$j++;}$i++;}foreach $jj (0..$j-1){\\nforeach $ii (0..$i-1){$output.=$file[$ii][$jj];$output.=$ii==$i-1?\"\":\" \";}$output.=\"\\\\n\";}\\nprint $output;\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55504,
                "title": "ac-solution-using-python3",
                "content": "just share my simple solution\\n```\\npython3 <<EOF\\nmatrix = [line[:-1].split(' ') for line in open('file.txt')]\\nfor column in range(len(matrix[0])):\\n    print(*(matrix[row][column] for row in range(len(matrix))))\\nEOF\\n```\\n`<<EOF` is really a helpful syntax",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\npython3 <<EOF\\nmatrix = [line[:-1].split(' ') for line in open('file.txt')]\\nfor column in range(len(matrix[0])):\\n    print(*(matrix[row][column] for row in range(len(matrix))))\\nEOF\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4092401,
                "title": "jidejj",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\n#!/bin/bash\\n\\n# Define the input file\\ninput_file=\"file.txt\"\\n\\n# Check if the file exists\\nif [ ! -f \"$input_file\" ]; then\\n    echo \"File not found: $input_file\"\\n    exit 1\\nfi\\n\\n# Use awk to transpose the file content\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        if (NR == 1) {\\n            rows[i] = $i;\\n        } else {\\n            rows[i] = rows[i] \" \" $i;\\n        }\\n    }\\n}\\nEND {\\n    for (i = 1; i <= NF; i++) {\\n        print rows[i];\\n    }\\n}\\n\\' \"$input_file\"\\n                                \\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\n#!/bin/bash\\n\\n# Define the input file\\ninput_file=\"file.txt\"\\n\\n# Check if the file exists\\nif [ ! -f \"$input_file\" ]; then\\n    echo \"File not found: $input_file\"\\n    exit 1\\nfi\\n\\n# Use awk to transpose the file content\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        if (NR == 1) {\\n            rows[i] = $i;\\n        } else {\\n            rows[i] = rows[i] \" \" $i;\\n        }\\n    }\\n}\\nEND {\\n    for (i = 1; i <= NF; i++) {\\n        print rows[i];\\n    }\\n}\\n\\' \"$input_file\"\\n                                \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4017176,
                "title": "awk-gets-the-job-done",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen approaching this problem, the first thing that comes to mind is finding a way to swap the rows and columns of the file content. To achieve this, we need to think about how to read the file and store its content in a way that allows for easy transposition. We can then output the transposed content to the console or another file.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo solve this problem, we will use the `awk` command-line utility, which is a powerful tool for text processing.\\n\\nIn the code, we start by defining an awk script enclosed in single quotes. The script consists of two parts: the main code block and the `END` block.\\n\\nIn the main code block, we iterate over each line of the input file using the default behavior of awk. For each line, we use a for loop to iterate over the fields `$i` separated by whitespace. We then store each field in the array `a` with the column index `i` and the row index `NR`, which represents the current line number.\\n\\nAfter processing all the lines, we move to the `END` block. Here, we iterate over the array `a` by nested for loops. The outer loop iterates over the columns `i`, and the inner loop iterates over the rows `j`. We use the `printf` statement to print the transposed content by accessing the elements of the array with the indices `a[i, j]`. We add the appropriate separators (`RS` for the end of a row and `FS` for the space between elements) to format the output correctly.\\n\\nFinally, we execute the `awk` command by passing the input file `file.txt` as an argument. The transposed content is then printed to the standard output `stdout`.\\n\\nUsing `awk` allows us to efficiently read and process the file, store the content in an array, and print the transposed result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$, where $$n$$ represents the total number of elements in the input file. This is because we need to iterate over each line and each field in the file to store them in the array. The nested loops in the `END` block also contribute to the linear time complexity.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ because we need to store the content of the input file in the array `a`. The size of the array depends on the number of elements in the file, which is directly proportional to the space complexity. The additional space used by variables and temporary storage is negligible compared to the size of the input file.\\n# Runtime & Memory\\n![Screenshot 2023-09-08 at 11.52.36.png](https://assets.leetcode.com/users/images/f72741b1-5778-47f3-b2f9-eebced5848af_1694156608.758566.png)\\n\\n# Code\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        a[i, NR] = $i\\n    }\\n}\\nEND {\\n    for (i = 1; i <= NF; i++) {\\n        for (j = 1; j <= NR; j++) {\\n            printf \"%s%s\", a[i, j], (j == NR ? RS : FS)\\n        }\\n    }\\n}\\n\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        a[i, NR] = $i\\n    }\\n}\\nEND {\\n    for (i = 1; i <= NF; i++) {\\n        for (j = 1; j <= NR; j++) {\\n            printf \"%s%s\", a[i, j], (j == NR ? RS : FS)\\n        }\\n    }\\n}\\n\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3938515,
                "title": "perl-solution",
                "content": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\n\\nperl <<\\'EOF\\' - file.txt\\n    my @rows;\\n    while (<>) {\\n        my @words = split /\\\\s+/;\\n        foreach my $i (0 .. $#words) {\\n            push @{$rows[$i]}, $words[$i];\\n        }\\n    }\\n    print join(\\' \\' => @$_), \"\\\\n\" for (@rows)\\nEOF\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\n\\nperl <<\\'EOF\\' - file.txt\\n    my @rows;\\n    while (<>) {\\n        my @words = split /\\\\s+/;\\n        foreach my $i (0 .. $#words) {\\n            push @{$rows[$i]}, $words[$i];\\n        }\\n    }\\n    print join(\\' \\' => @$_), \"\\\\n\" for (@rows)\\nEOF\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3919684,
                "title": "bash-no-awk-just-bash-arrays",
                "content": "The best performimg solution to this problem use `awk`, but I wanted to see if I could to this using bash arrays instead.\\n\\nIt possible, but it\\'s not pretty...\\n\\n# Code\\n```\\ninput=\"file.txt\"\\ndeclare -a lines=()\\n\\nrows=$((0))\\n\\n# Read the input into an array\\n# bash does not seem to support 2D arrays\\n# so it\\'s just 1D\\nwhile IFS=\\' \\' read -a line\\ndo\\n  columns=${#line[@]}\\n  rows=$(($rows + 1))\\n  lines=(${lines[@]} ${line[@]})\\ndone < \"$input\"\\n\\n\\n# Index into the array to transpose it\\n# building output line by line\\nfor ((c = 0; c < $columns; c++ ))\\ndo\\n  line=${lines[$c]}\\n  for ((r = 1; r < $rows; r++)) do\\n    line=\"$line ${lines[$(($c + $r * $columns))]}\"\\n  done\\n  echo $line\\ndone\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ninput=\"file.txt\"\\ndeclare -a lines=()\\n\\nrows=$((0))\\n\\n# Read the input into an array\\n# bash does not seem to support 2D arrays\\n# so it\\'s just 1D\\nwhile IFS=\\' \\' read -a line\\ndo\\n  columns=${#line[@]}\\n  rows=$(($rows + 1))\\n  lines=(${lines[@]} ${line[@]})\\ndone < \"$input\"\\n\\n\\n# Index into the array to transpose it\\n# building output line by line\\nfor ((c = 0; c < $columns; c++ ))\\ndo\\n  line=${lines[$c]}\\n  for ((r = 1; r < $rows; r++)) do\\n    line=\"$line ${lines[$(($c + $r * $columns))]}\"\\n  done\\n  echo $line\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3807270,
                "title": "bash-awk",
                "content": "```\\n#!/bin/bash\\n\\nawk \\'\\n{\\n    # loop over words in curr line\\n    for (i = 1; i <= NF; i++) {\\n        # if first line\\n        if(NR == 1) {\\n            # init array ans[i] with first word of each line\\n            ans[i] = $i;\\n        } else {\\n            # append words to ans[i]\\n            ans[i] = ans[i] \" \" $i;\\n        }\\n    }\\n}\\nEND {\\n    # print ans array\\n    for (i = 1; ans[i] != \"\"; i++) {\\n        print ans[i];\\n    }\\n}\\' file.txt\\n\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```\\n#!/bin/bash\\n\\nawk \\'\\n{\\n    # loop over words in curr line\\n    for (i = 1; i <= NF; i++) {\\n        # if first line\\n        if(NR == 1) {\\n            # init array ans[i] with first word of each line\\n            ans[i] = $i;\\n        } else {\\n            # append words to ans[i]\\n            ans[i] = ans[i] \" \" $i;\\n        }\\n    }\\n}\\nEND {\\n    # print ans array\\n    for (i = 1; ans[i] != \"\"; i++) {\\n        print ans[i];\\n    }\\n}\\' file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3713407,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nseq 1 $(head -1 file.txt | wc -w) | xargs -I \\'{}\\' bash -c \"cut -d \\'\"\\' \\'\"\\' -f {} file.txt| xargs\"\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nseq 1 $(head -1 file.txt | wc -w) | xargs -I \\'{}\\' bash -c \"cut -d \\'\"\\' \\'\"\\' -f {} file.txt| xargs\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3598971,
                "title": "solution-using-loop-bash-hyder-nabi",
                "content": "# Complexity \\nM: No of Lines\\nN: No of Words in each Line\\n- Time complexity: $$O(M*N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(M*N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\n\\nfile=\"file.txt\"\\nwhile read line; do\\n\\tIFS=\\' \\' read -ra Arr <<< \"$line\";\\n\\tfor j in ${!Arr[@]}; do\\n\\t\\tmat[j]+=\" ${Arr[j]}\";\\n\\tdone\\t\\ndone < $file;\\n\\nfor i in ${!mat[@]}; do\\n\\techo ${mat[i]};\\ndone;\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\n\\nfile=\"file.txt\"\\nwhile read line; do\\n\\tIFS=\\' \\' read -ra Arr <<< \"$line\";\\n\\tfor j in ${!Arr[@]}; do\\n\\t\\tmat[j]+=\" ${Arr[j]}\";\\n\\tdone\\t\\ndone < $file;\\n\\nfor i in ${!mat[@]}; do\\n\\techo ${mat[i]};\\ndone;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3514033,
                "title": "awk-please-don-t-roast-my-bash-i-am-python-noob-arch-linux-sheesh",
                "content": "# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\nThis script uses awk to read the input file and transpose its content. It maintains an array transposed where each element represents a column in the transposed output. For each row, it appends the corresponding fields to the respective column in the transposed array. Finally, it prints the transposed content.\\r\\n\\r\\nThis approach is more efficient for larger inputs compared to reading the file into an array in Bash. It leverages the power of awk for handling large datasets efficiently.\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n$$O(NM)$$\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n$$O(N)$$\\r\\n# Code\\r\\n```\\r\\n#!/bin/bash\\r\\n\\r\\n# Use awk to transpose the content\\r\\nawk \\'\\r\\n{\\r\\n    for (i=1; i<=NF; i++) {\\r\\n        if (NR == 1) {\\r\\n            # For the first row, create an array with the fields as columns\\r\\n            transposed[i] = $i\\r\\n        } else {\\r\\n            # For subsequent rows, append the fields to the corresponding column\\r\\n            transposed[i] = transposed[i] \" \" $i\\r\\n        }\\r\\n    }\\r\\n}\\r\\nEND {\\r\\n    # Print the transposed content\\r\\n    for (i=1; i<=NF; i++) {\\r\\n        print transposed[i]\\r\\n    }\\r\\n}\\' file.txt\\r\\n\\r\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\r\\n#!/bin/bash\\r\\n\\r\\n# Use awk to transpose the content\\r\\nawk \\'\\r\\n{\\r\\n    for (i=1; i<=NF; i++) {\\r\\n        if (NR == 1) {\\r\\n            # For the first row, create an array with the fields as columns\\r\\n            transposed[i] = $i\\r\\n        } else {\\r\\n            # For subsequent rows, append the fields to the corresponding column\\r\\n            transposed[i] = transposed[i] \" \" $i\\r\\n        }\\r\\n    }\\r\\n}\\r\\nEND {\\r\\n    # Print the transposed content\\r\\n    for (i=1; i<=NF; i++) {\\r\\n        print transposed[i]\\r\\n    }\\r\\n}\\' file.txt\\r\\n\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3420456,
                "title": "bash-command-concise-code-steps-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. This script uses awk, a text processing tool, to read the contents of the file and transpose them. Here\\'s how it works:\\n\\n2. For each field in each row of the input file, it stores the field in an array a with indices i (column) and NR (row number).\\n\\n3. After reading the entire file, it loops over the columns and rows of the array a, printing each element separated by a space. When it reaches the end of a row, it prints a newline character.\\n\\n\\n# Complexity\\n\\n1. Reading the file into a 2D array takes O(NM) time and O(NM) space, where N is the number of rows in the file, M is the number of columns in the file, and we assume that each field is of constant length.\\n\\n2. Transposing the array takes O(NM) time and O(NM) space, since we are constructing a new 2D array with dimensions M x N.\\n\\n3. Printing the transposed array takes O(N*M) time and O(1) space, since we are just printing each element once.\\n- Time complexity: O(NM)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(NM)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\nawk \\'{for (i=1; i<=NF; i++) {a[i,NR]=$i}} END {for (i=1; i<=NF; i++) {for (j=1; j<=NR; j++) {printf(\"%s\",a[i,j]); if (j!=NR) printf(\" \");} printf(\"\\\\n\")}}\\' file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\nawk \\'{for (i=1; i<=NF; i++) {a[i,NR]=$i}} END {for (i=1; i<=NF; i++) {for (j=1; j<=NR; j++) {printf(\"%s\",a[i,j]); if (j!=NR) printf(\" \");} printf(\"\\\\n\")}}\\' file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3389186,
                "title": "transpose-file-bash",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\n\\ncolumn=$(cat file.txt | head -n 1 | wc -w)\\n\\ni=1\\nwhile [ $i -le $column ]\\ndo\\n    cat file.txt | cut -d \\' \\' -f $i | tr \\'\\\\n\\' \\' \\' | rev | cut -c2- | rev\\n    let i=i+1\\ndone\\n\\nexit 0\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\n\\ncolumn=$(cat file.txt | head -n 1 | wc -w)\\n\\ni=1\\nwhile [ $i -le $column ]\\ndo\\n    cat file.txt | cut -d \\' \\' -f $i | tr \\'\\\\n\\' \\' \\' | rev | cut -c2- | rev\\n    let i=i+1\\ndone\\n\\nexit 0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3370714,
                "title": "194-transpose-file",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe task is to transpose the given text file, which means we need to convert the rows of the file to columns and vice versa.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOne way to approach this problem is to use a bash script that reads the text file line by line, splits each line using the space delimiter, and stores the values in an array. Then, we can use another loop to iterate over the columns and store them in a separate array. Finally, we can print the transposed content of the file by iterating over the columns and printing each row.\\n\\n# Algorithm\\nRead the text file line by line using a loop\\nFor each line, split the line using the space delimiter and store the values in an array\\nUse another loop to iterate over the columns and store them in a separate array\\nFinally, print the transposed content of the file by iterating over the columns and printing each row\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this approach is O(m*n), where m is the number of rows and n is the number of columns in the text file. This is because we need to read each line of the file and split it into an array of n elements\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this approach is also O(m*n) because we need to store the entire contents of the file in an array of m rows and n columns. However, since we are transposing the content of the file, we only need to store the transpose of the file, which means we can optimize the space complexity by storing only n rows and m columns.\\n# Code\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\nawk \\'{ for(i=1; i<=NF; i++) { a[i,NR]=$i; } } END { for(i=1; i<=NF; i++) { printf(\"%s\", a[i,1]); for(j=2; j<=NR; j++) { printf(\" %s\", a[i,j]); } printf(\"\\\\n\"); } }\\' file.txt\\n\\n```\\nThis command reads the content of file.txt and creates an array a to store the values. The first loop for(i=1; i<=NF; i++) iterates over the columns and rows of the file, and assigns the value of each field to the corresponding position in the array (a[i,NR]=$i). The second loop for(i=1; i<=NF; i++) iterates over the columns of the array, and prints the values of each row in transposed order (printf(\"%s\", a[i,1]); for(j=2; j<=NR; j++) { printf(\" %s\", a[i,j]); } printf(\"\\\\n\");).\\n\\nThe time complexity of this solution is O(mn), where m is the number of rows and n is the number of columns in the file. The space complexity is also O(mn), since the entire file is stored in the a array.",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\nawk \\'{ for(i=1; i<=NF; i++) { a[i,NR]=$i; } } END { for(i=1; i<=NF; i++) { printf(\"%s\", a[i,1]); for(j=2; j<=NR; j++) { printf(\" %s\", a[i,j]); } printf(\"\\\\n\"); } }\\' file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3368166,
                "title": "solution-using-awk",
                "content": "# Code\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\nawk \\'{\\n    for(i=1;i<=NF;++i)columns[i][NR]=$i;\\n}\\nEND {\\n    for(c in columns) {\\n        has_elem=0;\\n        for(l in columns[c]) {\\n            if(has_elem==1) printf(\" \");\\n            has_elem=1;\\n            printf(\"%s\", columns[c][l]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n}\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\nawk \\'{\\n    for(i=1;i<=NF;++i)columns[i][NR]=$i;\\n}\\nEND {\\n    for(c in columns) {\\n        has_elem=0;\\n        for(l in columns[c]) {\\n            if(has_elem==1) printf(\" \");\\n            has_elem=1;\\n            printf(\"%s\", columns[c][l]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3360683,
                "title": "concise-and-easy-solution-using-temporary-files",
                "content": "# Intuition\\nRead file line by line, transform each line into a column (multiple lines) and save column somewhere for later. At the end combine all columns.\\n\\n# Approach\\nEach line from file is piped to `tr`, which transforms the line to a column by replacing spaces with line breaks. These lines are saved to a temporary file, whose name is remembered in `columnFiles` variable.\\nAfter reading all lines from input file, `paste` combines column-files side-by-side.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n + m)$$, where `n` is the number of lines in input file (for reading input); `m` is the number of columns in input file (for combining columns).\\n\\n- Space complexity:\\n$$O(n)$$ memory space, where `n` is a number of lines in input file. The variable holding names of column-files grows with the number of lines (lines are transformed to columns).\\n$$O(n)$$ disk space, where `n` is the size of input file. Solution effectively makes a copy of input file, but splitted to chunks.\\n\\n# Code\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\n\\n# The idea is to transform each line in to a column (multiple lines)\\n# and save it to a separate file. Then combine all columns using `paste`\\n# command, which reads lines from multiple sources and outputs all\\n# that lines joined.\\n\\ncolumnFiles=\"\"\\n\\nwhile read -r line\\ndo\\n    columnFileName=\"$(mktemp)\"\\n    # I use `tee` to save output to file because testing environment forbids output\\n    # redirections. \\n    # The \\'while read\\' cycle after `tee` suppresses tee\\'s output, because, again,\\n    # no output redirections are allowed and 2>/dev/null is not available.\\n    echo \"$line\" | tr -s \\' \\' \\'\\\\n\\' | tee  \"$columnFileName\" | while read -r suppressed; do true; done\\n    columnFiles=\"$columnFiles $columnFileName\"\\ndone <file.txt\\n\\npaste -d \\' \\' $columnFiles\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\n\\n# The idea is to transform each line in to a column (multiple lines)\\n# and save it to a separate file. Then combine all columns using `paste`\\n# command, which reads lines from multiple sources and outputs all\\n# that lines joined.\\n\\ncolumnFiles=\"\"\\n\\nwhile read -r line\\ndo\\n    columnFileName=\"$(mktemp)\"\\n    # I use `tee` to save output to file because testing environment forbids output\\n    # redirections. \\n    # The \\'while read\\' cycle after `tee` suppresses tee\\'s output, because, again,\\n    # no output redirections are allowed and 2>/dev/null is not available.\\n    echo \"$line\" | tr -s \\' \\' \\'\\\\n\\' | tee  \"$columnFileName\" | while read -r suppressed; do true; done\\n    columnFiles=\"$columnFiles $columnFileName\"\\ndone <file.txt\\n\\npaste -d \\' \\' $columnFiles\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3349525,
                "title": "really-simple-solution-using-bash-script",
                "content": "Just iterate over each column and print the corresponding row.\\n\\n# Code\\n```\\n#!/bin/sh\\ncols=$(awk \\'{print NF}\\' file.txt | sort -nu | tail -n 1)\\nfor (( c=1; c<=$cols; c++ ))\\ndo  \\n    cat file.txt | awk -v x=$c \\'{print $x}\\' | paste -s -d \\' \\'\\ndone\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n#!/bin/sh\\ncols=$(awk \\'{print NF}\\' file.txt | sort -nu | tail -n 1)\\nfor (( c=1; c<=$cols; c++ ))\\ndo  \\n    cat file.txt | awk -v x=$c \\'{print $x}\\' | paste -s -d \\' \\'\\ndone\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3266001,
                "title": "just-builtins-one-file-pass",
                "content": "Loop over lines, gather line items into successive array elements.  Dump the array afterwards.\\n\\nPure in-memory (filter-like) program: memory consumption is proportional to the file size.\\n\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\n# Bash version, uses arrays.  One pass over the input file.\\n\\nexec < file.txt\\n\\nread -r z\\nl=($z)\\n\\nwhile read -r z; do\\n    i=0\\n    for v in $z; do\\n            l[$i]+=\" $v\"\\n            ((i++))\\n    done\\ndone\\n\\nz=${#l[@]}\\nfor ((i=0; i < $z; i++)); do\\n    echo \"${l[$i]}\"\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\n# Bash version, uses arrays.  One pass over the input file.\\n\\nexec < file.txt\\n\\nread -r z\\nl=($z)\\n\\nwhile read -r z; do\\n    i=0\\n    for v in $z; do\\n            l[$i]+=\" $v\"\\n            ((i++))\\n    done\\ndone\\n\\nz=${#l[@]}\\nfor ((i=0; i < $z; i++)); do\\n    echo \"${l[$i]}\"\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3143221,
                "title": "transpose-file-using-cut-and-awk-explanation",
                "content": "# Approach\\n1. With the help of awk count amount of columns in file\\n2. Make iterator i equal to amount of columns in file\\n3. In for-loop cut columns in file one by one\\n4. Send column to the output\\n\\n# Code\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\n#!/bin/bash\\n\\ncolumns=$(cat \"file.txt\" | awk -F \\' \\' END\\'{print NF}\\')\\nfor i in $(seq 1 $columns)\\ndo\\noutput=$(cut -f $i -d \\' \\' \"file.txt\")\\necho $output\\ndone\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\n#!/bin/bash\\n\\ncolumns=$(cat \"file.txt\" | awk -F \\' \\' END\\'{print NF}\\')\\nfor i in $(seq 1 $columns)\\ndo\\noutput=$(cut -f $i -d \\' \\' \"file.txt\")\\necho $output\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3134897,
                "title": "transpose-file-solution",
                "content": "```\\npython3 <<EOF\\nmatrix = [line[:-1].split(\\' \\') for line in open(\\'file.txt\\')]\\nfor column in range(len(matrix[0])):\\n    print(*(matrix[row][column] for row in range(len(matrix))))\\nEOF\\n```# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npython3 <<EOF\\nmatrix = [line[:-1].split(\\' \\') for line in open(\\'file.txt\\')]\\nfor column in range(len(matrix[0])):\\n    print(*(matrix[row][column] for row in range(len(matrix))))\\nEOF\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\npython3 <<EOF\\nmatrix = [line[:-1].split(\\' \\') for line in open(\\'file.txt\\')]\\nfor column in range(len(matrix[0])):\\n    print(*(matrix[row][column] for row in range(len(matrix))))\\nEOF\\n```\n```\\npython3 <<EOF\\nmatrix = [line[:-1].split(\\' \\') for line in open(\\'file.txt\\')]\\nfor column in range(len(matrix[0])):\\n    print(*(matrix[row][column] for row in range(len(matrix))))\\nEOF\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3125300,
                "title": "clean-bash-code-high-speed-beats-98-9",
                "content": "\\n# Code\\n```\\n#!/bin/bash\\n\\ncolumn=$(cat file.txt | head -n 1 | wc -w)\\n\\ni=1\\nwhile [ $i -le $column ]\\ndo\\n    cat file.txt | cut -d \\' \\' -f $i | tr \\'\\\\n\\' \\' \\' | rev | cut -c2- | rev\\n    let i=i+1\\ndone\\n\\nexit 0\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n#!/bin/bash\\n\\ncolumn=$(cat file.txt | head -n 1 | wc -w)\\n\\ni=1\\nwhile [ $i -le $column ]\\ndo\\n    cat file.txt | cut -d \\' \\' -f $i | tr \\'\\\\n\\' \\' \\' | rev | cut -c2- | rev\\n    let i=i+1\\ndone\\n\\nexit 0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3046056,
                "title": "very-detailed-solution-easy-to-understande",
                "content": "# Intuition\\nFirst you need to know what\\'s the number of columns?\\n\\n# Approach\\n1) Using `wc` word count to count the number of lines and the number of words.\\n2) Given that the number of columns is the same in every line you can get the number of columns by `columns = words / lines`.\\n3) Iterate over each column to using `cut` with a `space` as delimiter with specifying the field number.\\n4) Using `tr` you can print the output in a single line by replacing the `newline` with the  `space`. \\n\\n# Code\\n```\\n#!/bin/bash\\nlines=$(cat file.txt |wc -l)\\nwords=$(cat file.txt |wc -w)\\ncolumns=$(($words/$lines))\\n\\nfor (( i=1;i<=$columns;i++ ));\\ndo\\n        echo $(cat file.txt | cut -d \" \" -f $i | tr \\'\\\\n\\' \\' \\') \\ndone  \\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n#!/bin/bash\\nlines=$(cat file.txt |wc -l)\\nwords=$(cat file.txt |wc -w)\\ncolumns=$(($words/$lines))\\n\\nfor (( i=1;i<=$columns;i++ ));\\ndo\\n        echo $(cat file.txt | cut -d \" \" -f $i | tr \\'\\\\n\\' \\' \\') \\ndone  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2989965,
                "title": "my-try",
                "content": "I count the number of columns (as specified they\\'ll be always the same on each line), Then use that number for specify the column to get with awk, then it\\'s easy to convert end lines to spaces and print that line. Doing this for every column will invert the matrix.\\n\\n# Code\\n```\\nNUM=\"$(sed \\'1q;d\\' file.txt | wc -w)\"; for ((i = 1; i <= $NUM; i++));do awk \"{ print \\\\${i} }\" < file.txt | tr \\'\\\\n\\' \\' \\' | xargs; done\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nNUM=\"$(sed \\'1q;d\\' file.txt | wc -w)\"; for ((i = 1; i <= $NUM; i++));do awk \"{ print \\\\${i} }\" < file.txt | tr \\'\\\\n\\' \\' \\' | xargs; done\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2950901,
                "title": "transpose-a-file-without-using-awk-simple-soln",
                "content": "# Code\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\nword_count=$(cat file.txt | head -n 1 | wc -w)\\nfor (( i=1; i<=word_count; i++ ));do\\n  cat file.txt | cut -d \\' \\' -f $i | tr \\'\\\\n\\' \\' \\' |  sed \\'s/.$//\\'\\n  echo\\ndone\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\nword_count=$(cat file.txt | head -n 1 | wc -w)\\nfor (( i=1; i<=word_count; i++ ));do\\n  cat file.txt | cut -d \\' \\' -f $i | tr \\'\\\\n\\' \\' \\' |  sed \\'s/.$//\\'\\n  echo\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2923860,
                "title": "194-transpose-file-by-boolean-autocrats",
                "content": "# Intuition\\nTo transpose the content of a text file, we can read the lines of the file and store each field in an array, with the array index representing the column number. Then, we can iterate over the array and print each element, which represents a transposed row of the file.\\n\\nIn this solution, I used the awk command to read the lines of the file and transpose the content. The awk command is a powerful text-processing utility that can be used to perform complex operations on text files. It reads the input line by line and allows you to specify actions to be taken based on the contents of the input.\\n\\nTo transpose the content of the file, I used the NF variable, which represents the number of fields in the current line, and the NR variable, which represents the current line number. I iterated over the fields of each line and stored them in an array s, with the array index representing the column number. If the current line was the first line of the file, I stored the field in the corresponding array index. If the current line was not the first line, I appended the field to the value stored in the corresponding array index, separated by a space character.\\n\\nFinally, after all the lines of the file had been processed, I iterated over the array and printed each element, which represented a transposed row of the file.\\n\\nI hope this helps to clarify the intuition behind the Bash solution I provided. Let me know if you have any problem in this questions.\\n\\n# Approach\\nThe approach I used to solve this problem was to use the awk command to read the lines of the file and transpose the content.\\n\\nTo do this, I used the NF variable, which represents the number of fields in the current line, and the NR variable, which represents the current line number. I iterated over the fields of each line and stored them in an array s, with the array index representing the column number. If the current line was the first line of the file, I stored the field in the corresponding array index. If the current line was not the first line, I appended the field to the value stored in the corresponding array index, separated by a space character.\\n\\nFinally, after all the lines of the file had been processed, I iterated over the array and printed each element, which represented a transposed row of the file.\\n\\nI hope this helps to clarify the approach I took to solve this problem. Let me know if you have any problem in this questions.\\n# Complexity\\n- Time complexity:The time complexity of the Bash solution I provided for this problem is O(n), where n is the number of lines in the input file.\\n\\nThe awk command reads the input line by line and processes each line in constant time. Therefore, the time complexity of the solution is determined by the number of lines in the input file.\\n\\nIn this solution, I used a loop to iterate over the fields of each line and store them in an array. I also used another loop to iterate over the array and print each element. Both of these loops execute in O(n) time, since they iterate over all the lines of the input file.\\n\\nTherefore, the overall time complexity of this solution is O(n), since it involves two loops that each execute in O(n) time.\\n\\nI hope this helps! Let me know if you have any problem in this questions.\\n\\n\\n- Space complexity:The space complexity of the Bash solution I provided for this problem is O(n), where n is the number of lines in the input file.\\n\\nThis solution stores each field of the input file in an array, with the array index representing the column number. Therefore, the space complexity is determined by the size of the array, which is equal to the number of lines in the input file.\\n\\nIn addition to the array, this solution also uses a few variables to store intermediate results and control the execution of the loops. However, these variables have a constant size and do not contribute significantly to the space complexity of the solution.\\n\\nTherefore, the overall space complexity of this solution is O(n), since it involves storing all the fields of the input file in an array of size n.\\n\\n\\n# Code\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\nawk \\'\\n{\\n  for (i=1; i<=NF; i++) {\\n    if(NR == 1) {\\n      s[i] = $i;\\n    } else {\\n      s[i] = s[i] \" \" $i;\\n    }\\n  }\\n}\\nEND {\\n  for (i=1; s[i] != \"\"; i++) {\\n    print s[i];\\n  }\\n}\\n\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\nawk \\'\\n{\\n  for (i=1; i<=NF; i++) {\\n    if(NR == 1) {\\n      s[i] = $i;\\n    } else {\\n      s[i] = s[i] \" \" $i;\\n    }\\n  }\\n}\\nEND {\\n  for (i=1; s[i] != \"\"; i++) {\\n    print s[i];\\n  }\\n}\\n\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2887070,
                "title": "bash-script-pipes-and-redirections",
                "content": "# Intuition\\nUsing pipes and redirections \\nUsing cut -f to select column by column\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst, count the number of columns.\\nThen, start a while with a variabile counter i to cut column by column the input file.\\nFor each column, command tr transpose it to a row, but it adds a \\' \\' (space) at the end of the row. \\nTo overcome this issue (believe me, I failed a submission due to it), the last cut command eliminates the last char of the row. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N), N number of columns\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#!/bin/bash\\n\\ncolumn=$(cat file.txt | head -n 1 | wc -w)\\n\\ni=1\\nwhile [ $i -le $column ]\\ndo\\n    cat file.txt | cut -d \\' \\' -f $i | tr \\'\\\\n\\' \\' \\' | rev | cut -c2- | rev\\n    let i=i+1\\ndone\\n\\nexit 0\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n#!/bin/bash\\n\\ncolumn=$(cat file.txt | head -n 1 | wc -w)\\n\\ni=1\\nwhile [ $i -le $column ]\\ndo\\n    cat file.txt | cut -d \\' \\' -f $i | tr \\'\\\\n\\' \\' \\' | rev | cut -c2- | rev\\n    let i=i+1\\ndone\\n\\nexit 0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2805116,
                "title": "my-not-quick-but-dirty-solution-using-awk",
                "content": "```bash\\nCOLS=$(awk \\'NR == 1 {print NF}\\' file.txt) # Get the number of columns from awk\\nfor ((field=1; field <=$COLS; field++)) # For each column i\\ndo\\n    #For each row j, get element in position (i,j), print it and append space\\n\\tline=$(awk -v field_num=\"$field\" \\'{ORS=\" \"; print $field_num}\\' file.txt)\\n    \\n\\techo \"${line%% }\" #remove trailing space\\ndone\\n```\\nThis code above works but it is not really perfomant (Runtime: 520ms; faster than 30%) since awk has to re-read the whole file for each iteration. I came up with it by skimming through the manual of awk and stumbling upon the ORS variable definition. I just got into Shell Scripting so for a beginner, I think I did pretty alright.",
                "solutionTags": [],
                "code": "```bash\\nCOLS=$(awk \\'NR == 1 {print NF}\\' file.txt) # Get the number of columns from awk\\nfor ((field=1; field <=$COLS; field++)) # For each column i\\ndo\\n    #For each row j, get element in position (i,j), print it and append space\\n\\tline=$(awk -v field_num=\"$field\" \\'{ORS=\" \"; print $field_num}\\' file.txt)\\n    \\n\\techo \"${line%% }\" #remove trailing space\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2624921,
                "title": "my-solution",
                "content": "```\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        if(NR == 1) {\\n            s[i] = $i;\\n        } else {\\n            s[i] = s[i] \" \" $i;\\n        }\\n    }\\n}\\nEND {\\n    for (i = 1; s[i] != \"\"; i++) {\\n        print s[i];\\n    }\\n}\\' file.txt\\n\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        if(NR == 1) {\\n            s[i] = $i;\\n        } else {\\n            s[i] = s[i] \" \" $i;\\n        }\\n    }\\n}\\nEND {\\n    for (i = 1; s[i] != \"\"; i++) {\\n        print s[i];\\n    }\\n}\\' file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2472406,
                "title": "a-few-short-solutions-on-awk-perl",
                "content": "Perl_#1\\n```\\nperl \\'-alne$r=@F;push@f,@F}{for$a(0..$r-1){print\"@f[map{$_*$r+$a}0..$.-1]\"}\\' < file.txt\\n```\\nPerl_#2\\n```\\nperl \\'-alne$a[$k].=\" $v\"while($k,$v)=each@F}{$,=$\\\\;print@a\\' < file.txt\\n```\\nawk\\n```\\nawk \\'{for(i=1;NF>=i;i++)w[i][NR]=$i}END{for(j=1;i>=j;j++){for(k=1;NR>=k;k++)printf\"%s \",w[j][k];print\"\"}}\\' < file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nperl \\'-alne$r=@F;push@f,@F}{for$a(0..$r-1){print\"@f[map{$_*$r+$a}0..$.-1]\"}\\' < file.txt\\n```\n```\\nperl \\'-alne$a[$k].=\" $v\"while($k,$v)=each@F}{$,=$\\\\;print@a\\' < file.txt\\n```\n```\\nawk \\'{for(i=1;NF>=i;i++)w[i][NR]=$i}END{for(j=1;i>=j;j++){for(k=1;NR>=k;k++)printf\"%s \",w[j][k];print\"\"}}\\' < file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2256789,
                "title": "for-loop-simple-solution",
                "content": "```\\nfor i in $(seq 1 $(head -n1 file.txt | wc -w)); do echo $(cut -d\\' \\' -f$i file.txt); done\\n```",
                "solutionTags": [],
                "code": "```\\nfor i in $(seq 1 $(head -n1 file.txt | wc -w)); do echo $(cut -d\\' \\' -f$i file.txt); done\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2236632,
                "title": "very-obvious-and-simple-solution-with-awk",
                "content": "It seems very obvious just to do simple cycle `column_count` times each times print specific column\\nxargs used to trim whitespaces and newlines (900 ms, 3.9 MB)\\n\\n```bash\\ncolumn_count=$(head -n 1 file.txt | wc -w) # get column count\\nfor i in $(seq $column_count); do \\n    awk \"{printf \\\\\"%s \\\\\",\\\\$$i }\" file.txt | xargs \\ndone\\n```\\n\\nor with cut (273 ms, 3.5 MB)\\n```bash\\ncolumn_count=$(head -n 1 file.txt | wc -w) # get column count\\nfor i in $(seq $column_count); do \\n    echo $(cut -d\\' \\' -f$i file.txt); \\ndone\\n```\\n\\nnot obvious but beautifull one (529 ms,  3.9 MB):\\n```bash\\nfor ((i = 1; ; i++)); do \\n\\tline=$(awk \"{print \\\\$$i}\" file.txt); \\n    [[ $line ]] || break && echo $line\\ndone\\n```",
                "solutionTags": [],
                "code": "```bash\\ncolumn_count=$(head -n 1 file.txt | wc -w) # get column count\\nfor i in $(seq $column_count); do \\n    awk \"{printf \\\\\"%s \\\\\",\\\\$$i }\" file.txt | xargs \\ndone\\n```\n```bash\\ncolumn_count=$(head -n 1 file.txt | wc -w) # get column count\\nfor i in $(seq $column_count); do \\n    echo $(cut -d\\' \\' -f$i file.txt); \\ndone\\n```\n```bash\\nfor ((i = 1; ; i++)); do \\n\\tline=$(awk \"{print \\\\$$i}\" file.txt); \\n    [[ $line ]] || break && echo $line\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2154248,
                "title": "leetcode-problem",
                "content": "Hello.\\nI have a sultion that works on my computer and online bash compiler and the output is fine - as expacted,\\nbut when i submit my solution to Leetcode its says error..  anyone have an idea ??\\n\\n```\\nnames=\\'\\'\\nages=\\'\\'\\n\\nwhile read line || [ -n \"$line\" ]\\ndo\\n\\n\\tnames=\"$names $(echo $line | cut -d \\' \\' -f 1)\"\\n\\tages=\"$ages $(echo $line | cut -d \\' \\' -f 2)\"\\n\\ndone < file.txt\\n\\necho $names\\necho $ages\\n```\\n",
                "solutionTags": [],
                "code": "```\\nnames=\\'\\'\\nages=\\'\\'\\n\\nwhile read line || [ -n \"$line\" ]\\ndo\\n\\n\\tnames=\"$names $(echo $line | cut -d \\' \\' -f 1)\"\\n\\tages=\"$ages $(echo $line | cut -d \\' \\' -f 2)\"\\n\\ndone < file.txt\\n\\necho $names\\necho $ages\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2111393,
                "title": "another-while-loop-with-awk",
                "content": "count the numner of columns and loop thru them with an awk\\n| xargs is just to trim the white space that was messing up my tests\\n\\n```\\nnumber_of_columns=$(head -n 1 file.txt | wc -w)\\ncolumn_counter=1\\n\\nwhile [ $column_counter -le $number_of_columns ]\\ndo\\n   awk -v x=$column_counter \\'{print $x}\\' file.txt | tr \"\\\\n\" \" \" | xargs\\n   column_counter=$((column_counter+1))\\ndone\\n```\\n\\ni\\'m embarassed at how long this took me, but better late than never.",
                "solutionTags": [],
                "code": "```\\nnumber_of_columns=$(head -n 1 file.txt | wc -w)\\ncolumn_counter=1\\n\\nwhile [ $column_counter -le $number_of_columns ]\\ndo\\n   awk -v x=$column_counter \\'{print $x}\\' file.txt | tr \"\\\\n\" \" \" | xargs\\n   column_counter=$((column_counter+1))\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2057914,
                "title": "is-using-python-fine",
                "content": "You have to read the whole content to memory, right?\\nI decided to use python for that.\\n\\n```bash\\npython3 -c \\'\\nfrom collections import defaultdict\\ndata = defaultdict(list)\\nwith open(\"file.txt\") as f:\\n   for line in f:\\n       for i, word in enumerate(line.split()):\\n           data[i].append(word)\\nfor line in data.values():\\n    print(\" \".join(line))\\n\\'\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```bash\\npython3 -c \\'\\nfrom collections import defaultdict\\ndata = defaultdict(list)\\nwith open(\"file.txt\") as f:\\n   for line in f:\\n       for i, word in enumerate(line.split()):\\n           data[i].append(word)\\nfor line in data.values():\\n    print(\" \".join(line))\\n\\'\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2052137,
                "title": "yet-another-awk-one-line-solution",
                "content": "awk \\'NR==1{for (i=1;i<=NF;i++){s[i]=$i}}NR>1{for (i=1;i<=NF;i++){s[i]=s[i] \" \" $i}}END{for (i=1;i<=NF;i++){print s[i]}}\\' file.txt",
                "solutionTags": [],
                "code": "awk \\'NR==1{for (i=1;i<=NF;i++){s[i]=$i}}NR>1{for (i=1;i<=NF;i++){s[i]=s[i] \" \" $i}}END{for (i=1;i<=NF;i++){print s[i]}}\\' file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 1994989,
                "title": "awk-naive-solution",
                "content": "```\\ncat file.txt | awk \\'\\n(NR==1){ncols = NF}\\n{for(col=1;col<=ncols;col++) a[NR,col] = $col}\\nEND {\\n    for(i=1;i<=NR;i++) {\\n        if(i==1) {for(j=1;j<=ncols;j++) {b[j] = a[i,j]}}\\n        else {for(j=1;j<=ncols;j++) b[j] = b[j] \" \" a[i,j]}\\n    }\\n    for(j=1;j<=ncols;j++) print b[j]\\n}\\n\\'```",
                "solutionTags": [],
                "code": "```\\ncat file.txt | awk \\'\\n(NR==1){ncols = NF}\\n{for(col=1;col<=ncols;col++) a[NR,col] = $col}\\nEND {\\n    for(i=1;i<=NR;i++) {\\n        if(i==1) {for(j=1;j<=ncols;j++) {b[j] = a[i,j]}}\\n        else {for(j=1;j<=ncols;j++) b[j] = b[j] \" \" a[i,j]}\\n    }\\n    for(j=1;j<=ncols;j++) print b[j]\\n}\\n\\'```",
                "codeTag": "Unknown"
            },
            {
                "id": 1713075,
                "title": "runtime-400-ms-memory-usage-3-5-mb-bash-shell",
                "content": "```\\nsplit -l 1 file.txt _A\\nls _A* | xargs -I % sh -c \"tr <% \\' \\' \\'\\\\n\\' >_%\" \\npaste -d \" \" __A* \\nrm _*\\n```",
                "solutionTags": [],
                "code": "```\\nsplit -l 1 file.txt _A\\nls _A* | xargs -I % sh -c \"tr <% \\' \\' \\'\\\\n\\' >_%\" \\npaste -d \" \" __A* \\nrm _*\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1533609,
                "title": "split-tr-paste-rm-simple-but-slow",
                "content": "In a sense it isn\\'t trully a Bash script, but one may appreciate a different approach :)\\n```\\nsplit -l 1 file.txt _A\\nls _A* | xargs -I % sh -c \"tr <% \\' \\' \\'\\\\n\\' >_%\" \\npaste -d \" \" __A* \\nrm _*\\n```",
                "solutionTags": [],
                "code": "```\\nsplit -l 1 file.txt _A\\nls _A* | xargs -I % sh -c \"tr <% \\' \\' \\'\\\\n\\' >_%\" \\npaste -d \" \" __A* \\nrm _*\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1479122,
                "title": "pure-awk-solution-use-2d-array-like-c",
                "content": "```\\nawk \\'{ \\nfor (i = 1; i <= NF; i++) { num[NR][i] = $i } \\n}\\nEND {\\n\\tfor (i = 1; i <= NF; i++) {\\n\\t\\tfor (j = 1; j <= NR; j++) {\\n\\t\\t\\tprintf \"%s\", num[j][i]\\n\\t\\t\\tif (j < NR) { printf \"%s\", \" \"}\\n\\t\\t}\\n\\t\\tif (i < NF) { print \\'\\\\n\\' }\\n\\t}\\n}\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'{ \\nfor (i = 1; i <= NF; i++) { num[NR][i] = $i } \\n}\\nEND {\\n\\tfor (i = 1; i <= NF; i++) {\\n\\t\\tfor (j = 1; j <= NR; j++) {\\n\\t\\t\\tprintf \"%s\", num[j][i]\\n\\t\\t\\tif (j < NR) { printf \"%s\", \" \"}\\n\\t\\t}\\n\\t\\tif (i < NF) { print \\'\\\\n\\' }\\n\\t}\\n}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1470039,
                "title": "a-simple-solution-awk-sed",
                "content": "```bash\\nCOL=$(awk -F \" \" \\'END{printf NF}\\' file.txt)\\nfor ((i=0; i<$COL; i++));\\ndo\\n        awk \\'{printf $\\'\"$(($i+1))\"\\'\" \"}\\' file.txt | sed \\'s/.$/\\\\n/g\\'\\ndone\\n```",
                "solutionTags": [],
                "code": "```bash\\nCOL=$(awk -F \" \" \\'END{printf NF}\\' file.txt)\\nfor ((i=0; i<$COL; i++));\\ndo\\n        awk \\'{printf $\\'\"$(($i+1))\"\\'\" \"}\\' file.txt | sed \\'s/.$/\\\\n/g\\'\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1428262,
                "title": "one-awk-sed-solution",
                "content": "Treat file.txt as a table. firstly use awk to split tables by columns, for a centain colume, using sed to replace \\\\n with a space (this action compare to altering a column of data to a row of data), then use sed to remove the trailing space. column by column.\\n\\n```\\n#!/bin/bash\\n\\ndeclare -i column\\ndeclare -i i\\n\\ncolumn=$(cat file.txt | awk \\'NR==1 {print NF}\\')\\ni=1\\n\\nwhile [[ $i -le $column ]] \\ndo \\n    cat file.txt | awk \\'{print $\\'$i\\'}\\' | sed \\'s/\\\\n/\" \"/\\' | sed \\'s/ $/\\\\n/\\'\\n    let i+=1\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\n#!/bin/bash\\n\\ndeclare -i column\\ndeclare -i i\\n\\ncolumn=$(cat file.txt | awk \\'NR==1 {print NF}\\')\\ni=1\\n\\nwhile [[ $i -le $column ]] \\ndo \\n    cat file.txt | awk \\'{print $\\'$i\\'}\\' | sed \\'s/\\\\n/\" \"/\\' | sed \\'s/ $/\\\\n/\\'\\n    let i+=1\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1400251,
                "title": "pure-bash-solution-newline-problems-passed-but-still-weird",
                "content": "Here\\'s a pure bash solution, but I had to mess with the newlines during the output phase to pass this test case\\n```\\na\\n```\\nIf I use echo instead of printf (program below), I get :\\n```\\na\\\\n\\n```\\nwhich makes the test fail ... very picky judge ... Can anyone explain why it makes a difference to not print a newline for the last output line?\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\nallLists=()\\n\\nwhile IFS=\\' \\' read -a LINE;\\ndo\\n    for (( i=0; i<=${#LINE[@]}; i++ ))\\n    do\\n        if [[ -z \"${LINE[i]//[$\\'\\\\t\\\\r\\\\n \\']}\" ]]; then\\n            continue\\n        fi\\n        if [ -v allLists[i] ]; then\\n            allLists[$i]=\"${allLists[i]} ${LINE[i]//[$\\'\\\\t\\\\r\\\\n \\']}\"\\n        else\\n            allLists[$i]=\"${LINE[i]//[$\\'\\\\t\\\\r\\\\n \\']}\"\\n        fi\\n    done\\ndone <\"file.txt\"\\n\\nfor (( i=0; i<=${#allLists[@]}; i++ ))\\ndo\\n    # Can\\'t just use echo ${allLists[i]}, but this mess instead:\\n    printf \\'%s\\' \"${allLists[i]//[$\\'\\\\t\\\\r\\\\n\\']}\"\\n    if (( i < ${#allLists[@]} )); then\\n        printf \\'\\\\n\\'\\n    fi\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\na\\n```\n```\\na\\\\n\\n```\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\nallLists=()\\n\\nwhile IFS=\\' \\' read -a LINE;\\ndo\\n    for (( i=0; i<=${#LINE[@]}; i++ ))\\n    do\\n        if [[ -z \"${LINE[i]//[$\\'\\\\t\\\\r\\\\n \\']}\" ]]; then\\n            continue\\n        fi\\n        if [ -v allLists[i] ]; then\\n            allLists[$i]=\"${allLists[i]} ${LINE[i]//[$\\'\\\\t\\\\r\\\\n \\']}\"\\n        else\\n            allLists[$i]=\"${LINE[i]//[$\\'\\\\t\\\\r\\\\n \\']}\"\\n        fi\\n    done\\ndone <\"file.txt\"\\n\\nfor (( i=0; i<=${#allLists[@]}; i++ ))\\ndo\\n    # Can\\'t just use echo ${allLists[i]}, but this mess instead:\\n    printf \\'%s\\' \"${allLists[i]//[$\\'\\\\t\\\\r\\\\n\\']}\"\\n    if (( i < ${#allLists[@]} )); then\\n        printf \\'\\\\n\\'\\n    fi\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1378260,
                "title": "solution-with-cut-pure-bash-no-awk",
                "content": "```\\ndelimiter=\\' \\'\\ncount=`head -n1 file.txt|grep -o \"$delimiter\" |wc -l`\\nfor (( line = 1; line <= $((count+1)); line++ ))\\ndo\\n        outLine=`cat file.txt|cut -d\"$delimiter\" -f$line |tr \\'\\\\n\\' \"$delimiter\"`\\n        lineLen=`echo $outLine|wc --chars`\\n        echo $outLine |cut -c 1-$(($lineLen-1))\\ndone\\n```\\n",
                "solutionTags": [],
                "code": "```\\ndelimiter=\\' \\'\\ncount=`head -n1 file.txt|grep -o \"$delimiter\" |wc -l`\\nfor (( line = 1; line <= $((count+1)); line++ ))\\ndo\\n        outLine=`cat file.txt|cut -d\"$delimiter\" -f$line |tr \\'\\\\n\\' \"$delimiter\"`\\n        lineLen=`echo $outLine|wc --chars`\\n        echo $outLine |cut -c 1-$(($lineLen-1))\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1344331,
                "title": "another-perl-solution",
                "content": "\\n```\\n#!/usr/bin/env perl\\nuse strict;\\nuse warnings;\\nuse Data::Dumper;\\n\\nmy (@words, @a, @b);\\n\\nwhile (<DATA>) {\\n    chomp( my $line = $_ );\\n    @words = split / /,$line;\\n    push @a, $words[0];\\n    push @b, $words[1];\\n}\\n\\nprint Dumper @a;\\nprint \"====\\\\n\";\\nprint Dumper @b;\\n\\n__DATA__\\nname age\\nalice 21\\nryan 30\\n```",
                "solutionTags": [],
                "code": "```\\n#!/usr/bin/env perl\\nuse strict;\\nuse warnings;\\nuse Data::Dumper;\\n\\nmy (@words, @a, @b);\\n\\nwhile (<DATA>) {\\n    chomp( my $line = $_ );\\n    @words = split / /,$line;\\n    push @a, $words[0];\\n    push @b, $words[1];\\n}\\n\\nprint Dumper @a;\\nprint \"====\\\\n\";\\nprint Dumper @b;\\n\\n__DATA__\\nname age\\nalice 21\\nryan 30\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1276318,
                "title": "bash",
                "content": "```\\n#!/usr/bin/bash\\nwhile IFS=\\' \\' read -a l; do\\n        for i in ${!l[@]}; do\\n                a[i]=\"${a[i]} ${l[i]}\"\\n        done\\ndone < file.txt\\nfor i in ${!a[@]}; do\\n        echo ${a[i]}\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\n#!/usr/bin/bash\\nwhile IFS=\\' \\' read -a l; do\\n        for i in ${!l[@]}; do\\n                a[i]=\"${a[i]} ${l[i]}\"\\n        done\\ndone < file.txt\\nfor i in ${!a[@]}; do\\n        echo ${a[i]}\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1174920,
                "title": "average-awk-solution",
                "content": "```\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        arr[i] = arr[i] \" \" $i;\\n    }\\n}\\n\\nEND {\\n    for (i = 1; i <= NF; i++) {\\n        print gensub(/^[ \\\\t]*|[ \\\\t]*$/, \"\", \"g\", arr[i]);\\n    }\\n}\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        arr[i] = arr[i] \" \" $i;\\n    }\\n}\\n\\nEND {\\n    for (i = 1; i <= NF; i++) {\\n        print gensub(/^[ \\\\t]*|[ \\\\t]*$/, \"\", \"g\", arr[i]);\\n    }\\n}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1162707,
                "title": "awk-associative-array-solution",
                "content": "```\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        transposed[NR, i] = $i \\n    }\\n}\\n\\nEND {\\n    for (r = 1; r <= NF; r++) {\\n        sep = \"\"\\n        for (c = 1; c <= NR; c++) {\\n            printf(\"%s%s\", sep, transposed[c, r])\\n            sep = \" \"\\n        }\\n        printf(\"\\\\n\")\\n    }\\n}\\n\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        transposed[NR, i] = $i \\n    }\\n}\\n\\nEND {\\n    for (r = 1; r <= NF; r++) {\\n        sep = \"\"\\n        for (c = 1; c <= NR; c++) {\\n            printf(\"%s%s\", sep, transposed[c, r])\\n            sep = \" \"\\n        }\\n        printf(\"\\\\n\")\\n    }\\n}\\n\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1074958,
                "title": "awk-reading-into-two-dimentional-array-and-printing-it",
                "content": "```\\nawk \\'{for (i=1;i<=NF;i++) {m[i,NR]=$i; a=NR;}}END{i--; for (j=1;j<=i;j++){for (k=1;k<=a;k++){printf(\"%s \",m[j,k])}printf\"\\\\n\"}}\\' file.txt |  sed \\'s/^ *//;s/ *$//;s/  */ /;\\'\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'{for (i=1;i<=NF;i++) {m[i,NR]=$i; a=NR;}}END{i--; for (j=1;j<=i;j++){for (k=1;k<=a;k++){printf(\"%s \",m[j,k])}printf\"\\\\n\"}}\\' file.txt |  sed \\'s/^ *//;s/ *$//;s/  */ /;\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1073957,
                "title": "this-works-on-my-computer-usr-bin-bash-not-on-leetcode-strange",
                "content": "```\\ncl1=\"\"; cl2=\"\"; i=0; cat file.txt | while read line; do cl1=\"$cl1 `echo $line| awk \\'{print $1}\\'`\"; cl2=\"$cl2 `echo $line | awk \\'{print $2\\'}`\"; i=`expr $i + 1`; if [ $i -eq 3 ]; then echo $cl1; echo $cl2; fi; done;\\n```",
                "solutionTags": [],
                "code": "```\\ncl1=\"\"; cl2=\"\"; i=0; cat file.txt | while read line; do cl1=\"$cl1 `echo $line| awk \\'{print $1}\\'`\"; cl2=\"$cl2 `echo $line | awk \\'{print $2\\'}`\"; i=`expr $i + 1`; if [ $i -eq 3 ]; then echo $cl1; echo $cl2; fi; done;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1058674,
                "title": "awk-and-sed-awk-and-remove-leading-blank-with-sed",
                "content": "\\ncat file.txt |\\n  awk -F\" \" \\'{for (f=1;f<=NF;f++) str[f] = str[f] FS $f}END{for (f=1;f<=NF;f++) print str[f]}\\' |\\n  sed \\'s/^ //g\\'",
                "solutionTags": [],
                "code": "\\ncat file.txt |\\n  awk -F\" \" \\'{for (f=1;f<=NF;f++) str[f] = str[f] FS $f}END{for (f=1;f<=NF;f++) print str[f]}\\' |\\n  sed \\'s/^ //g\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1001883,
                "title": "why-is-this-wrong",
                "content": "Why is this wrong?\\n\\nWhen I run the test cases on my local machine, I get the expected output\\n\\'\\'\\'\\n#!/bin/bash\\n\\nNO_OF_COLUMNS=$(head -n 1 file.txt | awk \\'{print NF}\\')\\n\\nfor (( i=1 ; i<=${NO_OF_COLUMNS} ; i++ ))\\ndo\\n  awk -v j=$i \\'{print $j}\\' file.txt | while read ITEM\\n  do\\n\\n    echo -n \"${ITEM} \"\\n\\n  done\\n  echo\\n\\ndone\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "Why is this wrong?\\n\\nWhen I run the test cases on my local machine, I get the expected output\\n\\'\\'\\'\\n#!/bin/bash\\n\\nNO_OF_COLUMNS=$(head -n 1 file.txt | awk \\'{print NF}\\')\\n\\nfor (( i=1 ; i<=${NO_OF_COLUMNS} ; i++ ))\\ndo\\n  awk -v j=$i \\'{print $j}\\' file.txt | while read ITEM\\n  do\\n\\n    echo -n \"${ITEM} \"\\n\\n  done\\n  echo\\n\\ndone\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 967824,
                "title": "can-someone-explain-this-test-case",
                "content": "Input: a b c\\n\\nExpected: a\\\\nb\\\\nc\\n\\nI don\\'t understand why that is the expected output for this testcase.\\n",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 966848,
                "title": "simple-solution",
                "content": "```\\nawk \\'\\n{ \\n    for (i=1; i<=NF; i++)  {\\n        a[NR,i] = $i\\n    }\\n}\\nNF>p { p = NF }\\nEND {    \\n    for(j=1; j<=p; j++) {\\n        str=a[1,j]\\n        for(i=2; i<=NR; i++){\\n            str=str\" \"a[i,j];\\n        }\\n        print str\\n    }\\n}\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'\\n{ \\n    for (i=1; i<=NF; i++)  {\\n        a[NR,i] = $i\\n    }\\n}\\nNF>p { p = NF }\\nEND {    \\n    for(j=1; j<=p; j++) {\\n        str=a[1,j]\\n        for(i=2; i<=NR; i++){\\n            str=str\" \"a[i,j];\\n        }\\n        print str\\n    }\\n}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935870,
                "title": "huh-computer-says-no",
                "content": "input: a\\noutput: a\\nexpected: a\\n*wrong answer*\\n lolwtf",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 871358,
                "title": "very-simple-hashmap-ish-style-solution",
                "content": "```\\nfile=\"file.txt\"\\n\\nIFS=$\\'\\\\n\\'\\narr=()\\n\\nfor line in $(cat $file); do\\n    i=0\\n    for word in $(echo \"$line\" | tr \\' \\' \\'\\\\n\\'); do \\n        [[ -z ${arr[i]} ]] && arr[i]=\"$word\" || arr[i]=\"${arr[i]} $word\" \\n        (( i++ ))\\n    done \\ndone\\n\\nfor line in ${arr[@]}; do echo $line; done \\n```",
                "solutionTags": [],
                "code": "```\\nfile=\"file.txt\"\\n\\nIFS=$\\'\\\\n\\'\\narr=()\\n\\nfor line in $(cat $file); do\\n    i=0\\n    for word in $(echo \"$line\" | tr \\' \\' \\'\\\\n\\'); do \\n        [[ -z ${arr[i]} ]] && arr[i]=\"$word\" || arr[i]=\"${arr[i]} $word\" \\n        (( i++ ))\\n    done \\ndone\\n\\nfor line in ${arr[@]}; do echo $line; done \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 818362,
                "title": "bug-failing-test-case-a-nb",
                "content": "Test case 5 of 17 has the input \\'a\\\\nb\\' (with a literal \\'\\\\n\\' not an actual new line) and it expects \\'a b\\'.\\nMy code below outputs \\'a\\\\nb\\' because it isn\\'t interpreting the newline and thus treating the input as one column and one row.\\nRunning on my Mac (GNU bash, version 5.0.18-release (x86_64-apple-darwin17.7.0)), none of the accepted solutions here appear to work but some of them will be accepted by the website. Is any one else seeing this?\\n\\n```bash\\nn_cols=$(head -n 1 file.txt | wc -w)\\nfor c in $(seq $n_cols); do\\n    echo \"$(cut -d \\' \\' -f \"${c}\" file.txt)\" | xargs\\ndone\\n```",
                "solutionTags": [],
                "code": "```bash\\nn_cols=$(head -n 1 file.txt | wc -w)\\nfor c in $(seq $n_cols); do\\n    echo \"$(cut -d \\' \\' -f \"${c}\" file.txt)\" | xargs\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 705247,
                "title": "why-is-this-getting-wrong-answer",
                "content": "Input is `a`, output is `a`, expected is `a`.\\nWhy does this not work? I don\\'t see any `\\\\n`s in there.\\n\\n```\\nfor i in $(seq 1 \"$(awk \\'{print NF; exit}\\' file.txt)\"); do\\n    awk -v col=$i \\'BEGIN {ORS=\" \"}; {print $col}\\' file.txt\\n\\techo\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\nfor i in $(seq 1 \"$(awk \\'{print NF; exit}\\' file.txt)\"); do\\n    awk -v col=$i \\'BEGIN {ORS=\" \"}; {print $col}\\' file.txt\\n\\techo\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 673853,
                "title": "why-does-this-get-permission-denied",
                "content": "```\\nncol=$(head -n1 file.txt | wc -w)\\nfor i in $(seq 1 $ncol); do\\n    echo $(cut -d \\' \\' -f $i file.txt)\\ndone\\n```\\nI submitted this same code several times. Some times it got accepted, sometimes the same code got permission denied.\\n\\nGot error:\\n```\\nrbash: ./prog.sh: Permission denied\\n```",
                "solutionTags": [],
                "code": "```\\nncol=$(head -n1 file.txt | wc -w)\\nfor i in $(seq 1 $ncol); do\\n    echo $(cut -d \\' \\' -f $i file.txt)\\ndone\\n```\n```\\nrbash: ./prog.sh: Permission denied\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 615067,
                "title": "simple-bash-solution",
                "content": "```\\ncol=\"$(head -1 file.txt | wc -w)\"\\n\\nfor i in $(seq 1 $col);do awk \\'{ print $\\'$i\\' }\\' file.txt | paste -s -d\" \";done\\n```",
                "solutionTags": [],
                "code": "```\\ncol=\"$(head -1 file.txt | wc -w)\"\\n\\nfor i in $(seq 1 $col);do awk \\'{ print $\\'$i\\' }\\' file.txt | paste -s -d\" \";done\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 574865,
                "title": "solution-slower-but-better-memory-perf",
                "content": "```\\nfor i in {1..500}\\ndo\\n  cmd=\"cat file.txt | awk \\'{print \\\\$${i}}\\' | tr -s \\\\\"\\\\\\\\\\\\n\\\\\" \\\\\"\\\\ \\\\\"\"\\n  output=$( eval $cmd )\\n  [[ $output == \" \" ]] && exit 0\\n  echo $output\\ndone\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfor i in {1..500}\\ndo\\n  cmd=\"cat file.txt | awk \\'{print \\\\$${i}}\\' | tr -s \\\\\"\\\\\\\\\\\\n\\\\\" \\\\\"\\\\ \\\\\"\"\\n  output=$( eval $cmd )\\n  [[ $output == \" \" ]] && exit 0\\n  echo $output\\ndone\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 568814,
                "title": "a-short-one-liner-awk",
                "content": "awk \\'{a=a\" \"$1; b=b\" \"$2}; END {print a\"\\\\n\"b}\\' file.txt",
                "solutionTags": [],
                "code": "awk \\'{a=a\" \"$1; b=b\" \"$2}; END {print a\"\\\\n\"b}\\' file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 553829,
                "title": "script-solution",
                "content": "```\\n#!/bin/bash\\n\\ntarget=\\'file.txt\\';\\n\\nfields=$(head -n 1 $target);\\nvalues=$(tail -n +2 $target | tr \"\\\\n\" \" \");\\n\\nlet count=0;\\nfor i in $fields\\ndo\\n    tarr[$count]=$i;\\n    let count++;\\ndone\\n\\nlet s=0;\\nfor value in $values\\ndo\\n    let index=s%count;\\n    let s++;\\n    tarr[$index]=\"${tarr[index]} $value\";\\ndone\\n\\ni=0;\\nwhile [ $i -lt ${#tarr[*]} ]\\ndo\\n    echo ${tarr[$i]};\\n    let i++;\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\n#!/bin/bash\\n\\ntarget=\\'file.txt\\';\\n\\nfields=$(head -n 1 $target);\\nvalues=$(tail -n +2 $target | tr \"\\\\n\" \" \");\\n\\nlet count=0;\\nfor i in $fields\\ndo\\n    tarr[$count]=$i;\\n    let count++;\\ndone\\n\\nlet s=0;\\nfor value in $values\\ndo\\n    let index=s%count;\\n    let s++;\\n    tarr[$index]=\"${tarr[index]} $value\";\\ndone\\n\\ni=0;\\nwhile [ $i -lt ${#tarr[*]} ]\\ndo\\n    echo ${tarr[$i]};\\n    let i++;\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 540453,
                "title": "my-solution-using-cut-awk-and-while-loop",
                "content": "```\\nfile=file.txt\\ncols=`cat $file | awk \\'{print NF}\\'`\\nfCol=`echo $cols | awk \\'{print $1}\\'`\\nindex=1\\nwhile [ $index -le $fCol ];\\ndo\\ncut -d\\' \\' -f$index $file | xargs\\nindex=$((index + 1))\\ndone\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfile=file.txt\\ncols=`cat $file | awk \\'{print NF}\\'`\\nfCol=`echo $cols | awk \\'{print $1}\\'`\\nindex=1\\nwhile [ $index -le $fCol ];\\ndo\\ncut -d\\' \\' -f$index $file | xargs\\nindex=$((index + 1))\\ndone\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 538800,
                "title": "my-simple-one-liner",
                "content": "```\\nfor i in `seq \\\\`head -n1 file.txt | wc -w\\\\``; do awk -v c=$i \\'{print $c}\\' file.txt | tr \\'\\\\n\\' \\' \\' | awk \\'{$1=$1};1\\';   done\\n```",
                "solutionTags": [],
                "code": "```\\nfor i in `seq \\\\`head -n1 file.txt | wc -w\\\\``; do awk -v c=$i \\'{print $c}\\' file.txt | tr \\'\\\\n\\' \\' \\' | awk \\'{$1=$1};1\\';   done\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 521116,
                "title": "cut-columns-one-by-one",
                "content": "\\nCOLS=\\\\`head -1 file.txt | tr \\' \\' \\'\\\\n\\' | wc -l\\\\`\\nfor i in \\\\`seq 1 $COLS\\\\`\\ndo\\n    COL=\\\\`cut -d \\' \\' -f $i file.txt | tr \\'\\\\n\\' \\' \\'\\\\`\\n    echo $COL\\ndone",
                "solutionTags": [],
                "code": "\\nCOLS=\\\\`head -1 file.txt | tr \\' \\' \\'\\\\n\\' | wc -l\\\\`\\nfor i in \\\\`seq 1 $COLS\\\\`\\ndo\\n    COL=\\\\`cut -d \\' \\' -f $i file.txt | tr \\'\\\\n\\' \\' \\'\\\\`\\n    echo $COL\\ndone",
                "codeTag": "Unknown"
            },
            {
                "id": 491321,
                "title": "awk-solution-why-permission-denied",
                "content": "can anyone help me clarify why permission denied?\\n\\n```\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++){\\n        #printf \"[%d,%d] %s\\\\n\", NR, i, $i\\n        line[NR][i] = $i\\n    }\\n}\\nEND {\\n#printf \"lines %d \\\\n\", lines\\n#printf \"NR %d \\\\n\", NR\\n#printf \"NF %d \\\\n\", NF\\n    for (j = 1; j <= NF; j++){\\n        for (i = 1; i <= NR; i++){\\n            #printf \"[%d,%d] %s \", j, i, line[i][j]\\n            printf \"%s \", line[i][j]\\n        }\\n        printf \"\\\\n\"\\n    }\\n}\\n\\' < file.txt\\n```\\n\\nthanks in advance",
                "solutionTags": [],
                "code": "```\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++){\\n        #printf \"[%d,%d] %s\\\\n\", NR, i, $i\\n        line[NR][i] = $i\\n    }\\n}\\nEND {\\n#printf \"lines %d \\\\n\", lines\\n#printf \"NR %d \\\\n\", NR\\n#printf \"NF %d \\\\n\", NF\\n    for (j = 1; j <= NF; j++){\\n        for (i = 1; i <= NR; i++){\\n            #printf \"[%d,%d] %s \", j, i, line[i][j]\\n            printf \"%s \", line[i][j]\\n        }\\n        printf \"\\\\n\"\\n    }\\n}\\n\\' < file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 472807,
                "title": "nothing-fancy-but-very-readable",
                "content": "Looks like a lot of submissions here are focused on trying to make things shorter but the filp side it makes it obscure.\\n\\nSo here is a somewhat opposite approach - keep it readable.\\n\\nThe idea:\\n\\n1. Calculate number of fields\\n2. in a for loop read the file and extract all values from column i into a line \\n\\nA couple notes:\\n\\n1. awk adds a new line at the end, so the \\'tr\\' command will replace new lines with spaces and the \\'sed\\' command will remove the last space in each line.\\n2. the echo command will insert a new line between the lines.\\n\\n\\n\\n\\n```\\nfields=`head -1 file.txt | wc -w`\\nfor i in `seq 1 $fields`\\ndo \\n    cat file.txt | awk \"{print $\"$i\"}\"  |tr \\'\\\\r\\\\n\\' \\' \\' |sed \\'s/ $//g\\'\\n    echo\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\nfields=`head -1 file.txt | wc -w`\\nfor i in `seq 1 $fields`\\ndo \\n    cat file.txt | awk \"{print $\"$i\"}\"  |tr \\'\\\\r\\\\n\\' \\' \\' |sed \\'s/ $//g\\'\\n    echo\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 454464,
                "title": "perl-solution",
                "content": "```perl\\nopen(my $fh, \"<\", \"file.txt\");\\nmy @file;\\nwhile(<$fh>) {\\n\\tmy @sp = split;\\n\\tpush(@file, \\\\@sp);\\n}\\n\\nfor my $i (0 .. @{$file[0]}-1) {\\n\\tfor my $j (0 .. @file-1) {\\n\\t\\tprint($file[$j][$i]);\\n\\t\\tprint(\" \") if $j != @file-1;\\n\\t}\\n\\tprint(\"\\\\n\");\\n}\\n```",
                "solutionTags": [],
                "code": "```perl\\nopen(my $fh, \"<\", \"file.txt\");\\nmy @file;\\nwhile(<$fh>) {\\n\\tmy @sp = split;\\n\\tpush(@file, \\\\@sp);\\n}\\n\\nfor my $i (0 .. @{$file[0]}-1) {\\n\\tfor my $j (0 .. @file-1) {\\n\\t\\tprint($file[$j][$i]);\\n\\t\\tprint(\" \") if $j != @file-1;\\n\\t}\\n\\tprint(\"\\\\n\");\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 400244,
                "title": "no-awk",
                "content": "This bash sciprt works  (tested on Ubuntu on WSL) and works perfectly.  But leet fails it with of the field being passed to ```cut -f```.\\n\\t\\t\\tWhile not as efficient in time or memory as other solutions,  it is easier to understand without having to know ```awk``` syntax.\\n\\n```\\ncols=`head -1 file.txt | wc -w `\\n\\nfor x in $(seq 0 $cols)\\ndo\\n  cat file.txt | while read foo; do echo $foo; done | cut -f$x -d\" \" | xargs echo\\ndone\\n```\\n",
                "solutionTags": [],
                "code": "```cut -f```\n```awk```\n```\\ncols=`head -1 file.txt | wc -w `\\n\\nfor x in $(seq 0 $cols)\\ndo\\n  cat file.txt | while read foo; do echo $foo; done | cut -f$x -d\" \" | xargs echo\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 369851,
                "title": "beat-99-single-line",
                "content": "```\\ncat file.txt | awk \\'{for(i=0;++i<=NF;)a[i]=a[i]?a[i] FS $i:$i}END{for(i=0;i++<NF;)print a[i]}\\'\\n```",
                "solutionTags": [],
                "code": "```\\ncat file.txt | awk \\'{for(i=0;++i<=NF;)a[i]=a[i]?a[i] FS $i:$i}END{for(i=0;i++<NF;)print a[i]}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 353080,
                "title": "awk-single-line",
                "content": "awk \\'NR == 1 {for (i = 1; i <= NF; i++) {cols[i] = $i}} NR > 1 {for(i = 1; i <= NF; i++) {cols[i] = cols[i]\" \"$i}} END {for (k in cols) {print cols[k]}}\\' file.txt",
                "solutionTags": [],
                "code": "awk \\'NR == 1 {for (i = 1; i <= NF; i++) {cols[i] = $i}} NR > 1 {for(i = 1; i <= NF; i++) {cols[i] = cols[i]\" \"$i}} END {for (k in cols) {print cols[k]}}\\' file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 338464,
                "title": "trailing-whitespace",
                "content": "Heads up: if your answer contains trailing whitespace, an otherwise correct solution may not be accepted. Worth noting if you use awk with `ORS=\\' \\'`.",
                "solutionTags": [],
                "code": "Heads up: if your answer contains trailing whitespace, an otherwise correct solution may not be accepted. Worth noting if you use awk with `ORS=\\' \\'`.",
                "codeTag": "Unknown"
            },
            {
                "id": 337764,
                "title": "as-most-others-sulotion-with-awk",
                "content": "```\\nawk \\'{for(i=1;i<=NF;i++){array[NR][i]=$i;}} END{for (col=1; col <=NF; col++) {for (row=1; row <= NR; row++) {if (row==NR){printf(\"%s\", array[row][col]);}else {printf (\"%s \",array[row][col])}}printf \"\\\\n\";}}\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'{for(i=1;i<=NF;i++){array[NR][i]=$i;}} END{for (col=1; col <=NF; col++) {for (row=1; row <= NR; row++) {if (row==NR){printf(\"%s\", array[row][col]);}else {printf (\"%s \",array[row][col])}}printf \"\\\\n\";}}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 335023,
                "title": "faster-than-99-5-with-simple-awks",
                "content": "```\\ncat file.txt | head -n1 | awk \\'{print NF}\\' | xargs seq 1 \\\\\\n  | xargs -I {} sh -c \\\\\\n  \"cat file.txt | awk \\'{print \\\\${}}\\' | tr \\'\\\\n\\' \\' \\'  | sed -E \\'s/\\\\ +$//g\\' && echo\"\\n```",
                "solutionTags": [],
                "code": "```\\ncat file.txt | head -n1 | awk \\'{print NF}\\' | xargs seq 1 \\\\\\n  | xargs -I {} sh -c \\\\\\n  \"cat file.txt | awk \\'{print \\\\${}}\\' | tr \\'\\\\n\\' \\' \\'  | sed -E \\'s/\\\\ +$//g\\' && echo\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 331425,
                "title": "memory-usage-3-5-mb-less-than-99-28",
                "content": "```\\nfor ((i=1; i<=$(head -n 1 file.txt | wc -w);i++)){\\n echo $(cut -d \\' \\' -f $i file.txt)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfor ((i=1; i<=$(head -n 1 file.txt | wc -w);i++)){\\n echo $(cut -d \\' \\' -f $i file.txt)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 330250,
                "title": "awk-bash-8ms",
                "content": "```\\nnum_words=$((`cat file.txt | head -n 1 | wc -w`))  # 2\\nfor a in `seq 1 ${num_words}`; do\\n    awk -v col=\"$a\" \\'{\\n        printf \"%s \",$col; \\n    }\\n    END {\\n        print \"\"\\n    }\\' file.txt | sed -e \\'s/ $//\\'; done\\n```\\n\\nPretty simple solution. Had trouble with trailing whitespace so solved it with the sed call at the end.",
                "solutionTags": [],
                "code": "```\\nnum_words=$((`cat file.txt | head -n 1 | wc -w`))  # 2\\nfor a in `seq 1 ${num_words}`; do\\n    awk -v col=\"$a\" \\'{\\n        printf \"%s \",$col; \\n    }\\n    END {\\n        print \"\"\\n    }\\' file.txt | sed -e \\'s/ $//\\'; done\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 330024,
                "title": "awk-easy",
                "content": "```\\nawk \\'\\n{\\n\\tfor (i=1;i<=NF;i++) {\\n\\t\\tarr[i] = arr[i]\" \"$i;\\n\\t}\\n}\\nEND {\\n\\tfor (key in arr) {\\n\\t\\tsub(\" \",\"\",arr[key]);\\n\\t\\tprint arr[key]\\n\\t}\\n}\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'\\n{\\n\\tfor (i=1;i<=NF;i++) {\\n\\t\\tarr[i] = arr[i]\" \"$i;\\n\\t}\\n}\\nEND {\\n\\tfor (key in arr) {\\n\\t\\tsub(\" \",\"\",arr[key]);\\n\\t\\tprint arr[key]\\n\\t}\\n}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 302757,
                "title": "awk-4ms",
                "content": "cat file.txt |awk \\'BEGIN {Col_num=0} {if(NR==1) {for (i=1;i<=NF;++i) {a[i]=$i}; Col_num=NF} else if(NF==Col_num) {for (i=1;i<=NF;++i){a[i]=a[i]\" \"$i}} }   END{ for(i=1;i<=Col_num;++i){ print a[i] }  }\\'",
                "solutionTags": [],
                "code": "cat file.txt |awk \\'BEGIN {Col_num=0} {if(NR==1) {for (i=1;i<=NF;++i) {a[i]=$i}; Col_num=NF} else if(NF==Col_num) {for (i=1;i<=NF;++i){a[i]=a[i]\" \"$i}} }   END{ for(i=1;i<=Col_num;++i){ print a[i] }  }\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 249408,
                "title": "why-can-t-pass",
                "content": "A=`cat file.txt  |awk \\'{print $1}\\' |tr -t \\'\\\\n\\' \\' \\'`;\\necho $A\\nB=`cat file.txt  |awk \\'{print $2}\\' |tr -t  \\'\\\\n\\' \\' \\'`;\\necho $B",
                "solutionTags": [],
                "code": "A=`cat file.txt  |awk \\'{print $1}\\' |tr -t \\'\\\\n\\' \\' \\'`;\\necho $A\\nB=`cat file.txt  |awk \\'{print $2}\\' |tr -t  \\'\\\\n\\' \\' \\'`;\\necho $B",
                "codeTag": "Unknown"
            },
            {
                "id": 240226,
                "title": "one-line-awk",
                "content": "```\\ncat file.txt |awk \\'BEGIN{i=1;}{if(i == 1){for(x=1;x <= NF;x++){a[x-1]=$x}}else{for(x=1;x <= NF;x++){a[x-1]=a[x-1]\" \"$x}};i++}END{for(i=0;i<NF;i++)print a[i]}\\'\\n```",
                "solutionTags": [],
                "code": "```\\ncat file.txt |awk \\'BEGIN{i=1;}{if(i == 1){for(x=1;x <= NF;x++){a[x-1]=$x}}else{for(x=1;x <= NF;x++){a[x-1]=a[x-1]\" \"$x}};i++}END{for(i=0;i<NF;i++)print a[i]}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 235778,
                "title": "use-awk-nf-for-solution",
                "content": "##### first get column number\\ncolnum=`awk \\'END{print NF}\\' file.txt`\\n##### then use for loop print the anwser\\nfor i in $(seq 1 $colnum); \\n    do \\n    awk -v b=$i \\'{print $b}\\' file.txt|xargs; \\n    done",
                "solutionTags": [],
                "code": "##### first get column number\\ncolnum=`awk \\'END{print NF}\\' file.txt`\\n##### then use for loop print the anwser\\nfor i in $(seq 1 $colnum); \\n    do \\n    awk -v b=$i \\'{print $b}\\' file.txt|xargs; \\n    done",
                "codeTag": "Unknown"
            },
            {
                "id": 219569,
                "title": "12ms-awk-solution",
                "content": "awk -F\\' \\' \\'BEGIN{nb=0} {nb=NF;i=1;while(i<=NF){m[i]=m[i]\" \"$i;i=i+1}} END{i=1;while(i<=nb){print substr(m[i],2);i++}}\\' file.txt",
                "solutionTags": [],
                "code": "awk -F\\' \\' \\'BEGIN{nb=0} {nb=NF;i=1;while(i<=NF){m[i]=m[i]\" \"$i;i=i+1}} END{i=1;while(i<=nb){print substr(m[i],2);i++}}\\' file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 219457,
                "title": "20ms-awk",
                "content": "```\\nawk \\'{\\n    for(i=1;i<=NF;i++) \\n        a[NR][i]=$i\\n}END{\\n    for (i=1;i<=NF;i++) {\\n        for(j=1;j<=NR;j++)\\n            printf(\"%s \",a[j][i])\\n        print \"\\\\n\"\\n    }\\n}\\' file.txt|sed \\'/^$/d\\'|sed \\'s/ $//g\\'\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'{\\n    for(i=1;i<=NF;i++) \\n        a[NR][i]=$i\\n}END{\\n    for (i=1;i<=NF;i++) {\\n        for(j=1;j<=NR;j++)\\n            printf(\"%s \",a[j][i])\\n        print \"\\\\n\"\\n    }\\n}\\' file.txt|sed \\'/^$/d\\'|sed \\'s/ $//g\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 211802,
                "title": "using-bash-arrays",
                "content": "Adding a separator conditionally has added some ugliness, bit otherwise it is relatively clean:\\n```\\ndeclare -a result\\nwhile read p; do \\n\\ti=0\\n\\tfor w in $p; do\\n\\t\\tif [ \"x${result[$i]}\" != \"x\" ]; then\\n\\t\\t\\tresult[$i]+=\" \"\\n\\t\\tfi\\n\\t\\tresult[$i]+=$w\\n\\t\\ti=$(($i+1))\\n\\tdone\\t\\ndone < file.txt\\n\\nfor l in \"${result[@]}\"; do\\n\\techo \"$l\"\\ndone\\n\\n```",
                "solutionTags": [],
                "code": "```\\ndeclare -a result\\nwhile read p; do \\n\\ti=0\\n\\tfor w in $p; do\\n\\t\\tif [ \"x${result[$i]}\" != \"x\" ]; then\\n\\t\\t\\tresult[$i]+=\" \"\\n\\t\\tfi\\n\\t\\tresult[$i]+=$w\\n\\t\\ti=$(($i+1))\\n\\tdone\\t\\ndone < file.txt\\n\\nfor l in \"${result[@]}\"; do\\n\\techo \"$l\"\\ndone\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 204945,
                "title": "supposed-to-work-but-file-doesn-t-exist",
                "content": "My shortest solution:\\n```cat file.txt | awk \\'{line[1]=line[1]\" \"$1;line[2]=line[2]\" \"$2}END{print line[1]; print line[2]}\\'```",
                "solutionTags": [],
                "code": "```cat file.txt | awk \\'{line[1]=line[1]\" \"$1;line[2]=line[2]\" \"$2}END{print line[1]; print line[2]}\\'```",
                "codeTag": "Unknown"
            },
            {
                "id": 204461,
                "title": "awk-why-this-do-not-ok-please-help-me",
                "content": "```\\nawk \\'{for(i=1;i<=NF;i++)file[i][NR]=$i}END{for(i=1;i<=NF;i++){for(j=1;j<=NR;j++){printf(\"%s \",file[i][j])};printf(\"\\\\n\")}}\\' file.txt\\n```\\n\\nwhy this do not ok?",
                "solutionTags": [],
                "code": "```\\nawk \\'{for(i=1;i<=NF;i++)file[i][NR]=$i}END{for(i=1;i<=NF;i++){for(j=1;j<=NR;j++){printf(\"%s \",file[i][j])};printf(\"\\\\n\")}}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 202440,
                "title": "memory-limit-exceeded",
                "content": "This is a simple solution.  I need some help to figure out why this generates a \"memory limit exceeded\" on this problem.  Any tips from anyone?\\n```\\nwords=$(wc -w file.txt | awk {\\'print $1\\'})\\nlines=$(wc -l file.txt | awk {\\'print $1\\'})\\ncolumns=$(( $words / $lines ))\\nif [ $columns -eq 1 ]\\nthen\\n    cut -f 1 -d \" \" file.txt | paste -sd \" \" -\\nelse\\n    for i in `seq 1 $columns`; do cut -f $i -sd \" \" file.txt | paste -sd \" \" -; done\\nfi\\n```",
                "solutionTags": [],
                "code": "```\\nwords=$(wc -w file.txt | awk {\\'print $1\\'})\\nlines=$(wc -l file.txt | awk {\\'print $1\\'})\\ncolumns=$(( $words / $lines ))\\nif [ $columns -eq 1 ]\\nthen\\n    cut -f 1 -d \" \" file.txt | paste -sd \" \" -\\nelse\\n    for i in `seq 1 $columns`; do cut -f $i -sd \" \" file.txt | paste -sd \" \" -; done\\nfi\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 196656,
                "title": "a-very-slow-solution",
                "content": "```\\ntext=`cat file.txt`\\nIFS=$\\'\\\\n\\'\\nlines=($text)\\ndeclare -a array\\narray=()\\nfor line in ${lines[@]}\\ndo\\n    IFS=\\' \\'\\n    words=($line)\\n    for w in ${!words[@]}\\n    do\\n        array[$w]=\"${array[$w]} ${words[$w]}\"\\n    done\\ndone\\nfor i in ${!array[@]}\\ndo\\n    echo ${array[$i]}\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\ntext=`cat file.txt`\\nIFS=$\\'\\\\n\\'\\nlines=($text)\\ndeclare -a array\\narray=()\\nfor line in ${lines[@]}\\ndo\\n    IFS=\\' \\'\\n    words=($line)\\n    for w in ${!words[@]}\\n    do\\n        array[$w]=\"${array[$w]} ${words[$w]}\"\\n    done\\ndone\\nfor i in ${!array[@]}\\ndo\\n    echo ${array[$i]}\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 183456,
                "title": "bash-transpose-file",
                "content": "Why the site says following bash code is wrong to transpose a file, file.txt:\\na 1\\nb 2\\nc 3\\n\\n```#!/bin/bash\\ncut -d \" \" -f1 file.txt|paste -d \" \" -s\\ncut -d \" \" -f2 file.txt|paste -d \" \" -s\\n```",
                "solutionTags": [],
                "code": "```#!/bin/bash\\ncut -d \" \" -f1 file.txt|paste -d \" \" -s\\ncut -d \" \" -f2 file.txt|paste -d \" \" -s\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 173533,
                "title": "solution-that-actually-uses-bash-as-opposed-to-awk-cut-sort-etc",
                "content": "Unlike many others I tried to come up with a solution that actually uses bash (as opposed to awk, cut, sort, etc) However it won\\'t pass and I can\\'t figure out why, here it is:\\n\\n```\\n#!/bin/bash\\n\\ndeclare -a names\\ndeclare -a ages\\n\\nwhile read line\\ndo \\n\\twords=($line)\\n\\tnames+=(${words[0]})\\n\\tages+=(${words[1]})\\ndone < file.txt\\n\\nfor name in ${names[@]}\\ndo \\n\\tprintf \"%s \" $name\\ndone\\n\\nprintf \"\\\\n\"\\n\\nfor age in ${ages[@]}\\ndo \\n\\tprintf \"%s \" $age\\ndone\\n```\\n\\nIt says wrong answer:\\n\\nInput:\\na\\nOutput:\\na \\nExpected:\\na\\n\\nWTF?",
                "solutionTags": [],
                "code": "```\\n#!/bin/bash\\n\\ndeclare -a names\\ndeclare -a ages\\n\\nwhile read line\\ndo \\n\\twords=($line)\\n\\tnames+=(${words[0]})\\n\\tages+=(${words[1]})\\ndone < file.txt\\n\\nfor name in ${names[@]}\\ndo \\n\\tprintf \"%s \" $name\\ndone\\n\\nprintf \"\\\\n\"\\n\\nfor age in ${ages[@]}\\ndo \\n\\tprintf \"%s \" $age\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 168510,
                "title": "what-format-does-it-want-for-bash",
                "content": "A simple stupid solution like..\\n\\n```bash\\nN=$(awk \\'{print $1}\\'< file.txt)\\nA=$(awk \\'{print $2}\\'< file.txt)\\necho $N\\necho $A\\n```\\n\\nGets marked as wrong and says it outputs just \\'a\\'. I assume I\\'m not writing the script the way the site wants it somehow..\\n",
                "solutionTags": [],
                "code": "```bash\\nN=$(awk \\'{print $1}\\'< file.txt)\\nA=$(awk \\'{print $2}\\'< file.txt)\\necho $N\\necho $A\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 163881,
                "title": "my-simple-solution-with-awk",
                "content": "cat  file.txt | awk \\'BEGIN {col=NF;NR=0;} { for (i=1;i<=NF;i++) {a[NR,i]=$i;} }  END { for (i=1;i<=NF;i++) { str=a[1,i]; for (j=2;j<=NR;j++) {str=str\" \"a[j,i];} print str;}}\\'",
                "solutionTags": [],
                "code": "cat  file.txt | awk \\'BEGIN {col=NF;NR=0;} { for (i=1;i<=NF;i++) {a[NR,i]=$i;} }  END { for (i=1;i<=NF;i++) { str=a[1,i]; for (j=2;j<=NR;j++) {str=str\" \"a[j,i];} print str;}}\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 151469,
                "title": "please-help-me-runtime-error",
                "content": "```\\nnum=`cat file.txt | awk \\'END{print NF}\\'`\\nfor ((i=1;i<=$num;i++));do\\n\\trow=`cut -d \" \" -f $i file.txt|tr \\'\\\\n\\' \\' \\'|sed \\'s/ $//g\\'`\\n\\techo $row\\ndone\\n```\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/marcsea/image_1531985514.png)\\nI got the runtime error when I met the input above.",
                "solutionTags": [],
                "code": "```\\nnum=`cat file.txt | awk \\'END{print NF}\\'`\\nfor ((i=1;i<=$num;i++));do\\n\\trow=`cut -d \" \" -f $i file.txt|tr \\'\\\\n\\' \\' \\'|sed \\'s/ $//g\\'`\\n\\techo $row\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 140791,
                "title": "this-is-general-awk-piece-to-convert-from-line-to-col-or-reverse",
                "content": "{\\n    for (i=1;i<=NF;i++) {\\n        arr[i, NR]=$i;\\n        if (nf<=NF) {\\n            nf=NF\\n            }\\n    }\\n}\\nEND {\\n    for (j=1;j<=nf;j++){\\n        for (i=1;i<=NR;i++){\\n            printf(\"%s \", arr[j,i]);\\n            }\\n        printf(\"\\\\n\");\\n        }\\n    }\\n",
                "solutionTags": [],
                "code": "{\\n    for (i=1;i<=NF;i++) {\\n        arr[i, NR]=$i;\\n        if (nf<=NF) {\\n            nf=NF\\n            }\\n    }\\n}\\nEND {\\n    for (j=1;j<=nf;j++){\\n        for (i=1;i<=NR;i++){\\n            printf(\"%s \", arr[j,i]);\\n            }\\n        printf(\"\\\\n\");\\n        }\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 130990,
                "title": "two-solution",
                "content": "first: 16ms\\n```\\nawk \\'{for(i=1;i<=NF;i++){if(NR==1){arr[i]=$i}else{arr[i]=arr[i]\" \"$i}}}END{for(i=1;i<=NF;i++){printf arr[i];if(i!=NF){printf \"\\\\n\"}}}\\' file.txt\\n```\\nsecond: 40ms\\n```\\n awk \\'{for(i=1;i<=NF;i++){arr[i,NR]=$i;}}END{for(i=1;i<=NF;i++){for(j=1;j<=NR;j++){printf arr[i,j];if(j!=NR){printf \" \"}}if(i!=NF){printf \"\\\\n\"}}}\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'{for(i=1;i<=NF;i++){if(NR==1){arr[i]=$i}else{arr[i]=arr[i]\" \"$i}}}END{for(i=1;i<=NF;i++){printf arr[i];if(i!=NF){printf \"\\\\n\"}}}\\' file.txt\\n```\n```\\n awk \\'{for(i=1;i<=NF;i++){arr[i,NR]=$i;}}END{for(i=1;i<=NF;i++){for(j=1;j<=NR;j++){printf arr[i,j];if(j!=NR){printf \" \"}}if(i!=NF){printf \"\\\\n\"}}}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 130022,
                "title": "simple-oneliner-solution",
                "content": "\\n```for i in `seq 1 $(head -1 file.txt | wc -w)`; do awk -v I=$i \\'{print $I}\\' file.txt | tr \\'\\\\n\\' \\' \\'; echo; done;```",
                "solutionTags": [],
                "code": "```for i in `seq 1 $(head -1 file.txt | wc -w)`; do awk -v I=$i \\'{print $I}\\' file.txt | tr \\'\\\\n\\' \\' \\'; echo; done;```",
                "codeTag": "Unknown"
            },
            {
                "id": 114344,
                "title": "awk-with-2-d-array",
                "content": "```\\nawk '{for(i=1; i<=NF; i++) a[i,NR]=$i} END {for(i=1; a[i,1]!=\"\"; i++) {for(j=1; j<NR; j++) printf a[i,j] \" \"; print a[i,NR]}}' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk '{for(i=1; i<=NF; i++) a[i,NR]=$i} END {for(i=1; a[i,1]!=\"\"; i++) {for(j=1; j<NR; j++) printf a[i,j] \" \"; print a[i,NR]}}' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55505,
                "title": "memory-limit",
                "content": "I've got memory limit with this code but 17/17 passed\\n...\\ncounter=1\\nwhile (( $(head -n1 file.txt | wc -w) >= $counter ))\\ndo \\n    cut -d\" \" -f$counter file.txt | paste -s -d\" \"\\n    counter=$(($counter+1))\\ndone\\n...",
                "solutionTags": [],
                "code": "I've got memory limit with this code but 17/17 passed\\n...\\ncounter=1\\nwhile (( $(head -n1 file.txt | wc -w) >= $counter ))\\ndo \\n    cut -d\" \" -f$counter file.txt | paste -s -d\" \"\\n    counter=$(($counter+1))\\ndone\\n...",
                "codeTag": "Unknown"
            },
            {
                "id": 55506,
                "title": "my-solution-with-awk-and-sed-faster-than-only-awk",
                "content": "awk '{for(i=1; i<=NF;i++){line[i] = line[i]\" \"$i}} END{for(i=1;i<=NF;i++){print line[i]}}' file.txt |sed 's/^\\\\ //g'",
                "solutionTags": [],
                "code": "awk '{for(i=1; i<=NF;i++){line[i] = line[i]\" \"$i}} END{for(i=1;i<=NF;i++){print line[i]}}' file.txt |sed 's/^\\\\ //g'",
                "codeTag": "Unknown"
            },
            {
                "id": 55507,
                "title": "what-is-wrong-with-this-bash-solution",
                "content": "What is wrong with this solution?\\n\\n```\\ncount=`head -1 file.txt | egrep -c \" \"`\\ncount=$(expr $count + 1)\\nfor i in $(seq 1 $count); do\\n   cat file.txt  | cut -f$i -d \" \" | tr \"\\\\n\" \" \" | sed -e 's/ $//g'\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\ncount=`head -1 file.txt | egrep -c \" \"`\\ncount=$(expr $count + 1)\\nfor i in $(seq 1 $count); do\\n   cat file.txt  | cut -f$i -d \" \" | tr \"\\\\n\" \" \" | sed -e 's/ $//g'\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55508,
                "title": "what-is-wrong-with-my-solution",
                "content": "The test seems to be too picky about newlines!\\n\\n```\\ngname=()\\ngage=()\\nwhile read name age; do\\n    gname+=( $name )\\n    gage+=( $age )\\ndone < file.txt\\n\\necho \"${gname[@]}\"\\n#echo \"${gage[@]}\"\\n[[ -n $gage ]] && echo \"${gage[@]}\" #fix first test\\n```",
                "solutionTags": [],
                "code": "```\\ngname=()\\ngage=()\\nwhile read name age; do\\n    gname+=( $name )\\n    gage+=( $age )\\ndone < file.txt\\n\\necho \"${gname[@]}\"\\n#echo \"${gage[@]}\"\\n[[ -n $gage ]] && echo \"${gage[@]}\" #fix first test\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55509,
                "title": "why-i-use-awk-in-my-system-is-right-but-in-leetcode-is-wrong",
                "content": "awk 'BEGIN {ORS=\" \";count=0} {name[count]=$1; age[count]=$2; count++} END {for(i=0;i<NR;i++) print name[i];print \"\\\\n\";for(i=0;i<NR;i++) print age[i]}'",
                "solutionTags": [],
                "code": "awk 'BEGIN {ORS=\" \";count=0} {name[count]=$1; age[count]=$2; count++} END {for(i=0;i<NR;i++) print name[i];print \"\\\\n\";for(i=0;i<NR;i++) print age[i]}'",
                "codeTag": "Unknown"
            },
            {
                "id": 55519,
                "title": "it-gives-me-the-expected-answer-but-does-not-pass-the-test-anything-wrong",
                "content": "NLINES=$(wc -l < \"file.txt\")\\nawk '{printf \"%s \", $1}' file.txt\\nif [ $NLINES -ge 2 ]; then\\n    echo\\nfi\\nawk '{printf \"%s \", $2}' file.txt\\necho",
                "solutionTags": [],
                "code": "NLINES=$(wc -l < \"file.txt\")\\nawk '{printf \"%s \", $1}' file.txt\\nif [ $NLINES -ge 2 ]; then\\n    echo\\nfi\\nawk '{printf \"%s \", $2}' file.txt\\necho",
                "codeTag": "Unknown"
            },
            {
                "id": 55518,
                "title": "my-solution-not-being-accepted",
                "content": "    #!bin/bash\\n    \\n    i=0\\n    while read p; do\\n    \\tj=0\\n    \\tfor word in $p\\n    \\t\\tdo\\n    \\t\\t\\t#echo \"i value:\" $i \"j value:\" $j \"word value:\" $word\\n    \\t\\t\\tif [ $j -eq 0 ];\\n    \\t\\t\\tthen\\n    \\t\\t\\t\\t#echo \"inside name\"\\n    \\t\\t\\t\\tname[$i]=$word\\n    \\t\\t\\t\\t((j++))\\n    \\t\\t\\t\\t#echo \" name value\" ${name[$i]}\\n    \\t\\t\\telse\\n    \\t\\t\\t\\t#echo \"inside age\"\\n    \\t\\t\\t\\tage[$i]=$word\\n    \\t\\t\\t\\t#echo \" age value\" ${age[$i]}\\n    \\t\\t\\tfi\\n    \\t\\tdone\\n    \\t((i++))\\n    done < file.txt\\n    \\n    printf \"%s \" ${name[@]}\\n    echo\\n    printf \"%s \" ${age[@]}",
                "solutionTags": [],
                "code": "    #!bin/bash\\n    \\n    i=0\\n    while read p; do\\n    \\tj=0\\n    \\tfor word in $p\\n    \\t\\tdo\\n    \\t\\t\\t#echo \"i value:\" $i \"j value:\" $j \"word value:\" $word\\n    \\t\\t\\tif [ $j -eq 0 ];\\n    \\t\\t\\tthen\\n    \\t\\t\\t\\t#echo \"inside name\"\\n    \\t\\t\\t\\tname[$i]=$word\\n    \\t\\t\\t\\t((j++))\\n    \\t\\t\\t\\t#echo \" name value\" ${name[$i]}\\n    \\t\\t\\telse\\n    \\t\\t\\t\\t#echo \"inside age\"\\n    \\t\\t\\t\\tage[$i]=$word\\n    \\t\\t\\t\\t#echo \" age value\" ${age[$i]}\\n    \\t\\t\\tfi\\n    \\t\\tdone\\n    \\t((i++))\\n    done < file.txt\\n    \\n    printf \"%s \" ${name[@]}\\n    echo\\n    printf \"%s \" ${age[@]}",
                "codeTag": "Unknown"
            },
            {
                "id": 55521,
                "title": "why-can-t-i-pass-this-problem-by-using-awk",
                "content": "Code is as follows, please give me a suggestion\\uff1a\\nawk -F ' ' '{for (i=1; i <= NF; i++){s[i] = (s[i]\"\"$i\"\"\" \")}} END{for (a in s)print s[a]}'  file.txt",
                "solutionTags": [],
                "code": "Code is as follows, please give me a suggestion\\uff1a\\nawk -F ' ' '{for (i=1; i <= NF; i++){s[i] = (s[i]\"\"$i\"\"\" \")}} END{for (a in s)print s[a]}'  file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 55503,
                "title": "my-solution-written-only-in-bash",
                "content": "    array=()\\n    \\n    while read -a columns; do\\n        for (( i = 0; i < ${#columns[@]}; i++ )); do\\n            array[i]=\"${array[i]} ${columns[i]}\"\\n        done\\n    done < file.txt\\n    \\n    for (( i = 0; i < ${#array[@]}; i++ )); do\\n        echo ${array[i]}\\n    done\\n\\nTaught by @yongjhih",
                "solutionTags": [],
                "code": "    array=()\\n    \\n    while read -a columns; do\\n        for (( i = 0; i < ${#columns[@]}; i++ )); do\\n            array[i]=\"${array[i]} ${columns[i]}\"\\n        done\\n    done < file.txt\\n    \\n    for (( i = 0; i < ${#array[@]}; i++ )); do\\n        echo ${array[i]}\\n    done\\n\\nTaught by @yongjhih",
                "codeTag": "Unknown"
            },
            {
                "id": 55525,
                "title": "my-ac-code-just-use-bash-array",
                "content": "    empty=\" \"\\n    i=0\\n    while read line\\n    do \\n    \\tif [ $i -eq 0 ]; then\\n    \\t\\tarray=($line)\\n    \\telse\\n    \\t\\ttmp=($line)\\n    \\t\\tlen=${#tmp[@]}\\n    \\t\\tk=0\\n    \\t\\twhile [ $k -lt $len ]\\n    \\t\\tdo \\n    \\t\\t\\tarray[$k]=${array[$k]}$empty${tmp[$k]}\\n    \\t\\t\\tlet k++\\n    \\t\\tdone\\n    \\tfi\\n    \\tlet i++\\n    done < file.txt\\n    \\n    #print result\\n    for ((i=0;i<${#array[@]};i++));\\n    do\\n    \\techo ${array[$i]}\\n    done",
                "solutionTags": [],
                "code": "    empty=\" \"\\n    i=0\\n    while read line\\n    do \\n    \\tif [ $i -eq 0 ]; then\\n    \\t\\tarray=($line)\\n    \\telse\\n    \\t\\ttmp=($line)\\n    \\t\\tlen=${#tmp[@]}\\n    \\t\\tk=0\\n    \\t\\twhile [ $k -lt $len ]\\n    \\t\\tdo \\n    \\t\\t\\tarray[$k]=${array[$k]}$empty${tmp[$k]}\\n    \\t\\t\\tlet k++\\n    \\t\\tdone\\n    \\tfi\\n    \\tlet i++\\n    done < file.txt\\n    \\n    #print result\\n    for ((i=0;i<${#array[@]};i++));\\n    do\\n    \\techo ${array[$i]}\\n    done",
                "codeTag": "Unknown"
            },
            {
                "id": 55513,
                "title": "wrong-answer-with-input-a-for-transpose-file-in-bash-oj-s-mistake",
                "content": "I have submitted the following code as an answer to \"transpose file with bash\", and LeetCode OJ decides it spits wrong answer for input 'a' while both the output and the expected values are 'a'. I am confused...\\n\\n    #!/bin/bash\\n    fname='file.txt'\\n    #fname=$1\\n    nlines=$(wc -l < \"$fname\")\\n    ncol=$(awk '{print NF; exit}' $fname)\\n    #echo nlines $nlines ncol $ncol\\n    row_id=0\\n    {![enter image description here][1]\\n      while read -a line; do\\n        row_id=$((row_id+1))\\n        #echo read row $row_id\\n        for j in \"${!line[@]}\"; do\\n          i=$((j+1))\\n          #echo row $row_id column $i\\n          #echo $(( (row_id-1) * (ncol) + i))\\n          r[$(( (row_id-1) * ncol + i))]=${line[$j]}\\n          #echo '####' element ${r[$(( (row_id-1) * (ncol) + i))]} '####'\\n        done\\n      done\\n    } < $fname\\n    \\n    for(( j=1; j<=$ncol; j++)) do\\n      for(( k=1; k<=$((nlines)); k++)) do\\n      if [ -n \"${r[$(( (k-1) * ncol + j))]}\" ]; then\\n          echo -n \"${r[$(( (k-1) * ncol + j))]}\"' '\\n        fi\\n      done\\n      echo\\n    done\\n\\n\\n![Screenshot of the OJ's output][1]\\n\\n\\n  [1]: https://dl.dropboxusercontent.com/u/83334653/LeetCodeOJ_transposeFile.png",
                "solutionTags": [],
                "code": "I have submitted the following code as an answer to \"transpose file with bash\", and LeetCode OJ decides it spits wrong answer for input 'a' while both the output and the expected values are 'a'. I am confused...\\n\\n    #!/bin/bash\\n    fname='file.txt'\\n    #fname=$1\\n    nlines=$(wc -l < \"$fname\")\\n    ncol=$(awk '{print NF; exit}' $fname)\\n    #echo nlines $nlines ncol $ncol\\n    row_id=0\\n    {![enter image description here][1]\\n      while read -a line; do\\n        row_id=$((row_id+1))\\n        #echo read row $row_id\\n        for j in \"${!line[@]}\"; do\\n          i=$((j+1))\\n          #echo row $row_id column $i\\n          #echo $(( (row_id-1) * (ncol) + i))\\n          r[$(( (row_id-1) * ncol + i))]=${line[$j]}\\n          #echo '####' element ${r[$(( (row_id-1) * (ncol) + i))]} '####'\\n        done\\n      done\\n    } < $fname\\n    \\n    for(( j=1; j<=$ncol; j++)) do\\n      for(( k=1; k<=$((nlines)); k++)) do\\n      if [ -n \"${r[$(( (k-1) * ncol + j))]}\" ]; then\\n          echo -n \"${r[$(( (k-1) * ncol + j))]}\"' '\\n        fi\\n      done\\n      echo\\n    done\\n\\n\\n![Screenshot of the OJ's output][1]\\n\\n\\n  [1]: https://dl.dropboxusercontent.com/u/83334653/LeetCodeOJ_transposeFile.png",
                "codeTag": "Unknown"
            },
            {
                "id": 55527,
                "title": "ac-solution-with-question",
                "content": "This is the AC solution using a big array to store all elements from stack exchange\\n\\n    awk '\\n    { \\n        for (i=1; i<=NF; i++)  {\\n            a[NR,i] = $i\\n        }\\n    }\\n    NF>p { p = NF }\\n    END {    \\n        for(j=1; j<=p; j++) {\\n            str=a[1,j]\\n            for(i=2; i<=NR; i++){\\n                str=str\" \"a[i,j];\\n            }\\n            print str\\n        }\\n    }' file.txt\\n\\n\\nThen I tried to improve it somehow by using \"attaching\" idea and got the following code which \"should\" be better I think:\\n\\n\\n     col=`head -1 \"file.txt\"|awk '{print NF'}`\\n     echo $col\\n        \\n        \\n     for((i=1;i<=$col;i++))\\n     do\\n         awk '{printf \"%s %s\",$'\"$i\"',\" \"}END{print \"\"}' file.txt\\n     done\\n\\n\\n\\nthen I got Memory exceed result. Would someone please enlighten me on this?",
                "solutionTags": [],
                "code": "This is the AC solution using a big array to store all elements from stack exchange\\n\\n    awk '\\n    { \\n        for (i=1; i<=NF; i++)  {\\n            a[NR,i] = $i\\n        }\\n    }\\n    NF>p { p = NF }\\n    END {    \\n        for(j=1; j<=p; j++) {\\n            str=a[1,j]\\n            for(i=2; i<=NR; i++){\\n                str=str\" \"a[i,j];\\n            }\\n            print str\\n        }\\n    }' file.txt\\n\\n\\nThen I tried to improve it somehow by using \"attaching\" idea and got the following code which \"should\" be better I think:\\n\\n\\n     col=`head -1 \"file.txt\"|awk '{print NF'}`\\n     echo $col\\n        \\n        \\n     for((i=1;i<=$col;i++))\\n     do\\n         awk '{printf \"%s %s\",$'\"$i\"',\" \"}END{print \"\"}' file.txt\\n     done\\n\\n\\n\\nthen I got Memory exceed result. Would someone please enlighten me on this?",
                "codeTag": "Unknown"
            },
            {
                "id": 3985001,
                "title": "efficient-matrix-transposition-with-awk",
                "content": "# Intuition\\nWhen presented with the problem of transposing a matrix in the form of a file, one might first think of using nested loops: an outer loop for columns and an inner loop for rows. But with AWK, a powerful pattern scanning and processing language, we can perform the transposition in a more elegant manner.\\n\\n# Approach\\nThe script uses the power of associative arrays in AWK:\\n    We loop through each field in the input rows using for (i=1; i<=NF; i++). Here, NF represents the number of fields in the current record, essentially giving us the column count.\\n    Within this loop, we\\'re building our associative array a. The key to this array is the column number i, and we\\'re appending the current field value $i to this key. If a[i] already has a value, we append the new value with a space, otherwise, we simply set the new value.\\n    Once all rows have been processed, we enter the END block where we print out each value of our associative array a using for (i in a). This gives us the transposed matrix.\\n\\n# Complexity\\n- Time complexity:\\n O(n\\xD7m)O(n\\xD7m) where nn is the number of rows and mm is the number of columns. We are effectively visiting each cell of the matrix once.\\n\\n- Space complexity:\\nO(n\\xD7m)O(n\\xD7m) as we need to store the entire transposed matrix in memory.\\n\\n# Code\\n```\\nawk \\'{for (i=1; i<=NF; i++) a[i]=a[i] ? a[i] \" \" $i : $i} END {for (i in a) print a[i]}\\' file.txt\\n\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```\\nawk \\'{for (i=1; i<=NF; i++) a[i]=a[i] ? a[i] \" \" $i : $i} END {for (i in a) print a[i]}\\' file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1392995,
                "title": "map-reduce-type-solution-with-awk",
                "content": "A simple awk-heavy solution which first outputs every field with its field number, e.g.\\n\\n```\\n1   name\\n2   age\\n1   alice\\n2   21\\n1   ryan\\n2   30\\n```\\n\\nthen does a stable sort (`sort -s`) on the field numbers, then combines them with awk again:\\n\\n```\\nawk \\'{for (i=1;i<=NF;i++) print i, \" \", $i}\\' file.txt \\\\\\n   | sort -snk 1 \\\\\\n   | awk \\'BEGIN {i=1; start=1} {\\n\\t   if ($1 != i) {i = $1; printf \"\\\\n\"; start=1}; \\n\\t   if (start != 1) printf \" \"; \\n\\t   printf \"%s\", $2; start=0}\\'\\n```",
                "solutionTags": [],
                "code": "```\\n1   name\\n2   age\\n1   alice\\n2   21\\n1   ryan\\n2   30\\n```\n```\\nawk \\'{for (i=1;i<=NF;i++) print i, \" \", $i}\\' file.txt \\\\\\n   | sort -snk 1 \\\\\\n   | awk \\'BEGIN {i=1; start=1} {\\n\\t   if ($1 != i) {i = $1; printf \"\\\\n\"; start=1}; \\n\\t   if (start != 1) printf \" \"; \\n\\t   printf \"%s\", $2; start=0}\\'\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1569014,
                "content": [
                    {
                        "username": "illuz",
                        "content": "Is O(n) or O(nlogn) space can solve this problem?  \\n\\nI have a idea:  \\n**Record the \"current position\" of every line and loop.**  \\n\\nBut I don't know how to implement it.  \\n\\nIs there an implement or other ideas?"
                    },
                    {
                        "username": "gemtra",
                        "content": "num=`awk \\'END{print NF}\\' file.txt`\\nfor i in `seq 1 $num`;do cut -d \\' \\' -f $i file.txt|xargs; done"
                    },
                    {
                        "username": "firejox",
                        "content": "seq 1 $(head -1 file.txt | wc -w) | xargs -I \\'{}\\' bash -c \"cut -d \\'\"\\' \\'\"\\' -f {} file.txt| xargs\""
                    },
                    {
                        "username": "caspergao",
                        "content": "# awk \\'{print $1;}\\' file.txt |tr -s \\'\\\\n\\' \\' \\';echo \\'\\';awk \\'{print $2;}\\' file.txt |tr -s \\'\\\\n\\' \\' \\';echo \\'\\'\\nname alice ryan \\nage 21 30 "
                    },
                    {
                        "username": "patrickfung",
                        "content": "echo $(cat file.txt|cut -d \\' \\' -f 1) && echo $(cat file.txt|cut -d \\' \\' -f 2)\\n\\nname alice ryan\\nage 21 30\\n"
                    }
                ]
            },
            {
                "id": 1573207,
                "content": [
                    {
                        "username": "illuz",
                        "content": "Is O(n) or O(nlogn) space can solve this problem?  \\n\\nI have a idea:  \\n**Record the \"current position\" of every line and loop.**  \\n\\nBut I don't know how to implement it.  \\n\\nIs there an implement or other ideas?"
                    },
                    {
                        "username": "gemtra",
                        "content": "num=`awk \\'END{print NF}\\' file.txt`\\nfor i in `seq 1 $num`;do cut -d \\' \\' -f $i file.txt|xargs; done"
                    },
                    {
                        "username": "firejox",
                        "content": "seq 1 $(head -1 file.txt | wc -w) | xargs -I \\'{}\\' bash -c \"cut -d \\'\"\\' \\'\"\\' -f {} file.txt| xargs\""
                    },
                    {
                        "username": "caspergao",
                        "content": "# awk \\'{print $1;}\\' file.txt |tr -s \\'\\\\n\\' \\' \\';echo \\'\\';awk \\'{print $2;}\\' file.txt |tr -s \\'\\\\n\\' \\' \\';echo \\'\\'\\nname alice ryan \\nage 21 30 "
                    },
                    {
                        "username": "patrickfung",
                        "content": "echo $(cat file.txt|cut -d \\' \\' -f 1) && echo $(cat file.txt|cut -d \\' \\' -f 2)\\n\\nname alice ryan\\nage 21 30\\n"
                    }
                ]
            },
            {
                "id": 1572415,
                "content": [
                    {
                        "username": "illuz",
                        "content": "Is O(n) or O(nlogn) space can solve this problem?  \\n\\nI have a idea:  \\n**Record the \"current position\" of every line and loop.**  \\n\\nBut I don't know how to implement it.  \\n\\nIs there an implement or other ideas?"
                    },
                    {
                        "username": "gemtra",
                        "content": "num=`awk \\'END{print NF}\\' file.txt`\\nfor i in `seq 1 $num`;do cut -d \\' \\' -f $i file.txt|xargs; done"
                    },
                    {
                        "username": "firejox",
                        "content": "seq 1 $(head -1 file.txt | wc -w) | xargs -I \\'{}\\' bash -c \"cut -d \\'\"\\' \\'\"\\' -f {} file.txt| xargs\""
                    },
                    {
                        "username": "caspergao",
                        "content": "# awk \\'{print $1;}\\' file.txt |tr -s \\'\\\\n\\' \\' \\';echo \\'\\';awk \\'{print $2;}\\' file.txt |tr -s \\'\\\\n\\' \\' \\';echo \\'\\'\\nname alice ryan \\nage 21 30 "
                    },
                    {
                        "username": "patrickfung",
                        "content": "echo $(cat file.txt|cut -d \\' \\' -f 1) && echo $(cat file.txt|cut -d \\' \\' -f 2)\\n\\nname alice ryan\\nage 21 30\\n"
                    }
                ]
            },
            {
                "id": 1571882,
                "content": [
                    {
                        "username": "illuz",
                        "content": "Is O(n) or O(nlogn) space can solve this problem?  \\n\\nI have a idea:  \\n**Record the \"current position\" of every line and loop.**  \\n\\nBut I don't know how to implement it.  \\n\\nIs there an implement or other ideas?"
                    },
                    {
                        "username": "gemtra",
                        "content": "num=`awk \\'END{print NF}\\' file.txt`\\nfor i in `seq 1 $num`;do cut -d \\' \\' -f $i file.txt|xargs; done"
                    },
                    {
                        "username": "firejox",
                        "content": "seq 1 $(head -1 file.txt | wc -w) | xargs -I \\'{}\\' bash -c \"cut -d \\'\"\\' \\'\"\\' -f {} file.txt| xargs\""
                    },
                    {
                        "username": "caspergao",
                        "content": "# awk \\'{print $1;}\\' file.txt |tr -s \\'\\\\n\\' \\' \\';echo \\'\\';awk \\'{print $2;}\\' file.txt |tr -s \\'\\\\n\\' \\' \\';echo \\'\\'\\nname alice ryan \\nage 21 30 "
                    },
                    {
                        "username": "patrickfung",
                        "content": "echo $(cat file.txt|cut -d \\' \\' -f 1) && echo $(cat file.txt|cut -d \\' \\' -f 2)\\n\\nname alice ryan\\nage 21 30\\n"
                    }
                ]
            },
            {
                "id": 1973625,
                "content": [
                    {
                        "username": "illuz",
                        "content": "Is O(n) or O(nlogn) space can solve this problem?  \\n\\nI have a idea:  \\n**Record the \"current position\" of every line and loop.**  \\n\\nBut I don't know how to implement it.  \\n\\nIs there an implement or other ideas?"
                    },
                    {
                        "username": "gemtra",
                        "content": "num=`awk \\'END{print NF}\\' file.txt`\\nfor i in `seq 1 $num`;do cut -d \\' \\' -f $i file.txt|xargs; done"
                    },
                    {
                        "username": "firejox",
                        "content": "seq 1 $(head -1 file.txt | wc -w) | xargs -I \\'{}\\' bash -c \"cut -d \\'\"\\' \\'\"\\' -f {} file.txt| xargs\""
                    },
                    {
                        "username": "caspergao",
                        "content": "# awk \\'{print $1;}\\' file.txt |tr -s \\'\\\\n\\' \\' \\';echo \\'\\';awk \\'{print $2;}\\' file.txt |tr -s \\'\\\\n\\' \\' \\';echo \\'\\'\\nname alice ryan \\nage 21 30 "
                    },
                    {
                        "username": "patrickfung",
                        "content": "echo $(cat file.txt|cut -d \\' \\' -f 1) && echo $(cat file.txt|cut -d \\' \\' -f 2)\\n\\nname alice ryan\\nage 21 30\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Flip Game II",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1565434,
                "content": [
                    {
                        "username": "SylvanasWindrunner",
                        "content": "I'm not sure why the simple recursive algorithm would work. It replaces every pair of \"++\" in the original string with \"--\" and ask the questions: can my opponent win? \\n\\nHowever, the canWin() function returns true if the current player is \"guarantee a win\", and it returns false if the current player cannot guarantee a win - meaning the current player might win or lose depending on the action of the opponent. If this is the case, why algorithm like [this][1] works?\\n\\n\\n\\n \\n\\n\\n  [1]: https://leetcode.com/discuss/64291/share-my-java-backtracking-solution"
                    },
                    {
                        "username": "n_leetcode",
                        "content": "\"+++++++++\"\\n\\nPlayer a plays: \"+--++++++\"\\nPlayer b plays: \"+--+--+++\"\\nPlayer a plays: \"+--+--+--\"\\nPlayer b\\'s turn, he has no move to play. So (starting) player A wins.\\n\\nwhy does this testcase return false?\\n"
                    },
                    {
                        "username": "sachinppuranik",
                        "content": "Player a plays: \"+--++++++\"\\nPlayer b plays: \"+--++--++\"\\nPlayer a plays: \"+------++\"\\nPlayer b plays: \"+--------\"\\nNow player a has no move."
                    },
                    {
                        "username": "dilit",
                        "content": "You have to account for turn switching.  \nIf A plays +++--++++, B can play in ++++ half to lose in that half, but grab the turn to play first on the +++ side where it wins."
                    },
                    {
                        "username": "Zhuzeng",
                        "content": "Can anyone please confirm why the expected result for the following test case is TRUE?\\n\"++++-++++++\"\\n\\nMy code failed because my alg is giving 'false', but I am a little confused why the OJ gives 'TRUE'. No matter what the first player does, the second player can find a way to eventually win the game. Am I missing some critical info here?"
                    },
                    {
                        "username": "dilit",
                        "content": "On both sides 1st player can make the 2nd player win or lose depending on the 1st player\\'s strategy.  Losing on one side gives an opportunity to win on the other one..."
                    },
                    {
                        "username": "xuankushuocai2",
                        "content": "I\\'m also confused about it. I think this case is false. \"Garanteed to win\" means as long as the first person did the first move, no matter what moves were done after it, the first person will win, right? I don\\'t think it\\'s true for this case. Could anyone tell me the reason to be true? Thank you."
                    },
                    {
                        "username": "yoursyj",
                        "content": "Update:\\n\\nThanks  bravejia for pointing out one case which was missing in my original post.\\n\\nthe winning strategy is that after flip, two strings are still both can-win-or-lose strings. Basically, starting player can choose not to make decision in his first turn.\\n\\nTake \"++++-++++++\" as an example again:\\n\\nA: ++++---++++\\n\\nThis will leave B with two both can-win-or-lose strings. And there will be no further subset can-win-or-lose strings. \\n\\n-----------------------------------------------------------------------\\nOrignal Post:\\n\\nI think  \"++++-++++++\" is a lose. And here is why.\\n\\nBoth ++++ and ++++++ are can-win-or-lose strings. A can-win-or-lose string is a case where first player can choose if he wants to win or lose. \\nFor example, in case of ++++, first player can choose flip middle two to win, or to flip first two to lose.\\n\\nSo in case of two can-win-or-lose strings, or even number of can-win-or-lose strings, second player can always adjust his strategy based on first player's move. \\n\\nTake \"++++-++++++\" as an example, \\n\\nIf A choose to win \"++++\", B can win by winning\"++++++\".\\n\\nA: +--+-++++++\\n\\nB: +--+-++--++\\n\\nIf A choose to lose \"++++\", B can win by losing\"++++++\".\\n\\nA: --++-++++++\\n\\nB: --++-+--+++\\n\\nB can have same strategy If A choose to flip second  can-win-or-lose strings first.\\n\\nSo  \"++++-++++++\" is a lose. Feel free to correct me if I am wrong."
                    },
                    {
                        "username": "harperjiang",
                        "content": "I was using Java and replaced StringBuilder with char array and reduce the running time from 137ms to 11ms. But I don\\'t think StringBuilder is that slow"
                    }
                ]
            },
            {
                "id": 1568060,
                "content": [
                    {
                        "username": "SylvanasWindrunner",
                        "content": "I'm not sure why the simple recursive algorithm would work. It replaces every pair of \"++\" in the original string with \"--\" and ask the questions: can my opponent win? \\n\\nHowever, the canWin() function returns true if the current player is \"guarantee a win\", and it returns false if the current player cannot guarantee a win - meaning the current player might win or lose depending on the action of the opponent. If this is the case, why algorithm like [this][1] works?\\n\\n\\n\\n \\n\\n\\n  [1]: https://leetcode.com/discuss/64291/share-my-java-backtracking-solution"
                    },
                    {
                        "username": "n_leetcode",
                        "content": "\"+++++++++\"\\n\\nPlayer a plays: \"+--++++++\"\\nPlayer b plays: \"+--+--+++\"\\nPlayer a plays: \"+--+--+--\"\\nPlayer b\\'s turn, he has no move to play. So (starting) player A wins.\\n\\nwhy does this testcase return false?\\n"
                    },
                    {
                        "username": "sachinppuranik",
                        "content": "Player a plays: \"+--++++++\"\\nPlayer b plays: \"+--++--++\"\\nPlayer a plays: \"+------++\"\\nPlayer b plays: \"+--------\"\\nNow player a has no move."
                    },
                    {
                        "username": "dilit",
                        "content": "You have to account for turn switching.  \nIf A plays +++--++++, B can play in ++++ half to lose in that half, but grab the turn to play first on the +++ side where it wins."
                    },
                    {
                        "username": "Zhuzeng",
                        "content": "Can anyone please confirm why the expected result for the following test case is TRUE?\\n\"++++-++++++\"\\n\\nMy code failed because my alg is giving 'false', but I am a little confused why the OJ gives 'TRUE'. No matter what the first player does, the second player can find a way to eventually win the game. Am I missing some critical info here?"
                    },
                    {
                        "username": "dilit",
                        "content": "On both sides 1st player can make the 2nd player win or lose depending on the 1st player\\'s strategy.  Losing on one side gives an opportunity to win on the other one..."
                    },
                    {
                        "username": "xuankushuocai2",
                        "content": "I\\'m also confused about it. I think this case is false. \"Garanteed to win\" means as long as the first person did the first move, no matter what moves were done after it, the first person will win, right? I don\\'t think it\\'s true for this case. Could anyone tell me the reason to be true? Thank you."
                    },
                    {
                        "username": "yoursyj",
                        "content": "Update:\\n\\nThanks  bravejia for pointing out one case which was missing in my original post.\\n\\nthe winning strategy is that after flip, two strings are still both can-win-or-lose strings. Basically, starting player can choose not to make decision in his first turn.\\n\\nTake \"++++-++++++\" as an example again:\\n\\nA: ++++---++++\\n\\nThis will leave B with two both can-win-or-lose strings. And there will be no further subset can-win-or-lose strings. \\n\\n-----------------------------------------------------------------------\\nOrignal Post:\\n\\nI think  \"++++-++++++\" is a lose. And here is why.\\n\\nBoth ++++ and ++++++ are can-win-or-lose strings. A can-win-or-lose string is a case where first player can choose if he wants to win or lose. \\nFor example, in case of ++++, first player can choose flip middle two to win, or to flip first two to lose.\\n\\nSo in case of two can-win-or-lose strings, or even number of can-win-or-lose strings, second player can always adjust his strategy based on first player's move. \\n\\nTake \"++++-++++++\" as an example, \\n\\nIf A choose to win \"++++\", B can win by winning\"++++++\".\\n\\nA: +--+-++++++\\n\\nB: +--+-++--++\\n\\nIf A choose to lose \"++++\", B can win by losing\"++++++\".\\n\\nA: --++-++++++\\n\\nB: --++-+--+++\\n\\nB can have same strategy If A choose to flip second  can-win-or-lose strings first.\\n\\nSo  \"++++-++++++\" is a lose. Feel free to correct me if I am wrong."
                    },
                    {
                        "username": "harperjiang",
                        "content": "I was using Java and replaced StringBuilder with char array and reduce the running time from 137ms to 11ms. But I don\\'t think StringBuilder is that slow"
                    }
                ]
            },
            {
                "id": 1567949,
                "content": [
                    {
                        "username": "SylvanasWindrunner",
                        "content": "I'm not sure why the simple recursive algorithm would work. It replaces every pair of \"++\" in the original string with \"--\" and ask the questions: can my opponent win? \\n\\nHowever, the canWin() function returns true if the current player is \"guarantee a win\", and it returns false if the current player cannot guarantee a win - meaning the current player might win or lose depending on the action of the opponent. If this is the case, why algorithm like [this][1] works?\\n\\n\\n\\n \\n\\n\\n  [1]: https://leetcode.com/discuss/64291/share-my-java-backtracking-solution"
                    },
                    {
                        "username": "n_leetcode",
                        "content": "\"+++++++++\"\\n\\nPlayer a plays: \"+--++++++\"\\nPlayer b plays: \"+--+--+++\"\\nPlayer a plays: \"+--+--+--\"\\nPlayer b\\'s turn, he has no move to play. So (starting) player A wins.\\n\\nwhy does this testcase return false?\\n"
                    },
                    {
                        "username": "sachinppuranik",
                        "content": "Player a plays: \"+--++++++\"\\nPlayer b plays: \"+--++--++\"\\nPlayer a plays: \"+------++\"\\nPlayer b plays: \"+--------\"\\nNow player a has no move."
                    },
                    {
                        "username": "dilit",
                        "content": "You have to account for turn switching.  \nIf A plays +++--++++, B can play in ++++ half to lose in that half, but grab the turn to play first on the +++ side where it wins."
                    },
                    {
                        "username": "Zhuzeng",
                        "content": "Can anyone please confirm why the expected result for the following test case is TRUE?\\n\"++++-++++++\"\\n\\nMy code failed because my alg is giving 'false', but I am a little confused why the OJ gives 'TRUE'. No matter what the first player does, the second player can find a way to eventually win the game. Am I missing some critical info here?"
                    },
                    {
                        "username": "dilit",
                        "content": "On both sides 1st player can make the 2nd player win or lose depending on the 1st player\\'s strategy.  Losing on one side gives an opportunity to win on the other one..."
                    },
                    {
                        "username": "xuankushuocai2",
                        "content": "I\\'m also confused about it. I think this case is false. \"Garanteed to win\" means as long as the first person did the first move, no matter what moves were done after it, the first person will win, right? I don\\'t think it\\'s true for this case. Could anyone tell me the reason to be true? Thank you."
                    },
                    {
                        "username": "yoursyj",
                        "content": "Update:\\n\\nThanks  bravejia for pointing out one case which was missing in my original post.\\n\\nthe winning strategy is that after flip, two strings are still both can-win-or-lose strings. Basically, starting player can choose not to make decision in his first turn.\\n\\nTake \"++++-++++++\" as an example again:\\n\\nA: ++++---++++\\n\\nThis will leave B with two both can-win-or-lose strings. And there will be no further subset can-win-or-lose strings. \\n\\n-----------------------------------------------------------------------\\nOrignal Post:\\n\\nI think  \"++++-++++++\" is a lose. And here is why.\\n\\nBoth ++++ and ++++++ are can-win-or-lose strings. A can-win-or-lose string is a case where first player can choose if he wants to win or lose. \\nFor example, in case of ++++, first player can choose flip middle two to win, or to flip first two to lose.\\n\\nSo in case of two can-win-or-lose strings, or even number of can-win-or-lose strings, second player can always adjust his strategy based on first player's move. \\n\\nTake \"++++-++++++\" as an example, \\n\\nIf A choose to win \"++++\", B can win by winning\"++++++\".\\n\\nA: +--+-++++++\\n\\nB: +--+-++--++\\n\\nIf A choose to lose \"++++\", B can win by losing\"++++++\".\\n\\nA: --++-++++++\\n\\nB: --++-+--+++\\n\\nB can have same strategy If A choose to flip second  can-win-or-lose strings first.\\n\\nSo  \"++++-++++++\" is a lose. Feel free to correct me if I am wrong."
                    },
                    {
                        "username": "harperjiang",
                        "content": "I was using Java and replaced StringBuilder with char array and reduce the running time from 137ms to 11ms. But I don\\'t think StringBuilder is that slow"
                    }
                ]
            },
            {
                "id": 1569260,
                "content": [
                    {
                        "username": "SylvanasWindrunner",
                        "content": "I'm not sure why the simple recursive algorithm would work. It replaces every pair of \"++\" in the original string with \"--\" and ask the questions: can my opponent win? \\n\\nHowever, the canWin() function returns true if the current player is \"guarantee a win\", and it returns false if the current player cannot guarantee a win - meaning the current player might win or lose depending on the action of the opponent. If this is the case, why algorithm like [this][1] works?\\n\\n\\n\\n \\n\\n\\n  [1]: https://leetcode.com/discuss/64291/share-my-java-backtracking-solution"
                    },
                    {
                        "username": "n_leetcode",
                        "content": "\"+++++++++\"\\n\\nPlayer a plays: \"+--++++++\"\\nPlayer b plays: \"+--+--+++\"\\nPlayer a plays: \"+--+--+--\"\\nPlayer b\\'s turn, he has no move to play. So (starting) player A wins.\\n\\nwhy does this testcase return false?\\n"
                    },
                    {
                        "username": "sachinppuranik",
                        "content": "Player a plays: \"+--++++++\"\\nPlayer b plays: \"+--++--++\"\\nPlayer a plays: \"+------++\"\\nPlayer b plays: \"+--------\"\\nNow player a has no move."
                    },
                    {
                        "username": "dilit",
                        "content": "You have to account for turn switching.  \nIf A plays +++--++++, B can play in ++++ half to lose in that half, but grab the turn to play first on the +++ side where it wins."
                    },
                    {
                        "username": "Zhuzeng",
                        "content": "Can anyone please confirm why the expected result for the following test case is TRUE?\\n\"++++-++++++\"\\n\\nMy code failed because my alg is giving 'false', but I am a little confused why the OJ gives 'TRUE'. No matter what the first player does, the second player can find a way to eventually win the game. Am I missing some critical info here?"
                    },
                    {
                        "username": "dilit",
                        "content": "On both sides 1st player can make the 2nd player win or lose depending on the 1st player\\'s strategy.  Losing on one side gives an opportunity to win on the other one..."
                    },
                    {
                        "username": "xuankushuocai2",
                        "content": "I\\'m also confused about it. I think this case is false. \"Garanteed to win\" means as long as the first person did the first move, no matter what moves were done after it, the first person will win, right? I don\\'t think it\\'s true for this case. Could anyone tell me the reason to be true? Thank you."
                    },
                    {
                        "username": "yoursyj",
                        "content": "Update:\\n\\nThanks  bravejia for pointing out one case which was missing in my original post.\\n\\nthe winning strategy is that after flip, two strings are still both can-win-or-lose strings. Basically, starting player can choose not to make decision in his first turn.\\n\\nTake \"++++-++++++\" as an example again:\\n\\nA: ++++---++++\\n\\nThis will leave B with two both can-win-or-lose strings. And there will be no further subset can-win-or-lose strings. \\n\\n-----------------------------------------------------------------------\\nOrignal Post:\\n\\nI think  \"++++-++++++\" is a lose. And here is why.\\n\\nBoth ++++ and ++++++ are can-win-or-lose strings. A can-win-or-lose string is a case where first player can choose if he wants to win or lose. \\nFor example, in case of ++++, first player can choose flip middle two to win, or to flip first two to lose.\\n\\nSo in case of two can-win-or-lose strings, or even number of can-win-or-lose strings, second player can always adjust his strategy based on first player's move. \\n\\nTake \"++++-++++++\" as an example, \\n\\nIf A choose to win \"++++\", B can win by winning\"++++++\".\\n\\nA: +--+-++++++\\n\\nB: +--+-++--++\\n\\nIf A choose to lose \"++++\", B can win by losing\"++++++\".\\n\\nA: --++-++++++\\n\\nB: --++-+--+++\\n\\nB can have same strategy If A choose to flip second  can-win-or-lose strings first.\\n\\nSo  \"++++-++++++\" is a lose. Feel free to correct me if I am wrong."
                    },
                    {
                        "username": "harperjiang",
                        "content": "I was using Java and replaced StringBuilder with char array and reduce the running time from 137ms to 11ms. But I don\\'t think StringBuilder is that slow"
                    }
                ]
            },
            {
                "id": 1569057,
                "content": [
                    {
                        "username": "SylvanasWindrunner",
                        "content": "I'm not sure why the simple recursive algorithm would work. It replaces every pair of \"++\" in the original string with \"--\" and ask the questions: can my opponent win? \\n\\nHowever, the canWin() function returns true if the current player is \"guarantee a win\", and it returns false if the current player cannot guarantee a win - meaning the current player might win or lose depending on the action of the opponent. If this is the case, why algorithm like [this][1] works?\\n\\n\\n\\n \\n\\n\\n  [1]: https://leetcode.com/discuss/64291/share-my-java-backtracking-solution"
                    },
                    {
                        "username": "n_leetcode",
                        "content": "\"+++++++++\"\\n\\nPlayer a plays: \"+--++++++\"\\nPlayer b plays: \"+--+--+++\"\\nPlayer a plays: \"+--+--+--\"\\nPlayer b\\'s turn, he has no move to play. So (starting) player A wins.\\n\\nwhy does this testcase return false?\\n"
                    },
                    {
                        "username": "sachinppuranik",
                        "content": "Player a plays: \"+--++++++\"\\nPlayer b plays: \"+--++--++\"\\nPlayer a plays: \"+------++\"\\nPlayer b plays: \"+--------\"\\nNow player a has no move."
                    },
                    {
                        "username": "dilit",
                        "content": "You have to account for turn switching.  \nIf A plays +++--++++, B can play in ++++ half to lose in that half, but grab the turn to play first on the +++ side where it wins."
                    },
                    {
                        "username": "Zhuzeng",
                        "content": "Can anyone please confirm why the expected result for the following test case is TRUE?\\n\"++++-++++++\"\\n\\nMy code failed because my alg is giving 'false', but I am a little confused why the OJ gives 'TRUE'. No matter what the first player does, the second player can find a way to eventually win the game. Am I missing some critical info here?"
                    },
                    {
                        "username": "dilit",
                        "content": "On both sides 1st player can make the 2nd player win or lose depending on the 1st player\\'s strategy.  Losing on one side gives an opportunity to win on the other one..."
                    },
                    {
                        "username": "xuankushuocai2",
                        "content": "I\\'m also confused about it. I think this case is false. \"Garanteed to win\" means as long as the first person did the first move, no matter what moves were done after it, the first person will win, right? I don\\'t think it\\'s true for this case. Could anyone tell me the reason to be true? Thank you."
                    },
                    {
                        "username": "yoursyj",
                        "content": "Update:\\n\\nThanks  bravejia for pointing out one case which was missing in my original post.\\n\\nthe winning strategy is that after flip, two strings are still both can-win-or-lose strings. Basically, starting player can choose not to make decision in his first turn.\\n\\nTake \"++++-++++++\" as an example again:\\n\\nA: ++++---++++\\n\\nThis will leave B with two both can-win-or-lose strings. And there will be no further subset can-win-or-lose strings. \\n\\n-----------------------------------------------------------------------\\nOrignal Post:\\n\\nI think  \"++++-++++++\" is a lose. And here is why.\\n\\nBoth ++++ and ++++++ are can-win-or-lose strings. A can-win-or-lose string is a case where first player can choose if he wants to win or lose. \\nFor example, in case of ++++, first player can choose flip middle two to win, or to flip first two to lose.\\n\\nSo in case of two can-win-or-lose strings, or even number of can-win-or-lose strings, second player can always adjust his strategy based on first player's move. \\n\\nTake \"++++-++++++\" as an example, \\n\\nIf A choose to win \"++++\", B can win by winning\"++++++\".\\n\\nA: +--+-++++++\\n\\nB: +--+-++--++\\n\\nIf A choose to lose \"++++\", B can win by losing\"++++++\".\\n\\nA: --++-++++++\\n\\nB: --++-+--+++\\n\\nB can have same strategy If A choose to flip second  can-win-or-lose strings first.\\n\\nSo  \"++++-++++++\" is a lose. Feel free to correct me if I am wrong."
                    },
                    {
                        "username": "harperjiang",
                        "content": "I was using Java and replaced StringBuilder with char array and reduce the running time from 137ms to 11ms. But I don\\'t think StringBuilder is that slow"
                    }
                ]
            },
            {
                "id": 1707575,
                "content": [
                    {
                        "username": "SylvanasWindrunner",
                        "content": "I'm not sure why the simple recursive algorithm would work. It replaces every pair of \"++\" in the original string with \"--\" and ask the questions: can my opponent win? \\n\\nHowever, the canWin() function returns true if the current player is \"guarantee a win\", and it returns false if the current player cannot guarantee a win - meaning the current player might win or lose depending on the action of the opponent. If this is the case, why algorithm like [this][1] works?\\n\\n\\n\\n \\n\\n\\n  [1]: https://leetcode.com/discuss/64291/share-my-java-backtracking-solution"
                    },
                    {
                        "username": "n_leetcode",
                        "content": "\"+++++++++\"\\n\\nPlayer a plays: \"+--++++++\"\\nPlayer b plays: \"+--+--+++\"\\nPlayer a plays: \"+--+--+--\"\\nPlayer b\\'s turn, he has no move to play. So (starting) player A wins.\\n\\nwhy does this testcase return false?\\n"
                    },
                    {
                        "username": "sachinppuranik",
                        "content": "Player a plays: \"+--++++++\"\\nPlayer b plays: \"+--++--++\"\\nPlayer a plays: \"+------++\"\\nPlayer b plays: \"+--------\"\\nNow player a has no move."
                    },
                    {
                        "username": "dilit",
                        "content": "You have to account for turn switching.  \nIf A plays +++--++++, B can play in ++++ half to lose in that half, but grab the turn to play first on the +++ side where it wins."
                    },
                    {
                        "username": "Zhuzeng",
                        "content": "Can anyone please confirm why the expected result for the following test case is TRUE?\\n\"++++-++++++\"\\n\\nMy code failed because my alg is giving 'false', but I am a little confused why the OJ gives 'TRUE'. No matter what the first player does, the second player can find a way to eventually win the game. Am I missing some critical info here?"
                    },
                    {
                        "username": "dilit",
                        "content": "On both sides 1st player can make the 2nd player win or lose depending on the 1st player\\'s strategy.  Losing on one side gives an opportunity to win on the other one..."
                    },
                    {
                        "username": "xuankushuocai2",
                        "content": "I\\'m also confused about it. I think this case is false. \"Garanteed to win\" means as long as the first person did the first move, no matter what moves were done after it, the first person will win, right? I don\\'t think it\\'s true for this case. Could anyone tell me the reason to be true? Thank you."
                    },
                    {
                        "username": "yoursyj",
                        "content": "Update:\\n\\nThanks  bravejia for pointing out one case which was missing in my original post.\\n\\nthe winning strategy is that after flip, two strings are still both can-win-or-lose strings. Basically, starting player can choose not to make decision in his first turn.\\n\\nTake \"++++-++++++\" as an example again:\\n\\nA: ++++---++++\\n\\nThis will leave B with two both can-win-or-lose strings. And there will be no further subset can-win-or-lose strings. \\n\\n-----------------------------------------------------------------------\\nOrignal Post:\\n\\nI think  \"++++-++++++\" is a lose. And here is why.\\n\\nBoth ++++ and ++++++ are can-win-or-lose strings. A can-win-or-lose string is a case where first player can choose if he wants to win or lose. \\nFor example, in case of ++++, first player can choose flip middle two to win, or to flip first two to lose.\\n\\nSo in case of two can-win-or-lose strings, or even number of can-win-or-lose strings, second player can always adjust his strategy based on first player's move. \\n\\nTake \"++++-++++++\" as an example, \\n\\nIf A choose to win \"++++\", B can win by winning\"++++++\".\\n\\nA: +--+-++++++\\n\\nB: +--+-++--++\\n\\nIf A choose to lose \"++++\", B can win by losing\"++++++\".\\n\\nA: --++-++++++\\n\\nB: --++-+--+++\\n\\nB can have same strategy If A choose to flip second  can-win-or-lose strings first.\\n\\nSo  \"++++-++++++\" is a lose. Feel free to correct me if I am wrong."
                    },
                    {
                        "username": "harperjiang",
                        "content": "I was using Java and replaced StringBuilder with char array and reduce the running time from 137ms to 11ms. But I don\\'t think StringBuilder is that slow"
                    }
                ]
            }
        ]
    },
    {
        "title": "Decode String",
        "question_content": "<p>Given an encoded string, return its decoded string.</p>\n\n<p>The encoding rule is: <code>k[encoded_string]</code>, where the <code>encoded_string</code> inside the square brackets is being repeated exactly <code>k</code> times. Note that <code>k</code> is guaranteed to be a positive integer.</p>\n\n<p>You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, <code>k</code>. For example, there will not be input like <code>3a</code> or <code>2[4]</code>.</p>\n\n<p>The test cases are generated so that the length of the output will never exceed <code>10<sup>5</sup></code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;3[a]2[bc]&quot;\n<strong>Output:</strong> &quot;aaabcbc&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;3[a2[c]]&quot;\n<strong>Output:</strong> &quot;accaccacc&quot;\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;2[abc]3[cd]ef&quot;\n<strong>Output:</strong> &quot;abcabccdcdcdef&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 30</code></li>\n\t<li><code>s</code> consists of lowercase English letters, digits, and square brackets <code>&#39;[]&#39;</code>.</li>\n\t<li><code>s</code> is guaranteed to be <strong>a valid</strong> input.</li>\n\t<li>All the integers in <code>s</code> are in the range <code>[1, 300]</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 87662,
                "title": "python-solution-using-stack",
                "content": "```\\nclass Solution(object):\\n    def decodeString(self, s):\\n        stack = []; curNum = 0; curString = ''\\n        for c in s:\\n            if c == '[':\\n                stack.append(curString)\\n                stack.append(curNum)\\n                curString = ''\\n                curNum = 0\\n            elif c == ']':\\n                num = stack.pop()\\n                prevString = stack.pop()\\n                curString = prevString + num*curString\\n            elif c.isdigit():\\n                curNum = curNum*10 + int(c)\\n            else:\\n                curString += c\\n        return curString\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def decodeString(self, s):\\n        stack = []; curNum = 0; curString = ''\\n        for c in s:\\n            if c == '[':\\n                stack.append(curString)\\n                stack.append(curNum)\\n                curString = ''\\n                curNum = 0\\n            elif c == ']':\\n                num = stack.pop()\\n                prevString = stack.pop()\\n                curString = prevString + num*curString\\n            elif c.isdigit():\\n                curNum = curNum*10 + int(c)\\n            else:\\n                curString += c\\n        return curString\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87543,
                "title": "0ms-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeString(const string& s, int& i) {\\n        string res;\\n        \\n        while (i < s.length() && s[i] != ']') {\\n            if (!isdigit(s[i]))\\n                res += s[i++];\\n            else {\\n                int n = 0;\\n                while (i < s.length() && isdigit(s[i]))\\n                    n = n * 10 + s[i++] - '0';\\n                    \\n                i++; // '['\\n                string t = decodeString(s, i);\\n                i++; // ']'\\n                \\n                while (n-- > 0)\\n                    res += t;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n\\n    string decodeString(string s) {\\n        int i = 0;\\n        return decodeString(s, i);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(const string& s, int& i) {\\n        string res;\\n        \\n        while (i < s.length() && s[i] != ']') {\\n            if (!isdigit(s[i]))\\n                res += s[i++];\\n            else {\\n                int n = 0;\\n                while (i < s.length() && isdigit(s[i]))\\n                    n = n * 10 + s[i++] - '0';\\n                    \\n                i++; // '['\\n                string t = decodeString(s, i);\\n                i++; // ']'\\n                \\n                while (n-- > 0)\\n                    res += t;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n\\n    string decodeString(string s) {\\n        int i = 0;\\n        return decodeString(s, i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87534,
                "title": "simple-java-solution-using-stack",
                "content": "```\\npublic class Solution {\\n    public String decodeString(String s) {\\n        String res = \"\";\\n        Stack<Integer> countStack = new Stack<>();\\n        Stack<String> resStack = new Stack<>();\\n        int idx = 0;\\n        while (idx < s.length()) {\\n            if (Character.isDigit(s.charAt(idx))) {\\n                int count = 0;\\n                while (Character.isDigit(s.charAt(idx))) {\\n                    count = 10 * count + (s.charAt(idx) - '0');\\n                    idx++;\\n                }\\n                countStack.push(count);\\n            }\\n            else if (s.charAt(idx) == '[') {\\n                resStack.push(res);\\n                res = \"\";\\n                idx++;\\n            }\\n            else if (s.charAt(idx) == ']') {\\n                StringBuilder temp = new StringBuilder (resStack.pop());\\n                int repeatTimes = countStack.pop();\\n                for (int i = 0; i < repeatTimes; i++) {\\n                    temp.append(res);\\n                }\\n                res = temp.toString();\\n                idx++;\\n            }\\n            else {\\n                res += s.charAt(idx++);\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String decodeString(String s) {\\n        String res = \"\";\\n        Stack<Integer> countStack = new Stack<>();\\n        Stack<String> resStack = new Stack<>();\\n        int idx = 0;\\n        while (idx < s.length()) {\\n            if (Character.isDigit(s.charAt(idx))) {\\n                int count = 0;\\n                while (Character.isDigit(s.charAt(idx))) {\\n                    count = 10 * count + (s.charAt(idx) - '0');\\n                    idx++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 210284,
                "title": "java-recursive",
                "content": "```\\nclass Solution {\\n    public String decodeString(String s) {\\n        Deque<Character> queue = new LinkedList<>();\\n        for (char c : s.toCharArray()) queue.offer(c);\\n        return helper(queue);\\n    }\\n    \\n    public String helper(Deque<Character> queue) {\\n        StringBuilder sb = new StringBuilder();\\n        int num = 0;\\n        while (!queue.isEmpty()) {\\n            char c= queue.poll();\\n            if (Character.isDigit(c)) {\\n                num = num * 10 + c - \\'0\\';\\n            } else if (c == \\'[\\') {\\n                String sub = helper(queue);\\n                for (int i = 0; i < num; i++) sb.append(sub);   \\n                num = 0;\\n            } else if (c == \\']\\') {\\n                break;\\n            } else {\\n                sb.append(c);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String decodeString(String s) {\\n        Deque<Character> queue = new LinkedList<>();\\n        for (char c : s.toCharArray()) queue.offer(c);\\n        return helper(queue);\\n    }\\n    \\n    public String helper(Deque<Character> queue) {\\n        StringBuilder sb = new StringBuilder();\\n        int num = 0;\\n        while (!queue.isEmpty()) {\\n            char c= queue.poll();\\n            if (Character.isDigit(c)) {\\n                num = num * 10 + c - \\'0\\';\\n            } else if (c == \\'[\\') {\\n                String sub = helper(queue);\\n                for (int i = 0; i < num; i++) sb.append(sub);   \\n                num = 0;\\n            } else if (c == \\']\\') {\\n                break;\\n            } else {\\n                sb.append(c);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87544,
                "title": "clean-c-recursive-solution-with-explanation",
                "content": "Every time we meet a '[', we treat it as a subproblem so call our recursive function to get the content in that '[' and ']'. After that, repeat that content for 'num' times.\\nEvery time we meet a ']', we know a subproblem finished and just return the 'word' we got in this subproblem.\\nPlease notice that the 'pos' is passed by reference, use it to record the position of the original string we are looking at.\\n\\n```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        int pos = 0;\\n        return helper(pos, s);\\n    }\\n    \\n    string helper(int& pos, string s) {\\n        int num=0;\\n        string word = \"\";\\n        for(;pos<s.size(); pos++) {\\n            char cur = s[pos];\\n            if(cur == '[') {\\n                string curStr = helper(++pos, s);\\n                for(;num>0;num--) word += curStr;\\n            } else if (cur >= '0' && cur <='9') {\\n                num = num*10 + cur - '0';\\n            } else if (cur == ']') {\\n                return word;\\n            } else {    // Normal characters\\n                word += cur;\\n            }\\n        }\\n        return word;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        int pos = 0;\\n        return helper(pos, s);\\n    }\\n    \\n    string helper(int& pos, string s) {\\n        int num=0;\\n        string word = \"\";\\n        for(;pos<s.size(); pos++) {\\n            char cur = s[pos];\\n            if(cur == '[') {\\n                string curStr = helper(++pos, s);\\n                for(;num>0;num--) word += curStr;\\n            } else if (cur >= '0' && cur <='9') {\\n                num = num*10 + cur - '0';\\n            } else if (cur == ']') {\\n                return word;\\n            } else {    // Normal characters\\n                word += cur;\\n            }\\n        }\\n        return word;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87563,
                "title": "share-my-python-stack-simple-solution-easy-to-understand",
                "content": "```\\nclass Solution(object):\\n    def decodeString(self, s):\\n        stack = []\\n        stack.append([\"\", 1])\\n        num = \"\"\\n        for ch in s:\\n            if ch.isdigit():\\n              num += ch\\n            elif ch == '[':\\n                stack.append([\"\", int(num)])\\n                num = \"\"\\n            elif ch == ']':\\n                st, k = stack.pop()\\n                stack[-1][0] += st*k\\n            else:\\n                stack[-1][0] += ch\\n        return stack[0][0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def decodeString(self, s):\\n        stack = []\\n        stack.append([\"\", 1])\\n        num = \"\"\\n        for ch in s:\\n            if ch.isdigit():\\n              num += ch\\n            elif ch == '[':\\n                stack.append([\"\", int(num)])\\n                num = \"\"\\n            elif ch == ']':\\n                st, k = stack.pop()\\n                stack[-1][0] += st*k\\n            else:\\n                stack[-1][0] += ch\\n        return stack[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941309,
                "title": "python-stack-solution-explained",
                "content": "For me it was not medium problem, more like hard, I am not very good at all these parser problems. However if you spend some time on this problem, logic will be not very difficult. The idea is to read symbol by symbol and check options:\\n\\n1. If we see digit, it means that we need to form number, so just do it: multiply already formed number by `10` and add this digit.\\n2. If we see open bracket `[`, it means, that we just right before finished to form our number: so we put it into our stack. Also we put in our stack empty string.\\n3. If we have close bracket `]`, it means that we just finished `[...]` block and what we have in our stack: on the top it is solution for what we have inside bracktes, before we have number of repetitions of this string `rep` and finally, before we have string built previously: so we concatenate `str2` and `str1 * rep`.\\n4. Finally, if we have some other symbol, that is letter, we add it the the last element of our stack.\\n\\nFor better understanding the process, let us consider example `s = 3[a5[c]]4[b]`:\\n1. `[\\'\\']` at first we have stack with empty string.\\n2. `[\\'\\', 3, \\'\\']`, open bracket: now we have stack with 3 elements: empty string, number `3` and empty string.\\n3. `[\\'\\', 3, \\'a\\']`: build our string\\n4. `[\\'\\', 3, \\'a\\', 5, \\'\\']`, open bracket: add number and empty string\\n5. `[\\'\\', 3, \\'a\\', 5, \\'c\\']` build string\\n6. `[\\'\\', 3, \\'accccc\\']` : now we have closing bracket, so we remove last `3` elements and put `accccc` into our stack\\n7. `[\\'acccccacccccaccccc\\']` we again have closing bracket, so we remove last `3` elements and put new one.\\n8. `[\\'acccccacccccaccccc\\', 4, \\'\\']`: open bracket, add number and empty string to stack\\n9. `[\\'acccccacccccaccccc\\', 4, \\'b\\']` build string\\n10. `[\\'acccccacccccacccccbbbb\\']` closing bracket: remove last 3 elements and put one new.\\n\\nFinally, return joined strings from our stack.\\n\\n**Complexity**: we can say, that time and space complexity is `O(m)`, where `m` is size of our answer. Potentially it can be very big, for strings like `999999999999999[a]`, but I do not think leetcode will have such tests.\\n\\n\\n```\\nclass Solution:\\n    def decodeString(self, s):\\n        it, num, stack = 0, 0, [\"\"]\\n        while it < len(s):\\n            if s[it].isdigit():\\n                num = num * 10 + int(s[it])\\n            elif s[it] == \"[\":\\n                stack.append(num)\\n                num = 0\\n                stack.append(\"\")\\n            elif s[it] == \"]\":\\n                str1 = stack.pop()\\n                rep = stack.pop()\\n                str2 = stack.pop()\\n                stack.append(str2 + str1 * rep)\\n            else:\\n                stack[-1] += s[it]              \\n            it += 1           \\n        return \"\".join(stack)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def decodeString(self, s):\\n        it, num, stack = 0, 0, [\"\"]\\n        while it < len(s):\\n            if s[it].isdigit():\\n                num = num * 10 + int(s[it])\\n            elif s[it] == \"[\":\\n                stack.append(num)\\n                num = 0\\n                stack.append(\"\")\\n            elif s[it] == \"]\":\\n                str1 = stack.pop()\\n                rep = stack.pop()\\n                str2 = stack.pop()\\n                stack.append(str2 + str1 * rep)\\n            else:\\n                stack[-1] += s[it]              \\n            it += 1           \\n        return \"\".join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87651,
                "title": "c-simple-and-clear-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<string> chars;\\n        stack<int> nums;\\n        string res;\\n        int num = 0;\\n        for(char c : s) {\\n            if(isdigit(c)) {\\n                num = num*10 + (c-'0');                              \\n            }\\n            else if(isalpha(c)) {\\n                res.push_back(c);                \\n            }\\n            else if(c == '[') {\\n                chars.push(res);\\n                nums.push(num);\\n                res = \"\";\\n                num = 0;\\n            }\\n            else if(c == ']') {\\n                string tmp = res;\\n                for(int i = 0; i < nums.top()-1; ++i) {\\n                    res += tmp;\\n                }\\n                res = chars.top() + res;\\n                chars.pop(); nums.pop();\\n            }\\n        }\\n        return res;\\n     }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<string> chars;\\n        stack<int> nums;\\n        string res;\\n        int num = 0;\\n        for(char c : s) {\\n            if(isdigit(c)) {\\n                num = num*10 + (c-'0');                              \\n            }\\n            else if(isalpha(c)) {\\n                res.push_back(c);                \\n            }\\n            else if(c == '[') {\\n                chars.push(res);\\n                nums.push(num);\\n                res = \"\";\\n                num = 0;\\n            }\\n            else if(c == ']') {\\n                string tmp = res;\\n                for(int i = 0; i < nums.top()-1; ++i) {\\n                    res += tmp;\\n                }\\n                res = chars.top() + res;\\n                chars.pop(); nums.pop();\\n            }\\n        }\\n        return res;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 472087,
                "title": "0ms-c-solution-using-one-stack",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    string decodeString(string s) {\\n        stack<char> st;\\n        for(int i = 0; i < s.size(); i++){\\n            if(s[i] != \\']\\') {\\n                st.push(s[i]);\\n            }\\n            else{\\n                string curr_str = \"\";\\n                \\n                while(st.top() != \\'[\\'){\\n                    curr_str = st.top() + curr_str ;\\n                    st.pop();\\n                }\\n                \\n                st.pop();   // for \\'[\\'\\n                string number = \"\";\\n                \\n                // for calculating number\\n                \\n                while(!st.empty() && isdigit(st.top())){\\n                    number = st.top() + number;\\n                    st.pop();\\n                }\\n                int k_time = stoi(number);    // convert string to number\\n                \\n                while(k_time--){\\n                    for(int p = 0; p < curr_str.size() ; p++)\\n                        st.push(curr_str[p]);\\n                }\\n            }\\n        }\\n        \\n        s = \"\";\\n        while(!st.empty()){\\n            s = st.top() + s;\\n            st.pop();\\n        }\\n        return s;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    string decodeString(string s) {\\n        stack<char> st;\\n        for(int i = 0; i < s.size(); i++){\\n            if(s[i] != \\']\\') {\\n                st.push(s[i]);\\n            }\\n            else{\\n                string curr_str = \"\";\\n                \\n                while(st.top() != \\'[\\'){\\n                    curr_str = st.top() + curr_str ;\\n                    st.pop();\\n                }\\n                \\n                st.pop();   // for \\'[\\'\\n                string number = \"\";\\n                \\n                // for calculating number\\n                \\n                while(!st.empty() && isdigit(st.top())){\\n                    number = st.top() + number;\\n                    st.pop();\\n                }\\n                int k_time = stoi(number);    // convert string to number\\n                \\n                while(k_time--){\\n                    for(int p = 0; p < curr_str.size() ; p++)\\n                        st.push(curr_str[p]);\\n                }\\n            }\\n        }\\n        \\n        s = \"\";\\n        while(!st.empty()){\\n            s = st.top() + s;\\n            st.pop();\\n        }\\n        return s;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1332601,
                "title": "c-java-python-bracket-matching-recursion-easy-to-understand-clean-concise",
                "content": "**Idea**\\n- Example: `\"3[a2[c]]\"`\\n- Iterate to find the position of the matching **close bracket** for an **open bracket**, let name it `closePos`.\\n\\t- In the above example: `closePos[1] = 7, closePos[4] = 6`.\\n- Build a `dfs(l, r)` function to return decoded string from index left `l` to `r` (inclusive):\\n\\t- Iterate from i in range `[l..r]`\\n\\t\\t- If `s[i]` is digit then `num = num * 10 + int(s[i])`\\n\\t\\t- Else if `s[i]` == `[` then `ans += num * dfs(i + 1, closePos[i] - 1)`\\n\\t\\t- Else `ans += s[i]`\\n- Return `dfs(0, len(s) - 1)`.\\n\\n<iframe src=\"https://leetcode.com/playground/3Ju2heYr/shared\" frameBorder=\"0\" width=\"100%\" height=\"680\"></iframe>\\n\\n**Complexity:**\\n- Time: `O(M)`, where `M` is the size of the output answer.\\n- Space: `O(M)`",
                "solutionTags": [],
                "code": "**Idea**\\n- Example: `\"3[a2[c]]\"`\\n- Iterate to find the position of the matching **close bracket** for an **open bracket**, let name it `closePos`.\\n\\t- In the above example: `closePos[1] = 7, closePos[4] = 6`.\\n- Build a `dfs(l, r)` function to return decoded string from index left `l` to `r` (inclusive):\\n\\t- Iterate from i in range `[l..r]`\\n\\t\\t- If `s[i]` is digit then `num = num * 10 + int(s[i])`\\n\\t\\t- Else if `s[i]` == `[` then `ans += num * dfs(i + 1, closePos[i] - 1)`\\n\\t\\t- Else `ans += s[i]`\\n- Return `dfs(0, len(s) - 1)`.\\n\\n<iframe src=\"https://leetcode.com/playground/3Ju2heYr/shared\" frameBorder=\"0\" width=\"100%\" height=\"680\"></iframe>\\n\\n**Complexity:**\\n- Time: `O(M)`, where `M` is the size of the output answer.\\n- Space: `O(M)`",
                "codeTag": "Unknown"
            },
            {
                "id": 87556,
                "title": "java-short-and-easy-understanding-solution-using-stack",
                "content": "```\\npublic class Solution {\\n    public String decodeString(String s) {\\n        Stack<Integer> count = new Stack<>();\\n        Stack<String> result = new Stack<>();\\n        int i = 0;\\n        result.push(\"\");\\n        while (i < s.length()) {\\n            char ch = s.charAt(i);\\n            if (ch >= '0' && ch <= '9') {\\n                int start = i;\\n                while (s.charAt(i + 1) >= '0' && s.charAt(i + 1) <= '9') i++;\\n                count.push(Integer.parseInt(s.substring(start, i + 1)));\\n            } else if (ch == '[') {\\n                result.push(\"\");\\n            } else if (ch == ']') {\\n                String str = result.pop();\\n                StringBuilder sb = new StringBuilder();\\n                int times = count.pop();\\n                for (int j = 0; j < times; j += 1) {\\n                    sb.append(str);\\n                }\\n                result.push(result.pop() + sb.toString());\\n            } else {\\n                result.push(result.pop() + ch);\\n            }\\n            i += 1;\\n        }\\n        return result.pop();\\n    }\\n}\\n```\\nQuite clear, isn't it?",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public String decodeString(String s) {\\n        Stack<Integer> count = new Stack<>();\\n        Stack<String> result = new Stack<>();\\n        int i = 0;\\n        result.push(\"\");\\n        while (i < s.length()) {\\n            char ch = s.charAt(i);\\n            if (ch >= '0' && ch <= '9') {\\n                int start = i;\\n                while (s.charAt(i + 1) >= '0' && s.charAt(i + 1) <= '9') i++;\\n                count.push(Integer.parseInt(s.substring(start, i + 1)));\\n            } else if (ch == '[') {\\n                result.push(\"\");\\n            } else if (ch == ']') {\\n                String str = result.pop();\\n                StringBuilder sb = new StringBuilder();\\n                int times = count.pop();\\n                for (int j = 0; j < times; j += 1) {\\n                    sb.append(str);\\n                }\\n                result.push(result.pop() + sb.toString());\\n            } else {\\n                result.push(result.pop() + ch);\\n            }\\n            i += 1;\\n        }\\n        return result.pop();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87536,
                "title": "3-lines-python-2-lines-ruby-regular-expression",
                "content": "## Python\\n\\n    def decodeString(self, s):\\n        while '[' in s:\\n            s = re.sub(r'(\\\\d+)\\\\[([a-z]*)\\\\]', lambda m: int(m.group(1)) * m.group(2), s)\\n        return s\\n\\nSubmitted once, got accepted in 32 ms.\\n\\n## Ruby\\n\\n```\\ndef decode_string(s)\\n  1 while s.gsub!(/(\\\\d+)\\\\[([a-z]*)\\\\]/) { $2 * $1.to_i }\\n  s\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef decode_string(s)\\n  1 while s.gsub!(/(\\\\d+)\\\\[([a-z]*)\\\\]/) { $2 * $1.to_i }\\n  s\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 87570,
                "title": "simple-1-pass-java-solution-with-only-1-stack-with-explanation",
                "content": "We don't have to use more than one stack. the concept is simple : If you see a closing bracket, repeat the string it contains inside given number of time and then push it back. [Recursion call, turned into iteration]. \\n\\n```\\npublic String decodeString(String s) {\\n        \\n        Stack<Character> stack = new Stack<>();\\n        \\n        for(char c : s.toCharArray())\\n        {\\n            if(c != ']') \\n                stack.push(c); //push everything but ]\\n            \\n            else \\n            {\\n                //step 1: \\n                    //if you find a closing ] then \\n                   //retrieve the string it encapsulates\\n                \\n                StringBuilder sb = new StringBuilder();\\n                while(!stack.isEmpty() && Character.isLetter(stack.peek()))\\n                    sb.insert(0, stack.pop());\\n                \\n                String sub = sb.toString(); //this is the string contained in [ ]\\n                stack.pop(); //Discard the '[';\\n                \\n                \\n                //step 2: \\n                    //after that get the number of\\n                  // times it should repeat from stack\\n                    \\n                sb = new StringBuilder();\\n                while(!stack.isEmpty() && Character.isDigit(stack.peek()))\\n                    sb.insert(0, stack.pop());\\n                    \\n                int count = Integer.valueOf(sb.toString()); //this is the number\\n                \\n                \\n                //step 3: \\n                    //repeat the string within the [ ] count \\n                  //number of times and push it back into stack\\n                \\n                while(count > 0)\\n                {\\n                    for(char ch : sub.toCharArray())  \\n                        stack.push(ch);\\n                    count--;\\n                }\\n            }\\n        }\\n        \\n      //final fetching and returning the value in stack \\n        StringBuilder retv = new StringBuilder();\\n        while(!stack.isEmpty())\\n            retv.insert(0, stack.pop());\\n\\n        return retv.toString();\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\npublic String decodeString(String s) {\\n        \\n        Stack<Character> stack = new Stack<>();\\n        \\n        for(char c : s.toCharArray())\\n        {\\n            if(c != ']') \\n                stack.push(c); //push everything but ]\\n            \\n            else \\n            {\\n                //step 1: \\n                    //if you find a closing ] then \\n                   //retrieve the string it encapsulates\\n                \\n                StringBuilder sb = new StringBuilder();\\n                while(!stack.isEmpty() && Character.isLetter(stack.peek()))\\n                    sb.insert(0, stack.pop());\\n                \\n                String sub = sb.toString(); //this is the string contained in [ ]\\n                stack.pop(); //Discard the '[';\\n                \\n                \\n                //step 2: \\n                    //after that get the number of\\n                  // times it should repeat from stack\\n                    \\n                sb = new StringBuilder();\\n                while(!stack.isEmpty() && Character.isDigit(stack.peek()))\\n                    sb.insert(0, stack.pop());\\n                    \\n                int count = Integer.valueOf(sb.toString()); //this is the number\\n                \\n                \\n                //step 3: \\n                    //repeat the string within the [ ] count \\n                  //number of times and push it back into stack\\n                \\n                while(count > 0)\\n                {\\n                    for(char ch : sub.toCharArray())  \\n                        stack.push(ch);\\n                    count--;\\n                }\\n            }\\n        }\\n        \\n      //final fetching and returning the value in stack \\n        StringBuilder retv = new StringBuilder();\\n        while(!stack.isEmpty())\\n            retv.insert(0, stack.pop());\\n\\n        return retv.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 384193,
                "title": "javascript-easy-to-understand-using-stack-44ms",
                "content": "- Traversal the string `s` and push into a stack for non-`]` character\\n- When we meets the `]` character, we should do these steps\\n\\t- pop all characters until meets `[`\\n\\t- pop all numbers to get the repeat count\\n\\t- repeat the substring and push it back to stack\\n- Finally, we `join` all the pieces in the stack\\n\\n```js\\nconst decodeString = s => {\\n  const stack = [];\\n  for (const char of s) {\\n    if (char !== \"]\") { stack.push(char); continue; }\\n    let cur = stack.pop();\\n    let str = \\'\\';\\n    while (cur !== \\'[\\') {\\n      str = cur + str;\\n      cur = stack.pop();\\n    }\\n    let num = \\'\\';\\n    cur = stack.pop();\\n    while (!Number.isNaN(Number(cur))) {\\n      num = cur + num;\\n      cur = stack.pop();\\n    }\\n    stack.push(cur);\\n    stack.push(str.repeat(Number(num)));\\n  }\\n  return stack.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst decodeString = s => {\\n  const stack = [];\\n  for (const char of s) {\\n    if (char !== \"]\") { stack.push(char); continue; }\\n    let cur = stack.pop();\\n    let str = \\'\\';\\n    while (cur !== \\'[\\') {\\n      str = cur + str;\\n      cur = stack.pop();\\n    }\\n    let num = \\'\\';\\n    cur = stack.pop();\\n    while (!Number.isNaN(Number(cur))) {\\n      num = cur + num;\\n      cur = stack.pop();\\n    }\\n    stack.push(cur);\\n    stack.push(str.repeat(Number(num)));\\n  }\\n  return stack.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 87615,
                "title": "simple-java-dfs-solution",
                "content": "```\\npublic class Solution {\\n    private int pos = 0;\\n    public String decodeString(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        String num = \"\";\\n        for (int i = pos; i < s.length(); i++) {\\n            if (s.charAt(i) != '[' && s.charAt(i) != ']' && !Character.isDigit(s.charAt(i))) {\\n                sb.append(s.charAt(i));\\n            } else if (Character.isDigit(s.charAt(i))) {\\n                num += s.charAt(i);\\n            } else if (s.charAt(i) == '[') {\\n                pos = i + 1;\\n                String next = decodeString(s);\\n                for (int n = Integer.valueOf(num); n > 0; n--) sb.append(next);\\n                num = \"\";\\n                i = pos;\\n            } else if (s.charAt(i) == ']') {\\n                pos = i;\\n                return sb.toString();\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    private int pos = 0;\\n    public String decodeString(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        String num = \"\";\\n        for (int i = pos; i < s.length(); i++) {\\n            if (s.charAt(i) != '[' && s.charAt(i) != ']' && !Character.isDigit(s.charAt(i))) {\\n                sb.append(s.charAt(i));\\n            } else if (Character.isDigit(s.charAt(i))) {\\n                num += s.charAt(i);\\n            } else if (s.charAt(i) == '[') {\\n                pos = i + 1;\\n                String next = decodeString(s);\\n                for (int n = Integer.valueOf(num); n > 0; n--) sb.append(next);\\n                num = \"\";\\n                i = pos;\\n            } else if (s.charAt(i) == ']') {\\n                pos = i;\\n                return sb.toString();\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 586930,
                "title": "explained-python-solution-using-single-stack",
                "content": "\\nExplanation:\\nSolved using stack\\n1. Possible inputs are - \\'[\\' , \\']\\', alphabet(s) or numbers. Lets talk about each one by one.\\n\\n2. We will start for loop for traversing through each element of \\'s\\'. If we encounter a number, it will be handled by checking isdigit() condition. curNum10+int(c) helps in storing the number in curnum ,when the number is more than single digit.\\n\\n3.When we encounter a character, we will start it adding to a string named curString. The character can be single or multiple. curString+=c will keep the character string.\\n\\n4.The easy part is over.Now, when we encounter \\'[\\' it means thats a start of a new substring, meaning the previous substring (if there was one) has already been traversed and handled. So , we will append the current curString and curNum to stack and,  reset our curString as empty string and curNum as 0 to use in further porcessing as we have a open bracket which means start of a new substring.\\n\\n5.Finally when we encounter a close bracket \\']\\', it certainely means we have reached where our substring is complete, now we have to find a way to calculate it. Thats when we go back to stack to find what we have stored there which will help us in calculating the current substring. In the stack we will find a number on top which is popped and then a previous string which we will need to add with the curstringnum, and everything will be stored in curString after calculation.  \\n\\n6.The calculated curstring will be returned as answer if \\'s\\' is over else it will be again appended to stack when an open bracket is encountered. And the above process will be repeated per condition.\\n\\n\\n```\\n\\nclass Solution(object):\\n    def decodeString(self, s):\\n        stack = []; curNum = 0; curString = \\'\\'\\n        for c in s:\\n            if c == \\'[\\':\\n                stack.append(curString)\\n                stack.append(curNum)\\n                curString = \\'\\'\\n                curNum = 0\\n            elif c == \\']\\':\\n                num = stack.pop()\\n                prevString = stack.pop()\\n                curString = prevString + num*curString\\n            elif c.isdigit():     # curNum*10+int(c) is helpful in keep track of more than 1 digit number\\n                curNum = curNum*10 + int(c)\\n            else:\\n                curString += c\\n        return curString\\n```\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\n\\nclass Solution(object):\\n    def decodeString(self, s):\\n        stack = []; curNum = 0; curString = \\'\\'\\n        for c in s:\\n            if c == \\'[\\':\\n                stack.append(curString)\\n                stack.append(curNum)\\n                curString = \\'\\'\\n                curNum = 0\\n            elif c == \\']\\':\\n                num = stack.pop()\\n                prevString = stack.pop()\\n                curString = prevString + num*curString\\n            elif c.isdigit():     # curNum*10+int(c) is helpful in keep track of more than 1 digit number\\n                curNum = curNum*10 + int(c)\\n            else:\\n                curString += c\\n        return curString\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635464,
                "title": "c-python-clean-simple-solutions-w-explanation-recursive-iterative-using-custom-stack",
                "content": "We are given an encoded string with rule: `k[encoded_string]` and we need to return the decoded string.\\n\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (Recursion)***\\n\\nIt\\'s important to observe the pattern of the encoded string. The encoded string is of the format - \\n\\n```\\n\"alphabets + number[encoded_string] + alphabets + number[encoded_string] + ... + alphabets\"\\n```\\n\\nEach of the term is optional which means string may or may not start/end with alphabets or contain numbers within it. Some examples are `\"ab2[cd]ef\"`, `\"2[cd]ef\"`, `\"ab2[cd]\"`, `\"abef\"`, `\"ab2[cd]ef3[gh]ij\"` and so on...\\n\\nAlso, each of encoded-string in bracket is itself an encoded string and thus it can also contain a string with similar format as mentioned above. Thus, an encoded string may consists of multiple encoded string recursively. This gives us the intuition to solve this problem recursively. \\n* Each time we decode **1st part of encoded string which string of alphabets**. We can simply add these to the final string directly.\\n* Then we decode the **2nd part of encoded string which is a digits followed by next level of encoded string**. We form the number from digits and recurse for next level of encoded string.\\n* Each recursive call will return the decoded string of the encoded string present on that level. The recursive call will return / end when we reach the end of string (only possible in base level) or find an extra closing bracket which denotes end of current level.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int i = 0;                                                // global variable used to track current index\\n    string repeat(string s, int times) {                      // repeats a string for given number of times\\n        for(int n = size(s); --times; s += s.substr(0, n));\\n        return s;\\n    }\\n    string decodeString(string& s) {\\n        string ans = \"\", n = \"\";\\n        while(i < size(s) && s[i] != \\']\\') {                   // loop till reach end or decode current level by reaching \\']\\'\\n            for(; i < size(s) && isalpha(s[i]); i++)          // 1st part\\n                ans += s[i]; \\n            if(i >= size(s) || s[i] == \\']\\') continue;         // skip if next part doesn\\'t contain number\\n            for(n = \"\"; i < size(s) && isdigit(s[i]); i++)    // 2nd part\\n                n += s[i];\\n            i++;                                              // skip opening bracket   \\n            ans += repeat(decodeString(s), stoi(n));          // repeats string decoded from bracket n times\\n            i++;                                              // skip closing bracket    \\n        } \\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def decodeString(self, s):\\n        def decode(i):\\n            ans = \"\"\\n            while i < len(s) and s[i] != \\']\\':\\n                while i < len(s) and s[i].isalpha():\\n                    ans += s[i]\\n                    i += 1\\n                if i >= len(s) or s[i] == \\']\\': continue\\n                n = \"\"\\n                while i < len(s) and s[i].isdigit():\\n                    n += s[i]\\n                    i += 1\\n                tmp, i = decode(i+1)\\n                ans += tmp * int(n)\\n            return (ans, i+1)\\n        return decode(0)[0]\\n```\\n\\n***Time Complexity :*** <code>O(N)</code>, where `N` is the length of output\\n***Space Complexity :*** `O(L)`, where `L` is the maximum depth/levels of nested encoded string\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Using Custom Stack)***\\n\\nA solution with similar logic as above but the iterative version using explicit custom stack. \\n* As done above, for string of alphabets, we will simply add them to `ans`. \\n* If we get digits, we add them in `n` string till we find `[`\\n* Once we find `[`, we will push `n` and `ans` formed till now\\n* When we find `]`, we will pop top element (denoted by `cnt` and `prev` in the code below) which will be count to repeat string formed in this level and the previous string formed. We simply repeat current string `ans` for `cnt` number of times and add it to `prev` string.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    string repeat(string& s, int times) {\\n        for(int n = size(s); --times; s += s.substr(0, n));\\n        return s;\\n    }    \\n    string decodeString(string& s) {\\n        stack<pair<string, string>> stk;                          // {n, ans} = {count to repeat, string formed in this level till now}\\n        string ans = \"\", n = \"\";\\n        for(auto c : s)\\n            if(isalpha(c))      ans += c;\\n            else if(isdigit(c)) n += c;\\n            else if(c == \\'[\\')   stk.push({move(n), move(ans)});   // directly moves into stack avoiding copy & thus also clears n and ans\\n            else {\\n                auto [cnt, prev] = stk.top(); stk.pop();\\n                ans = prev + repeat(ans, stoi(cnt));\\n            }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def decodeString(self, s):\\n        stk, ans, n = deque(), \"\", \"\"\\n        for c in s:\\n            if c.isalpha():   ans += c\\n            elif c.isdigit(): n += c\\n            elif c == \\'[\\': \\n                stk.append((n, ans))\\n                n, ans = \"\", \"\"\\n            else:\\n                cnt, prev = stk.pop()\\n                ans = prev + ans * int(cnt)\\n        return ans\\n```\\n\\n***Time Complexity :*** <code>O(N)</code>\\n***Space Complexity :*** `O(L)`\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```\\n\"alphabets + number[encoded_string] + alphabets + number[encoded_string] + ... + alphabets\"\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int i = 0;                                                // global variable used to track current index\\n    string repeat(string s, int times) {                      // repeats a string for given number of times\\n        for(int n = size(s); --times; s += s.substr(0, n));\\n        return s;\\n    }\\n    string decodeString(string& s) {\\n        string ans = \"\", n = \"\";\\n        while(i < size(s) && s[i] != \\']\\') {                   // loop till reach end or decode current level by reaching \\']\\'\\n            for(; i < size(s) && isalpha(s[i]); i++)          // 1st part\\n                ans += s[i]; \\n            if(i >= size(s) || s[i] == \\']\\') continue;         // skip if next part doesn\\'t contain number\\n            for(n = \"\"; i < size(s) && isdigit(s[i]); i++)    // 2nd part\\n                n += s[i];\\n            i++;                                              // skip opening bracket   \\n            ans += repeat(decodeString(s), stoi(n));          // repeats string decoded from bracket n times\\n            i++;                                              // skip closing bracket    \\n        } \\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def decodeString(self, s):\\n        def decode(i):\\n            ans = \"\"\\n            while i < len(s) and s[i] != \\']\\':\\n                while i < len(s) and s[i].isalpha():\\n                    ans += s[i]\\n                    i += 1\\n                if i >= len(s) or s[i] == \\']\\': continue\\n                n = \"\"\\n                while i < len(s) and s[i].isdigit():\\n                    n += s[i]\\n                    i += 1\\n                tmp, i = decode(i+1)\\n                ans += tmp * int(n)\\n            return (ans, i+1)\\n        return decode(0)[0]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    string repeat(string& s, int times) {\\n        for(int n = size(s); --times; s += s.substr(0, n));\\n        return s;\\n    }    \\n    string decodeString(string& s) {\\n        stack<pair<string, string>> stk;                          // {n, ans} = {count to repeat, string formed in this level till now}\\n        string ans = \"\", n = \"\";\\n        for(auto c : s)\\n            if(isalpha(c))      ans += c;\\n            else if(isdigit(c)) n += c;\\n            else if(c == \\'[\\')   stk.push({move(n), move(ans)});   // directly moves into stack avoiding copy & thus also clears n and ans\\n            else {\\n                auto [cnt, prev] = stk.top(); stk.pop();\\n                ans = prev + repeat(ans, stoi(cnt));\\n            }\\n\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def decodeString(self, s):\\n        stk, ans, n = deque(), \"\", \"\"\\n        for c in s:\\n            if c.isalpha():   ans += c\\n            elif c.isdigit(): n += c\\n            elif c == \\'[\\': \\n                stk.append((n, ans))\\n                n, ans = \"\", \"\"\\n            else:\\n                cnt, prev = stk.pop()\\n                ans = prev + ans * int(cnt)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163479,
                "title": "python-short-and-simple-stack-solution-beats-100-with-explanation",
                "content": "The solution is a simple stack based one which evalutes the innermost brackets first. You iterate through the string, and push everything to a stack until you\\'ve found a right bracket. Once you\\'ve found a right bracket, you use that and pop from the stack to evaluate the innermost expression in the string. For example, if you have `2[a3[b]]`, your stack would be ` [2, \"[\", \"a\", 3, \"[\", \"b\"] ` when it reaches the first right bracket. Once it reaches the first right bracket, it attempts to evaluate everything in the innermost bracket by popping from the stack to form the entire string you need to multiply, and finding the number you need to multiply by. After this, the stack will look like: `[2, \"[\", \"a\", \"bbb\" ]`. The innermost expression of `3, \"[\", \"b\"` was turned into `bbb` and put back into the stack. At the next right bracket, we will similarily evaluate the innermost bracket , so that the stack turns into `[\"abbbabbb\"]`. If there are multiple sets of enclosed brackets in the expression, our stack will end up with multiple strings in the end. Simply join them for the result. \\n\\n```\\n    def decodeString(self, s):\\n        stack = []\\n        for i in range(len(s)):\\n            if s[i] == \"]\":\\n                current = \\'\\'\\n                while stack:\\n                    val = stack.pop()\\n                    if val ==  \"[\":\\n                        break\\n                    current = val + current\\n                num = \\'\\'\\n                while stack and stack[-1].isdigit():\\n                    num = stack.pop() + num\\n                stack.append(int(num)*current)\\n            else:\\n                stack.append(s[i])\\n        return \\'\\'.join(stack)\\n```",
                "solutionTags": [],
                "code": "```\\n    def decodeString(self, s):\\n        stack = []\\n        for i in range(len(s)):\\n            if s[i] == \"]\":\\n                current = \\'\\'\\n                while stack:\\n                    val = stack.pop()\\n                    if val ==  \"[\":\\n                        break\\n                    current = val + current\\n                num = \\'\\'\\n                while stack and stack[-1].isdigit():\\n                    num = stack.pop() + num\\n                stack.append(int(num)*current)\\n            else:\\n                stack.append(s[i])\\n        return \\'\\'.join(stack)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 810400,
                "title": "clean-java-solution-beats-100-stringbuilder",
                "content": "Clean solution easy to understand. The idea is similar to [basic calculator](https://leetcode.com/problems/basic-calculator/). We use a counter `i` to keep track of our progress in string `s` and recursively calculate subproblems quoted by `[]`.\\n\\n\\n    int i = 0;\\n    public String decodeString(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int count = 0;\\n        String tmp_string = \"\";\\n        \\n        while (i < s.length()) {\\n            char c = s.charAt(i);\\n            i++;\\n            \\n            if (c == \\'[\\') {\\n                tmp_string = decodeString(s); // do subproblem\\n                for (int j = 0; j < count; j++) {\\n                    sb.append(tmp_string);\\n                }\\n                count = 0; // reset counter\\n            } else if (c == \\']\\') { // subproblem complete\\n                break;\\n            } else if (Character.isAlphabetic(c)) {\\n                sb.append(c);\\n            } else {\\n                count = count * 10 + c - \\'0\\';\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n",
                "solutionTags": [
                    "Java",
                    "String",
                    "Recursion"
                ],
                "code": "Clean solution easy to understand. The idea is similar to [basic calculator](https://leetcode.com/problems/basic-calculator/). We use a counter `i` to keep track of our progress in string `s` and recursively calculate subproblems quoted by `[]`.\\n\\n\\n    int i = 0;\\n    public String decodeString(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int count = 0;\\n        String tmp_string = \"\";\\n        \\n        while (i < s.length()) {\\n            char c = s.charAt(i);\\n            i++;\\n            \\n            if (c == \\'[\\') {\\n                tmp_string = decodeString(s); // do subproblem\\n                for (int j = 0; j < count; j++) {\\n                    sb.append(tmp_string);\\n                }\\n                count = 0; // reset counter\\n            } else if (c == \\']\\') { // subproblem complete\\n                break;\\n            } else if (Character.isAlphabetic(c)) {\\n                sb.append(c);\\n            } else {\\n                count = count * 10 + c - \\'0\\';\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 87567,
                "title": "java-simple-recursive-solution",
                "content": "the run time is 3 ms. And the method is really straight-forward: every time when you meet a number, it must be followed by [...], we just need to recursively call our method to decode \"...\", then repeat the result \"num\" times.\\n\\n'''\\npublic class Solution {\\n    public String decodeString(String s) {\\n\\n        if (s.length() == 0) return \"\";\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < s.length(); i ++) {\\n            char c = s.charAt(i);\\n            if (Character.isDigit(c)) {\\n                int digit_begin = i;\\n                while (s.charAt(i) != '[') i++;\\n                int num = Integer.valueOf(s.substring(digit_begin, i));\\n                int count = 1;\\n                int str_begin = i+1;\\n                i ++;\\n                while (count != 0) {\\n                    if (s.charAt(i) == '[') count ++;\\n                    else if (s.charAt(i) == ']') count --;\\n                    i ++;\\n                }\\n                i--;\\n                String str = decodeString(s.substring(str_begin, i));\\n                for (int j = 0; j < num; j ++) {\\n                    sb.append(str);\\n                }\\n            } else {\\n                sb.append(c);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n'''",
                "solutionTags": [],
                "code": "class Solution {\\n    public String decodeString(String s) {\\n\\n        if (s.length() == 0) return \"\";\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < s.length(); i ++) {\\n            char c = s.charAt(i);\\n            if (Character.isDigit(c)) {\\n                int digit_begin = i;\\n                while (s.charAt(i) != '[') i++;\\n                int num = Integer.valueOf(s.substring(digit_begin, i));\\n                int count = 1;\\n                int str_begin = i+1;\\n                i ++;\\n                while (count != 0) {\\n                    if (s.charAt(i) == '[') count ++;\\n                    else if (s.charAt(i) == ']') count --;\\n                    i ++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3224703,
                "title": "stack-java-1ms-beat",
                "content": "\\n# Approach\\nO(N)\\n# Code\\n```\\nclass Solution {\\n    public String decodeString(String s) {\\n        Stack<Integer>numStack=new Stack<>();\\n        Stack<StringBuilder>strBuild=new Stack<>();\\n        StringBuilder str = new StringBuilder();\\n        int num=0;\\n        for(char c:s.toCharArray()){\\n            if(c>=\\'0\\' && c<=\\'9\\'){\\n                num=num*10 +c -\\'0\\';\\n            }\\n            else if(c==\\'[\\'){\\n                strBuild.push(str);\\n                str=new StringBuilder();\\n                numStack.push(num);\\n                num=0;\\n            }else if(c==\\']\\'){\\n                StringBuilder temp=str;\\n                str=strBuild.pop();\\n                int count=numStack.pop();\\n                while(count-->0){\\n                    str.append(temp);\\n                }\\n            }else{\\n                str.append(c);\\n            }\\n        }\\n        return str.toString();\\n    }   \\n}\\n```\\n\\n![8873f9b1-dfa4-4d9c-bb67-1b6db9d65e35_1674992431.3815322.jpeg](https://assets.leetcode.com/users/images/87473a41-9c53-4e65-967e-15f92ebc9310_1677233624.267395.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeString(String s) {\\n        Stack<Integer>numStack=new Stack<>();\\n        Stack<StringBuilder>strBuild=new Stack<>();\\n        StringBuilder str = new StringBuilder();\\n        int num=0;\\n        for(char c:s.toCharArray()){\\n            if(c>=\\'0\\' && c<=\\'9\\'){\\n                num=num*10 +c -\\'0\\';\\n            }\\n            else if(c==\\'[\\'){\\n                strBuild.push(str);\\n                str=new StringBuilder();\\n                numStack.push(num);\\n                num=0;\\n            }else if(c==\\']\\'){\\n                StringBuilder temp=str;\\n                str=strBuild.pop();\\n                int count=numStack.pop();\\n                while(count-->0){\\n                    str.append(temp);\\n                }\\n            }else{\\n                str.append(c);\\n            }\\n        }\\n        return str.toString();\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1400105,
                "title": "98-faster-with-and-without-stack-cleane-concise",
                "content": "## IDEA :\\n**Using stack** to store the previously stored string and the number which we have to use instantly after bracket(if any) gets closed.\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        \\n        res,num = \"\",0\\n        st = []\\n        for c in s:\\n            if c.isdigit():\\n                num = num*10+int(c)    \\n            elif c==\"[\":\\n                st.append(res)\\n                st.append(num)\\n                res=\"\"\\n                num=0\\n            elif c==\"]\":\\n                pnum = st.pop()\\n                pstr = st.pop()\\n                res = pstr + pnum*res\\n            else:\\n                res+=c\\n        \\n        return res\\n\\t\\t\\n****\\n### IDEA :\\n**Using RECURSION :**\\n\\'\\'\\'\\n\\t\\n\\tclass Solution:\\n    def decodeString(self, s: str) -> str:       \\n        def dfs(s,p):\\n            res = \"\"\\n            i,num = p,0\\n            while i<len(s):\\n                asc = (ord(s[i])-48)\\n                if 0<=asc<=9:           # can also be written as if s[i].isdigit()\\n                    num=num*10+asc\\n                elif s[i]==\"[\":\\n                    local,pos = dfs(s,i+1)\\n                    res+=local*num\\n                    i=pos\\n                    num=0\\n                elif s[i]==\"]\":\\n                    return res,i\\n                else:\\n                    res+=s[i]\\n                i+=1\\n            return res,i\\n        \\n        return dfs(s,0)[0]\\n\\t\\t\\n***Thanks*** and feel free to ask if you have any doubt!! \\uD83E\\uDD17\\n**Upvote** if you found interesting !!\\uD83E\\uDD1E",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Recursion"
                ],
                "code": "## IDEA :\\n**Using stack** to store the previously stored string and the number which we have to use instantly after bracket(if any) gets closed.\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        \\n        res,num = \"\",0\\n        st = []\\n        for c in s:\\n            if c.isdigit():\\n                num = num*10+int(c)    \\n            elif c==\"[\":\\n                st.append(res)\\n                st.append(num)\\n                res=\"\"\\n                num=0\\n            elif c==\"]\":\\n                pnum = st.pop()\\n                pstr = st.pop()\\n                res = pstr + pnum*res\\n            else:\\n                res+=c\\n        \\n        return res\\n\\t\\t\\n****\\n### IDEA :\\n**Using RECURSION :**\\n\\'\\'\\'\\n\\t\\n\\tclass Solution:\\n    def decodeString(self, s: str) -> str:       \\n        def dfs(s,p):\\n            res = \"\"\\n            i,num = p,0\\n            while i<len(s):\\n                asc = (ord(s[i])-48)\\n                if 0<=asc<=9:           # can also be written as if s[i].isdigit()\\n                    num=num*10+asc\\n                elif s[i]==\"[\":\\n                    local,pos = dfs(s,i+1)\\n                    res+=local*num\\n                    i=pos\\n                    num=0\\n                elif s[i]==\"]\":\\n                    return res,i\\n                else:\\n                    res+=s[i]\\n                i+=1\\n            return res,i\\n        \\n        return dfs(s,0)[0]\\n\\t\\t\\n***Thanks*** and feel free to ask if you have any doubt!! \\uD83E\\uDD17\\n**Upvote** if you found interesting !!\\uD83E\\uDD1E",
                "codeTag": "Java"
            },
            {
                "id": 941380,
                "title": "c-amazing-easy-iterative-fully-explained-solution-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    // Helper function to repeat substring a number of times:\\n    string repeat(string str, int times) {\\n        string res = \"\";\\n        for (int i=0; i<times; i++)\\n            res += str;\\n        return res;\\n    }\\n    \\n    string decodeString(string s) {\\n        int i=0;\\n        while (i < s.size()) {\\n            if (s[i] != \\']\\') {\\n                i++;\\n                continue;\\n            }\\n            \\n            // When we get to closing parenthesis,\\n            // we will look back to get the letters to repeat and the number of times\\n            // then we replace the original part in the string and place i after that to continue.\\n            int j = i;\\n            while (s[j] != \\'[\\') // Extract letters\\n                j--;\\n        \\n            string letters_to_repeat = s.substr(j+1, i-j-1);\\n            int k = j;\\n            j--;\\n            while ((j > 0) &&(isdigit(s[j]))) // Before opening parethesis we get the number\\n                j--;\\n            \\n            if (j != 0) j++; // Edge case where we are at the beginning of the string\\n            int times_to_repeat = stoi(s.substr(j, k-j));\\n            \\n            s.replace(j, i-j+1, repeat(letters_to_repeat, times_to_repeat));\\n\\t\\t\\t\\n            // Put i in the right place now\\n            i = j+letters_to_repeat.size()*times_to_repeat;\\n        }\\n        return s;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Helper function to repeat substring a number of times:\\n    string repeat(string str, int times) {\\n        string res = \"\";\\n        for (int i=0; i<times; i++)\\n            res += str;\\n        return res;\\n    }\\n    \\n    string decodeString(string s) {\\n        int i=0;\\n        while (i < s.size()) {\\n            if (s[i] != \\']\\') {\\n                i++;\\n                continue;\\n            }\\n            \\n            // When we get to closing parenthesis,\\n            // we will look back to get the letters to repeat and the number of times\\n            // then we replace the original part in the string and place i after that to continue.\\n            int j = i;\\n            while (s[j] != \\'[\\') // Extract letters\\n                j--;\\n        \\n            string letters_to_repeat = s.substr(j+1, i-j-1);\\n            int k = j;\\n            j--;\\n            while ((j > 0) &&(isdigit(s[j]))) // Before opening parethesis we get the number\\n                j--;\\n            \\n            if (j != 0) j++; // Edge case where we are at the beginning of the string\\n            int times_to_repeat = stoi(s.substr(j, k-j));\\n            \\n            s.replace(j, i-j+1, repeat(letters_to_repeat, times_to_repeat));\\n\\t\\t\\t\\n            // Put i in the right place now\\n            i = j+letters_to_repeat.size()*times_to_repeat;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87598,
                "title": "simple-linear-time-python-solution-with-notes",
                "content": "Concatenate digits and alphabets. When `[` appears, push the current alphas and digits (as an integer `n`) into the stack, and start a new concatenation for alphas and digits. When a `]` appears, pop the stack and extend the popped alphas `n` times to the current alphas. \\n\\nComplexity is linear in both time and space.\\n\\n```\\nclass Solution(object):\\n    def decodeString(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        stack = []\\n        \\n        alphas, digits = '', ''\\n\\n        for c in s:\\n            if c.isdigit():\\n                digits += c\\n            elif c == '[':\\n                stack.append((alphas, int(digits)))\\n                alphas, digits = '', ''\\n            elif c == ']':\\n                prev, n = stack.pop()\\n                alphas = prev + alphas * n\\n            elif c.isalpha():\\n                alphas += c\\n\\n        return alphas\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def decodeString(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        stack = []\\n        \\n        alphas, digits = '', ''\\n\\n        for c in s:\\n            if c.isdigit():\\n                digits += c\\n            elif c == '[':\\n                stack.append((alphas, int(digits)))\\n                alphas, digits = '', ''\\n            elif c == ']':\\n                prev, n = stack.pop()\\n                alphas = prev + alphas * n\\n            elif c.isalpha():\\n                alphas += c\\n\\n        return alphas\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1162986,
                "title": "stack-javascript-with-explanation",
                "content": "```\\nvar decodeString = function(str) {\\n    /*\\n        we have 4 possibilities\\n        1) opening braces -> new sequence starts, so \\n        add curr string and curr number to the stack, reassign both\\n        to initial values\\n        2) closing braces -> the sequence is over, it is time to create a substring\\n        by getting prev string and prev number from the stack, add prev string(repeated prev num times)\\n        to curr string\\n        3) if it is number add to curr num\\n        4) if it is char add to curr string\\n    */\\n    let stack = [];\\n    let currStr = \\'\\';\\n    let currNum = 0;\\n    \\n    for (let i = 0; i < str.length; i ++) {\\n        if (str[i] === \\'[\\') {\\n            stack.push(currStr);\\n            stack.push(currNum);\\n            currStr = \\'\\';\\n            currNum = 0;\\n        } else if (str[i] === \\']\\') {\\n            let prevNum = stack.pop();\\n            let prevStr = stack.pop();\\n            currStr = prevStr + currStr.repeat(prevNum);\\n        } else if (str[i] >= \\'0\\' && str[i] <= \\'9\\') {\\n            currNum = currNum * 10 + Number(str[i]);\\n        } else {\\n            currStr += str[i];\\n        }\\n    }\\n    \\n    return currStr;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nvar decodeString = function(str) {\\n    /*\\n        we have 4 possibilities\\n        1) opening braces -> new sequence starts, so \\n        add curr string and curr number to the stack, reassign both\\n        to initial values\\n        2) closing braces -> the sequence is over, it is time to create a substring\\n        by getting prev string and prev number from the stack, add prev string(repeated prev num times)\\n        to curr string\\n        3) if it is number add to curr num\\n        4) if it is char add to curr string\\n    */\\n    let stack = [];\\n    let currStr = \\'\\';\\n    let currNum = 0;\\n    \\n    for (let i = 0; i < str.length; i ++) {\\n        if (str[i] === \\'[\\') {\\n            stack.push(currStr);\\n            stack.push(currNum);\\n            currStr = \\'\\';\\n            currNum = 0;\\n        } else if (str[i] === \\']\\') {\\n            let prevNum = stack.pop();\\n            let prevStr = stack.pop();\\n            currStr = prevStr + currStr.repeat(prevNum);\\n        } else if (str[i] >= \\'0\\' && str[i] <= \\'9\\') {\\n            currNum = currNum * 10 + Number(str[i]);\\n        } else {\\n            currStr += str[i];\\n        }\\n    }\\n    \\n    return currStr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3258413,
                "title": "394-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize the stack and the current string:\\n```\\nstack = []\\ncurr_str = \"\"\\n```\\nThe stack is used to keep track of the current number and string that are being processed. The curr_str variable will store the current string that is being decoded.\\n\\n2. Initialize the current number to 0:\\n```\\ncurr_num = 0\\n```\\nThe curr_num variable is used to keep track of the current number that is being processed.\\n\\n3. Iterate through each character of the string:\\n```\\nfor c in s:\\n```\\nThis loop will iterate through each character of the given string s.\\n\\n4. If the character is a digit, update the current number:\\n```\\nif c.isdigit():\\n    curr_num = curr_num * 10 + int(c)\\n```\\nIf the current character is a digit, it is part of a number that needs to be decoded. The curr_num variable is updated by multiplying the current number by 10 and adding the value of the current digit.\\n\\n5. If the character is an opening bracket, push the current number and current string onto the stack:\\n```\\nelif c == \"[\":\\n    stack.append(curr_num)\\n    stack.append(curr_str)\\n    curr_num = 0\\n    curr_str = \"\"\\n```\\nIf the current character is an opening bracket, it means that a new string is to be decoded. The curr_num and curr_str variables are pushed onto the stack, and are reset to their initial values.\\n\\n6. If the character is a closing bracket, repeat the popped characters and push the result back onto the stack:\\n```\\nelif c == \"]\":\\n    prev_str = stack.pop()\\n    prev_num = stack.pop()\\n    curr_str = prev_str + curr_str * prev_num\\n```\\nIf the current character is a closing bracket, it means that a string needs to be repeated. The prev_str and prev_num variables are popped from the stack and the curr_str variable is updated by concatenating the previous string with the current string repeated prev_num times.\\n\\n7. If the character is a letter, append it to the current string:\\n```\\nelse:\\n    curr_str += c\\n```\\nIf the current character is a letter, it is part of the string that needs to be decoded. The current character is appended to the curr_str variable.\\n\\n8. Pop any remaining characters from the stack and concatenate them to the final result:\\n```\\nwhile stack:\\n    curr_str = stack.pop() + curr_str\\n```\\nAfter the loop has finished, there may be remaining characters in the stack that need to be added to the final result. The remaining characters are popped from the stack and concatenated to the beginning of the curr_str variable.\\n\\n9. Return the final decoded string:\\n```\\nreturn curr_str\\n```\\nThe final decoded string is returned.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        # Initialize the stack and the current string\\n        stack = []\\n        curr_str = \"\"\\n        # Initialize the current number to 0\\n        curr_num = 0\\n        \\n        # Iterate through each character of the string\\n        for c in s:\\n            # If the character is a digit, update the current number\\n            if c.isdigit():\\n                curr_num = curr_num * 10 + int(c)\\n            # If the character is an opening bracket, push the current number and current string onto the stack\\n            elif c == \"[\":\\n                stack.append(curr_num)\\n                stack.append(curr_str)\\n                # Reset the current number and current string\\n                curr_num = 0\\n                curr_str = \"\"\\n            # If the character is a closing bracket, repeat the popped characters and push the result back onto the stack\\n            elif c == \"]\":\\n                prev_str = stack.pop()\\n                prev_num = stack.pop()\\n                curr_str = prev_str + curr_str * prev_num\\n            # If the character is a letter, append it to the current string\\n            else:\\n                curr_str += c\\n        \\n        # Pop any remaining characters from the stack and concatenate them to the final result\\n        while stack:\\n            curr_str = stack.pop() + curr_str\\n        \\n        return curr_str\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nstack = []\\ncurr_str = \"\"\\n```\n```\\ncurr_num = 0\\n```\n```\\nfor c in s:\\n```\n```\\nif c.isdigit():\\n    curr_num = curr_num * 10 + int(c)\\n```\n```\\nelif c == \"[\":\\n    stack.append(curr_num)\\n    stack.append(curr_str)\\n    curr_num = 0\\n    curr_str = \"\"\\n```\n```\\nelif c == \"]\":\\n    prev_str = stack.pop()\\n    prev_num = stack.pop()\\n    curr_str = prev_str + curr_str * prev_num\\n```\n```\\nelse:\\n    curr_str += c\\n```\n```\\nwhile stack:\\n    curr_str = stack.pop() + curr_str\\n```\n```\\nreturn curr_str\\n```\n```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        # Initialize the stack and the current string\\n        stack = []\\n        curr_str = \"\"\\n        # Initialize the current number to 0\\n        curr_num = 0\\n        \\n        # Iterate through each character of the string\\n        for c in s:\\n            # If the character is a digit, update the current number\\n            if c.isdigit():\\n                curr_num = curr_num * 10 + int(c)\\n            # If the character is an opening bracket, push the current number and current string onto the stack\\n            elif c == \"[\":\\n                stack.append(curr_num)\\n                stack.append(curr_str)\\n                # Reset the current number and current string\\n                curr_num = 0\\n                curr_str = \"\"\\n            # If the character is a closing bracket, repeat the popped characters and push the result back onto the stack\\n            elif c == \"]\":\\n                prev_str = stack.pop()\\n                prev_num = stack.pop()\\n                curr_str = prev_str + curr_str * prev_num\\n            # If the character is a letter, append it to the current string\\n            else:\\n                curr_str += c\\n        \\n        # Pop any remaining characters from the stack and concatenate them to the final result\\n        while stack:\\n            curr_str = stack.pop() + curr_str\\n        \\n        return curr_str\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 378711,
                "title": "easy-understand-python-solution-88-beat",
                "content": "When meet \\'[\\' append the previous num and string to stack, when meet the \\']\\' pop the previous num and string to calculate. Notice the num*10 + num is for some case like \"100[leetcode]\" that num is greater than 10.\\n\\n```\\n\\tdef decodeString(self, s: str) -> str:\\n        num = 0\\n        string = \\'\\'\\n        stack = []\\n        for c in s:\\n            if c.isdigit():\\n                num = num*10 + int(c)\\n            elif c == \"[\":\\n                stack.append(string)\\n                stack.append(num)\\n                string = \\'\\'\\n                num = 0\\n            elif c.isalpha():\\n                string += c\\n            elif c == \\']\\':\\n                pre_num = stack.pop()\\n                pre_string = stack.pop()\\n                string = pre_string + pre_num * string\\n        return string\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\n\\tdef decodeString(self, s: str) -> str:\\n        num = 0\\n        string = \\'\\'\\n        stack = []\\n        for c in s:\\n            if c.isdigit():\\n                num = num*10 + int(c)\\n            elif c == \"[\":\\n                stack.append(string)\\n                stack.append(num)\\n                string = \\'\\'\\n                num = 0\\n            elif c.isalpha():\\n                string += c\\n            elif c == \\']\\':\\n                pre_num = stack.pop()\\n                pre_string = stack.pop()\\n                string = pre_string + pre_num * string\\n        return string\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 738090,
                "title": "c-recursion-and-short",
                "content": "Four cases are considered. 1st when we encounter a `[`. 2nd when we encounter a `digit`. 3rd encountering a `]`. and last simple `words`. Please note that index i is passed by reference not by value.\\n```\\nclass Solution {\\npublic:\\n    string helper(int &i,string s){\\n        int num=0;\\n        string word=\"\";\\n        for(;i<s.length();i++)\\n        {\\n            if(s[i]>=\\'0\\' and s[i]<=\\'9\\')\\n                num=num*10+s[i]-\\'0\\';\\n            else if(s[i]==\\'[\\')\\n            {\\n                string ans=helper(++i,s);\\n                for(;num>0;num--)word+=ans;\\n            }\\n            else if(s[i]==\\']\\')\\n                return word;\\n            else\\n                word+=s[i];\\n        }\\n        return word;\\n    }\\n    string decodeString(string s) {\\n        int i=0;\\n        return helper(i,s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string helper(int &i,string s){\\n        int num=0;\\n        string word=\"\";\\n        for(;i<s.length();i++)\\n        {\\n            if(s[i]>=\\'0\\' and s[i]<=\\'9\\')\\n                num=num*10+s[i]-\\'0\\';\\n            else if(s[i]==\\'[\\')\\n            {\\n                string ans=helper(++i,s);\\n                for(;num>0;num--)word+=ans;\\n            }\\n            else if(s[i]==\\']\\')\\n                return word;\\n            else\\n                word+=s[i];\\n        }\\n        return word;\\n    }\\n    string decodeString(string s) {\\n        int i=0;\\n        return helper(i,s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2927099,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n         stack<string> chars;\\n        stack<int> nums;\\n        string res;\\n        int num = 0;\\n        for(char c : s) {\\n            if(isdigit(c)) {\\n                num = num*10 + (c-\\'0\\');                              \\n            }\\n            else if(isalpha(c)) {\\n                res.push_back(c);                \\n            }\\n            else if(c == \\'[\\') {\\n                chars.push(res);\\n                nums.push(num);\\n                res = \"\";\\n                num = 0;\\n            }\\n            else if(c == \\']\\') {\\n                string tmp = res;\\n                for(int i = 0; i < nums.top()-1; ++i) {\\n                    res += tmp;\\n                }\\n                res = chars.top() + res;\\n                chars.pop(); nums.pop();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n         stack<string> chars;\\n        stack<int> nums;\\n        string res;\\n        int num = 0;\\n        for(char c : s) {\\n            if(isdigit(c)) {\\n                num = num*10 + (c-\\'0\\');                              \\n            }\\n            else if(isalpha(c)) {\\n                res.push_back(c);                \\n            }\\n            else if(c == \\'[\\') {\\n                chars.push(res);\\n                nums.push(num);\\n                res = \"\";\\n                num = 0;\\n            }\\n            else if(c == \\']\\') {\\n                string tmp = res;\\n                for(int i = 0; i < nums.top()-1; ++i) {\\n                    res += tmp;\\n                }\\n                res = chars.top() + res;\\n                chars.pop(); nums.pop();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87690,
                "title": "simple-java-solution-single-stack-5ms",
                "content": "```\\npublic String decodeString(String s) {\\n\\tif(s==null || s.isEmpty()) return \"\";\\n\\tStringBuilder sb = new StringBuilder();\\n\\tchar[] charsS = s.toCharArray();\\n\\tDeque<String> stack = new ArrayDeque<>();\\n\\tfor(int i=0;i<charsS.length;i++) {\\n\\t\\tchar c = charsS[i];\\n\\t\\tif(c==']') { // if char is ], pop out the string to repeat and the repeat number\\n\\t\\t\\tStringBuilder sbCharsToRepeat = new StringBuilder();\\n\\t\\t\\twhile(!stack.isEmpty() && Character.isLetter(stack.peek().charAt(0))) { // build the string to repeat\\n\\t\\t\\t\\tsbCharsToRepeat.insert(0,stack.pop());\\n\\t\\t\\t}\\n\\t\\t\\tif(\"[\".equals(stack.peek())) stack.pop(); // pop out the [ char next to the repeat number\\n\\t\\t\\tStringBuilder kRepeats = new StringBuilder();\\n\\t\\t\\twhile(!stack.isEmpty() && Character.isDigit(stack.peek().charAt(0))) { // build the repeat number\\n\\t\\t\\t\\tkRepeats.insert(0,stack.pop());\\n\\t\\t\\t}\\n\\t\\t\\tInteger k = kRepeats.length()>0?Integer.parseInt(kRepeats.toString()):1;\\n\\t\\t\\tStringBuilder charsToPush = new StringBuilder();\\n\\t\\t\\tfor(int j=0;j<k;j++) { // build the string to repeat k times\\n\\t\\t\\t\\tcharsToPush.append(sbCharsToRepeat);\\n\\t\\t\\t}\\n\\t\\t\\tstack.push(charsToPush.toString()); // push back the repeated string into the stack\\n\\t\\t} else {\\n\\t\\t\\tstack.push(\"\"+c); // push the characters until you find a ]\\n\\t\\t}\\n\\t}\\n\\twhile(!stack.isEmpty()) { // build the final string\\n\\t\\tsb.insert(0, stack.pop());\\n\\t}\\n\\treturn sb.toString();\\n}\\n```\\n\\nExecution stacks examples:\\n```\\nInput String: 3[a]2[bc]\\n\\nStack steps:\\n[3]\\n[[, 3]\\n[a, [, 3]\\n[aaa]\\n[2, aaa]\\n[[, 2, aaa]\\n[b, [, 2, aaa]\\n[c, b, [, 2, aaa]\\n[bcbc, aaa]\\n\\nOutput String: aaabcbc\\n\\n```\\n\\n```\\nInput String: 3[a2[c]]\\n\\nStack steps:\\n[3]\\n[[, 3]\\n[a, [, 3]\\n[2, a, [, 3]\\n[[, 2, a, [, 3]\\n[c, [, 2, a, [, 3]\\n[cc, a, [, 3]\\n[accaccacc]\\n\\nOutput String: accaccacc\\n```\\n\\n```\\nInput String: 2[abc]3[cd]ef\\n\\nStack steps:\\n[2]\\n[[, 2]\\n[a, [, 2]\\n[b, a, [, 2]\\n[c, b, a, [, 2]\\n[abcabc]\\n[3, abcabc]\\n[[, 3, abcabc]\\n[c, [, 3, abcabc]\\n[d, c, [, 3, abcabc]\\n[cdcdcd, abcabc]\\n[e, cdcdcd, abcabc]\\n[f, e, cdcdcd, abcabc]\\n\\nOutput String: abcabccdcdcdef\\n```\\n\\n```\\nInput String: 2[2[ab]]\\n\\nStack steps:\\n[2]\\n[[, 2]\\n[2, [, 2]\\n[[, 2, [, 2]\\n[a, [, 2, [, 2]\\n[b, a, [, 2, [, 2]\\n[abab, [, 2]\\n[abababab]\\n\\nOutput String: abababab\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\npublic String decodeString(String s) {\\n\\tif(s==null || s.isEmpty()) return \"\";\\n\\tStringBuilder sb = new StringBuilder();\\n\\tchar[] charsS = s.toCharArray();\\n\\tDeque<String> stack = new ArrayDeque<>();\\n\\tfor(int i=0;i<charsS.length;i++) {\\n\\t\\tchar c = charsS[i];\\n\\t\\tif(c==']') { // if char is ], pop out the string to repeat and the repeat number\\n\\t\\t\\tStringBuilder sbCharsToRepeat = new StringBuilder();\\n\\t\\t\\twhile(!stack.isEmpty() && Character.isLetter(stack.peek().charAt(0))) { // build the string to repeat\\n\\t\\t\\t\\tsbCharsToRepeat.insert(0,stack.pop());\\n\\t\\t\\t}\\n\\t\\t\\tif(\"[\".equals(stack.peek())) stack.pop(); // pop out the [ char next to the repeat number\\n\\t\\t\\tStringBuilder kRepeats = new StringBuilder();\\n\\t\\t\\twhile(!stack.isEmpty() && Character.isDigit(stack.peek().charAt(0))) { // build the repeat number\\n\\t\\t\\t\\tkRepeats.insert(0,stack.pop());\\n\\t\\t\\t}\\n\\t\\t\\tInteger k = kRepeats.length()>0?Integer.parseInt(kRepeats.toString()):1;\\n\\t\\t\\tStringBuilder charsToPush = new StringBuilder();\\n\\t\\t\\tfor(int j=0;j<k;j++) { // build the string to repeat k times\\n\\t\\t\\t\\tcharsToPush.append(sbCharsToRepeat);\\n\\t\\t\\t}\\n\\t\\t\\tstack.push(charsToPush.toString()); // push back the repeated string into the stack\\n\\t\\t} else {\\n\\t\\t\\tstack.push(\"\"+c); // push the characters until you find a ]\\n\\t\\t}\\n\\t}\\n\\twhile(!stack.isEmpty()) { // build the final string\\n\\t\\tsb.insert(0, stack.pop());\\n\\t}\\n\\treturn sb.toString();\\n}\\n```\n```\\nInput String: 3[a]2[bc]\\n\\nStack steps:\\n[3]\\n[[, 3]\\n[a, [, 3]\\n[aaa]\\n[2, aaa]\\n[[, 2, aaa]\\n[b, [, 2, aaa]\\n[c, b, [, 2, aaa]\\n[bcbc, aaa]\\n\\nOutput String: aaabcbc\\n\\n```\n```\\nInput String: 3[a2[c]]\\n\\nStack steps:\\n[3]\\n[[, 3]\\n[a, [, 3]\\n[2, a, [, 3]\\n[[, 2, a, [, 3]\\n[c, [, 2, a, [, 3]\\n[cc, a, [, 3]\\n[accaccacc]\\n\\nOutput String: accaccacc\\n```\n```\\nInput String: 2[abc]3[cd]ef\\n\\nStack steps:\\n[2]\\n[[, 2]\\n[a, [, 2]\\n[b, a, [, 2]\\n[c, b, a, [, 2]\\n[abcabc]\\n[3, abcabc]\\n[[, 3, abcabc]\\n[c, [, 3, abcabc]\\n[d, c, [, 3, abcabc]\\n[cdcdcd, abcabc]\\n[e, cdcdcd, abcabc]\\n[f, e, cdcdcd, abcabc]\\n\\nOutput String: abcabccdcdcdef\\n```\n```\\nInput String: 2[2[ab]]\\n\\nStack steps:\\n[2]\\n[[, 2]\\n[2, [, 2]\\n[[, 2, [, 2]\\n[a, [, 2, [, 2]\\n[b, a, [, 2, [, 2]\\n[abab, [, 2]\\n[abababab]\\n\\nOutput String: abababab\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1635242,
                "title": "c-easy-to-solve-beginner-friendly-with-detailed-explanations-and-comments",
                "content": "**Intuition:-**\\nAfter reading the question let\\'s track some general terms like what type of observation will lead us to problem solving. In the question they told us about the repeatation and to show that there will be numbers outside the square brackets `[...]`. So we need to use this information of square brackets . Let\\'s see how :\\n* Before opening parenthesis we will get the number that we will be using for repeatations of our string .\\n* when we get our closing parenthesis we will go back to our string letters to repeat them the number of times the number and replace the originial part of that string and place `i` after that to continue .\\n\\n**Algorithm:-**\\n1. Let\\'s first initialize some variables and functions `string repeat()`->our helper function to repeat our substring that many number of times , `s`->our final decoded string , `repeatLetters`->This are the letters that should be repeated , `repeatTimes`->Number of times the letters should be repeated .\\n2. Let\\'s create a helper function which repeates the substring that many number of times the logic is quiet simple\\n3. After the first `[` parenthesis we need to extract those letters to repeate that many times\\n4. After getting the decode part we will just replace the original encoded string with our repeated decoded string by the `s.replace() built in method in c++`\\n\\n**Code:-**\\n```\\n//Comment and Upvote\\n\\nclass Solution {\\npublic:\\n    //Function to help repeat the substring a number of times\\n    string repeat(string str,int times){\\n        string result=\"\";\\n        for(int i=0;i<times;i++) result += str;\\n        return result;\\n    }\\n    string decodeString(string s) {\\n        int i=0;\\n        while(i<s.size()){\\n            if(s[i]!=\\']\\'){\\n                i++;\\n                continue;\\n            }\\n            //The string that needs to get repeated after the first parenthesis \\'[\\'\\n            int j=i;\\n            while(s[j]!=\\'[\\') j--;\\n            //The letters that we will be repeating\\n            string repeatLetters = s.substr(j+1,i-j-1);\\n            int k=j;\\n            j--;\\n            //checking the number before opening the parenthesis so we can get a count that how many times we need to repeat the strin\\n            while((j>0) && (isdigit(s[j])))\\n                j--;\\n            \\n            //Corner case : When we r at the start of our string\\n            if(j!=0) j++;\\n            //Find the number of times the letter should be repeated\\n            int repeatTimes = stoi(s.substr(j,k-j));\\n            //replace the encoded part of string with decoded part\\n            s.replace(j,i-j+1,repeat(repeatLetters,repeatTimes));\\n            //Putting i in the right place of our string\\n            i=j+repeatLetters.size()*repeatTimes;\\n        }\\n        return s;\\n    }\\n};\\n```\\n\\n\\n**Feel free to comment and Upvote if you liked my post :))**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\n//Comment and Upvote\\n\\nclass Solution {\\npublic:\\n    //Function to help repeat the substring a number of times\\n    string repeat(string str,int times){\\n        string result=\"\";\\n        for(int i=0;i<times;i++) result += str;\\n        return result;\\n    }\\n    string decodeString(string s) {\\n        int i=0;\\n        while(i<s.size()){\\n            if(s[i]!=\\']\\'){\\n                i++;\\n                continue;\\n            }\\n            //The string that needs to get repeated after the first parenthesis \\'[\\'\\n            int j=i;\\n            while(s[j]!=\\'[\\') j--;\\n            //The letters that we will be repeating\\n            string repeatLetters = s.substr(j+1,i-j-1);\\n            int k=j;\\n            j--;\\n            //checking the number before opening the parenthesis so we can get a count that how many times we need to repeat the strin\\n            while((j>0) && (isdigit(s[j])))\\n                j--;\\n            \\n            //Corner case : When we r at the start of our string\\n            if(j!=0) j++;\\n            //Find the number of times the letter should be repeated\\n            int repeatTimes = stoi(s.substr(j,k-j));\\n            //replace the encoded part of string with decoded part\\n            s.replace(j,i-j+1,repeat(repeatLetters,repeatTimes));\\n            //Putting i in the right place of our string\\n            i=j+repeatLetters.size()*repeatTimes;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 782552,
                "title": "swift-solution-clean-concise",
                "content": "Here is a concise Swift solution. It uses a `switch` statement to simplify the logic and it uses an `Array` as a stack to simulate recursion. It\\'s similar to the [most voted answer](https://leetcode.com/problems/decode-string/discuss/87662/Python-solution-using-stack) but using Swift instead of Python. \\n\\n```swift \\nfunc decodeString(_ s: String) -> String {\\n\\tvar stack = [(String, Int)]()\\n\\tvar result = \"\" \\n\\tvar num = 0\\n\\n\\tfor char in s {\\n\\t\\tswitch char {\\n\\t\\tcase \"[\":\\n\\t\\t\\tstack.append((result, num))\\n\\t\\t\\tresult = \"\"\\n\\t\\t\\tnum = 0\\n\\t\\tcase \"]\":\\n\\t\\t\\tlet (prev, num) = stack.removeLast() \\n\\t\\t\\tresult = prev + String(repeating: result, count: num)\\n\\t\\tcase _ where char.isNumber:\\n\\t\\t\\tnum *= 10 \\n\\t\\t\\tnum += Int(String(char))!\\n\\t\\tdefault: \\n\\t\\t\\tresult += String(char)\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "solutionTags": [],
                "code": "```swift \\nfunc decodeString(_ s: String) -> String {\\n\\tvar stack = [(String, Int)]()\\n\\tvar result = \"\" \\n\\tvar num = 0\\n\\n\\tfor char in s {\\n\\t\\tswitch char {\\n\\t\\tcase \"[\":\\n\\t\\t\\tstack.append((result, num))\\n\\t\\t\\tresult = \"\"\\n\\t\\t\\tnum = 0\\n\\t\\tcase \"]\":\\n\\t\\t\\tlet (prev, num) = stack.removeLast() \\n\\t\\t\\tresult = prev + String(repeating: result, count: num)\\n\\t\\tcase _ where char.isNumber:\\n\\t\\t\\tnum *= 10 \\n\\t\\t\\tnum += Int(String(char))!\\n\\t\\tdefault: \\n\\t\\t\\tresult += String(char)\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 87576,
                "title": "no-stack-o-n-recursive-solution-in-python",
                "content": "```\\ndef helper(s):\\n    res = \"\"\\n    while s:\\n        num = \"\"\\n        while s and s[-1] in '0123456789':\\n            num += s.pop()\\n        if num:\\n            num = int(num)\\n            s.pop()\\n            res += helper(s) * num\\n        else:\\n            c = s.pop()\\n            if c not in \"[]\":\\n                res += c\\n            if c == ']':\\n                break\\n    return res\\n\\nclass Solution(object):\\n    def decodeString(self, s):\\n        return helper(list(s)[::-1])\\n```",
                "solutionTags": [],
                "code": "```\\ndef helper(s):\\n    res = \"\"\\n    while s:\\n        num = \"\"\\n        while s and s[-1] in '0123456789':\\n            num += s.pop()\\n        if num:\\n            num = int(num)\\n            s.pop()\\n            res += helper(s) * num\\n        else:\\n            c = s.pop()\\n            if c not in \"[]\":\\n                res += c\\n            if c == ']':\\n                break\\n    return res\\n\\nclass Solution(object):\\n    def decodeString(self, s):\\n        return helper(list(s)[::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635424,
                "title": "easy-c-solution-with-explanation",
                "content": "```\\n    string decodeString(string s)\\n    {\\n        int n=s.length();\\n        stack<char>st;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]!=\\']\\')\\n                st.push(s[i]);\\n            else\\n            {\\n                string ss=\"\";\\n                while(!st.empty() && st.top()!=\\'[\\')\\n                {\\n                    ss=st.top()+ss;\\n                    st.pop();\\n                }\\n            \\n                st.pop();\\n            \\n                string number=\"\";\\n                while(!st.empty() && isdigit(st.top()))\\n                {\\n                   number=st.top()+number;\\n                   st.pop();\\n                }\\n            \\n                int k=stoi(number);\\n            \\n                while(k--)\\n                {\\n                   for(int j=0;j<ss.length();j++)\\n                       st.push(ss[j]);\\n                }\\n           }\\n        }\\n        \\n        string ans=\"\";\\n        while(!st.empty())\\n        {\\n            ans=st.top()+ans;\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n/*\\nLogic\\n\\nFirst make a char stack.\\nTraverse the string.\\nIf the char is not a ] \\n    push it into the stack.\\nElse \\n    store all elements of the stack in a string in reverse fashion until we encounter a [.\\n    pop the top element of stack as it it [.\\n    After that create a number string and store the frequency in reverse fashion. We use while here and not if because we can also have 2 digit or 3 digit number as frequency. Keep popping from stack.\\n    Then convert that number string into int k.\\n    now use a while loop until k>0 and store each char of string k number of times.\\n    \\nNow traverse through the stack and store all the characters in reverse order until stack becomes empty.\\nFinally, return ans.\\n\\n*/",
                "solutionTags": [
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\n    string decodeString(string s)\\n    {\\n        int n=s.length();\\n        stack<char>st;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]!=\\']\\')\\n                st.push(s[i]);\\n            else\\n            {\\n                string ss=\"\";\\n                while(!st.empty() && st.top()!=\\'[\\')\\n                {\\n                    ss=st.top()+ss;\\n                    st.pop();\\n                }\\n            \\n                st.pop();\\n            \\n                string number=\"\";\\n                while(!st.empty() && isdigit(st.top()))\\n                {\\n                   number=st.top()+number;\\n                   st.pop();\\n                }\\n            \\n                int k=stoi(number);\\n            \\n                while(k--)\\n                {\\n                   for(int j=0;j<ss.length();j++)\\n                       st.push(ss[j]);\\n                }\\n           }\\n        }\\n        \\n        string ans=\"\";\\n        while(!st.empty())\\n        {\\n            ans=st.top()+ans;\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n/*\\nLogic\\n\\nFirst make a char stack.\\nTraverse the string.\\nIf the char is not a ] \\n    push it into the stack.\\nElse \\n    store all elements of the stack in a string in reverse fashion until we encounter a [.\\n    pop the top element of stack as it it [.\\n    After that create a number string and store the frequency in reverse fashion. We use while here and not if because we can also have 2 digit or 3 digit number as frequency. Keep popping from stack.\\n    Then convert that number string into int k.\\n    now use a while loop until k>0 and store each char of string k number of times.\\n    \\nNow traverse through the stack and store all the characters in reverse order until stack becomes empty.\\nFinally, return ans.\\n\\n*/",
                "codeTag": "Unknown"
            },
            {
                "id": 975185,
                "title": "decode-string-with-regex",
                "content": "Another alternative could be using regular expression. (**[Try it on Regex101](https://regex101.com/r/7leAKA/1)**)\\n`const regex = /(\\\\d+)\\\\[([A-Za-z]+)\\\\]/g;`\\n\\nThe above regex will find a string pattern which match `number[letter]` like `3[a]`, `2[bc]`, etc.\\nFor example, if full match the string part of `2[bc]`.\\n* The *1<sup>st</sup> Capturing Group* (**number**) is `2`\\n* The *2<sup>nd</sup> Capturing Group* (**letter**) is `bc`\\n\\n\\nThen, replace it with letter repeated number of times by using `letter.repeat(number)`. And now you can get the decode string of `bcbc`.\\n\\nThis is how I\\'m trying to do it:\\n\\n```\\nvar decodeString = function (s) {\\n  const regex = /(\\\\d+)\\\\[([A-Za-z]+)\\\\]/g;\\n\\n  function replacer(match, number, letter) {\\n    return letter.repeat(number);\\n  }\\n\\n  while (s.includes(\\'[\\')) {\\n    s = s.replace(regex, replacer);\\n  }\\n  return s;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar decodeString = function (s) {\\n  const regex = /(\\\\d+)\\\\[([A-Za-z]+)\\\\]/g;\\n\\n  function replacer(match, number, letter) {\\n    return letter.repeat(number);\\n  }\\n\\n  while (s.includes(\\'[\\')) {\\n    s = s.replace(regex, replacer);\\n  }\\n  return s;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1634874,
                "title": "java-dfs-0ms-easy-understanding",
                "content": "The idea is: for the string in [ ] pair, we can recurse it as the source string. The codes go into the lower level at \\'[\\', and back to parent at \\']\\'.\\nThe int pos is a globle parameter to indicate the current index of char in the String s.\\n```\\n\\tprivate int pos = 0;\\n    public String decodeString(String s) {\\n    \\tint n = s.length(), repeat = 0;\\n    \\tStringBuilder buf = new StringBuilder();\\n    \\twhile (pos < n) {\\n    \\t\\tchar c = s.charAt(pos);\\n    \\t\\tif (c >= \\'a\\' && c <= \\'z\\') {\\n    \\t\\t\\tbuf.append(c);\\n    \\t\\t} else if (c >= \\'0\\' && c <= \\'9\\') {\\n    \\t\\t\\trepeat = repeat * 10 + (c - \\'0\\');\\n    \\t\\t} else if (c == \\'[\\') {\\n    \\t\\t\\tpos++;  // skip the char \\'[\\'\\n    \\t\\t\\tString str = decodeString(s);  // pos is diff for each call\\n    \\t\\t\\tfor (int i = 0; i < repeat; i++)\\n   \\t\\t\\t\\t\\tbuf.append(str);\\n    \\t\\t\\trepeat = 0;  // reset the value for the next input\\n    \\t\\t} else if (c == \\']\\')\\n    \\t\\t\\tbreak;\\n    \\t\\tpos++;\\n    \\t}\\n    \\treturn buf.toString();\\n    }\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "The idea is: for the string in [ ] pair, we can recurse it as the source string. The codes go into the lower level at \\'[\\', and back to parent at \\']\\'.\\nThe int pos is a globle parameter to indicate the current index of char in the String s.\\n```\\n\\tprivate int pos = 0;\\n    public String decodeString(String s) {\\n    \\tint n = s.length(), repeat = 0;\\n    \\tStringBuilder buf = new StringBuilder();\\n    \\twhile (pos < n) {\\n    \\t\\tchar c = s.charAt(pos);\\n    \\t\\tif (c >= \\'a\\' && c <= \\'z\\') {\\n    \\t\\t\\tbuf.append(c);\\n    \\t\\t} else if (c >= \\'0\\' && c <= \\'9\\') {\\n    \\t\\t\\trepeat = repeat * 10 + (c - \\'0\\');\\n    \\t\\t} else if (c == \\'[\\') {\\n    \\t\\t\\tpos++;  // skip the char \\'[\\'\\n    \\t\\t\\tString str = decodeString(s);  // pos is diff for each call\\n    \\t\\t\\tfor (int i = 0; i < repeat; i++)\\n   \\t\\t\\t\\t\\tbuf.append(str);\\n    \\t\\t\\trepeat = 0;  // reset the value for the next input\\n    \\t\\t} else if (c == \\']\\')\\n    \\t\\t\\tbreak;\\n    \\t\\tpos++;\\n    \\t}\\n    \\treturn buf.toString();\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 518155,
                "title": "concise-recursion-in-python-beats-99",
                "content": "\\tclass Solution:\\n\\t\\tdef decodeString(self, s):\\n\\n\\t\\t\\tif not s or len(s) == 0:\\n\\t\\t\\t\\treturn s\\n\\t\\t\\tresult, position = self.dfs(0,s,0,\\'\\')\\n\\t\\t\\treturn result\\n\\n\\t\\tdef dfs(self, position, s, prev_num, prev_str):\\n\\t\\t\\twhile position < len(s):\\n\\t\\t\\t\\twhile s[position].isdigit():\\n\\t\\t\\t\\t\\tprev_num  = prev_num*10 + int(s[position])\\n\\t\\t\\t\\t\\tposition += 1\\n\\n\\t\\t\\t\\tif s[position] == \"[\":\\n\\t\\t\\t\\t\\t#reset the prev_str\\n\\t\\t\\t\\t\\treturned_str, ending_pos = self.dfs(position+1, s, prev_num=0, prev_str=\"\")\\n\\t\\t\\t\\t\\t#backtrack\\n\\t\\t\\t\\t\\tprev_str = prev_str + returned_str*prev_num\\n\\t\\t\\t\\t\\tposition = ending_pos\\n\\t\\t\\t\\t\\tprev_num = 0\\n\\t\\t\\t\\t#return the result\\n\\t\\t\\t\\telif s[position] == \\']\\':\\n\\t\\t\\t\\t\\treturn prev_str, position\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tprev_str += s[position]\\n\\t\\t\\t\\tposition += 1\\n\\t\\t\\treturn prev_str, position",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef decodeString(self, s):\\n\\n\\t\\t\\tif not s or len(s) == 0:\\n\\t\\t\\t\\treturn s\\n\\t\\t\\tresult, position = self.dfs(0,s,0,\\'\\')\\n\\t\\t\\treturn result\\n\\n\\t\\tdef dfs(self, position, s, prev_num, prev_str):\\n\\t\\t\\twhile position < len(s):\\n\\t\\t\\t\\twhile s[position].isdigit():\\n\\t\\t\\t\\t\\tprev_num  = prev_num*10 + int(s[position])\\n\\t\\t\\t\\t\\tposition += 1\\n\\n\\t\\t\\t\\tif s[position] == \"[\":\\n\\t\\t\\t\\t\\t#reset the prev_str\\n\\t\\t\\t\\t\\treturned_str, ending_pos = self.dfs(position+1, s, prev_num=0, prev_str=\"\")\\n\\t\\t\\t\\t\\t#backtrack\\n\\t\\t\\t\\t\\tprev_str = prev_str + returned_str*prev_num\\n\\t\\t\\t\\t\\tposition = ending_pos\\n\\t\\t\\t\\t\\tprev_num = 0\\n\\t\\t\\t\\t#return the result\\n\\t\\t\\t\\telif s[position] == \\']\\':\\n\\t\\t\\t\\t\\treturn prev_str, position\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tprev_str += s[position]\\n\\t\\t\\t\\tposition += 1\\n\\t\\t\\treturn prev_str, position",
                "codeTag": "Java"
            },
            {
                "id": 1031958,
                "title": "java-recursive-0ms-100-with-explanation-o-n-solution",
                "content": "```\\npublic String decodeString(String s) {\\n        int[] i = {0}; // maintains the index we\\'re at through out the recursion. \\n        return decode(s, i);\\n    }\\n    \\n    public String decode(String s, int[] i){\\n        StringBuilder sb = new StringBuilder();\\n        int num = 0;\\n        \\n        while(i[0] < s.length()){\\n            char ch = s.charAt(i[0]);\\n            i[0]++; \\n            \\n            if(Character.isDigit(ch)){\\n                num = num * 10+ (ch -\\'0\\'); // if curr char is a number, store it\\n            }\\n            else if(ch == \\'[\\'){\\n                String innerStr = decode(s, i); // start recursion to solve sub problem. Returns the string between [ and ].\\n                while(num != 0){ \\n                    sb.append(innerStr); // multiply returned string with the num. \\n                    num--; // num resets to 0.\\n                }\\n            }\\n            else if(ch == \\']\\'){ // At this point, we\\'re finishing up a recursive call. \\n                break;  // break from the sub call and return innerString.\\n            }\\n            else{\\n                sb.append(ch); // appends any extra characters that do not need multiplying Ex: abc2[a], a2[b]a\\n            }\\n        }\\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\npublic String decodeString(String s) {\\n        int[] i = {0}; // maintains the index we\\'re at through out the recursion. \\n        return decode(s, i);\\n    }\\n    \\n    public String decode(String s, int[] i){\\n        StringBuilder sb = new StringBuilder();\\n        int num = 0;\\n        \\n        while(i[0] < s.length()){\\n            char ch = s.charAt(i[0]);\\n            i[0]++; \\n            \\n            if(Character.isDigit(ch)){\\n                num = num * 10+ (ch -\\'0\\'); // if curr char is a number, store it\\n            }\\n            else if(ch == \\'[\\'){\\n                String innerStr = decode(s, i); // start recursion to solve sub problem. Returns the string between [ and ].\\n                while(num != 0){ \\n                    sb.append(innerStr); // multiply returned string with the num. \\n                    num--; // num resets to 0.\\n                }\\n            }\\n            else if(ch == \\']\\'){ // At this point, we\\'re finishing up a recursive call. \\n                break;  // break from the sub call and return innerString.\\n            }\\n            else{\\n                sb.append(ch); // appends any extra characters that do not need multiplying Ex: abc2[a], a2[b]a\\n            }\\n        }\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 941382,
                "title": "python-dfs-with-comments",
                "content": "Here we need to evaluate the expression in the deepest levels first, so it is a depth-first search question. \\n\\nYou need to be aware of a **trick applied in paranthesis questions** here: As you notice, to apply DFS you need to find the end-point of each bracket opened. The idea is to use a variable called `bal` (balance) which is initially set to `1`. You increment `bal` for each `[` and decrement for each `]`. When `bal=0` you have reached the corresponding `]` for the initial `[`. This way you can segment the string, and carrying out the rest of recursion is straightforward. Not the easiest recursion question, though.\\n\\n``` python\\nclass Solution:\\n    def decodeString(self, s):\\n        def recur(s):\\n            ans = \\'\\' #answer from this step of recursion\\n            i = 0 #index of input string s\\n            num = \\'\\' #repetition number if any character is repeated\\n            while i<len(s):\\n                x = s[i]\\n                if x.isnumeric(): #we get a digit, append it to num\\n                    num += x\\n                elif x==\\'[\\': #we are opening a bracket\\n                    #now find j and i such that s[j:i] is the string inside the bracket\\n                    bal = 1 \\n                    j = i+1\\n                    while bal:\\n                        i += 1\\n                        if s[i]==\\'[\\': bal += 1\\n                        if s[i]==\\']\\': bal -= 1\\n                    #we add num*s[j:i]\\n                    #but we apply the function recursively in case there is a nested bracket\\n                    ans += int(float(num))*recur(s[j:i]) \\n                    num = \\'\\' #reset num\\n                else: #we get a regular character, just append it\\n                    ans += x\\n                i += 1 #increment counter\\n            return ans\\n        \\n        return recur(s)\\n```",
                "solutionTags": [],
                "code": "``` python\\nclass Solution:\\n    def decodeString(self, s):\\n        def recur(s):\\n            ans = \\'\\' #answer from this step of recursion\\n            i = 0 #index of input string s\\n            num = \\'\\' #repetition number if any character is repeated\\n            while i<len(s):\\n                x = s[i]\\n                if x.isnumeric(): #we get a digit, append it to num\\n                    num += x\\n                elif x==\\'[\\': #we are opening a bracket\\n                    #now find j and i such that s[j:i] is the string inside the bracket\\n                    bal = 1 \\n                    j = i+1\\n                    while bal:\\n                        i += 1\\n                        if s[i]==\\'[\\': bal += 1\\n                        if s[i]==\\']\\': bal -= 1\\n                    #we add num*s[j:i]\\n                    #but we apply the function recursively in case there is a nested bracket\\n                    ans += int(float(num))*recur(s[j:i]) \\n                    num = \\'\\' #reset num\\n                else: #we get a regular character, just append it\\n                    ans += x\\n                i += 1 #increment counter\\n            return ans\\n        \\n        return recur(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680089,
                "title": "beginner-friendly-solution-using-stacks-most-efficient",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIdea here is to use a stack.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe initialize an empty stack to store characters.\\n\\nWe iterate through each character in the given string.\\n\\nIf the current character is not \\']\\', we push it onto the stack.\\n\\nIf the current character is \\']\\', we start the decoding process:\\n-->We pop characters from the stack until we encounter a \\'[\\'. These characters represent a substring that needs to be repeated.\\n-->After popping the substring, we pop the next characters from the stack until we reach a digit. These characters represent the number that specifies the repetition count.\\n-->We reverse the extracted number and convert it to an integer.\\n-->We multiply the substring by the repetition count and push the result back onto the stack.\\n\\nOnce we have processed all the characters in the input string, we join the remaining characters in the stack to obtain the final decoded string. Since the characters were pushed onto the stack in reverse order, we reverse each substring before joining them to maintain the original order.\\n\\n![Stack img.jpeg](https://assets.leetcode.com/users/images/58154099-73ae-48d3-bd1c-ac608d933f89_1687678647.316495.jpeg)\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n\\n        stack=[]\\n\\n        for c in s:\\n            if c!=\\']\\':\\n                stack.append(c)\\n            else:\\n                res=\\'\\'\\n                while stack[-1]!=\\'[\\':\\n                    res+=stack.pop()\\n                stack.pop()\\n                n=\\'\\'\\n                while len(stack)!=0 and stack[-1].isdigit()==True:\\n                    n+=stack.pop()\\n                stack.append(res*int(n[::-1]))\\n\\n        return \\'\\'.join([word[::-1] for word in stack])\\n\\n\\n    \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n\\n        stack=[]\\n\\n        for c in s:\\n            if c!=\\']\\':\\n                stack.append(c)\\n            else:\\n                res=\\'\\'\\n                while stack[-1]!=\\'[\\':\\n                    res+=stack.pop()\\n                stack.pop()\\n                n=\\'\\'\\n                while len(stack)!=0 and stack[-1].isdigit()==True:\\n                    n+=stack.pop()\\n                stack.append(res*int(n[::-1]))\\n\\n        return \\'\\'.join([word[::-1] for word in stack])\\n\\n\\n    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448843,
                "title": "python-simple-clean-code-easy-sol-using-stack",
                "content": "- One of the Best problems to learn how to use stack.\\n# Code\\n```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        st = []\\n        num = 0\\n        res = \\'\\'\\n\\n        for ch in s:\\n            if ch.isnumeric():\\n                num = num * 10 + int(ch)\\n            elif ch == \\'[\\':\\n                st.append(res)\\n                st.append(num)\\n                res = \\'\\'\\n                num = 0\\n            elif ch == \\']\\':\\n                cnt = st.pop()\\n                prev = st.pop()\\n                res = prev + cnt * res\\n            else:\\n                res += ch\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        st = []\\n        num = 0\\n        res = \\'\\'\\n\\n        for ch in s:\\n            if ch.isnumeric():\\n                num = num * 10 + int(ch)\\n            elif ch == \\'[\\':\\n                st.append(res)\\n                st.append(num)\\n                res = \\'\\'\\n                num = 0\\n            elif ch == \\']\\':\\n                cnt = st.pop()\\n                prev = st.pop()\\n                res = prev + cnt * res\\n            else:\\n                res += ch\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941345,
                "title": "python-o-n-by-stack-w-comment",
                "content": "Python O(n) by stack \\n\\n---\\n\\n**Implementation** by stack:\\n\\n```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        \\n\\t\\t# record of tuple ( previous token, repeat times of current token)\\n        stack = []\\n        \\n        cur_token, cur_number =  \\'\\', 0\\n        \\n        for char in s:\\n            \\n            if char == \\'[\\':\\n                # meet start symbol \\'[\\'\\n                # save current token and current number into stack\\n                stack.append( (cur_token, cur_number) )\\n                \\n                # clear cur_token for new symbol in [ ]\\n                cur_token = \\'\\'\\n                \\n                # clear cur_number for new number in [ ]\\n                cur_number = 0\\n                \\n            elif char == \\']\\':\\n                # meet ending symbol \\']\\'\\n                # pop previous token and repeat times of current token from stack\\n                prev_token, repeat_times = stack.pop()\\n                \\n                # update current token with specified repeat times\\n                cur_token = prev_token + cur_token * repeat_times\\n                \\n            elif char.isdigit():\\n            \\n                # update current number\\n                cur_number = cur_number*10 + int(char)\\n            \\n            else:\\n                \\n                # update current token\\n                cur_token += char\\n                \\n                \\n        return cur_token\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        \\n\\t\\t# record of tuple ( previous token, repeat times of current token)\\n        stack = []\\n        \\n        cur_token, cur_number =  \\'\\', 0\\n        \\n        for char in s:\\n            \\n            if char == \\'[\\':\\n                # meet start symbol \\'[\\'\\n                # save current token and current number into stack\\n                stack.append( (cur_token, cur_number) )\\n                \\n                # clear cur_token for new symbol in [ ]\\n                cur_token = \\'\\'\\n                \\n                # clear cur_number for new number in [ ]\\n                cur_number = 0\\n                \\n            elif char == \\']\\':\\n                # meet ending symbol \\']\\'\\n                # pop previous token and repeat times of current token from stack\\n                prev_token, repeat_times = stack.pop()\\n                \\n                # update current token with specified repeat times\\n                cur_token = prev_token + cur_token * repeat_times\\n                \\n            elif char.isdigit():\\n            \\n                # update current number\\n                cur_number = cur_number*10 + int(char)\\n            \\n            else:\\n                \\n                # update current token\\n                cur_token += char\\n                \\n                \\n        return cur_token\\n```",
                "codeTag": "Java"
            },
            {
                "id": 699980,
                "title": "python-simple-solution-using-2-stacks",
                "content": "```\\nclass Solution:\\n    def decodeString(self, string: str) -> str:\\n        ## RC ##        \\n        ## APPROACH : 2 Stacks ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n\\n        nums = []\\n        strs = []\\n        num = \"\"\\n        s = \"\"\\n        for i, ch in enumerate(string):\\n            if ch.isdigit():\\n                num += ch\\n            elif ch == \"[\":\\n                nums.append(int(num))\\n                strs.append(s)\\n                num = \"\"\\n                s = \"\"\\n            elif ch == \"]\":\\n                s =  strs.pop() + nums.pop() * s        # watchout, replacing with the same string\\n            else:\\n                s += ch\\n        return s\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeString(self, string: str) -> str:\\n        ## RC ##        \\n        ## APPROACH : 2 Stacks ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n\\n        nums = []\\n        strs = []\\n        num = \"\"\\n        s = \"\"\\n        for i, ch in enumerate(string):\\n            if ch.isdigit():\\n                num += ch\\n            elif ch == \"[\":\\n                nums.append(int(num))\\n                strs.append(s)\\n                num = \"\"\\n                s = \"\"\\n            elif ch == \"]\":\\n                s =  strs.pop() + nums.pop() * s        # watchout, replacing with the same string\\n            else:\\n                s += ch\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 208633,
                "title": "dfs-simple-python",
                "content": "```py\\n\\'\\'\\'\\ndfs post-order, make sure recurisve calls refer the same i, same s \\n\\'\\'\\'\\nclass Solution:\\n    def __init__(self):\\n        self.i = 0\\n        \\n    def decodeString(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        return self.dfs(list(s))\\n    \\n    def dfs(self, s):\\n        r = []\\n        \\n        while self.i < len(s): \\n            if s[self.i] == \\']\\':\\n                self.i +=1 \\n                return \\'\\'.join(r)\\n            \\n            elif s[self.i] == \\'[\\':\\n                self.i += 1 \\n                sub = self.dfs(s) \\n                r.append(sub * n)\\n            \\n            elif s[self.i].isdigit():\\n                n = 0 \\n                while self.i < len(s) and s[self.i].isdigit():\\n                    n = n * 10 + int(s[self.i]) \\n                    self.i += 1\\n                    \\n            else:\\n                r.append(s[self.i]);\\n                self.i += 1 \\n        \\n        return \\'\\'.join(r)\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n\\'\\'\\'\\ndfs post-order, make sure recurisve calls refer the same i, same s \\n\\'\\'\\'\\nclass Solution:\\n    def __init__(self):\\n        self.i = 0\\n        \\n    def decodeString(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        return self.dfs(list(s))\\n    \\n    def dfs(self, s):\\n        r = []\\n        \\n        while self.i < len(s): \\n            if s[self.i] == \\']\\':\\n                self.i +=1 \\n                return \\'\\'.join(r)\\n            \\n            elif s[self.i] == \\'[\\':\\n                self.i += 1 \\n                sub = self.dfs(s) \\n                r.append(sub * n)\\n            \\n            elif s[self.i].isdigit():\\n                n = 0 \\n                while self.i < len(s) and s[self.i].isdigit():\\n                    n = n * 10 + int(s[self.i]) \\n                    self.i += 1\\n                    \\n            else:\\n                r.append(s[self.i]);\\n                self.i += 1 \\n        \\n        return \\'\\'.join(r)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1559008,
                "title": "c-solution-0ms-using-stacks-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        string ans=\"\";\\n        int num=0;\\n        stack<pair<string,int>>stk;//Stack to store the string between [] and the number of times it needs to be generated\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(isdigit(s[i]))\\n                num=(num*10)+(s[i]-48);//Since the number can be 2 digit or more we are generating the number\\n           else if(isalpha(s[i]))//IF given character is al[habet we build the string\\n                ans+=s[i];\\n           else if(s[i]==\\'[\\')//The moment the first [ is encountered we push the substring and the number generated to the stack\\n            {\\n                stk.push({ans,num});\\n                ans=\"\";// making the substring variable blank and number zero to prepare it for the next iteration\\n                    num=0;\\n            }\\n            else if(s[i]==\\']\\')//As a ] is encountered we generate the given substring according to \\'k\\' times given on stack top.We add the string at stack top and generated string so that it may be processed again if required\\n            {\\n                string tmp=ans;\\n                for(int i=1;i<stk.top().second;i++)                \\n                   tmp+=ans;\\n                ans=stk.top().first+tmp;\\n                stk.pop();\\n                \\n            }\\n                \\n        }\\n     \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        string ans=\"\";\\n        int num=0;\\n        stack<pair<string,int>>stk;//Stack to store the string between [] and the number of times it needs to be generated\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(isdigit(s[i]))\\n                num=(num*10)+(s[i]-48);//Since the number can be 2 digit or more we are generating the number\\n           else if(isalpha(s[i]))//IF given character is al[habet we build the string\\n                ans+=s[i];\\n           else if(s[i]==\\'[\\')//The moment the first [ is encountered we push the substring and the number generated to the stack\\n            {\\n                stk.push({ans,num});\\n                ans=\"\";// making the substring variable blank and number zero to prepare it for the next iteration\\n                    num=0;\\n            }\\n            else if(s[i]==\\']\\')//As a ] is encountered we generate the given substring according to \\'k\\' times given on stack top.We add the string at stack top and generated string so that it may be processed again if required\\n            {\\n                string tmp=ans;\\n                for(int i=1;i<stk.top().second;i++)                \\n                   tmp+=ans;\\n                ans=stk.top().first+tmp;\\n                stk.pop();\\n                \\n            }\\n                \\n        }\\n     \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2985821,
                "title": "parse-with-stack-o-n-faster-than-100-fluent",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\nThe problem can be seen as a stack problem because the ordering of the closed brackets and opening ones is analogous to the `LIFO` princile of stacks. \\r\\n\\r\\n![faster.PNG](https://assets.leetcode.com/users/images/48ee7572-1d6f-4ac9-a67d-77522cee5396_1672660823.216575.png)\\r\\n\\r\\n> I know I know LeetCode\\'s Runtime is biased :)\\r\\n\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\nWhenever we find opening brackets(`[`) we append the characters after it and until a digit is found, and the digit before it to the stack. That means as a tuple in Python.\\r\\n\\r\\nWhenever we find closing brackets(`]`) we will pop the last element in the stack. And update our running current string `cur`.\\r\\n\\r\\n> Well, how do we keep track of both the characters in between `[` and `]` and the integer with which we are going to multiply the former with?\\r\\n\\r\\nThat is a good question actually. We will keep checking whether the character at hand is one of the brackets, or whether it is a digit, or it is a lower case English letter.\\r\\n\\r\\n# Complexity\\r\\n- Time complexity: $$O(n)$$\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity: $$O(n)$$\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution:\\r\\n    def decodeString(self, s: str) -> str:\\r\\n        stack = []\\r\\n        cur = \"\"\\r\\n        k = 0\\r\\n        for c in s:\\r\\n            if c == \"[\":\\r\\n                stack.append((cur, k))\\r\\n                cur, k = \"\", 0 # reset global vars\\r\\n            elif c == \"]\":\\r\\n                enc, n = stack.pop()\\r\\n                cur = enc + n * cur \\r\\n            elif c.isdigit():\\r\\n                k = k * 10 + int(c) # for two and three digit numbers\\r\\n            else:\\r\\n                cur += c # track the lower case letters\\r\\n        return cur\\r\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\r\\nclass Solution:\\r\\n    def decodeString(self, s: str) -> str:\\r\\n        stack = []\\r\\n        cur = \"\"\\r\\n        k = 0\\r\\n        for c in s:\\r\\n            if c == \"[\":\\r\\n                stack.append((cur, k))\\r\\n                cur, k = \"\", 0 # reset global vars\\r\\n            elif c == \"]\":\\r\\n                enc, n = stack.pop()\\r\\n                cur = enc + n * cur \\r\\n            elif c.isdigit():\\r\\n                k = k * 10 + int(c) # for two and three digit numbers\\r\\n            else:\\r\\n                cur += c # track the lower case letters\\r\\n        return cur\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 772227,
                "title": "python-solution-using-stack-beats-98-3",
                "content": "```python\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        stack = []\\n        a, d = \\'\\', \\'\\'\\n        for letter in s:\\n            if letter.isdigit():\\n                d+=letter\\n            elif letter.isalpha():\\n                a+=letter\\n            elif letter==\\'[\\':\\n                stack.append((a, int(d)))\\n                a, d = \\'\\', \\'\\'\\n            elif letter==\\']\\':\\n                p, n = stack.pop()\\n                a = p+a*n\\n            \\n        return a\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        stack = []\\n        a, d = \\'\\', \\'\\'\\n        for letter in s:\\n            if letter.isdigit():\\n                d+=letter\\n            elif letter.isalpha():\\n                a+=letter\\n            elif letter==\\'[\\':\\n                stack.append((a, int(d)))\\n                a, d = \\'\\', \\'\\'\\n            elif letter==\\']\\':\\n                p, n = stack.pop()\\n                a = p+a*n\\n            \\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549026,
                "title": "how-to-explain-to-the-interviewer-in-an-interview-394-decode-string",
                "content": "Similar problems:\\n[224. Basic Calculator](https://leetcode.com/problems/basic-calculator/)\\n\\n#### 1. Clarify\\n(1) Is the input \"[abc]\" a valid input? -No, if there is a [], there must be a number in front of it\\n\\n#### 2. Idea\\nThis is a DFS problem, for example s = \"2[ab3[cd4[ef]]5[gh]]\", the tree is\\n<img src=\"https://assets.leetcode.com/users/qy9mg/image_1584966338.png\" width=\"300\">\\nIf a node is a number k, it means its children will be repeated k times. \\nIf a node is a string, it means you can use it directly. \\nIf two nodes are in the same level, that means we need to append the string represented by the next tree to the string represented by the previous tree, for example, string rooted at ab + string rooted at 3 + string rooted at 5\\n\\nif dfs(node) returns the string rooted at node, we should define dfs(node) like this:\\n```\\ndfs(node){\\n\\tStringBuilder sb = new StringBuilder();\\n\\tString children = dfs(child1) + dfs(child2) + dfs(child3) + ...\\n\\tfor(int i = 0; i < node.k; i ++){\\n\\t\\tsb.append(children);\\n\\t}\\n\\treturn sb.toString();\\n}\\n```\\n\\n#### 3. Solution\\n**Solution 1. Recursive** [This solution is from this post](https://leetcode.com/problems/decode-string/discuss/87544/Clean-C%2B%2B-Recursive-Solution-with-Explanation)\\n```\\nclass Solution {\\n    \\n    private int idx;\\n    private String s;\\n\\n    public String decodeString(String s) {\\n        idx = 0;\\n        this.s = s;\\n        return helper();\\n    }\\n\\n    private String helper() {\\n        int num = 0;\\n        String word = \"\";\\n        for(; idx < s.length(); idx++) {\\n            char cur = s.charAt(idx);\\n            if(cur == \\'[\\') {\\n                idx ++;\\n                String curStr = helper();\\n                for(; num > 0; num--) word += curStr;\\n            }\\n            else if (cur >= \\'0\\' && cur <=\\'9\\') {\\n                num = num * 10 + cur - \\'0\\';\\n            }\\n            else if (cur == \\']\\') {\\n                return word;\\n            }\\n            else { \\n                word += cur;\\n            }\\n        }\\n        return word;\\n    }\\n}\\n```\\n\\n-----\\n**Solution 2 Interative**\\nIterative solution explanation:\\nThe way the operation system deals with recursion is, before enter the next level of the recursive method, push the current state into a stack; after the next level of recursive method is done, fetch the state before it\\'s excuted, and do calcuation using the state and the result of the next level of recursive method, for example, the fibonacci series:\\n\\nBefore fibonacci(n - 2) runs, the OS must run fibonacci(n - 1)  and push its result into a stack, after fibonacci(n - 1) is run and get the result, the OS fetch the result of fibonacci(n - 2) and sum up with fibonacci(n - 1) and return.\\n\\n```\\nint fibonacci(n){\\n\\tif(n == 1) return 1;\\n\\tif(n == 2) return 2;\\n\\t\\n\\treturn fibonacci(n - 1) + fibonacci(n - 2);\\n}\\n```\\n\\nIn this problem, as is written in the top, we are using dfs to solve this problem:\\n```\\ndfs(node){\\n\\tStringBuilder sb = new StringBuilder(node.stringBeforeFirstChild);\\n\\tString children = dfs(node.child0) + dfs(node.child1) + dfs(node.child2) + ...\\n\\tfor(int i = 0; i < node.k; i ++){\\n\\t\\tsb.append(children);\\n\\t}\\n\\t\\n\\tsb.append(node.stringAfterLastChild);\\n\\treturn sb.toString();\\n}\\n```\\n\\n(1) When we encounter \\'[\\', it means we are going into the child, so we must push the current state into stacks. The current state includes the number k and the current String we get. Then we must reset the number and the current string because now we are processing the next level.\\n(2) when we encounter \\']\\', it means we finish the current level, now we must fetch the state before we go into this level, append the current level\\'s result after the previous state. \\n\\n```\\nclass Solution {\\n    public String decodeString(String s){\\n        Stack<Integer> counts = new Stack<>();\\n        Stack<String> prefixes = new Stack<>();\\n\\n        int count = 0;\\n        StringBuilder curString = new StringBuilder();\\n\\n        for (char c: s.toCharArray()){\\n            if (Character.isDigit(c)){\\n                count = count * 10 + c - \\'0\\';\\n            }\\n            else if (Character.isLetter(c)){\\n                curString.append(c);\\n            }\\n            else if (c == \\'[\\'){\\n                counts.add(count);\\n                prefixes.add(curString.toString());\\n\\n                count = 0;\\n                curString = new StringBuilder();\\n            }\\n            else {\\n                String temp = curString.toString();\\n                curString = new StringBuilder(prefixes.pop());\\n                int repeatTimes = counts.pop();\\n\\n                for(int i = 0; i < repeatTimes; i ++){\\n                    curString.append(temp);\\n                }\\n            }\\n        }\\n        return curString.toString();\\n    }\\n}\\n```\\n\\n#### 4. Complexity\\nTC: Both solutions are O(n) where n is the length of the string\\nSC: solution 1 is O(1), solution 2 is O(n)\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\ndfs(node){\\n\\tStringBuilder sb = new StringBuilder();\\n\\tString children = dfs(child1) + dfs(child2) + dfs(child3) + ...\\n\\tfor(int i = 0; i < node.k; i ++){\\n\\t\\tsb.append(children);\\n\\t}\\n\\treturn sb.toString();\\n}\\n```\n```\\nclass Solution {\\n    \\n    private int idx;\\n    private String s;\\n\\n    public String decodeString(String s) {\\n        idx = 0;\\n        this.s = s;\\n        return helper();\\n    }\\n\\n    private String helper() {\\n        int num = 0;\\n        String word = \"\";\\n        for(; idx < s.length(); idx++) {\\n            char cur = s.charAt(idx);\\n            if(cur == \\'[\\') {\\n                idx ++;\\n                String curStr = helper();\\n                for(; num > 0; num--) word += curStr;\\n            }\\n            else if (cur >= \\'0\\' && cur <=\\'9\\') {\\n                num = num * 10 + cur - \\'0\\';\\n            }\\n            else if (cur == \\']\\') {\\n                return word;\\n            }\\n            else { \\n                word += cur;\\n            }\\n        }\\n        return word;\\n    }\\n}\\n```\n```\\nint fibonacci(n){\\n\\tif(n == 1) return 1;\\n\\tif(n == 2) return 2;\\n\\t\\n\\treturn fibonacci(n - 1) + fibonacci(n - 2);\\n}\\n```\n```\\ndfs(node){\\n\\tStringBuilder sb = new StringBuilder(node.stringBeforeFirstChild);\\n\\tString children = dfs(node.child0) + dfs(node.child1) + dfs(node.child2) + ...\\n\\tfor(int i = 0; i < node.k; i ++){\\n\\t\\tsb.append(children);\\n\\t}\\n\\t\\n\\tsb.append(node.stringAfterLastChild);\\n\\treturn sb.toString();\\n}\\n```\n```\\nclass Solution {\\n    public String decodeString(String s){\\n        Stack<Integer> counts = new Stack<>();\\n        Stack<String> prefixes = new Stack<>();\\n\\n        int count = 0;\\n        StringBuilder curString = new StringBuilder();\\n\\n        for (char c: s.toCharArray()){\\n            if (Character.isDigit(c)){\\n                count = count * 10 + c - \\'0\\';\\n            }\\n            else if (Character.isLetter(c)){\\n                curString.append(c);\\n            }\\n            else if (c == \\'[\\'){\\n                counts.add(count);\\n                prefixes.add(curString.toString());\\n\\n                count = 0;\\n                curString = new StringBuilder();\\n            }\\n            else {\\n                String temp = curString.toString();\\n                curString = new StringBuilder(prefixes.pop());\\n                int repeatTimes = counts.pop();\\n\\n                for(int i = 0; i < repeatTimes; i ++){\\n                    curString.append(temp);\\n                }\\n            }\\n        }\\n        return curString.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 424563,
                "title": "java-o-n-solution-using-two-stacks-with-easy-explanation-and-comments",
                "content": "Three line explanation for interviews\\n1. Maintain two stacks nums and strings\\n\\t* The number stacks stores number of times a future string ( a string that is in upcoming square brackets) needs to be processed at the top.\\n\\t* The strings stack contains all the past strings have been processed. These past strings needs to be contactenated with future strings to give out the resultant strings\\n\\n\\nTime Complexity: O(n) \\nSpace Complexity: O(n) \\n\\nYou can follow me on https://twitter.com/Jaspind07199761 for DS and Algo tips\\nor connect on https://www.linkedin.com/in/jaspindersingh1/\\n\\n```\\nclass Solution {\\n    public String decodeString(String s) {\\n      Stack <Integer> num = new Stack<>();\\n      Stack <String> str = new Stack<>();\\n      String currStr = \"\";\\n      int currNum = 0;\\n      for(int i = 0; i < s.length(); i++){\\n          char c = s.charAt(i);\\n          if(Character.isDigit(c)){\\n              currNum = currNum * 10 + c - \\'0\\';\\n          } else if (c == \\'[\\'){\\n              // At the starting of square bracket push the past strings in string stack and num for future string in num stack\\n              num.push(currNum);\\n              str.push(currStr);\\n              currNum = 0;\\n              currStr = \"\";\\n          } else if ( c == \\']\\'){\\n              // At end of square bracket process the past string\\n              int times = num.pop();\\n              StringBuilder newStr = new StringBuilder(); // newString = \"\"\\n              for(int j = 0;j < times; j++){\\n                   newStr.append(currStr);\\n              }\\n              currStr = str.pop();\\n              currStr += newStr;\\n          } else {\\n              currStr += c;\\n          }\\n      }\\n        return currStr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String decodeString(String s) {\\n      Stack <Integer> num = new Stack<>();\\n      Stack <String> str = new Stack<>();\\n      String currStr = \"\";\\n      int currNum = 0;\\n      for(int i = 0; i < s.length(); i++){\\n          char c = s.charAt(i);\\n          if(Character.isDigit(c)){\\n              currNum = currNum * 10 + c - \\'0\\';\\n          } else if (c == \\'[\\'){\\n              // At the starting of square bracket push the past strings in string stack and num for future string in num stack\\n              num.push(currNum);\\n              str.push(currStr);\\n              currNum = 0;\\n              currStr = \"\";\\n          } else if ( c == \\']\\'){\\n              // At end of square bracket process the past string\\n              int times = num.pop();\\n              StringBuilder newStr = new StringBuilder(); // newString = \"\"\\n              for(int j = 0;j < times; j++){\\n                   newStr.append(currStr);\\n              }\\n              currStr = str.pop();\\n              currStr += newStr;\\n          } else {\\n              currStr += c;\\n          }\\n      }\\n        return currStr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924309,
                "title": "easy-solution-using-stack-c-tc-beats-100-mem-beats-90-72",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize an empty string `ans` to store the decoded result.\\n2. Initialize a variable `num` to keep track of the current number being built.\\n3. Iterate through each character `s[i]` in the input string:\\n   - If `s[i]` is a digit, update the `num` accordingly.\\n   - If `s[i]` is an opening bracket `[`, push the current `ans` to the `str` stack, reset `ans` to an empty string, and push `num` to the `count` stack. Reset `num` to 0.\\n   - If `s[i]` is a closing bracket `]`, pop the top string from the `str` stack into `temp`, pop the top count from the `count` stack into `times`, and append `times` copies of `temp` to the current `ans`.\\n   - Otherwise, if `s[i]` is an alphabet character, add it to the current `ans`.\\n4. After iterating through all characters, the `ans` will contain the decoded string.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n![image.png](https://assets.leetcode.com/users/images/15cb1e2c-a86c-4a14-9a11-a1f6d7d0dc7a_1692303892.3943768.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<string>str;\\n        stack<int>count;\\n        string ans=\"\";\\n        int num=0;\\n        for (int i=0;i<s.size();i++){\\n           if (s[i]>=\\'0\\' && s[i]<=\\'9\\'){ \\n               num=10*num+s[i]-\\'0\\';\\n           }\\n           else if (s[i]==\\'[\\') {//reset\\n                str.push(ans);\\n                ans=\"\";\\n                count.push(num);\\n                num=0;\\n           }\\n           else if(s[i]==\\']\\'){ //add the num times to the ans\\n               string temp=ans;\\n               ans=str.top();\\n               str.pop();\\n               int times=count.top();\\n               count.pop();\\n               while (times--){\\n                   ans+=temp;\\n               }\\n           }\\n           else { // for char \\n               ans+=s[i];\\n           }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```\\nIf it\\'s helpfull , then please upvote \\u2B06\\uFE0F",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<string>str;\\n        stack<int>count;\\n        string ans=\"\";\\n        int num=0;\\n        for (int i=0;i<s.size();i++){\\n           if (s[i]>=\\'0\\' && s[i]<=\\'9\\'){ \\n               num=10*num+s[i]-\\'0\\';\\n           }\\n           else if (s[i]==\\'[\\') {//reset\\n                str.push(ans);\\n                ans=\"\";\\n                count.push(num);\\n                num=0;\\n           }\\n           else if(s[i]==\\']\\'){ //add the num times to the ans\\n               string temp=ans;\\n               ans=str.top();\\n               str.pop();\\n               int times=count.top();\\n               count.pop();\\n               while (times--){\\n                   ans+=temp;\\n               }\\n           }\\n           else { // for char \\n               ans+=s[i];\\n           }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671952,
                "title": "c-python-clean-simple-solutions-w-explanation-recursive",
                "content": "\\u2714\\uFE0F Solution\\n1. add every character to the stack untill we get `\"]\"` \\n2. else decode the substring till we get `[`\\n3. and also decode the number untill there is no digit on the top of the stack\\n\\n```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        stack = []\\n        for c in range(len(s)):\\n            if s[c] != \\']\\':\\n                stack.append(s[c])\\n            else:\\n                string = \\'\\'\\n                num = \\'\\'\\n                while stack[-1] != \\'[\\':\\n                    string = stack.pop() + string\\n                stack.pop()\\n                while stack and stack[-1].isdigit():\\n                    num = stack.pop() + num\\n                stack.append(int(num) * string)\\n                print(num)\\n        return \"\".join(stack)\\n```\\n\\n# ****\\u2714\\uFE0F UP VOTE IF HELPFUL",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        stack = []\\n        for c in range(len(s)):\\n            if s[c] != \\']\\':\\n                stack.append(s[c])\\n            else:\\n                string = \\'\\'\\n                num = \\'\\'\\n                while stack[-1] != \\'[\\':\\n                    string = stack.pop() + string\\n                stack.pop()\\n                while stack and stack[-1].isdigit():\\n                    num = stack.pop() + num\\n                stack.append(int(num) * string)\\n                print(num)\\n        return \"\".join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2515445,
                "title": "c-stack-0-ms-faster-than-100-approach-explained-easy-solution",
                "content": "\\uD83D\\uDC49 Approach :- We traverse the string and we push every character in the stack except the closing bracket. When we find the closing bracket we pop the element till we find the opening bracket. After doing this we will have the string that we have to copy. Then we pop the element unitl we are finding a digit. After doing this we will have the number till which we have to repeat the string we got. Then we push the string we got (number) times back in the stack. After traversing the given string completely we will have our answer in stack in reverse order\\n\\n**CODE:-**\\n\\nclass Solution {\\npublic:\\n*     string decodeString(string s) {\\n        stack<char>st;\\n        string ans = \"\";\\n        int len = s.length();\\n        for(int i = 0;i < len; i++)\\n        {\\n            if(s[i] != \\']\\')\\n            {\\n                st.push(s[i]);\\n            }else\\n            {\\n                string temp = \"\";\\n                while(st.top() != \\'[\\')\\n                {\\n                    temp += st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                string num = \"\";\\n                while(st.size() > 0 && isdigit(st.top()))\\n                {\\n                    num += st.top();\\n                    st.pop();\\n                }\\n                reverse(num.begin(),num.end());\\n                int number = stoi(num);\\n                reverse(temp.begin(),temp.end());\\n                string copy = \"\";\\n                for(int j = 0;j < number; j++)\\n                {\\n                    for(int k = 0;k < temp.length(); k++)\\n                    {\\n                        st.push(temp[k]);\\n                    }\\n                }\\n            }\\n        }\\n        while(st.size() > 0)\\n        {\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n**DO upvote if you understood it !**",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n*     string decodeString(string s) {\\n        stack<char>st;\\n        string ans = \"\";\\n        int len = s.length();\\n        for(int i = 0;i < len; i++)\\n        {\\n            if(s[i] != \\']\\')\\n            {\\n                st.push(s[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1635433,
                "title": "100-faster-recursive-solution-detailed-explanation",
                "content": "<br/> The crux of this recursive problem is that solve the substring between \\'[\\' and \\']\\' as an independent problem, because that may also contain other such bracket sequences. <br/>\\n\\n**Steps:**\\n* let cur = s[pos]\\n* if cur is an alphabet, then just add it our ans string\\n* if cur is a digit, then take it in a variable num, to keep track of how many times we need to repeat the subtring after it (remember that the integer can be `between [1, 300]` not just single digit\\n* if cur is \\'[\\' (`opening bracket`) then call the function recursively with pos starting from the next character\\n* append the string returned by recursive call num times to our ans\\n* if cur is \\']\\' (`closing bracket`) then just return the ans, see carefully that \\']\\' will be encountered only at the end of a recursive call, so the ans formed in current call will be returned to caller (after getting \\'[\\') and `appended num times`\\n* reason for passing pos by reference is that in the recursive call also we don\\'t want to repeat any operation, i.e. `when recursive call ends, we want to continue after \\']\\'` so pos should be changed in each call\\n\\n<br/>\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    string solve(string s, int& pos) {\\n        \\n        int n = s.size(), num = 0;\\n        string ans = \"\";\\n        \\n        for(; pos < n; pos++) {\\n            \\n            char cur = s[pos];\\n            if(isalpha(cur)) ans += cur;\\n            else if(isdigit(cur)) num = num * 10 + cur - \\'0\\';\\n            else if(cur == \\']\\') return ans;\\n\\t\\t\\t// cur == \\'[\\'\\n            else {\\n                string tmp = solve(s, ++pos);\\n                while(num--) ans += tmp;\\n                num = 0;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    string decodeString(string s) {\\n        int i = 0;\\n        return solve(s, i);\\n    }\\n};\\n```\\n\\n<br/>",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string solve(string s, int& pos) {\\n        \\n        int n = s.size(), num = 0;\\n        string ans = \"\";\\n        \\n        for(; pos < n; pos++) {\\n            \\n            char cur = s[pos];\\n            if(isalpha(cur)) ans += cur;\\n            else if(isdigit(cur)) num = num * 10 + cur - \\'0\\';\\n            else if(cur == \\']\\') return ans;\\n\\t\\t\\t// cur == \\'[\\'\\n            else {\\n                string tmp = solve(s, ++pos);\\n                while(num--) ans += tmp;\\n                num = 0;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    string decodeString(string s) {\\n        int i = 0;\\n        return solve(s, i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385397,
                "title": "100-faster-java-solution-using-two-stack-efficient-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\n    public String decodeString(String s) {\\n        Stack<Integer> is = new Stack<>();\\n        Stack<StringBuilder> ss = new Stack<>();\\n\\n        int n = s.length(), num = 0;\\n        StringBuilder str = new StringBuilder();\\n\\n        for(char ch : s.toCharArray()) {\\n            // There will be 4 types of characters --> number, [ , ], character\\n\\n            if(ch >= \\'0\\' && ch <= \\'9\\') {\\n                num = (num * 10) + ch - \\'0\\';\\n            } else if(ch == \\'[\\') {\\n                ss.push(str);\\n                str = new StringBuilder();\\n\\n                is.push(num);\\n                num = 0;\\n            } else if(ch == \\']\\') {\\n                StringBuilder temp = str;\\n                str = ss.pop();\\n                int count = is.pop();\\n\\n                while(count-- > 0) {\\n                    str.append(temp);\\n                }\\n            } else {\\n                str.append(ch);\\n            }\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeString(String s) {\\n        Stack<Integer> is = new Stack<>();\\n        Stack<StringBuilder> ss = new Stack<>();\\n\\n        int n = s.length(), num = 0;\\n        StringBuilder str = new StringBuilder();\\n\\n        for(char ch : s.toCharArray()) {\\n            // There will be 4 types of characters --> number, [ , ], character\\n\\n            if(ch >= \\'0\\' && ch <= \\'9\\') {\\n                num = (num * 10) + ch - \\'0\\';\\n            } else if(ch == \\'[\\') {\\n                ss.push(str);\\n                str = new StringBuilder();\\n\\n                is.push(num);\\n                num = 0;\\n            } else if(ch == \\']\\') {\\n                StringBuilder temp = str;\\n                str = ss.pop();\\n                int count = is.pop();\\n\\n                while(count-- > 0) {\\n                    str.append(temp);\\n                }\\n            } else {\\n                str.append(ch);\\n            }\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941375,
                "title": "js-4-line-solution-with-regexp",
                "content": "The idea is simple. While we have a bracket in the input string, find all encoded strings, which are patterns like *number[word]* and replace them with *word* repeated *number* of times\\n\\n```js\\nconst decodeString = s => {\\n    while (s.includes(\\'[\\')) {\\n        s = s.replace(/(\\\\d+)\\\\[(\\\\w+)\\\\]/g, (_, number, word) => word.repeat(number));\\n    }\\n    return s;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst decodeString = s => {\\n    while (s.includes(\\'[\\')) {\\n        s = s.replace(/(\\\\d+)\\\\[(\\\\w+)\\\\]/g, (_, number, word) => word.repeat(number));\\n    }\\n    return s;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 827515,
                "title": "python-recursive-soln-o-n-95-performance-commented",
                "content": "My recursive solution below will make a single pass of some input string \\'s\\'. A pointer variable `idx` is used as a \"global-like\" pointer for all nested recursive calls. Using my helper function `decode`, I parse \\'s\\' from the first index, and build a string.\\n* Anytime we encounter a digit, we trigger the steps that result in a recursive call.\\n* Anytime we encounter a alphabetical character, we build our string\\n* Anytime we encounter a right bracket, \\']\\', we return the string multiplied by the multiplier passed from its caller\\n\\n```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        idx = 0                                      # index pointer for \\'s\\' string\\n        def decode(s, mult=1) -> str:                # define recursive decode helper function\\n            nonlocal idx                             # reference our index pointer\\n            curr_str = \\'\\'                            # begin with an empty string\\n            while idx < len(s):                      # while there remains un-parsed letters\\n                if s[idx].isdigit():                 # parse digit, triggers recursive call\\n                    curr_mult = \\'\\'                   # derive the multiplier\\n                    while s[idx].isdigit():          # parse all digits\\n                        curr_mult += s[idx]\\n                        idx += 1\\n                    idx += 1                         # move the pointer past left bracket \\'[\\'\\n                    curr_str += decode(s, mult=int(curr_mult))  # recursive call\\n                elif s[idx].isalpha():               # parse alphabet char, build the string\\n                    curr_str += s[idx]\\n                    idx += 1\\n                else:                                # parse right bracket \\']\\', call end condition\\n                    idx += 1\\n                    return mult * curr_str           # multiply the resulting string from this call and return\\n            return mult * curr_str\\n        return decode(s)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        idx = 0                                      # index pointer for \\'s\\' string\\n        def decode(s, mult=1) -> str:                # define recursive decode helper function\\n            nonlocal idx                             # reference our index pointer\\n            curr_str = \\'\\'                            # begin with an empty string\\n            while idx < len(s):                      # while there remains un-parsed letters\\n                if s[idx].isdigit():                 # parse digit, triggers recursive call\\n                    curr_mult = \\'\\'                   # derive the multiplier\\n                    while s[idx].isdigit():          # parse all digits\\n                        curr_mult += s[idx]\\n                        idx += 1\\n                    idx += 1                         # move the pointer past left bracket \\'[\\'\\n                    curr_str += decode(s, mult=int(curr_mult))  # recursive call\\n                elif s[idx].isalpha():               # parse alphabet char, build the string\\n                    curr_str += s[idx]\\n                    idx += 1\\n                else:                                # parse right bracket \\']\\', call end condition\\n                    idx += 1\\n                    return mult * curr_str           # multiply the resulting string from this call and return\\n            return mult * curr_str\\n        return decode(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2846797,
                "title": "go-simple-solution-using-stack-100-runtime-92-memory",
                "content": "# Code\\n```\\ntype item struct {\\n\\tn     int\\n\\tbytes []byte\\n}\\n\\nfunc decodeString(str string) string {\\n\\tnum := 0\\n\\tst := []item{{1, []byte{}}}\\n\\n\\tfor i := range str {\\n\\t\\tswitch {\\n\\t\\tcase str[i] == \\'0\\':\\n\\t\\t\\tnum *= 10\\n\\t\\tcase str[i] > \\'0\\' && str[i] <= \\'9\\':\\n\\t\\t\\tnum = num*10 + int(str[i]-\\'0\\')\\n\\t\\tcase str[i] == \\'[\\':\\n\\t\\t\\tst = append(st, item{num, []byte{}})\\n\\t\\t\\tnum = 0\\n\\t\\tcase str[i] == \\']\\':\\n\\t\\t\\ttmp := st[len(st)-1]\\n\\t\\t\\tst = st[:len(st)-1]\\n\\t\\t\\tfor j := 0; j < tmp.n; j++ {\\n\\t\\t\\t\\tst[len(st)-1].bytes = append(st[len(st)-1].bytes, tmp.bytes...)\\n\\t\\t\\t}\\n\\t\\tdefault:\\n\\t\\t\\tst[len(st)-1].bytes = append(st[len(st)-1].bytes, str[i])\\n\\t\\t}\\n\\t}\\n\\n\\treturn string(st[0].bytes)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype item struct {\\n\\tn     int\\n\\tbytes []byte\\n}\\n\\nfunc decodeString(str string) string {\\n\\tnum := 0\\n\\tst := []item{{1, []byte{}}}\\n\\n\\tfor i := range str {\\n\\t\\tswitch {\\n\\t\\tcase str[i] == \\'0\\':\\n\\t\\t\\tnum *= 10\\n\\t\\tcase str[i] > \\'0\\' && str[i] <= \\'9\\':\\n\\t\\t\\tnum = num*10 + int(str[i]-\\'0\\')\\n\\t\\tcase str[i] == \\'[\\':\\n\\t\\t\\tst = append(st, item{num, []byte{}})\\n\\t\\t\\tnum = 0\\n\\t\\tcase str[i] == \\']\\':\\n\\t\\t\\ttmp := st[len(st)-1]\\n\\t\\t\\tst = st[:len(st)-1]\\n\\t\\t\\tfor j := 0; j < tmp.n; j++ {\\n\\t\\t\\t\\tst[len(st)-1].bytes = append(st[len(st)-1].bytes, tmp.bytes...)\\n\\t\\t\\t}\\n\\t\\tdefault:\\n\\t\\t\\tst[len(st)-1].bytes = append(st[len(st)-1].bytes, str[i])\\n\\t\\t}\\n\\t}\\n\\n\\treturn string(st[0].bytes)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2769142,
                "title": "easy-jav-solution-using-stack",
                "content": "```\\nclass Solution {\\n    public String decodeString(String s) {\\n        String res = \"\";\\n        Stack<Integer> countStack = new Stack<>();\\n        Stack<String> resStack = new Stack<>();\\n        int idx = 0;\\n        while (idx < s.length()) {\\n            if (Character.isDigit(s.charAt(idx))) {\\n                int count = 0;\\n                while (Character.isDigit(s.charAt(idx))) {\\n                    count = 10 * count + (s.charAt(idx) - \\'0\\');\\n                    idx++;\\n                }\\n                countStack.push(count);\\n            }\\n            else if (s.charAt(idx) == \\'[\\') {\\n                resStack.push(res);\\n                res = \"\";\\n                idx++;\\n            }\\n            else if (s.charAt(idx) == \\']\\') {\\n                StringBuilder temp = new StringBuilder (resStack.pop());\\n                int repeatTimes = countStack.pop();\\n                for (int i = 0; i < repeatTimes; i++) {\\n                    temp.append(res);\\n                }\\n                res = temp.toString();\\n                idx++;\\n            }\\n            else {\\n                res += s.charAt(idx++);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeString(String s) {\\n        String res = \"\";\\n        Stack<Integer> countStack = new Stack<>();\\n        Stack<String> resStack = new Stack<>();\\n        int idx = 0;\\n        while (idx < s.length()) {\\n            if (Character.isDigit(s.charAt(idx))) {\\n                int count = 0;\\n                while (Character.isDigit(s.charAt(idx))) {\\n                    count = 10 * count + (s.charAt(idx) - \\'0\\');\\n                    idx++;\\n                }\\n                countStack.push(count);\\n            }\\n            else if (s.charAt(idx) == \\'[\\') {\\n                resStack.push(res);\\n                res = \"\";\\n                idx++;\\n            }\\n            else if (s.charAt(idx) == \\']\\') {\\n                StringBuilder temp = new StringBuilder (resStack.pop());\\n                int repeatTimes = countStack.pop();\\n                for (int i = 0; i < repeatTimes; i++) {\\n                    temp.append(res);\\n                }\\n                res = temp.toString();\\n                idx++;\\n            }\\n            else {\\n                res += s.charAt(idx++);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2014602,
                "title": "simple-c-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<char>st;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]!=\\']\\')\\n                st.push(s[i]);\\n            else\\n            {\\n                string characters=\"\";\\n                while(st.top()!=\\'[\\')\\n                {\\n                    characters=st.top()+characters;\\n                    st.pop();\\n                }\\n                st.pop();\\n                string number=\"\";\\n                while(!st.empty() && isdigit(st.top()))\\n                {\\n                    number=st.top()+number;\\n                    st.pop();\\n                   \\n                }\\n                for(int j=0;j<stoll(number);j++)\\n                {\\n                    for(int k=0;k<characters.size();k++)\\n                     {\\n                            st.push(characters[k]);\\n                     }\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        while(!st.empty())\\n         {  \\n             ans=st.top()+ans;\\n             st.pop();\\n         }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<char>st;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]!=\\']\\')\\n                st.push(s[i]);\\n            else\\n            {\\n                string characters=\"\";\\n                while(st.top()!=\\'[\\')\\n                {\\n                    characters=st.top()+characters;\\n                    st.pop();\\n                }\\n                st.pop();\\n                string number=\"\";\\n                while(!st.empty() && isdigit(st.top()))\\n                {\\n                    number=st.top()+number;\\n                    st.pop();\\n                   \\n                }\\n                for(int j=0;j<stoll(number);j++)\\n                {\\n                    for(int k=0;k<characters.size();k++)\\n                     {\\n                            st.push(characters[k]);\\n                     }\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        while(!st.empty())\\n         {  \\n             ans=st.top()+ans;\\n             st.pop();\\n         }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1851228,
                "title": "java-and-python3-stack-clear-annotation",
                "content": "***Please upvote if it helps\\uD83D\\uDE0A.***\\n\\n\\tStep1:put the char into the stack, except \\']\\'\\n\\tStep2:if char == \\']\\',start to find the (1)subStr;(2)k due to the formation of k[subStr]\\n\\t\\tStep2-1:find the (1)subStr and remove the \\'[\\' in the stack\\n\\t\\tStep2-2:find the (2)k and remove the k in the stack. k is in range [1,300]\\n\\t\\tStep2-3:push the subStr into the stack\\n\\tStep3:reverse the stack\\n\\n***Thanks a lot for [this answer](https://leetcode.com/problems/decode-string/discuss/1635285/Java-or-Single-Stack-or-Iterative-Approach-or-Detailed-Explanation)***\\n\\nJava codes:\\n```\\n   public String decodeString(String s) {\\n        Stack<Character> stack = new Stack<>();\\n\\n        for(char c : s.toCharArray()){\\n\\n            // Step2:if char == \\']\\',start to find the (1)subStr;(2)k due to the formation of k[subStr]\\n            if(c == \\']\\'){\\n                StringBuilder subStr = new StringBuilder();\\n                String temp = new String();\\n                int k;\\n                //Step2-1:find the (1)subStr and remove the \\'[\\' in the stack\\n                while(!stack.isEmpty() && stack.peek() != \\'[\\'){\\n                    subStr.append(stack.pop());\\n                }\\n                stack.pop();\\n\\n                //Step2-2:find the (2)k and remove the k in the stack. k is in range [1,300]\\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())){\\n                    temp = stack.pop() + temp;\\n                }\\n                k = Integer.parseInt(temp);\\n\\n                //Step2-3:push the subStr into the stack\\n                while(k-- > 0){\\n                    for(int i = subStr.length() - 1;i >= 0;i--){\\n                        stack.push(subStr.charAt(i));\\n                    }\\n                }\\n            }else{\\n                // Step1:put the char into the stack, except \\']\\'\\n                stack.push(c);\\n            }\\n        }\\n\\n        //Step3:reverse the stack\\n        char[] result = new char[stack.size()];\\n        int i = stack.size() - 1;\\n        while(!stack.isEmpty()){\\n            result[i--] = stack.pop();\\n        }\\n        return new String(result);\\n```\\nPython3 codes:\\n```\\nclass Solution:\\n    def decodeString(self, s):\\n        # In python, List can be used as stack(by using pop()) and queue(by using pop(0))\\n        result = []\\n        for curr_char in s:\\n            if curr_char == \"]\":\\n                # Step2-1 : Find the (1)subStr and remove \"[\" in the stack\\n                sub_str = []\\n                while result[-1] != \"[\":\\n                    sub_str.append(result.pop())\\n                sub_str = \"\".join(sub_str[::-1])\\n\\n                # Step2-2 : Find the (2)k and remove k in the stack\\n                result.pop()\\n                k = []\\n                while len(result) > 0 and result[-1] <= \"9\":\\n                    k.append(result.pop())\\n                k = int(\"\".join(k[::-1]))\\n\\n                # Step2-3 : Repeat sub_str k times after stack\\n                result += k*sub_str\\n\\n            else:\\n                # Step1 : Put the char into the stack, except \"]\"\\n                result.append(curr_char)\\n        return \"\".join(result)\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\n   public String decodeString(String s) {\\n        Stack<Character> stack = new Stack<>();\\n\\n        for(char c : s.toCharArray()){\\n\\n            // Step2:if char == \\']\\',start to find the (1)subStr;(2)k due to the formation of k[subStr]\\n            if(c == \\']\\'){\\n                StringBuilder subStr = new StringBuilder();\\n                String temp = new String();\\n                int k;\\n                //Step2-1:find the (1)subStr and remove the \\'[\\' in the stack\\n                while(!stack.isEmpty() && stack.peek() != \\'[\\'){\\n                    subStr.append(stack.pop());\\n                }\\n                stack.pop();\\n\\n                //Step2-2:find the (2)k and remove the k in the stack. k is in range [1,300]\\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())){\\n                    temp = stack.pop() + temp;\\n                }\\n                k = Integer.parseInt(temp);\\n\\n                //Step2-3:push the subStr into the stack\\n                while(k-- > 0){\\n                    for(int i = subStr.length() - 1;i >= 0;i--){\\n                        stack.push(subStr.charAt(i));\\n                    }\\n                }\\n            }else{\\n                // Step1:put the char into the stack, except \\']\\'\\n                stack.push(c);\\n            }\\n        }\\n\\n        //Step3:reverse the stack\\n        char[] result = new char[stack.size()];\\n        int i = stack.size() - 1;\\n        while(!stack.isEmpty()){\\n            result[i--] = stack.pop();\\n        }\\n        return new String(result);\\n```\n```\\nclass Solution:\\n    def decodeString(self, s):\\n        # In python, List can be used as stack(by using pop()) and queue(by using pop(0))\\n        result = []\\n        for curr_char in s:\\n            if curr_char == \"]\":\\n                # Step2-1 : Find the (1)subStr and remove \"[\" in the stack\\n                sub_str = []\\n                while result[-1] != \"[\":\\n                    sub_str.append(result.pop())\\n                sub_str = \"\".join(sub_str[::-1])\\n\\n                # Step2-2 : Find the (2)k and remove k in the stack\\n                result.pop()\\n                k = []\\n                while len(result) > 0 and result[-1] <= \"9\":\\n                    k.append(result.pop())\\n                k = int(\"\".join(k[::-1]))\\n\\n                # Step2-3 : Repeat sub_str k times after stack\\n                result += k*sub_str\\n\\n            else:\\n                # Step1 : Put the char into the stack, except \"]\"\\n                result.append(curr_char)\\n        return \"\".join(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635533,
                "title": "python-stack-beats-95-simplest-solution",
                "content": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        stack = []\\n        lenS = len(s)\\n        i = 0\\n        while i < lenS:\\n            if s[i] == \\']\\':\\n                decoded = \\'\\'\\n                while stack and stack[-1] != \\'[\\':\\n                    decoded = stack.pop() + decoded\\n                stack.pop()\\n                decoded *= int(stack.pop())\\n                stack.append(decoded)\\n            elif s[i].isdigit():\\n                if stack and stack[-1].isdigit():\\n                    stack[-1] += s[i]\\n                else:\\n                    stack.append(s[i])\\n            else:\\n                stack.append(s[i])\\n            i += 1\\n        decoded = \\'\\'\\n        while stack:\\n            decoded = stack.pop() + decoded\\n        return decoded\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        stack = []\\n        lenS = len(s)\\n        i = 0\\n        while i < lenS:\\n            if s[i] == \\']\\':\\n                decoded = \\'\\'\\n                while stack and stack[-1] != \\'[\\':\\n                    decoded = stack.pop() + decoded\\n                stack.pop()\\n                decoded *= int(stack.pop())\\n                stack.append(decoded)\\n            elif s[i].isdigit():\\n                if stack and stack[-1].isdigit():\\n                    stack[-1] += s[i]\\n                else:\\n                    stack.append(s[i])\\n            else:\\n                stack.append(s[i])\\n            i += 1\\n        decoded = \\'\\'\\n        while stack:\\n            decoded = stack.pop() + decoded\\n        return decoded\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635285,
                "title": "java-single-stack-iterative-approach-detailed-explanation",
                "content": "```\\nIntuition :\\n1) If string does not have inner substring like this 3[a5[cd]] then it can be solved easily (simple iteration)\\n2) In some cases, we can have inner sub string as I mentioned above then it is best to solve with stack. Solve inner substring first.(Iterative approach)\\n3) Insert the character in stack until you find \\']\\' char\\n4) If you find \\']\\' char then pop the character until you find \\'[\\', This is how you can get the substring.\\n5) Remove the \\'[\\' character\\n6) Find the number k, number can be in single digit, two digits, .. so on.\\n7) Put back the substring k times in stack\\n8) Atlast take the result in one char array because stack format will not in string format.\\n9) return the result\\n```\\n```\\npublic String decodeString(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        for(char ch : s.toCharArray()){\\n            if(ch != \\']\\'){\\n                stack.push(ch);\\n            }else{\\n                //get the sub string\\n                StringBuilder sb = new StringBuilder();\\n                while(stack.peek() != \\'[\\'){\\n                    sb.append(stack.pop());\\n                }\\n                //remove the \\'[\\' character\\n                stack.pop();\\n                //get the number\\n                int k = 0;\\n                int base = 1;\\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())){\\n                    k = (stack.pop() - \\'0\\') * base + k;\\n                    base *= 10;\\n                }\\n                //put back the substring in stack k times\\n                while(k-- > 0){\\n                    for(int i=sb.length()-1; i>=0; i--){\\n                        stack.push(sb.charAt(i));\\n                    }\\n                }\\n            }\\n        }\\n        char[] result = new char[stack.size()];\\n        for(int i=stack.size()-1;i>=0;i--)\\n            result[i] = stack.pop();\\n        return new String(result);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nIntuition :\\n1) If string does not have inner substring like this 3[a5[cd]] then it can be solved easily (simple iteration)\\n2) In some cases, we can have inner sub string as I mentioned above then it is best to solve with stack. Solve inner substring first.(Iterative approach)\\n3) Insert the character in stack until you find \\']\\' char\\n4) If you find \\']\\' char then pop the character until you find \\'[\\', This is how you can get the substring.\\n5) Remove the \\'[\\' character\\n6) Find the number k, number can be in single digit, two digits, .. so on.\\n7) Put back the substring k times in stack\\n8) Atlast take the result in one char array because stack format will not in string format.\\n9) return the result\\n```\n```\\npublic String decodeString(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        for(char ch : s.toCharArray()){\\n            if(ch != \\']\\'){\\n                stack.push(ch);\\n            }else{\\n                //get the sub string\\n                StringBuilder sb = new StringBuilder();\\n                while(stack.peek() != \\'[\\'){\\n                    sb.append(stack.pop());\\n                }\\n                //remove the \\'[\\' character\\n                stack.pop();\\n                //get the number\\n                int k = 0;\\n                int base = 1;\\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())){\\n                    k = (stack.pop() - \\'0\\') * base + k;\\n                    base *= 10;\\n                }\\n                //put back the substring in stack k times\\n                while(k-- > 0){\\n                    for(int i=sb.length()-1; i>=0; i--){\\n                        stack.push(sb.charAt(i));\\n                    }\\n                }\\n            }\\n        }\\n        char[] result = new char[stack.size()];\\n        for(int i=stack.size()-1;i>=0;i--)\\n            result[i] = stack.pop();\\n        return new String(result);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 818463,
                "title": "c-0-ms-solution-100-00-1-stack-approach-easy-to-understand",
                "content": "***Runtime: 0 ms, faster than 100.00% of C++ online submissions for Decode String.\\nMemory Usage: 6.6 MB, less than 60.19% of C++ online submissions for Decode String.***\\n```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        string result;\\n        stack<string> st;\\n        for(int i = 0 ;i < s.size(); i++){\\n            if(isdigit(s[i])){\\n                int num = 0;\\n                while(i < s.size() && isdigit(s[i])){\\n                    num = num * 10 + (s[i++] - \\'0\\');\\n                }\\n                i--;\\n                st.push(to_string(num));\\n            }else if(isalpha(s[i])){\\n                string word = \"\";\\n                while(i < s.size() && isalpha(s[i])){\\n                    word = word + s[i++];\\n                }\\n                i--;\\n                st.push(word);\\n            }else if(s[i] == \\'[\\'){\\n                st.push(\"[\");\\n            }else if(s[i] == \\']\\'){\\n                string word, current;\\n                while(st.top() != \"[\"){\\n                    word = st.top() + word;\\n                    st.pop();\\n                }\\n                st.pop();\\n                int times = stoi(st.top());  st.pop();\\n                while(times--){\\n                    current += word;\\n                }\\n                st.push(current);\\n            }\\n        }\\n        while(!st.empty()){\\n            result = st.top() + result; \\n            st.pop();\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        string result;\\n        stack<string> st;\\n        for(int i = 0 ;i < s.size(); i++){\\n            if(isdigit(s[i])){\\n                int num = 0;\\n                while(i < s.size() && isdigit(s[i])){\\n                    num = num * 10 + (s[i++] - \\'0\\');\\n                }\\n                i--;\\n                st.push(to_string(num));\\n            }else if(isalpha(s[i])){\\n                string word = \"\";\\n                while(i < s.size() && isalpha(s[i])){\\n                    word = word + s[i++];\\n                }\\n                i--;\\n                st.push(word);\\n            }else if(s[i] == \\'[\\'){\\n                st.push(\"[\");\\n            }else if(s[i] == \\']\\'){\\n                string word, current;\\n                while(st.top() != \"[\"){\\n                    word = st.top() + word;\\n                    st.pop();\\n                }\\n                st.pop();\\n                int times = stoi(st.top());  st.pop();\\n                while(times--){\\n                    current += word;\\n                }\\n                st.push(current);\\n            }\\n        }\\n        while(!st.empty()){\\n            result = st.top() + result; \\n            st.pop();\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 762300,
                "title": "python-stack",
                "content": "Note:\\nI use cur_level string as an array because strings are immutable in python and it\\'s better working with arrays and then concat\\n\\n```\\ndef decodeString(self, s: str) -> str:\\n        stack = []\\n        cur_level = []\\n        num = 0\\n        \\n        for char in s:\\n            if char.isdigit():\\n                num = num * 10 + int(char)\\n            \\n            elif char.isalpha():\\n                cur_level.append(char)\\n            \\n            elif char == \\'[\\':\\n                stack.append((num, [*cur_level]))\\n                cur_level = []\\n                num = 0\\n            \\n            elif char == \\']\\':\\n                prev_level_num, prev_level = stack.pop()\\n                cur_level_string = \"\".join(cur_level)\\n                cur_level = [*prev_level, prev_level_num * cur_level_string] \\n            \\n        return \"\".join(cur_level)\\n```",
                "solutionTags": [],
                "code": "```\\ndef decodeString(self, s: str) -> str:\\n        stack = []\\n        cur_level = []\\n        num = 0\\n        \\n        for char in s:\\n            if char.isdigit():\\n                num = num * 10 + int(char)\\n            \\n            elif char.isalpha():\\n                cur_level.append(char)\\n            \\n            elif char == \\'[\\':\\n                stack.append((num, [*cur_level]))\\n                cur_level = []\\n                num = 0\\n            \\n            elif char == \\']\\':\\n                prev_level_num, prev_level = stack.pop()\\n                cur_level_string = \"\".join(cur_level)\\n                cur_level = [*prev_level, prev_level_num * cur_level_string] \\n            \\n        return \"\".join(cur_level)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 752163,
                "title": "python-regex-beats-99",
                "content": "```\\nimport re\\n\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n\\t\\n        while True:\\n\\t\\t\\t# find a match with a number followed by a bracket enclosing a substring (with no more brackets inside)\\n            match = re.search(\\'(\\\\d+)\\\\[(\\\\w+)\\\\]\\', s)\\n\\t\\t\\t\\n\\t\\t\\t# if no match we are done\\n            if not match:\\n                break\\n\\t\\t\\t\\t\\n\\t\\t\\t# break the match into the number and substring\\n            mult = int(match.group(1))\\n            sub = match.group(2)\\n\\t\\t\\t\\n\\t\\t\\t# substitute the original match with the substring multiplied by the number and continue with the updated string\\n            s = re.sub(\\'\\\\d+\\\\[\\\\w+\\\\]\\', mult*sub, s, 1)\\n\\t\\t\\t\\n        return s\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport re\\n\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n\\t\\n        while True:\\n\\t\\t\\t# find a match with a number followed by a bracket enclosing a substring (with no more brackets inside)\\n            match = re.search(\\'(\\\\d+)\\\\[(\\\\w+)\\\\]\\', s)\\n\\t\\t\\t\\n\\t\\t\\t# if no match we are done\\n            if not match:\\n                break\\n\\t\\t\\t\\t\\n\\t\\t\\t# break the match into the number and substring\\n            mult = int(match.group(1))\\n            sub = match.group(2)\\n\\t\\t\\t\\n\\t\\t\\t# substitute the original match with the substring multiplied by the number and continue with the updated string\\n            s = re.sub(\\'\\\\d+\\\\[\\\\w+\\\\]\\', mult*sub, s, 1)\\n\\t\\t\\t\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 618832,
                "title": "javascript-clean",
                "content": "```javascript\\nconst decodeString = (s) => {\\n    const stack = new Array();\\n    \\n    for(let i = 0; i < s.length; i++) { \\n        const char = s.charAt(i);\\n        if(isClose(char)) {\\n            let decoded = getInner(stack);\\n            let counter = getCounter(stack);\\n            let repeated = decoded.repeat(counter);\\n            \\n            stack.push(repeated);\\n\\n        } else stack.push(char);\\n    }\\n    \\n    let ans = \\'\\';\\n    while(stack.length) ans = `${stack.pop()}${ans}`;\\n    \\n    return ans;\\n};\\n\\nconst getCounter = (stack) => {\\n    let ans = \\'\\';\\n    while( isNum(stack[stack.length - 1]) ) ans = `${stack.pop()}${ans}`;\\n    return parseInt(ans);\\n};\\n\\nconst getInner = (stack) => {\\n    let ans = \\'\\';\\n    while(!isOpen(stack[stack.length - 1] )) {\\n        ans = `${stack.pop()}${ans}`;\\n    }\\n    stack.pop(); // leftover\\n    return ans;\\n}\\n\\nconst isNum = char => char >= \\'0\\' && char <= \\'9\\';\\nconst isOpen = char => char ===\\'[\\';\\nconst isClose = char => char === \\']\\';\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst decodeString = (s) => {\\n    const stack = new Array();\\n    \\n    for(let i = 0; i < s.length; i++) { \\n        const char = s.charAt(i);\\n        if(isClose(char)) {\\n            let decoded = getInner(stack);\\n            let counter = getCounter(stack);\\n            let repeated = decoded.repeat(counter);\\n            \\n            stack.push(repeated);\\n\\n        } else stack.push(char);\\n    }\\n    \\n    let ans = \\'\\';\\n    while(stack.length) ans = `${stack.pop()}${ans}`;\\n    \\n    return ans;\\n};\\n\\nconst getCounter = (stack) => {\\n    let ans = \\'\\';\\n    while( isNum(stack[stack.length - 1]) ) ans = `${stack.pop()}${ans}`;\\n    return parseInt(ans);\\n};\\n\\nconst getInner = (stack) => {\\n    let ans = \\'\\';\\n    while(!isOpen(stack[stack.length - 1] )) {\\n        ans = `${stack.pop()}${ans}`;\\n    }\\n    stack.pop(); // leftover\\n    return ans;\\n}\\n\\nconst isNum = char => char >= \\'0\\' && char <= \\'9\\';\\nconst isOpen = char => char ===\\'[\\';\\nconst isClose = char => char === \\']\\';\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 408777,
                "title": "javascript-simple-logic-solution-w-explanation",
                "content": "#### The idea\\nGiven the example from the description,  `s = \"3[a2[c]]\"`, since it is possible for us to encounter nested brackets, my intuition is to always figure out the inner-most bracket first. So, In order to find the inner-most brackets, I  try to find the last `[`, and the first `]` after that, and with a `while` loop to figure our how many repetitions we need.\\n\\n``` javascript\\nvar decodeString = function(s) {\\n    while(s.indexOf(\\'[\\')!=-1) { // base case, breaks when there\\'s no bracket found\\n        let left = s.lastIndexOf(\\'[\\'); // left position of the inner-most `[`\\n        let right = left + s.substring(left).indexOf(\\']\\'); // right positio of the inner-most `]`\\n        let word = s.substring(left+1, right); // between them is the string\\n        let count = \"\";\\n        while(s[left-1] >= 0 && s[left-1]<=9) { // try to find a valid number\\n            left--;\\n            count = s[left] + count;\\n        }\\n        s = s.substring(0,left) + word.repeat(count) + s.substring(right+1); // put them all togher and repeat :)\\n    }\\n    return s;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar decodeString = function(s) {\\n    while(s.indexOf(\\'[\\')!=-1) { // base case, breaks when there\\'s no bracket found\\n        let left = s.lastIndexOf(\\'[\\'); // left position of the inner-most `[`\\n        let right = left + s.substring(left).indexOf(\\']\\'); // right positio of the inner-most `]`\\n        let word = s.substring(left+1, right); // between them is the string\\n        let count = \"\";\\n        while(s[left-1] >= 0 && s[left-1]<=9) { // try to find a valid number\\n            left--;\\n            count = s[left] + count;\\n        }\\n        s = s.substring(0,left) + word.repeat(count) + s.substring(right+1); // put them all togher and repeat :)\\n    }\\n    return s;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 203854,
                "title": "easy-to-understand-javascript",
                "content": "Modified from a python solution by user simkieu\\n\\n```\\nfunction decocdeString(s) {\\n  let stack = []\\n  let curNum = 0\\n  let curString = \\'\\'\\n  for (let c of s) {\\n    if (c === \\'[\\') {\\n      stack.push(curString)\\n      stack.push(curNum)\\n      curNum = 0\\n      curString = \\'\\'\\n    } else if (c === \\']\\') {\\n      let num = stack.pop()\\n      let prevString = stack.pop()\\n      curString = prevString + curString.repeat(parseInt(num))\\n    } else if (parseInt(c) || c === \\'0\\') {\\n      curNum = curNum*10 + parseInt(c)\\n    } else {\\n      curString += c\\n    }\\n  }\\n  return curString\\n}",
                "solutionTags": [],
                "code": "Modified from a python solution by user simkieu\\n\\n```\\nfunction decocdeString(s) {\\n  let stack = []\\n  let curNum = 0\\n  let curString = \\'\\'\\n  for (let c of s) {\\n    if (c === \\'[\\') {\\n      stack.push(curString)\\n      stack.push(curNum)\\n      curNum = 0\\n      curString = \\'\\'\\n    } else if (c === \\']\\') {\\n      let num = stack.pop()\\n      let prevString = stack.pop()\\n      curString = prevString + curString.repeat(parseInt(num))\\n    } else if (parseInt(c) || c === \\'0\\') {\\n      curNum = curNum*10 + parseInt(c)\\n    } else {\\n      curString += c\\n    }\\n  }\\n  return curString\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2723127,
                "title": "c-faster-than-100-solution-with-comments-recursion-o-n",
                "content": "# Code\\n```\\nclass Solution {\\n\\n   // starting Index of encoding string\\n   int start = 0;\\n\\n   string Solve(string &s )\\n   {\\n       // Variable To store our answer\\n       string ans = \"\";\\n\\n      //We will Traverse forward till wo dont get a numeric alphabet \\n      // or closing bracket or we reach till end\\n\\n       while( start < s.length() && s[start] >= \\'a\\' && s[start]<= \\'z\\' && s[start] != \\']\\' )\\n       ans.push_back(s[start++]);\\n       \\n     // if We reach end or we are at closing bracket we return \\n     // our ans as it is \\n     // eg1 : string = abcdef\\n     // we will have reache the end after starting from 0\\n     \\n     // eg2 : string = ab2[def]ghi\\n     // we will have reach at \\']\\' after starting from \\'d\\'\\n     \\n    \\n       if(start >= s.length() || s[start] == \\']\\')\\n       return ans;\\n    \\n     // We have reach the numerical character\\n       string num = \"\";\\n     \\n     // store the number to be repeated\\n       while(s[start] != \\'[\\' )\\n       num.push_back(s[start++]);\\n       int n = stoi(num) ;\\n     \\n     // Jump one index from \\'[\\' and get the repeating substring \\n       start++;\\n    \\n       string repeat = Solve(s );\\n    // Attach the repeating substring to our ans\\n      for(int k = 0 ; k< n ; k++)\\n           ans+= repeat;\\n\\n     // Jump one index from \\']\\' and get the substring ahead of\\n     //  repeating substring if any \\n\\n       start++;\\n     \\n     //Return ans\\n        return ans + Solve(s);\\n        \\n}\\n\\npublic:\\n    string decodeString(string s) {\\n        \\n        return Solve(s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\n   // starting Index of encoding string\\n   int start = 0;\\n\\n   string Solve(string &s )\\n   {\\n       // Variable To store our answer\\n       string ans = \"\";\\n\\n      //We will Traverse forward till wo dont get a numeric alphabet \\n      // or closing bracket or we reach till end\\n\\n       while( start < s.length() && s[start] >= \\'a\\' && s[start]<= \\'z\\' && s[start] != \\']\\' )\\n       ans.push_back(s[start++]);\\n       \\n     // if We reach end or we are at closing bracket we return \\n     // our ans as it is \\n     // eg1 : string = abcdef\\n     // we will have reache the end after starting from 0\\n     \\n     // eg2 : string = ab2[def]ghi\\n     // we will have reach at \\']\\' after starting from \\'d\\'\\n     \\n    \\n       if(start >= s.length() || s[start] == \\']\\')\\n       return ans;\\n    \\n     // We have reach the numerical character\\n       string num = \"\";\\n     \\n     // store the number to be repeated\\n       while(s[start] != \\'[\\' )\\n       num.push_back(s[start++]);\\n       int n = stoi(num) ;\\n     \\n     // Jump one index from \\'[\\' and get the repeating substring \\n       start++;\\n    \\n       string repeat = Solve(s );\\n    // Attach the repeating substring to our ans\\n      for(int k = 0 ; k< n ; k++)\\n           ans+= repeat;\\n\\n     // Jump one index from \\']\\' and get the substring ahead of\\n     //  repeating substring if any \\n\\n       start++;\\n     \\n     //Return ans\\n        return ans + Solve(s);\\n        \\n}\\n\\npublic:\\n    string decodeString(string s) {\\n        \\n        return Solve(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2399359,
                "title": "python-soln-using-stack",
                "content": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        \\n        stack = []\\n        \\n        for i in range(len(s)):\\n            \\n            if s[i] != \\']\\':\\n                stack.append(s[i])\\n                \\n            else:\\n                subStr = \\'\\'\\n                while stack[-1] != \\'[\\':\\n                    subStr = stack.pop() + subStr\\n                stack.pop()\\n                \\n                digit = \\'\\'\\n                while stack and stack[-1].isdigit():\\n                    digit = stack.pop() + digit\\n                    \\n                stack.append(int(digit) * subStr)\\n                \\n        return \\'\\'.join(stack)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        \\n        stack = []\\n        \\n        for i in range(len(s)):\\n            \\n            if s[i] != \\']\\':\\n                stack.append(s[i])\\n                \\n            else:\\n                subStr = \\'\\'\\n                while stack[-1] != \\'[\\':\\n                    subStr = stack.pop() + subStr\\n                stack.pop()\\n                \\n                digit = \\'\\'\\n                while stack and stack[-1].isdigit():\\n                    digit = stack.pop() + digit\\n                    \\n                stack.append(int(digit) * subStr)\\n                \\n        return \\'\\'.join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1220962,
                "title": "java-easy-to-understand-with-explanation",
                "content": "We will solve the problem by dividing it into subproblems. The algorithm is as follows:\\n\\n1. Iterate through the string\\n2. If we have a closing bracket, subproblem is done\\n3. If the current character is a letter, append it and continue\\n4. If the current character is an opening bracket, append it as count times\\n5. If none of the above, we have a digit that represents how many times we should append the subproblem. To accomplish it, don\\'t forget that we may have digits which has more than one digit. So, if we see sequential digits, the previous one should be multiplied by 10 to calculate the count number.\\n\\n```\\nclass Solution {\\n    int i = 0; //tricky part, we globally iterate forward with the help of defining this variable as global\\n    \\n    public String decodeString(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int count = 0;\\n        \\n        while (i < s.length()) {\\n            char c = s.charAt(i);\\n            i++;\\n            \\n            if (c == \\']\\') { //subproblem is done\\n                break;\\n            }\\n            \\n            if (Character.isLetter(c)) { //append and continue\\n                sb.append(c);\\n                continue;\\n            }\\n            \\n            if (c == \\'[\\') {\\n                String tmp = decodeString(s); //recursive call to solve the subproblem\\n                for (int j = 0; j < count; j++) {\\n                    sb.append(tmp);\\n                }\\n                count = 0; // reset the counter\\n            } else {\\n                count = count * 10 + c - \\'0\\'; //handle count case which has more than one digit\\n            }\\n            \\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int i = 0; //tricky part, we globally iterate forward with the help of defining this variable as global\\n    \\n    public String decodeString(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int count = 0;\\n        \\n        while (i < s.length()) {\\n            char c = s.charAt(i);\\n            i++;\\n            \\n            if (c == \\']\\') { //subproblem is done\\n                break;\\n            }\\n            \\n            if (Character.isLetter(c)) { //append and continue\\n                sb.append(c);\\n                continue;\\n            }\\n            \\n            if (c == \\'[\\') {\\n                String tmp = decodeString(s); //recursive call to solve the subproblem\\n                for (int j = 0; j < count; j++) {\\n                    sb.append(tmp);\\n                }\\n                count = 0; // reset the counter\\n            } else {\\n                count = count * 10 + c - \\'0\\'; //handle count case which has more than one digit\\n            }\\n            \\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87631,
                "title": "can-we-do-the-encode-way-i-post-one-the-return-is-the-shortest-length-of-encoded-string",
                "content": "Suppose we have a string with only lowercase letters and the problem asked us to encode it and return the shortest one. \\nHow can we do that? Does anyone have the idea?\\n\\n\\n\\nupdate: I write a solution for the problem. Does anyone have some suggestion?\\n\\n11/18 update: This solution return the shortest encode string, this means if the string is ```\"aaa\"```, it will return ```\"aaa\"```.\\n             if the string is ```\"aaaaa\"```, it will return ```\"5[a]\"```\\n\\n```\\n// this function is used to check if a string is combined by repeating a substring. \\n// Also Here can be replaced by doing KMP algorithm for whole string to improvement\\nbool checkRepeating(string& s, int l, int r, int start, int end){  \\n    if((end-start+1)%(r-l+1) != 0)\\n        return false;\\n    int len = r-l+1;\\n    bool res = true;\\n    for(int i=start; i<=end; i++){\\n        if(s[(i-start)%len+l] != s[i]){\\n            res = false;\\n            break;\\n        }\\n    }\\n    return res;\\n}\\n\\n// this function is used to get the length of the current number\\nint getLength(int l1, int l2){\\n    return (int)(log10(l2/l1+1)+1);\\n}\\n\\nstring shortestEncodeString(string s){\\n    int len = s.length();\\n\\n    vector< vector<int> > res(len, vector<int>(len, 0));\\n    //Initial the matrix \\n    for(int i=0; i<len; i++){\\n        for(int j=0; j<=i; j++){\\n            res[j][i] = i-j+1;\\n        }\\n    }\\n\\n    unordered_map<string, string> record;\\n\\n    for(int i=0; i<len; i++){\\n        for(int j=i; j>=0; j--){\\n\\n            string temp = s.substr(j, i-j+1);\\n/* if the current substring has showed before, then no need to compute again\\n * Here is a example for this part: if the string is \"abcabc\".\\n * if we see the second \"abc\", then no need to compute again, just use the\\n * result from first \"abc\".\\n**/\\n            if(record.find(temp) != record.end()){\\n                res[j][i] = record[temp].size();\\n                continue;\\n            }\\n            string ans = temp;\\n            for(int k=j; k<i; k++){\\n\\n                string str1 = s.substr(j, k-j+1);\\n                string str2 = s.substr(k+1, i-k);\\n                if(res[j][i] > res[j][k] + res[k+1][i]){\\n                    res[j][i] = res[j][k]+res[k+1][i];\\n                    ans = record[str1] + record[str2];\\n                }\\n\\n                if(checkRepeating(s, j, k, k+1, i) == true && res[j][i] > 2+getLength(k-j+1, i-k)+res[j][k]){\\n                    res[j][i] = 2+getLength(k-j+1, i-k)+res[j][k];\\n                    ans = to_string((i-j+1)/(k-j+1)) + '[' + record[str1] +']';\\n                }\\n            }\\n            record[temp] = ans;\\n        }\\n\\n    }\\n\\n    return record[s];\\n}\\n```",
                "solutionTags": [],
                "code": "```\"aaa\"```\n```\"aaa\"```\n```\"aaaaa\"```\n```\"5[a]\"```\n```\\n// this function is used to check if a string is combined by repeating a substring. \\n// Also Here can be replaced by doing KMP algorithm for whole string to improvement\\nbool checkRepeating(string& s, int l, int r, int start, int end){  \\n    if((end-start+1)%(r-l+1) != 0)\\n        return false;\\n    int len = r-l+1;\\n    bool res = true;\\n    for(int i=start; i<=end; i++){\\n        if(s[(i-start)%len+l] != s[i]){\\n            res = false;\\n            break;\\n        }\\n    }\\n    return res;\\n}\\n\\n// this function is used to get the length of the current number\\nint getLength(int l1, int l2){\\n    return (int)(log10(l2/l1+1)+1);\\n}\\n\\nstring shortestEncodeString(string s){\\n    int len = s.length();\\n\\n    vector< vector<int> > res(len, vector<int>(len, 0));\\n    //Initial the matrix \\n    for(int i=0; i<len; i++){\\n        for(int j=0; j<=i; j++){\\n            res[j][i] = i-j+1;\\n        }\\n    }\\n\\n    unordered_map<string, string> record;\\n\\n    for(int i=0; i<len; i++){\\n        for(int j=i; j>=0; j--){\\n\\n            string temp = s.substr(j, i-j+1);\\n/* if the current substring has showed before, then no need to compute again\\n * Here is a example for this part: if the string is \"abcabc\".\\n * if we see the second \"abc\", then no need to compute again, just use the\\n * result from first \"abc\".\\n**/\\n            if(record.find(temp) != record.end()){\\n                res[j][i] = record[temp].size();\\n                continue;\\n            }\\n            string ans = temp;\\n            for(int k=j; k<i; k++){\\n\\n                string str1 = s.substr(j, k-j+1);\\n                string str2 = s.substr(k+1, i-k);\\n                if(res[j][i] > res[j][k] + res[k+1][i]){\\n                    res[j][i] = res[j][k]+res[k+1][i];\\n                    ans = record[str1] + record[str2];\\n                }\\n\\n                if(checkRepeating(s, j, k, k+1, i) == true && res[j][i] > 2+getLength(k-j+1, i-k)+res[j][k]){\\n                    res[j][i] = 2+getLength(k-j+1, i-k)+res[j][k];\\n                    ans = to_string((i-j+1)/(k-j+1)) + '[' + record[str1] +']';\\n                }\\n            }\\n            record[temp] = ans;\\n        }\\n\\n    }\\n\\n    return record[s];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3838764,
                "title": "c-solution-using-stack-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nuse 1 stack to store the number of times the string has to be repeated and one to keep the letters of the string\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nuse ] to indicate the end of the repeated part when encountered take the top most integer from the integer stack and the part to be repeated from the other stack. the repeated part will be until we have encountred [ this in stack. repeat the string. then store the string in ans string if stack is empty but if stack is not empty then that string is in another [] so it has to be repeated again so store it back in stack.  \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n ## **please upvote**\\n\\n---\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        string ans = \"\";\\n        stack<char> st;\\n        stack<int> m;\\n        for(int i = 0; i < s.size() ; i++){\\n            if(s[i] >= \\'0\\' && s[i] <= \\'9\\'){\\n                string t = \"\";\\n                t.push_back(s[i]);\\n                for(int j = i+1 ; j < s.size();j++){\\n                    if(s[j] >= \\'0\\' && s[j] <= \\'9\\'){\\n                        t.push_back(s[j]);\\n                    }\\n                    else{\\n                        i = j - 1;\\n                        break;\\n                    }\\n                }\\n                int num = stoi(t);\\n                m.push(num);\\n            }\\n            else if(s[i] == \\']\\'){\\n                int rep = m.top();\\n                m.pop();\\n                string temp = \"\";\\n                while(!st.empty() && st.top() != \\'[\\'){\\n                    temp += st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                reverse(temp.begin(),temp.end());\\n                string str = temp;\\n                for(int j = 1; j < rep; j++){\\n                    str += temp;\\n                }\\n\\n                if(!st.empty()){\\n                    for(int k = 0; k < str.size(); k++){\\n                        st.push(str[k]);\\n                    }\\n                }\\n                else{\\n                    ans += str;\\n                }\\n            }\\n            else{\\n                st.push(s[i]);\\n            }\\n        }\\n        string te = \"\";\\n        while(!st.empty()){\\n            te += st.top();\\n            st.pop();\\n        }\\n        reverse(te.begin(),te.end());\\n        ans += te;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        string ans = \"\";\\n        stack<char> st;\\n        stack<int> m;\\n        for(int i = 0; i < s.size() ; i++){\\n            if(s[i] >= \\'0\\' && s[i] <= \\'9\\'){\\n                string t = \"\";\\n                t.push_back(s[i]);\\n                for(int j = i+1 ; j < s.size();j++){\\n                    if(s[j] >= \\'0\\' && s[j] <= \\'9\\'){\\n                        t.push_back(s[j]);\\n                    }\\n                    else{\\n                        i = j - 1;\\n                        break;\\n                    }\\n                }\\n                int num = stoi(t);\\n                m.push(num);\\n            }\\n            else if(s[i] == \\']\\'){\\n                int rep = m.top();\\n                m.pop();\\n                string temp = \"\";\\n                while(!st.empty() && st.top() != \\'[\\'){\\n                    temp += st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                reverse(temp.begin(),temp.end());\\n                string str = temp;\\n                for(int j = 1; j < rep; j++){\\n                    str += temp;\\n                }\\n\\n                if(!st.empty()){\\n                    for(int k = 0; k < str.size(); k++){\\n                        st.push(str[k]);\\n                    }\\n                }\\n                else{\\n                    ans += str;\\n                }\\n            }\\n            else{\\n                st.push(s[i]);\\n            }\\n        }\\n        string te = \"\";\\n        while(!st.empty()){\\n            te += st.top();\\n            st.pop();\\n        }\\n        reverse(te.begin(),te.end());\\n        ans += te;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051710,
                "title": "stack-ts-solution",
                "content": "\\n# Code\\n```\\nfunction decodeString(s: string): string {\\n    const stack: [number, string][] = []\\n    let currentString = \\'\\'\\n    let currentMultiplier = 0\\n\\n    for (let ch of s) {\\n        if (ch === \\'[\\') {\\n            stack.push([currentMultiplier, currentString])\\n            currentMultiplier = 0\\n            currentString = \\'\\'\\n        } else if (ch === \\']\\') {\\n            const [prevMultiplier, prevString] = stack.pop()\\n            currentString = prevString + currentString.repeat(prevMultiplier)\\n        } else if (!isNaN(Number(ch))) {\\n            // it\\'s digit\\n            currentMultiplier = currentMultiplier*10 + +ch\\n        } else {\\n            // it\\'s a char\\n            currentString += ch\\n        }\\n    }\\n\\n    return currentString\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction decodeString(s: string): string {\\n    const stack: [number, string][] = []\\n    let currentString = \\'\\'\\n    let currentMultiplier = 0\\n\\n    for (let ch of s) {\\n        if (ch === \\'[\\') {\\n            stack.push([currentMultiplier, currentString])\\n            currentMultiplier = 0\\n            currentString = \\'\\'\\n        } else if (ch === \\']\\') {\\n            const [prevMultiplier, prevString] = stack.pop()\\n            currentString = prevString + currentString.repeat(prevMultiplier)\\n        } else if (!isNaN(Number(ch))) {\\n            // it\\'s digit\\n            currentMultiplier = currentMultiplier*10 + +ch\\n        } else {\\n            // it\\'s a char\\n            currentString += ch\\n        }\\n    }\\n\\n    return currentString\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2251889,
                "title": "c-recursion-clean-code-100-faster",
                "content": "class Solution {\\npublic:\\n\\n    string helper(string &s, int &i){\\n        string res;\\n        \\n        while(i < s.length() and s[i] != \\']\\'){\\n            if(!isdigit(s[i])){\\n                res += s[i++]; // if its a character just add to res.\\n            } else {\\n                int n = 0;\\n                \\n                while(i < s.length() and isdigit(s[i])){\\n                    n = n * 10 + s[i++] - \\'0\\'; \\n                }\\n                \\n                i++; // skip \\'[\\'\\n                string ans = helper(s, i);\\n                i++; // skip \\']\\'\\n                \\n                while(n-- > 0){\\n                    res += ans;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    string decodeString(string s) {\\n        int i = 0;\\n        string ans = helper(s, i);\\n        return ans;\\n    }\\n};\\n\\n**Time: O(N), Space: O(N) for storing result.**\\n\\nNote: For better understanding and learning, consider dry running the code yourself.\\nFor doubt or query comment below.\\n**PLEASE UPVOTE IF HELPFUL!!!**",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\n    string helper(string &s, int &i){\\n        string res;\\n        \\n        while(i < s.length() and s[i] != \\']\\'){\\n            if(!isdigit(s[i])){\\n                res += s[i++]; // if its a character just add to res.\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1651984,
                "title": "faster-than-99-07-python-with-stack",
                "content": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        #Time: O(n)\\n        #Space: O(n)\\n        stack = []\\n        \\n        for char in s:\\n            if char == \\']\\': #Only with \\']\\', do we start decoding strings\\n                encodedString, multiplier = \\'\\', \\'\\'\\n                \\n                #Inserting in them front of another maintains the original order\\n                while len(stack) and stack[-1].isalpha():\\n                    encodedString = stack.pop() + encodedString\\n                stack.pop() #Dispose of \\'[\\'\\n                \\n                while len(stack) and stack[-1].isdigit():\\n                    multiplier = stack.pop() + multiplier\\n                \\n                stack.append(encodedString * int(multiplier))\\n            else:\\n                stack.append(char)\\n                \\n        return \\'\\'.join(stack)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        #Time: O(n)\\n        #Space: O(n)\\n        stack = []\\n        \\n        for char in s:\\n            if char == \\']\\': #Only with \\']\\', do we start decoding strings\\n                encodedString, multiplier = \\'\\', \\'\\'\\n                \\n                #Inserting in them front of another maintains the original order\\n                while len(stack) and stack[-1].isalpha():\\n                    encodedString = stack.pop() + encodedString\\n                stack.pop() #Dispose of \\'[\\'\\n                \\n                while len(stack) and stack[-1].isdigit():\\n                    multiplier = stack.pop() + multiplier\\n                \\n                stack.append(encodedString * int(multiplier))\\n            else:\\n                stack.append(char)\\n                \\n        return \\'\\'.join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1167364,
                "title": "concise-and-simple-recursive-solution",
                "content": "My intuition is the same as the rest but I think my implementation is simpler. \\n\\n1. If digit, calculate the multiplier\\n2. If opening bracket, recurse (more on this in a bit)\\n3. If closing bracket, base case so return. \\n4. Otherwise, just collect the char local result\\n\\nIn the recursion, I pass in the current value of index and return the final value from recursion. Makes it really simple I believe. Once returned, multiply, append, and update the index to the last location from the recursion. Don\\'t forget to reset the multiplier number otherwise it would keep on growing. \\n\\nHope you like it. \\n\\n```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:                         \\n        \\n        def recurse(s, pos):       \\n            result = \"\"\\n            i, num = pos, 0\\n            \\n            while i < len(s):\\n                c = s[i]\\n                if c.isdigit():\\n                    num = num * 10 + int(c)\\n                elif c == \\'[\\':\\n                    string, end = recurse(s, i + 1)\\n                    result += num * string\\n                    i = end\\n                    num = 0\\n                elif c == \\']\\':\\n                    return result, i\\n                else:\\n                    result += c\\n                i += 1\\n            \\n            return result, i\\n                \\n        return recurse(s, 0)[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:                         \\n        \\n        def recurse(s, pos):       \\n            result = \"\"\\n            i, num = pos, 0\\n            \\n            while i < len(s):\\n                c = s[i]\\n                if c.isdigit():\\n                    num = num * 10 + int(c)\\n                elif c == \\'[\\':\\n                    string, end = recurse(s, i + 1)\\n                    result += num * string\\n                    i = end\\n                    num = 0\\n                elif c == \\']\\':\\n                    return result, i\\n                else:\\n                    result += c\\n                i += 1\\n            \\n            return result, i\\n                \\n        return recurse(s, 0)[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941553,
                "title": "rust-stack-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn decode_string(s: String) -> String {\\n        let mut stack: Vec<(usize, String)> = Vec::new();\\n        let (mut n, mut str) = (0, String::new());\\n        for c in s.chars() {\\n            match c {\\n                \\'[\\' => {\\n                    stack.push((n, str.clone()));\\n                    n = 0;\\n                    str.clear();\\n                }\\n                \\']\\' => {\\n                    if let Some(last) = stack.pop() {\\n                        str = last.1 + str.repeat(last.0).as_str();\\n                    }\\n                }\\n                \\'0\\'..=\\'9\\' => n = n * 10 + (c as u8 - b\\'0\\') as usize,\\n                c => str.push(c),\\n            }\\n        }\\n        str\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Stack"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn decode_string(s: String) -> String {\\n        let mut stack: Vec<(usize, String)> = Vec::new();\\n        let (mut n, mut str) = (0, String::new());\\n        for c in s.chars() {\\n            match c {\\n                \\'[\\' => {\\n                    stack.push((n, str.clone()));\\n                    n = 0;\\n                    str.clear();\\n                }\\n                \\']\\' => {\\n                    if let Some(last) = stack.pop() {\\n                        str = last.1 + str.repeat(last.0).as_str();\\n                    }\\n                }\\n                \\'0\\'..=\\'9\\' => n = n * 10 + (c as u8 - b\\'0\\') as usize,\\n                c => str.push(c),\\n            }\\n        }\\n        str\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 714732,
                "title": "python-solution-using-stacks-o-n",
                "content": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        # instantiate stacks to store the number and the string to repeat.\\n        repeatStr = []\\n        numRepeat = []\\n        \\n        # initialize empty strings. One to store a multidigit number and other one to store the decoded string. \\n        tempNum = \\'\\'\\n        decodedStr = \\'\\'        \\n        \\n        # start iterating throught the encoded string\\n        for char in s:\\n            # check if the char is a digit. \\n            if char.isdigit():\\n                tempNum += char # add the number to tempNum\\n                \\n            # check if the char is an opening bracket\\n            elif char == \\'[\\':\\n                repeatStr.append(decodedStr)\\n                numRepeat.append(tempNum)\\n                tempNum = \\'\\'\\n                decodedStr = \\'\\'\\n                \\n            # check when the bracket closes\\n            elif char == \\']\\':\\n                decodedStr = repeatStr.pop() + (decodedStr * int(numRepeat.pop()))\\n                \\n            # else build the substring to repeat\\n            else:\\n                decodedStr += char            \\n                \\n        return decodedStr\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        # instantiate stacks to store the number and the string to repeat.\\n        repeatStr = []\\n        numRepeat = []\\n        \\n        # initialize empty strings. One to store a multidigit number and other one to store the decoded string. \\n        tempNum = \\'\\'\\n        decodedStr = \\'\\'        \\n        \\n        # start iterating throught the encoded string\\n        for char in s:\\n            # check if the char is a digit. \\n            if char.isdigit():\\n                tempNum += char # add the number to tempNum\\n                \\n            # check if the char is an opening bracket\\n            elif char == \\'[\\':\\n                repeatStr.append(decodedStr)\\n                numRepeat.append(tempNum)\\n                tempNum = \\'\\'\\n                decodedStr = \\'\\'\\n                \\n            # check when the bracket closes\\n            elif char == \\']\\':\\n                decodedStr = repeatStr.pop() + (decodedStr * int(numRepeat.pop()))\\n                \\n            # else build the substring to repeat\\n            else:\\n                decodedStr += char            \\n                \\n        return decodedStr\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 629715,
                "title": "java-solution-with-two-stacks-beats-100",
                "content": "Use two stacks - one for the numbers and another for the prefixes.\\nReuse the same StringBuilder instance.\\n\\n```\\nclass Solution {\\n    public String decodeString(String s) {\\n        Stack<String> prefixes = new Stack<>();\\n        Stack<Integer> numbers = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (Character.isDigit(c)) {\\n                int number = 0;\\n                while (Character.isDigit(s.charAt(i))) {\\n                    number = number*10 + (s.charAt(i) - \\'0\\');\\n                    i++;\\n                }\\n                numbers.push(number);\\n                prefixes.push(sb.toString());\\n                sb.setLength(0);\\n                // the loop increment i++ skips the next opening bracket\\n            } else if (c == \\']\\') {\\n                String inner = sb.toString();\\n                sb.setLength(0);\\n                sb.append(prefixes.pop());\\n                int number = numbers.pop();\\n                for (int j = 0; j < number; j++) {\\n                    sb.append(inner);\\n                }\\n            } else {// a regular character\\n                sb.append(c);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeString(String s) {\\n        Stack<String> prefixes = new Stack<>();\\n        Stack<Integer> numbers = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (Character.isDigit(c)) {\\n                int number = 0;\\n                while (Character.isDigit(s.charAt(i))) {\\n                    number = number*10 + (s.charAt(i) - \\'0\\');\\n                    i++;\\n                }\\n                numbers.push(number);\\n                prefixes.push(sb.toString());\\n                sb.setLength(0);\\n                // the loop increment i++ skips the next opening bracket\\n            } else if (c == \\']\\') {\\n                String inner = sb.toString();\\n                sb.setLength(0);\\n                sb.append(prefixes.pop());\\n                int number = numbers.pop();\\n                for (int j = 0; j < number; j++) {\\n                    sb.append(inner);\\n                }\\n            } else {// a regular character\\n                sb.append(c);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 617892,
                "title": "easy-understand-o-n-explanation-stack",
                "content": "\\tclass Solution:\\n\\t\\tdef decodeString(self, s: str) -> str:\\n\\t\\t\\t# if string is None\\n\\t\\t\\tif not s:\\n\\t\\t\\t\\treturn s\\n\\n\\t\\t\\t# stack for stirng\\n\\t\\t\\tstring_stack = []\\n\\t\\t\\t# stack for integer\\n\\t\\t\\tnum_stack = []\\n\\n\\t\\t\\t# result \\n\\t\\t\\tres = \\'\\'\\n\\t\\t\\t# handle the num\\n\\t\\t\\tnum = 0\\n\\n\\t\\t\\t# four situations: \\n\\t\\t\\t# 1. integer\\n\\t\\t\\t# 2. letter\\n\\t\\t\\t# 3. left square bracket \\n\\t\\t\\t# 4. right square bracket \\n\\n\\t\\t\\t# push & pop data\\n\\t\\t\\tfor index in range(len(s)):\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# Situation 1: digit\\n\\t\\t\\t\\tif s[index].isdigit():\\n\\t\\t\\t\\t\\t# put all of the digit together and get the num\\n\\t\\t\\t\\t\\tnum = num*10 + int(s[index])\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t# Situation 3: left square bracket\\n\\t\\t\\t\\telif  s[index] == \\'[\\':\\n\\t\\t\\t\\t\\t# means there is no more num, so push to num stack\\n\\t\\t\\t\\t\\tnum_stack.append(num)\\n\\t\\t\\t\\t\\t# and reset the num \\n\\t\\t\\t\\t\\tnum = 0\\n\\n\\t\\t\\t\\t\\t# put exisit (temp)res to string_stack and rest it\\n\\t\\t\\t\\t\\tstring_stack.append(res)\\n\\t\\t\\t\\t\\tres = \\'\\'\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t# Situation 4: right square bracket\\n\\t\\t\\t\\t# pop num & string: add string on res\\n\\t\\t\\t\\telif s[index] == \\']\\':\\n\\t\\t\\t\\t\\tres = string_stack.pop() + res * num_stack.pop()\\n\\t\\t\\n\\t\\t\\t\\t# Situation 2: letter\\n\\t\\t\\t\\t# do the easiest part: situation 2 first\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres += s[index]\\n\\n\\n\\t\\t\\treturn res\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Stack"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef decodeString(self, s: str) -> str:\\n\\t\\t\\t# if string is None\\n\\t\\t\\tif not s:\\n\\t\\t\\t\\treturn s\\n\\n\\t\\t\\t# stack for stirng\\n\\t\\t\\tstring_stack = []\\n\\t\\t\\t# stack for integer\\n\\t\\t\\tnum_stack = []\\n\\n\\t\\t\\t# result \\n\\t\\t\\tres = \\'\\'\\n\\t\\t\\t# handle the num\\n\\t\\t\\tnum = 0\\n\\n\\t\\t\\t# four situations: \\n\\t\\t\\t# 1. integer\\n\\t\\t\\t# 2. letter\\n\\t\\t\\t# 3. left square bracket \\n\\t\\t\\t# 4. right square bracket \\n\\n\\t\\t\\t# push & pop data\\n\\t\\t\\tfor index in range(len(s)):\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# Situation 1: digit\\n\\t\\t\\t\\tif s[index].isdigit():\\n\\t\\t\\t\\t\\t# put all of the digit together and get the num\\n\\t\\t\\t\\t\\tnum = num*10 + int(s[index])\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t# Situation 3: left square bracket\\n\\t\\t\\t\\telif  s[index] == \\'[\\':\\n\\t\\t\\t\\t\\t# means there is no more num, so push to num stack\\n\\t\\t\\t\\t\\tnum_stack.append(num)\\n\\t\\t\\t\\t\\t# and reset the num \\n\\t\\t\\t\\t\\tnum = 0\\n\\n\\t\\t\\t\\t\\t# put exisit (temp)res to string_stack and rest it\\n\\t\\t\\t\\t\\tstring_stack.append(res)\\n\\t\\t\\t\\t\\tres = \\'\\'\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t# Situation 4: right square bracket\\n\\t\\t\\t\\t# pop num & string: add string on res\\n\\t\\t\\t\\telif s[index] == \\']\\':\\n\\t\\t\\t\\t\\tres = string_stack.pop() + res * num_stack.pop()\\n\\t\\t\\n\\t\\t\\t\\t# Situation 2: letter\\n\\t\\t\\t\\t# do the easiest part: situation 2 first\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres += s[index]\\n\\n\\n\\t\\t\\treturn res\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 533390,
                "title": "java-clean-code-with-recursion",
                "content": "**Tips**\\nTo avoid global variable use the array with length 1\\n\\n```java\\npublic String decodeString(String s) {\\n\\tint[] index = new int[1];\\n\\tindex[0] = 0;\\n\\treturn decodeStringHelper(s, index);\\n}\\nprivate String decodeStringHelper(String s, int[] index) {\\n\\tStringBuilder sb = new StringBuilder();\\n\\tString num = \"\";\\n\\tfor (int i = index[0]; i < s.length(); i++) {\\n\\t\\tchar c = s.charAt(i);\\n\\t\\tif (c != \\'[\\' && c != \\']\\' && !Character.isDigit(c))\\n\\t\\t\\tsb.append(c);\\n\\t\\telse if (Character.isDigit(c))\\n\\t\\t\\tnum += c;\\n\\t\\telse if (c == \\'[\\') {\\n\\t\\t\\tindex[0] = i + 1;\\n\\t\\t\\tString next = decodeStringHelper(s, index);\\n\\t\\t\\tfor (int n = Integer.valueOf(num); n > 0; n--)\\n\\t\\t\\t\\tsb.append(next);\\n\\t\\t\\tnum = \"\";\\n\\t\\t\\ti = index[0];\\n\\t\\t} else if (c == \\']\\') {\\n\\t\\t\\tindex[0] = i;\\n\\t\\t\\treturn sb.toString();\\n\\t\\t}\\n\\t}\\n\\treturn sb.toString();\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "**Tips**\\nTo avoid global variable use the array with length 1\\n\\n```java\\npublic String decodeString(String s) {\\n\\tint[] index = new int[1];\\n\\tindex[0] = 0;\\n\\treturn decodeStringHelper(s, index);\\n}\\nprivate String decodeStringHelper(String s, int[] index) {\\n\\tStringBuilder sb = new StringBuilder();\\n\\tString num = \"\";\\n\\tfor (int i = index[0]; i < s.length(); i++) {\\n\\t\\tchar c = s.charAt(i);\\n\\t\\tif (c != \\'[\\' && c != \\']\\' && !Character.isDigit(c))\\n\\t\\t\\tsb.append(c);\\n\\t\\telse if (Character.isDigit(c))\\n\\t\\t\\tnum += c;\\n\\t\\telse if (c == \\'[\\') {\\n\\t\\t\\tindex[0] = i + 1;\\n\\t\\t\\tString next = decodeStringHelper(s, index);\\n\\t\\t\\tfor (int n = Integer.valueOf(num); n > 0; n--)\\n\\t\\t\\t\\tsb.append(next);\\n\\t\\t\\tnum = \"\";\\n\\t\\t\\ti = index[0];\\n\\t\\t} else if (c == \\']\\') {\\n\\t\\t\\tindex[0] = i;\\n\\t\\t\\treturn sb.toString();\\n\\t\\t}\\n\\t}\\n\\treturn sb.toString();\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 346959,
                "title": "golang-solution-using-recursion-with-my-analysis",
                "content": "After my [previous post](https://leetcode.com/problems/decode-string/discuss/346216/Golang-solution-using-2-stacks-with-my-thoughts-and-notes), I thought what if we can\\'t came up with a solution using stacks, then could we use recursion to solve the problem? The answer is yes.\\n\\nWe need to see the pattern of the encoded string.\\n`s = \"3[a2[c]]\", return \"accaccacc\". `\\nWhen we meet a `[ `, we will go deep into next level, which is where a recursion starts. When should we return from the recursion? That\\u2019s the time when we meet `]` .\\n\\n```\\nfunc decodeString(s string) string {\\n\\tr, _ := helper(s, 0)\\n\\treturn r\\n}\\n\\nfunc helper(s string, start int) (cur string, end int) {\\n\\tif len(s) == 0 {\\n\\t\\treturn \"\", 0\\n\\t}\\n\\tk := 0\\n\\ti := start\\n\\tfor i < len(s) {\\n\\t\\tch := string(s[i])\\n\\t\\tif n, err := strconv.Atoi(ch); err == nil {\\n\\t\\t\\tk = k*10 + n\\n\\t\\t} else if ch == \"[\" {\\n\\t\\t\\tdecoded, end := helper(s, i+1)\\n\\t\\t\\tcur += strings.Repeat(decoded, k)\\n\\t\\t\\ti = end\\n\\t\\t\\tk = 0\\n\\t\\t} else if ch == \"]\" {\\n\\t\\t\\t// this is the base case\\n\\t\\t\\treturn cur, i\\n\\t\\t} else {\\n\\t\\t\\tcur += ch\\n\\t\\t}\\n\\t\\ti++\\n\\t}\\n\\treturn cur, i\\n}\\n```\\n\\nAt this point, I would prefer recursion.",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "```\\nfunc decodeString(s string) string {\\n\\tr, _ := helper(s, 0)\\n\\treturn r\\n}\\n\\nfunc helper(s string, start int) (cur string, end int) {\\n\\tif len(s) == 0 {\\n\\t\\treturn \"\", 0\\n\\t}\\n\\tk := 0\\n\\ti := start\\n\\tfor i < len(s) {\\n\\t\\tch := string(s[i])\\n\\t\\tif n, err := strconv.Atoi(ch); err == nil {\\n\\t\\t\\tk = k*10 + n\\n\\t\\t} else if ch == \"[\" {\\n\\t\\t\\tdecoded, end := helper(s, i+1)\\n\\t\\t\\tcur += strings.Repeat(decoded, k)\\n\\t\\t\\ti = end\\n\\t\\t\\tk = 0\\n\\t\\t} else if ch == \"]\" {\\n\\t\\t\\t// this is the base case\\n\\t\\t\\treturn cur, i\\n\\t\\t} else {\\n\\t\\t\\tcur += ch\\n\\t\\t}\\n\\t\\ti++\\n\\t}\\n\\treturn cur, i\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 300067,
                "title": "14-lines-python-stack",
                "content": "```python\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        stack = [[\\'\\', 1, \\'\\']]\\n        a = n = \\'\\'\\n        for c in s:\\n            if c.isalpha():\\n                a += c\\n            elif c.isdigit():\\n                n += c\\n            elif c == \\'[\\':\\n                stack.append([a, int(n), \\'\\'])\\n                a = n = \\'\\'\\n            else:\\n                p, t, b = stack.pop()\\n                stack[-1][-1] += p + t * (b + a)\\n                a = \\'\\'\\n        return stack.pop()[-1] + a\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        stack = [[\\'\\', 1, \\'\\']]\\n        a = n = \\'\\'\\n        for c in s:\\n            if c.isalpha():\\n                a += c\\n            elif c.isdigit():\\n                n += c\\n            elif c == \\'[\\':\\n                stack.append([a, int(n), \\'\\'])\\n                a = n = \\'\\'\\n            else:\\n                p, t, b = stack.pop()\\n                stack[-1][-1] += p + t * (b + a)\\n                a = \\'\\'\\n        return stack.pop()[-1] + a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87705,
                "title": "java-one-pass-recursive-solution",
                "content": "```\\n/*\\n * Recursive. helper(s) consumes one layer of \"[ ]\".\\n */\\n    int idx;\\n    public String decodeString(String s) {\\n        idx = 0;\\n        return helper(s);\\n    }\\n    String helper(String s) {\\n        StringBuilder ans = new StringBuilder();\\n        for (int k = 0; idx < s.length(); ++idx) {\\n            char ch = s.charAt(idx);\\n            if (ch == '[') {\\n                ++idx;\\n                String str = helper(s);\\n                while (k > 0) {\\n                    ans.append(str);\\n                    --k;\\n                }\\n            } else if (ch == ']') {\\n                break;\\n            } else if (Character.isDigit(ch)) {\\n                k = k * 10 + ch - '0';\\n            } else ans.append(ch);\\n        }\\n        return ans.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n * Recursive. helper(s) consumes one layer of \"[ ]\".\\n */\\n    int idx;\\n    public String decodeString(String s) {\\n        idx = 0;\\n        return helper(s);\\n    }\\n    String helper(String s) {\\n        StringBuilder ans = new StringBuilder();\\n        for (int k = 0; idx < s.length(); ++idx) {\\n            char ch = s.charAt(idx);\\n            if (ch == '[') {\\n                ++idx;\\n                String str = helper(s);\\n                while (k > 0) {\\n                    ans.append(str);\\n                    --k;\\n                }\\n            } else if (ch == ']') {\\n                break;\\n            } else if (Character.isDigit(ch)) {\\n                k = k * 10 + ch - '0';\\n            } else ans.append(ch);\\n        }\\n        return ans.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3359679,
                "title": "java-stack-decode-string",
                "content": "\\n```\\nclass Solution {\\n    public int alphaDigtSearch(int finish, String sourse, ArrayList<String> stack, boolean isAlpha)\\n    {\\n        int start = finish;\\n\\n        if (isAlpha)\\n            while (finish < sourse.length() && Character.isAlphabetic(sourse.charAt(finish))) finish++;\\n        else\\n            while (finish < sourse.length() && Character.isDigit(sourse.charAt(finish))) finish++;\\n\\n        if (start != finish)\\n            stack.add(sourse.substring(start, finish));\\n        if (finish < sourse.length() && sourse.charAt(finish) == \\'[\\')\\n            finish++;\\n        return finish;\\n    }\\n\\n    public void stackWork(ArrayList<String> stack)\\n    {\\n        String str = null;\\n        int repeat;\\n        StringBuilder answ = new StringBuilder();\\n\\n        if (stack.size() > 0)\\n        {\\n            answ = new StringBuilder(stack.get(stack.size() - 1));\\n            stack.remove(stack.size() - 1);\\n        }\\n        while (stack.size() > 0 && !Character.isDigit(stack.get(stack.size() - 1).charAt(0))) {\\n            answ.insert(0, stack.get(stack.size() - 1));\\n            stack.remove(stack.size() - 1);\\n        }\\n        if (stack.size() > 0 && Character.isDigit(stack.get(stack.size() - 1).charAt(0)))\\n        {\\n            repeat = Integer.parseInt(stack.get(stack.size() - 1));\\n            stack.remove(stack.size() - 1);\\n            answ = repeat(answ, repeat);\\n        }\\n\\n        while (stack.size() > 0 && Character.isAlphabetic(stack.get(stack.size() - 1).charAt(0))) {\\n            answ.insert(0, stack.get(stack.size() - 1));\\n            stack.remove(stack.size() - 1);\\n        }\\n        stack.add(answ.toString());\\n    }\\n\\n    private StringBuilder repeat(StringBuilder answ, int i) {\\n        StringBuilder tmp = new StringBuilder();\\n        for (int j = 0; j < i; j++)\\n            tmp.append(answ);\\n        return tmp;\\n    }\\n\\n    public String decodeString(String s)\\n    {\\n        ArrayList<String> stack = new ArrayList<>();\\n        int finish = 0;\\n        finish = alphaDigtSearch(finish, s, stack, true);\\n        while (finish < s.length())\\n        {\\n            finish = alphaDigtSearch(finish, s, stack, false);\\n            finish = alphaDigtSearch(finish, s, stack, true);\\n            if (finish < s.length() && s.charAt(finish) == \\']\\') {\\n                stackWork(stack);\\n                finish++;\\n            }\\n        }\\n        if (stack.size() > 1)\\n            stackWork(stack);\\n        return stack.get(0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int alphaDigtSearch(int finish, String sourse, ArrayList<String> stack, boolean isAlpha)\\n    {\\n        int start = finish;\\n\\n        if (isAlpha)\\n            while (finish < sourse.length() && Character.isAlphabetic(sourse.charAt(finish))) finish++;\\n        else\\n            while (finish < sourse.length() && Character.isDigit(sourse.charAt(finish))) finish++;\\n\\n        if (start != finish)\\n            stack.add(sourse.substring(start, finish));\\n        if (finish < sourse.length() && sourse.charAt(finish) == \\'[\\')\\n            finish++;\\n        return finish;\\n    }\\n\\n    public void stackWork(ArrayList<String> stack)\\n    {\\n        String str = null;\\n        int repeat;\\n        StringBuilder answ = new StringBuilder();\\n\\n        if (stack.size() > 0)\\n        {\\n            answ = new StringBuilder(stack.get(stack.size() - 1));\\n            stack.remove(stack.size() - 1);\\n        }\\n        while (stack.size() > 0 && !Character.isDigit(stack.get(stack.size() - 1).charAt(0))) {\\n            answ.insert(0, stack.get(stack.size() - 1));\\n            stack.remove(stack.size() - 1);\\n        }\\n        if (stack.size() > 0 && Character.isDigit(stack.get(stack.size() - 1).charAt(0)))\\n        {\\n            repeat = Integer.parseInt(stack.get(stack.size() - 1));\\n            stack.remove(stack.size() - 1);\\n            answ = repeat(answ, repeat);\\n        }\\n\\n        while (stack.size() > 0 && Character.isAlphabetic(stack.get(stack.size() - 1).charAt(0))) {\\n            answ.insert(0, stack.get(stack.size() - 1));\\n            stack.remove(stack.size() - 1);\\n        }\\n        stack.add(answ.toString());\\n    }\\n\\n    private StringBuilder repeat(StringBuilder answ, int i) {\\n        StringBuilder tmp = new StringBuilder();\\n        for (int j = 0; j < i; j++)\\n            tmp.append(answ);\\n        return tmp;\\n    }\\n\\n    public String decodeString(String s)\\n    {\\n        ArrayList<String> stack = new ArrayList<>();\\n        int finish = 0;\\n        finish = alphaDigtSearch(finish, s, stack, true);\\n        while (finish < s.length())\\n        {\\n            finish = alphaDigtSearch(finish, s, stack, false);\\n            finish = alphaDigtSearch(finish, s, stack, true);\\n            if (finish < s.length() && s.charAt(finish) == \\']\\') {\\n                stackWork(stack);\\n                finish++;\\n            }\\n        }\\n        if (stack.size() > 1)\\n            stackWork(stack);\\n        return stack.get(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123975,
                "title": "java-solution-using-stack-beginner-friendly-heavily-commented",
                "content": "Kindly upvote if you find this solution useful :)\\n```\\npublic String decodeString(String s) {\\n        Stack<String> wordstk = new Stack<String>();   //to store characters present in the string\\n        Stack<Integer> intstk = new Stack<Integer>();  //to store integer values present in the string\\n        StringBuilder temp = new StringBuilder();  //storing the string\\n        int number = 0;   //stores the number of times temp has to be duplicated\\n        for(int i = 0; i < s.length();i++)\\n        {\\n            char c = s.charAt(i);\\n            if(Character.isDigit(c))    number = number * 10 + (c - \\'0\\');   //goes over digitwise and gives the number\\n            else if(Character.isLetter(c)) temp.append(c);\\n            else if(c == \\'[\\')   // denotes the start of another encoded string, so add temp and number to their respective stacks\\n            {\\n                intstk.add(number);\\n                wordstk.add(temp.toString());\\n                number = 0;\\n                temp = new StringBuilder();\\n            }\\n            else\\n            {\\n                int count = intstk.pop();\\n                StringBuilder dupe = new StringBuilder(wordstk.pop());\\n                for(int j = 1; j <= count;j++)    dupe.append(temp);\\n                temp = dupe;\\n            }\\n\\t\\t}\\n        return temp.toString();\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\npublic String decodeString(String s) {\\n        Stack<String> wordstk = new Stack<String>();   //to store characters present in the string\\n        Stack<Integer> intstk = new Stack<Integer>();  //to store integer values present in the string\\n        StringBuilder temp = new StringBuilder();  //storing the string\\n        int number = 0;   //stores the number of times temp has to be duplicated\\n        for(int i = 0; i < s.length();i++)\\n        {\\n            char c = s.charAt(i);\\n            if(Character.isDigit(c))    number = number * 10 + (c - \\'0\\');   //goes over digitwise and gives the number\\n            else if(Character.isLetter(c)) temp.append(c);\\n            else if(c == \\'[\\')   // denotes the start of another encoded string, so add temp and number to their respective stacks\\n            {\\n                intstk.add(number);\\n                wordstk.add(temp.toString());\\n                number = 0;\\n                temp = new StringBuilder();\\n            }\\n            else\\n            {\\n                int count = intstk.pop();\\n                StringBuilder dupe = new StringBuilder(wordstk.pop());\\n                for(int j = 1; j <= count;j++)    dupe.append(temp);\\n                temp = dupe;\\n            }\\n\\t\\t}\\n        return temp.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2628412,
                "title": "c-solution-with-explanation-using-recursion",
                "content": "This is the standard solution given under the tab \\'Solution\\' of the same problem: https://leetcode.com/problems/decode-string/solution/\\nWe start with the original string s and index = 0. If the index is not \\']\\', meaning its a digit or alphabet (but not \\'[\\' -> this is ensured in the later part of the code). Also note that the string won\\'t start with \\'[\\' so there is no chance of having it initially. \\nFirst lets take the case when the string isdigit. In that case, count the number of times the inner string need to be repeated. For example 26[X], string X will be repeated 26 times and 26 is stored in k. Now increment the index -> this is done as we know that number will be accompanied by [. \\nNow recurse on the inner string s and also increment index, this time for ]. While recursing for inner string, if the character is not digit, we store that and return it as a string. Now remember this inner string needs to be repeated \\'k\\' times so we add that to current return string \\'ret\\'. Return the ret string.\\n\\n```\\nclass Solution {\\npublic:\\n    string recurse(string &s, int &index)\\n    {\\n        string ret;\\n        while(index<s.length() && s[index]!=\\']\\')\\n        {\\n            if(!isdigit(s[index]))\\n                ret+=s[index++];\\n            else\\n            {\\n                int k=0;\\n                while(index<s.length()&&isdigit(s[index]))\\n                    k = k*10 + s[index++]-\\'0\\';\\n                index++; //because digit always accompained by \\'[\\'\\n                string dec = recurse(s, index);\\n                index++; //and accompanied by a closing \\']\\' too\\n                while(k-- > 0)\\n                    ret+=dec;\\n            }\\n        }\\n        return ret;\\n    }\\n    string decodeString(string s) {\\n        int index = 0;\\n        return recurse(s, index);\\n        \\n    }\\n};\\n```\\nTime complexity: O(max(K).N) //as maximum repeatitions are bounded by max(K)\\nSpace complexity: O(N) //N = length of the string",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string recurse(string &s, int &index)\\n    {\\n        string ret;\\n        while(index<s.length() && s[index]!=\\']\\')\\n        {\\n            if(!isdigit(s[index]))\\n                ret+=s[index++];\\n            else\\n            {\\n                int k=0;\\n                while(index<s.length()&&isdigit(s[index]))\\n                    k = k*10 + s[index++]-\\'0\\';\\n                index++; //because digit always accompained by \\'[\\'\\n                string dec = recurse(s, index);\\n                index++; //and accompanied by a closing \\']\\' too\\n                while(k-- > 0)\\n                    ret+=dec;\\n            }\\n        }\\n        return ret;\\n    }\\n    string decodeString(string s) {\\n        int index = 0;\\n        return recurse(s, index);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2611211,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    int i = 0;\\n\\n    public String decodeString(String s) {\\n        int count = 0;\\n        StringBuilder sb = new StringBuilder();\\n        while (i < s.length()) {\\n            char c = s.charAt(i);\\n            i++;\\n            if (Character.isLetter(c)) {\\n                sb.append(c);\\n            } else if (Character.isDigit(c)) {\\n                count = count * 10 + Character.getNumericValue(c);\\n            } else if (c == \\']\\') {\\n                break;\\n            } else if (c == \\'[\\') {\\n                // sub problem\\n                String repeat = decodeString(s);\\n                while (count > 0) {\\n                    sb.append(repeat);\\n                    count--;\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    int i = 0;\\n\\n    public String decodeString(String s) {\\n        int count = 0;\\n        StringBuilder sb = new StringBuilder();\\n        while (i < s.length()) {\\n            char c = s.charAt(i);\\n            i++;\\n            if (Character.isLetter(c)) {\\n                sb.append(c);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2595784,
                "title": "simple-recursive-c-solution-with-explanation-0-ms-100",
                "content": "First, we have to find an opening bracket from the end. This is due to the fact that the brackets can be stacked within each other. The right-most opening bracket is guaranteed to be the innermost one.\\n\\n```c++\\nint first = s.rfind(\\'[\\');\\n```\\n\\nIf no opening bracket exists, we can return the initial string, otherwise, we should find the matching closing bracket, which is guaranteed to be the one after the opening bracket.\\n\\n```c++\\nif (first == string::npos) return s;\\nint second = s.find(\\']\\', first + 1);\\n```\\n\\nAfter finding the brackets, we now have to find `k`, which is the amount of repetitions for the value inside the brackets. For this, we can search backward until we reach a non-digit, or the beginning of the string.\\n\\n```c++\\nint kLength = 1;\\nfor (;; ++kLength) {\\n\\tif (first - kLength < 0 || !isdigit(s[first - kLength])) {\\n\\t\\t--kLength;\\n\\t\\tbreak;\\n\\t}\\n}\\n```\\n\\nAfter our search is complete, we can convert the found string to an integer using `stoi`.\\n\\n```c++\\nint k = stoi(s.substr(first - kLength, kLength));\\n```\\n\\nNow that we have the values for the `k` and the encoded string, we can split `s` into three parts: \\n- Before `k` and the encoded string\\n- The encoded string repeated `k` times\\n- After `k` and the encoded string\\n\\nTo find the before and after strings, we can use\\n\\n```c++\\nstring before = s.substr(0, first - kLength);\\nstring after = s.substr(second + 1);\\n```\\n\\nTo get the encoded string repeated `k` times, we can use\\n\\n```c++\\nstring decoded = \"\";\\nstring substr = s.substr(first + 1, second - first - 1);\\nfor (int i = 0; i < k; ++i) {\\n\\tdecoded += substr;\\n}\\n```\\n\\nand reconstruct `s` using\\n\\n```c++\\ns = before + decoded + after;\\n```\\n\\nWe then will apply this operation recursively until no brackets remain, and return the `s` value.\\n\\n```c++\\nreturn decodeString(s);\\n```\\n\\nThe overall code can be found below. Note that we are using the reference value of `s`, using `&` operator. This is due to the fact that we are changing the value of `s` in each iteration.\\n\\n```c++\\nstring decodeString(string& s) {\\n\\tint first = s.rfind(\\'[\\');\\n\\tif (first == string::npos) return s;\\n\\tint second = s.find(\\']\\', first + 1);\\n\\n\\tint kLength = 1;\\n\\tfor (;; ++kLength) {\\n\\t\\tif (first - kLength < 0 || !isdigit(s[first - kLength])) {\\n\\t\\t\\t--kLength;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tint k = stoi(s.substr(first - kLength, kLength));\\n\\n\\tstring before = s.substr(0, first - kLength);\\n\\tstring after = s.substr(second + 1);\\n\\n\\tstring decoded = \"\";\\n\\tstring substr = s.substr(first + 1, second - first - 1);\\n\\tfor (int i = 0; i < k; ++i) {\\n\\t\\tdecoded += substr;\\n\\t}\\n\\n\\ts = before + decoded + after;\\n\\n\\treturn decodeString(s);\\n}\\n```\\n\\nHope this helped you! Good luck on your interview.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```c++\\nint first = s.rfind(\\'[\\');\\n```\n```c++\\nif (first == string::npos) return s;\\nint second = s.find(\\']\\', first + 1);\\n```\n```c++\\nint kLength = 1;\\nfor (;; ++kLength) {\\n\\tif (first - kLength < 0 || !isdigit(s[first - kLength])) {\\n\\t\\t--kLength;\\n\\t\\tbreak;\\n\\t}\\n}\\n```\n```c++\\nint k = stoi(s.substr(first - kLength, kLength));\\n```\n```c++\\nstring before = s.substr(0, first - kLength);\\nstring after = s.substr(second + 1);\\n```\n```c++\\nstring decoded = \"\";\\nstring substr = s.substr(first + 1, second - first - 1);\\nfor (int i = 0; i < k; ++i) {\\n\\tdecoded += substr;\\n}\\n```\n```c++\\ns = before + decoded + after;\\n```\n```c++\\nreturn decodeString(s);\\n```\n```c++\\nstring decodeString(string& s) {\\n\\tint first = s.rfind(\\'[\\');\\n\\tif (first == string::npos) return s;\\n\\tint second = s.find(\\']\\', first + 1);\\n\\n\\tint kLength = 1;\\n\\tfor (;; ++kLength) {\\n\\t\\tif (first - kLength < 0 || !isdigit(s[first - kLength])) {\\n\\t\\t\\t--kLength;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tint k = stoi(s.substr(first - kLength, kLength));\\n\\n\\tstring before = s.substr(0, first - kLength);\\n\\tstring after = s.substr(second + 1);\\n\\n\\tstring decoded = \"\";\\n\\tstring substr = s.substr(first + 1, second - first - 1);\\n\\tfor (int i = 0; i < k; ++i) {\\n\\t\\tdecoded += substr;\\n\\t}\\n\\n\\ts = before + decoded + after;\\n\\n\\treturn decodeString(s);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1861915,
                "title": "c-simple-and-clean-solution-with-comments-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) \\n    {\\n        // encoding rule is k[encoded_string]\\n        stack<string> chars; // stack for keeping track of the already decoded string\\n        stack<int> nums; // stack for k\\n        string res;\\n        int num = 0;\\n        \\n        //Iterate through every single character in s -->o(n); n is size of s\\n        for(char c : s) {\\n            /*\\n            There are 4 possible states that we can see\\n            (1) number --> use built in isdigit(char)\\n            (2) alphabet --> use built in isaplha(char)\\n                >> Just add the character to the result if we see a letter\\n            (3) \\'[\\' -->just compare with that char\\n            (4) \\']\\' --> just compare with that char\\n            */\\n            if(isdigit(c)) \\n            {\\n                num = num*10 + (c-\\'0\\');  // coverts the string number to integer\\n                // Note that we need to handle cases like 22[a], this is just using increasing the place value by one and then adding the single digit to the ones place value\\n            }\\n            else if(isalpha(c)) \\n            { // check if character is a letter\\n                res.push_back(c);            \\n            }\\n            else if(c == \\'[\\') \\n            { // From the encoding rule, we are guaranteed a number\\n                // prior to \\'[\\' and an encoded_string after \\'[\\'\\n                // Hence we can push all number and encoded_string to their stacks\\n                \\n                chars.push(res); // put the encoded_string to stack\\n                nums.push(num); // put the number into the stack\\n                \\n                // reset back to default \\n                res = \"\";\\n                num = 0;\\n            }\\n            else if(c == \\']\\') \\n            {\\n                // every time we see \\']\\' we are guaranteed to have finished a set of \\n                // k[encoded_string]. Hence we can start processing the stacks                       // emptying them and moving it to res.  \\n                \\n                string tmp = res; \\n                for(int i=0; i<nums.top()-1; i++) res += tmp;\\n                \\n                res = chars.top() + res;\\n                chars.pop(); \\n                nums.pop();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) \\n    {\\n        // encoding rule is k[encoded_string]\\n        stack<string> chars; // stack for keeping track of the already decoded string\\n        stack<int> nums; // stack for k\\n        string res;\\n        int num = 0;\\n        \\n        //Iterate through every single character in s -->o(n); n is size of s\\n        for(char c : s) {\\n            /*\\n            There are 4 possible states that we can see\\n            (1) number --> use built in isdigit(char)\\n            (2) alphabet --> use built in isaplha(char)\\n                >> Just add the character to the result if we see a letter\\n            (3) \\'[\\' -->just compare with that char\\n            (4) \\']\\' --> just compare with that char\\n            */\\n            if(isdigit(c)) \\n            {\\n                num = num*10 + (c-\\'0\\');  // coverts the string number to integer\\n                // Note that we need to handle cases like 22[a], this is just using increasing the place value by one and then adding the single digit to the ones place value\\n            }\\n            else if(isalpha(c)) \\n            { // check if character is a letter\\n                res.push_back(c);            \\n            }\\n            else if(c == \\'[\\') \\n            { // From the encoding rule, we are guaranteed a number\\n                // prior to \\'[\\' and an encoded_string after \\'[\\'\\n                // Hence we can push all number and encoded_string to their stacks\\n                \\n                chars.push(res); // put the encoded_string to stack\\n                nums.push(num); // put the number into the stack\\n                \\n                // reset back to default \\n                res = \"\";\\n                num = 0;\\n            }\\n            else if(c == \\']\\') \\n            {\\n                // every time we see \\']\\' we are guaranteed to have finished a set of \\n                // k[encoded_string]. Hence we can start processing the stacks                       // emptying them and moving it to res.  \\n                \\n                string tmp = res; \\n                for(int i=0; i<nums.top()-1; i++) res += tmp;\\n                \\n                res = chars.top() + res;\\n                chars.pop(); \\n                nums.pop();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635529,
                "title": "fastest-solution-0ms-well-explained-c-recursion",
                "content": "This solutin can be very fast with recusrion.\\nLets take an example...\\n\\n![image](https://assets.leetcode.com/users/images/b5116ec6-72cf-414f-b0cc-d9efd5f3d4d9_1639896946.4418724.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    string solve(const string &s, int &i)\\n    {\\n        string z;\\n        \\n        while(i<s.size() && s[i]!=\\']\\')\\n        {\\n\\t\\t\\t// This loop will continue till we get \\']\\'\\n            if(isdigit(s[i]))\\n            {\\n                int k=0;\\n                \\n                while(i<s.size() && isdigit(s[i]))\\n                {\\n                    k=k*10 +(s[i++]-\\'0\\'); // For numbers like 12,100,1212....\\n                }\\n                \\n                i++; // For \\'[\\'\\n                \\n                string t=solve(s,i); // string got from recursion\\n                \\n                i++; // For \\']\\'\\n                \\n                while(k--)\\n                {\\n                    z+=t; // Adding string got from recursion k*(string)...\\n                }      \\n            }\\n            else\\n                z+=s[i++]; // Adding string which are before digits.\\n        }\\n        return z;\\n    }\\n    \\n    string decodeString(string s) \\n    {\\n        int i=0;\\n        return solve(s,i);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string solve(const string &s, int &i)\\n    {\\n        string z;\\n        \\n        while(i<s.size() && s[i]!=\\']\\')\\n        {\\n\\t\\t\\t// This loop will continue till we get \\']\\'\\n            if(isdigit(s[i]))\\n            {\\n                int k=0;\\n                \\n                while(i<s.size() && isdigit(s[i]))\\n                {\\n                    k=k*10 +(s[i++]-\\'0\\'); // For numbers like 12,100,1212....\\n                }\\n                \\n                i++; // For \\'[\\'\\n                \\n                string t=solve(s,i); // string got from recursion\\n                \\n                i++; // For \\']\\'\\n                \\n                while(k--)\\n                {\\n                    z+=t; // Adding string got from recursion k*(string)...\\n                }      \\n            }\\n            else\\n                z+=s[i++]; // Adding string which are before digits.\\n        }\\n        return z;\\n    }\\n    \\n    string decodeString(string s) \\n    {\\n        int i=0;\\n        return solve(s,i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1452908,
                "title": "easy-to-understand-javascript-solution-using-stack",
                "content": "```\\nvar decodeString = function(s) {\\n    const stack = [];\\n    \\n    for (let letter of s) {\\n        if (letter != \"]\") {\\n            stack.push(letter);\\n        } else {\\n            let substr = \"\";\\n            while (stack[stack.length - 1] != \"[\")\\n                substr = stack.pop() + substr;\\n            \\n            // remove closing open bracket\\n            stack.pop();\\n            \\n            let k = \"\";\\n            \\n            while (stack.length && /^\\\\d+$/.test(stack[stack.length - 1])) \\n                k = stack.pop() + k;\\n\\n            stack.push(substr.repeat(Number(k)))            \\n        }\\n    }\\n    \\n    return stack.join(\"\");\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nvar decodeString = function(s) {\\n    const stack = [];\\n    \\n    for (let letter of s) {\\n        if (letter != \"]\") {\\n            stack.push(letter);\\n        } else {\\n            let substr = \"\";\\n            while (stack[stack.length - 1] != \"[\")\\n                substr = stack.pop() + substr;\\n            \\n            // remove closing open bracket\\n            stack.pop();\\n            \\n            let k = \"\";\\n            \\n            while (stack.length && /^\\\\d+$/.test(stack[stack.length - 1])) \\n                k = stack.pop() + k;\\n\\n            stack.push(substr.repeat(Number(k)))            \\n        }\\n    }\\n    \\n    return stack.join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1450881,
                "title": "js-using-stack-o-n-time-and-space",
                "content": "```\\nfunction decodeString(s) {\\n\\t// stack is used to maintain the string that is decoded already and the count of the current string into consideration\\n    const stack = [];\\n\\tlet currStr = \\'\\', k = 0;\\n\\t\\n\\t// iterating through each character in the string\\n    for(let idx = 0; idx < s.length; ++idx) {    // O(n)\\n        const char = s[idx];\\n        if(char === \\'[\\') {\\n\\t\\t// if the char is `[`, that means the following string is encoded string, so we add the previous string and k (already processed) to the stack \\n            stack.push([currStr, k]);\\n            currStr = \\'\\';    // reset the value before the following string\\n            k = 0;\\n        } else if(char === \\']\\') {\\n\\t\\t// if the char is `]`, we have processed the encoded string, and we need to append it k times to the previous string (we can get these values from the stack - LIFO)\\n            const [prevStr, times] = stack.pop();\\n            currStr = prevStr + currStr.repeat(times);\\n        } else if(char.charCodeAt(0) >= 48 && char.charCodeAt(0) <= 57) {\\n\\t\\t// if the char is a digit, update the value of k\\n            k = k * 10 + parseInt(char);\\n        } else {\\n\\t\\t// otherwise, the char is a letter, we can append it to the currStr (which is the curr string into consideration) \\n            currStr += char;\\n        }\\n    }\\n    return currStr;    // after the loop finishes, currStr will be the resultant decoded string\\n}\\n```\\n\\nTime Complexity = O(m)\\nSpace Complexity = O(m) [stack]\\n[m - length of the output string]\\n\\n-----\\n\\nEdit: `Intuitive approach`\\n\\nThe encoded part will be of structure: `k[encoded_str]`\\nIf we start iterating the input string, number `k` will always be followed by `[` which will be followed by another number of a character.\\n\\n```\\nvar decodeString = function(s) {\\n    const stack = [];\\n    let i = 0, num = 1, m = 10, curr_str = [];\\n    while(i < s.length) {\\n\\t\\t// constructing the number `k`\\n        num = 0;\\n        while(s[i] >= \\'0\\' && s[i] <= \\'9\\') {\\n            num = num * m + parseInt(s[i]);\\n            ++i;\\n        }\\n\\t\\t// a number is always followed by `[`\\n        if(s[i] === \\'[\\') {\\n\\t\\t\\t++i;\\n\\t\\t}\\n\\t\\t// add the number to the stack\\n        if(num) {\\n            stack.push(num);\\n        }\\n\\t\\t// `k[` can be followed either by another number or a string, in case of a string, this block will construct the complete string until we find another type of character\\n        curr_str = [];\\n        while(s[i] >= \\'a\\' && s[i] <= \\'z\\') {\\n            curr_str.push(s[i]);\\n            ++i;\\n        }\\n        if(curr_str.length) {\\n\\t\\t\\t// stack will always have a number followed by a string until all the decoding is done\\n\\t\\t\\t// so if the top value in the stack is another string, we prepend it to the curr_str before pushing the complete string into the stack\\n            if(stack.length && typeof stack[stack.length - 1] === \"string\") {\\n                stack.push(stack.pop() + curr_str.join(\\'\\'));\\n            } else {\\n                stack.push(curr_str.join(\\'\\'));\\n            }\\n        }\\n        if(s[i] === \\']\\') {\\n\\t\\t\\t// as mentioned above, stack will always have a number followed by a string\\n            let top_str = stack.pop(), count = stack.pop();\\n\\t\\t\\t// similarly, if top value is a string, we prepend it to the new decoded string before pushing the complete string into the stack\\n            const temp_str = [];\\n\\t\\t\\tif(stack.length && typeof stack[stack.length - 1] === \"string\") {\\n                temp_str.push(stack.pop());\\n            }\\n            while(count--) {    // O(k)\\n                temp_str.push(top_str);\\n            }\\n            stack.push(temp_str.join(\\'\\'));\\n            ++i;\\n        } \\n    }\\n\\t// if using pure stack then we cannot perform this, so we can have another block where we construct the result by popping chars from the stack and then reverse the order and join\\n    return stack.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nfunction decodeString(s) {\\n\\t// stack is used to maintain the string that is decoded already and the count of the current string into consideration\\n    const stack = [];\\n\\tlet currStr = \\'\\', k = 0;\\n\\t\\n\\t// iterating through each character in the string\\n    for(let idx = 0; idx < s.length; ++idx) {    // O(n)\\n        const char = s[idx];\\n        if(char === \\'[\\') {\\n\\t\\t// if the char is `[`, that means the following string is encoded string, so we add the previous string and k (already processed) to the stack \\n            stack.push([currStr, k]);\\n            currStr = \\'\\';    // reset the value before the following string\\n            k = 0;\\n        } else if(char === \\']\\') {\\n\\t\\t// if the char is `]`, we have processed the encoded string, and we need to append it k times to the previous string (we can get these values from the stack - LIFO)\\n            const [prevStr, times] = stack.pop();\\n            currStr = prevStr + currStr.repeat(times);\\n        } else if(char.charCodeAt(0) >= 48 && char.charCodeAt(0) <= 57) {\\n\\t\\t// if the char is a digit, update the value of k\\n            k = k * 10 + parseInt(char);\\n        } else {\\n\\t\\t// otherwise, the char is a letter, we can append it to the currStr (which is the curr string into consideration) \\n            currStr += char;\\n        }\\n    }\\n    return currStr;    // after the loop finishes, currStr will be the resultant decoded string\\n}\\n```\n```\\nvar decodeString = function(s) {\\n    const stack = [];\\n    let i = 0, num = 1, m = 10, curr_str = [];\\n    while(i < s.length) {\\n\\t\\t// constructing the number `k`\\n        num = 0;\\n        while(s[i] >= \\'0\\' && s[i] <= \\'9\\') {\\n            num = num * m + parseInt(s[i]);\\n            ++i;\\n        }\\n\\t\\t// a number is always followed by `[`\\n        if(s[i] === \\'[\\') {\\n\\t\\t\\t++i;\\n\\t\\t}\\n\\t\\t// add the number to the stack\\n        if(num) {\\n            stack.push(num);\\n        }\\n\\t\\t// `k[` can be followed either by another number or a string, in case of a string, this block will construct the complete string until we find another type of character\\n        curr_str = [];\\n        while(s[i] >= \\'a\\' && s[i] <= \\'z\\') {\\n            curr_str.push(s[i]);\\n            ++i;\\n        }\\n        if(curr_str.length) {\\n\\t\\t\\t// stack will always have a number followed by a string until all the decoding is done\\n\\t\\t\\t// so if the top value in the stack is another string, we prepend it to the curr_str before pushing the complete string into the stack\\n            if(stack.length && typeof stack[stack.length - 1] === \"string\") {\\n                stack.push(stack.pop() + curr_str.join(\\'\\'));\\n            } else {\\n                stack.push(curr_str.join(\\'\\'));\\n            }\\n        }\\n        if(s[i] === \\']\\') {\\n\\t\\t\\t// as mentioned above, stack will always have a number followed by a string\\n            let top_str = stack.pop(), count = stack.pop();\\n\\t\\t\\t// similarly, if top value is a string, we prepend it to the new decoded string before pushing the complete string into the stack\\n            const temp_str = [];\\n\\t\\t\\tif(stack.length && typeof stack[stack.length - 1] === \"string\") {\\n                temp_str.push(stack.pop());\\n            }\\n            while(count--) {    // O(k)\\n                temp_str.push(top_str);\\n            }\\n            stack.push(temp_str.join(\\'\\'));\\n            ++i;\\n        } \\n    }\\n\\t// if using pure stack then we cannot perform this, so we can have another block where we construct the result by popping chars from the stack and then reverse the order and join\\n    return stack.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1212911,
                "title": "best-and-simple-stack-solution-beats-100-submissions-0-ms",
                "content": "```\\nstring decodeString(string s) {\\n        stack<char> stk;\\n        string ans = \"\";\\n        string temp = \"\";\\n        string no;\\n        \\n        for(int i = 0 ; i < s.length() ; i++){\\n            if(s[i]==\\'[\\'){\\n                stk.push(\\'[\\');\\n            }\\n            else if(s[i] == \\']\\'){\\n                temp = \"\";\\n                no = \"\" ;\\n                while(stk.top()!=\\'[\\'){\\n                    temp += stk.top();\\n                    stk.pop();\\n                }\\n                stk.pop();\\n                reverse(temp.begin(),temp.end());\\n                while(!stk.empty() and (stk.top() - \\'0\\' <= 9 and stk.top() - \\'0\\' >= 0 )){\\n                    no += stk.top();\\n                    stk.pop();\\n                }\\n                int num = 0;\\n                int p = 1;\\n                for(int k = 0 ; k < no.length() ; k++){\\n                     int x = no[k] - \\'0\\';\\n                     num += x*p;\\n                     p = p*10;\\n                }           \\n                string ch = temp;\\n                while(num>1){\\n                    temp += ch;\\n                    num--;\\n                }\\n\\n                if(stk.empty()){\\n                    ans += temp;\\n                }\\n                else{\\n                    for(int j = 0 ; j < temp.length() ; j++){\\n                        stk.push(temp[j]);\\n                    }\\n                }\\n                \\n            }\\n            else{\\n                if(stk.empty() and ((s[i] - \\'0\\' < 0) or (s[i] - \\'0\\' > 9))){\\n                    ans += s[i];\\n                }\\n                else{\\n                    stk.push(s[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nstring decodeString(string s) {\\n        stack<char> stk;\\n        string ans = \"\";\\n        string temp = \"\";\\n        string no;\\n        \\n        for(int i = 0 ; i < s.length() ; i++){\\n            if(s[i]==\\'[\\'){\\n                stk.push(\\'[\\');\\n            }\\n            else if(s[i] == \\']\\'){\\n                temp = \"\";\\n                no = \"\" ;\\n                while(stk.top()!=\\'[\\'){\\n                    temp += stk.top();\\n                    stk.pop();\\n                }\\n                stk.pop();\\n                reverse(temp.begin(),temp.end());\\n                while(!stk.empty() and (stk.top() - \\'0\\' <= 9 and stk.top() - \\'0\\' >= 0 )){\\n                    no += stk.top();\\n                    stk.pop();\\n                }\\n                int num = 0;\\n                int p = 1;\\n                for(int k = 0 ; k < no.length() ; k++){\\n                     int x = no[k] - \\'0\\';\\n                     num += x*p;\\n                     p = p*10;\\n                }           \\n                string ch = temp;\\n                while(num>1){\\n                    temp += ch;\\n                    num--;\\n                }\\n\\n                if(stk.empty()){\\n                    ans += temp;\\n                }\\n                else{\\n                    for(int j = 0 ; j < temp.length() ; j++){\\n                        stk.push(temp[j]);\\n                    }\\n                }\\n                \\n            }\\n            else{\\n                if(stk.empty() and ((s[i] - \\'0\\' < 0) or (s[i] - \\'0\\' > 9))){\\n                    ans += s[i];\\n                }\\n                else{\\n                    stk.push(s[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1127720,
                "title": "ruby-stack-solution",
                "content": "```\\ndef decode_string(s)\\n  stack = []\\n  s.each_char do |c|\\n    if c == \\']\\'\\n      s1 = \\'\\'\\n      while stack.last != \\'[\\'\\n        s1 = stack.pop + s1\\n      end\\n      stack.pop # remove \\'[\\'\\n      n = \\'\\'\\n      while !stack.empty? && stack.last.match?(/[0-9]/) # eg. \"100[leetcode]\"\\n        n = stack.pop + n\\n      end\\n      stack.push(s1 * n.to_i)\\n    else\\n      stack.push(c)\\n    end\\n  end\\n  stack.join\\nend",
                "solutionTags": [
                    "Ruby",
                    "Stack"
                ],
                "code": "```\\ndef decode_string(s)\\n  stack = []\\n  s.each_char do |c|\\n    if c == \\']\\'\\n      s1 = \\'\\'\\n      while stack.last != \\'[\\'\\n        s1 = stack.pop + s1\\n      end\\n      stack.pop # remove \\'[\\'\\n      n = \\'\\'\\n      while !stack.empty? && stack.last.match?(/[0-9]/) # eg. \"100[leetcode]\"\\n        n = stack.pop + n\\n      end\\n      stack.push(s1 * n.to_i)\\n    else\\n      stack.push(c)\\n    end\\n  end\\n  stack.join\\nend",
                "codeTag": "Python3"
            },
            {
                "id": 989421,
                "title": "c-two-approaches-recursion-two-stack-time-o-n-space-o-n",
                "content": "**Recursive**\\nThis is a smart af solution, originally by @bluedawnstar (I guess). If you\\'re wondering why i needs to be passed as a reference, it is because, we are changing the instance of the i variable by calling it in the middle of decodeStringUtil. Try cout-ing the i when the i is passed as a value and as a reference. :)\\nTime Complexity: O (size of original string + size of the result string) ~ O (n)\\nSpace Complexity: O (n)\\n```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        int i = 0;\\n        return decodeStringUtil(s, i);\\n    }\\n    string decodeStringUtil (string s, int &i) {\\n        string res; \\n        while (i < s.length() && s[i] != \\']\\') {\\n\\n            if (!isdigit(s[i]))\\n                res += s[i++];\\n            else {\\n                int n = 0;\\n                while (i < s.length() && isdigit(s[i]))\\n                    n = n * 10 + s[i++] - \\'0\\';\\n                i++; \\n                string t = decodeStringUtil(s, i);\\n\\t\\t\\t\\t\\t\\t\\t\\t//cout<<i;\\n                i++; \\n                while (n--)\\n                    res += t;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Stack Based Solution**\\nTime Complexity: O (size of original string + size of the result string) ~ O (n)\\nSpace Complexity: O (n)\\n```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack <string> sString;\\n        stack <int> sInt; \\n        string res;\\n        int n=0;\\n        \\n        for (int i=0; i<s.size(); i++) {\\n            if (isdigit(s[i])) {\\n                    n=n*10+s[i]-\\'0\\';\\n            }\\n            else if (isalpha(s[i])) {\\n                res.push_back(s[i]);\\n            }\\n            else if (s[i]==\\'[\\') {\\n                sString.push(res);\\n                sInt.push(n);\\n                \\n                res=\"\";\\n                n=0;\\n            }\\n\\n            else if (s[i]==\\']\\'){\\n                string tmp = res;\\n                for(int i = 0; i < sInt.top()-1; ++i) {\\n                    res += tmp;\\n                }\\n                res = sString.top() + res;\\n                sString.pop(); sInt.pop();\\n            }\\n        }\\n    return res;\\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        int i = 0;\\n        return decodeStringUtil(s, i);\\n    }\\n    string decodeStringUtil (string s, int &i) {\\n        string res; \\n        while (i < s.length() && s[i] != \\']\\') {\\n\\n            if (!isdigit(s[i]))\\n                res += s[i++];\\n            else {\\n                int n = 0;\\n                while (i < s.length() && isdigit(s[i]))\\n                    n = n * 10 + s[i++] - \\'0\\';\\n                i++; \\n                string t = decodeStringUtil(s, i);\\n\\t\\t\\t\\t\\t\\t\\t\\t//cout<<i;\\n                i++; \\n                while (n--)\\n                    res += t;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack <string> sString;\\n        stack <int> sInt; \\n        string res;\\n        int n=0;\\n        \\n        for (int i=0; i<s.size(); i++) {\\n            if (isdigit(s[i])) {\\n                    n=n*10+s[i]-\\'0\\';\\n            }\\n            else if (isalpha(s[i])) {\\n                res.push_back(s[i]);\\n            }\\n            else if (s[i]==\\'[\\') {\\n                sString.push(res);\\n                sInt.push(n);\\n                \\n                res=\"\";\\n                n=0;\\n            }\\n\\n            else if (s[i]==\\']\\'){\\n                string tmp = res;\\n                for(int i = 0; i < sInt.top()-1; ++i) {\\n                    res += tmp;\\n                }\\n                res = sString.top() + res;\\n                sString.pop(); sInt.pop();\\n            }\\n        }\\n    return res;\\n      \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 941687,
                "title": "python-3-solution-explained-video-code",
                "content": "[](https://www.youtube.com/watch?v=-LNwE2E-8eE)\\nhttps://www.youtube.com/watch?v=-LNwE2E-8eE\\n```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        stack = [[\"\",1]]\\n        num = \"\"\\n        nums = [str(x) for x in range(10)]\\n        \\n        for char in s:\\n            if char in nums:\\n                num += char\\n            elif char == \"[\":\\n                stack.append([\"\", int(num)])\\n                num = \"\"\\n            elif char == \"]\":\\n                string_, k = stack.pop()\\n                stack[-1][0] += string_ * k\\n            else:\\n                stack[-1][0] += char\\n        \\n        return stack[-1][0]\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        stack = [[\"\",1]]\\n        num = \"\"\\n        nums = [str(x) for x in range(10)]\\n        \\n        for char in s:\\n            if char in nums:\\n                num += char\\n            elif char == \"[\":\\n                stack.append([\"\", int(num)])\\n                num = \"\"\\n            elif char == \"]\":\\n                string_, k = stack.pop()\\n                stack[-1][0] += string_ * k\\n            else:\\n                stack[-1][0] += char\\n        \\n        return stack[-1][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760318,
                "title": "c-solution-0ms-explanations-no-recursion-two-stacks",
                "content": "```\\nstruct node_times {\\n    int times;\\n    struct node_times* next;\\n};\\nstruct node_char {\\n    char c;\\n    struct node_char* next;\\n};\\nvoid push_num(struct node_times** head, int num) {\\n    struct node_times* new_node = (struct node_times*)malloc(sizeof(struct node_times));\\n    new_node->times = num;\\n    new_node->next = *head;\\n    *head = new_node;\\n}\\nvoid push_char(struct node_char** head, char c) {\\n    struct node_char* new_node = (struct node_char*)malloc(sizeof(struct node_char));\\n    new_node->c = c;\\n    new_node->next = *head;\\n    *head = new_node;\\n}\\nint pop_number(struct node_times** head) {\\n    struct node_times* tmp = *head;\\n    int ret_n = tmp->times;\\n    *head = (*head)->next;\\n    free(tmp);\\n    return ret_n;\\n}\\nchar pop_char(struct node_char** head) {\\n    struct node_char* tmp = *head;\\n    char ret_c = tmp->c;\\n    (*head) = (*head)->next;\\n    free(tmp);\\n    return ret_c;\\n}\\nint get_word_size(struct node_char* head) {\\n    int size = 0;\\n    while (head) {\\n        if (head->c == \\'[\\') break;\\n        size++;\\n        head = head->next;\\n    }\\n    return size;\\n}\\nchar* decodeString(char* s) {\\n    struct node_times* head_num_stack = NULL;\\n    struct node_char* head_char_stack = NULL;\\n    int i = 0;\\n    int w_size;\\n    int k;\\n    while (s[i]) {\\n        // if its a number push it to number\\'s stack\\n        if (s[i] >= \\'0\\' && s[i] <= \\'9\\') {\\n            int num = atoi(&s[i]);\\n            while (s[i] >= \\'0\\' && s[i] <= \\'9\\') i++;// increment index to pass by the number\\n            // push the number to numbers stack\\n            push_num(&head_num_stack, num);\\n        }\\n        else if (s[i] > \\'9\\' && s[i] != \\']\\') {\\n            // if its any letter but not \\']\\' then just push it to char stack\\n            push_char(&head_char_stack, s[i]);\\n            i++;\\n        }\\n        else if (s[i] == \\'[\\') {\\n            // if its an opnening bracket push it to char stack\\n            push_char(&head_char_stack, \\'[\\');\\n            i++;\\n        }\\n        else if (s[i] == \\']\\') {\\n            // here we need building word procedure to begin\\n            w_size = get_word_size(head_char_stack); // get word size\\n            int n_times = pop_number(&head_num_stack); // get how much we need to repeat the word\\n            char* word = (char*)malloc(w_size * sizeof(char));// allocate memory for word for temporary work\\n            // read word chars into temporary word, also empty it from chars stack\\n            for (k = 0; k < w_size; k++) {\\n                word[k] = pop_char(&head_char_stack);\\n            }\\n            // now we have the word we need to push it the multiplier amount of times:\\n            // we have to push it in reversed order because we pulled it from char stack ( which is reversed )\\n           \\n            pop_char(&head_char_stack); // get rid of the opening bracket at char stack - \\'[\\'\\n            // now we need to push the word n_times\\n            for (; n_times > 0; n_times--) {\\n                for (k = w_size - 1; k >= 0; k--) {\\n                    push_char(&head_char_stack, word[k]);\\n                }\\n            }\\n            free(word); // free the temp string\\n            i++;\\n        }\\n    }\\n    // now we have the complete decoded string at the char_stack, all we need to do is to pop it out char by char and then reverse the chars order!\\n\\t // and dont forget we need 1 null byte for ending string Muhahaha!\\n    w_size = get_word_size(head_char_stack);// get overall string size - how many chars\\n    char* res = (char*)calloc(w_size + 1, sizeof(char)); // allocate memory for solution string\\n    //free(s); // free memory of instruction string - this is optional \\n    for (k = w_size - 1; k >= 0; k--) res[k] = pop_char(&head_char_stack);\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nstruct node_times {\\n    int times;\\n    struct node_times* next;\\n};\\nstruct node_char {\\n    char c;\\n    struct node_char* next;\\n};\\nvoid push_num(struct node_times** head, int num) {\\n    struct node_times* new_node = (struct node_times*)malloc(sizeof(struct node_times));\\n    new_node->times = num;\\n    new_node->next = *head;\\n    *head = new_node;\\n}\\nvoid push_char(struct node_char** head, char c) {\\n    struct node_char* new_node = (struct node_char*)malloc(sizeof(struct node_char));\\n    new_node->c = c;\\n    new_node->next = *head;\\n    *head = new_node;\\n}\\nint pop_number(struct node_times** head) {\\n    struct node_times* tmp = *head;\\n    int ret_n = tmp->times;\\n    *head = (*head)->next;\\n    free(tmp);\\n    return ret_n;\\n}\\nchar pop_char(struct node_char** head) {\\n    struct node_char* tmp = *head;\\n    char ret_c = tmp->c;\\n    (*head) = (*head)->next;\\n    free(tmp);\\n    return ret_c;\\n}\\nint get_word_size(struct node_char* head) {\\n    int size = 0;\\n    while (head) {\\n        if (head->c == \\'[\\') break;\\n        size++;\\n        head = head->next;\\n    }\\n    return size;\\n}\\nchar* decodeString(char* s) {\\n    struct node_times* head_num_stack = NULL;\\n    struct node_char* head_char_stack = NULL;\\n    int i = 0;\\n    int w_size;\\n    int k;\\n    while (s[i]) {\\n        // if its a number push it to number\\'s stack\\n        if (s[i] >= \\'0\\' && s[i] <= \\'9\\') {\\n            int num = atoi(&s[i]);\\n            while (s[i] >= \\'0\\' && s[i] <= \\'9\\') i++;// increment index to pass by the number\\n            // push the number to numbers stack\\n            push_num(&head_num_stack, num);\\n        }\\n        else if (s[i] > \\'9\\' && s[i] != \\']\\') {\\n            // if its any letter but not \\']\\' then just push it to char stack\\n            push_char(&head_char_stack, s[i]);\\n            i++;\\n        }\\n        else if (s[i] == \\'[\\') {\\n            // if its an opnening bracket push it to char stack\\n            push_char(&head_char_stack, \\'[\\');\\n            i++;\\n        }\\n        else if (s[i] == \\']\\') {\\n            // here we need building word procedure to begin\\n            w_size = get_word_size(head_char_stack); // get word size\\n            int n_times = pop_number(&head_num_stack); // get how much we need to repeat the word\\n            char* word = (char*)malloc(w_size * sizeof(char));// allocate memory for word for temporary work\\n            // read word chars into temporary word, also empty it from chars stack\\n            for (k = 0; k < w_size; k++) {\\n                word[k] = pop_char(&head_char_stack);\\n            }\\n            // now we have the word we need to push it the multiplier amount of times:\\n            // we have to push it in reversed order because we pulled it from char stack ( which is reversed )\\n           \\n            pop_char(&head_char_stack); // get rid of the opening bracket at char stack - \\'[\\'\\n            // now we need to push the word n_times\\n            for (; n_times > 0; n_times--) {\\n                for (k = w_size - 1; k >= 0; k--) {\\n                    push_char(&head_char_stack, word[k]);\\n                }\\n            }\\n            free(word); // free the temp string\\n            i++;\\n        }\\n    }\\n    // now we have the complete decoded string at the char_stack, all we need to do is to pop it out char by char and then reverse the chars order!\\n\\t // and dont forget we need 1 null byte for ending string Muhahaha!\\n    w_size = get_word_size(head_char_stack);// get overall string size - how many chars\\n    char* res = (char*)calloc(w_size + 1, sizeof(char)); // allocate memory for solution string\\n    //free(s); // free memory of instruction string - this is optional \\n    for (k = w_size - 1; k >= 0; k--) res[k] = pop_char(&head_char_stack);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 442453,
                "title": "easy-to-understand-c-stack-solution-0ms-beats-100",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Decode String.\\nMemory Usage: 9.2 MB, less than 7.84% of C++ online submissions for Decode String.\\n\\n```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        \\n        if(s.size() == 0) return \"\";\\n        string res = \"\";\\n        stack<int> count;\\n        stack<string> st;\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(isdigit(s[i]))\\n            {\\n                string str = \"\";\\n                while(i < s.size() && s[i+1] != \\'[\\')\\n                    str += s[i++];\\n                str += s[i];\\n                count.push(stoi(str));\\n            }\\n            else if(s[i] == \\']\\')\\n            {\\n                int cnt = count.top();\\n                count.pop();\\n                \\n                string str = \"\";\\n                while(!st.empty() && st.top() != \"[\")\\n                {\\n                    str =  st.top() + str;\\n                    st.pop();\\n                }\\n                \\n                st.pop();\\n                string temp = \"\";\\n                for(int k=0; k<cnt; k++)\\n                    temp = str + temp;\\n                \\n                st.push(temp);\\n            }\\n            else\\n                st.push(string(1,s[i]));\\n        }\\n        \\n        while(!st.empty())\\n        {\\n            res = st.top() + res;\\n            st.pop();\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string decodeString(string s) {\\n        \\n        if(s.size() == 0) return \"\";\\n        string res = \"\";\\n        stack<int> count;\\n        stack<string> st;\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(isdigit(s[i]))\\n            {\\n                string str = \"\";\\n                while(i < s.size() && s[i+1] != \\'[\\')\\n                    str += s[i++];\\n                str += s[i];\\n                count.push(stoi(str));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 326178,
                "title": "go-solution-using-stack",
                "content": "```\\nfunc decodeString(s string) string {\\n\\tstackNums := make([]int, 0)\\n\\tstackStr := make([]string, 0)\\n\\tvar res string\\n\\tvar num int\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tswitch {\\n\\t\\tcase s[i] >= \\'0\\' && s[i] <= \\'9\\':\\n\\t\\t\\tnum = 10*num + int(s[i]) - \\'0\\'\\n\\t\\tcase s[i] == \\'[\\':\\n\\t\\t\\tstackNums = append(stackNums, num)\\n\\t\\t\\tnum = 0\\n\\t\\t\\tstackStr = append(stackStr, res)\\n\\t\\t\\tres = \"\"\\n\\t\\tcase s[i] == \\']\\':\\n\\t\\t\\ttmp := stackStr[len(stackStr)-1]\\n\\t\\t\\tstackStr = stackStr[:len(stackStr)-1]\\n\\t\\t\\tcount := stackNums[len(stackNums)-1]\\n\\t\\t\\tstackNums = stackNums[:len(stackNums)-1]\\n\\t\\t\\tres = tmp + strings.Repeat(res, count)\\n\\t\\tdefault:\\n\\t\\t\\tres += string(s[i])\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc decodeString(s string) string {\\n\\tstackNums := make([]int, 0)\\n\\tstackStr := make([]string, 0)\\n\\tvar res string\\n\\tvar num int\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tswitch {\\n\\t\\tcase s[i] >= \\'0\\' && s[i] <= \\'9\\':\\n\\t\\t\\tnum = 10*num + int(s[i]) - \\'0\\'\\n\\t\\tcase s[i] == \\'[\\':\\n\\t\\t\\tstackNums = append(stackNums, num)\\n\\t\\t\\tnum = 0\\n\\t\\t\\tstackStr = append(stackStr, res)\\n\\t\\t\\tres = \"\"\\n\\t\\tcase s[i] == \\']\\':\\n\\t\\t\\ttmp := stackStr[len(stackStr)-1]\\n\\t\\t\\tstackStr = stackStr[:len(stackStr)-1]\\n\\t\\t\\tcount := stackNums[len(stackNums)-1]\\n\\t\\t\\tstackNums = stackNums[:len(stackNums)-1]\\n\\t\\t\\tres = tmp + strings.Repeat(res, count)\\n\\t\\tdefault:\\n\\t\\t\\tres += string(s[i])\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 195133,
                "title": "recursive-descent-parser-solution",
                "content": "Maybe it\\'s an overkill, but definitely easier to reason. No need to handle edge cases or anything. \\n\\nThe hardest thing  is come up with the grammar. As long as you come up with the grammar is mechanical parser implementation.\\n```\\nGrammar:\\nenc_s := multiplier enc_s | s enc_s | eps\\nmultiplier := num [ enc_s ]\\ns := w+\\nnum := d+\\n```\\n\\nI use regex for the lexing part in order not to play with the input, like:\\n```\\nif char.isdigit():\\n\\taccumulator = accumulator * 10 + (ord(char) - ord(\\'0\\'))\\n```\\n\\nJust split into tokens, parse and then eval and eval function is easy for all of the non-terminals\\n\\nCode:\\n```\\nimport re\\n\\nclass String(object):\\n    def __init__(self, s): self.s = s\\n    def eval(self): return self.s\\n\\nclass EncodedString(object):\\n    def __init__(self, left, right=String(\"\")):\\n        self.left = left\\n        self.right = right\\n    \\n    def eval(self): return \"\".join([self.left.eval(), self.right.eval()])\\n\\nclass MultiplierNode(object):\\n    def __init__(self, num, child):\\n        self.multiplier = num\\n        self.child = child\\n    \\n    def eval(self): return self.multiplier * self.child.eval()\\n\\nclass Parser(object):\\n    def consume(self):\\n        val = self.lookahead()\\n        self.idx += 1\\n        return val\\n    \\n    def lookahead(self): return self.tokens[self.idx]\\n    \\n    def parse(self, tokens):\\n        self.idx = 0\\n        self.tokens = tokens\\n        return self.__enc_s__()\\n    \\n    def __enc_s__(self):\\n        node = String(\"\") ## empty string\\n        \\n        while self.idx < len(self.tokens) and (self.lookahead().isdigit() or self.lookahead().isalpha()):\\n            if self.lookahead().isdigit():  node = EncodedString(node, self.__multiplier__())\\n            else:                           node = EncodedString(node, String(self.consume()))\\n        \\n        return node\\n    \\n    def __multiplier__(self):\\n        multiplier = int(self.consume())\\n\\n        self.consume() ## skip [\\n        node = MultiplierNode(multiplier, self.__enc_s__())\\n        self.consume() ## skip ]\\n\\n        return node\\n\\nclass Solution(object):\\n    def decodeString(self, s): \\n        def scan(s): return re.findall(\"\\\\d+|\\\\[|\\\\]|[a-zA-Z]+\", s)\\n        \\n        parser = Parser()\\n        return parser.parse(scan(s)).eval()\\n```",
                "solutionTags": [],
                "code": "```\\nGrammar:\\nenc_s := multiplier enc_s | s enc_s | eps\\nmultiplier := num [ enc_s ]\\ns := w+\\nnum := d+\\n```\n```\\nif char.isdigit():\\n\\taccumulator = accumulator * 10 + (ord(char) - ord(\\'0\\'))\\n```\n```\\nimport re\\n\\nclass String(object):\\n    def __init__(self, s): self.s = s\\n    def eval(self): return self.s\\n\\nclass EncodedString(object):\\n    def __init__(self, left, right=String(\"\")):\\n        self.left = left\\n        self.right = right\\n    \\n    def eval(self): return \"\".join([self.left.eval(), self.right.eval()])\\n\\nclass MultiplierNode(object):\\n    def __init__(self, num, child):\\n        self.multiplier = num\\n        self.child = child\\n    \\n    def eval(self): return self.multiplier * self.child.eval()\\n\\nclass Parser(object):\\n    def consume(self):\\n        val = self.lookahead()\\n        self.idx += 1\\n        return val\\n    \\n    def lookahead(self): return self.tokens[self.idx]\\n    \\n    def parse(self, tokens):\\n        self.idx = 0\\n        self.tokens = tokens\\n        return self.__enc_s__()\\n    \\n    def __enc_s__(self):\\n        node = String(\"\") ## empty string\\n        \\n        while self.idx < len(self.tokens) and (self.lookahead().isdigit() or self.lookahead().isalpha()):\\n            if self.lookahead().isdigit():  node = EncodedString(node, self.__multiplier__())\\n            else:                           node = EncodedString(node, String(self.consume()))\\n        \\n        return node\\n    \\n    def __multiplier__(self):\\n        multiplier = int(self.consume())\\n\\n        self.consume() ## skip [\\n        node = MultiplierNode(multiplier, self.__enc_s__())\\n        self.consume() ## skip ]\\n\\n        return node\\n\\nclass Solution(object):\\n    def decodeString(self, s): \\n        def scan(s): return re.findall(\"\\\\d+|\\\\[|\\\\]|[a-zA-Z]+\", s)\\n        \\n        parser = Parser()\\n        return parser.parse(scan(s)).eval()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87587,
                "title": "python-recursion-and-iteration-dfs",
                "content": "The recursion is a little bit strange. Since Python's Integer is immutable, and Python 2.7 doesn't support `nonlocal`, I return both `i` and processed string in the recursion function.\\n\\n```python\\nclass Solution(object):\\n    def dfs(self, s, i):\\n        length = len(s)\\n        result = []\\n        while i < length:\\n            if s[i].isdigit():\\n                count_str = ''\\n                while s[i] != '[':\\n                    count_str += s[i]\\n                    i += 1\\n                count = int(count_str)\\n                i += 1\\n                i, substr = self.dfs(s, i)\\n                result.append(count * substr)\\n            elif s[i] == ']':\\n                i += 1\\n                return i, ''.join(result)\\n            else:\\n                result.append(s[i])\\n                i += 1\\n\\n        return ''.join(result)\\n\\n    def decodeString(self, s):\\n        if not s or len(s) == 0:\\n            return ''\\n\\n        return self.dfs(s, 0)\\n```\\n\\n\\n```python\\nclass Solution(object):\\n    def decodeString(self, s):\\n        if not s or len(s) == 0:\\n            return ''\\n\\n        i, length = 0, len(s)\\n        substr = []\\n        stack = []\\n        while i < length:\\n            if s[i].isdigit():\\n                count_str = ''\\n                while s[i] != '[':\\n                    count_str += s[i]\\n                    i += 1\\n                count = int(count_str)\\n                stack.append(substr)\\n                stack.append(count)\\n                substr = []\\n            elif s[i] == ']':\\n                count = stack.pop()\\n                outer_substr = stack.pop()\\n                outer_substr.append(''.join(substr) * count)\\n                substr = outer_substr\\n            else:\\n                substr.append(s[i])\\n\\n            i += 1\\n\\n        return ''.join(substr)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def dfs(self, s, i):\\n        length = len(s)\\n        result = []\\n        while i < length:\\n            if s[i].isdigit():\\n                count_str = ''\\n                while s[i] != '[':\\n                    count_str += s[i]\\n                    i += 1\\n                count = int(count_str)\\n                i += 1\\n                i, substr = self.dfs(s, i)\\n                result.append(count * substr)\\n            elif s[i] == ']':\\n                i += 1\\n                return i, ''.join(result)\\n            else:\\n                result.append(s[i])\\n                i += 1\\n\\n        return ''.join(result)\\n\\n    def decodeString(self, s):\\n        if not s or len(s) == 0:\\n            return ''\\n\\n        return self.dfs(s, 0)\\n```\n```python\\nclass Solution(object):\\n    def decodeString(self, s):\\n        if not s or len(s) == 0:\\n            return ''\\n\\n        i, length = 0, len(s)\\n        substr = []\\n        stack = []\\n        while i < length:\\n            if s[i].isdigit():\\n                count_str = ''\\n                while s[i] != '[':\\n                    count_str += s[i]\\n                    i += 1\\n                count = int(count_str)\\n                stack.append(substr)\\n                stack.append(count)\\n                substr = []\\n            elif s[i] == ']':\\n                count = stack.pop()\\n                outer_substr = stack.pop()\\n                outer_substr.append(''.join(substr) * count)\\n                substr = outer_substr\\n            else:\\n                substr.append(s[i])\\n\\n            i += 1\\n\\n        return ''.join(substr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87720,
                "title": "javascript-solution-with-stack",
                "content": "Javascript solution with stack\\n```\\nvar decodeString = function(s) {\\n    var stack = [];\\n    var i=0;\\n    var j=0;\\n    for(; i<s.length; i++) {\\n        var buf = [];\\n        var seq;\\n        var freq = 0;\\n        var c = s.charAt(i);\\n        if (c===']') {\\n            for(j = stack.length-1; j>=0; j--) {\\n                var p = stack.pop();\\n                if (p === '[') {\\n                    seq = buf.join('');\\n                    buf = [];\\n                    for(var k=j-1; k>=0 && stack[k]>='0' && stack[k]<='9'; k--) {\\n                        buf.unshift(stack.pop());\\n                    }\\n                    freq=parseInt(buf.join(''));\\n                    stack.push(Array(freq+1).join(seq));\\n                    buf = [];\\n                    break;\\n                }\\n                else {\\n                    buf.unshift(p);\\n                }\\n            }\\n        }\\n        else {\\n            stack.push(c);\\n        }\\n    }\\n    return stack.join('');\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "Javascript solution with stack\\n```\\nvar decodeString = function(s) {\\n    var stack = [];\\n    var i=0;\\n    var j=0;\\n    for(; i<s.length; i++) {\\n        var buf = [];\\n        var seq;\\n        var freq = 0;\\n        var c = s.charAt(i);\\n        if (c===']') {\\n            for(j = stack.length-1; j>=0; j--) {\\n                var p = stack.pop();\\n                if (p === '[') {\\n                    seq = buf.join('');\\n                    buf = [];\\n                    for(var k=j-1; k>=0 && stack[k]>='0' && stack[k]<='9'; k--) {\\n                        buf.unshift(stack.pop());\\n                    }\\n                    freq=parseInt(buf.join(''));\\n                    stack.push(Array(freq+1).join(seq));\\n                    buf = [];\\n                    break;\\n                }\\n                else {\\n                    buf.unshift(p);\\n                }\\n            }\\n        }\\n        else {\\n            stack.push(c);\\n        }\\n    }\\n    return stack.join('');\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3776871,
                "title": "simple-explained-c-solution-using-1-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing stack and looping through string and checking for each character\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are traversing string and pushing element is stack if it\\'s not \\']\\'.\\nWhen we encounter \\']\\', we pop elements of stack and process then until we find \\'[\\'. We  make string temp which stores the string which is to be processed latest and we store the integer n, ie number of times that string is to be repeated. then for n times we push the characters of that string back to the stack and continue it for same. At last we pop elements and store in ans string.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<char> st;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]!=\\']\\')\\n            st.push(s[i]);\\n            else\\n            {\\n                string temp=\"\";\\n                while(st.top()!=\\'[\\')\\n                {\\n                    temp+=st.top();\\n                    st.pop();\\n                }\\n                reverse(temp.begin(),temp.end());\\n                st.pop();\\n\\n                string num=\"\";\\n                while(st.empty()==false && isdigit(st.top()))\\n                {\\n                    num+=st.top();\\n                    st.pop();\\n                }\\n                if(num.size()>0)\\n                {\\n                    reverse(num.begin(),num.end());\\n                    int n = stoi(num);\\n                    while(n>0)\\n                    {\\n                        for(int j=0;j<temp.size();j++)\\n                        {\\n                            st.push(temp[j]);\\n                        }\\n                        n--;\\n                    }\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        while(!st.empty())\\n        {\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\\nPlease upvote if you liked solution",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<char> st;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]!=\\']\\')\\n            st.push(s[i]);\\n            else\\n            {\\n                string temp=\"\";\\n                while(st.top()!=\\'[\\')\\n                {\\n                    temp+=st.top();\\n                    st.pop();\\n                }\\n                reverse(temp.begin(),temp.end());\\n                st.pop();\\n\\n                string num=\"\";\\n                while(st.empty()==false && isdigit(st.top()))\\n                {\\n                    num+=st.top();\\n                    st.pop();\\n                }\\n                if(num.size()>0)\\n                {\\n                    reverse(num.begin(),num.end());\\n                    int n = stoi(num);\\n                    while(n>0)\\n                    {\\n                        for(int j=0;j<temp.size();j++)\\n                        {\\n                            st.push(temp[j]);\\n                        }\\n                        n--;\\n                    }\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        while(!st.empty())\\n        {\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3637054,
                "title": "easy-c-solution-beat-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<string> st;\\n        for(auto ch: s){\\n            if(ch==\\']\\'){\\n                string stringtorepeat=\"\";\\n                while(!st.empty()&& st.top()!=\"[\"){\\n                    string top=st.top();\\n                    stringtorepeat+=top;\\n                    st.pop();\\n                }\\n                st.pop();//st.top has \\'[\\' this one the top so pop\\n                //now we will take number of time we want to repeat \\n                string num=\"\";\\n                while(!st.empty() && isdigit(st.top()[0])){\\n                    string top=st.top();\\n                    num+=st.top();\\n                    st.pop();\\n                }\\n                // reverse 321 to 123\\n                reverse(num.begin(),num.end());\\n                int n=stoi(num);\\n            \\n\\n                //final decoding \\n                string currdecode=\"\";\\n                while(n--){\\n                    currdecode+=stringtorepeat;\\n                }\\n                st.push(currdecode);\\n            }\\n            else \\n            {\\n                string temp(1,ch);///convert char to string\\n                st.push(temp);\\n            }\\n        }\\n        ///ye mujhe sari stirng dedega abh m inko final rev karke ans return kardunga \\n                string ans=\"\";\\n                while(!st.empty()){\\n                    ans+=st.top();\\n                    st.pop();\\n                }\\n                reverse(ans.begin(),ans.end());\\n                return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<string> st;\\n        for(auto ch: s){\\n            if(ch==\\']\\'){\\n                string stringtorepeat=\"\";\\n                while(!st.empty()&& st.top()!=\"[\"){\\n                    string top=st.top();\\n                    stringtorepeat+=top;\\n                    st.pop();\\n                }\\n                st.pop();//st.top has \\'[\\' this one the top so pop\\n                //now we will take number of time we want to repeat \\n                string num=\"\";\\n                while(!st.empty() && isdigit(st.top()[0])){\\n                    string top=st.top();\\n                    num+=st.top();\\n                    st.pop();\\n                }\\n                // reverse 321 to 123\\n                reverse(num.begin(),num.end());\\n                int n=stoi(num);\\n            \\n\\n                //final decoding \\n                string currdecode=\"\";\\n                while(n--){\\n                    currdecode+=stringtorepeat;\\n                }\\n                st.push(currdecode);\\n            }\\n            else \\n            {\\n                string temp(1,ch);///convert char to string\\n                st.push(temp);\\n            }\\n        }\\n        ///ye mujhe sari stirng dedega abh m inko final rev karke ans return kardunga \\n                string ans=\"\";\\n                while(!st.empty()){\\n                    ans+=st.top();\\n                    st.pop();\\n                }\\n                reverse(ans.begin(),ans.end());\\n                return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232199,
                "title": "javascript-easy-fun-solution-o-m-n",
                "content": "# Approach\\nFirst I defiened ```stack``` data structure to keep track of the characters in the input string.\\n\\nThen the function iterates over each character in the string, and if the character is a closing square bracket ```\"]\"```, it pops characters off the stack until it finds the corresponding opening square bracket ```\"[\"```\\n```\\nwhile (true) { \\n    const char = stack.pop()\\n    if (char === \\'[\\') break \\n    str = char + str\\n}\\n```\\nIt then pops off any numbers that are immediately before the opening bracket\\n```\\n while (Number.isInteger(+stack[stack.length - 1])) { \\n    const number = stack.pop()\\n    n = number + n\\n}\\n```\\nthe function then uses those numbers to repeat the string that was just popped off the stack. The repeated string is then pushed back onto the stack.\\n\\n``` stack.push(str.repeat(+n))```\\n\\nIf the character is not a closing square bracket, it is simply pushed onto the stack. Once all characters have been processed, the remaining contents of the stack are joined together into a single string, which is returned as the final result.\\n# Time Complexity: O(n * m)\\nThe time complexity of my code is O(n*m), where n is the length of the input string and m is the maximum number that appears in the input string.\\n\\nThis is because for each character in the input string, the code either pushes it onto the stack or pops characters off the stack until it finds a matching opening bracket. In the worst case, each character in the string could correspond to a bracket, which means the code would need to traverse the entire stack for each character. \\n\\n```return stack.join(\\'\\')```\\n# Space Complexity: O(n)\\n# Enjoy with my code (^_^)\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nconst decodeString = s => {\\n    if (s.length === 1) { \\n        if (Number.isInteger(+s)) return \"\"\\n        else return s\\n    }\\n    const stack = []\\n    for (let i = 0; i < s.length; i++) { \\n        if (s[i] === \\']\\') { \\n            let str = \\'\\'\\n            while (true) { \\n                const char = stack.pop()\\n                if (char === \\'[\\') break \\n                str = char + str\\n            }\\n            let n = \\'\\'\\n            while (Number.isInteger( +stack[stack.length - 1])) { \\n                const number = stack.pop()\\n                n = number + n\\n            }\\n            stack.push(str.repeat(+n))\\n        } \\n        else stack.push(s[i])\\n    }\\n    return stack.join(\\'\\')\\n};\\n```\\n# that\\'s it bro\\n![T\\xED \\uD83D\\uDC2D.jfif](https://assets.leetcode.com/users/images/13be616b-964e-4d47-9798-2fbbb7f0eed0_1677404287.5793607.jpeg)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```stack```\n```\"]\"```\n```\"[\"```\n```\\nwhile (true) { \\n    const char = stack.pop()\\n    if (char === \\'[\\') break \\n    str = char + str\\n}\\n```\n```\\n while (Number.isInteger(+stack[stack.length - 1])) { \\n    const number = stack.pop()\\n    n = number + n\\n}\\n```\n``` stack.push(str.repeat(+n))```\n```return stack.join(\\'\\')```\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nconst decodeString = s => {\\n    if (s.length === 1) { \\n        if (Number.isInteger(+s)) return \"\"\\n        else return s\\n    }\\n    const stack = []\\n    for (let i = 0; i < s.length; i++) { \\n        if (s[i] === \\']\\') { \\n            let str = \\'\\'\\n            while (true) { \\n                const char = stack.pop()\\n                if (char === \\'[\\') break \\n                str = char + str\\n            }\\n            let n = \\'\\'\\n            while (Number.isInteger( +stack[stack.length - 1])) { \\n                const number = stack.pop()\\n                n = number + n\\n            }\\n            stack.push(str.repeat(+n))\\n        } \\n        else stack.push(s[i])\\n    }\\n    return stack.join(\\'\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3134985,
                "title": "0ms-easy-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String decodeString(String s) {\\n        Stack<Integer>numStack=new Stack<>();\\n        Stack<StringBuilder>strBuild=new Stack<>();\\n        StringBuilder str = new StringBuilder();\\n        int num=0;\\n        for(char c:s.toCharArray()){\\n            if(c>=\\'0\\' && c<=\\'9\\'){\\n                num=num*10 +c -\\'0\\';\\n            }\\n            else if(c==\\'[\\'){\\n                strBuild.push(str);\\n                str=new StringBuilder();\\n                numStack.push(num);\\n                num=0;\\n            }else if(c==\\']\\'){\\n                StringBuilder temp=str;\\n                str=strBuild.pop();\\n                int count=numStack.pop();\\n                while(count-->0){\\n                    str.append(temp);\\n                }\\n            }else{\\n                str.append(c);\\n            }\\n        }\\n        return str.toString();\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeString(String s) {\\n        Stack<Integer>numStack=new Stack<>();\\n        Stack<StringBuilder>strBuild=new Stack<>();\\n        StringBuilder str = new StringBuilder();\\n        int num=0;\\n        for(char c:s.toCharArray()){\\n            if(c>=\\'0\\' && c<=\\'9\\'){\\n                num=num*10 +c -\\'0\\';\\n            }\\n            else if(c==\\'[\\'){\\n                strBuild.push(str);\\n                str=new StringBuilder();\\n                numStack.push(num);\\n                num=0;\\n            }else if(c==\\']\\'){\\n                StringBuilder temp=str;\\n                str=strBuild.pop();\\n                int count=numStack.pop();\\n                while(count-->0){\\n                    str.append(temp);\\n                }\\n            }else{\\n                str.append(c);\\n            }\\n        }\\n        return str.toString();\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019418,
                "title": "c-beats-100-recursion",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n     string solve(string s, int &index) {\\n        string ans; \\n        while (index < s.size() && s[index] != \\']\\')\\n        {\\n            if (!isdigit(s[index]))\\n                ans += s[index++];\\n            else \\n            {\\n                int n = 0;\\n                while (index < s.size() && isdigit(s[index]))\\n                    n = n * 10 + s[index++] - \\'0\\';\\n                index++; \\n                string temp = solve(s, index);\\n                index++; \\n                while (n--)\\n                    ans += temp;\\n            }\\n        }\\n        return ans;\\n    }\\n    string decodeString(string s) {\\n        int index = 0;\\n        return solve(s, index);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     string solve(string s, int &index) {\\n        string ans; \\n        while (index < s.size() && s[index] != \\']\\')\\n        {\\n            if (!isdigit(s[index]))\\n                ans += s[index++];\\n            else \\n            {\\n                int n = 0;\\n                while (index < s.size() && isdigit(s[index]))\\n                    n = n * 10 + s[index++] - \\'0\\';\\n                index++; \\n                string temp = solve(s, index);\\n                index++; \\n                while (n--)\\n                    ans += temp;\\n            }\\n        }\\n        return ans;\\n    }\\n    string decodeString(string s) {\\n        int index = 0;\\n        return solve(s, index);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2571855,
                "title": "python-code-using-recursion",
                "content": "**Points to Note:**\\n1. Until we encounter an opening bracket \\'[\\' it must be an integer.\\n\\n2. When we encounter a closing bracket \\']\\' it means from the preceeding opening bracket \\'[\\' the expression between the brackets \\'[.....]\\' needs to be evaluated and multiplied with the number before the opening bracket. eg. number * [....]\\n\\n3. So, the idea is to go as deep inside as possible and evaluate the inner expression first then the outer ones.\\neg. \"3[a2[c]]\"\\n* \\tWe need to evaluate 2[c] first, then we get 3[acc]\\n* \\twe evaluate 3[acc] we get \"accaccacc\".\\n\\nAnother case to remember:\\n* If we encounter an closing bracket that doesn\\'t mean we are done there may be string ahead so we need to move forward to check.\\n* So, after encountering a \\']\\' remember the index and return so that you can check if there is string ahead\\n\\n` int(n)*helper(i+1,\"\",l)+helper(l[0]+1,\"\",l)`\\n That is exactly what the above expression does,\\n*  we multiply the number to the expression in the brackets i,e., `int(n)*helper(i+1,\"\",l)`\\n*  Then with that function call we get the evaluated string and then to check ahead in the string we call the function `helper(l[0]+1,\"\",l)` and append it to the return value\\n\\n\\t` int(n)*helper(i+1,\"\",l)+helper(l[0]+1,\"\",l)`.\\n\\n\\tHere, l is the list with index 0 to remember the index from where we returned after evaluating the expression in the brackets [...]\\n\\t\\n\\t**Note:**  *list is used instead of a variable because list is passed by reference so value can be retained.*\\n\\t\\n\\t\\t \\n\\t\\t \\n```    def decodeString(self, s: str) -> str:\\n        def helper(i,n,l):\\n            if i>=len(s):\\n                return \"\"\\n\\t\\t\\t\\t\\n            if s[i]==\"]\":\\n                l[0] = i #we keep track where we left\\n                return \"\"\\n\\t\\t\\t\\t\\n            if s[i]==\"[\":\\n                return int(n)*helper(i+1,\"\",l)+helper(l[0]+1,\"\",l)\\n\\t\\t\\t\\t\\n            if s[i].isnumeric():\\n                return helper(i+1,n+s[i],l)\\n\\t\\t\\t\\t\\n            else:\\n                return s[i]+helper(i+1,n,l)\\n\\t\\t\\t\\t\\n        l = [0]\\n        return helper(0,\"\",l)\\n\\t```\\n\\t\\n\\t",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```    def decodeString(self, s: str) -> str:\\n        def helper(i,n,l):\\n            if i>=len(s):\\n                return \"\"\\n\\t\\t\\t\\t\\n            if s[i]==\"]\":\\n                l[0] = i #we keep track where we left\\n                return \"\"\\n\\t\\t\\t\\t\\n            if s[i]==\"[\":\\n                return int(n)*helper(i+1,\"\",l)+helper(l[0]+1,\"\",l)\\n\\t\\t\\t\\t\\n            if s[i].isnumeric():\\n                return helper(i+1,n+s[i],l)\\n\\t\\t\\t\\t\\n            else:\\n                return s[i]+helper(i+1,n,l)\\n\\t\\t\\t\\t\\n        l = [0]\\n        return helper(0,\"\",l)\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 2467138,
                "title": "python-solution-with-some-comments",
                "content": "Inspired by [simkieu\\'s solution](https://leetcode.com/problems/decode-string/discuss/87662/Python-solution-using-stack). I just added some comments to make it clear:\\n\\nWe have to understand the meaning of \\'[\\' and \\']\\'.\\nEvery time we see a **number** followed by a **\\'[\\'**, we are going to repeat the string in the bracket. The bracket is going to create a lower level.\\n\\nThere are 4 cases:\\n1. **digit**: keep reading until we get a \\'[\\'.\\n\\n2. **\\'[\\'**: the start of a lower level.\\n\\n    push the current number and string to stack, set num=0 and string=\\'\\'\\n\\n3. **\\']\\'**: the end of a lower level. \\n    \\n    Multiply the string in this level by the number before \\'[\\', then append it to the previous string in the upper level.\\n\\n4. **letter**: add to string, there is nothing else to do.\\n\\nI made a simple diagram showing different levels of strings.\\n![image](https://assets.leetcode.com/users/images/698de091-8d25-420e-bff5-3c73e910a9a4_1661235013.145312.png)\\n\\n```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        stack=[]\\n        num=0\\n        string=\\'\\'\\n        for x in s:\\n            ordx=ord(x)\\n            if ordx>=ord(\\'a\\') and ordx<=ord(\\'z\\'): # is a letter\\n                string+=x # append it to the current level string\\n            elif ordx>=ord(\\'0\\') and ordx<=ord(\\'9\\'): # is a number\\n                num=num*10+int(x) # append it to the current level number\\n            elif x==\\'[\\':\\n                # start a lower level, push string and num to stack\\n                stack.append(string)\\n                stack.append(num)\\n                # reset \\n                num=0\\n                string=\\'\\'\\n            else: # \\']\\', end of a lower level\\n                lower_level_string=string*stack.pop() # decode this bracket\\n                string=stack.pop()+lower_level_string # append the decoded bracket to string before the bracket, which is of upper level\\n        return string\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        stack=[]\\n        num=0\\n        string=\\'\\'\\n        for x in s:\\n            ordx=ord(x)\\n            if ordx>=ord(\\'a\\') and ordx<=ord(\\'z\\'): # is a letter\\n                string+=x # append it to the current level string\\n            elif ordx>=ord(\\'0\\') and ordx<=ord(\\'9\\'): # is a number\\n                num=num*10+int(x) # append it to the current level number\\n            elif x==\\'[\\':\\n                # start a lower level, push string and num to stack\\n                stack.append(string)\\n                stack.append(num)\\n                # reset \\n                num=0\\n                string=\\'\\'\\n            else: # \\']\\', end of a lower level\\n                lower_level_string=string*stack.pop() # decode this bracket\\n                string=stack.pop()+lower_level_string # append the decoded bracket to string before the bracket, which is of upper level\\n        return string\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2346290,
                "title": "easy-c-solution-stack-string",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<char> st;\\n        \\n        for(int i=0; i<s.length(); i++){\\n            if(s[i]!=\\']\\')\\n                st.push(s[i]);\\n            else{\\n                string str = \"\";\\n        \\n                while(st.top() != \\'[\\'){\\n                    str =st.top()+str;\\n                    st.pop();\\n                }\\n                st.pop();\\n                \\n                string number = \"\";\\n                while(!st.empty() && isdigit(st.top())){\\n                    number = st.top() + number;\\n                    st.pop();\\n                }\\n                int freq=stoi(number);\\n                \\n                while(freq--)\\n                    for(int j=0; j<str.length() ; j++)\\n                        st.push(str[j]);\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans = st.top() + ans;\\n            st.pop();\\n        }\\n                \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<char> st;\\n        \\n        for(int i=0; i<s.length(); i++){\\n            if(s[i]!=\\']\\')\\n                st.push(s[i]);\\n            else{\\n                string str = \"\";\\n        \\n                while(st.top() != \\'[\\'){\\n                    str =st.top()+str;\\n                    st.pop();\\n                }\\n                st.pop();\\n                \\n                string number = \"\";\\n                while(!st.empty() && isdigit(st.top())){\\n                    number = st.top() + number;\\n                    st.pop();\\n                }\\n                int freq=stoi(number);\\n                \\n                while(freq--)\\n                    for(int j=0; j<str.length() ; j++)\\n                        st.push(str[j]);\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans = st.top() + ans;\\n            st.pop();\\n        }\\n                \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170142,
                "title": "cpp-solution-0ms-100-faster-recursive-solution",
                "content": "__Thank you for checking my Solution,\\nDo Upvote, if it helped :)__\\n\\n__Lets Take an example first and see its solution\\ns = 2[ab]2[d3[a2[c]]]__\\n![image](https://assets.leetcode.com/users/images/047f146c-1938-4bec-9ca2-795e705d245c_1655635970.822745.jpeg)\\n![image](https://assets.leetcode.com/users/images/2d37b4f9-30e5-4c8c-8548-45d066c69a6a_1655635982.9163513.jpeg)\\n![image](https://assets.leetcode.com/users/images/0b4c4ff3-82a1-4bd3-a616-3b37139c3199_1655635999.5368323.jpeg)\\n![image](https://assets.leetcode.com/users/images/a772021a-67a0-4fab-bf0c-b04d6fc16f7c_1655636006.9801486.jpeg)\\n\\n\\n__So as per the images, arrows represent returning a control, therefore we will recursion to solve this problem.\\nThe Idea is to add all the sets of independent brackets\\nFor every call, our current result is an empty string, we advance in the string and perform the following tasks__\\n>__If the current character is an opening bracket, we hold our current result and recursively check for any nested brackets__\\n>>__To solve the current pair of brackets, we have to ensure all the brackets inside it are solved!!\\n>>After A recursive call is finished, we set the multiplier (integer that tells us how many times our string will be repeated) to 0\\n>>We take the control to the next index which has to been traversed yet,__\\n>>>__Take an array and initialise all values to 0\\n>>>Whenever an index is encountered, set it to 1 in the array.\\n>>>0 ---> Untraversed, 1 ---> Traversed\\n>>>Therefore we take the control to the next index with value 0__\\n>>>\\n>__If current character is a letter, we add it to our current result and continue to advance  in the input string\\n>If the current character is an closing bracket,__\\n>> __We repeat our current result, multiplier times, and store it in a temporary string\\n>> We return the temporary string, this operation ends one set of brackets__\\n>> \\n>__Otherwise the current character is a digit,__ \\n>> __It will give us the multiplier, so we will store it in another variable\\n>> This will help us to pass on the multiplier to another recursive call, if needed, after converting it into integer__\\n>> \\n__Finally we will return the Current Result__\\n____\\n__Below is the C++ code for the above mentioned approach__\\n\\n\\n```\\nclass Solution\\n{ // Runtime: 0 ms, faster than 100.00% of C++ online submissions for Decode String.\\n  // Memory Usage: 6.4 MB, less than 78.36% of C++ online submissions for Decode String.\\npublic:\\n    int l, br = 0;\\n    // Since string length can at worst be 30, create an array of length 30 to track the indices that have been traversed\\n    int v[30]; \\n\\n    string get_it(string s, int index, int mul) //(Original String, index to start with, multiplier)\\n    {\\n        //Res to store immidiate results, \\n        //result_so_far to get the result so far, \\n        //num to get the multiplier\\n        string res = \"\", result_so_far = \"\", num = \"\";       \\n        int b = 0, i = index;\\n        while(i < l)\\n        {\\n            //Mark the index as traversed\\n            v[i] = 1;\\n            //If there is an opening\\n            if (s[i] == \\'[\\')                        \\n            {\\n                //For Every beginning, make a recursive call, as there might be nested Coded Strings like 3[a2[c]]\\n                //Store the result of the recursive call in result_so_far\\n                result_so_far += get_it(s, i + 1, stoi(num));\\n                //Set num as \"\", empty!\\n                num = \"\";\\n                //Take i to the next untraversed index\\n                while (v[i] != 0)\\n                    i++;\\n            }\\n            //If there is an alphabet, add it to result_so_far\\n            else if (isalpha(s[i]))\\n            {\\n                result_so_far += s[i++];\\n            }\\n            //If its a closing bracket\\n            else if (s[i] == \\']\\')\\n            {\\n                //Time to add the strings, m times,\\n                //This step is responsible for decoding(building up) the string\\n                for (int i = 1; i <= mul; i++)\\n                    res += result_so_far;       //Immediate immresult\\n                return res;\\n            }\\n            //Otherwise the current character is a part of multiplier, i.e. number\\n            else\\n                num += s[i++];\\n        }   \\n        return result_so_far;\\n    }\\n    string decodeString(string s)\\n    {\\n        l = s.size();\\n        //Set the l(size) places in the array v, as 0, stating all are untraversed\\n        for (int i = 0; i < l; i++)  \\n            v[i] = 0;\\n        \\n        return get_it(s, 0, 1);\\n    }\\n};\\n```\\n__Time Complexity : O(N), N = Length of the String\\nSpace Complexity : O(N), Since recursion uses a stack to process the info__",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{ // Runtime: 0 ms, faster than 100.00% of C++ online submissions for Decode String.\\n  // Memory Usage: 6.4 MB, less than 78.36% of C++ online submissions for Decode String.\\npublic:\\n    int l, br = 0;\\n    // Since string length can at worst be 30, create an array of length 30 to track the indices that have been traversed\\n    int v[30]; \\n\\n    string get_it(string s, int index, int mul) //(Original String, index to start with, multiplier)\\n    {\\n        //Res to store immidiate results, \\n        //result_so_far to get the result so far, \\n        //num to get the multiplier\\n        string res = \"\", result_so_far = \"\", num = \"\";       \\n        int b = 0, i = index;\\n        while(i < l)\\n        {\\n            //Mark the index as traversed\\n            v[i] = 1;\\n            //If there is an opening\\n            if (s[i] == \\'[\\')                        \\n            {\\n                //For Every beginning, make a recursive call, as there might be nested Coded Strings like 3[a2[c]]\\n                //Store the result of the recursive call in result_so_far\\n                result_so_far += get_it(s, i + 1, stoi(num));\\n                //Set num as \"\", empty!\\n                num = \"\";\\n                //Take i to the next untraversed index\\n                while (v[i] != 0)\\n                    i++;\\n            }\\n            //If there is an alphabet, add it to result_so_far\\n            else if (isalpha(s[i]))\\n            {\\n                result_so_far += s[i++];\\n            }\\n            //If its a closing bracket\\n            else if (s[i] == \\']\\')\\n            {\\n                //Time to add the strings, m times,\\n                //This step is responsible for decoding(building up) the string\\n                for (int i = 1; i <= mul; i++)\\n                    res += result_so_far;       //Immediate immresult\\n                return res;\\n            }\\n            //Otherwise the current character is a part of multiplier, i.e. number\\n            else\\n                num += s[i++];\\n        }   \\n        return result_so_far;\\n    }\\n    string decodeString(string s)\\n    {\\n        l = s.size();\\n        //Set the l(size) places in the array v, as 0, stating all are untraversed\\n        for (int i = 0; i < l; i++)  \\n            v[i] = 0;\\n        \\n        return get_it(s, 0, 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2155077,
                "title": "c-not-recursive-easy-runtime-0-ms-faster-than-100-00",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<string> st;\\n        for(int i=s.length()-1; i>=0; i--){\\n            if(s[i]==\\']\\'){  st.push(\"]\");   }\\n            else if(s[i]==\\'[\\'){\\n                string tm=\"\";\\n                while(!st.empty() and st.top()!=\"]\"){\\n                    tm+=st.top();\\n                    st.pop();\\n                }\\n                st.pop();i--;\\n                int g=1, x=0;\\n                while(i>=0){\\n                    if(!isdigit(s[i])){break;}\\n                    int xy = (s[i]-\\'0\\');\\n                    x+=(xy*g);\\n                    i--; g=g*10;\\n                }\\n                i++;\\n                string ans=\"\";\\n                while(x--){\\n                    ans+=tm;\\n                }\\n                st.push(ans);\\n            }\\n            else{\\n                string tm = \"\";\\n                tm+=s[i];\\n                st.push(tm);\\n            }\\n        }\\n        string as = \"\";\\n        while(!st.empty()){\\n            as+=st.top();\\n            st.pop();\\n        }\\n        return as;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/03bd9cbc-cc01-462f-a512-c1b2d0046eb7_1655300255.1603012.png)\\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<string> st;\\n        for(int i=s.length()-1; i>=0; i--){\\n            if(s[i]==\\']\\'){  st.push(\"]\");   }\\n            else if(s[i]==\\'[\\'){\\n                string tm=\"\";\\n                while(!st.empty() and st.top()!=\"]\"){\\n                    tm+=st.top();\\n                    st.pop();\\n                }\\n                st.pop();i--;\\n                int g=1, x=0;\\n                while(i>=0){\\n                    if(!isdigit(s[i])){break;}\\n                    int xy = (s[i]-\\'0\\');\\n                    x+=(xy*g);\\n                    i--; g=g*10;\\n                }\\n                i++;\\n                string ans=\"\";\\n                while(x--){\\n                    ans+=tm;\\n                }\\n                st.push(ans);\\n            }\\n            else{\\n                string tm = \"\";\\n                tm+=s[i];\\n                st.push(tm);\\n            }\\n        }\\n        string as = \"\";\\n        while(!st.empty()){\\n            as+=st.top();\\n            st.pop();\\n        }\\n        return as;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1658532,
                "title": "naive-to-efficient-3-approaches-iterative-recursive-c",
                "content": "Implementation\\n\\n**1st\\nNaive Approach\\nUsing 2 stacks\\nTime Complexity = O(N), Space Complexity = O(N)**\\n```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<int> intSt;   // int stack\\n        stack<string> strSt;    // string stack\\n        string res = \"\";\\n        int itr = 0;\\n        while(itr < s.size()){\\n            if(isdigit(s[itr])){\\n                int num = 0;\\n                while(isdigit(s[itr])){\\n                    num = num * 10 + s[itr++] - \\'0\\';\\n                }\\n                intSt.push(num);\\n            }\\n            else if(s[itr] == \\']\\'){\\n                int times = intSt.top();\\n                intSt.pop();\\n                \\n                string str = strSt.top();\\n                strSt.pop();\\n                \\n                for(int itr = 1; itr <= times; itr++){\\n                    str += res;\\n                }\\n                \\n                res = str;\\n                itr++;\\n            }\\n            else if(s[itr] == \\'[\\'){\\n                strSt.push(res);\\n                res = \"\";\\n                itr++;\\n            }\\n            else{\\n                res += s[itr];\\n                itr++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n\\n\\n**2nd\\nEfficient Approach\\nUsing 1 stack\\nTime Complexity = O(N), Space Complexity = O(N)**\\n```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<char> st;   // char stack        \\n        for(int itr = 0; itr < s.size(); itr++){\\n            if(s[itr] == \\']\\'){\\n                string str = \"\";\\n                while(st.top() != \\'[\\'){\\n                    str = st.top() + str;\\n                    st.pop();\\n                }                \\n                st.pop();\\n                \\n                string times = \"\";\\n                while(!st.empty() && isdigit(st.top())){\\n                    times = st.top() + times;\\n                    st.pop();\\n                }\\n                \\n                int count = stoi(times);\\n                \\n                while(count--){\\n                    for(int jtr = 0; jtr < str.size(); jtr++){\\n                        st.push(str[jtr]);\\n                    }\\n                }\\n            }\\n            else{\\n                st.push(s[itr]);\\n            }\\n        }\\n        \\n        string res = \"\";\\n        while(!st.empty()){\\n            res += st.top();\\n            st.pop();\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```\\n\\n\\n\\n**3rd\\nEfficient\\nRecursive Approach\\nTime Complexity = O(N), Space Complexity = O(N), considering the resursion stack**\\n```\\nclass Solution {\\npublic:\\n    string decodeTheString(string s, int &itr){\\n        string res = \"\";\\n        \\n        while(itr < s.size() && s[itr] != \\']\\'){\\n            if(isdigit(s[itr])){\\n                int num = 0;\\n                while(itr < s.size() && isdigit(s[itr])){\\n                    num = num * 10 + (s[itr++] - \\'0\\');\\n                }\\n                // to escape the \\'[\\'\\n                itr++;\\n                \\n                // store the return result and repeat it num times\\n                string temp = decodeTheString(s, itr);\\n                \\n                // to escape the \\']\\'\\n                itr++;\\n                \\n                while(num--){\\n                    res += temp;\\n                }\\n            }\\n            else{\\n                res += s[itr++];\\n            }\\n        }\\n        \\n        return res;    \\n    }\\n    \\n    string decodeString(string s) {\\n        int itr = 0;\\n        return decodeTheString(s, itr);\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "String",
                    "Stack",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<int> intSt;   // int stack\\n        stack<string> strSt;    // string stack\\n        string res = \"\";\\n        int itr = 0;\\n        while(itr < s.size()){\\n            if(isdigit(s[itr])){\\n                int num = 0;\\n                while(isdigit(s[itr])){\\n                    num = num * 10 + s[itr++] - \\'0\\';\\n                }\\n                intSt.push(num);\\n            }\\n            else if(s[itr] == \\']\\'){\\n                int times = intSt.top();\\n                intSt.pop();\\n                \\n                string str = strSt.top();\\n                strSt.pop();\\n                \\n                for(int itr = 1; itr <= times; itr++){\\n                    str += res;\\n                }\\n                \\n                res = str;\\n                itr++;\\n            }\\n            else if(s[itr] == \\'[\\'){\\n                strSt.push(res);\\n                res = \"\";\\n                itr++;\\n            }\\n            else{\\n                res += s[itr];\\n                itr++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<char> st;   // char stack        \\n        for(int itr = 0; itr < s.size(); itr++){\\n            if(s[itr] == \\']\\'){\\n                string str = \"\";\\n                while(st.top() != \\'[\\'){\\n                    str = st.top() + str;\\n                    st.pop();\\n                }                \\n                st.pop();\\n                \\n                string times = \"\";\\n                while(!st.empty() && isdigit(st.top())){\\n                    times = st.top() + times;\\n                    st.pop();\\n                }\\n                \\n                int count = stoi(times);\\n                \\n                while(count--){\\n                    for(int jtr = 0; jtr < str.size(); jtr++){\\n                        st.push(str[jtr]);\\n                    }\\n                }\\n            }\\n            else{\\n                st.push(s[itr]);\\n            }\\n        }\\n        \\n        string res = \"\";\\n        while(!st.empty()){\\n            res += st.top();\\n            st.pop();\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string decodeTheString(string s, int &itr){\\n        string res = \"\";\\n        \\n        while(itr < s.size() && s[itr] != \\']\\'){\\n            if(isdigit(s[itr])){\\n                int num = 0;\\n                while(itr < s.size() && isdigit(s[itr])){\\n                    num = num * 10 + (s[itr++] - \\'0\\');\\n                }\\n                // to escape the \\'[\\'\\n                itr++;\\n                \\n                // store the return result and repeat it num times\\n                string temp = decodeTheString(s, itr);\\n                \\n                // to escape the \\']\\'\\n                itr++;\\n                \\n                while(num--){\\n                    res += temp;\\n                }\\n            }\\n            else{\\n                res += s[itr++];\\n            }\\n        }\\n        \\n        return res;    \\n    }\\n    \\n    string decodeString(string s) {\\n        int itr = 0;\\n        return decodeTheString(s, itr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1638379,
                "title": "very-easy-python-stack-o-n-96-faster",
                "content": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n                \\n        st = []\\n        \\n        for c in s:\\n\\n            if c != \\']\\':\\n                st.append(c)\\n            else:\\n\\t\\t\\t\\t# join the string inside the 1st balanced brackets\\n                tmp = \"\"\\n                while st and st[-1] != \\'[\\':                                        \\n                    tmp = st.pop() + tmp\\n                \\n\\t\\t\\t\\t# pop out the opening `[`\\n                st.pop()\\n                num = \"\"\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# calculate the multiplier\\n                while st and st[-1].isdigit():\\n                    num = st.pop() + num\\n                    \\n                # add the multiplied string back to the stack\\n                st.append(int(num)*tmp)\\n        \\n        return \\'\\'.join(st)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n                \\n        st = []\\n        \\n        for c in s:\\n\\n            if c != \\']\\':\\n                st.append(c)\\n            else:\\n\\t\\t\\t\\t# join the string inside the 1st balanced brackets\\n                tmp = \"\"\\n                while st and st[-1] != \\'[\\':                                        \\n                    tmp = st.pop() + tmp\\n                \\n\\t\\t\\t\\t# pop out the opening `[`\\n                st.pop()\\n                num = \"\"\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# calculate the multiplier\\n                while st and st[-1].isdigit():\\n                    num = st.pop() + num\\n                    \\n                # add the multiplied string back to the stack\\n                st.append(int(num)*tmp)\\n        \\n        return \\'\\'.join(st)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635795,
                "title": "iterative-stack-0ms-100-faster",
                "content": "**Idea?**\\n* Maintain a **stack of strings**.\\n* Whenever we encounter a closing square bracket, we will pick up the string in between this bracket and **duplicate it k time**s.\\n* How do we perform the operations efficiently using stack?\\n* **Hint:- Work on every character of the input string**.\\n* Check detailed commented code\\n\\n```\\nclass Solution {\\npublic: \\n    string decodeString(string s) {\\n        stack<string> st; // stack to maintain string of characters\\n        for(auto& c:s){\\n            if(c==\\']\\'){ //  we need to duplicate the strings between the brackets\\n                string temp = \"\",curr = \"\"; // temp finally stores all the strings between the brackets\\n                while(!st.empty() and st.top()!=\"[\"){\\n                    reverse(st.top().begin(),st.top().end());\\n                    temp += st.top(); // temp picks up each string from stack\\n                    st.pop();\\n                }\\n                st.pop(); // pop the opening bracket\\n                string times = \"\"; // stores the string representation of number of times we need to duplicate\\n                while(!st.empty() and st.top()>=\"0\" and st.top()<=\"9\"){\\n                    times += st.top();\\n                    st.pop();\\n                }\\n                reverse(times.begin(),times.end());\\n                reverse(temp.begin(),temp.end());\\n                int k = stoi(times); // k = number of times we need to duplicate\\n                while(k--)\\n                    curr += temp;\\n                // curr stores the duplicated string\\n                // push string back into stack\\n                if(!st.empty() and st.top()!=\"[\")\\n                    st.top() += curr;  \\n                else\\n                    st.push(curr);\\n            }\\n            else{\\n                string curr = \"\";\\n                curr.push_back(c);\\n                st.push(curr); // push the string representation of the character into the stack\\n            }\\n        }\\n        string ans = \"\"; // stores the final answer\\n        while(!st.empty()){\\n            reverse(st.top().begin(),st.top().end());\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n    \\n    /* If you\\'re getting WA, try this test case:- \"3[z]2[2[y]pq4[2[jk]e1[f]]]ef\"\\n       Correct Output:- \"zzzyypqjkjkefjkjkefjkjkefjkjkefyypqjkjkefjkjkefjkjkefjkjkefef\" */\\n};\\n```\\n**Don\\'t Forget to Upvote!**\\n\\n![image](https://assets.leetcode.com/users/images/e5fbff28-d72c-4cb7-85ae-93793f21fe60_1639908248.8918557.png)\\n",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    string decodeString(string s) {\\n        stack<string> st; // stack to maintain string of characters\\n        for(auto& c:s){\\n            if(c==\\']\\'){ //  we need to duplicate the strings between the brackets\\n                string temp = \"\",curr = \"\"; // temp finally stores all the strings between the brackets\\n                while(!st.empty() and st.top()!=\"[\"){\\n                    reverse(st.top().begin(),st.top().end());\\n                    temp += st.top(); // temp picks up each string from stack\\n                    st.pop();\\n                }\\n                st.pop(); // pop the opening bracket\\n                string times = \"\"; // stores the string representation of number of times we need to duplicate\\n                while(!st.empty() and st.top()>=\"0\" and st.top()<=\"9\"){\\n                    times += st.top();\\n                    st.pop();\\n                }\\n                reverse(times.begin(),times.end());\\n                reverse(temp.begin(),temp.end());\\n                int k = stoi(times); // k = number of times we need to duplicate\\n                while(k--)\\n                    curr += temp;\\n                // curr stores the duplicated string\\n                // push string back into stack\\n                if(!st.empty() and st.top()!=\"[\")\\n                    st.top() += curr;  \\n                else\\n                    st.push(curr);\\n            }\\n            else{\\n                string curr = \"\";\\n                curr.push_back(c);\\n                st.push(curr); // push the string representation of the character into the stack\\n            }\\n        }\\n        string ans = \"\"; // stores the final answer\\n        while(!st.empty()){\\n            reverse(st.top().begin(),st.top().end());\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n    \\n    /* If you\\'re getting WA, try this test case:- \"3[z]2[2[y]pq4[2[jk]e1[f]]]ef\"\\n       Correct Output:- \"zzzyypqjkjkefjkjkefjkjkefjkjkefyypqjkjkefjkjkefjkjkefjkjkefef\" */\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1442416,
                "title": "easy-python-stack-solution-runtime-99-91-memory-usage-99",
                "content": "**Using Stack.**\\n\\n```\\ndef decodeString(self, s: str) -> str:\\n        stack = []\\n        \\n        for ch in s:\\n\\t\\t\\n\\t\\t\\t# whenever a closing bracket arrives in s.\\n            if ch == \"]\":\\n                value  = \"\" # set value to default\\n\\t\\t\\t\\t\\n                #store each character from stack in reverse order.\\n                while stack and stack[-1] != \"[\":\\n                    value = stack.pop() + value\\n                # for example: If stack contains [3, [, c, 12, [, a, b]. Loop will continue till \"[\" and value will store \"ab\".\\n\\t\\t\\t\\t\\n                stack.pop() # Removing Opening Bracket \"[\" from stack.\\n                value *= int(stack.pop()) # Multiplying string to number stored after \"[\" that is 12.\\n                stack.append(value) # Now append the result again in stack for further brackets.\\n                \\n            else:\\n                if ch.isdigit() and stack and stack[-1].isdigit(): \\n\\t\\t\\t\\t\\t# If a number already inserted in stack[-1]. For eg. [3, [, c, 1]\\n                    stack[-1] += ch \\n\\t\\t\\t\\t\\t# now stack becomes [3, [, c, 12]. if ch is 2 this time.\\n                else:\\n\\t\\t\\t\\t\\t# for character other then a number\\n                    stack.append(ch)\\n        \\n        return \"\".join(stack)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\ndef decodeString(self, s: str) -> str:\\n        stack = []\\n        \\n        for ch in s:\\n\\t\\t\\n\\t\\t\\t# whenever a closing bracket arrives in s.\\n            if ch == \"]\":\\n                value  = \"\" # set value to default\\n\\t\\t\\t\\t\\n                #store each character from stack in reverse order.\\n                while stack and stack[-1] != \"[\":\\n                    value = stack.pop() + value\\n                # for example: If stack contains [3, [, c, 12, [, a, b]. Loop will continue till \"[\" and value will store \"ab\".\\n\\t\\t\\t\\t\\n                stack.pop() # Removing Opening Bracket \"[\" from stack.\\n                value *= int(stack.pop()) # Multiplying string to number stored after \"[\" that is 12.\\n                stack.append(value) # Now append the result again in stack for further brackets.\\n                \\n            else:\\n                if ch.isdigit() and stack and stack[-1].isdigit(): \\n\\t\\t\\t\\t\\t# If a number already inserted in stack[-1]. For eg. [3, [, c, 1]\\n                    stack[-1] += ch \\n\\t\\t\\t\\t\\t# now stack becomes [3, [, c, 12]. if ch is 2 this time.\\n                else:\\n\\t\\t\\t\\t\\t# for character other then a number\\n                    stack.append(ch)\\n        \\n        return \"\".join(stack)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1357323,
                "title": "c-100-faster-comments-full-explanation",
                "content": "// I am just going to follow what is written in the question, this is just an implementation question, let me explpain you how \\n// 5 Steps for smooth solution with use of stack\\n// 1 when input is other than \\']\\', it basically means we have to input, because till now we donot know what should be the substring that needed to be multiplied, so we just keep in inputing the characters \\n// 2 when we hit \\']\\' then we pop character untill we get \\'[\\' because it opening of the string naa so we get our required string(Implementation is shown below)\\n// 3 now pop for the number of time it needed to be added again \\n// 4 then just add string, the required number of time\\n// 5 At last just pop from it, reverse and return the string \\n\\n// Implementation with steps marked are given in the code \\n// Hope it helps \\n```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<char>st;\\n        string ans = \"\";\\n        for(int i=0;i<s.size();i++){\\n            // Step1 \\n            if(s[i]!=\\']\\'){\\n                st.push(s[i]);\\n            }else{\\n                // Step2\\n                string temp = \"\";\\n                while(st.top()!=\\'[\\'){\\n                    temp += st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                // Step3\\n                string num = \"\";\\n                while(!st.empty() && st.top()>=\\'0\\' && st.top()<=\\'9\\'){\\n                    num += st.top();\\n                    st.pop();\\n                }\\n                reverse(num.begin(),num.end());\\n                int n = stoi(num);\\n                // Step4\\n                for(int k=0;k<n;k++){\\n                    for(int j=temp.size()-1;j>=0;j--){\\n                        st.push(temp[j]);\\n                    }\\n                }\\n            }\\n        }\\n        // Step5 \\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<char>st;\\n        string ans = \"\";\\n        for(int i=0;i<s.size();i++){\\n            // Step1 \\n            if(s[i]!=\\']\\'){\\n                st.push(s[i]);\\n            }else{\\n                // Step2\\n                string temp = \"\";\\n                while(st.top()!=\\'[\\'){\\n                    temp += st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                // Step3\\n                string num = \"\";\\n                while(!st.empty() && st.top()>=\\'0\\' && st.top()<=\\'9\\'){\\n                    num += st.top();\\n                    st.pop();\\n                }\\n                reverse(num.begin(),num.end());\\n                int n = stoi(num);\\n                // Step4\\n                for(int k=0;k<n;k++){\\n                    for(int j=temp.size()-1;j>=0;j--){\\n                        st.push(temp[j]);\\n                    }\\n                }\\n            }\\n        }\\n        // Step5 \\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1016302,
                "title": "using-queue-and-dfs",
                "content": "```\\nclass Solution {\\n    public String decodeString(String s) {\\n        Queue<Character> queue = new ArrayDeque<>();\\n        \\n        for(char c : s.toCharArray()) {\\n            queue.offer(c);\\n        }\\n        \\n        return dfs(queue);\\n    }\\n    \\n    public String dfs(Queue<Character> queue) {\\n        int num = 0;\\n        StringBuilder builder = new StringBuilder();\\n        \\n        while(!queue.isEmpty()) {\\n            char c = queue.poll();\\n            \\n            if(\\'0\\' <= c && c <= \\'9\\') {\\n                num = num * 10 + (c-\\'0\\');\\n            } else if( c ==\\'[\\'){\\n                builder.append(dfs(queue).repeat(num));\\n                num = 0;\\n            } else {\\n                if( \\'a\\' <= c && c <= \\'z\\') {\\n                    builder.append(c);\\n                }\\n                \\n                if(c == \\']\\') {\\n                    break;\\n                }\\n            }\\n        }\\n        return builder.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeString(String s) {\\n        Queue<Character> queue = new ArrayDeque<>();\\n        \\n        for(char c : s.toCharArray()) {\\n            queue.offer(c);\\n        }\\n        \\n        return dfs(queue);\\n    }\\n    \\n    public String dfs(Queue<Character> queue) {\\n        int num = 0;\\n        StringBuilder builder = new StringBuilder();\\n        \\n        while(!queue.isEmpty()) {\\n            char c = queue.poll();\\n            \\n            if(\\'0\\' <= c && c <= \\'9\\') {\\n                num = num * 10 + (c-\\'0\\');\\n            } else if( c ==\\'[\\'){\\n                builder.append(dfs(queue).repeat(num));\\n                num = 0;\\n            } else {\\n                if( \\'a\\' <= c && c <= \\'z\\') {\\n                    builder.append(c);\\n                }\\n                \\n                if(c == \\']\\') {\\n                    break;\\n                }\\n            }\\n        }\\n        return builder.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 942487,
                "title": "c-o-n-two-pass-beats-98",
                "content": "### Idea overview\\n1. In the first pass ony create a map of opening - closing brackets (using simple stack method)\\n2. In the second pass use above information for each opening bracket index and call a helper method with respective indexes\\n\\nRuntime: 76 ms, faster than 98.03% of C# online submissions for Decode String.\\nMemory Usage: 23.4 MB, less than 34.83% of C# online submissions for Decode String.\\n```\\npublic class Solution\\n{\\n\\tint[] brackets = new int[30];\\n\\tpublic string DecodeString(string s)\\n\\t{\\n\\t\\tStack<int> stack = new Stack<int>();\\n\\t\\tfor(int i=0; i<s.Length; i++)\\n\\t\\t{\\n\\t\\t\\tvar c = s[i];\\n\\t\\t\\tif(c == \\'[\\')\\n\\t\\t\\t\\tstack.Push(i);\\n\\t\\t\\telse if (c == \\']\\')\\n\\t\\t\\t\\tbrackets[stack.Pop()] = i;\\n\\t\\t}\\n\\n\\t\\treturn Helper(s, 0, s.Length - 1);\\n\\t}\\n\\n\\tprivate string Helper(string s, int start, int end)\\n\\t{\\n\\t\\tstring res = \"\";\\n\\t\\twhile(start <= end)\\n\\t\\t{\\n\\t\\t\\tvar c = s[start++];\\n\\t\\t\\tif(Char.IsLetter(c))\\n\\t\\t\\t\\tres += c;\\n\\t\\t\\telse if(Char.IsDigit(c))\\n\\t\\t\\t{\\n\\t\\t\\t\\tint num = int.Parse(c.ToString());\\n\\t\\t\\t\\twhile(s[start] != \\'[\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint n;\\n\\t\\t\\t\\t\\tif(int.TryParse(s[start++].ToString(), out n))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnum *= 10;\\n\\t\\t\\t\\t\\t\\tnum += n;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar inner = Helper(s, start + 1, brackets[start] - 1);\\n\\t\\t\\t\\tfor(int i=0; i<num; i++)\\n\\t\\t\\t\\t\\tres += inner;\\n\\t\\t\\t\\tstart = brackets[start] + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn res;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n\\tint[] brackets = new int[30];\\n\\tpublic string DecodeString(string s)\\n\\t{\\n\\t\\tStack<int> stack = new Stack<int>();\\n\\t\\tfor(int i=0; i<s.Length; i++)\\n\\t\\t{\\n\\t\\t\\tvar c = s[i];\\n\\t\\t\\tif(c == \\'[\\')\\n\\t\\t\\t\\tstack.Push(i);\\n\\t\\t\\telse if (c == \\']\\')\\n\\t\\t\\t\\tbrackets[stack.Pop()] = i;\\n\\t\\t}\\n\\n\\t\\treturn Helper(s, 0, s.Length - 1);\\n\\t}\\n\\n\\tprivate string Helper(string s, int start, int end)\\n\\t{\\n\\t\\tstring res = \"\";\\n\\t\\twhile(start <= end)\\n\\t\\t{\\n\\t\\t\\tvar c = s[start++];\\n\\t\\t\\tif(Char.IsLetter(c))\\n\\t\\t\\t\\tres += c;\\n\\t\\t\\telse if(Char.IsDigit(c))\\n\\t\\t\\t{\\n\\t\\t\\t\\tint num = int.Parse(c.ToString());\\n\\t\\t\\t\\twhile(s[start] != \\'[\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint n;\\n\\t\\t\\t\\t\\tif(int.TryParse(s[start++].ToString(), out n))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnum *= 10;\\n\\t\\t\\t\\t\\t\\tnum += n;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar inner = Helper(s, start + 1, brackets[start] - 1);\\n\\t\\t\\t\\tfor(int i=0; i<num; i++)\\n\\t\\t\\t\\t\\tres += inner;\\n\\t\\t\\t\\tstart = brackets[start] + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn res;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941590,
                "title": "python3-easy-solution-faster-than-90",
                "content": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        index=s.find(\"]\")\\n        char=\"\"\\n        digit=\"\"\\n        while index!=-1:\\n            print(index)\\n            for i in range(index-1,0,-1):\\n                if s[i]==\"[\":\\n                    for j in range(i-1,-1,-1):\\n                        if s[j].isdigit():\\n                            digit+=s[j]\\n                        else:\\n                            break  \\n                    s=s.replace(f\"{digit[::-1]}[{char[::-1]}]\",int(digit[::-1])*char[::-1],1)\\n                    break\\n                char+=s[i]\\n            char=\"\"\\n            digit=\"\"\\n            index=s.find(\"]\")\\n        return s\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        index=s.find(\"]\")\\n        char=\"\"\\n        digit=\"\"\\n        while index!=-1:\\n            print(index)\\n            for i in range(index-1,0,-1):\\n                if s[i]==\"[\":\\n                    for j in range(i-1,-1,-1):\\n                        if s[j].isdigit():\\n                            digit+=s[j]\\n                        else:\\n                            break  \\n                    s=s.replace(f\"{digit[::-1]}[{char[::-1]}]\",int(digit[::-1])*char[::-1],1)\\n                    break\\n                char+=s[i]\\n            char=\"\"\\n            digit=\"\"\\n            index=s.find(\"]\")\\n        return s\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 941467,
                "title": "pure-recursion-direct-translation-of-recurrence-relation",
                "content": "```\\n\"\"\"\\n## Base Cases\\nF(None) = \"\"\\nF(alpha_str) = alpha_str\\n\\n## Recurrence\\nF(alpha_str + d + [X] + Y) = alpha_str + sum_d(F(X)) + F(Y)\\n\\nNote: + = string concatenation; sum_d = sum over d\\n\"\"\"\\n\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        \\n        def F(s):\\n            ### Base Cases\\n            ## F(None) & F(alpha_str)\\n            if not s or s.isalpha(): return s             \\n            \\n            ### Recurrence \\n            ## F(alpha_str + d + [X] + Y) = alpha_str + sum_d(F(X)) + F(Y)\\n            \\n            ## alpha_str\\n            alpha_str = \"\"; i = 0\\n            while s[i].isalpha():\\n                alpha_str += s[i]\\n                i += 1\\n        \\n            ## d\\n            d = \"\"\\n            while s[i].isdigit():\\n                d += s[i]\\n                i += 1\\n            d = int(d)\\n            \\n            ## X\\n            j = i + 1; X = \"\"; open_brackets = 1\\n            while open_brackets != 0:\\n                if   s[j] == \"[\": open_brackets += 1\\n                elif s[j] == \"]\": open_brackets -= 1\\n                j += 1                \\n            X = s[i+1:j-1]\\n                    \\n            ## Y\\n            Y = s[j:]\\n    \\n            ## = \\n            return alpha_str + d * F(X) + F(Y)\\n \\n        return F(s)",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n\"\"\"\\n## Base Cases\\nF(None) = \"\"\\nF(alpha_str) = alpha_str\\n\\n## Recurrence\\nF(alpha_str + d + [X] + Y) = alpha_str + sum_d(F(X)) + F(Y)\\n\\nNote: + = string concatenation; sum_d = sum over d\\n\"\"\"\\n\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        \\n        def F(s):\\n            ### Base Cases\\n            ## F(None) & F(alpha_str)\\n            if not s or s.isalpha(): return s             \\n            \\n            ### Recurrence \\n            ## F(alpha_str + d + [X] + Y) = alpha_str + sum_d(F(X)) + F(Y)\\n            \\n            ## alpha_str\\n            alpha_str = \"\"; i = 0\\n            while s[i].isalpha():\\n                alpha_str += s[i]\\n                i += 1\\n        \\n            ## d\\n            d = \"\"\\n            while s[i].isdigit():\\n                d += s[i]\\n                i += 1\\n            d = int(d)\\n            \\n            ## X\\n            j = i + 1; X = \"\"; open_brackets = 1\\n            while open_brackets != 0:\\n                if   s[j] == \"[\": open_brackets += 1\\n                elif s[j] == \"]\": open_brackets -= 1\\n                j += 1                \\n            X = s[i+1:j-1]\\n                    \\n            ## Y\\n            Y = s[j:]\\n    \\n            ## = \\n            return alpha_str + d * F(X) + F(Y)\\n \\n        return F(s)",
                "codeTag": "Java"
            },
            {
                "id": 684345,
                "title": "short-java-solution",
                "content": "```\\nclass Solution {\\n    public String decodeString(String s) {\\n        Stack<Integer> timeSt = new Stack<>();\\n        Stack<StringBuilder> builderSt = new Stack<>();     \\n        int times = 0;\\n        builderSt.push(new StringBuilder());\\n        for(int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            if(ch == \\'[\\') {\\n                builderSt.push(new StringBuilder());\\n                timeSt.push(times);\\n                times = 0;\\n            } else if(ch == \\']\\') {\\n                String str = builderSt.pop().toString(); \\n                int time = timeSt.pop();\\n                StringBuilder builder = builderSt.peek();\\n                for(int j = 0; j < time; j++) builder.append(str);\\n            } else if(ch - \\'0\\' >= 0 && ch - \\'0\\' <= 9) {\\n                times = times * 10 + (ch - \\'0\\');\\n            } else {\\n                builderSt.peek().append(ch);\\n            }\\n        }\\n        \\n        return builderSt.pop().toString(); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeString(String s) {\\n        Stack<Integer> timeSt = new Stack<>();\\n        Stack<StringBuilder> builderSt = new Stack<>();     \\n        int times = 0;\\n        builderSt.push(new StringBuilder());\\n        for(int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            if(ch == \\'[\\') {\\n                builderSt.push(new StringBuilder());\\n                timeSt.push(times);\\n                times = 0;\\n            } else if(ch == \\']\\') {\\n                String str = builderSt.pop().toString(); \\n                int time = timeSt.pop();\\n                StringBuilder builder = builderSt.peek();\\n                for(int j = 0; j < time; j++) builder.append(str);\\n            } else if(ch - \\'0\\' >= 0 && ch - \\'0\\' <= 9) {\\n                times = times * 10 + (ch - \\'0\\');\\n            } else {\\n                builderSt.peek().append(ch);\\n            }\\n        }\\n        \\n        return builderSt.pop().toString(); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 596048,
                "title": "python-easy-to-follow-solution-using-stack",
                "content": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        stack = []\\n        \\n        for i in s:\\n            if i != \\']\\':\\n                stack.append(i)\\n                continue\\n            tmp = \\'\\'\\n            while stack and stack[-1] != \\'[\\':\\n                tmp = stack.pop() + tmp\\n            stack.pop()\\n            num = \\'\\'\\n            while stack and stack[-1].isnumeric():\\n                num = stack.pop() + num\\n            stack.append(int(num)*tmp)\\n            \\n        return \\'\\'.join(stack)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        stack = []\\n        \\n        for i in s:\\n            if i != \\']\\':\\n                stack.append(i)\\n                continue\\n            tmp = \\'\\'\\n            while stack and stack[-1] != \\'[\\':\\n                tmp = stack.pop() + tmp\\n            stack.pop()\\n            num = \\'\\'\\n            while stack and stack[-1].isnumeric():\\n                num = stack.pop() + num\\n            stack.append(int(num)*tmp)\\n            \\n        return \\'\\'.join(stack)",
                "codeTag": "Java"
            },
            {
                "id": 511060,
                "title": "java-solution-beats-100-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String decodeString(String s) {\\n        Stack<Integer> numStack = new Stack<>();\\n        Stack<String> strStack = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n        int n=s.length();\\n        for (int i=0; i<n; ++i){\\n            char c = s.charAt(i);\\n            if (Character.isDigit(c)){\\n                int num = c-\\'0\\';\\n                while (i+1 < n && Character.isDigit(s.charAt(i+1))){\\n                    num = num*10 + s.charAt(i+1)-\\'0\\';\\n                    i++;\\n                }\\n                numStack.push(num);\\n            }\\n            else if (c == \\'[\\'){\\n                strStack.push(sb.toString());\\n                sb = new StringBuilder();\\n            }\\n            else if (c == \\']\\'){\\n                int repeats = numStack.pop();\\n                StringBuilder temp = new StringBuilder(strStack.pop());\\n                for (int j=0; j<repeats; ++j){\\n                    temp.append(sb);\\n                }\\n                sb = temp;\\n            }\\n            else\\n                sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeString(String s) {\\n        Stack<Integer> numStack = new Stack<>();\\n        Stack<String> strStack = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n        int n=s.length();\\n        for (int i=0; i<n; ++i){\\n            char c = s.charAt(i);\\n            if (Character.isDigit(c)){\\n                int num = c-\\'0\\';\\n                while (i+1 < n && Character.isDigit(s.charAt(i+1))){\\n                    num = num*10 + s.charAt(i+1)-\\'0\\';\\n                    i++;\\n                }\\n                numStack.push(num);\\n            }\\n            else if (c == \\'[\\'){\\n                strStack.push(sb.toString());\\n                sb = new StringBuilder();\\n            }\\n            else if (c == \\']\\'){\\n                int repeats = numStack.pop();\\n                StringBuilder temp = new StringBuilder(strStack.pop());\\n                for (int j=0; j<repeats; ++j){\\n                    temp.append(sb);\\n                }\\n                sb = temp;\\n            }\\n            else\\n                sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478713,
                "title": "javascript-recursive",
                "content": "Recursive is like using a stack, Its just cleaner.\\nI have no idea why the execution is 60 ms for me.\\n\\n```\\nvar decodeString = function(s) {\\n    return helper(s, \"\")\\n    \\n    function helper(s, str){\\n        let num = 0;\\n        for(let i = 0; i < s.length; i++){\\n            let x = s.substr(i, 1);\\n            \\n            if(x == \\'[\\'){\\n                let result, n;\\n                [result, n] = helper(s.substr(i+1), \"\");\\n                while(num > 0){\\n                    str += result;\\n                    num--;\\n                }\\n                i += n;\\n            }\\n            else if(x == \\']\\') return [str, ++i]\\n            \\n            else if(!isNaN(x)) num = num*10 + parseInt(x);\\n            else str += x;\\n        }\\n        return str\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar decodeString = function(s) {\\n    return helper(s, \"\")\\n    \\n    function helper(s, str){\\n        let num = 0;\\n        for(let i = 0; i < s.length; i++){\\n            let x = s.substr(i, 1);\\n            \\n            if(x == \\'[\\'){\\n                let result, n;\\n                [result, n] = helper(s.substr(i+1), \"\");\\n                while(num > 0){\\n                    str += result;\\n                    num--;\\n                }\\n                i += n;\\n            }\\n            else if(x == \\']\\') return [str, ++i]\\n            \\n            else if(!isNaN(x)) num = num*10 + parseInt(x);\\n            else str += x;\\n        }\\n        return str\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 442387,
                "title": "swift-94-100-with-explanation",
                "content": "```\\nclass Solution {\\n    func decodeString(_ s: String) -> String {\\n        guard s.count > 0 else {\\n            return \"\"\\n        }\\n        \\n        //multiplier stack record k, the number of repeating times\\n        var multiplierStack = [Int]()\\n        \\n        //prefix stack record the substrings before the bracket\\n        var prefixStack = [String]()\\n        \\n        var numberString = \"\"\\n        var subString = \"\"\\n        \\n        //if the string start with charater, treat it as 1[...]\\n        if !s.first!.isNumber {\\n            multiplierStack.append(1)\\n        }\\n\\t\\t\\n        for char in s {\\n            if char.isNumber {\\n\\t\\t\\t\\t// -- In the case char is \"number\", save it by numberString, \\n\\t\\t\\t\\t// because number can be multiple digits\\n                numberString.append(char)\\n            } else if char == \"[\" {\\n\\t\\t\\t\\t// -- In the case char is \"[\", we know we finish recoding the last \\n\\t\\t\\t\\t// digit of the Int, so we push it to stack as type of Int value, \\n\\t\\t\\t\\t// also push the subString to another stack as prefix\\n                multiplierStack.append(Int(numberString)!)\\n                prefixStack.append(subString)\\n                numberString = \"\"\\n                subString = \"\"\\n            } else if char == \"]\" {\\n\\t\\t\\t\\t // -- In the case char is \"]\", we know this is the end of a repeating\\n\\t\\t\\t\\t// case, and there are prefix and mutiplier in the stack ready to use\\n\\t\\t\\t\\t// and form the repeating chars.\\n                let multiplier = multiplierStack.removeLast()\\n                var temp = \"\"\\n                for index in 0..<multiplier {\\n                    temp.append(subString)\\n                }\\n                let prefix = prefixStack.removeLast()\\n                subString = prefix + temp\\n            } else {\\n\\t\\t\\t\\t// -- In the case char is \"character\", save it by subString\\n                subString.append(char)\\n            }\\n        }\\n        \\n        return subString\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func decodeString(_ s: String) -> String {\\n        guard s.count > 0 else {\\n            return \"\"\\n        }\\n        \\n        //multiplier stack record k, the number of repeating times\\n        var multiplierStack = [Int]()\\n        \\n        //prefix stack record the substrings before the bracket\\n        var prefixStack = [String]()\\n        \\n        var numberString = \"\"\\n        var subString = \"\"\\n        \\n        //if the string start with charater, treat it as 1[...]\\n        if !s.first!.isNumber {\\n            multiplierStack.append(1)\\n        }\\n\\t\\t\\n        for char in s {\\n            if char.isNumber {\\n\\t\\t\\t\\t// -- In the case char is \"number\", save it by numberString, \\n\\t\\t\\t\\t// because number can be multiple digits\\n                numberString.append(char)\\n            } else if char == \"[\" {\\n\\t\\t\\t\\t// -- In the case char is \"[\", we know we finish recoding the last \\n\\t\\t\\t\\t// digit of the Int, so we push it to stack as type of Int value, \\n\\t\\t\\t\\t// also push the subString to another stack as prefix\\n                multiplierStack.append(Int(numberString)!)\\n                prefixStack.append(subString)\\n                numberString = \"\"\\n                subString = \"\"\\n            } else if char == \"]\" {\\n\\t\\t\\t\\t // -- In the case char is \"]\", we know this is the end of a repeating\\n\\t\\t\\t\\t// case, and there are prefix and mutiplier in the stack ready to use\\n\\t\\t\\t\\t// and form the repeating chars.\\n                let multiplier = multiplierStack.removeLast()\\n                var temp = \"\"\\n                for index in 0..<multiplier {\\n                    temp.append(subString)\\n                }\\n                let prefix = prefixStack.removeLast()\\n                subString = prefix + temp\\n            } else {\\n\\t\\t\\t\\t// -- In the case char is \"character\", save it by subString\\n                subString.append(char)\\n            }\\n        }\\n        \\n        return subString\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 400101,
                "title": "python-o-n-100-faster-with-explanation",
                "content": "When we see pair matching, like parenthesis match / start-end / check-first-with-last etc. Stacks should be our go-to data structure.\\nThe code is quite intuitive. \\nIf needed, I can answer the questions in comment section.\\n```\\nclass Solution(object):\\n    def decodeString(self, s):\\n        stack = []\\n        result = \"\"\\n        i, n = 0, len(s)\\n        \\n        while i < n:\\n            if s[i].isdigit():\\n                num = \"\"\\n\\t\\t\\t\\t#Extract the number\\n                while i < n and s[i].isdigit():\\n                    num += s[i]\\n                    i += 1\\n\\t\\t\\t\\t#Skip \\'[\\'\\n                i += 1\\n                string = \"\"\\n\\t\\t\\t\\t#Extract the string after the number \\n                while i < n and s[i].isalpha():\\n                    string += s[i]\\n                    i += 1\\n                stack.append([int(num), string])\\n                continue\\n            if s[i] == \\']\\':\\n\\t\\t\\t\\t#If you see a closing bracket, pop the stack pop and multiply it num times.\\n                num, string = stack.pop()\\n                string = string * num\\n                i += 1\\n            else:\\n\\t\\t\\t\\t#This is the case when some part of the string are not enclosed within the []\\n                string = \"\"\\n                while i < n and s[i].isalpha():\\n                    string += s[i]\\n                    i += 1\\n            if stack:\\n\\t\\t\\t\\t#If the stack is not empty, the popped & multiplied string might have to be multiplied again.\\n                stack[-1][1] += string\\n            else:\\n\\t\\t\\t\\t#If the stack is empty, no parent, just add it to the result.\\n                result += string\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def decodeString(self, s):\\n        stack = []\\n        result = \"\"\\n        i, n = 0, len(s)\\n        \\n        while i < n:\\n            if s[i].isdigit():\\n                num = \"\"\\n\\t\\t\\t\\t#Extract the number\\n                while i < n and s[i].isdigit():\\n                    num += s[i]\\n                    i += 1\\n\\t\\t\\t\\t#Skip \\'[\\'\\n                i += 1\\n                string = \"\"\\n\\t\\t\\t\\t#Extract the string after the number \\n                while i < n and s[i].isalpha():\\n                    string += s[i]\\n                    i += 1\\n                stack.append([int(num), string])\\n                continue\\n            if s[i] == \\']\\':\\n\\t\\t\\t\\t#If you see a closing bracket, pop the stack pop and multiply it num times.\\n                num, string = stack.pop()\\n                string = string * num\\n                i += 1\\n            else:\\n\\t\\t\\t\\t#This is the case when some part of the string are not enclosed within the []\\n                string = \"\"\\n                while i < n and s[i].isalpha():\\n                    string += s[i]\\n                    i += 1\\n            if stack:\\n\\t\\t\\t\\t#If the stack is not empty, the popped & multiplied string might have to be multiplied again.\\n                stack[-1][1] += string\\n            else:\\n\\t\\t\\t\\t#If the stack is empty, no parent, just add it to the result.\\n                result += string\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 377882,
                "title": "easy-understand-python-3-solution",
                "content": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        numstack = []\\n        resstack = []\\n        res = \\'\\'\\n        n = \\'\\'\\n        \\n        for i in s:\\n            if i.isdigit():\\n                n += i\\n            elif i.isalpha():\\n                res += i\\n            elif i == \"[\":\\n                numstack.append(int(n))\\n                resstack.append(res)\\n                n = \\'\\'\\n                res = \\'\\'\\n            else:\\n                newstr = resstack.pop()\\n                repeat = numstack.pop()\\n                res = newstr + res * repeat\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        numstack = []\\n        resstack = []\\n        res = \\'\\'\\n        n = \\'\\'\\n        \\n        for i in s:\\n            if i.isdigit():\\n                n += i\\n            elif i.isalpha():\\n                res += i\\n            elif i == \"[\":\\n                numstack.append(int(n))\\n                resstack.append(res)\\n                n = \\'\\'\\n                res = \\'\\'\\n            else:\\n                newstr = resstack.pop()\\n                repeat = numstack.pop()\\n                res = newstr + res * repeat\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354083,
                "title": "beats-100-cpp-solutions-very-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n    \\n    int i=0; \\n    return decode(s, i);\\n    }\\n    \\n    string decode(string &s, int &i)\\n    {\\n        int count;\\n        string result;\\n        while(i<s.size())\\n        {\\n            if(isdigit(s[i]))\\n            {\\n                int beg = i;\\n                while(isdigit(s[i]))\\n                    i++;\\n                count = stoi(s.substr(beg, i-beg));\\n            }\\n            if(s[i] == \\'[\\')\\n            {\\n                string temp = decode(s, ++i);\\n                while(count--)\\n                    result = result + temp;\\n            }\\n            else\\n            if(isalpha(s[i]))\\n            {\\n                result = result + s[i];\\n            }\\n            else\\n            {\\n                return(result);\\n            }\\n            i++;\\n        }\\n        return(result);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n    \\n    int i=0; \\n    return decode(s, i);\\n    }\\n    \\n    string decode(string &s, int &i)\\n    {\\n        int count;\\n        string result;\\n        while(i<s.size())\\n        {\\n            if(isdigit(s[i]))\\n            {\\n                int beg = i;\\n                while(isdigit(s[i]))\\n                    i++;\\n                count = stoi(s.substr(beg, i-beg));\\n            }\\n            if(s[i] == \\'[\\')\\n            {\\n                string temp = decode(s, ++i);\\n                while(count--)\\n                    result = result + temp;\\n            }\\n            else\\n            if(isalpha(s[i]))\\n            {\\n                result = result + s[i];\\n            }\\n            else\\n            {\\n                return(result);\\n            }\\n            i++;\\n        }\\n        return(result);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 275221,
                "title": "recursion-python-solution-with-detailed-explanation",
                "content": "Multiple brackets within a bracket make this question more complicated. In order to make the solution almost O(n), whenever you encounter a bracket that encloses a complete bracket set, you call recursion on just the middle part, so that you get a clean alphabet solution of the middle operation. Once you receive the \"middle\", you can complete the answer by finding the k in front of the middle part and stitching everything else together. \\n\\nHow to find the middle part that is enclosed by the outer-most bracket:\\nYou interate through the string and store all the opening brackets\\' index numbers in the stack and and keep on popping it out when you encounter a closing bracket. You know that you encountered the outer-most bracket when the stack is empty after popping. then you call recursion on the middle part using the indices and then once you receive the \"middle\", then you multiply it by k. (k could be greater than 10, so i look for \"numstart\")\\n\\nIf stack is empty, and you encounter an alphabet, you know that it\\'s not part of the bracket operation and just add it to the \"res\" string. \\n\\neg)\\ndecodeString(\"3[a2[c]]\") -> call recursion decodeString(\"a2[c]\") -> call recursion decodeString(\"c\")\\n\\ndecodeString(\"c\") returns \"c\"\\ndecodeString(\"a2[c]\") returns \"acc\"\\ndecodeString(\"3[a2[c]]\") returns \"accaccacc\"\\n\\n```\\nclass Solution:\\n\\tdef decodeString(self, s:str) -> str:\\n\\t\\tstack = []\\n\\t\\tres = \"\"\\n\\t\\tfor i in range(len(s)):\\n\\t\\t\\tif s[i] == \"[\":\\n\\t\\t\\t\\tstack.append(i)\\n\\t\\t\\telif s[i] == \"]\":\\n\\t\\t\\t\\tstartIndex = stack.pop()\\n\\t\\t\\t\\tif stack == []:\\n\\t\\t\\t\\t\\tmiddle = self.decodeString(s[startIndex + 1: i])\\n\\t\\t\\t\\t\\tnumstart = startIndex\\n\\t\\t\\t\\t\\twhile numstart - 1 >= 0 and s[numstart - 1].isdigit():\\n\\t\\t\\t\\t\\t\\tnumstart -= 1\\n\\t\\t\\t\\t\\tadd_string = int(s[numstart:startIndex]) * middle\\n\\t\\t\\t\\t\\tres += add_string\\n\\t\\t\\telif stack == [] and s[i].isalpha():\\n\\t\\t\\t\\tres += s[i]\\n\\t\\t\\n\\t\\treturn res\\n````",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\tdef decodeString(self, s:str) -> str:\\n\\t\\tstack = []\\n\\t\\tres = \"\"\\n\\t\\tfor i in range(len(s)):\\n\\t\\t\\tif s[i] == \"[\":\\n\\t\\t\\t\\tstack.append(i)\\n\\t\\t\\telif s[i] == \"]\":\\n\\t\\t\\t\\tstartIndex = stack.pop()\\n\\t\\t\\t\\tif stack == []:\\n\\t\\t\\t\\t\\tmiddle = self.decodeString(s[startIndex + 1: i])\\n\\t\\t\\t\\t\\tnumstart = startIndex\\n\\t\\t\\t\\t\\twhile numstart - 1 >= 0 and s[numstart - 1].isdigit():\\n\\t\\t\\t\\t\\t\\tnumstart -= 1\\n\\t\\t\\t\\t\\tadd_string = int(s[numstart:startIndex]) * middle\\n\\t\\t\\t\\t\\tres += add_string\\n\\t\\t\\telif stack == [] and s[i].isalpha():\\n\\t\\t\\t\\tres += s[i]\\n\\t\\t\\n\\t\\treturn res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 245538,
                "title": "javascript-using-regex",
                "content": "Simple Javascript version with Regex.\\n\\n``` Javascript\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nfunction decodeString1(s) {\\n    return s.replace(/(\\\\d+\\\\[\\\\w+\\\\])/gi, function(item) {\\n        var match = /(\\\\d+)\\\\[(\\\\w+)\\\\]/.exec(item);\\n        var repeat = parseInt(match[1]);\\n        var pattern = match[2];\\n        \\n        var result = \"\";\\n        while(repeat-- > 0) {\\n            result += pattern;\\n        }\\n        return result;\\n    });\\n};\\n\\nvar decodeString = function(s) {\\n    while(/\\\\d+\\\\[\\\\w+\\\\]/gi.test(s)) {\\n        s = decodeString1(s);\\n    }\\n    return s;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` Javascript\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nfunction decodeString1(s) {\\n    return s.replace(/(\\\\d+\\\\[\\\\w+\\\\])/gi, function(item) {\\n        var match = /(\\\\d+)\\\\[(\\\\w+)\\\\]/.exec(item);\\n        var repeat = parseInt(match[1]);\\n        var pattern = match[2];\\n        \\n        var result = \"\";\\n        while(repeat-- > 0) {\\n            result += pattern;\\n        }\\n        return result;\\n    });\\n};\\n\\nvar decodeString = function(s) {\\n    while(/\\\\d+\\\\[\\\\w+\\\\]/gi.test(s)) {\\n        s = decodeString1(s);\\n    }\\n    return s;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 190485,
                "title": "very-easy-dfs-solution-with-no-stack",
                "content": "```\\n    private int i = 0;\\n    public String decodeString(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int num = 0;\\n        \\n        while (i < s.length()) {\\n            char c = s.charAt(i);\\n            \\n            if (c >= \\'0\\' && c <= \\'9\\') {\\n                num = num * 10 + c - \\'0\\';\\n            } else if (c == \\'[\\') {\\n                i++;\\n                String str = decodeString(s);\\n                for (int k = 0; k < num; k++) \\n                    sb.append(str);\\n                num = 0;\\n            } else if (c == \\']\\') {\\n                return sb.toString();\\n            } else {\\n                sb.append(c);\\n            }\\n            i++;\\n        }\\n        \\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private int i = 0;\\n    public String decodeString(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int num = 0;\\n        \\n        while (i < s.length()) {\\n            char c = s.charAt(i);\\n            \\n            if (c >= \\'0\\' && c <= \\'9\\') {\\n                num = num * 10 + c - \\'0\\';\\n            } else if (c == \\'[\\') {\\n                i++;\\n                String str = decodeString(s);\\n                for (int k = 0; k < num; k++) \\n                    sb.append(str);\\n                num = 0;\\n            } else if (c == \\']\\') {\\n                return sb.toString();\\n            } else {\\n                sb.append(c);\\n            }\\n            i++;\\n        }\\n        \\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 163114,
                "title": "python-solution",
                "content": "DFS recursive:\\n```\\nclass Solution(object):\\n    def decodeString(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        res = \"\"\\n        for i in range(len(s)):\\n            if s[i].isalpha():\\n                res += s[i]\\n            elif s[i].isnumeric():\\n                a = s[i]\\n                j = i+1\\n                while s[j].isnumeric():\\n                    a += s[j]\\n                    j += 1\\n                num = int(a)\\n                j += 1\\n                l = j\\n                count = 1\\n                while count != 0:\\n                    if s[j] == \"[\":\\n                        count += 1\\n                    elif s[j] == \"]\":\\n                        count -= 1\\n                    j += 1\\n                return res + num*self.decodeString(s[l:j-1]) + self.decodeString(s[j:])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def decodeString(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        res = \"\"\\n        for i in range(len(s)):\\n            if s[i].isalpha():\\n                res += s[i]\\n            elif s[i].isnumeric():\\n                a = s[i]\\n                j = i+1\\n                while s[j].isnumeric():\\n                    a += s[j]\\n                    j += 1\\n                num = int(a)\\n                j += 1\\n                l = j\\n                count = 1\\n                while count != 0:\\n                    if s[j] == \"[\":\\n                        count += 1\\n                    elif s[j] == \"]\":\\n                        count -= 1\\n                    j += 1\\n                return res + num*self.decodeString(s[l:j-1]) + self.decodeString(s[j:])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141504,
                "title": "c-easy-to-understand-solution-using-stacks",
                "content": "```\\npublic class Solution {\\n    public string DecodeString(string s) {\\n        String res = string.Empty;\\n        Stack<string> resStack = new Stack<string>();\\n        Stack<int> countStack = new Stack<int>();\\n        int currIndex = 0;\\n        while (currIndex < s.Length)\\n        {\\n            if (char.IsDigit(s[currIndex]))\\n            {\\n                int count = s[currIndex] - \\'0\\';\\n                currIndex++;\\n                while (char.IsDigit(s[currIndex]))\\n                {\\n                    count = 10 * count + (s[currIndex] - \\'0\\');\\n                    currIndex++;           \\n                }\\n                countStack.Push(count);\\n            }\\n            else if (s[currIndex] == \\'[\\')\\n            {\\n                resStack.Push(res);\\n                res = string.Empty;\\n                currIndex++; \\n            }\\n            else if (s[currIndex] == \\']\\')\\n            {                    \\n                StringBuilder repeatString = new StringBuilder();\\n                int repeatTimes = countStack.Pop();\\n                for (int i = 0; i < repeatTimes; i++)\\n                    repeatString.Append(res);\\n                res = resStack.Pop() + repeatString.ToString();                   \\n                currIndex++;\\n            }\\n            else\\n            {\\n                res += s[currIndex++];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string DecodeString(string s) {\\n        String res = string.Empty;\\n        Stack<string> resStack = new Stack<string>();\\n        Stack<int> countStack = new Stack<int>();\\n        int currIndex = 0;\\n        while (currIndex < s.Length)\\n        {\\n            if (char.IsDigit(s[currIndex]))\\n            {\\n                int count = s[currIndex] - \\'0\\';\\n                currIndex++;\\n                while (char.IsDigit(s[currIndex]))\\n                {\\n                    count = 10 * count + (s[currIndex] - \\'0\\');\\n                    currIndex++;           \\n                }\\n                countStack.Push(count);\\n            }\\n            else if (s[currIndex] == \\'[\\')\\n            {\\n                resStack.Push(res);\\n                res = string.Empty;\\n                currIndex++; \\n            }\\n            else if (s[currIndex] == \\']\\')\\n            {                    \\n                StringBuilder repeatString = new StringBuilder();\\n                int repeatTimes = countStack.Pop();\\n                for (int i = 0; i < repeatTimes; i++)\\n                    repeatString.Append(res);\\n                res = resStack.Pop() + repeatString.ToString();                   \\n                currIndex++;\\n            }\\n            else\\n            {\\n                res += s[currIndex++];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87634,
                "title": "python-with-stack",
                "content": "We need to pay attention to the digit processing. (10[a])\\n\\n    class Solution(object):\\n        def decodeString(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: str\\n            \"\"\"\\n            stack = []\\n            for chr in s:\\n                if chr != ']':\\n                    stack.append(chr)\\n                else:\\n                    temp_s = ''\\n                    while stack:\\n                        x = stack.pop()\\n                        if x == '[':\\n                            n = ''\\n                            while stack and stack[-1].isdigit():\\n                                n = stack.pop() + n\\n                            stack.append(temp_s*int(n))\\n                            break\\n                        else:\\n                            temp_s = x + temp_s\\n            return ''.join(stack)",
                "solutionTags": [],
                "code": "We need to pay attention to the digit processing. (10[a])\\n\\n    class Solution(object):\\n        def decodeString(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: str\\n            \"\"\"\\n            stack = []\\n            for chr in s:\\n                if chr != ']':\\n                    stack.append(chr)\\n                else:\\n                    temp_s = ''\\n                    while stack:\\n                        x = stack.pop()\\n                        if x == '[':\\n                            n = ''\\n                            while stack and stack[-1].isdigit():\\n                                n = stack.pop() + n\\n                            stack.append(temp_s*int(n))\\n                            break\\n                        else:\\n                            temp_s = x + temp_s\\n            return ''.join(stack)",
                "codeTag": "Java"
            },
            {
                "id": 3718878,
                "title": "easy-c-solution-using-stack-iterative-beats-100-of-the-submissions",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        string ans = \"\";\\n        stack<string> st;\\n        string number = \"\";\\n\\n        for (int i = 0; i < s.size(); i++) {\\n            string t = string(1, s[i]);\\n\\n            if (isdigit(s[i])) {\\n                number += s[i];\\n                continue;\\n            }\\n\\n            if (s[i] == \\'[\\') {\\n                st.push(number);\\n                number.clear();\\n            }\\n\\n            if (s[i] == \\']\\') {\\n                string tempString = \"\";\\n\\n                while (st.top() != \"[\") {\\n                    tempString += st.top();\\n                    st.pop();\\n                }\\n\\n                st.pop();\\n                int temp = stoi(st.top());\\n                st.pop();\\n\\n                for (int j = 0; j < temp; j++) {\\n                    ans += tempString;\\n                }\\n\\n                st.push(ans);\\n                ans.clear();\\n                continue;\\n            }\\n\\n            st.push(t);\\n        }\\n\\n        while (!st.empty()) {\\n            ans += st.top();\\n            st.pop();\\n        }\\n\\n        reverse(ans.begin(), ans.end());\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        string ans = \"\";\\n        stack<string> st;\\n        string number = \"\";\\n\\n        for (int i = 0; i < s.size(); i++) {\\n            string t = string(1, s[i]);\\n\\n            if (isdigit(s[i])) {\\n                number += s[i];\\n                continue;\\n            }\\n\\n            if (s[i] == \\'[\\') {\\n                st.push(number);\\n                number.clear();\\n            }\\n\\n            if (s[i] == \\']\\') {\\n                string tempString = \"\";\\n\\n                while (st.top() != \"[\") {\\n                    tempString += st.top();\\n                    st.pop();\\n                }\\n\\n                st.pop();\\n                int temp = stoi(st.top());\\n                st.pop();\\n\\n                for (int j = 0; j < temp; j++) {\\n                    ans += tempString;\\n                }\\n\\n                st.push(ans);\\n                ans.clear();\\n                continue;\\n            }\\n\\n            st.push(t);\\n        }\\n\\n        while (!st.empty()) {\\n            ans += st.top();\\n            st.pop();\\n        }\\n\\n        reverse(ans.begin(), ans.end());\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676504,
                "title": "beats-100-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncontinue to decode until a string has a number, store the number and the string in a vector.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStore The number and corresponding string in the vector, copy the string in i+1 to i number of times and return the string, continue if the resulting string has a number. \\n\\n# Complexity\\n- Time complexity:O(depth of brackets)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nUpvote if you find it helpful vro ;)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decode(string s){\\n        int count = 0; string temp = \"\", n = \"\", res = \"\"; vector<string> ans; \\n\\n\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i]>=48 && s[i]<58 && count == 0) {n+= s[i]; if(temp!= \"\"){ans.push_back(\"1\");  ans.push_back(temp); temp = \"\"; } }\\n            else if(s[i] == \\'[\\' && count == 0) count++; \\n            else if(s[i] == \\']\\' && count == 1) { ans.push_back(n); ans.push_back(temp); n = \"\"; temp = \"\"; count = 0; }\\n            else if(s[i] == \\'[\\') {count++; temp += s[i]; }\\n            else if(s[i] == \\']\\'){ count--; temp += s[i]; }\\n            else {temp += s[i]; } \\n        } \\n        \\n        if(temp != \"\"){ans.push_back(\"1\");  ans.push_back(temp); }\\n\\n        // for(int i=0; i<ans.size(); i++) cout << ans[i] << \" \";\\n\\n        for(int i=0; i<ans.size(); i+=2){\\n            int c = stoi(ans[i]);  string temp = ans[i+1]; \\n            while(c--) res += temp; \\n        }\\n\\n        return res; \\n    }\\n\\n    bool check(string s){\\n        for(int i=0; i<s.length(); i++) if(s[i]>=48 && s[i]<58) return true; \\n        return false; \\n    }\\n\\n    string decodeString(string s) {\\n     \\n    while(check(s)) s = decode(s); \\n\\n    return s; \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decode(string s){\\n        int count = 0; string temp = \"\", n = \"\", res = \"\"; vector<string> ans; \\n\\n\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i]>=48 && s[i]<58 && count == 0) {n+= s[i]; if(temp!= \"\"){ans.push_back(\"1\");  ans.push_back(temp); temp = \"\"; } }\\n            else if(s[i] == \\'[\\' && count == 0) count++; \\n            else if(s[i] == \\']\\' && count == 1) { ans.push_back(n); ans.push_back(temp); n = \"\"; temp = \"\"; count = 0; }\\n            else if(s[i] == \\'[\\') {count++; temp += s[i]; }\\n            else if(s[i] == \\']\\'){ count--; temp += s[i]; }\\n            else {temp += s[i]; } \\n        } \\n        \\n        if(temp != \"\"){ans.push_back(\"1\");  ans.push_back(temp); }\\n\\n        // for(int i=0; i<ans.size(); i++) cout << ans[i] << \" \";\\n\\n        for(int i=0; i<ans.size(); i+=2){\\n            int c = stoi(ans[i]);  string temp = ans[i+1]; \\n            while(c--) res += temp; \\n        }\\n\\n        return res; \\n    }\\n\\n    bool check(string s){\\n        for(int i=0; i<s.length(); i++) if(s[i]>=48 && s[i]<58) return true; \\n        return false; \\n    }\\n\\n    string decodeString(string s) {\\n     \\n    while(check(s)) s = decode(s); \\n\\n    return s; \\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3291890,
                "title": "1-ms-java-using-2-stacks",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n-Traverse the string from start to finish and while doing so,\\n--Use charS stack To store all the characters except for \\']\\'\\n--Use numS stack To store all the numbers\\n--Once we hit a char == \\']\\' we pop from charS until we get \\'[\\', and then we pop once from numS to get the number of repetitions. \\n-- construct the new string and push it back on to the charS stack and continue the loop.\\n\\n(Let me know if you need any clarification)\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String decodeString(String s) {\\n        Stack<Integer> numS = new Stack();\\n        Stack<String> charS = new Stack();\\n\\n        for(int i = 0;i<s.length();i++){\\n            if(s.charAt(i) == \\']\\'){\\n                int k = numS.pop();\\n\\n                String ch = charS.pop();\\n                String toConcat = \"\";\\n                while(!ch.equals(\"[\")){\\n                    toConcat = ch+toConcat;\\n                    ch = charS.pop(); \\n                }\\n                String concat = \"\";\\n                while(k>0){\\n                    concat = concat + toConcat;\\n                    k--;\\n                }\\n                charS.push(concat);\\n                 \\n            }else if(Character.isDigit(s.charAt(i))){\\n                numS.push(Integer.valueOf(s.substring(i,s.indexOf(\\'[\\',i))));\\n                i = s.indexOf(\\'[\\',i)-1;\\n            }else{\\n                charS.push(Character.toString(s.charAt(i)));\\n            }\\n                            \\n        }\\n        \\n        String result=\"\";\\n         while(!charS.empty()){\\n            result = charS.pop() + result;\\n         }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeString(String s) {\\n        Stack<Integer> numS = new Stack();\\n        Stack<String> charS = new Stack();\\n\\n        for(int i = 0;i<s.length();i++){\\n            if(s.charAt(i) == \\']\\'){\\n                int k = numS.pop();\\n\\n                String ch = charS.pop();\\n                String toConcat = \"\";\\n                while(!ch.equals(\"[\")){\\n                    toConcat = ch+toConcat;\\n                    ch = charS.pop(); \\n                }\\n                String concat = \"\";\\n                while(k>0){\\n                    concat = concat + toConcat;\\n                    k--;\\n                }\\n                charS.push(concat);\\n                 \\n            }else if(Character.isDigit(s.charAt(i))){\\n                numS.push(Integer.valueOf(s.substring(i,s.indexOf(\\'[\\',i))));\\n                i = s.indexOf(\\'[\\',i)-1;\\n            }else{\\n                charS.push(Character.toString(s.charAt(i)));\\n            }\\n                            \\n        }\\n        \\n        String result=\"\";\\n         while(!charS.empty()){\\n            result = charS.pop() + result;\\n         }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164075,
                "title": "decose-string-easily-understandable-method-with-comments-100-beats",
                "content": "# Learning Point\\nHere we are just traversing string and applying some require operations,\\nOne learning point is that \"how to convert char to string\"\\nAns to that is, using string(length,character) inbuilt STL function.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack <string> st;\\n        for(char c : s){\\n            //pushing all characters other than \\']\\'\\n            if(c != \\']\\') st.push(string(1,c));\\n            else{\\n                //finding string part \\n                string str = \"\";\\n                while(st.top() != string(1,\\'[\\')){\\n                    str += st.top();\\n                    st.pop();\\n                }\\n                reverse(str.begin() , str.end());\\n                //finding number/integer part\\n                string temp = \"\";\\n                st.pop(); // poping \\'[\\'\\n                while(!st.empty() && st.top() >= string(1,\\'0\\') && st.top() <= string(1,\\'9\\')){\\n                    temp += st.top();\\n                    st.pop();\\n                }\\n                reverse(temp.begin(),temp.end());\\n                int num = 0;\\n                if(temp.size()==0) num = 1;\\n                else num = stoll(temp);\\n                //putting back resulting string in the stack !\\n                string toPush = \"\";\\n                while(num--) toPush += str;\\n                reverse(toPush.begin() , toPush.end()); // we are putting this again in the stack so reversing is needed !\\n                st.push(toPush);\\n            }\\n        }\\n        if(st.empty()) return \"\";\\n        string ans = \"\";\\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin() , ans.end());\\n        return ans;\\n    }\\n};\\n// how to convert character to string ~ use string(1,c);\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack <string> st;\\n        for(char c : s){\\n            //pushing all characters other than \\']\\'\\n            if(c != \\']\\') st.push(string(1,c));\\n            else{\\n                //finding string part \\n                string str = \"\";\\n                while(st.top() != string(1,\\'[\\')){\\n                    str += st.top();\\n                    st.pop();\\n                }\\n                reverse(str.begin() , str.end());\\n                //finding number/integer part\\n                string temp = \"\";\\n                st.pop(); // poping \\'[\\'\\n                while(!st.empty() && st.top() >= string(1,\\'0\\') && st.top() <= string(1,\\'9\\')){\\n                    temp += st.top();\\n                    st.pop();\\n                }\\n                reverse(temp.begin(),temp.end());\\n                int num = 0;\\n                if(temp.size()==0) num = 1;\\n                else num = stoll(temp);\\n                //putting back resulting string in the stack !\\n                string toPush = \"\";\\n                while(num--) toPush += str;\\n                reverse(toPush.begin() , toPush.end()); // we are putting this again in the stack so reversing is needed !\\n                st.push(toPush);\\n            }\\n        }\\n        if(st.empty()) return \"\";\\n        string ans = \"\";\\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin() , ans.end());\\n        return ans;\\n    }\\n};\\n// how to convert character to string ~ use string(1,c);\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135858,
                "title": "using-of-stacks-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasically the opening and closing brackets plays a crucial role in this problemm.. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirstly we should insert the possible elements inside of our stack till we encounter any closing brackets the moment we got that we traverse back and then delete the elements in the stack we will be having a number and a character...\\nBut they mentioned always a number comes after the character 3[a] \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\nLinear Time \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\nStack..\\n# Code\\n```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        stack=[]\\n        for i in s:\\n            if(i==\"]\"):\\n                #we have encountered a closing brackets..\\n                stri=\"\"\\n                while stack[0]!=\"[\":\\n                    stri=stack.pop(0)+stri\\n                stack.pop(0)\\n                #we are extracting the possible character from the elements which are included in the stack..\\n                k=\"\"\\n                while stack and stack[0].isdigit():\\n                    k=stack.pop(0)+k\\n                stack.insert(0,int(k)*stri)\\n            else:\\n                stack.insert(0,i)\\n        stack.reverse()\\n        return (\"\".join(stack))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        stack=[]\\n        for i in s:\\n            if(i==\"]\"):\\n                #we have encountered a closing brackets..\\n                stri=\"\"\\n                while stack[0]!=\"[\":\\n                    stri=stack.pop(0)+stri\\n                stack.pop(0)\\n                #we are extracting the possible character from the elements which are included in the stack..\\n                k=\"\"\\n                while stack and stack[0].isdigit():\\n                    k=stack.pop(0)+k\\n                stack.insert(0,int(k)*stri)\\n            else:\\n                stack.insert(0,i)\\n        stack.reverse()\\n        return (\"\".join(stack))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3121220,
                "title": "0ms-ugly-but-fast-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nno intuition \\nuse long and stupid variable names\\nwrite bad comments\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncomment out cout\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        // go through the string, push all [ onto the stack, once you en//couter a ], pop off the [, map the index to the right index\\n        stack<int> st;\\n        unordered_map<int, int> leftToRight;\\n\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (s[i] == \\'[\\')\\n            {\\n                st.push(i);\\n            }\\n            else if (s[i] == \\']\\')\\n            {\\n                int left = st.top();\\n                st.pop();\\n                int right = i;\\n                leftToRight[left] = right;\\n            }\\n        }\\n        //cout << \"calling decode on s: \" << s << endl;\\n        // if you see a nonnumber push on\\n        // if you see a digit, find the first [, slice out the digit\\n        // then find the ], slice out the internal substring\\n        // recursive call on the internal substring\\n        // push the internal substring on however that many times\\n        string res;\\n        int currIndex = 0;\\n        int n = s.size();\\n        while (currIndex < n) // still processing\\n        {\\n            //cout << \"   currIndex: \" << currIndex << endl;\\n            if (!isdigit(s[currIndex]))\\n            {\\n                res += s[currIndex];\\n                currIndex++;\\n                //cout << \"       safely pushed to res: \" << res << endl;\\n            }\\n            else\\n            {\\n                // find the last instance of the digit, find the left[ and right]\\n                int lastDigitIndex = currIndex;\\n                //cout << \"       found some digit, currIndex: \" << currIndex << endl;\\n                while(s[lastDigitIndex] != \\'[\\')\\n                {\\n                    lastDigitIndex++;\\n                } // now: s[lastDigitIndex] = \\'[\\'\\n                int leftBracketIndex = lastDigitIndex;\\n                lastDigitIndex--;\\n                int numRep = stoi(s.substr(currIndex, lastDigitIndex - currIndex + 1));\\n                int rightBracketIndex = leftToRight[leftBracketIndex];\\n                string innerString = s.substr(leftBracketIndex+1, (rightBracketIndex - 1 - (leftBracketIndex + 1) + 1));\\n                string innerDecoded = decodeString(innerString);\\n\\n                for (int i = 0; i < numRep; i++)\\n                {\\n                    res += innerDecoded;\\n                }\\n                currIndex = rightBracketIndex + 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        // go through the string, push all [ onto the stack, once you en//couter a ], pop off the [, map the index to the right index\\n        stack<int> st;\\n        unordered_map<int, int> leftToRight;\\n\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (s[i] == \\'[\\')\\n            {\\n                st.push(i);\\n            }\\n            else if (s[i] == \\']\\')\\n            {\\n                int left = st.top();\\n                st.pop();\\n                int right = i;\\n                leftToRight[left] = right;\\n            }\\n        }\\n        //cout << \"calling decode on s: \" << s << endl;\\n        // if you see a nonnumber push on\\n        // if you see a digit, find the first [, slice out the digit\\n        // then find the ], slice out the internal substring\\n        // recursive call on the internal substring\\n        // push the internal substring on however that many times\\n        string res;\\n        int currIndex = 0;\\n        int n = s.size();\\n        while (currIndex < n) // still processing\\n        {\\n            //cout << \"   currIndex: \" << currIndex << endl;\\n            if (!isdigit(s[currIndex]))\\n            {\\n                res += s[currIndex];\\n                currIndex++;\\n                //cout << \"       safely pushed to res: \" << res << endl;\\n            }\\n            else\\n            {\\n                // find the last instance of the digit, find the left[ and right]\\n                int lastDigitIndex = currIndex;\\n                //cout << \"       found some digit, currIndex: \" << currIndex << endl;\\n                while(s[lastDigitIndex] != \\'[\\')\\n                {\\n                    lastDigitIndex++;\\n                } // now: s[lastDigitIndex] = \\'[\\'\\n                int leftBracketIndex = lastDigitIndex;\\n                lastDigitIndex--;\\n                int numRep = stoi(s.substr(currIndex, lastDigitIndex - currIndex + 1));\\n                int rightBracketIndex = leftToRight[leftBracketIndex];\\n                string innerString = s.substr(leftBracketIndex+1, (rightBracketIndex - 1 - (leftBracketIndex + 1) + 1));\\n                string innerDecoded = decodeString(innerString);\\n\\n                for (int i = 0; i < numRep; i++)\\n                {\\n                    res += innerDecoded;\\n                }\\n                currIndex = rightBracketIndex + 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3112902,
                "title": "simple-and-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<char> st;\\n        string ans=\"\";\\n        int n=s.length();\\n        for(int i=0;i<n;i++)\\n        {   \\n            st.push(s[i]);\\n            if(s[i]==\\']\\')\\n            {\\n                st.pop();\\n                string temp=\"\";\\n                while(!st.empty() && st.top()!=\\'[\\')\\n                {\\n                    temp=st.top()+temp;\\n                    st.pop();\\n                }\\n                if(!st.empty())\\n                st.pop();\\n                string d=\"\";\\n                while(!st.empty() && isdigit(st.top()))\\n                {\\n                    d=st.top()+d;\\n                    st.pop();\\n                }\\n\\n                int num=stoi(d);\\n                string result=\"\";\\n                while(num--)\\n                {\\n                    result+=temp;\\n                }\\n\\n                for(auto c:result)\\n                {\\n                    st.push(c);\\n                }\\n            }\\n        }\\n        string temp=\"\";\\n        while(!st.empty())\\n        {\\n            temp=st.top()+temp;\\n            st.pop();\\n        }\\n\\n        ans+=temp;\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<char> st;\\n        string ans=\"\";\\n        int n=s.length();\\n        for(int i=0;i<n;i++)\\n        {   \\n            st.push(s[i]);\\n            if(s[i]==\\']\\')\\n            {\\n                st.pop();\\n                string temp=\"\";\\n                while(!st.empty() && st.top()!=\\'[\\')\\n                {\\n                    temp=st.top()+temp;\\n                    st.pop();\\n                }\\n                if(!st.empty())\\n                st.pop();\\n                string d=\"\";\\n                while(!st.empty() && isdigit(st.top()))\\n                {\\n                    d=st.top()+d;\\n                    st.pop();\\n                }\\n\\n                int num=stoi(d);\\n                string result=\"\";\\n                while(num--)\\n                {\\n                    result+=temp;\\n                }\\n\\n                for(auto c:result)\\n                {\\n                    st.push(c);\\n                }\\n            }\\n        }\\n        string temp=\"\";\\n        while(!st.empty())\\n        {\\n            temp=st.top()+temp;\\n            st.pop();\\n        }\\n\\n        ans+=temp;\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040419,
                "title": "two-stacks-solution-on-swift",
                "content": "\\n# Code\\n```\\nfunc decodeString(_ s: String) -> String {\\n    var intStack = [Int](), strStack = [String](), currentNum = Int(), currentString = String()\\n    for char in s {\\n        if char == \"[\" {\\n            strStack.append(currentString)\\n            intStack.append(currentNum)\\n            currentString = \"\"\\n            currentNum = 0\\n        } else if char == \"]\" {\\n            let num = intStack.removeLast()\\n            let prevString = strStack.removeLast()\\n            currentString = prevString + String(repeating: currentString, count: num)\\n        } else if let charNum = Int(String(char)) {\\n            currentNum = currentNum * 10 + charNum\\n        } else {\\n            currentString.append(String(char))\\n        }\\n    }\\n    return currentString\\n}\\n```\\n### Please upvote if the solution was useful!",
                "solutionTags": [
                    "Swift",
                    "Stack"
                ],
                "code": "```\\nfunc decodeString(_ s: String) -> String {\\n    var intStack = [Int](), strStack = [String](), currentNum = Int(), currentString = String()\\n    for char in s {\\n        if char == \"[\" {\\n            strStack.append(currentString)\\n            intStack.append(currentNum)\\n            currentString = \"\"\\n            currentNum = 0\\n        } else if char == \"]\" {\\n            let num = intStack.removeLast()\\n            let prevString = strStack.removeLast()\\n            currentString = prevString + String(repeating: currentString, count: num)\\n        } else if let charNum = Int(String(char)) {\\n            currentNum = currentNum * 10 + charNum\\n        } else {\\n            currentString.append(String(char))\\n        }\\n    }\\n    return currentString\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3018366,
                "title": "c-dfs-beats-99",
                "content": "# Intuition\\nUse String Builders and DFS to obtain the decoded string. By the time of submission, this solution was 99% faster than existing solutions.\\n\\n# Approach\\nFind Multiplier:\\n```\\nint n = 0 ;\\nwhile (pointer < s.Length && Char.IsDigit(s[pointer]))\\n{\\n    sbNumber.Append(s[pointer]);\\n    pointer++;\\n}\\nif (sbNumber.Length > 0)\\n{\\n    n = Convert.ToInt32(sbNumber.ToString());\\n}\\n```\\nFind string that follows the multiplier and concatenate replicas:\\n```\\nif (n>0)\\n{\\n    if (s[pointer] == \\'[\\')\\n    {\\n        pointer++;\\n        sbWord = Dfs(s, ref pointer);\\n    }\\n    for(int i = 0; i< n; i++)\\n    {\\n        sbResult.Append(sbWord.ToString());\\n    }\\n}\\n```\\nIf we\\'re not done yet, keep running with updated pointer, concatenate results, then return:\\n```\\nif (pointer < s.Length -1)\\n{\\n    pointer++;\\n    sbResult.Append(Dfs(s, ref pointer));\\n}\\nreturn sbResult;\\n\\n```\\nIf we found a letter, keep aggregating to other letters until a closing bracket is found or the end of the string, then return:\\n```\\nwhile (pointer < s.Length && Char.IsLetter(s[pointer]))\\n{\\n    sbWord.Append(s[pointer]);\\n    pointer++;\\n}\\nif (pointer >= s.Length -1 ||s[pointer] == \\']\\')\\n{\\n    return sbWord;\\n}\\n```\\nif a digit was found, re-run Dfs, aggregate the result to sbWord, then return:\\n```\\n{\\n    sbWord.Append(Dfs(s, ref pointer));\\n    return sbWord;\\n}\\n```\\n\\n# Code\\n```\\npublic class Solution {\\n    public string DecodeString(string s) {\\n        int pointer = 0;\\n        var sb = Dfs(s, ref pointer );\\n        return sb.ToString();\\n    }\\n    StringBuilder Dfs(string s, ref int pointer )\\n    {\\n        StringBuilder sbNumber = new();\\n        StringBuilder sbWord = new();\\n        StringBuilder sbResult = new();\\n        if (pointer >= s.Length)\\n        {\\n            return sbResult;\\n        }\\n        int n = 0 ;\\n        while (pointer < s.Length && Char.IsDigit(s[pointer]))\\n        {\\n            sbNumber.Append(s[pointer]);\\n            pointer++;\\n        }\\n        if (sbNumber.Length > 0)\\n        {\\n            n = Convert.ToInt32(sbNumber.ToString());\\n        }\\n        if (n>0)\\n        {\\n            if (s[pointer] == \\'[\\')\\n            {\\n                pointer++;\\n                sbWord = Dfs(s, ref pointer);\\n            }\\n            for(int i = 0; i< n; i++)\\n            {\\n                sbResult.Append(sbWord.ToString());\\n            }\\n        }\\n        else\\n        {\\n            while (pointer < s.Length && Char.IsLetter(s[pointer]))\\n            {\\n                sbWord.Append(s[pointer]);\\n                pointer++;\\n            }\\n            if (pointer >= s.Length -1 ||s[pointer] == \\']\\')\\n            {\\n                return sbWord;\\n            }\\n            else if (Char.IsDigit(s[pointer]))\\n            {\\n                sbWord.Append(Dfs(s, ref pointer));\\n                return sbWord;\\n            }\\n        }\\n        if (pointer < s.Length -1)\\n        {\\n            pointer++;\\n            sbResult.Append(Dfs(s, ref pointer));\\n        }\\n        return sbResult;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Depth-First Search"
                ],
                "code": "```\\nint n = 0 ;\\nwhile (pointer < s.Length && Char.IsDigit(s[pointer]))\\n{\\n    sbNumber.Append(s[pointer]);\\n    pointer++;\\n}\\nif (sbNumber.Length > 0)\\n{\\n    n = Convert.ToInt32(sbNumber.ToString());\\n}\\n```\n```\\nif (n>0)\\n{\\n    if (s[pointer] == \\'[\\')\\n    {\\n        pointer++;\\n        sbWord = Dfs(s, ref pointer);\\n    }\\n    for(int i = 0; i< n; i++)\\n    {\\n        sbResult.Append(sbWord.ToString());\\n    }\\n}\\n```\n```\\nif (pointer < s.Length -1)\\n{\\n    pointer++;\\n    sbResult.Append(Dfs(s, ref pointer));\\n}\\nreturn sbResult;\\n\\n```\n```\\nwhile (pointer < s.Length && Char.IsLetter(s[pointer]))\\n{\\n    sbWord.Append(s[pointer]);\\n    pointer++;\\n}\\nif (pointer >= s.Length -1 ||s[pointer] == \\']\\')\\n{\\n    return sbWord;\\n}\\n```\n```\\n{\\n    sbWord.Append(Dfs(s, ref pointer));\\n    return sbWord;\\n}\\n```\n```\\npublic class Solution {\\n    public string DecodeString(string s) {\\n        int pointer = 0;\\n        var sb = Dfs(s, ref pointer );\\n        return sb.ToString();\\n    }\\n    StringBuilder Dfs(string s, ref int pointer )\\n    {\\n        StringBuilder sbNumber = new();\\n        StringBuilder sbWord = new();\\n        StringBuilder sbResult = new();\\n        if (pointer >= s.Length)\\n        {\\n            return sbResult;\\n        }\\n        int n = 0 ;\\n        while (pointer < s.Length && Char.IsDigit(s[pointer]))\\n        {\\n            sbNumber.Append(s[pointer]);\\n            pointer++;\\n        }\\n        if (sbNumber.Length > 0)\\n        {\\n            n = Convert.ToInt32(sbNumber.ToString());\\n        }\\n        if (n>0)\\n        {\\n            if (s[pointer] == \\'[\\')\\n            {\\n                pointer++;\\n                sbWord = Dfs(s, ref pointer);\\n            }\\n            for(int i = 0; i< n; i++)\\n            {\\n                sbResult.Append(sbWord.ToString());\\n            }\\n        }\\n        else\\n        {\\n            while (pointer < s.Length && Char.IsLetter(s[pointer]))\\n            {\\n                sbWord.Append(s[pointer]);\\n                pointer++;\\n            }\\n            if (pointer >= s.Length -1 ||s[pointer] == \\']\\')\\n            {\\n                return sbWord;\\n            }\\n            else if (Char.IsDigit(s[pointer]))\\n            {\\n                sbWord.Append(Dfs(s, ref pointer));\\n                return sbWord;\\n            }\\n        }\\n        if (pointer < s.Length -1)\\n        {\\n            pointer++;\\n            sbResult.Append(Dfs(s, ref pointer));\\n        }\\n        return sbResult;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2940066,
                "title": "1-ms-simple-code",
                "content": "# Please upvote if you like my solution .\\n$$O(n)$$ \\n\\n# Code\\n```\\nvar decodeString = function(s) {\\n  var regex = /(\\\\d*)(?:\\\\[)([A-Za-z]*)(?:\\\\])/\\n\\n  while (regex.test(s)) {\\n    var matchStr = s.match(regex)\\n    var ind = matchStr.index\\n    var str = matchStr[0]\\n    var mLen = str.length\\n\\n    var strCount = parseInt(matchStr[1])\\n    var template = matchStr[2].repeat(strCount)\\n\\n    s = s.slice(0, ind) + template + s.slice(ind + mLen, s.length)\\n  } \\n  \\n  return s\\n};\\n```\\n# Please upvote if you like my solution .\\nIf you really found my solution helpful please upvote it, as it motivates me to post such kind of codes.\\nLet me know in comment if i can do better.\\nLets connect on Linkedin https://www.linkedin.com/in/kailas-rathod/",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar decodeString = function(s) {\\n  var regex = /(\\\\d*)(?:\\\\[)([A-Za-z]*)(?:\\\\])/\\n\\n  while (regex.test(s)) {\\n    var matchStr = s.match(regex)\\n    var ind = matchStr.index\\n    var str = matchStr[0]\\n    var mLen = str.length\\n\\n    var strCount = parseInt(matchStr[1])\\n    var template = matchStr[2].repeat(strCount)\\n\\n    s = s.slice(0, ind) + template + s.slice(ind + mLen, s.length)\\n  } \\n  \\n  return s\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2901887,
                "title": "codedominar-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        nums = \"0123456789\"\\n        stack = []\\n        for char in s:\\n            #print(stack)\\n            if char == \\']\\':\\n                temp_s = \\'\\'\\n                num=\\'\\'\\n                while stack[-1] != \\'[\\':\\n                    temp_s = stack.pop()+temp_s\\n                stack.pop()\\n                while stack and stack[-1] in nums:\\n                    num+= stack.pop()\\n                num = int(num[::-1])\\n                while num:\\n                    stack.append(temp_s)\\n                    num-=1\\n            else:\\n                stack.append(char)\\n        l = \"\".join(map(str,stack))\\n        return l\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        nums = \"0123456789\"\\n        stack = []\\n        for char in s:\\n            #print(stack)\\n            if char == \\']\\':\\n                temp_s = \\'\\'\\n                num=\\'\\'\\n                while stack[-1] != \\'[\\':\\n                    temp_s = stack.pop()+temp_s\\n                stack.pop()\\n                while stack and stack[-1] in nums:\\n                    num+= stack.pop()\\n                num = int(num[::-1])\\n                while num:\\n                    stack.append(temp_s)\\n                    num-=1\\n            else:\\n                stack.append(char)\\n        l = \"\".join(map(str,stack))\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2890480,
                "title": "394-decode-string-solution-by-priyanka",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBy using Stacks for storing data and StringBuilder\\n# Complexity\\n- Time complexity:\\n- $$O(n*k)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String decodeString(String s) {\\n        Stack<Integer> numStack = new Stack();\\n        Stack<String> strStack = new Stack();\\n        StringBuilder sb = new StringBuilder();\\n        int len = s.length();\\n        for(int i=0;i< len ; i++){\\n            char ch = s.charAt(i);\\n            if(Character.isDigit(ch)){\\n                int num = ch -\\'0\\';\\n                while(i+1 <len && Character.isDigit(s.charAt(i+1))){\\n                    num = num*10 +s.charAt(i+1) - \\'0\\';\\n                    i++;\\n                }\\n                numStack.push(num);\\n            }else if(ch == \\'[\\'){\\n                strStack.push(sb.toString());\\n                sb = new StringBuilder();\\n            }else if(ch==\\']\\'){\\n                int k = numStack.pop();\\n                StringBuilder temp = new StringBuilder(strStack.pop());\\n                for(int j=0;j<k;j++){\\n                    temp.append(sb);\\n                }\\n                sb=temp;\\n            }else{\\n                sb.append(ch);\\n            }\\n        }    \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeString(String s) {\\n        Stack<Integer> numStack = new Stack();\\n        Stack<String> strStack = new Stack();\\n        StringBuilder sb = new StringBuilder();\\n        int len = s.length();\\n        for(int i=0;i< len ; i++){\\n            char ch = s.charAt(i);\\n            if(Character.isDigit(ch)){\\n                int num = ch -\\'0\\';\\n                while(i+1 <len && Character.isDigit(s.charAt(i+1))){\\n                    num = num*10 +s.charAt(i+1) - \\'0\\';\\n                    i++;\\n                }\\n                numStack.push(num);\\n            }else if(ch == \\'[\\'){\\n                strStack.push(sb.toString());\\n                sb = new StringBuilder();\\n            }else if(ch==\\']\\'){\\n                int k = numStack.pop();\\n                StringBuilder temp = new StringBuilder(strStack.pop());\\n                for(int j=0;j<k;j++){\\n                    temp.append(sb);\\n                }\\n                sb=temp;\\n            }else{\\n                sb.append(ch);\\n            }\\n        }    \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2849363,
                "title": "decode-string-easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeString(string str) {\\n      \\n      stack<string>st;\\n      string currstring=\"\",currnum=\"\";\\n\\n      for(auto i:str)\\n      {\\n        if(i==\\'[\\')\\n        {\\n          st.push(currstring);\\n          st.push(currnum);\\n\\n          currstring=\"\";\\n          currnum=\"\";\\n        }\\n        else if(i==\\']\\')\\n        {\\n           int num=stoi(st.top());\\n           st.pop();\\n           string prevstring =st.top();\\n           st.pop();\\n\\n           string temp=prevstring;\\n           for(int i=0;i<num;i++)\\n           {\\n             temp+=currstring;\\n           }\\n           currstring=temp;\\n        }\\n        else if(isdigit(i))\\n        {\\n          currnum+=i;\\n        }\\n        else\\n        {\\n          currstring+=i;\\n        }\\n      }\\n      return currstring;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string str) {\\n      \\n      stack<string>st;\\n      string currstring=\"\",currnum=\"\";\\n\\n      for(auto i:str)\\n      {\\n        if(i==\\'[\\')\\n        {\\n          st.push(currstring);\\n          st.push(currnum);\\n\\n          currstring=\"\";\\n          currnum=\"\";\\n        }\\n        else if(i==\\']\\')\\n        {\\n           int num=stoi(st.top());\\n           st.pop();\\n           string prevstring =st.top();\\n           st.pop();\\n\\n           string temp=prevstring;\\n           for(int i=0;i<num;i++)\\n           {\\n             temp+=currstring;\\n           }\\n           currstring=temp;\\n        }\\n        else if(isdigit(i))\\n        {\\n          currnum+=i;\\n        }\\n        else\\n        {\\n          currstring+=i;\\n        }\\n      }\\n      return currstring;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1574402,
                "content": [
                    {
                        "username": "daily_coder",
                        "content": "Many times I solve some problem and after few hours/days I find amazed of myself that how did I even solved/coded this complex problem earlier!! Had this feeling? Please tell me, so that I can feel no alien."
                    },
                    {
                        "username": "an5dy90",
                        "content": "many times I forgot how I solved complex problems like this days months later and I needed to solve it again  "
                    },
                    {
                        "username": "aruuu____",
                        "content": "yeah same :)\\n"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "Yeah me too. Though I am beginner, I sometimes solve complex problems and after few days, I am amazed how did I solved."
                    },
                    {
                        "username": "Paleoanthropologist",
                        "content": "This is because you did not think through everything when you solved the problem initially. This happens a lot due to you have been band-aiding your code iteratively to achieve AC. "
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "at least you can solve it man"
                    },
                    {
                        "username": "Ranjan2002",
                        "content": "Ya  totally XD"
                    },
                    {
                        "username": "sahilbest999",
                        "content": "totally bro"
                    },
                    {
                        "username": "dengning1205",
                        "content": "Seems to be a lot harder than decode"
                    },
                    {
                        "username": "pbindal",
                        "content": "This is categorized under graph and trees. Looks like stacks and backtracking algo to me. Please correct if I am wrong"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1e9c82ea-4ff3-430b-a686-1be8a3e647f5_1642613017.35797.png)\\n\\n![image](https://assets.leetcode.com/users/images/5eee0955-2597-4439-8c87-8e0df45e461e_1642613023.443171.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d7645d9-4ef3-4875-810a-297d2f82a81a_1642613028.1248252.png)\\n\\n![image](https://assets.leetcode.com/users/images/5cec2dfd-2ec1-4ab6-9d9b-9a9b5f8e8d44_1642613031.8151512.png)\\n\\n![image](https://assets.leetcode.com/users/images/85c375af-7ac1-4006-b1f6-03da63b1d84a_1642613037.3188505.png)\\n\\n![image](https://assets.leetcode.com/users/images/42f7256e-f408-4c85-88f1-a029a32e7e4c_1642613048.1025255.png)\\n"
                    },
                    {
                        "username": "julyakovleva1107",
                        "content": "Hi! Could somebody please explain - how come we have s = \"3\" in the test cases if there are such constraints:\\n1) s consists of lowercase English letters, digits, AND square brackets \\'[]\\'.\\n2) s is guaranteed to be a valid input.\\n\\uD83E\\uDD14\\n"
                    },
                    {
                        "username": "Miryafa",
                        "content": "Well you're right - every number should be followed by brackets. The description specifically says \"there will not be input like 3a or 2[4]\", and '3' is an input like '2[4]', because if 3 is valid then 2[3] is too, so 2[4] must be too.\n\nAnd there's no input to the encoding function that can result in an encoded string of '3', so that's what I'd call an invalid test case that only avoids causing an error if you write your program the same way the author did."
                    },
                    {
                        "username": "cloudycandy",
                        "content": "Today I saw some people were asked the encoding as a follow up for leetcode #394 decode string. Most of the them only gave a brief direction during the interview and didn't write any code. But I would like to ask for more thoughts.\\n\\nI may think about using dynamic programming. For string s, the shortest encoding from the i<sup>th</sup> character to the j<sup>th</sup> character is denoted by dp[i][j], then we have:\\n* If i+2 > j, dp[i][j] = s[i-1:j ], i.e. just keep those characters.\\n* else If s[i-1:j ] can be represented as repeating patterns, then encode it as repeating_times[repeating_pattern], using the finest repeating pattern.\\n* otherwise dp[i][j] = min_length(dp[i][k] + dp[k+1][j]) where i < k < j\\n\\nIt runs in O(n<sup>3</sup>) time however, where n is the length of the string to be encoded.\\nDoes this work? What do you think about it?"
                    },
                    {
                        "username": "madfcat",
                        "content": "Does even the test case 34\\n\\ns = \"3\"\\n\\nmake sense?\\n\\nIt is said that \"s is guaranteed to be a valid input\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is \"3\" a testcase? My code passed all testcases but when I used \"3\" as a testcase directly, LeetCode came back with \"Invalid input\". Just as well. Had my code tried to run it, it would have pushed past the \"[\" (which in this case is actually the ASCII NULL character) and caused a segmentation fault;"
                    },
                    {
                        "username": "eLementarydew",
                        "content": "This was definitely a tricky test case . I think they were expecting what if there is nothing to decode . Any number followed by an empty string is still an empty string. Still a weird test case because of the question language."
                    },
                    {
                        "username": "ILoveBigBits",
                        "content": "Time complexity cannot depend only on the length of the input string.\\n**Time Complexity is also a function of the numbers that are represented inside the string**,\\n\\nSince **we are also appending characters to our final answer string**, consider this,\\n\\n\\n100[a101[b102[c]]]\\n\\n\\nHere the length of the string is 18, but in the final string we need to append approximately10^6 times.\\n\\n\\nGeneral Proof, \\n\\nLets consider an input of Length N\\nLet N\\' = N+1\\nconsider the string\\n**N[aN\\'[b]]**\\n\\n\\nHere we require atleast **N^2**, operations to append a and b to final string.\\n\\nA very bad upperbound is **O(N * ProductofAllNumbers * MaxDepthofRecursionTree)**\\n\\nIf someone has a better upper bound, or something is wrong with the above analysis please share!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Leetcode describes this as an invalid testcase - probably because the decoded string is longer than 10^5 characters."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/decode-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Using 2 Stack\n\n  \n**Approach 3:** Using Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dlrudqhr7180",
                        "content": " I think test case 34 is invalid input (s = 3) while the problem indicates that \"s is guaranteed to be a valid input.\""
                    }
                ]
            },
            {
                "id": 1567969,
                "content": [
                    {
                        "username": "daily_coder",
                        "content": "Many times I solve some problem and after few hours/days I find amazed of myself that how did I even solved/coded this complex problem earlier!! Had this feeling? Please tell me, so that I can feel no alien."
                    },
                    {
                        "username": "an5dy90",
                        "content": "many times I forgot how I solved complex problems like this days months later and I needed to solve it again  "
                    },
                    {
                        "username": "aruuu____",
                        "content": "yeah same :)\\n"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "Yeah me too. Though I am beginner, I sometimes solve complex problems and after few days, I am amazed how did I solved."
                    },
                    {
                        "username": "Paleoanthropologist",
                        "content": "This is because you did not think through everything when you solved the problem initially. This happens a lot due to you have been band-aiding your code iteratively to achieve AC. "
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "at least you can solve it man"
                    },
                    {
                        "username": "Ranjan2002",
                        "content": "Ya  totally XD"
                    },
                    {
                        "username": "sahilbest999",
                        "content": "totally bro"
                    },
                    {
                        "username": "dengning1205",
                        "content": "Seems to be a lot harder than decode"
                    },
                    {
                        "username": "pbindal",
                        "content": "This is categorized under graph and trees. Looks like stacks and backtracking algo to me. Please correct if I am wrong"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1e9c82ea-4ff3-430b-a686-1be8a3e647f5_1642613017.35797.png)\\n\\n![image](https://assets.leetcode.com/users/images/5eee0955-2597-4439-8c87-8e0df45e461e_1642613023.443171.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d7645d9-4ef3-4875-810a-297d2f82a81a_1642613028.1248252.png)\\n\\n![image](https://assets.leetcode.com/users/images/5cec2dfd-2ec1-4ab6-9d9b-9a9b5f8e8d44_1642613031.8151512.png)\\n\\n![image](https://assets.leetcode.com/users/images/85c375af-7ac1-4006-b1f6-03da63b1d84a_1642613037.3188505.png)\\n\\n![image](https://assets.leetcode.com/users/images/42f7256e-f408-4c85-88f1-a029a32e7e4c_1642613048.1025255.png)\\n"
                    },
                    {
                        "username": "julyakovleva1107",
                        "content": "Hi! Could somebody please explain - how come we have s = \"3\" in the test cases if there are such constraints:\\n1) s consists of lowercase English letters, digits, AND square brackets \\'[]\\'.\\n2) s is guaranteed to be a valid input.\\n\\uD83E\\uDD14\\n"
                    },
                    {
                        "username": "Miryafa",
                        "content": "Well you're right - every number should be followed by brackets. The description specifically says \"there will not be input like 3a or 2[4]\", and '3' is an input like '2[4]', because if 3 is valid then 2[3] is too, so 2[4] must be too.\n\nAnd there's no input to the encoding function that can result in an encoded string of '3', so that's what I'd call an invalid test case that only avoids causing an error if you write your program the same way the author did."
                    },
                    {
                        "username": "cloudycandy",
                        "content": "Today I saw some people were asked the encoding as a follow up for leetcode #394 decode string. Most of the them only gave a brief direction during the interview and didn't write any code. But I would like to ask for more thoughts.\\n\\nI may think about using dynamic programming. For string s, the shortest encoding from the i<sup>th</sup> character to the j<sup>th</sup> character is denoted by dp[i][j], then we have:\\n* If i+2 > j, dp[i][j] = s[i-1:j ], i.e. just keep those characters.\\n* else If s[i-1:j ] can be represented as repeating patterns, then encode it as repeating_times[repeating_pattern], using the finest repeating pattern.\\n* otherwise dp[i][j] = min_length(dp[i][k] + dp[k+1][j]) where i < k < j\\n\\nIt runs in O(n<sup>3</sup>) time however, where n is the length of the string to be encoded.\\nDoes this work? What do you think about it?"
                    },
                    {
                        "username": "madfcat",
                        "content": "Does even the test case 34\\n\\ns = \"3\"\\n\\nmake sense?\\n\\nIt is said that \"s is guaranteed to be a valid input\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is \"3\" a testcase? My code passed all testcases but when I used \"3\" as a testcase directly, LeetCode came back with \"Invalid input\". Just as well. Had my code tried to run it, it would have pushed past the \"[\" (which in this case is actually the ASCII NULL character) and caused a segmentation fault;"
                    },
                    {
                        "username": "eLementarydew",
                        "content": "This was definitely a tricky test case . I think they were expecting what if there is nothing to decode . Any number followed by an empty string is still an empty string. Still a weird test case because of the question language."
                    },
                    {
                        "username": "ILoveBigBits",
                        "content": "Time complexity cannot depend only on the length of the input string.\\n**Time Complexity is also a function of the numbers that are represented inside the string**,\\n\\nSince **we are also appending characters to our final answer string**, consider this,\\n\\n\\n100[a101[b102[c]]]\\n\\n\\nHere the length of the string is 18, but in the final string we need to append approximately10^6 times.\\n\\n\\nGeneral Proof, \\n\\nLets consider an input of Length N\\nLet N\\' = N+1\\nconsider the string\\n**N[aN\\'[b]]**\\n\\n\\nHere we require atleast **N^2**, operations to append a and b to final string.\\n\\nA very bad upperbound is **O(N * ProductofAllNumbers * MaxDepthofRecursionTree)**\\n\\nIf someone has a better upper bound, or something is wrong with the above analysis please share!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Leetcode describes this as an invalid testcase - probably because the decoded string is longer than 10^5 characters."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/decode-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Using 2 Stack\n\n  \n**Approach 3:** Using Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dlrudqhr7180",
                        "content": " I think test case 34 is invalid input (s = 3) while the problem indicates that \"s is guaranteed to be a valid input.\""
                    }
                ]
            },
            {
                "id": 1570173,
                "content": [
                    {
                        "username": "daily_coder",
                        "content": "Many times I solve some problem and after few hours/days I find amazed of myself that how did I even solved/coded this complex problem earlier!! Had this feeling? Please tell me, so that I can feel no alien."
                    },
                    {
                        "username": "an5dy90",
                        "content": "many times I forgot how I solved complex problems like this days months later and I needed to solve it again  "
                    },
                    {
                        "username": "aruuu____",
                        "content": "yeah same :)\\n"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "Yeah me too. Though I am beginner, I sometimes solve complex problems and after few days, I am amazed how did I solved."
                    },
                    {
                        "username": "Paleoanthropologist",
                        "content": "This is because you did not think through everything when you solved the problem initially. This happens a lot due to you have been band-aiding your code iteratively to achieve AC. "
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "at least you can solve it man"
                    },
                    {
                        "username": "Ranjan2002",
                        "content": "Ya  totally XD"
                    },
                    {
                        "username": "sahilbest999",
                        "content": "totally bro"
                    },
                    {
                        "username": "dengning1205",
                        "content": "Seems to be a lot harder than decode"
                    },
                    {
                        "username": "pbindal",
                        "content": "This is categorized under graph and trees. Looks like stacks and backtracking algo to me. Please correct if I am wrong"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1e9c82ea-4ff3-430b-a686-1be8a3e647f5_1642613017.35797.png)\\n\\n![image](https://assets.leetcode.com/users/images/5eee0955-2597-4439-8c87-8e0df45e461e_1642613023.443171.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d7645d9-4ef3-4875-810a-297d2f82a81a_1642613028.1248252.png)\\n\\n![image](https://assets.leetcode.com/users/images/5cec2dfd-2ec1-4ab6-9d9b-9a9b5f8e8d44_1642613031.8151512.png)\\n\\n![image](https://assets.leetcode.com/users/images/85c375af-7ac1-4006-b1f6-03da63b1d84a_1642613037.3188505.png)\\n\\n![image](https://assets.leetcode.com/users/images/42f7256e-f408-4c85-88f1-a029a32e7e4c_1642613048.1025255.png)\\n"
                    },
                    {
                        "username": "julyakovleva1107",
                        "content": "Hi! Could somebody please explain - how come we have s = \"3\" in the test cases if there are such constraints:\\n1) s consists of lowercase English letters, digits, AND square brackets \\'[]\\'.\\n2) s is guaranteed to be a valid input.\\n\\uD83E\\uDD14\\n"
                    },
                    {
                        "username": "Miryafa",
                        "content": "Well you're right - every number should be followed by brackets. The description specifically says \"there will not be input like 3a or 2[4]\", and '3' is an input like '2[4]', because if 3 is valid then 2[3] is too, so 2[4] must be too.\n\nAnd there's no input to the encoding function that can result in an encoded string of '3', so that's what I'd call an invalid test case that only avoids causing an error if you write your program the same way the author did."
                    },
                    {
                        "username": "cloudycandy",
                        "content": "Today I saw some people were asked the encoding as a follow up for leetcode #394 decode string. Most of the them only gave a brief direction during the interview and didn't write any code. But I would like to ask for more thoughts.\\n\\nI may think about using dynamic programming. For string s, the shortest encoding from the i<sup>th</sup> character to the j<sup>th</sup> character is denoted by dp[i][j], then we have:\\n* If i+2 > j, dp[i][j] = s[i-1:j ], i.e. just keep those characters.\\n* else If s[i-1:j ] can be represented as repeating patterns, then encode it as repeating_times[repeating_pattern], using the finest repeating pattern.\\n* otherwise dp[i][j] = min_length(dp[i][k] + dp[k+1][j]) where i < k < j\\n\\nIt runs in O(n<sup>3</sup>) time however, where n is the length of the string to be encoded.\\nDoes this work? What do you think about it?"
                    },
                    {
                        "username": "madfcat",
                        "content": "Does even the test case 34\\n\\ns = \"3\"\\n\\nmake sense?\\n\\nIt is said that \"s is guaranteed to be a valid input\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is \"3\" a testcase? My code passed all testcases but when I used \"3\" as a testcase directly, LeetCode came back with \"Invalid input\". Just as well. Had my code tried to run it, it would have pushed past the \"[\" (which in this case is actually the ASCII NULL character) and caused a segmentation fault;"
                    },
                    {
                        "username": "eLementarydew",
                        "content": "This was definitely a tricky test case . I think they were expecting what if there is nothing to decode . Any number followed by an empty string is still an empty string. Still a weird test case because of the question language."
                    },
                    {
                        "username": "ILoveBigBits",
                        "content": "Time complexity cannot depend only on the length of the input string.\\n**Time Complexity is also a function of the numbers that are represented inside the string**,\\n\\nSince **we are also appending characters to our final answer string**, consider this,\\n\\n\\n100[a101[b102[c]]]\\n\\n\\nHere the length of the string is 18, but in the final string we need to append approximately10^6 times.\\n\\n\\nGeneral Proof, \\n\\nLets consider an input of Length N\\nLet N\\' = N+1\\nconsider the string\\n**N[aN\\'[b]]**\\n\\n\\nHere we require atleast **N^2**, operations to append a and b to final string.\\n\\nA very bad upperbound is **O(N * ProductofAllNumbers * MaxDepthofRecursionTree)**\\n\\nIf someone has a better upper bound, or something is wrong with the above analysis please share!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Leetcode describes this as an invalid testcase - probably because the decoded string is longer than 10^5 characters."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/decode-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Using 2 Stack\n\n  \n**Approach 3:** Using Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dlrudqhr7180",
                        "content": " I think test case 34 is invalid input (s = 3) while the problem indicates that \"s is guaranteed to be a valid input.\""
                    }
                ]
            },
            {
                "id": 1576264,
                "content": [
                    {
                        "username": "daily_coder",
                        "content": "Many times I solve some problem and after few hours/days I find amazed of myself that how did I even solved/coded this complex problem earlier!! Had this feeling? Please tell me, so that I can feel no alien."
                    },
                    {
                        "username": "an5dy90",
                        "content": "many times I forgot how I solved complex problems like this days months later and I needed to solve it again  "
                    },
                    {
                        "username": "aruuu____",
                        "content": "yeah same :)\\n"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "Yeah me too. Though I am beginner, I sometimes solve complex problems and after few days, I am amazed how did I solved."
                    },
                    {
                        "username": "Paleoanthropologist",
                        "content": "This is because you did not think through everything when you solved the problem initially. This happens a lot due to you have been band-aiding your code iteratively to achieve AC. "
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "at least you can solve it man"
                    },
                    {
                        "username": "Ranjan2002",
                        "content": "Ya  totally XD"
                    },
                    {
                        "username": "sahilbest999",
                        "content": "totally bro"
                    },
                    {
                        "username": "dengning1205",
                        "content": "Seems to be a lot harder than decode"
                    },
                    {
                        "username": "pbindal",
                        "content": "This is categorized under graph and trees. Looks like stacks and backtracking algo to me. Please correct if I am wrong"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1e9c82ea-4ff3-430b-a686-1be8a3e647f5_1642613017.35797.png)\\n\\n![image](https://assets.leetcode.com/users/images/5eee0955-2597-4439-8c87-8e0df45e461e_1642613023.443171.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d7645d9-4ef3-4875-810a-297d2f82a81a_1642613028.1248252.png)\\n\\n![image](https://assets.leetcode.com/users/images/5cec2dfd-2ec1-4ab6-9d9b-9a9b5f8e8d44_1642613031.8151512.png)\\n\\n![image](https://assets.leetcode.com/users/images/85c375af-7ac1-4006-b1f6-03da63b1d84a_1642613037.3188505.png)\\n\\n![image](https://assets.leetcode.com/users/images/42f7256e-f408-4c85-88f1-a029a32e7e4c_1642613048.1025255.png)\\n"
                    },
                    {
                        "username": "julyakovleva1107",
                        "content": "Hi! Could somebody please explain - how come we have s = \"3\" in the test cases if there are such constraints:\\n1) s consists of lowercase English letters, digits, AND square brackets \\'[]\\'.\\n2) s is guaranteed to be a valid input.\\n\\uD83E\\uDD14\\n"
                    },
                    {
                        "username": "Miryafa",
                        "content": "Well you're right - every number should be followed by brackets. The description specifically says \"there will not be input like 3a or 2[4]\", and '3' is an input like '2[4]', because if 3 is valid then 2[3] is too, so 2[4] must be too.\n\nAnd there's no input to the encoding function that can result in an encoded string of '3', so that's what I'd call an invalid test case that only avoids causing an error if you write your program the same way the author did."
                    },
                    {
                        "username": "cloudycandy",
                        "content": "Today I saw some people were asked the encoding as a follow up for leetcode #394 decode string. Most of the them only gave a brief direction during the interview and didn't write any code. But I would like to ask for more thoughts.\\n\\nI may think about using dynamic programming. For string s, the shortest encoding from the i<sup>th</sup> character to the j<sup>th</sup> character is denoted by dp[i][j], then we have:\\n* If i+2 > j, dp[i][j] = s[i-1:j ], i.e. just keep those characters.\\n* else If s[i-1:j ] can be represented as repeating patterns, then encode it as repeating_times[repeating_pattern], using the finest repeating pattern.\\n* otherwise dp[i][j] = min_length(dp[i][k] + dp[k+1][j]) where i < k < j\\n\\nIt runs in O(n<sup>3</sup>) time however, where n is the length of the string to be encoded.\\nDoes this work? What do you think about it?"
                    },
                    {
                        "username": "madfcat",
                        "content": "Does even the test case 34\\n\\ns = \"3\"\\n\\nmake sense?\\n\\nIt is said that \"s is guaranteed to be a valid input\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is \"3\" a testcase? My code passed all testcases but when I used \"3\" as a testcase directly, LeetCode came back with \"Invalid input\". Just as well. Had my code tried to run it, it would have pushed past the \"[\" (which in this case is actually the ASCII NULL character) and caused a segmentation fault;"
                    },
                    {
                        "username": "eLementarydew",
                        "content": "This was definitely a tricky test case . I think they were expecting what if there is nothing to decode . Any number followed by an empty string is still an empty string. Still a weird test case because of the question language."
                    },
                    {
                        "username": "ILoveBigBits",
                        "content": "Time complexity cannot depend only on the length of the input string.\\n**Time Complexity is also a function of the numbers that are represented inside the string**,\\n\\nSince **we are also appending characters to our final answer string**, consider this,\\n\\n\\n100[a101[b102[c]]]\\n\\n\\nHere the length of the string is 18, but in the final string we need to append approximately10^6 times.\\n\\n\\nGeneral Proof, \\n\\nLets consider an input of Length N\\nLet N\\' = N+1\\nconsider the string\\n**N[aN\\'[b]]**\\n\\n\\nHere we require atleast **N^2**, operations to append a and b to final string.\\n\\nA very bad upperbound is **O(N * ProductofAllNumbers * MaxDepthofRecursionTree)**\\n\\nIf someone has a better upper bound, or something is wrong with the above analysis please share!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Leetcode describes this as an invalid testcase - probably because the decoded string is longer than 10^5 characters."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/decode-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Using 2 Stack\n\n  \n**Approach 3:** Using Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dlrudqhr7180",
                        "content": " I think test case 34 is invalid input (s = 3) while the problem indicates that \"s is guaranteed to be a valid input.\""
                    }
                ]
            },
            {
                "id": 1817605,
                "content": [
                    {
                        "username": "daily_coder",
                        "content": "Many times I solve some problem and after few hours/days I find amazed of myself that how did I even solved/coded this complex problem earlier!! Had this feeling? Please tell me, so that I can feel no alien."
                    },
                    {
                        "username": "an5dy90",
                        "content": "many times I forgot how I solved complex problems like this days months later and I needed to solve it again  "
                    },
                    {
                        "username": "aruuu____",
                        "content": "yeah same :)\\n"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "Yeah me too. Though I am beginner, I sometimes solve complex problems and after few days, I am amazed how did I solved."
                    },
                    {
                        "username": "Paleoanthropologist",
                        "content": "This is because you did not think through everything when you solved the problem initially. This happens a lot due to you have been band-aiding your code iteratively to achieve AC. "
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "at least you can solve it man"
                    },
                    {
                        "username": "Ranjan2002",
                        "content": "Ya  totally XD"
                    },
                    {
                        "username": "sahilbest999",
                        "content": "totally bro"
                    },
                    {
                        "username": "dengning1205",
                        "content": "Seems to be a lot harder than decode"
                    },
                    {
                        "username": "pbindal",
                        "content": "This is categorized under graph and trees. Looks like stacks and backtracking algo to me. Please correct if I am wrong"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1e9c82ea-4ff3-430b-a686-1be8a3e647f5_1642613017.35797.png)\\n\\n![image](https://assets.leetcode.com/users/images/5eee0955-2597-4439-8c87-8e0df45e461e_1642613023.443171.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d7645d9-4ef3-4875-810a-297d2f82a81a_1642613028.1248252.png)\\n\\n![image](https://assets.leetcode.com/users/images/5cec2dfd-2ec1-4ab6-9d9b-9a9b5f8e8d44_1642613031.8151512.png)\\n\\n![image](https://assets.leetcode.com/users/images/85c375af-7ac1-4006-b1f6-03da63b1d84a_1642613037.3188505.png)\\n\\n![image](https://assets.leetcode.com/users/images/42f7256e-f408-4c85-88f1-a029a32e7e4c_1642613048.1025255.png)\\n"
                    },
                    {
                        "username": "julyakovleva1107",
                        "content": "Hi! Could somebody please explain - how come we have s = \"3\" in the test cases if there are such constraints:\\n1) s consists of lowercase English letters, digits, AND square brackets \\'[]\\'.\\n2) s is guaranteed to be a valid input.\\n\\uD83E\\uDD14\\n"
                    },
                    {
                        "username": "Miryafa",
                        "content": "Well you're right - every number should be followed by brackets. The description specifically says \"there will not be input like 3a or 2[4]\", and '3' is an input like '2[4]', because if 3 is valid then 2[3] is too, so 2[4] must be too.\n\nAnd there's no input to the encoding function that can result in an encoded string of '3', so that's what I'd call an invalid test case that only avoids causing an error if you write your program the same way the author did."
                    },
                    {
                        "username": "cloudycandy",
                        "content": "Today I saw some people were asked the encoding as a follow up for leetcode #394 decode string. Most of the them only gave a brief direction during the interview and didn't write any code. But I would like to ask for more thoughts.\\n\\nI may think about using dynamic programming. For string s, the shortest encoding from the i<sup>th</sup> character to the j<sup>th</sup> character is denoted by dp[i][j], then we have:\\n* If i+2 > j, dp[i][j] = s[i-1:j ], i.e. just keep those characters.\\n* else If s[i-1:j ] can be represented as repeating patterns, then encode it as repeating_times[repeating_pattern], using the finest repeating pattern.\\n* otherwise dp[i][j] = min_length(dp[i][k] + dp[k+1][j]) where i < k < j\\n\\nIt runs in O(n<sup>3</sup>) time however, where n is the length of the string to be encoded.\\nDoes this work? What do you think about it?"
                    },
                    {
                        "username": "madfcat",
                        "content": "Does even the test case 34\\n\\ns = \"3\"\\n\\nmake sense?\\n\\nIt is said that \"s is guaranteed to be a valid input\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is \"3\" a testcase? My code passed all testcases but when I used \"3\" as a testcase directly, LeetCode came back with \"Invalid input\". Just as well. Had my code tried to run it, it would have pushed past the \"[\" (which in this case is actually the ASCII NULL character) and caused a segmentation fault;"
                    },
                    {
                        "username": "eLementarydew",
                        "content": "This was definitely a tricky test case . I think they were expecting what if there is nothing to decode . Any number followed by an empty string is still an empty string. Still a weird test case because of the question language."
                    },
                    {
                        "username": "ILoveBigBits",
                        "content": "Time complexity cannot depend only on the length of the input string.\\n**Time Complexity is also a function of the numbers that are represented inside the string**,\\n\\nSince **we are also appending characters to our final answer string**, consider this,\\n\\n\\n100[a101[b102[c]]]\\n\\n\\nHere the length of the string is 18, but in the final string we need to append approximately10^6 times.\\n\\n\\nGeneral Proof, \\n\\nLets consider an input of Length N\\nLet N\\' = N+1\\nconsider the string\\n**N[aN\\'[b]]**\\n\\n\\nHere we require atleast **N^2**, operations to append a and b to final string.\\n\\nA very bad upperbound is **O(N * ProductofAllNumbers * MaxDepthofRecursionTree)**\\n\\nIf someone has a better upper bound, or something is wrong with the above analysis please share!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Leetcode describes this as an invalid testcase - probably because the decoded string is longer than 10^5 characters."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/decode-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Using 2 Stack\n\n  \n**Approach 3:** Using Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dlrudqhr7180",
                        "content": " I think test case 34 is invalid input (s = 3) while the problem indicates that \"s is guaranteed to be a valid input.\""
                    }
                ]
            },
            {
                "id": 1566788,
                "content": [
                    {
                        "username": "daily_coder",
                        "content": "Many times I solve some problem and after few hours/days I find amazed of myself that how did I even solved/coded this complex problem earlier!! Had this feeling? Please tell me, so that I can feel no alien."
                    },
                    {
                        "username": "an5dy90",
                        "content": "many times I forgot how I solved complex problems like this days months later and I needed to solve it again  "
                    },
                    {
                        "username": "aruuu____",
                        "content": "yeah same :)\\n"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "Yeah me too. Though I am beginner, I sometimes solve complex problems and after few days, I am amazed how did I solved."
                    },
                    {
                        "username": "Paleoanthropologist",
                        "content": "This is because you did not think through everything when you solved the problem initially. This happens a lot due to you have been band-aiding your code iteratively to achieve AC. "
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "at least you can solve it man"
                    },
                    {
                        "username": "Ranjan2002",
                        "content": "Ya  totally XD"
                    },
                    {
                        "username": "sahilbest999",
                        "content": "totally bro"
                    },
                    {
                        "username": "dengning1205",
                        "content": "Seems to be a lot harder than decode"
                    },
                    {
                        "username": "pbindal",
                        "content": "This is categorized under graph and trees. Looks like stacks and backtracking algo to me. Please correct if I am wrong"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1e9c82ea-4ff3-430b-a686-1be8a3e647f5_1642613017.35797.png)\\n\\n![image](https://assets.leetcode.com/users/images/5eee0955-2597-4439-8c87-8e0df45e461e_1642613023.443171.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d7645d9-4ef3-4875-810a-297d2f82a81a_1642613028.1248252.png)\\n\\n![image](https://assets.leetcode.com/users/images/5cec2dfd-2ec1-4ab6-9d9b-9a9b5f8e8d44_1642613031.8151512.png)\\n\\n![image](https://assets.leetcode.com/users/images/85c375af-7ac1-4006-b1f6-03da63b1d84a_1642613037.3188505.png)\\n\\n![image](https://assets.leetcode.com/users/images/42f7256e-f408-4c85-88f1-a029a32e7e4c_1642613048.1025255.png)\\n"
                    },
                    {
                        "username": "julyakovleva1107",
                        "content": "Hi! Could somebody please explain - how come we have s = \"3\" in the test cases if there are such constraints:\\n1) s consists of lowercase English letters, digits, AND square brackets \\'[]\\'.\\n2) s is guaranteed to be a valid input.\\n\\uD83E\\uDD14\\n"
                    },
                    {
                        "username": "Miryafa",
                        "content": "Well you're right - every number should be followed by brackets. The description specifically says \"there will not be input like 3a or 2[4]\", and '3' is an input like '2[4]', because if 3 is valid then 2[3] is too, so 2[4] must be too.\n\nAnd there's no input to the encoding function that can result in an encoded string of '3', so that's what I'd call an invalid test case that only avoids causing an error if you write your program the same way the author did."
                    },
                    {
                        "username": "cloudycandy",
                        "content": "Today I saw some people were asked the encoding as a follow up for leetcode #394 decode string. Most of the them only gave a brief direction during the interview and didn't write any code. But I would like to ask for more thoughts.\\n\\nI may think about using dynamic programming. For string s, the shortest encoding from the i<sup>th</sup> character to the j<sup>th</sup> character is denoted by dp[i][j], then we have:\\n* If i+2 > j, dp[i][j] = s[i-1:j ], i.e. just keep those characters.\\n* else If s[i-1:j ] can be represented as repeating patterns, then encode it as repeating_times[repeating_pattern], using the finest repeating pattern.\\n* otherwise dp[i][j] = min_length(dp[i][k] + dp[k+1][j]) where i < k < j\\n\\nIt runs in O(n<sup>3</sup>) time however, where n is the length of the string to be encoded.\\nDoes this work? What do you think about it?"
                    },
                    {
                        "username": "madfcat",
                        "content": "Does even the test case 34\\n\\ns = \"3\"\\n\\nmake sense?\\n\\nIt is said that \"s is guaranteed to be a valid input\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is \"3\" a testcase? My code passed all testcases but when I used \"3\" as a testcase directly, LeetCode came back with \"Invalid input\". Just as well. Had my code tried to run it, it would have pushed past the \"[\" (which in this case is actually the ASCII NULL character) and caused a segmentation fault;"
                    },
                    {
                        "username": "eLementarydew",
                        "content": "This was definitely a tricky test case . I think they were expecting what if there is nothing to decode . Any number followed by an empty string is still an empty string. Still a weird test case because of the question language."
                    },
                    {
                        "username": "ILoveBigBits",
                        "content": "Time complexity cannot depend only on the length of the input string.\\n**Time Complexity is also a function of the numbers that are represented inside the string**,\\n\\nSince **we are also appending characters to our final answer string**, consider this,\\n\\n\\n100[a101[b102[c]]]\\n\\n\\nHere the length of the string is 18, but in the final string we need to append approximately10^6 times.\\n\\n\\nGeneral Proof, \\n\\nLets consider an input of Length N\\nLet N\\' = N+1\\nconsider the string\\n**N[aN\\'[b]]**\\n\\n\\nHere we require atleast **N^2**, operations to append a and b to final string.\\n\\nA very bad upperbound is **O(N * ProductofAllNumbers * MaxDepthofRecursionTree)**\\n\\nIf someone has a better upper bound, or something is wrong with the above analysis please share!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Leetcode describes this as an invalid testcase - probably because the decoded string is longer than 10^5 characters."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/decode-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Using 2 Stack\n\n  \n**Approach 3:** Using Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dlrudqhr7180",
                        "content": " I think test case 34 is invalid input (s = 3) while the problem indicates that \"s is guaranteed to be a valid input.\""
                    }
                ]
            },
            {
                "id": 1817631,
                "content": [
                    {
                        "username": "daily_coder",
                        "content": "Many times I solve some problem and after few hours/days I find amazed of myself that how did I even solved/coded this complex problem earlier!! Had this feeling? Please tell me, so that I can feel no alien."
                    },
                    {
                        "username": "an5dy90",
                        "content": "many times I forgot how I solved complex problems like this days months later and I needed to solve it again  "
                    },
                    {
                        "username": "aruuu____",
                        "content": "yeah same :)\\n"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "Yeah me too. Though I am beginner, I sometimes solve complex problems and after few days, I am amazed how did I solved."
                    },
                    {
                        "username": "Paleoanthropologist",
                        "content": "This is because you did not think through everything when you solved the problem initially. This happens a lot due to you have been band-aiding your code iteratively to achieve AC. "
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "at least you can solve it man"
                    },
                    {
                        "username": "Ranjan2002",
                        "content": "Ya  totally XD"
                    },
                    {
                        "username": "sahilbest999",
                        "content": "totally bro"
                    },
                    {
                        "username": "dengning1205",
                        "content": "Seems to be a lot harder than decode"
                    },
                    {
                        "username": "pbindal",
                        "content": "This is categorized under graph and trees. Looks like stacks and backtracking algo to me. Please correct if I am wrong"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1e9c82ea-4ff3-430b-a686-1be8a3e647f5_1642613017.35797.png)\\n\\n![image](https://assets.leetcode.com/users/images/5eee0955-2597-4439-8c87-8e0df45e461e_1642613023.443171.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d7645d9-4ef3-4875-810a-297d2f82a81a_1642613028.1248252.png)\\n\\n![image](https://assets.leetcode.com/users/images/5cec2dfd-2ec1-4ab6-9d9b-9a9b5f8e8d44_1642613031.8151512.png)\\n\\n![image](https://assets.leetcode.com/users/images/85c375af-7ac1-4006-b1f6-03da63b1d84a_1642613037.3188505.png)\\n\\n![image](https://assets.leetcode.com/users/images/42f7256e-f408-4c85-88f1-a029a32e7e4c_1642613048.1025255.png)\\n"
                    },
                    {
                        "username": "julyakovleva1107",
                        "content": "Hi! Could somebody please explain - how come we have s = \"3\" in the test cases if there are such constraints:\\n1) s consists of lowercase English letters, digits, AND square brackets \\'[]\\'.\\n2) s is guaranteed to be a valid input.\\n\\uD83E\\uDD14\\n"
                    },
                    {
                        "username": "Miryafa",
                        "content": "Well you're right - every number should be followed by brackets. The description specifically says \"there will not be input like 3a or 2[4]\", and '3' is an input like '2[4]', because if 3 is valid then 2[3] is too, so 2[4] must be too.\n\nAnd there's no input to the encoding function that can result in an encoded string of '3', so that's what I'd call an invalid test case that only avoids causing an error if you write your program the same way the author did."
                    },
                    {
                        "username": "cloudycandy",
                        "content": "Today I saw some people were asked the encoding as a follow up for leetcode #394 decode string. Most of the them only gave a brief direction during the interview and didn't write any code. But I would like to ask for more thoughts.\\n\\nI may think about using dynamic programming. For string s, the shortest encoding from the i<sup>th</sup> character to the j<sup>th</sup> character is denoted by dp[i][j], then we have:\\n* If i+2 > j, dp[i][j] = s[i-1:j ], i.e. just keep those characters.\\n* else If s[i-1:j ] can be represented as repeating patterns, then encode it as repeating_times[repeating_pattern], using the finest repeating pattern.\\n* otherwise dp[i][j] = min_length(dp[i][k] + dp[k+1][j]) where i < k < j\\n\\nIt runs in O(n<sup>3</sup>) time however, where n is the length of the string to be encoded.\\nDoes this work? What do you think about it?"
                    },
                    {
                        "username": "madfcat",
                        "content": "Does even the test case 34\\n\\ns = \"3\"\\n\\nmake sense?\\n\\nIt is said that \"s is guaranteed to be a valid input\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is \"3\" a testcase? My code passed all testcases but when I used \"3\" as a testcase directly, LeetCode came back with \"Invalid input\". Just as well. Had my code tried to run it, it would have pushed past the \"[\" (which in this case is actually the ASCII NULL character) and caused a segmentation fault;"
                    },
                    {
                        "username": "eLementarydew",
                        "content": "This was definitely a tricky test case . I think they were expecting what if there is nothing to decode . Any number followed by an empty string is still an empty string. Still a weird test case because of the question language."
                    },
                    {
                        "username": "ILoveBigBits",
                        "content": "Time complexity cannot depend only on the length of the input string.\\n**Time Complexity is also a function of the numbers that are represented inside the string**,\\n\\nSince **we are also appending characters to our final answer string**, consider this,\\n\\n\\n100[a101[b102[c]]]\\n\\n\\nHere the length of the string is 18, but in the final string we need to append approximately10^6 times.\\n\\n\\nGeneral Proof, \\n\\nLets consider an input of Length N\\nLet N\\' = N+1\\nconsider the string\\n**N[aN\\'[b]]**\\n\\n\\nHere we require atleast **N^2**, operations to append a and b to final string.\\n\\nA very bad upperbound is **O(N * ProductofAllNumbers * MaxDepthofRecursionTree)**\\n\\nIf someone has a better upper bound, or something is wrong with the above analysis please share!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Leetcode describes this as an invalid testcase - probably because the decoded string is longer than 10^5 characters."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/decode-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Using 2 Stack\n\n  \n**Approach 3:** Using Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dlrudqhr7180",
                        "content": " I think test case 34 is invalid input (s = 3) while the problem indicates that \"s is guaranteed to be a valid input.\""
                    }
                ]
            },
            {
                "id": 1566929,
                "content": [
                    {
                        "username": "daily_coder",
                        "content": "Many times I solve some problem and after few hours/days I find amazed of myself that how did I even solved/coded this complex problem earlier!! Had this feeling? Please tell me, so that I can feel no alien."
                    },
                    {
                        "username": "an5dy90",
                        "content": "many times I forgot how I solved complex problems like this days months later and I needed to solve it again  "
                    },
                    {
                        "username": "aruuu____",
                        "content": "yeah same :)\\n"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "Yeah me too. Though I am beginner, I sometimes solve complex problems and after few days, I am amazed how did I solved."
                    },
                    {
                        "username": "Paleoanthropologist",
                        "content": "This is because you did not think through everything when you solved the problem initially. This happens a lot due to you have been band-aiding your code iteratively to achieve AC. "
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "at least you can solve it man"
                    },
                    {
                        "username": "Ranjan2002",
                        "content": "Ya  totally XD"
                    },
                    {
                        "username": "sahilbest999",
                        "content": "totally bro"
                    },
                    {
                        "username": "dengning1205",
                        "content": "Seems to be a lot harder than decode"
                    },
                    {
                        "username": "pbindal",
                        "content": "This is categorized under graph and trees. Looks like stacks and backtracking algo to me. Please correct if I am wrong"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1e9c82ea-4ff3-430b-a686-1be8a3e647f5_1642613017.35797.png)\\n\\n![image](https://assets.leetcode.com/users/images/5eee0955-2597-4439-8c87-8e0df45e461e_1642613023.443171.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d7645d9-4ef3-4875-810a-297d2f82a81a_1642613028.1248252.png)\\n\\n![image](https://assets.leetcode.com/users/images/5cec2dfd-2ec1-4ab6-9d9b-9a9b5f8e8d44_1642613031.8151512.png)\\n\\n![image](https://assets.leetcode.com/users/images/85c375af-7ac1-4006-b1f6-03da63b1d84a_1642613037.3188505.png)\\n\\n![image](https://assets.leetcode.com/users/images/42f7256e-f408-4c85-88f1-a029a32e7e4c_1642613048.1025255.png)\\n"
                    },
                    {
                        "username": "julyakovleva1107",
                        "content": "Hi! Could somebody please explain - how come we have s = \"3\" in the test cases if there are such constraints:\\n1) s consists of lowercase English letters, digits, AND square brackets \\'[]\\'.\\n2) s is guaranteed to be a valid input.\\n\\uD83E\\uDD14\\n"
                    },
                    {
                        "username": "Miryafa",
                        "content": "Well you're right - every number should be followed by brackets. The description specifically says \"there will not be input like 3a or 2[4]\", and '3' is an input like '2[4]', because if 3 is valid then 2[3] is too, so 2[4] must be too.\n\nAnd there's no input to the encoding function that can result in an encoded string of '3', so that's what I'd call an invalid test case that only avoids causing an error if you write your program the same way the author did."
                    },
                    {
                        "username": "cloudycandy",
                        "content": "Today I saw some people were asked the encoding as a follow up for leetcode #394 decode string. Most of the them only gave a brief direction during the interview and didn't write any code. But I would like to ask for more thoughts.\\n\\nI may think about using dynamic programming. For string s, the shortest encoding from the i<sup>th</sup> character to the j<sup>th</sup> character is denoted by dp[i][j], then we have:\\n* If i+2 > j, dp[i][j] = s[i-1:j ], i.e. just keep those characters.\\n* else If s[i-1:j ] can be represented as repeating patterns, then encode it as repeating_times[repeating_pattern], using the finest repeating pattern.\\n* otherwise dp[i][j] = min_length(dp[i][k] + dp[k+1][j]) where i < k < j\\n\\nIt runs in O(n<sup>3</sup>) time however, where n is the length of the string to be encoded.\\nDoes this work? What do you think about it?"
                    },
                    {
                        "username": "madfcat",
                        "content": "Does even the test case 34\\n\\ns = \"3\"\\n\\nmake sense?\\n\\nIt is said that \"s is guaranteed to be a valid input\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is \"3\" a testcase? My code passed all testcases but when I used \"3\" as a testcase directly, LeetCode came back with \"Invalid input\". Just as well. Had my code tried to run it, it would have pushed past the \"[\" (which in this case is actually the ASCII NULL character) and caused a segmentation fault;"
                    },
                    {
                        "username": "eLementarydew",
                        "content": "This was definitely a tricky test case . I think they were expecting what if there is nothing to decode . Any number followed by an empty string is still an empty string. Still a weird test case because of the question language."
                    },
                    {
                        "username": "ILoveBigBits",
                        "content": "Time complexity cannot depend only on the length of the input string.\\n**Time Complexity is also a function of the numbers that are represented inside the string**,\\n\\nSince **we are also appending characters to our final answer string**, consider this,\\n\\n\\n100[a101[b102[c]]]\\n\\n\\nHere the length of the string is 18, but in the final string we need to append approximately10^6 times.\\n\\n\\nGeneral Proof, \\n\\nLets consider an input of Length N\\nLet N\\' = N+1\\nconsider the string\\n**N[aN\\'[b]]**\\n\\n\\nHere we require atleast **N^2**, operations to append a and b to final string.\\n\\nA very bad upperbound is **O(N * ProductofAllNumbers * MaxDepthofRecursionTree)**\\n\\nIf someone has a better upper bound, or something is wrong with the above analysis please share!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Leetcode describes this as an invalid testcase - probably because the decoded string is longer than 10^5 characters."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/decode-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Using 2 Stack\n\n  \n**Approach 3:** Using Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dlrudqhr7180",
                        "content": " I think test case 34 is invalid input (s = 3) while the problem indicates that \"s is guaranteed to be a valid input.\""
                    }
                ]
            },
            {
                "id": 1565722,
                "content": [
                    {
                        "username": "daily_coder",
                        "content": "Many times I solve some problem and after few hours/days I find amazed of myself that how did I even solved/coded this complex problem earlier!! Had this feeling? Please tell me, so that I can feel no alien."
                    },
                    {
                        "username": "an5dy90",
                        "content": "many times I forgot how I solved complex problems like this days months later and I needed to solve it again  "
                    },
                    {
                        "username": "aruuu____",
                        "content": "yeah same :)\\n"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "Yeah me too. Though I am beginner, I sometimes solve complex problems and after few days, I am amazed how did I solved."
                    },
                    {
                        "username": "Paleoanthropologist",
                        "content": "This is because you did not think through everything when you solved the problem initially. This happens a lot due to you have been band-aiding your code iteratively to achieve AC. "
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "at least you can solve it man"
                    },
                    {
                        "username": "Ranjan2002",
                        "content": "Ya  totally XD"
                    },
                    {
                        "username": "sahilbest999",
                        "content": "totally bro"
                    },
                    {
                        "username": "dengning1205",
                        "content": "Seems to be a lot harder than decode"
                    },
                    {
                        "username": "pbindal",
                        "content": "This is categorized under graph and trees. Looks like stacks and backtracking algo to me. Please correct if I am wrong"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1e9c82ea-4ff3-430b-a686-1be8a3e647f5_1642613017.35797.png)\\n\\n![image](https://assets.leetcode.com/users/images/5eee0955-2597-4439-8c87-8e0df45e461e_1642613023.443171.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d7645d9-4ef3-4875-810a-297d2f82a81a_1642613028.1248252.png)\\n\\n![image](https://assets.leetcode.com/users/images/5cec2dfd-2ec1-4ab6-9d9b-9a9b5f8e8d44_1642613031.8151512.png)\\n\\n![image](https://assets.leetcode.com/users/images/85c375af-7ac1-4006-b1f6-03da63b1d84a_1642613037.3188505.png)\\n\\n![image](https://assets.leetcode.com/users/images/42f7256e-f408-4c85-88f1-a029a32e7e4c_1642613048.1025255.png)\\n"
                    },
                    {
                        "username": "julyakovleva1107",
                        "content": "Hi! Could somebody please explain - how come we have s = \"3\" in the test cases if there are such constraints:\\n1) s consists of lowercase English letters, digits, AND square brackets \\'[]\\'.\\n2) s is guaranteed to be a valid input.\\n\\uD83E\\uDD14\\n"
                    },
                    {
                        "username": "Miryafa",
                        "content": "Well you're right - every number should be followed by brackets. The description specifically says \"there will not be input like 3a or 2[4]\", and '3' is an input like '2[4]', because if 3 is valid then 2[3] is too, so 2[4] must be too.\n\nAnd there's no input to the encoding function that can result in an encoded string of '3', so that's what I'd call an invalid test case that only avoids causing an error if you write your program the same way the author did."
                    },
                    {
                        "username": "cloudycandy",
                        "content": "Today I saw some people were asked the encoding as a follow up for leetcode #394 decode string. Most of the them only gave a brief direction during the interview and didn't write any code. But I would like to ask for more thoughts.\\n\\nI may think about using dynamic programming. For string s, the shortest encoding from the i<sup>th</sup> character to the j<sup>th</sup> character is denoted by dp[i][j], then we have:\\n* If i+2 > j, dp[i][j] = s[i-1:j ], i.e. just keep those characters.\\n* else If s[i-1:j ] can be represented as repeating patterns, then encode it as repeating_times[repeating_pattern], using the finest repeating pattern.\\n* otherwise dp[i][j] = min_length(dp[i][k] + dp[k+1][j]) where i < k < j\\n\\nIt runs in O(n<sup>3</sup>) time however, where n is the length of the string to be encoded.\\nDoes this work? What do you think about it?"
                    },
                    {
                        "username": "madfcat",
                        "content": "Does even the test case 34\\n\\ns = \"3\"\\n\\nmake sense?\\n\\nIt is said that \"s is guaranteed to be a valid input\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is \"3\" a testcase? My code passed all testcases but when I used \"3\" as a testcase directly, LeetCode came back with \"Invalid input\". Just as well. Had my code tried to run it, it would have pushed past the \"[\" (which in this case is actually the ASCII NULL character) and caused a segmentation fault;"
                    },
                    {
                        "username": "eLementarydew",
                        "content": "This was definitely a tricky test case . I think they were expecting what if there is nothing to decode . Any number followed by an empty string is still an empty string. Still a weird test case because of the question language."
                    },
                    {
                        "username": "ILoveBigBits",
                        "content": "Time complexity cannot depend only on the length of the input string.\\n**Time Complexity is also a function of the numbers that are represented inside the string**,\\n\\nSince **we are also appending characters to our final answer string**, consider this,\\n\\n\\n100[a101[b102[c]]]\\n\\n\\nHere the length of the string is 18, but in the final string we need to append approximately10^6 times.\\n\\n\\nGeneral Proof, \\n\\nLets consider an input of Length N\\nLet N\\' = N+1\\nconsider the string\\n**N[aN\\'[b]]**\\n\\n\\nHere we require atleast **N^2**, operations to append a and b to final string.\\n\\nA very bad upperbound is **O(N * ProductofAllNumbers * MaxDepthofRecursionTree)**\\n\\nIf someone has a better upper bound, or something is wrong with the above analysis please share!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Leetcode describes this as an invalid testcase - probably because the decoded string is longer than 10^5 characters."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/decode-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Using 2 Stack\n\n  \n**Approach 3:** Using Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dlrudqhr7180",
                        "content": " I think test case 34 is invalid input (s = 3) while the problem indicates that \"s is guaranteed to be a valid input.\""
                    }
                ]
            },
            {
                "id": 1819647,
                "content": [
                    {
                        "username": "daily_coder",
                        "content": "Many times I solve some problem and after few hours/days I find amazed of myself that how did I even solved/coded this complex problem earlier!! Had this feeling? Please tell me, so that I can feel no alien."
                    },
                    {
                        "username": "an5dy90",
                        "content": "many times I forgot how I solved complex problems like this days months later and I needed to solve it again  "
                    },
                    {
                        "username": "aruuu____",
                        "content": "yeah same :)\\n"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "Yeah me too. Though I am beginner, I sometimes solve complex problems and after few days, I am amazed how did I solved."
                    },
                    {
                        "username": "Paleoanthropologist",
                        "content": "This is because you did not think through everything when you solved the problem initially. This happens a lot due to you have been band-aiding your code iteratively to achieve AC. "
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "at least you can solve it man"
                    },
                    {
                        "username": "Ranjan2002",
                        "content": "Ya  totally XD"
                    },
                    {
                        "username": "sahilbest999",
                        "content": "totally bro"
                    },
                    {
                        "username": "dengning1205",
                        "content": "Seems to be a lot harder than decode"
                    },
                    {
                        "username": "pbindal",
                        "content": "This is categorized under graph and trees. Looks like stacks and backtracking algo to me. Please correct if I am wrong"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1e9c82ea-4ff3-430b-a686-1be8a3e647f5_1642613017.35797.png)\\n\\n![image](https://assets.leetcode.com/users/images/5eee0955-2597-4439-8c87-8e0df45e461e_1642613023.443171.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d7645d9-4ef3-4875-810a-297d2f82a81a_1642613028.1248252.png)\\n\\n![image](https://assets.leetcode.com/users/images/5cec2dfd-2ec1-4ab6-9d9b-9a9b5f8e8d44_1642613031.8151512.png)\\n\\n![image](https://assets.leetcode.com/users/images/85c375af-7ac1-4006-b1f6-03da63b1d84a_1642613037.3188505.png)\\n\\n![image](https://assets.leetcode.com/users/images/42f7256e-f408-4c85-88f1-a029a32e7e4c_1642613048.1025255.png)\\n"
                    },
                    {
                        "username": "julyakovleva1107",
                        "content": "Hi! Could somebody please explain - how come we have s = \"3\" in the test cases if there are such constraints:\\n1) s consists of lowercase English letters, digits, AND square brackets \\'[]\\'.\\n2) s is guaranteed to be a valid input.\\n\\uD83E\\uDD14\\n"
                    },
                    {
                        "username": "Miryafa",
                        "content": "Well you're right - every number should be followed by brackets. The description specifically says \"there will not be input like 3a or 2[4]\", and '3' is an input like '2[4]', because if 3 is valid then 2[3] is too, so 2[4] must be too.\n\nAnd there's no input to the encoding function that can result in an encoded string of '3', so that's what I'd call an invalid test case that only avoids causing an error if you write your program the same way the author did."
                    },
                    {
                        "username": "cloudycandy",
                        "content": "Today I saw some people were asked the encoding as a follow up for leetcode #394 decode string. Most of the them only gave a brief direction during the interview and didn't write any code. But I would like to ask for more thoughts.\\n\\nI may think about using dynamic programming. For string s, the shortest encoding from the i<sup>th</sup> character to the j<sup>th</sup> character is denoted by dp[i][j], then we have:\\n* If i+2 > j, dp[i][j] = s[i-1:j ], i.e. just keep those characters.\\n* else If s[i-1:j ] can be represented as repeating patterns, then encode it as repeating_times[repeating_pattern], using the finest repeating pattern.\\n* otherwise dp[i][j] = min_length(dp[i][k] + dp[k+1][j]) where i < k < j\\n\\nIt runs in O(n<sup>3</sup>) time however, where n is the length of the string to be encoded.\\nDoes this work? What do you think about it?"
                    },
                    {
                        "username": "madfcat",
                        "content": "Does even the test case 34\\n\\ns = \"3\"\\n\\nmake sense?\\n\\nIt is said that \"s is guaranteed to be a valid input\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is \"3\" a testcase? My code passed all testcases but when I used \"3\" as a testcase directly, LeetCode came back with \"Invalid input\". Just as well. Had my code tried to run it, it would have pushed past the \"[\" (which in this case is actually the ASCII NULL character) and caused a segmentation fault;"
                    },
                    {
                        "username": "eLementarydew",
                        "content": "This was definitely a tricky test case . I think they were expecting what if there is nothing to decode . Any number followed by an empty string is still an empty string. Still a weird test case because of the question language."
                    },
                    {
                        "username": "ILoveBigBits",
                        "content": "Time complexity cannot depend only on the length of the input string.\\n**Time Complexity is also a function of the numbers that are represented inside the string**,\\n\\nSince **we are also appending characters to our final answer string**, consider this,\\n\\n\\n100[a101[b102[c]]]\\n\\n\\nHere the length of the string is 18, but in the final string we need to append approximately10^6 times.\\n\\n\\nGeneral Proof, \\n\\nLets consider an input of Length N\\nLet N\\' = N+1\\nconsider the string\\n**N[aN\\'[b]]**\\n\\n\\nHere we require atleast **N^2**, operations to append a and b to final string.\\n\\nA very bad upperbound is **O(N * ProductofAllNumbers * MaxDepthofRecursionTree)**\\n\\nIf someone has a better upper bound, or something is wrong with the above analysis please share!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Leetcode describes this as an invalid testcase - probably because the decoded string is longer than 10^5 characters."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/decode-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Using 2 Stack\n\n  \n**Approach 3:** Using Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dlrudqhr7180",
                        "content": " I think test case 34 is invalid input (s = 3) while the problem indicates that \"s is guaranteed to be a valid input.\""
                    }
                ]
            },
            {
                "id": 1574402,
                "content": [
                    {
                        "username": "daily_coder",
                        "content": "Many times I solve some problem and after few hours/days I find amazed of myself that how did I even solved/coded this complex problem earlier!! Had this feeling? Please tell me, so that I can feel no alien."
                    },
                    {
                        "username": "an5dy90",
                        "content": "many times I forgot how I solved complex problems like this days months later and I needed to solve it again  "
                    },
                    {
                        "username": "aruuu____",
                        "content": "yeah same :)\\n"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "Yeah me too. Though I am beginner, I sometimes solve complex problems and after few days, I am amazed how did I solved."
                    },
                    {
                        "username": "Paleoanthropologist",
                        "content": "This is because you did not think through everything when you solved the problem initially. This happens a lot due to you have been band-aiding your code iteratively to achieve AC. "
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "at least you can solve it man"
                    },
                    {
                        "username": "Ranjan2002",
                        "content": "Ya  totally XD"
                    },
                    {
                        "username": "sahilbest999",
                        "content": "totally bro"
                    },
                    {
                        "username": "dengning1205",
                        "content": "Seems to be a lot harder than decode"
                    },
                    {
                        "username": "pbindal",
                        "content": "This is categorized under graph and trees. Looks like stacks and backtracking algo to me. Please correct if I am wrong"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1e9c82ea-4ff3-430b-a686-1be8a3e647f5_1642613017.35797.png)\\n\\n![image](https://assets.leetcode.com/users/images/5eee0955-2597-4439-8c87-8e0df45e461e_1642613023.443171.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d7645d9-4ef3-4875-810a-297d2f82a81a_1642613028.1248252.png)\\n\\n![image](https://assets.leetcode.com/users/images/5cec2dfd-2ec1-4ab6-9d9b-9a9b5f8e8d44_1642613031.8151512.png)\\n\\n![image](https://assets.leetcode.com/users/images/85c375af-7ac1-4006-b1f6-03da63b1d84a_1642613037.3188505.png)\\n\\n![image](https://assets.leetcode.com/users/images/42f7256e-f408-4c85-88f1-a029a32e7e4c_1642613048.1025255.png)\\n"
                    },
                    {
                        "username": "julyakovleva1107",
                        "content": "Hi! Could somebody please explain - how come we have s = \"3\" in the test cases if there are such constraints:\\n1) s consists of lowercase English letters, digits, AND square brackets \\'[]\\'.\\n2) s is guaranteed to be a valid input.\\n\\uD83E\\uDD14\\n"
                    },
                    {
                        "username": "Miryafa",
                        "content": "Well you're right - every number should be followed by brackets. The description specifically says \"there will not be input like 3a or 2[4]\", and '3' is an input like '2[4]', because if 3 is valid then 2[3] is too, so 2[4] must be too.\n\nAnd there's no input to the encoding function that can result in an encoded string of '3', so that's what I'd call an invalid test case that only avoids causing an error if you write your program the same way the author did."
                    },
                    {
                        "username": "cloudycandy",
                        "content": "Today I saw some people were asked the encoding as a follow up for leetcode #394 decode string. Most of the them only gave a brief direction during the interview and didn't write any code. But I would like to ask for more thoughts.\\n\\nI may think about using dynamic programming. For string s, the shortest encoding from the i<sup>th</sup> character to the j<sup>th</sup> character is denoted by dp[i][j], then we have:\\n* If i+2 > j, dp[i][j] = s[i-1:j ], i.e. just keep those characters.\\n* else If s[i-1:j ] can be represented as repeating patterns, then encode it as repeating_times[repeating_pattern], using the finest repeating pattern.\\n* otherwise dp[i][j] = min_length(dp[i][k] + dp[k+1][j]) where i < k < j\\n\\nIt runs in O(n<sup>3</sup>) time however, where n is the length of the string to be encoded.\\nDoes this work? What do you think about it?"
                    },
                    {
                        "username": "madfcat",
                        "content": "Does even the test case 34\\n\\ns = \"3\"\\n\\nmake sense?\\n\\nIt is said that \"s is guaranteed to be a valid input\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is \"3\" a testcase? My code passed all testcases but when I used \"3\" as a testcase directly, LeetCode came back with \"Invalid input\". Just as well. Had my code tried to run it, it would have pushed past the \"[\" (which in this case is actually the ASCII NULL character) and caused a segmentation fault;"
                    },
                    {
                        "username": "eLementarydew",
                        "content": "This was definitely a tricky test case . I think they were expecting what if there is nothing to decode . Any number followed by an empty string is still an empty string. Still a weird test case because of the question language."
                    },
                    {
                        "username": "ILoveBigBits",
                        "content": "Time complexity cannot depend only on the length of the input string.\\n**Time Complexity is also a function of the numbers that are represented inside the string**,\\n\\nSince **we are also appending characters to our final answer string**, consider this,\\n\\n\\n100[a101[b102[c]]]\\n\\n\\nHere the length of the string is 18, but in the final string we need to append approximately10^6 times.\\n\\n\\nGeneral Proof, \\n\\nLets consider an input of Length N\\nLet N\\' = N+1\\nconsider the string\\n**N[aN\\'[b]]**\\n\\n\\nHere we require atleast **N^2**, operations to append a and b to final string.\\n\\nA very bad upperbound is **O(N * ProductofAllNumbers * MaxDepthofRecursionTree)**\\n\\nIf someone has a better upper bound, or something is wrong with the above analysis please share!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Leetcode describes this as an invalid testcase - probably because the decoded string is longer than 10^5 characters."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/decode-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Using 2 Stack\n\n  \n**Approach 3:** Using Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dlrudqhr7180",
                        "content": " I think test case 34 is invalid input (s = 3) while the problem indicates that \"s is guaranteed to be a valid input.\""
                    }
                ]
            },
            {
                "id": 1567969,
                "content": [
                    {
                        "username": "daily_coder",
                        "content": "Many times I solve some problem and after few hours/days I find amazed of myself that how did I even solved/coded this complex problem earlier!! Had this feeling? Please tell me, so that I can feel no alien."
                    },
                    {
                        "username": "an5dy90",
                        "content": "many times I forgot how I solved complex problems like this days months later and I needed to solve it again  "
                    },
                    {
                        "username": "aruuu____",
                        "content": "yeah same :)\\n"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "Yeah me too. Though I am beginner, I sometimes solve complex problems and after few days, I am amazed how did I solved."
                    },
                    {
                        "username": "Paleoanthropologist",
                        "content": "This is because you did not think through everything when you solved the problem initially. This happens a lot due to you have been band-aiding your code iteratively to achieve AC. "
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "at least you can solve it man"
                    },
                    {
                        "username": "Ranjan2002",
                        "content": "Ya  totally XD"
                    },
                    {
                        "username": "sahilbest999",
                        "content": "totally bro"
                    },
                    {
                        "username": "dengning1205",
                        "content": "Seems to be a lot harder than decode"
                    },
                    {
                        "username": "pbindal",
                        "content": "This is categorized under graph and trees. Looks like stacks and backtracking algo to me. Please correct if I am wrong"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1e9c82ea-4ff3-430b-a686-1be8a3e647f5_1642613017.35797.png)\\n\\n![image](https://assets.leetcode.com/users/images/5eee0955-2597-4439-8c87-8e0df45e461e_1642613023.443171.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d7645d9-4ef3-4875-810a-297d2f82a81a_1642613028.1248252.png)\\n\\n![image](https://assets.leetcode.com/users/images/5cec2dfd-2ec1-4ab6-9d9b-9a9b5f8e8d44_1642613031.8151512.png)\\n\\n![image](https://assets.leetcode.com/users/images/85c375af-7ac1-4006-b1f6-03da63b1d84a_1642613037.3188505.png)\\n\\n![image](https://assets.leetcode.com/users/images/42f7256e-f408-4c85-88f1-a029a32e7e4c_1642613048.1025255.png)\\n"
                    },
                    {
                        "username": "julyakovleva1107",
                        "content": "Hi! Could somebody please explain - how come we have s = \"3\" in the test cases if there are such constraints:\\n1) s consists of lowercase English letters, digits, AND square brackets \\'[]\\'.\\n2) s is guaranteed to be a valid input.\\n\\uD83E\\uDD14\\n"
                    },
                    {
                        "username": "Miryafa",
                        "content": "Well you're right - every number should be followed by brackets. The description specifically says \"there will not be input like 3a or 2[4]\", and '3' is an input like '2[4]', because if 3 is valid then 2[3] is too, so 2[4] must be too.\n\nAnd there's no input to the encoding function that can result in an encoded string of '3', so that's what I'd call an invalid test case that only avoids causing an error if you write your program the same way the author did."
                    },
                    {
                        "username": "cloudycandy",
                        "content": "Today I saw some people were asked the encoding as a follow up for leetcode #394 decode string. Most of the them only gave a brief direction during the interview and didn't write any code. But I would like to ask for more thoughts.\\n\\nI may think about using dynamic programming. For string s, the shortest encoding from the i<sup>th</sup> character to the j<sup>th</sup> character is denoted by dp[i][j], then we have:\\n* If i+2 > j, dp[i][j] = s[i-1:j ], i.e. just keep those characters.\\n* else If s[i-1:j ] can be represented as repeating patterns, then encode it as repeating_times[repeating_pattern], using the finest repeating pattern.\\n* otherwise dp[i][j] = min_length(dp[i][k] + dp[k+1][j]) where i < k < j\\n\\nIt runs in O(n<sup>3</sup>) time however, where n is the length of the string to be encoded.\\nDoes this work? What do you think about it?"
                    },
                    {
                        "username": "madfcat",
                        "content": "Does even the test case 34\\n\\ns = \"3\"\\n\\nmake sense?\\n\\nIt is said that \"s is guaranteed to be a valid input\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is \"3\" a testcase? My code passed all testcases but when I used \"3\" as a testcase directly, LeetCode came back with \"Invalid input\". Just as well. Had my code tried to run it, it would have pushed past the \"[\" (which in this case is actually the ASCII NULL character) and caused a segmentation fault;"
                    },
                    {
                        "username": "eLementarydew",
                        "content": "This was definitely a tricky test case . I think they were expecting what if there is nothing to decode . Any number followed by an empty string is still an empty string. Still a weird test case because of the question language."
                    },
                    {
                        "username": "ILoveBigBits",
                        "content": "Time complexity cannot depend only on the length of the input string.\\n**Time Complexity is also a function of the numbers that are represented inside the string**,\\n\\nSince **we are also appending characters to our final answer string**, consider this,\\n\\n\\n100[a101[b102[c]]]\\n\\n\\nHere the length of the string is 18, but in the final string we need to append approximately10^6 times.\\n\\n\\nGeneral Proof, \\n\\nLets consider an input of Length N\\nLet N\\' = N+1\\nconsider the string\\n**N[aN\\'[b]]**\\n\\n\\nHere we require atleast **N^2**, operations to append a and b to final string.\\n\\nA very bad upperbound is **O(N * ProductofAllNumbers * MaxDepthofRecursionTree)**\\n\\nIf someone has a better upper bound, or something is wrong with the above analysis please share!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Leetcode describes this as an invalid testcase - probably because the decoded string is longer than 10^5 characters."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/decode-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Using 2 Stack\n\n  \n**Approach 3:** Using Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dlrudqhr7180",
                        "content": " I think test case 34 is invalid input (s = 3) while the problem indicates that \"s is guaranteed to be a valid input.\""
                    }
                ]
            },
            {
                "id": 1570173,
                "content": [
                    {
                        "username": "daily_coder",
                        "content": "Many times I solve some problem and after few hours/days I find amazed of myself that how did I even solved/coded this complex problem earlier!! Had this feeling? Please tell me, so that I can feel no alien."
                    },
                    {
                        "username": "an5dy90",
                        "content": "many times I forgot how I solved complex problems like this days months later and I needed to solve it again  "
                    },
                    {
                        "username": "aruuu____",
                        "content": "yeah same :)\\n"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "Yeah me too. Though I am beginner, I sometimes solve complex problems and after few days, I am amazed how did I solved."
                    },
                    {
                        "username": "Paleoanthropologist",
                        "content": "This is because you did not think through everything when you solved the problem initially. This happens a lot due to you have been band-aiding your code iteratively to achieve AC. "
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "at least you can solve it man"
                    },
                    {
                        "username": "Ranjan2002",
                        "content": "Ya  totally XD"
                    },
                    {
                        "username": "sahilbest999",
                        "content": "totally bro"
                    },
                    {
                        "username": "dengning1205",
                        "content": "Seems to be a lot harder than decode"
                    },
                    {
                        "username": "pbindal",
                        "content": "This is categorized under graph and trees. Looks like stacks and backtracking algo to me. Please correct if I am wrong"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1e9c82ea-4ff3-430b-a686-1be8a3e647f5_1642613017.35797.png)\\n\\n![image](https://assets.leetcode.com/users/images/5eee0955-2597-4439-8c87-8e0df45e461e_1642613023.443171.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d7645d9-4ef3-4875-810a-297d2f82a81a_1642613028.1248252.png)\\n\\n![image](https://assets.leetcode.com/users/images/5cec2dfd-2ec1-4ab6-9d9b-9a9b5f8e8d44_1642613031.8151512.png)\\n\\n![image](https://assets.leetcode.com/users/images/85c375af-7ac1-4006-b1f6-03da63b1d84a_1642613037.3188505.png)\\n\\n![image](https://assets.leetcode.com/users/images/42f7256e-f408-4c85-88f1-a029a32e7e4c_1642613048.1025255.png)\\n"
                    },
                    {
                        "username": "julyakovleva1107",
                        "content": "Hi! Could somebody please explain - how come we have s = \"3\" in the test cases if there are such constraints:\\n1) s consists of lowercase English letters, digits, AND square brackets \\'[]\\'.\\n2) s is guaranteed to be a valid input.\\n\\uD83E\\uDD14\\n"
                    },
                    {
                        "username": "Miryafa",
                        "content": "Well you're right - every number should be followed by brackets. The description specifically says \"there will not be input like 3a or 2[4]\", and '3' is an input like '2[4]', because if 3 is valid then 2[3] is too, so 2[4] must be too.\n\nAnd there's no input to the encoding function that can result in an encoded string of '3', so that's what I'd call an invalid test case that only avoids causing an error if you write your program the same way the author did."
                    },
                    {
                        "username": "cloudycandy",
                        "content": "Today I saw some people were asked the encoding as a follow up for leetcode #394 decode string. Most of the them only gave a brief direction during the interview and didn't write any code. But I would like to ask for more thoughts.\\n\\nI may think about using dynamic programming. For string s, the shortest encoding from the i<sup>th</sup> character to the j<sup>th</sup> character is denoted by dp[i][j], then we have:\\n* If i+2 > j, dp[i][j] = s[i-1:j ], i.e. just keep those characters.\\n* else If s[i-1:j ] can be represented as repeating patterns, then encode it as repeating_times[repeating_pattern], using the finest repeating pattern.\\n* otherwise dp[i][j] = min_length(dp[i][k] + dp[k+1][j]) where i < k < j\\n\\nIt runs in O(n<sup>3</sup>) time however, where n is the length of the string to be encoded.\\nDoes this work? What do you think about it?"
                    },
                    {
                        "username": "madfcat",
                        "content": "Does even the test case 34\\n\\ns = \"3\"\\n\\nmake sense?\\n\\nIt is said that \"s is guaranteed to be a valid input\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is \"3\" a testcase? My code passed all testcases but when I used \"3\" as a testcase directly, LeetCode came back with \"Invalid input\". Just as well. Had my code tried to run it, it would have pushed past the \"[\" (which in this case is actually the ASCII NULL character) and caused a segmentation fault;"
                    },
                    {
                        "username": "eLementarydew",
                        "content": "This was definitely a tricky test case . I think they were expecting what if there is nothing to decode . Any number followed by an empty string is still an empty string. Still a weird test case because of the question language."
                    },
                    {
                        "username": "ILoveBigBits",
                        "content": "Time complexity cannot depend only on the length of the input string.\\n**Time Complexity is also a function of the numbers that are represented inside the string**,\\n\\nSince **we are also appending characters to our final answer string**, consider this,\\n\\n\\n100[a101[b102[c]]]\\n\\n\\nHere the length of the string is 18, but in the final string we need to append approximately10^6 times.\\n\\n\\nGeneral Proof, \\n\\nLets consider an input of Length N\\nLet N\\' = N+1\\nconsider the string\\n**N[aN\\'[b]]**\\n\\n\\nHere we require atleast **N^2**, operations to append a and b to final string.\\n\\nA very bad upperbound is **O(N * ProductofAllNumbers * MaxDepthofRecursionTree)**\\n\\nIf someone has a better upper bound, or something is wrong with the above analysis please share!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Leetcode describes this as an invalid testcase - probably because the decoded string is longer than 10^5 characters."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/decode-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Using 2 Stack\n\n  \n**Approach 3:** Using Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dlrudqhr7180",
                        "content": " I think test case 34 is invalid input (s = 3) while the problem indicates that \"s is guaranteed to be a valid input.\""
                    }
                ]
            },
            {
                "id": 1576264,
                "content": [
                    {
                        "username": "daily_coder",
                        "content": "Many times I solve some problem and after few hours/days I find amazed of myself that how did I even solved/coded this complex problem earlier!! Had this feeling? Please tell me, so that I can feel no alien."
                    },
                    {
                        "username": "an5dy90",
                        "content": "many times I forgot how I solved complex problems like this days months later and I needed to solve it again  "
                    },
                    {
                        "username": "aruuu____",
                        "content": "yeah same :)\\n"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "Yeah me too. Though I am beginner, I sometimes solve complex problems and after few days, I am amazed how did I solved."
                    },
                    {
                        "username": "Paleoanthropologist",
                        "content": "This is because you did not think through everything when you solved the problem initially. This happens a lot due to you have been band-aiding your code iteratively to achieve AC. "
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "at least you can solve it man"
                    },
                    {
                        "username": "Ranjan2002",
                        "content": "Ya  totally XD"
                    },
                    {
                        "username": "sahilbest999",
                        "content": "totally bro"
                    },
                    {
                        "username": "dengning1205",
                        "content": "Seems to be a lot harder than decode"
                    },
                    {
                        "username": "pbindal",
                        "content": "This is categorized under graph and trees. Looks like stacks and backtracking algo to me. Please correct if I am wrong"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1e9c82ea-4ff3-430b-a686-1be8a3e647f5_1642613017.35797.png)\\n\\n![image](https://assets.leetcode.com/users/images/5eee0955-2597-4439-8c87-8e0df45e461e_1642613023.443171.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d7645d9-4ef3-4875-810a-297d2f82a81a_1642613028.1248252.png)\\n\\n![image](https://assets.leetcode.com/users/images/5cec2dfd-2ec1-4ab6-9d9b-9a9b5f8e8d44_1642613031.8151512.png)\\n\\n![image](https://assets.leetcode.com/users/images/85c375af-7ac1-4006-b1f6-03da63b1d84a_1642613037.3188505.png)\\n\\n![image](https://assets.leetcode.com/users/images/42f7256e-f408-4c85-88f1-a029a32e7e4c_1642613048.1025255.png)\\n"
                    },
                    {
                        "username": "julyakovleva1107",
                        "content": "Hi! Could somebody please explain - how come we have s = \"3\" in the test cases if there are such constraints:\\n1) s consists of lowercase English letters, digits, AND square brackets \\'[]\\'.\\n2) s is guaranteed to be a valid input.\\n\\uD83E\\uDD14\\n"
                    },
                    {
                        "username": "Miryafa",
                        "content": "Well you're right - every number should be followed by brackets. The description specifically says \"there will not be input like 3a or 2[4]\", and '3' is an input like '2[4]', because if 3 is valid then 2[3] is too, so 2[4] must be too.\n\nAnd there's no input to the encoding function that can result in an encoded string of '3', so that's what I'd call an invalid test case that only avoids causing an error if you write your program the same way the author did."
                    },
                    {
                        "username": "cloudycandy",
                        "content": "Today I saw some people were asked the encoding as a follow up for leetcode #394 decode string. Most of the them only gave a brief direction during the interview and didn't write any code. But I would like to ask for more thoughts.\\n\\nI may think about using dynamic programming. For string s, the shortest encoding from the i<sup>th</sup> character to the j<sup>th</sup> character is denoted by dp[i][j], then we have:\\n* If i+2 > j, dp[i][j] = s[i-1:j ], i.e. just keep those characters.\\n* else If s[i-1:j ] can be represented as repeating patterns, then encode it as repeating_times[repeating_pattern], using the finest repeating pattern.\\n* otherwise dp[i][j] = min_length(dp[i][k] + dp[k+1][j]) where i < k < j\\n\\nIt runs in O(n<sup>3</sup>) time however, where n is the length of the string to be encoded.\\nDoes this work? What do you think about it?"
                    },
                    {
                        "username": "madfcat",
                        "content": "Does even the test case 34\\n\\ns = \"3\"\\n\\nmake sense?\\n\\nIt is said that \"s is guaranteed to be a valid input\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is \"3\" a testcase? My code passed all testcases but when I used \"3\" as a testcase directly, LeetCode came back with \"Invalid input\". Just as well. Had my code tried to run it, it would have pushed past the \"[\" (which in this case is actually the ASCII NULL character) and caused a segmentation fault;"
                    },
                    {
                        "username": "eLementarydew",
                        "content": "This was definitely a tricky test case . I think they were expecting what if there is nothing to decode . Any number followed by an empty string is still an empty string. Still a weird test case because of the question language."
                    },
                    {
                        "username": "ILoveBigBits",
                        "content": "Time complexity cannot depend only on the length of the input string.\\n**Time Complexity is also a function of the numbers that are represented inside the string**,\\n\\nSince **we are also appending characters to our final answer string**, consider this,\\n\\n\\n100[a101[b102[c]]]\\n\\n\\nHere the length of the string is 18, but in the final string we need to append approximately10^6 times.\\n\\n\\nGeneral Proof, \\n\\nLets consider an input of Length N\\nLet N\\' = N+1\\nconsider the string\\n**N[aN\\'[b]]**\\n\\n\\nHere we require atleast **N^2**, operations to append a and b to final string.\\n\\nA very bad upperbound is **O(N * ProductofAllNumbers * MaxDepthofRecursionTree)**\\n\\nIf someone has a better upper bound, or something is wrong with the above analysis please share!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Leetcode describes this as an invalid testcase - probably because the decoded string is longer than 10^5 characters."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/decode-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Using 2 Stack\n\n  \n**Approach 3:** Using Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dlrudqhr7180",
                        "content": " I think test case 34 is invalid input (s = 3) while the problem indicates that \"s is guaranteed to be a valid input.\""
                    }
                ]
            },
            {
                "id": 1817605,
                "content": [
                    {
                        "username": "daily_coder",
                        "content": "Many times I solve some problem and after few hours/days I find amazed of myself that how did I even solved/coded this complex problem earlier!! Had this feeling? Please tell me, so that I can feel no alien."
                    },
                    {
                        "username": "an5dy90",
                        "content": "many times I forgot how I solved complex problems like this days months later and I needed to solve it again  "
                    },
                    {
                        "username": "aruuu____",
                        "content": "yeah same :)\\n"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "Yeah me too. Though I am beginner, I sometimes solve complex problems and after few days, I am amazed how did I solved."
                    },
                    {
                        "username": "Paleoanthropologist",
                        "content": "This is because you did not think through everything when you solved the problem initially. This happens a lot due to you have been band-aiding your code iteratively to achieve AC. "
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "at least you can solve it man"
                    },
                    {
                        "username": "Ranjan2002",
                        "content": "Ya  totally XD"
                    },
                    {
                        "username": "sahilbest999",
                        "content": "totally bro"
                    },
                    {
                        "username": "dengning1205",
                        "content": "Seems to be a lot harder than decode"
                    },
                    {
                        "username": "pbindal",
                        "content": "This is categorized under graph and trees. Looks like stacks and backtracking algo to me. Please correct if I am wrong"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1e9c82ea-4ff3-430b-a686-1be8a3e647f5_1642613017.35797.png)\\n\\n![image](https://assets.leetcode.com/users/images/5eee0955-2597-4439-8c87-8e0df45e461e_1642613023.443171.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d7645d9-4ef3-4875-810a-297d2f82a81a_1642613028.1248252.png)\\n\\n![image](https://assets.leetcode.com/users/images/5cec2dfd-2ec1-4ab6-9d9b-9a9b5f8e8d44_1642613031.8151512.png)\\n\\n![image](https://assets.leetcode.com/users/images/85c375af-7ac1-4006-b1f6-03da63b1d84a_1642613037.3188505.png)\\n\\n![image](https://assets.leetcode.com/users/images/42f7256e-f408-4c85-88f1-a029a32e7e4c_1642613048.1025255.png)\\n"
                    },
                    {
                        "username": "julyakovleva1107",
                        "content": "Hi! Could somebody please explain - how come we have s = \"3\" in the test cases if there are such constraints:\\n1) s consists of lowercase English letters, digits, AND square brackets \\'[]\\'.\\n2) s is guaranteed to be a valid input.\\n\\uD83E\\uDD14\\n"
                    },
                    {
                        "username": "Miryafa",
                        "content": "Well you're right - every number should be followed by brackets. The description specifically says \"there will not be input like 3a or 2[4]\", and '3' is an input like '2[4]', because if 3 is valid then 2[3] is too, so 2[4] must be too.\n\nAnd there's no input to the encoding function that can result in an encoded string of '3', so that's what I'd call an invalid test case that only avoids causing an error if you write your program the same way the author did."
                    },
                    {
                        "username": "cloudycandy",
                        "content": "Today I saw some people were asked the encoding as a follow up for leetcode #394 decode string. Most of the them only gave a brief direction during the interview and didn't write any code. But I would like to ask for more thoughts.\\n\\nI may think about using dynamic programming. For string s, the shortest encoding from the i<sup>th</sup> character to the j<sup>th</sup> character is denoted by dp[i][j], then we have:\\n* If i+2 > j, dp[i][j] = s[i-1:j ], i.e. just keep those characters.\\n* else If s[i-1:j ] can be represented as repeating patterns, then encode it as repeating_times[repeating_pattern], using the finest repeating pattern.\\n* otherwise dp[i][j] = min_length(dp[i][k] + dp[k+1][j]) where i < k < j\\n\\nIt runs in O(n<sup>3</sup>) time however, where n is the length of the string to be encoded.\\nDoes this work? What do you think about it?"
                    },
                    {
                        "username": "madfcat",
                        "content": "Does even the test case 34\\n\\ns = \"3\"\\n\\nmake sense?\\n\\nIt is said that \"s is guaranteed to be a valid input\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is \"3\" a testcase? My code passed all testcases but when I used \"3\" as a testcase directly, LeetCode came back with \"Invalid input\". Just as well. Had my code tried to run it, it would have pushed past the \"[\" (which in this case is actually the ASCII NULL character) and caused a segmentation fault;"
                    },
                    {
                        "username": "eLementarydew",
                        "content": "This was definitely a tricky test case . I think they were expecting what if there is nothing to decode . Any number followed by an empty string is still an empty string. Still a weird test case because of the question language."
                    },
                    {
                        "username": "ILoveBigBits",
                        "content": "Time complexity cannot depend only on the length of the input string.\\n**Time Complexity is also a function of the numbers that are represented inside the string**,\\n\\nSince **we are also appending characters to our final answer string**, consider this,\\n\\n\\n100[a101[b102[c]]]\\n\\n\\nHere the length of the string is 18, but in the final string we need to append approximately10^6 times.\\n\\n\\nGeneral Proof, \\n\\nLets consider an input of Length N\\nLet N\\' = N+1\\nconsider the string\\n**N[aN\\'[b]]**\\n\\n\\nHere we require atleast **N^2**, operations to append a and b to final string.\\n\\nA very bad upperbound is **O(N * ProductofAllNumbers * MaxDepthofRecursionTree)**\\n\\nIf someone has a better upper bound, or something is wrong with the above analysis please share!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Leetcode describes this as an invalid testcase - probably because the decoded string is longer than 10^5 characters."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/decode-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Using 2 Stack\n\n  \n**Approach 3:** Using Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dlrudqhr7180",
                        "content": " I think test case 34 is invalid input (s = 3) while the problem indicates that \"s is guaranteed to be a valid input.\""
                    }
                ]
            },
            {
                "id": 1566788,
                "content": [
                    {
                        "username": "daily_coder",
                        "content": "Many times I solve some problem and after few hours/days I find amazed of myself that how did I even solved/coded this complex problem earlier!! Had this feeling? Please tell me, so that I can feel no alien."
                    },
                    {
                        "username": "an5dy90",
                        "content": "many times I forgot how I solved complex problems like this days months later and I needed to solve it again  "
                    },
                    {
                        "username": "aruuu____",
                        "content": "yeah same :)\\n"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "Yeah me too. Though I am beginner, I sometimes solve complex problems and after few days, I am amazed how did I solved."
                    },
                    {
                        "username": "Paleoanthropologist",
                        "content": "This is because you did not think through everything when you solved the problem initially. This happens a lot due to you have been band-aiding your code iteratively to achieve AC. "
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "at least you can solve it man"
                    },
                    {
                        "username": "Ranjan2002",
                        "content": "Ya  totally XD"
                    },
                    {
                        "username": "sahilbest999",
                        "content": "totally bro"
                    },
                    {
                        "username": "dengning1205",
                        "content": "Seems to be a lot harder than decode"
                    },
                    {
                        "username": "pbindal",
                        "content": "This is categorized under graph and trees. Looks like stacks and backtracking algo to me. Please correct if I am wrong"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1e9c82ea-4ff3-430b-a686-1be8a3e647f5_1642613017.35797.png)\\n\\n![image](https://assets.leetcode.com/users/images/5eee0955-2597-4439-8c87-8e0df45e461e_1642613023.443171.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d7645d9-4ef3-4875-810a-297d2f82a81a_1642613028.1248252.png)\\n\\n![image](https://assets.leetcode.com/users/images/5cec2dfd-2ec1-4ab6-9d9b-9a9b5f8e8d44_1642613031.8151512.png)\\n\\n![image](https://assets.leetcode.com/users/images/85c375af-7ac1-4006-b1f6-03da63b1d84a_1642613037.3188505.png)\\n\\n![image](https://assets.leetcode.com/users/images/42f7256e-f408-4c85-88f1-a029a32e7e4c_1642613048.1025255.png)\\n"
                    },
                    {
                        "username": "julyakovleva1107",
                        "content": "Hi! Could somebody please explain - how come we have s = \"3\" in the test cases if there are such constraints:\\n1) s consists of lowercase English letters, digits, AND square brackets \\'[]\\'.\\n2) s is guaranteed to be a valid input.\\n\\uD83E\\uDD14\\n"
                    },
                    {
                        "username": "Miryafa",
                        "content": "Well you're right - every number should be followed by brackets. The description specifically says \"there will not be input like 3a or 2[4]\", and '3' is an input like '2[4]', because if 3 is valid then 2[3] is too, so 2[4] must be too.\n\nAnd there's no input to the encoding function that can result in an encoded string of '3', so that's what I'd call an invalid test case that only avoids causing an error if you write your program the same way the author did."
                    },
                    {
                        "username": "cloudycandy",
                        "content": "Today I saw some people were asked the encoding as a follow up for leetcode #394 decode string. Most of the them only gave a brief direction during the interview and didn't write any code. But I would like to ask for more thoughts.\\n\\nI may think about using dynamic programming. For string s, the shortest encoding from the i<sup>th</sup> character to the j<sup>th</sup> character is denoted by dp[i][j], then we have:\\n* If i+2 > j, dp[i][j] = s[i-1:j ], i.e. just keep those characters.\\n* else If s[i-1:j ] can be represented as repeating patterns, then encode it as repeating_times[repeating_pattern], using the finest repeating pattern.\\n* otherwise dp[i][j] = min_length(dp[i][k] + dp[k+1][j]) where i < k < j\\n\\nIt runs in O(n<sup>3</sup>) time however, where n is the length of the string to be encoded.\\nDoes this work? What do you think about it?"
                    },
                    {
                        "username": "madfcat",
                        "content": "Does even the test case 34\\n\\ns = \"3\"\\n\\nmake sense?\\n\\nIt is said that \"s is guaranteed to be a valid input\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is \"3\" a testcase? My code passed all testcases but when I used \"3\" as a testcase directly, LeetCode came back with \"Invalid input\". Just as well. Had my code tried to run it, it would have pushed past the \"[\" (which in this case is actually the ASCII NULL character) and caused a segmentation fault;"
                    },
                    {
                        "username": "eLementarydew",
                        "content": "This was definitely a tricky test case . I think they were expecting what if there is nothing to decode . Any number followed by an empty string is still an empty string. Still a weird test case because of the question language."
                    },
                    {
                        "username": "ILoveBigBits",
                        "content": "Time complexity cannot depend only on the length of the input string.\\n**Time Complexity is also a function of the numbers that are represented inside the string**,\\n\\nSince **we are also appending characters to our final answer string**, consider this,\\n\\n\\n100[a101[b102[c]]]\\n\\n\\nHere the length of the string is 18, but in the final string we need to append approximately10^6 times.\\n\\n\\nGeneral Proof, \\n\\nLets consider an input of Length N\\nLet N\\' = N+1\\nconsider the string\\n**N[aN\\'[b]]**\\n\\n\\nHere we require atleast **N^2**, operations to append a and b to final string.\\n\\nA very bad upperbound is **O(N * ProductofAllNumbers * MaxDepthofRecursionTree)**\\n\\nIf someone has a better upper bound, or something is wrong with the above analysis please share!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Leetcode describes this as an invalid testcase - probably because the decoded string is longer than 10^5 characters."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/decode-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Using 2 Stack\n\n  \n**Approach 3:** Using Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dlrudqhr7180",
                        "content": " I think test case 34 is invalid input (s = 3) while the problem indicates that \"s is guaranteed to be a valid input.\""
                    }
                ]
            },
            {
                "id": 1817631,
                "content": [
                    {
                        "username": "daily_coder",
                        "content": "Many times I solve some problem and after few hours/days I find amazed of myself that how did I even solved/coded this complex problem earlier!! Had this feeling? Please tell me, so that I can feel no alien."
                    },
                    {
                        "username": "an5dy90",
                        "content": "many times I forgot how I solved complex problems like this days months later and I needed to solve it again  "
                    },
                    {
                        "username": "aruuu____",
                        "content": "yeah same :)\\n"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "Yeah me too. Though I am beginner, I sometimes solve complex problems and after few days, I am amazed how did I solved."
                    },
                    {
                        "username": "Paleoanthropologist",
                        "content": "This is because you did not think through everything when you solved the problem initially. This happens a lot due to you have been band-aiding your code iteratively to achieve AC. "
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "at least you can solve it man"
                    },
                    {
                        "username": "Ranjan2002",
                        "content": "Ya  totally XD"
                    },
                    {
                        "username": "sahilbest999",
                        "content": "totally bro"
                    },
                    {
                        "username": "dengning1205",
                        "content": "Seems to be a lot harder than decode"
                    },
                    {
                        "username": "pbindal",
                        "content": "This is categorized under graph and trees. Looks like stacks and backtracking algo to me. Please correct if I am wrong"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1e9c82ea-4ff3-430b-a686-1be8a3e647f5_1642613017.35797.png)\\n\\n![image](https://assets.leetcode.com/users/images/5eee0955-2597-4439-8c87-8e0df45e461e_1642613023.443171.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d7645d9-4ef3-4875-810a-297d2f82a81a_1642613028.1248252.png)\\n\\n![image](https://assets.leetcode.com/users/images/5cec2dfd-2ec1-4ab6-9d9b-9a9b5f8e8d44_1642613031.8151512.png)\\n\\n![image](https://assets.leetcode.com/users/images/85c375af-7ac1-4006-b1f6-03da63b1d84a_1642613037.3188505.png)\\n\\n![image](https://assets.leetcode.com/users/images/42f7256e-f408-4c85-88f1-a029a32e7e4c_1642613048.1025255.png)\\n"
                    },
                    {
                        "username": "julyakovleva1107",
                        "content": "Hi! Could somebody please explain - how come we have s = \"3\" in the test cases if there are such constraints:\\n1) s consists of lowercase English letters, digits, AND square brackets \\'[]\\'.\\n2) s is guaranteed to be a valid input.\\n\\uD83E\\uDD14\\n"
                    },
                    {
                        "username": "Miryafa",
                        "content": "Well you're right - every number should be followed by brackets. The description specifically says \"there will not be input like 3a or 2[4]\", and '3' is an input like '2[4]', because if 3 is valid then 2[3] is too, so 2[4] must be too.\n\nAnd there's no input to the encoding function that can result in an encoded string of '3', so that's what I'd call an invalid test case that only avoids causing an error if you write your program the same way the author did."
                    },
                    {
                        "username": "cloudycandy",
                        "content": "Today I saw some people were asked the encoding as a follow up for leetcode #394 decode string. Most of the them only gave a brief direction during the interview and didn't write any code. But I would like to ask for more thoughts.\\n\\nI may think about using dynamic programming. For string s, the shortest encoding from the i<sup>th</sup> character to the j<sup>th</sup> character is denoted by dp[i][j], then we have:\\n* If i+2 > j, dp[i][j] = s[i-1:j ], i.e. just keep those characters.\\n* else If s[i-1:j ] can be represented as repeating patterns, then encode it as repeating_times[repeating_pattern], using the finest repeating pattern.\\n* otherwise dp[i][j] = min_length(dp[i][k] + dp[k+1][j]) where i < k < j\\n\\nIt runs in O(n<sup>3</sup>) time however, where n is the length of the string to be encoded.\\nDoes this work? What do you think about it?"
                    },
                    {
                        "username": "madfcat",
                        "content": "Does even the test case 34\\n\\ns = \"3\"\\n\\nmake sense?\\n\\nIt is said that \"s is guaranteed to be a valid input\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is \"3\" a testcase? My code passed all testcases but when I used \"3\" as a testcase directly, LeetCode came back with \"Invalid input\". Just as well. Had my code tried to run it, it would have pushed past the \"[\" (which in this case is actually the ASCII NULL character) and caused a segmentation fault;"
                    },
                    {
                        "username": "eLementarydew",
                        "content": "This was definitely a tricky test case . I think they were expecting what if there is nothing to decode . Any number followed by an empty string is still an empty string. Still a weird test case because of the question language."
                    },
                    {
                        "username": "ILoveBigBits",
                        "content": "Time complexity cannot depend only on the length of the input string.\\n**Time Complexity is also a function of the numbers that are represented inside the string**,\\n\\nSince **we are also appending characters to our final answer string**, consider this,\\n\\n\\n100[a101[b102[c]]]\\n\\n\\nHere the length of the string is 18, but in the final string we need to append approximately10^6 times.\\n\\n\\nGeneral Proof, \\n\\nLets consider an input of Length N\\nLet N\\' = N+1\\nconsider the string\\n**N[aN\\'[b]]**\\n\\n\\nHere we require atleast **N^2**, operations to append a and b to final string.\\n\\nA very bad upperbound is **O(N * ProductofAllNumbers * MaxDepthofRecursionTree)**\\n\\nIf someone has a better upper bound, or something is wrong with the above analysis please share!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Leetcode describes this as an invalid testcase - probably because the decoded string is longer than 10^5 characters."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/decode-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Using 2 Stack\n\n  \n**Approach 3:** Using Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dlrudqhr7180",
                        "content": " I think test case 34 is invalid input (s = 3) while the problem indicates that \"s is guaranteed to be a valid input.\""
                    }
                ]
            },
            {
                "id": 1566929,
                "content": [
                    {
                        "username": "daily_coder",
                        "content": "Many times I solve some problem and after few hours/days I find amazed of myself that how did I even solved/coded this complex problem earlier!! Had this feeling? Please tell me, so that I can feel no alien."
                    },
                    {
                        "username": "an5dy90",
                        "content": "many times I forgot how I solved complex problems like this days months later and I needed to solve it again  "
                    },
                    {
                        "username": "aruuu____",
                        "content": "yeah same :)\\n"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "Yeah me too. Though I am beginner, I sometimes solve complex problems and after few days, I am amazed how did I solved."
                    },
                    {
                        "username": "Paleoanthropologist",
                        "content": "This is because you did not think through everything when you solved the problem initially. This happens a lot due to you have been band-aiding your code iteratively to achieve AC. "
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "at least you can solve it man"
                    },
                    {
                        "username": "Ranjan2002",
                        "content": "Ya  totally XD"
                    },
                    {
                        "username": "sahilbest999",
                        "content": "totally bro"
                    },
                    {
                        "username": "dengning1205",
                        "content": "Seems to be a lot harder than decode"
                    },
                    {
                        "username": "pbindal",
                        "content": "This is categorized under graph and trees. Looks like stacks and backtracking algo to me. Please correct if I am wrong"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1e9c82ea-4ff3-430b-a686-1be8a3e647f5_1642613017.35797.png)\\n\\n![image](https://assets.leetcode.com/users/images/5eee0955-2597-4439-8c87-8e0df45e461e_1642613023.443171.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d7645d9-4ef3-4875-810a-297d2f82a81a_1642613028.1248252.png)\\n\\n![image](https://assets.leetcode.com/users/images/5cec2dfd-2ec1-4ab6-9d9b-9a9b5f8e8d44_1642613031.8151512.png)\\n\\n![image](https://assets.leetcode.com/users/images/85c375af-7ac1-4006-b1f6-03da63b1d84a_1642613037.3188505.png)\\n\\n![image](https://assets.leetcode.com/users/images/42f7256e-f408-4c85-88f1-a029a32e7e4c_1642613048.1025255.png)\\n"
                    },
                    {
                        "username": "julyakovleva1107",
                        "content": "Hi! Could somebody please explain - how come we have s = \"3\" in the test cases if there are such constraints:\\n1) s consists of lowercase English letters, digits, AND square brackets \\'[]\\'.\\n2) s is guaranteed to be a valid input.\\n\\uD83E\\uDD14\\n"
                    },
                    {
                        "username": "Miryafa",
                        "content": "Well you're right - every number should be followed by brackets. The description specifically says \"there will not be input like 3a or 2[4]\", and '3' is an input like '2[4]', because if 3 is valid then 2[3] is too, so 2[4] must be too.\n\nAnd there's no input to the encoding function that can result in an encoded string of '3', so that's what I'd call an invalid test case that only avoids causing an error if you write your program the same way the author did."
                    },
                    {
                        "username": "cloudycandy",
                        "content": "Today I saw some people were asked the encoding as a follow up for leetcode #394 decode string. Most of the them only gave a brief direction during the interview and didn't write any code. But I would like to ask for more thoughts.\\n\\nI may think about using dynamic programming. For string s, the shortest encoding from the i<sup>th</sup> character to the j<sup>th</sup> character is denoted by dp[i][j], then we have:\\n* If i+2 > j, dp[i][j] = s[i-1:j ], i.e. just keep those characters.\\n* else If s[i-1:j ] can be represented as repeating patterns, then encode it as repeating_times[repeating_pattern], using the finest repeating pattern.\\n* otherwise dp[i][j] = min_length(dp[i][k] + dp[k+1][j]) where i < k < j\\n\\nIt runs in O(n<sup>3</sup>) time however, where n is the length of the string to be encoded.\\nDoes this work? What do you think about it?"
                    },
                    {
                        "username": "madfcat",
                        "content": "Does even the test case 34\\n\\ns = \"3\"\\n\\nmake sense?\\n\\nIt is said that \"s is guaranteed to be a valid input\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is \"3\" a testcase? My code passed all testcases but when I used \"3\" as a testcase directly, LeetCode came back with \"Invalid input\". Just as well. Had my code tried to run it, it would have pushed past the \"[\" (which in this case is actually the ASCII NULL character) and caused a segmentation fault;"
                    },
                    {
                        "username": "eLementarydew",
                        "content": "This was definitely a tricky test case . I think they were expecting what if there is nothing to decode . Any number followed by an empty string is still an empty string. Still a weird test case because of the question language."
                    },
                    {
                        "username": "ILoveBigBits",
                        "content": "Time complexity cannot depend only on the length of the input string.\\n**Time Complexity is also a function of the numbers that are represented inside the string**,\\n\\nSince **we are also appending characters to our final answer string**, consider this,\\n\\n\\n100[a101[b102[c]]]\\n\\n\\nHere the length of the string is 18, but in the final string we need to append approximately10^6 times.\\n\\n\\nGeneral Proof, \\n\\nLets consider an input of Length N\\nLet N\\' = N+1\\nconsider the string\\n**N[aN\\'[b]]**\\n\\n\\nHere we require atleast **N^2**, operations to append a and b to final string.\\n\\nA very bad upperbound is **O(N * ProductofAllNumbers * MaxDepthofRecursionTree)**\\n\\nIf someone has a better upper bound, or something is wrong with the above analysis please share!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Leetcode describes this as an invalid testcase - probably because the decoded string is longer than 10^5 characters."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/decode-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Using 2 Stack\n\n  \n**Approach 3:** Using Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dlrudqhr7180",
                        "content": " I think test case 34 is invalid input (s = 3) while the problem indicates that \"s is guaranteed to be a valid input.\""
                    }
                ]
            },
            {
                "id": 1565722,
                "content": [
                    {
                        "username": "daily_coder",
                        "content": "Many times I solve some problem and after few hours/days I find amazed of myself that how did I even solved/coded this complex problem earlier!! Had this feeling? Please tell me, so that I can feel no alien."
                    },
                    {
                        "username": "an5dy90",
                        "content": "many times I forgot how I solved complex problems like this days months later and I needed to solve it again  "
                    },
                    {
                        "username": "aruuu____",
                        "content": "yeah same :)\\n"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "Yeah me too. Though I am beginner, I sometimes solve complex problems and after few days, I am amazed how did I solved."
                    },
                    {
                        "username": "Paleoanthropologist",
                        "content": "This is because you did not think through everything when you solved the problem initially. This happens a lot due to you have been band-aiding your code iteratively to achieve AC. "
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "at least you can solve it man"
                    },
                    {
                        "username": "Ranjan2002",
                        "content": "Ya  totally XD"
                    },
                    {
                        "username": "sahilbest999",
                        "content": "totally bro"
                    },
                    {
                        "username": "dengning1205",
                        "content": "Seems to be a lot harder than decode"
                    },
                    {
                        "username": "pbindal",
                        "content": "This is categorized under graph and trees. Looks like stacks and backtracking algo to me. Please correct if I am wrong"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1e9c82ea-4ff3-430b-a686-1be8a3e647f5_1642613017.35797.png)\\n\\n![image](https://assets.leetcode.com/users/images/5eee0955-2597-4439-8c87-8e0df45e461e_1642613023.443171.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d7645d9-4ef3-4875-810a-297d2f82a81a_1642613028.1248252.png)\\n\\n![image](https://assets.leetcode.com/users/images/5cec2dfd-2ec1-4ab6-9d9b-9a9b5f8e8d44_1642613031.8151512.png)\\n\\n![image](https://assets.leetcode.com/users/images/85c375af-7ac1-4006-b1f6-03da63b1d84a_1642613037.3188505.png)\\n\\n![image](https://assets.leetcode.com/users/images/42f7256e-f408-4c85-88f1-a029a32e7e4c_1642613048.1025255.png)\\n"
                    },
                    {
                        "username": "julyakovleva1107",
                        "content": "Hi! Could somebody please explain - how come we have s = \"3\" in the test cases if there are such constraints:\\n1) s consists of lowercase English letters, digits, AND square brackets \\'[]\\'.\\n2) s is guaranteed to be a valid input.\\n\\uD83E\\uDD14\\n"
                    },
                    {
                        "username": "Miryafa",
                        "content": "Well you're right - every number should be followed by brackets. The description specifically says \"there will not be input like 3a or 2[4]\", and '3' is an input like '2[4]', because if 3 is valid then 2[3] is too, so 2[4] must be too.\n\nAnd there's no input to the encoding function that can result in an encoded string of '3', so that's what I'd call an invalid test case that only avoids causing an error if you write your program the same way the author did."
                    },
                    {
                        "username": "cloudycandy",
                        "content": "Today I saw some people were asked the encoding as a follow up for leetcode #394 decode string. Most of the them only gave a brief direction during the interview and didn't write any code. But I would like to ask for more thoughts.\\n\\nI may think about using dynamic programming. For string s, the shortest encoding from the i<sup>th</sup> character to the j<sup>th</sup> character is denoted by dp[i][j], then we have:\\n* If i+2 > j, dp[i][j] = s[i-1:j ], i.e. just keep those characters.\\n* else If s[i-1:j ] can be represented as repeating patterns, then encode it as repeating_times[repeating_pattern], using the finest repeating pattern.\\n* otherwise dp[i][j] = min_length(dp[i][k] + dp[k+1][j]) where i < k < j\\n\\nIt runs in O(n<sup>3</sup>) time however, where n is the length of the string to be encoded.\\nDoes this work? What do you think about it?"
                    },
                    {
                        "username": "madfcat",
                        "content": "Does even the test case 34\\n\\ns = \"3\"\\n\\nmake sense?\\n\\nIt is said that \"s is guaranteed to be a valid input\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is \"3\" a testcase? My code passed all testcases but when I used \"3\" as a testcase directly, LeetCode came back with \"Invalid input\". Just as well. Had my code tried to run it, it would have pushed past the \"[\" (which in this case is actually the ASCII NULL character) and caused a segmentation fault;"
                    },
                    {
                        "username": "eLementarydew",
                        "content": "This was definitely a tricky test case . I think they were expecting what if there is nothing to decode . Any number followed by an empty string is still an empty string. Still a weird test case because of the question language."
                    },
                    {
                        "username": "ILoveBigBits",
                        "content": "Time complexity cannot depend only on the length of the input string.\\n**Time Complexity is also a function of the numbers that are represented inside the string**,\\n\\nSince **we are also appending characters to our final answer string**, consider this,\\n\\n\\n100[a101[b102[c]]]\\n\\n\\nHere the length of the string is 18, but in the final string we need to append approximately10^6 times.\\n\\n\\nGeneral Proof, \\n\\nLets consider an input of Length N\\nLet N\\' = N+1\\nconsider the string\\n**N[aN\\'[b]]**\\n\\n\\nHere we require atleast **N^2**, operations to append a and b to final string.\\n\\nA very bad upperbound is **O(N * ProductofAllNumbers * MaxDepthofRecursionTree)**\\n\\nIf someone has a better upper bound, or something is wrong with the above analysis please share!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Leetcode describes this as an invalid testcase - probably because the decoded string is longer than 10^5 characters."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/decode-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Using 2 Stack\n\n  \n**Approach 3:** Using Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dlrudqhr7180",
                        "content": " I think test case 34 is invalid input (s = 3) while the problem indicates that \"s is guaranteed to be a valid input.\""
                    }
                ]
            },
            {
                "id": 1819647,
                "content": [
                    {
                        "username": "daily_coder",
                        "content": "Many times I solve some problem and after few hours/days I find amazed of myself that how did I even solved/coded this complex problem earlier!! Had this feeling? Please tell me, so that I can feel no alien."
                    },
                    {
                        "username": "an5dy90",
                        "content": "many times I forgot how I solved complex problems like this days months later and I needed to solve it again  "
                    },
                    {
                        "username": "aruuu____",
                        "content": "yeah same :)\\n"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "Yeah me too. Though I am beginner, I sometimes solve complex problems and after few days, I am amazed how did I solved."
                    },
                    {
                        "username": "Paleoanthropologist",
                        "content": "This is because you did not think through everything when you solved the problem initially. This happens a lot due to you have been band-aiding your code iteratively to achieve AC. "
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "at least you can solve it man"
                    },
                    {
                        "username": "Ranjan2002",
                        "content": "Ya  totally XD"
                    },
                    {
                        "username": "sahilbest999",
                        "content": "totally bro"
                    },
                    {
                        "username": "dengning1205",
                        "content": "Seems to be a lot harder than decode"
                    },
                    {
                        "username": "pbindal",
                        "content": "This is categorized under graph and trees. Looks like stacks and backtracking algo to me. Please correct if I am wrong"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1e9c82ea-4ff3-430b-a686-1be8a3e647f5_1642613017.35797.png)\\n\\n![image](https://assets.leetcode.com/users/images/5eee0955-2597-4439-8c87-8e0df45e461e_1642613023.443171.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d7645d9-4ef3-4875-810a-297d2f82a81a_1642613028.1248252.png)\\n\\n![image](https://assets.leetcode.com/users/images/5cec2dfd-2ec1-4ab6-9d9b-9a9b5f8e8d44_1642613031.8151512.png)\\n\\n![image](https://assets.leetcode.com/users/images/85c375af-7ac1-4006-b1f6-03da63b1d84a_1642613037.3188505.png)\\n\\n![image](https://assets.leetcode.com/users/images/42f7256e-f408-4c85-88f1-a029a32e7e4c_1642613048.1025255.png)\\n"
                    },
                    {
                        "username": "julyakovleva1107",
                        "content": "Hi! Could somebody please explain - how come we have s = \"3\" in the test cases if there are such constraints:\\n1) s consists of lowercase English letters, digits, AND square brackets \\'[]\\'.\\n2) s is guaranteed to be a valid input.\\n\\uD83E\\uDD14\\n"
                    },
                    {
                        "username": "Miryafa",
                        "content": "Well you're right - every number should be followed by brackets. The description specifically says \"there will not be input like 3a or 2[4]\", and '3' is an input like '2[4]', because if 3 is valid then 2[3] is too, so 2[4] must be too.\n\nAnd there's no input to the encoding function that can result in an encoded string of '3', so that's what I'd call an invalid test case that only avoids causing an error if you write your program the same way the author did."
                    },
                    {
                        "username": "cloudycandy",
                        "content": "Today I saw some people were asked the encoding as a follow up for leetcode #394 decode string. Most of the them only gave a brief direction during the interview and didn't write any code. But I would like to ask for more thoughts.\\n\\nI may think about using dynamic programming. For string s, the shortest encoding from the i<sup>th</sup> character to the j<sup>th</sup> character is denoted by dp[i][j], then we have:\\n* If i+2 > j, dp[i][j] = s[i-1:j ], i.e. just keep those characters.\\n* else If s[i-1:j ] can be represented as repeating patterns, then encode it as repeating_times[repeating_pattern], using the finest repeating pattern.\\n* otherwise dp[i][j] = min_length(dp[i][k] + dp[k+1][j]) where i < k < j\\n\\nIt runs in O(n<sup>3</sup>) time however, where n is the length of the string to be encoded.\\nDoes this work? What do you think about it?"
                    },
                    {
                        "username": "madfcat",
                        "content": "Does even the test case 34\\n\\ns = \"3\"\\n\\nmake sense?\\n\\nIt is said that \"s is guaranteed to be a valid input\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is \"3\" a testcase? My code passed all testcases but when I used \"3\" as a testcase directly, LeetCode came back with \"Invalid input\". Just as well. Had my code tried to run it, it would have pushed past the \"[\" (which in this case is actually the ASCII NULL character) and caused a segmentation fault;"
                    },
                    {
                        "username": "eLementarydew",
                        "content": "This was definitely a tricky test case . I think they were expecting what if there is nothing to decode . Any number followed by an empty string is still an empty string. Still a weird test case because of the question language."
                    },
                    {
                        "username": "ILoveBigBits",
                        "content": "Time complexity cannot depend only on the length of the input string.\\n**Time Complexity is also a function of the numbers that are represented inside the string**,\\n\\nSince **we are also appending characters to our final answer string**, consider this,\\n\\n\\n100[a101[b102[c]]]\\n\\n\\nHere the length of the string is 18, but in the final string we need to append approximately10^6 times.\\n\\n\\nGeneral Proof, \\n\\nLets consider an input of Length N\\nLet N\\' = N+1\\nconsider the string\\n**N[aN\\'[b]]**\\n\\n\\nHere we require atleast **N^2**, operations to append a and b to final string.\\n\\nA very bad upperbound is **O(N * ProductofAllNumbers * MaxDepthofRecursionTree)**\\n\\nIf someone has a better upper bound, or something is wrong with the above analysis please share!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Leetcode describes this as an invalid testcase - probably because the decoded string is longer than 10^5 characters."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/decode-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Using 2 Stack\n\n  \n**Approach 3:** Using Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dlrudqhr7180",
                        "content": " I think test case 34 is invalid input (s = 3) while the problem indicates that \"s is guaranteed to be a valid input.\""
                    }
                ]
            },
            {
                "id": 1814231,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\n1.If the character is a closing square bracket ']', we pop characters off the stack until we find the corresponding opening square bracket '['. We then pop the opening bracket, the number before it (which specifies how many times the substring inside the brackets should be repeated), and the characters we just popped off the stack. We repeat this process until we have processed the entire string.\n\n2.Otherwise, if the character is not a closing square bracket ']', we push it onto the stack."
                    },
                    {
                        "username": "xaviesta",
                        "content": "Check the following test-case: `99[99[99[99[99[99[a]]]]]]`\\nIt follows the constraints but has a huge output that is not possible to execute. I guess the constraints in the question need to revisited or it should be mentioned that test cases are such that output won\\'t exceed a certain length like 10^6."
                    },
                    {
                        "username": "David_E_something",
                        "content": "Requirement states: The test cases are generated so that the length of the output will never exceed 10^5."
                    },
                    {
                        "username": "alexNotusDev",
                        "content": "Simple advise! We adding each char to stack till we get  `]`, in this case, we can start decoding by taking last values from stack, process them (crate string, and multiply to integer) and push back into stack, hope it will help you to find right direction."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Similar to Problem No 1190.\\nReverse Substrings Between Each Pair of Parentheses\\nDo this problem first ."
                    },
                    {
                        "username": "deleted_user",
                        "content": "https://github.com/saquib-ahsan/leetcode/blob/main/all-problems/394-Decode-String.cpp"
                    },
                    {
                        "username": "sha256pki",
                        "content": "Just wondering, a string processing plus so many corner cases to consider."
                    },
                    {
                        "username": "BristolJ",
                        "content": "If these are medium, I don\\'t want to see Hard"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "try this if you are having any issue \\nhttps://www.youtube.com/watch?v=qB0zZpBJlh8"
                    },
                    {
                        "username": "anvuong",
                        "content": "what is the constraint on k?"
                    },
                    {
                        "username": "subhamjaiswal_mnit",
                        "content": "stack<int>num;\\n      stack<char>str;\\n      string ans;\\n      int i=0;\\n      while(i<s.length()){\\n          if(s[i]-\\'0\\'>=0&&s[i]-\\'0\\'<=9){\\n              num.push(s[i]-\\'0\\');\\n          }\\n          else if(s[i]==\\'[\\'){// means we got the opening bracket\\n              int j=i;\\n              while(s[j]!=\\']\\'){// meanswe are not getting anyclose bracket\\n           if(s[j]-\\'0\\'>=0&&s[j]-\\'0\\'<=9){\\n              num.push(s[j]-\\'0\\');\\n              }\\n              else{\\n                 str.push(s[j]); \\n              }\\n              j++;\\n          }\\n             i=j;\\n          }\\n             else{\\n        if(s[i]==\\']\\'){\\n            while(str.top()!=\\'[\\'&&!str.empty()){\\n                ans.push_back(str.top());\\n                str.pop();\\n            }\\n            if(!num.empty()){\\n           int k =num.top();\\n           num.pop();\\n           int m=0;\\n           while(m<k){\\n               ans=ans+ans;\\n               m++;\\n           }\\n        }\\n        }\\n      }\\n      i++; \\n      }\\n      reverse(ans.begin(),ans.end());\\n      return ans; \\n    }\\n};\\n// can u please tell me the error\\n"
                    }
                ]
            },
            {
                "id": 1576447,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\n1.If the character is a closing square bracket ']', we pop characters off the stack until we find the corresponding opening square bracket '['. We then pop the opening bracket, the number before it (which specifies how many times the substring inside the brackets should be repeated), and the characters we just popped off the stack. We repeat this process until we have processed the entire string.\n\n2.Otherwise, if the character is not a closing square bracket ']', we push it onto the stack."
                    },
                    {
                        "username": "xaviesta",
                        "content": "Check the following test-case: `99[99[99[99[99[99[a]]]]]]`\\nIt follows the constraints but has a huge output that is not possible to execute. I guess the constraints in the question need to revisited or it should be mentioned that test cases are such that output won\\'t exceed a certain length like 10^6."
                    },
                    {
                        "username": "David_E_something",
                        "content": "Requirement states: The test cases are generated so that the length of the output will never exceed 10^5."
                    },
                    {
                        "username": "alexNotusDev",
                        "content": "Simple advise! We adding each char to stack till we get  `]`, in this case, we can start decoding by taking last values from stack, process them (crate string, and multiply to integer) and push back into stack, hope it will help you to find right direction."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Similar to Problem No 1190.\\nReverse Substrings Between Each Pair of Parentheses\\nDo this problem first ."
                    },
                    {
                        "username": "deleted_user",
                        "content": "https://github.com/saquib-ahsan/leetcode/blob/main/all-problems/394-Decode-String.cpp"
                    },
                    {
                        "username": "sha256pki",
                        "content": "Just wondering, a string processing plus so many corner cases to consider."
                    },
                    {
                        "username": "BristolJ",
                        "content": "If these are medium, I don\\'t want to see Hard"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "try this if you are having any issue \\nhttps://www.youtube.com/watch?v=qB0zZpBJlh8"
                    },
                    {
                        "username": "anvuong",
                        "content": "what is the constraint on k?"
                    },
                    {
                        "username": "subhamjaiswal_mnit",
                        "content": "stack<int>num;\\n      stack<char>str;\\n      string ans;\\n      int i=0;\\n      while(i<s.length()){\\n          if(s[i]-\\'0\\'>=0&&s[i]-\\'0\\'<=9){\\n              num.push(s[i]-\\'0\\');\\n          }\\n          else if(s[i]==\\'[\\'){// means we got the opening bracket\\n              int j=i;\\n              while(s[j]!=\\']\\'){// meanswe are not getting anyclose bracket\\n           if(s[j]-\\'0\\'>=0&&s[j]-\\'0\\'<=9){\\n              num.push(s[j]-\\'0\\');\\n              }\\n              else{\\n                 str.push(s[j]); \\n              }\\n              j++;\\n          }\\n             i=j;\\n          }\\n             else{\\n        if(s[i]==\\']\\'){\\n            while(str.top()!=\\'[\\'&&!str.empty()){\\n                ans.push_back(str.top());\\n                str.pop();\\n            }\\n            if(!num.empty()){\\n           int k =num.top();\\n           num.pop();\\n           int m=0;\\n           while(m<k){\\n               ans=ans+ans;\\n               m++;\\n           }\\n        }\\n        }\\n      }\\n      i++; \\n      }\\n      reverse(ans.begin(),ans.end());\\n      return ans; \\n    }\\n};\\n// can u please tell me the error\\n"
                    }
                ]
            },
            {
                "id": 2010793,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\n1.If the character is a closing square bracket ']', we pop characters off the stack until we find the corresponding opening square bracket '['. We then pop the opening bracket, the number before it (which specifies how many times the substring inside the brackets should be repeated), and the characters we just popped off the stack. We repeat this process until we have processed the entire string.\n\n2.Otherwise, if the character is not a closing square bracket ']', we push it onto the stack."
                    },
                    {
                        "username": "xaviesta",
                        "content": "Check the following test-case: `99[99[99[99[99[99[a]]]]]]`\\nIt follows the constraints but has a huge output that is not possible to execute. I guess the constraints in the question need to revisited or it should be mentioned that test cases are such that output won\\'t exceed a certain length like 10^6."
                    },
                    {
                        "username": "David_E_something",
                        "content": "Requirement states: The test cases are generated so that the length of the output will never exceed 10^5."
                    },
                    {
                        "username": "alexNotusDev",
                        "content": "Simple advise! We adding each char to stack till we get  `]`, in this case, we can start decoding by taking last values from stack, process them (crate string, and multiply to integer) and push back into stack, hope it will help you to find right direction."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Similar to Problem No 1190.\\nReverse Substrings Between Each Pair of Parentheses\\nDo this problem first ."
                    },
                    {
                        "username": "deleted_user",
                        "content": "https://github.com/saquib-ahsan/leetcode/blob/main/all-problems/394-Decode-String.cpp"
                    },
                    {
                        "username": "sha256pki",
                        "content": "Just wondering, a string processing plus so many corner cases to consider."
                    },
                    {
                        "username": "BristolJ",
                        "content": "If these are medium, I don\\'t want to see Hard"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "try this if you are having any issue \\nhttps://www.youtube.com/watch?v=qB0zZpBJlh8"
                    },
                    {
                        "username": "anvuong",
                        "content": "what is the constraint on k?"
                    },
                    {
                        "username": "subhamjaiswal_mnit",
                        "content": "stack<int>num;\\n      stack<char>str;\\n      string ans;\\n      int i=0;\\n      while(i<s.length()){\\n          if(s[i]-\\'0\\'>=0&&s[i]-\\'0\\'<=9){\\n              num.push(s[i]-\\'0\\');\\n          }\\n          else if(s[i]==\\'[\\'){// means we got the opening bracket\\n              int j=i;\\n              while(s[j]!=\\']\\'){// meanswe are not getting anyclose bracket\\n           if(s[j]-\\'0\\'>=0&&s[j]-\\'0\\'<=9){\\n              num.push(s[j]-\\'0\\');\\n              }\\n              else{\\n                 str.push(s[j]); \\n              }\\n              j++;\\n          }\\n             i=j;\\n          }\\n             else{\\n        if(s[i]==\\']\\'){\\n            while(str.top()!=\\'[\\'&&!str.empty()){\\n                ans.push_back(str.top());\\n                str.pop();\\n            }\\n            if(!num.empty()){\\n           int k =num.top();\\n           num.pop();\\n           int m=0;\\n           while(m<k){\\n               ans=ans+ans;\\n               m++;\\n           }\\n        }\\n        }\\n      }\\n      i++; \\n      }\\n      reverse(ans.begin(),ans.end());\\n      return ans; \\n    }\\n};\\n// can u please tell me the error\\n"
                    }
                ]
            },
            {
                "id": 1828835,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\n1.If the character is a closing square bracket ']', we pop characters off the stack until we find the corresponding opening square bracket '['. We then pop the opening bracket, the number before it (which specifies how many times the substring inside the brackets should be repeated), and the characters we just popped off the stack. We repeat this process until we have processed the entire string.\n\n2.Otherwise, if the character is not a closing square bracket ']', we push it onto the stack."
                    },
                    {
                        "username": "xaviesta",
                        "content": "Check the following test-case: `99[99[99[99[99[99[a]]]]]]`\\nIt follows the constraints but has a huge output that is not possible to execute. I guess the constraints in the question need to revisited or it should be mentioned that test cases are such that output won\\'t exceed a certain length like 10^6."
                    },
                    {
                        "username": "David_E_something",
                        "content": "Requirement states: The test cases are generated so that the length of the output will never exceed 10^5."
                    },
                    {
                        "username": "alexNotusDev",
                        "content": "Simple advise! We adding each char to stack till we get  `]`, in this case, we can start decoding by taking last values from stack, process them (crate string, and multiply to integer) and push back into stack, hope it will help you to find right direction."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Similar to Problem No 1190.\\nReverse Substrings Between Each Pair of Parentheses\\nDo this problem first ."
                    },
                    {
                        "username": "deleted_user",
                        "content": "https://github.com/saquib-ahsan/leetcode/blob/main/all-problems/394-Decode-String.cpp"
                    },
                    {
                        "username": "sha256pki",
                        "content": "Just wondering, a string processing plus so many corner cases to consider."
                    },
                    {
                        "username": "BristolJ",
                        "content": "If these are medium, I don\\'t want to see Hard"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "try this if you are having any issue \\nhttps://www.youtube.com/watch?v=qB0zZpBJlh8"
                    },
                    {
                        "username": "anvuong",
                        "content": "what is the constraint on k?"
                    },
                    {
                        "username": "subhamjaiswal_mnit",
                        "content": "stack<int>num;\\n      stack<char>str;\\n      string ans;\\n      int i=0;\\n      while(i<s.length()){\\n          if(s[i]-\\'0\\'>=0&&s[i]-\\'0\\'<=9){\\n              num.push(s[i]-\\'0\\');\\n          }\\n          else if(s[i]==\\'[\\'){// means we got the opening bracket\\n              int j=i;\\n              while(s[j]!=\\']\\'){// meanswe are not getting anyclose bracket\\n           if(s[j]-\\'0\\'>=0&&s[j]-\\'0\\'<=9){\\n              num.push(s[j]-\\'0\\');\\n              }\\n              else{\\n                 str.push(s[j]); \\n              }\\n              j++;\\n          }\\n             i=j;\\n          }\\n             else{\\n        if(s[i]==\\']\\'){\\n            while(str.top()!=\\'[\\'&&!str.empty()){\\n                ans.push_back(str.top());\\n                str.pop();\\n            }\\n            if(!num.empty()){\\n           int k =num.top();\\n           num.pop();\\n           int m=0;\\n           while(m<k){\\n               ans=ans+ans;\\n               m++;\\n           }\\n        }\\n        }\\n      }\\n      i++; \\n      }\\n      reverse(ans.begin(),ans.end());\\n      return ans; \\n    }\\n};\\n// can u please tell me the error\\n"
                    }
                ]
            },
            {
                "id": 1576720,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\n1.If the character is a closing square bracket ']', we pop characters off the stack until we find the corresponding opening square bracket '['. We then pop the opening bracket, the number before it (which specifies how many times the substring inside the brackets should be repeated), and the characters we just popped off the stack. We repeat this process until we have processed the entire string.\n\n2.Otherwise, if the character is not a closing square bracket ']', we push it onto the stack."
                    },
                    {
                        "username": "xaviesta",
                        "content": "Check the following test-case: `99[99[99[99[99[99[a]]]]]]`\\nIt follows the constraints but has a huge output that is not possible to execute. I guess the constraints in the question need to revisited or it should be mentioned that test cases are such that output won\\'t exceed a certain length like 10^6."
                    },
                    {
                        "username": "David_E_something",
                        "content": "Requirement states: The test cases are generated so that the length of the output will never exceed 10^5."
                    },
                    {
                        "username": "alexNotusDev",
                        "content": "Simple advise! We adding each char to stack till we get  `]`, in this case, we can start decoding by taking last values from stack, process them (crate string, and multiply to integer) and push back into stack, hope it will help you to find right direction."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Similar to Problem No 1190.\\nReverse Substrings Between Each Pair of Parentheses\\nDo this problem first ."
                    },
                    {
                        "username": "deleted_user",
                        "content": "https://github.com/saquib-ahsan/leetcode/blob/main/all-problems/394-Decode-String.cpp"
                    },
                    {
                        "username": "sha256pki",
                        "content": "Just wondering, a string processing plus so many corner cases to consider."
                    },
                    {
                        "username": "BristolJ",
                        "content": "If these are medium, I don\\'t want to see Hard"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "try this if you are having any issue \\nhttps://www.youtube.com/watch?v=qB0zZpBJlh8"
                    },
                    {
                        "username": "anvuong",
                        "content": "what is the constraint on k?"
                    },
                    {
                        "username": "subhamjaiswal_mnit",
                        "content": "stack<int>num;\\n      stack<char>str;\\n      string ans;\\n      int i=0;\\n      while(i<s.length()){\\n          if(s[i]-\\'0\\'>=0&&s[i]-\\'0\\'<=9){\\n              num.push(s[i]-\\'0\\');\\n          }\\n          else if(s[i]==\\'[\\'){// means we got the opening bracket\\n              int j=i;\\n              while(s[j]!=\\']\\'){// meanswe are not getting anyclose bracket\\n           if(s[j]-\\'0\\'>=0&&s[j]-\\'0\\'<=9){\\n              num.push(s[j]-\\'0\\');\\n              }\\n              else{\\n                 str.push(s[j]); \\n              }\\n              j++;\\n          }\\n             i=j;\\n          }\\n             else{\\n        if(s[i]==\\']\\'){\\n            while(str.top()!=\\'[\\'&&!str.empty()){\\n                ans.push_back(str.top());\\n                str.pop();\\n            }\\n            if(!num.empty()){\\n           int k =num.top();\\n           num.pop();\\n           int m=0;\\n           while(m<k){\\n               ans=ans+ans;\\n               m++;\\n           }\\n        }\\n        }\\n      }\\n      i++; \\n      }\\n      reverse(ans.begin(),ans.end());\\n      return ans; \\n    }\\n};\\n// can u please tell me the error\\n"
                    }
                ]
            },
            {
                "id": 1571667,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\n1.If the character is a closing square bracket ']', we pop characters off the stack until we find the corresponding opening square bracket '['. We then pop the opening bracket, the number before it (which specifies how many times the substring inside the brackets should be repeated), and the characters we just popped off the stack. We repeat this process until we have processed the entire string.\n\n2.Otherwise, if the character is not a closing square bracket ']', we push it onto the stack."
                    },
                    {
                        "username": "xaviesta",
                        "content": "Check the following test-case: `99[99[99[99[99[99[a]]]]]]`\\nIt follows the constraints but has a huge output that is not possible to execute. I guess the constraints in the question need to revisited or it should be mentioned that test cases are such that output won\\'t exceed a certain length like 10^6."
                    },
                    {
                        "username": "David_E_something",
                        "content": "Requirement states: The test cases are generated so that the length of the output will never exceed 10^5."
                    },
                    {
                        "username": "alexNotusDev",
                        "content": "Simple advise! We adding each char to stack till we get  `]`, in this case, we can start decoding by taking last values from stack, process them (crate string, and multiply to integer) and push back into stack, hope it will help you to find right direction."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Similar to Problem No 1190.\\nReverse Substrings Between Each Pair of Parentheses\\nDo this problem first ."
                    },
                    {
                        "username": "deleted_user",
                        "content": "https://github.com/saquib-ahsan/leetcode/blob/main/all-problems/394-Decode-String.cpp"
                    },
                    {
                        "username": "sha256pki",
                        "content": "Just wondering, a string processing plus so many corner cases to consider."
                    },
                    {
                        "username": "BristolJ",
                        "content": "If these are medium, I don\\'t want to see Hard"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "try this if you are having any issue \\nhttps://www.youtube.com/watch?v=qB0zZpBJlh8"
                    },
                    {
                        "username": "anvuong",
                        "content": "what is the constraint on k?"
                    },
                    {
                        "username": "subhamjaiswal_mnit",
                        "content": "stack<int>num;\\n      stack<char>str;\\n      string ans;\\n      int i=0;\\n      while(i<s.length()){\\n          if(s[i]-\\'0\\'>=0&&s[i]-\\'0\\'<=9){\\n              num.push(s[i]-\\'0\\');\\n          }\\n          else if(s[i]==\\'[\\'){// means we got the opening bracket\\n              int j=i;\\n              while(s[j]!=\\']\\'){// meanswe are not getting anyclose bracket\\n           if(s[j]-\\'0\\'>=0&&s[j]-\\'0\\'<=9){\\n              num.push(s[j]-\\'0\\');\\n              }\\n              else{\\n                 str.push(s[j]); \\n              }\\n              j++;\\n          }\\n             i=j;\\n          }\\n             else{\\n        if(s[i]==\\']\\'){\\n            while(str.top()!=\\'[\\'&&!str.empty()){\\n                ans.push_back(str.top());\\n                str.pop();\\n            }\\n            if(!num.empty()){\\n           int k =num.top();\\n           num.pop();\\n           int m=0;\\n           while(m<k){\\n               ans=ans+ans;\\n               m++;\\n           }\\n        }\\n        }\\n      }\\n      i++; \\n      }\\n      reverse(ans.begin(),ans.end());\\n      return ans; \\n    }\\n};\\n// can u please tell me the error\\n"
                    }
                ]
            },
            {
                "id": 2075834,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\n1.If the character is a closing square bracket ']', we pop characters off the stack until we find the corresponding opening square bracket '['. We then pop the opening bracket, the number before it (which specifies how many times the substring inside the brackets should be repeated), and the characters we just popped off the stack. We repeat this process until we have processed the entire string.\n\n2.Otherwise, if the character is not a closing square bracket ']', we push it onto the stack."
                    },
                    {
                        "username": "xaviesta",
                        "content": "Check the following test-case: `99[99[99[99[99[99[a]]]]]]`\\nIt follows the constraints but has a huge output that is not possible to execute. I guess the constraints in the question need to revisited or it should be mentioned that test cases are such that output won\\'t exceed a certain length like 10^6."
                    },
                    {
                        "username": "David_E_something",
                        "content": "Requirement states: The test cases are generated so that the length of the output will never exceed 10^5."
                    },
                    {
                        "username": "alexNotusDev",
                        "content": "Simple advise! We adding each char to stack till we get  `]`, in this case, we can start decoding by taking last values from stack, process them (crate string, and multiply to integer) and push back into stack, hope it will help you to find right direction."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Similar to Problem No 1190.\\nReverse Substrings Between Each Pair of Parentheses\\nDo this problem first ."
                    },
                    {
                        "username": "deleted_user",
                        "content": "https://github.com/saquib-ahsan/leetcode/blob/main/all-problems/394-Decode-String.cpp"
                    },
                    {
                        "username": "sha256pki",
                        "content": "Just wondering, a string processing plus so many corner cases to consider."
                    },
                    {
                        "username": "BristolJ",
                        "content": "If these are medium, I don\\'t want to see Hard"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "try this if you are having any issue \\nhttps://www.youtube.com/watch?v=qB0zZpBJlh8"
                    },
                    {
                        "username": "anvuong",
                        "content": "what is the constraint on k?"
                    },
                    {
                        "username": "subhamjaiswal_mnit",
                        "content": "stack<int>num;\\n      stack<char>str;\\n      string ans;\\n      int i=0;\\n      while(i<s.length()){\\n          if(s[i]-\\'0\\'>=0&&s[i]-\\'0\\'<=9){\\n              num.push(s[i]-\\'0\\');\\n          }\\n          else if(s[i]==\\'[\\'){// means we got the opening bracket\\n              int j=i;\\n              while(s[j]!=\\']\\'){// meanswe are not getting anyclose bracket\\n           if(s[j]-\\'0\\'>=0&&s[j]-\\'0\\'<=9){\\n              num.push(s[j]-\\'0\\');\\n              }\\n              else{\\n                 str.push(s[j]); \\n              }\\n              j++;\\n          }\\n             i=j;\\n          }\\n             else{\\n        if(s[i]==\\']\\'){\\n            while(str.top()!=\\'[\\'&&!str.empty()){\\n                ans.push_back(str.top());\\n                str.pop();\\n            }\\n            if(!num.empty()){\\n           int k =num.top();\\n           num.pop();\\n           int m=0;\\n           while(m<k){\\n               ans=ans+ans;\\n               m++;\\n           }\\n        }\\n        }\\n      }\\n      i++; \\n      }\\n      reverse(ans.begin(),ans.end());\\n      return ans; \\n    }\\n};\\n// can u please tell me the error\\n"
                    }
                ]
            },
            {
                "id": 2060537,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\n1.If the character is a closing square bracket ']', we pop characters off the stack until we find the corresponding opening square bracket '['. We then pop the opening bracket, the number before it (which specifies how many times the substring inside the brackets should be repeated), and the characters we just popped off the stack. We repeat this process until we have processed the entire string.\n\n2.Otherwise, if the character is not a closing square bracket ']', we push it onto the stack."
                    },
                    {
                        "username": "xaviesta",
                        "content": "Check the following test-case: `99[99[99[99[99[99[a]]]]]]`\\nIt follows the constraints but has a huge output that is not possible to execute. I guess the constraints in the question need to revisited or it should be mentioned that test cases are such that output won\\'t exceed a certain length like 10^6."
                    },
                    {
                        "username": "David_E_something",
                        "content": "Requirement states: The test cases are generated so that the length of the output will never exceed 10^5."
                    },
                    {
                        "username": "alexNotusDev",
                        "content": "Simple advise! We adding each char to stack till we get  `]`, in this case, we can start decoding by taking last values from stack, process them (crate string, and multiply to integer) and push back into stack, hope it will help you to find right direction."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Similar to Problem No 1190.\\nReverse Substrings Between Each Pair of Parentheses\\nDo this problem first ."
                    },
                    {
                        "username": "deleted_user",
                        "content": "https://github.com/saquib-ahsan/leetcode/blob/main/all-problems/394-Decode-String.cpp"
                    },
                    {
                        "username": "sha256pki",
                        "content": "Just wondering, a string processing plus so many corner cases to consider."
                    },
                    {
                        "username": "BristolJ",
                        "content": "If these are medium, I don\\'t want to see Hard"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "try this if you are having any issue \\nhttps://www.youtube.com/watch?v=qB0zZpBJlh8"
                    },
                    {
                        "username": "anvuong",
                        "content": "what is the constraint on k?"
                    },
                    {
                        "username": "subhamjaiswal_mnit",
                        "content": "stack<int>num;\\n      stack<char>str;\\n      string ans;\\n      int i=0;\\n      while(i<s.length()){\\n          if(s[i]-\\'0\\'>=0&&s[i]-\\'0\\'<=9){\\n              num.push(s[i]-\\'0\\');\\n          }\\n          else if(s[i]==\\'[\\'){// means we got the opening bracket\\n              int j=i;\\n              while(s[j]!=\\']\\'){// meanswe are not getting anyclose bracket\\n           if(s[j]-\\'0\\'>=0&&s[j]-\\'0\\'<=9){\\n              num.push(s[j]-\\'0\\');\\n              }\\n              else{\\n                 str.push(s[j]); \\n              }\\n              j++;\\n          }\\n             i=j;\\n          }\\n             else{\\n        if(s[i]==\\']\\'){\\n            while(str.top()!=\\'[\\'&&!str.empty()){\\n                ans.push_back(str.top());\\n                str.pop();\\n            }\\n            if(!num.empty()){\\n           int k =num.top();\\n           num.pop();\\n           int m=0;\\n           while(m<k){\\n               ans=ans+ans;\\n               m++;\\n           }\\n        }\\n        }\\n      }\\n      i++; \\n      }\\n      reverse(ans.begin(),ans.end());\\n      return ans; \\n    }\\n};\\n// can u please tell me the error\\n"
                    }
                ]
            },
            {
                "id": 2056746,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\n1.If the character is a closing square bracket ']', we pop characters off the stack until we find the corresponding opening square bracket '['. We then pop the opening bracket, the number before it (which specifies how many times the substring inside the brackets should be repeated), and the characters we just popped off the stack. We repeat this process until we have processed the entire string.\n\n2.Otherwise, if the character is not a closing square bracket ']', we push it onto the stack."
                    },
                    {
                        "username": "xaviesta",
                        "content": "Check the following test-case: `99[99[99[99[99[99[a]]]]]]`\\nIt follows the constraints but has a huge output that is not possible to execute. I guess the constraints in the question need to revisited or it should be mentioned that test cases are such that output won\\'t exceed a certain length like 10^6."
                    },
                    {
                        "username": "David_E_something",
                        "content": "Requirement states: The test cases are generated so that the length of the output will never exceed 10^5."
                    },
                    {
                        "username": "alexNotusDev",
                        "content": "Simple advise! We adding each char to stack till we get  `]`, in this case, we can start decoding by taking last values from stack, process them (crate string, and multiply to integer) and push back into stack, hope it will help you to find right direction."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Similar to Problem No 1190.\\nReverse Substrings Between Each Pair of Parentheses\\nDo this problem first ."
                    },
                    {
                        "username": "deleted_user",
                        "content": "https://github.com/saquib-ahsan/leetcode/blob/main/all-problems/394-Decode-String.cpp"
                    },
                    {
                        "username": "sha256pki",
                        "content": "Just wondering, a string processing plus so many corner cases to consider."
                    },
                    {
                        "username": "BristolJ",
                        "content": "If these are medium, I don\\'t want to see Hard"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "try this if you are having any issue \\nhttps://www.youtube.com/watch?v=qB0zZpBJlh8"
                    },
                    {
                        "username": "anvuong",
                        "content": "what is the constraint on k?"
                    },
                    {
                        "username": "subhamjaiswal_mnit",
                        "content": "stack<int>num;\\n      stack<char>str;\\n      string ans;\\n      int i=0;\\n      while(i<s.length()){\\n          if(s[i]-\\'0\\'>=0&&s[i]-\\'0\\'<=9){\\n              num.push(s[i]-\\'0\\');\\n          }\\n          else if(s[i]==\\'[\\'){// means we got the opening bracket\\n              int j=i;\\n              while(s[j]!=\\']\\'){// meanswe are not getting anyclose bracket\\n           if(s[j]-\\'0\\'>=0&&s[j]-\\'0\\'<=9){\\n              num.push(s[j]-\\'0\\');\\n              }\\n              else{\\n                 str.push(s[j]); \\n              }\\n              j++;\\n          }\\n             i=j;\\n          }\\n             else{\\n        if(s[i]==\\']\\'){\\n            while(str.top()!=\\'[\\'&&!str.empty()){\\n                ans.push_back(str.top());\\n                str.pop();\\n            }\\n            if(!num.empty()){\\n           int k =num.top();\\n           num.pop();\\n           int m=0;\\n           while(m<k){\\n               ans=ans+ans;\\n               m++;\\n           }\\n        }\\n        }\\n      }\\n      i++; \\n      }\\n      reverse(ans.begin(),ans.end());\\n      return ans; \\n    }\\n};\\n// can u please tell me the error\\n"
                    }
                ]
            },
            {
                "id": 2037271,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\n1.If the character is a closing square bracket ']', we pop characters off the stack until we find the corresponding opening square bracket '['. We then pop the opening bracket, the number before it (which specifies how many times the substring inside the brackets should be repeated), and the characters we just popped off the stack. We repeat this process until we have processed the entire string.\n\n2.Otherwise, if the character is not a closing square bracket ']', we push it onto the stack."
                    },
                    {
                        "username": "xaviesta",
                        "content": "Check the following test-case: `99[99[99[99[99[99[a]]]]]]`\\nIt follows the constraints but has a huge output that is not possible to execute. I guess the constraints in the question need to revisited or it should be mentioned that test cases are such that output won\\'t exceed a certain length like 10^6."
                    },
                    {
                        "username": "David_E_something",
                        "content": "Requirement states: The test cases are generated so that the length of the output will never exceed 10^5."
                    },
                    {
                        "username": "alexNotusDev",
                        "content": "Simple advise! We adding each char to stack till we get  `]`, in this case, we can start decoding by taking last values from stack, process them (crate string, and multiply to integer) and push back into stack, hope it will help you to find right direction."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Similar to Problem No 1190.\\nReverse Substrings Between Each Pair of Parentheses\\nDo this problem first ."
                    },
                    {
                        "username": "deleted_user",
                        "content": "https://github.com/saquib-ahsan/leetcode/blob/main/all-problems/394-Decode-String.cpp"
                    },
                    {
                        "username": "sha256pki",
                        "content": "Just wondering, a string processing plus so many corner cases to consider."
                    },
                    {
                        "username": "BristolJ",
                        "content": "If these are medium, I don\\'t want to see Hard"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "try this if you are having any issue \\nhttps://www.youtube.com/watch?v=qB0zZpBJlh8"
                    },
                    {
                        "username": "anvuong",
                        "content": "what is the constraint on k?"
                    },
                    {
                        "username": "subhamjaiswal_mnit",
                        "content": "stack<int>num;\\n      stack<char>str;\\n      string ans;\\n      int i=0;\\n      while(i<s.length()){\\n          if(s[i]-\\'0\\'>=0&&s[i]-\\'0\\'<=9){\\n              num.push(s[i]-\\'0\\');\\n          }\\n          else if(s[i]==\\'[\\'){// means we got the opening bracket\\n              int j=i;\\n              while(s[j]!=\\']\\'){// meanswe are not getting anyclose bracket\\n           if(s[j]-\\'0\\'>=0&&s[j]-\\'0\\'<=9){\\n              num.push(s[j]-\\'0\\');\\n              }\\n              else{\\n                 str.push(s[j]); \\n              }\\n              j++;\\n          }\\n             i=j;\\n          }\\n             else{\\n        if(s[i]==\\']\\'){\\n            while(str.top()!=\\'[\\'&&!str.empty()){\\n                ans.push_back(str.top());\\n                str.pop();\\n            }\\n            if(!num.empty()){\\n           int k =num.top();\\n           num.pop();\\n           int m=0;\\n           while(m<k){\\n               ans=ans+ans;\\n               m++;\\n           }\\n        }\\n        }\\n      }\\n      i++; \\n      }\\n      reverse(ans.begin(),ans.end());\\n      return ans; \\n    }\\n};\\n// can u please tell me the error\\n"
                    }
                ]
            },
            {
                "id": 2025578,
                "content": [
                    {
                        "username": "chandleryeh",
                        "content": "Here is the Hint\n1. push elements to the stack until meet ']'\n2. pop elements from the stack until meet '[' => contents\n3. pop elements digitals from the stack => number\n4. repeat \"contents\" by \"number\" times and push to the stack\nrepeat step 1 to 4"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "quite interesting problem"
                    },
                    {
                        "username": "puneet-yadav",
                        "content": "I am getting mle for this code,, can anyone tell why i am getting mle?\\n Stack<Character> encodedChar = new Stack<>();\\n        //Stack<Integer> times = new Stack<>();\\n        StringBuilder ans = new StringBuilder();\\n      //  int n = s.length();\\n        for(char c: s.toCharArray()){\\n                if(c==\\']\\'){\\n                StringBuilder toDecode = new StringBuilder();\\n                while(encodedChar.peek()!=\\'[\\'){\\n                    char x = encodedChar.peek();\\n                    encodedChar.pop();\\n                    //toDecode = x + toDecode;\\n                    toDecode.append(x);\\n                }\\n                toDecode = toDecode.reverse();\\n                encodedChar.pop();\\n                if(Character.isDigit(encodedChar.peek())){\\n                    int time = (int)encodedChar.peek();\\n                    encodedChar.pop();\\n                    for(int i=0;i<time;i++){\\n                        toDecode.append(toDecode);\\n                    }\\n                }\\n                else{\\n                    ans.append(toDecode);\\n                    continue;\\n                }\\n                ans.append(toDecode);\\n            }\\n            else{\\n                encodedChar.push(c);\\n                continue;\\n            }\\n        }\\n        if(!encodedChar.isEmpty()){\\n            StringBuilder remaining = new StringBuilder();\\n            while(!encodedChar.isEmpty()){\\n               // remaining = encodedChar.peek() + remaining;\\n            \\tremaining.append(encodedChar.peek());\\n                encodedChar.pop();\\n            }\\n            ans.append(remaining.reverse());\\n        }\\n        return ans.toString();"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Now this is what you call a sexy problem"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "class Solution {\\npublic:\\n\\n    string decodeString(string s) \\n    {\\n        if(s.length()==1 && isalpha(s[0])){return s;}\\n        stack<char> st;\\n        string temp=\"\",res=\"\";\\n        int i=0,k_time=0;\\n        for(i=0;i<s.length();i++)\\n        {\\n            temp=\"\";\\n            while(s[i]!=\\']\\' && i<s.length())\\n            {\\n                st.push(s[i]);\\n                i++;    \\n            }\\n            i++;\\n            temp=\"\";\\n            while(st.top()!=\\'[\\' && !st.empty())\\n            {\\n                temp+=st.top();\\n                st.pop();\\n            }\\n\\n            st.pop();\\n            if(temp.length()>1)\\n            {\\n                reverse(temp.begin(),temp.end());\\n            }\\n            \\n            \\n            string num=\"\";\\n\\n            if(!st.empty())\\n            {\\n                num=num+st.top();\\n                st.pop();\\n                k_time= stoi(num);\\n            }\\n            \\n\\n            while(k_time>0)\\n            {\\n                res = res + temp;\\n                k_time--;\\n            }    \\n        }\\n        reverse(res.begin(),res.end());\\n        return res;    \\n    }\\n};\\n\\ncan somebody please explain what\\'s wrong with this code, I am getting a Runtime error indicating DEADLYSIGNAL with an error of SEGV on unknown address."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "please dont post your solutions in here ..\\n"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "[@ritikthakur09](/ritikthakur09) It didn\\'t work, but thanks for a new concept. "
                    },
                    {
                        "username": "ritikthakur09",
                        "content": "while(st.top()!=\\'[\\' && !st.empty()) \\nwrite it as while( !st.empty() && st.top()!=\\'[\\') instead since you need to check if it is empty first and not opposite."
                    },
                    {
                        "username": "dimitars",
                        "content": "Giving an input \"300[300[300[300[300[99[a]]]]]]\" returns an error reading \"The length of the output should not exceed 10^5.\"\\n\\nMaybe it would improve the description if this is mentioned there, considering I\\'m not missing some site-wide constraint."
                    },
                    {
                        "username": "d_e_v_i_l_07",
                        "content": "class Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<string> st;\\n        int ln= s.size();\\n        if(s.size()==1 && (s>=string(1,\\'0\\') && s<=string(1,\\'9\\')))\\n        return \"\";\\n        int check=0;\\n        for(int i=0;i<ln;i++){\\n            if(s[i]!= \\']\\') st.push(string(1,s[i]));\\n            else{\\n                //finding nested problem,ie string inside []\\n                string temp=\"\";\\n                while(st.top()!= string(1,\\'[\\')){\\n                    temp+= st.top();\\n                    st.pop();\\n                }\\n                reverse(temp.begin(),temp.end());\\n                st.pop();\\n                \\n                //finding number\\n                string num=\"\";\\n                while(!st.empty() && (st.top()>=string(1,\\'0\\') && st.top()<=string(1,\\'9\\'))){\\n                    num+=st.top();\\n                    st.pop();\\n                }\\n                reverse(num.begin(),num.end());\\n                \\n                int n= num.size()!=0? stoi(num): 1;\\n                string toPush= \"\";\\n                for(int i=0;i<n;i++)toPush+= temp;\\n                reverse(toPush.begin(),toPush.end());\\n                st.push(toPush);\\n                check = 1;\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans+= st.top();\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        // if(!check)\\n        // return \"\";\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Kaivalya",
                        "content": "Is  this valid input as a test case ? if yes then how it can be handled using stack ? 8th index of below input will try to get value from stack which is 2.\\n\\n2[[12[a]]bc] "
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "this is an invalid input."
                    },
                    {
                        "username": "keratonjava",
                        "content": "This is probably the hardest exercice so far, tips use recursion"
                    },
                    {
                        "username": "abhayx2910",
                        "content": "this is a pseudocode for this problem  for beginners\\n\\nfirst make a stack st,\\nrun a loop from 0->string length\\n       When \\']\\' is encountered, we need to start decoding\\n              run a while loop till we encounter \\'[\\'\\n                st.top() + temp makes sure that the string won\\'t be in reverse order eg, if the stack contains 12[abc temp = c + \"\" =>temp = b + \"c\"=>  temp = a + \"bc\"\\n        remove the [ from stack\\n         remove the digits from the stack\\n        if s[i] is not \\']\\', simply push s[i] to the stack\\n return the resultant string"
                    }
                ]
            },
            {
                "id": 1980730,
                "content": [
                    {
                        "username": "chandleryeh",
                        "content": "Here is the Hint\n1. push elements to the stack until meet ']'\n2. pop elements from the stack until meet '[' => contents\n3. pop elements digitals from the stack => number\n4. repeat \"contents\" by \"number\" times and push to the stack\nrepeat step 1 to 4"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "quite interesting problem"
                    },
                    {
                        "username": "puneet-yadav",
                        "content": "I am getting mle for this code,, can anyone tell why i am getting mle?\\n Stack<Character> encodedChar = new Stack<>();\\n        //Stack<Integer> times = new Stack<>();\\n        StringBuilder ans = new StringBuilder();\\n      //  int n = s.length();\\n        for(char c: s.toCharArray()){\\n                if(c==\\']\\'){\\n                StringBuilder toDecode = new StringBuilder();\\n                while(encodedChar.peek()!=\\'[\\'){\\n                    char x = encodedChar.peek();\\n                    encodedChar.pop();\\n                    //toDecode = x + toDecode;\\n                    toDecode.append(x);\\n                }\\n                toDecode = toDecode.reverse();\\n                encodedChar.pop();\\n                if(Character.isDigit(encodedChar.peek())){\\n                    int time = (int)encodedChar.peek();\\n                    encodedChar.pop();\\n                    for(int i=0;i<time;i++){\\n                        toDecode.append(toDecode);\\n                    }\\n                }\\n                else{\\n                    ans.append(toDecode);\\n                    continue;\\n                }\\n                ans.append(toDecode);\\n            }\\n            else{\\n                encodedChar.push(c);\\n                continue;\\n            }\\n        }\\n        if(!encodedChar.isEmpty()){\\n            StringBuilder remaining = new StringBuilder();\\n            while(!encodedChar.isEmpty()){\\n               // remaining = encodedChar.peek() + remaining;\\n            \\tremaining.append(encodedChar.peek());\\n                encodedChar.pop();\\n            }\\n            ans.append(remaining.reverse());\\n        }\\n        return ans.toString();"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Now this is what you call a sexy problem"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "class Solution {\\npublic:\\n\\n    string decodeString(string s) \\n    {\\n        if(s.length()==1 && isalpha(s[0])){return s;}\\n        stack<char> st;\\n        string temp=\"\",res=\"\";\\n        int i=0,k_time=0;\\n        for(i=0;i<s.length();i++)\\n        {\\n            temp=\"\";\\n            while(s[i]!=\\']\\' && i<s.length())\\n            {\\n                st.push(s[i]);\\n                i++;    \\n            }\\n            i++;\\n            temp=\"\";\\n            while(st.top()!=\\'[\\' && !st.empty())\\n            {\\n                temp+=st.top();\\n                st.pop();\\n            }\\n\\n            st.pop();\\n            if(temp.length()>1)\\n            {\\n                reverse(temp.begin(),temp.end());\\n            }\\n            \\n            \\n            string num=\"\";\\n\\n            if(!st.empty())\\n            {\\n                num=num+st.top();\\n                st.pop();\\n                k_time= stoi(num);\\n            }\\n            \\n\\n            while(k_time>0)\\n            {\\n                res = res + temp;\\n                k_time--;\\n            }    \\n        }\\n        reverse(res.begin(),res.end());\\n        return res;    \\n    }\\n};\\n\\ncan somebody please explain what\\'s wrong with this code, I am getting a Runtime error indicating DEADLYSIGNAL with an error of SEGV on unknown address."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "please dont post your solutions in here ..\\n"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "[@ritikthakur09](/ritikthakur09) It didn\\'t work, but thanks for a new concept. "
                    },
                    {
                        "username": "ritikthakur09",
                        "content": "while(st.top()!=\\'[\\' && !st.empty()) \\nwrite it as while( !st.empty() && st.top()!=\\'[\\') instead since you need to check if it is empty first and not opposite."
                    },
                    {
                        "username": "dimitars",
                        "content": "Giving an input \"300[300[300[300[300[99[a]]]]]]\" returns an error reading \"The length of the output should not exceed 10^5.\"\\n\\nMaybe it would improve the description if this is mentioned there, considering I\\'m not missing some site-wide constraint."
                    },
                    {
                        "username": "d_e_v_i_l_07",
                        "content": "class Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<string> st;\\n        int ln= s.size();\\n        if(s.size()==1 && (s>=string(1,\\'0\\') && s<=string(1,\\'9\\')))\\n        return \"\";\\n        int check=0;\\n        for(int i=0;i<ln;i++){\\n            if(s[i]!= \\']\\') st.push(string(1,s[i]));\\n            else{\\n                //finding nested problem,ie string inside []\\n                string temp=\"\";\\n                while(st.top()!= string(1,\\'[\\')){\\n                    temp+= st.top();\\n                    st.pop();\\n                }\\n                reverse(temp.begin(),temp.end());\\n                st.pop();\\n                \\n                //finding number\\n                string num=\"\";\\n                while(!st.empty() && (st.top()>=string(1,\\'0\\') && st.top()<=string(1,\\'9\\'))){\\n                    num+=st.top();\\n                    st.pop();\\n                }\\n                reverse(num.begin(),num.end());\\n                \\n                int n= num.size()!=0? stoi(num): 1;\\n                string toPush= \"\";\\n                for(int i=0;i<n;i++)toPush+= temp;\\n                reverse(toPush.begin(),toPush.end());\\n                st.push(toPush);\\n                check = 1;\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans+= st.top();\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        // if(!check)\\n        // return \"\";\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Kaivalya",
                        "content": "Is  this valid input as a test case ? if yes then how it can be handled using stack ? 8th index of below input will try to get value from stack which is 2.\\n\\n2[[12[a]]bc] "
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "this is an invalid input."
                    },
                    {
                        "username": "keratonjava",
                        "content": "This is probably the hardest exercice so far, tips use recursion"
                    },
                    {
                        "username": "abhayx2910",
                        "content": "this is a pseudocode for this problem  for beginners\\n\\nfirst make a stack st,\\nrun a loop from 0->string length\\n       When \\']\\' is encountered, we need to start decoding\\n              run a while loop till we encounter \\'[\\'\\n                st.top() + temp makes sure that the string won\\'t be in reverse order eg, if the stack contains 12[abc temp = c + \"\" =>temp = b + \"c\"=>  temp = a + \"bc\"\\n        remove the [ from stack\\n         remove the digits from the stack\\n        if s[i] is not \\']\\', simply push s[i] to the stack\\n return the resultant string"
                    }
                ]
            },
            {
                "id": 1967252,
                "content": [
                    {
                        "username": "chandleryeh",
                        "content": "Here is the Hint\n1. push elements to the stack until meet ']'\n2. pop elements from the stack until meet '[' => contents\n3. pop elements digitals from the stack => number\n4. repeat \"contents\" by \"number\" times and push to the stack\nrepeat step 1 to 4"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "quite interesting problem"
                    },
                    {
                        "username": "puneet-yadav",
                        "content": "I am getting mle for this code,, can anyone tell why i am getting mle?\\n Stack<Character> encodedChar = new Stack<>();\\n        //Stack<Integer> times = new Stack<>();\\n        StringBuilder ans = new StringBuilder();\\n      //  int n = s.length();\\n        for(char c: s.toCharArray()){\\n                if(c==\\']\\'){\\n                StringBuilder toDecode = new StringBuilder();\\n                while(encodedChar.peek()!=\\'[\\'){\\n                    char x = encodedChar.peek();\\n                    encodedChar.pop();\\n                    //toDecode = x + toDecode;\\n                    toDecode.append(x);\\n                }\\n                toDecode = toDecode.reverse();\\n                encodedChar.pop();\\n                if(Character.isDigit(encodedChar.peek())){\\n                    int time = (int)encodedChar.peek();\\n                    encodedChar.pop();\\n                    for(int i=0;i<time;i++){\\n                        toDecode.append(toDecode);\\n                    }\\n                }\\n                else{\\n                    ans.append(toDecode);\\n                    continue;\\n                }\\n                ans.append(toDecode);\\n            }\\n            else{\\n                encodedChar.push(c);\\n                continue;\\n            }\\n        }\\n        if(!encodedChar.isEmpty()){\\n            StringBuilder remaining = new StringBuilder();\\n            while(!encodedChar.isEmpty()){\\n               // remaining = encodedChar.peek() + remaining;\\n            \\tremaining.append(encodedChar.peek());\\n                encodedChar.pop();\\n            }\\n            ans.append(remaining.reverse());\\n        }\\n        return ans.toString();"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Now this is what you call a sexy problem"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "class Solution {\\npublic:\\n\\n    string decodeString(string s) \\n    {\\n        if(s.length()==1 && isalpha(s[0])){return s;}\\n        stack<char> st;\\n        string temp=\"\",res=\"\";\\n        int i=0,k_time=0;\\n        for(i=0;i<s.length();i++)\\n        {\\n            temp=\"\";\\n            while(s[i]!=\\']\\' && i<s.length())\\n            {\\n                st.push(s[i]);\\n                i++;    \\n            }\\n            i++;\\n            temp=\"\";\\n            while(st.top()!=\\'[\\' && !st.empty())\\n            {\\n                temp+=st.top();\\n                st.pop();\\n            }\\n\\n            st.pop();\\n            if(temp.length()>1)\\n            {\\n                reverse(temp.begin(),temp.end());\\n            }\\n            \\n            \\n            string num=\"\";\\n\\n            if(!st.empty())\\n            {\\n                num=num+st.top();\\n                st.pop();\\n                k_time= stoi(num);\\n            }\\n            \\n\\n            while(k_time>0)\\n            {\\n                res = res + temp;\\n                k_time--;\\n            }    \\n        }\\n        reverse(res.begin(),res.end());\\n        return res;    \\n    }\\n};\\n\\ncan somebody please explain what\\'s wrong with this code, I am getting a Runtime error indicating DEADLYSIGNAL with an error of SEGV on unknown address."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "please dont post your solutions in here ..\\n"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "[@ritikthakur09](/ritikthakur09) It didn\\'t work, but thanks for a new concept. "
                    },
                    {
                        "username": "ritikthakur09",
                        "content": "while(st.top()!=\\'[\\' && !st.empty()) \\nwrite it as while( !st.empty() && st.top()!=\\'[\\') instead since you need to check if it is empty first and not opposite."
                    },
                    {
                        "username": "dimitars",
                        "content": "Giving an input \"300[300[300[300[300[99[a]]]]]]\" returns an error reading \"The length of the output should not exceed 10^5.\"\\n\\nMaybe it would improve the description if this is mentioned there, considering I\\'m not missing some site-wide constraint."
                    },
                    {
                        "username": "d_e_v_i_l_07",
                        "content": "class Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<string> st;\\n        int ln= s.size();\\n        if(s.size()==1 && (s>=string(1,\\'0\\') && s<=string(1,\\'9\\')))\\n        return \"\";\\n        int check=0;\\n        for(int i=0;i<ln;i++){\\n            if(s[i]!= \\']\\') st.push(string(1,s[i]));\\n            else{\\n                //finding nested problem,ie string inside []\\n                string temp=\"\";\\n                while(st.top()!= string(1,\\'[\\')){\\n                    temp+= st.top();\\n                    st.pop();\\n                }\\n                reverse(temp.begin(),temp.end());\\n                st.pop();\\n                \\n                //finding number\\n                string num=\"\";\\n                while(!st.empty() && (st.top()>=string(1,\\'0\\') && st.top()<=string(1,\\'9\\'))){\\n                    num+=st.top();\\n                    st.pop();\\n                }\\n                reverse(num.begin(),num.end());\\n                \\n                int n= num.size()!=0? stoi(num): 1;\\n                string toPush= \"\";\\n                for(int i=0;i<n;i++)toPush+= temp;\\n                reverse(toPush.begin(),toPush.end());\\n                st.push(toPush);\\n                check = 1;\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans+= st.top();\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        // if(!check)\\n        // return \"\";\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Kaivalya",
                        "content": "Is  this valid input as a test case ? if yes then how it can be handled using stack ? 8th index of below input will try to get value from stack which is 2.\\n\\n2[[12[a]]bc] "
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "this is an invalid input."
                    },
                    {
                        "username": "keratonjava",
                        "content": "This is probably the hardest exercice so far, tips use recursion"
                    },
                    {
                        "username": "abhayx2910",
                        "content": "this is a pseudocode for this problem  for beginners\\n\\nfirst make a stack st,\\nrun a loop from 0->string length\\n       When \\']\\' is encountered, we need to start decoding\\n              run a while loop till we encounter \\'[\\'\\n                st.top() + temp makes sure that the string won\\'t be in reverse order eg, if the stack contains 12[abc temp = c + \"\" =>temp = b + \"c\"=>  temp = a + \"bc\"\\n        remove the [ from stack\\n         remove the digits from the stack\\n        if s[i] is not \\']\\', simply push s[i] to the stack\\n return the resultant string"
                    }
                ]
            },
            {
                "id": 1959079,
                "content": [
                    {
                        "username": "chandleryeh",
                        "content": "Here is the Hint\n1. push elements to the stack until meet ']'\n2. pop elements from the stack until meet '[' => contents\n3. pop elements digitals from the stack => number\n4. repeat \"contents\" by \"number\" times and push to the stack\nrepeat step 1 to 4"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "quite interesting problem"
                    },
                    {
                        "username": "puneet-yadav",
                        "content": "I am getting mle for this code,, can anyone tell why i am getting mle?\\n Stack<Character> encodedChar = new Stack<>();\\n        //Stack<Integer> times = new Stack<>();\\n        StringBuilder ans = new StringBuilder();\\n      //  int n = s.length();\\n        for(char c: s.toCharArray()){\\n                if(c==\\']\\'){\\n                StringBuilder toDecode = new StringBuilder();\\n                while(encodedChar.peek()!=\\'[\\'){\\n                    char x = encodedChar.peek();\\n                    encodedChar.pop();\\n                    //toDecode = x + toDecode;\\n                    toDecode.append(x);\\n                }\\n                toDecode = toDecode.reverse();\\n                encodedChar.pop();\\n                if(Character.isDigit(encodedChar.peek())){\\n                    int time = (int)encodedChar.peek();\\n                    encodedChar.pop();\\n                    for(int i=0;i<time;i++){\\n                        toDecode.append(toDecode);\\n                    }\\n                }\\n                else{\\n                    ans.append(toDecode);\\n                    continue;\\n                }\\n                ans.append(toDecode);\\n            }\\n            else{\\n                encodedChar.push(c);\\n                continue;\\n            }\\n        }\\n        if(!encodedChar.isEmpty()){\\n            StringBuilder remaining = new StringBuilder();\\n            while(!encodedChar.isEmpty()){\\n               // remaining = encodedChar.peek() + remaining;\\n            \\tremaining.append(encodedChar.peek());\\n                encodedChar.pop();\\n            }\\n            ans.append(remaining.reverse());\\n        }\\n        return ans.toString();"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Now this is what you call a sexy problem"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "class Solution {\\npublic:\\n\\n    string decodeString(string s) \\n    {\\n        if(s.length()==1 && isalpha(s[0])){return s;}\\n        stack<char> st;\\n        string temp=\"\",res=\"\";\\n        int i=0,k_time=0;\\n        for(i=0;i<s.length();i++)\\n        {\\n            temp=\"\";\\n            while(s[i]!=\\']\\' && i<s.length())\\n            {\\n                st.push(s[i]);\\n                i++;    \\n            }\\n            i++;\\n            temp=\"\";\\n            while(st.top()!=\\'[\\' && !st.empty())\\n            {\\n                temp+=st.top();\\n                st.pop();\\n            }\\n\\n            st.pop();\\n            if(temp.length()>1)\\n            {\\n                reverse(temp.begin(),temp.end());\\n            }\\n            \\n            \\n            string num=\"\";\\n\\n            if(!st.empty())\\n            {\\n                num=num+st.top();\\n                st.pop();\\n                k_time= stoi(num);\\n            }\\n            \\n\\n            while(k_time>0)\\n            {\\n                res = res + temp;\\n                k_time--;\\n            }    \\n        }\\n        reverse(res.begin(),res.end());\\n        return res;    \\n    }\\n};\\n\\ncan somebody please explain what\\'s wrong with this code, I am getting a Runtime error indicating DEADLYSIGNAL with an error of SEGV on unknown address."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "please dont post your solutions in here ..\\n"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "[@ritikthakur09](/ritikthakur09) It didn\\'t work, but thanks for a new concept. "
                    },
                    {
                        "username": "ritikthakur09",
                        "content": "while(st.top()!=\\'[\\' && !st.empty()) \\nwrite it as while( !st.empty() && st.top()!=\\'[\\') instead since you need to check if it is empty first and not opposite."
                    },
                    {
                        "username": "dimitars",
                        "content": "Giving an input \"300[300[300[300[300[99[a]]]]]]\" returns an error reading \"The length of the output should not exceed 10^5.\"\\n\\nMaybe it would improve the description if this is mentioned there, considering I\\'m not missing some site-wide constraint."
                    },
                    {
                        "username": "d_e_v_i_l_07",
                        "content": "class Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<string> st;\\n        int ln= s.size();\\n        if(s.size()==1 && (s>=string(1,\\'0\\') && s<=string(1,\\'9\\')))\\n        return \"\";\\n        int check=0;\\n        for(int i=0;i<ln;i++){\\n            if(s[i]!= \\']\\') st.push(string(1,s[i]));\\n            else{\\n                //finding nested problem,ie string inside []\\n                string temp=\"\";\\n                while(st.top()!= string(1,\\'[\\')){\\n                    temp+= st.top();\\n                    st.pop();\\n                }\\n                reverse(temp.begin(),temp.end());\\n                st.pop();\\n                \\n                //finding number\\n                string num=\"\";\\n                while(!st.empty() && (st.top()>=string(1,\\'0\\') && st.top()<=string(1,\\'9\\'))){\\n                    num+=st.top();\\n                    st.pop();\\n                }\\n                reverse(num.begin(),num.end());\\n                \\n                int n= num.size()!=0? stoi(num): 1;\\n                string toPush= \"\";\\n                for(int i=0;i<n;i++)toPush+= temp;\\n                reverse(toPush.begin(),toPush.end());\\n                st.push(toPush);\\n                check = 1;\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans+= st.top();\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        // if(!check)\\n        // return \"\";\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Kaivalya",
                        "content": "Is  this valid input as a test case ? if yes then how it can be handled using stack ? 8th index of below input will try to get value from stack which is 2.\\n\\n2[[12[a]]bc] "
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "this is an invalid input."
                    },
                    {
                        "username": "keratonjava",
                        "content": "This is probably the hardest exercice so far, tips use recursion"
                    },
                    {
                        "username": "abhayx2910",
                        "content": "this is a pseudocode for this problem  for beginners\\n\\nfirst make a stack st,\\nrun a loop from 0->string length\\n       When \\']\\' is encountered, we need to start decoding\\n              run a while loop till we encounter \\'[\\'\\n                st.top() + temp makes sure that the string won\\'t be in reverse order eg, if the stack contains 12[abc temp = c + \"\" =>temp = b + \"c\"=>  temp = a + \"bc\"\\n        remove the [ from stack\\n         remove the digits from the stack\\n        if s[i] is not \\']\\', simply push s[i] to the stack\\n return the resultant string"
                    }
                ]
            },
            {
                "id": 1883559,
                "content": [
                    {
                        "username": "chandleryeh",
                        "content": "Here is the Hint\n1. push elements to the stack until meet ']'\n2. pop elements from the stack until meet '[' => contents\n3. pop elements digitals from the stack => number\n4. repeat \"contents\" by \"number\" times and push to the stack\nrepeat step 1 to 4"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "quite interesting problem"
                    },
                    {
                        "username": "puneet-yadav",
                        "content": "I am getting mle for this code,, can anyone tell why i am getting mle?\\n Stack<Character> encodedChar = new Stack<>();\\n        //Stack<Integer> times = new Stack<>();\\n        StringBuilder ans = new StringBuilder();\\n      //  int n = s.length();\\n        for(char c: s.toCharArray()){\\n                if(c==\\']\\'){\\n                StringBuilder toDecode = new StringBuilder();\\n                while(encodedChar.peek()!=\\'[\\'){\\n                    char x = encodedChar.peek();\\n                    encodedChar.pop();\\n                    //toDecode = x + toDecode;\\n                    toDecode.append(x);\\n                }\\n                toDecode = toDecode.reverse();\\n                encodedChar.pop();\\n                if(Character.isDigit(encodedChar.peek())){\\n                    int time = (int)encodedChar.peek();\\n                    encodedChar.pop();\\n                    for(int i=0;i<time;i++){\\n                        toDecode.append(toDecode);\\n                    }\\n                }\\n                else{\\n                    ans.append(toDecode);\\n                    continue;\\n                }\\n                ans.append(toDecode);\\n            }\\n            else{\\n                encodedChar.push(c);\\n                continue;\\n            }\\n        }\\n        if(!encodedChar.isEmpty()){\\n            StringBuilder remaining = new StringBuilder();\\n            while(!encodedChar.isEmpty()){\\n               // remaining = encodedChar.peek() + remaining;\\n            \\tremaining.append(encodedChar.peek());\\n                encodedChar.pop();\\n            }\\n            ans.append(remaining.reverse());\\n        }\\n        return ans.toString();"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Now this is what you call a sexy problem"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "class Solution {\\npublic:\\n\\n    string decodeString(string s) \\n    {\\n        if(s.length()==1 && isalpha(s[0])){return s;}\\n        stack<char> st;\\n        string temp=\"\",res=\"\";\\n        int i=0,k_time=0;\\n        for(i=0;i<s.length();i++)\\n        {\\n            temp=\"\";\\n            while(s[i]!=\\']\\' && i<s.length())\\n            {\\n                st.push(s[i]);\\n                i++;    \\n            }\\n            i++;\\n            temp=\"\";\\n            while(st.top()!=\\'[\\' && !st.empty())\\n            {\\n                temp+=st.top();\\n                st.pop();\\n            }\\n\\n            st.pop();\\n            if(temp.length()>1)\\n            {\\n                reverse(temp.begin(),temp.end());\\n            }\\n            \\n            \\n            string num=\"\";\\n\\n            if(!st.empty())\\n            {\\n                num=num+st.top();\\n                st.pop();\\n                k_time= stoi(num);\\n            }\\n            \\n\\n            while(k_time>0)\\n            {\\n                res = res + temp;\\n                k_time--;\\n            }    \\n        }\\n        reverse(res.begin(),res.end());\\n        return res;    \\n    }\\n};\\n\\ncan somebody please explain what\\'s wrong with this code, I am getting a Runtime error indicating DEADLYSIGNAL with an error of SEGV on unknown address."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "please dont post your solutions in here ..\\n"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "[@ritikthakur09](/ritikthakur09) It didn\\'t work, but thanks for a new concept. "
                    },
                    {
                        "username": "ritikthakur09",
                        "content": "while(st.top()!=\\'[\\' && !st.empty()) \\nwrite it as while( !st.empty() && st.top()!=\\'[\\') instead since you need to check if it is empty first and not opposite."
                    },
                    {
                        "username": "dimitars",
                        "content": "Giving an input \"300[300[300[300[300[99[a]]]]]]\" returns an error reading \"The length of the output should not exceed 10^5.\"\\n\\nMaybe it would improve the description if this is mentioned there, considering I\\'m not missing some site-wide constraint."
                    },
                    {
                        "username": "d_e_v_i_l_07",
                        "content": "class Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<string> st;\\n        int ln= s.size();\\n        if(s.size()==1 && (s>=string(1,\\'0\\') && s<=string(1,\\'9\\')))\\n        return \"\";\\n        int check=0;\\n        for(int i=0;i<ln;i++){\\n            if(s[i]!= \\']\\') st.push(string(1,s[i]));\\n            else{\\n                //finding nested problem,ie string inside []\\n                string temp=\"\";\\n                while(st.top()!= string(1,\\'[\\')){\\n                    temp+= st.top();\\n                    st.pop();\\n                }\\n                reverse(temp.begin(),temp.end());\\n                st.pop();\\n                \\n                //finding number\\n                string num=\"\";\\n                while(!st.empty() && (st.top()>=string(1,\\'0\\') && st.top()<=string(1,\\'9\\'))){\\n                    num+=st.top();\\n                    st.pop();\\n                }\\n                reverse(num.begin(),num.end());\\n                \\n                int n= num.size()!=0? stoi(num): 1;\\n                string toPush= \"\";\\n                for(int i=0;i<n;i++)toPush+= temp;\\n                reverse(toPush.begin(),toPush.end());\\n                st.push(toPush);\\n                check = 1;\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans+= st.top();\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        // if(!check)\\n        // return \"\";\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Kaivalya",
                        "content": "Is  this valid input as a test case ? if yes then how it can be handled using stack ? 8th index of below input will try to get value from stack which is 2.\\n\\n2[[12[a]]bc] "
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "this is an invalid input."
                    },
                    {
                        "username": "keratonjava",
                        "content": "This is probably the hardest exercice so far, tips use recursion"
                    },
                    {
                        "username": "abhayx2910",
                        "content": "this is a pseudocode for this problem  for beginners\\n\\nfirst make a stack st,\\nrun a loop from 0->string length\\n       When \\']\\' is encountered, we need to start decoding\\n              run a while loop till we encounter \\'[\\'\\n                st.top() + temp makes sure that the string won\\'t be in reverse order eg, if the stack contains 12[abc temp = c + \"\" =>temp = b + \"c\"=>  temp = a + \"bc\"\\n        remove the [ from stack\\n         remove the digits from the stack\\n        if s[i] is not \\']\\', simply push s[i] to the stack\\n return the resultant string"
                    }
                ]
            },
            {
                "id": 1881918,
                "content": [
                    {
                        "username": "chandleryeh",
                        "content": "Here is the Hint\n1. push elements to the stack until meet ']'\n2. pop elements from the stack until meet '[' => contents\n3. pop elements digitals from the stack => number\n4. repeat \"contents\" by \"number\" times and push to the stack\nrepeat step 1 to 4"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "quite interesting problem"
                    },
                    {
                        "username": "puneet-yadav",
                        "content": "I am getting mle for this code,, can anyone tell why i am getting mle?\\n Stack<Character> encodedChar = new Stack<>();\\n        //Stack<Integer> times = new Stack<>();\\n        StringBuilder ans = new StringBuilder();\\n      //  int n = s.length();\\n        for(char c: s.toCharArray()){\\n                if(c==\\']\\'){\\n                StringBuilder toDecode = new StringBuilder();\\n                while(encodedChar.peek()!=\\'[\\'){\\n                    char x = encodedChar.peek();\\n                    encodedChar.pop();\\n                    //toDecode = x + toDecode;\\n                    toDecode.append(x);\\n                }\\n                toDecode = toDecode.reverse();\\n                encodedChar.pop();\\n                if(Character.isDigit(encodedChar.peek())){\\n                    int time = (int)encodedChar.peek();\\n                    encodedChar.pop();\\n                    for(int i=0;i<time;i++){\\n                        toDecode.append(toDecode);\\n                    }\\n                }\\n                else{\\n                    ans.append(toDecode);\\n                    continue;\\n                }\\n                ans.append(toDecode);\\n            }\\n            else{\\n                encodedChar.push(c);\\n                continue;\\n            }\\n        }\\n        if(!encodedChar.isEmpty()){\\n            StringBuilder remaining = new StringBuilder();\\n            while(!encodedChar.isEmpty()){\\n               // remaining = encodedChar.peek() + remaining;\\n            \\tremaining.append(encodedChar.peek());\\n                encodedChar.pop();\\n            }\\n            ans.append(remaining.reverse());\\n        }\\n        return ans.toString();"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Now this is what you call a sexy problem"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "class Solution {\\npublic:\\n\\n    string decodeString(string s) \\n    {\\n        if(s.length()==1 && isalpha(s[0])){return s;}\\n        stack<char> st;\\n        string temp=\"\",res=\"\";\\n        int i=0,k_time=0;\\n        for(i=0;i<s.length();i++)\\n        {\\n            temp=\"\";\\n            while(s[i]!=\\']\\' && i<s.length())\\n            {\\n                st.push(s[i]);\\n                i++;    \\n            }\\n            i++;\\n            temp=\"\";\\n            while(st.top()!=\\'[\\' && !st.empty())\\n            {\\n                temp+=st.top();\\n                st.pop();\\n            }\\n\\n            st.pop();\\n            if(temp.length()>1)\\n            {\\n                reverse(temp.begin(),temp.end());\\n            }\\n            \\n            \\n            string num=\"\";\\n\\n            if(!st.empty())\\n            {\\n                num=num+st.top();\\n                st.pop();\\n                k_time= stoi(num);\\n            }\\n            \\n\\n            while(k_time>0)\\n            {\\n                res = res + temp;\\n                k_time--;\\n            }    \\n        }\\n        reverse(res.begin(),res.end());\\n        return res;    \\n    }\\n};\\n\\ncan somebody please explain what\\'s wrong with this code, I am getting a Runtime error indicating DEADLYSIGNAL with an error of SEGV on unknown address."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "please dont post your solutions in here ..\\n"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "[@ritikthakur09](/ritikthakur09) It didn\\'t work, but thanks for a new concept. "
                    },
                    {
                        "username": "ritikthakur09",
                        "content": "while(st.top()!=\\'[\\' && !st.empty()) \\nwrite it as while( !st.empty() && st.top()!=\\'[\\') instead since you need to check if it is empty first and not opposite."
                    },
                    {
                        "username": "dimitars",
                        "content": "Giving an input \"300[300[300[300[300[99[a]]]]]]\" returns an error reading \"The length of the output should not exceed 10^5.\"\\n\\nMaybe it would improve the description if this is mentioned there, considering I\\'m not missing some site-wide constraint."
                    },
                    {
                        "username": "d_e_v_i_l_07",
                        "content": "class Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<string> st;\\n        int ln= s.size();\\n        if(s.size()==1 && (s>=string(1,\\'0\\') && s<=string(1,\\'9\\')))\\n        return \"\";\\n        int check=0;\\n        for(int i=0;i<ln;i++){\\n            if(s[i]!= \\']\\') st.push(string(1,s[i]));\\n            else{\\n                //finding nested problem,ie string inside []\\n                string temp=\"\";\\n                while(st.top()!= string(1,\\'[\\')){\\n                    temp+= st.top();\\n                    st.pop();\\n                }\\n                reverse(temp.begin(),temp.end());\\n                st.pop();\\n                \\n                //finding number\\n                string num=\"\";\\n                while(!st.empty() && (st.top()>=string(1,\\'0\\') && st.top()<=string(1,\\'9\\'))){\\n                    num+=st.top();\\n                    st.pop();\\n                }\\n                reverse(num.begin(),num.end());\\n                \\n                int n= num.size()!=0? stoi(num): 1;\\n                string toPush= \"\";\\n                for(int i=0;i<n;i++)toPush+= temp;\\n                reverse(toPush.begin(),toPush.end());\\n                st.push(toPush);\\n                check = 1;\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans+= st.top();\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        // if(!check)\\n        // return \"\";\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Kaivalya",
                        "content": "Is  this valid input as a test case ? if yes then how it can be handled using stack ? 8th index of below input will try to get value from stack which is 2.\\n\\n2[[12[a]]bc] "
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "this is an invalid input."
                    },
                    {
                        "username": "keratonjava",
                        "content": "This is probably the hardest exercice so far, tips use recursion"
                    },
                    {
                        "username": "abhayx2910",
                        "content": "this is a pseudocode for this problem  for beginners\\n\\nfirst make a stack st,\\nrun a loop from 0->string length\\n       When \\']\\' is encountered, we need to start decoding\\n              run a while loop till we encounter \\'[\\'\\n                st.top() + temp makes sure that the string won\\'t be in reverse order eg, if the stack contains 12[abc temp = c + \"\" =>temp = b + \"c\"=>  temp = a + \"bc\"\\n        remove the [ from stack\\n         remove the digits from the stack\\n        if s[i] is not \\']\\', simply push s[i] to the stack\\n return the resultant string"
                    }
                ]
            },
            {
                "id": 1823961,
                "content": [
                    {
                        "username": "chandleryeh",
                        "content": "Here is the Hint\n1. push elements to the stack until meet ']'\n2. pop elements from the stack until meet '[' => contents\n3. pop elements digitals from the stack => number\n4. repeat \"contents\" by \"number\" times and push to the stack\nrepeat step 1 to 4"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "quite interesting problem"
                    },
                    {
                        "username": "puneet-yadav",
                        "content": "I am getting mle for this code,, can anyone tell why i am getting mle?\\n Stack<Character> encodedChar = new Stack<>();\\n        //Stack<Integer> times = new Stack<>();\\n        StringBuilder ans = new StringBuilder();\\n      //  int n = s.length();\\n        for(char c: s.toCharArray()){\\n                if(c==\\']\\'){\\n                StringBuilder toDecode = new StringBuilder();\\n                while(encodedChar.peek()!=\\'[\\'){\\n                    char x = encodedChar.peek();\\n                    encodedChar.pop();\\n                    //toDecode = x + toDecode;\\n                    toDecode.append(x);\\n                }\\n                toDecode = toDecode.reverse();\\n                encodedChar.pop();\\n                if(Character.isDigit(encodedChar.peek())){\\n                    int time = (int)encodedChar.peek();\\n                    encodedChar.pop();\\n                    for(int i=0;i<time;i++){\\n                        toDecode.append(toDecode);\\n                    }\\n                }\\n                else{\\n                    ans.append(toDecode);\\n                    continue;\\n                }\\n                ans.append(toDecode);\\n            }\\n            else{\\n                encodedChar.push(c);\\n                continue;\\n            }\\n        }\\n        if(!encodedChar.isEmpty()){\\n            StringBuilder remaining = new StringBuilder();\\n            while(!encodedChar.isEmpty()){\\n               // remaining = encodedChar.peek() + remaining;\\n            \\tremaining.append(encodedChar.peek());\\n                encodedChar.pop();\\n            }\\n            ans.append(remaining.reverse());\\n        }\\n        return ans.toString();"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Now this is what you call a sexy problem"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "class Solution {\\npublic:\\n\\n    string decodeString(string s) \\n    {\\n        if(s.length()==1 && isalpha(s[0])){return s;}\\n        stack<char> st;\\n        string temp=\"\",res=\"\";\\n        int i=0,k_time=0;\\n        for(i=0;i<s.length();i++)\\n        {\\n            temp=\"\";\\n            while(s[i]!=\\']\\' && i<s.length())\\n            {\\n                st.push(s[i]);\\n                i++;    \\n            }\\n            i++;\\n            temp=\"\";\\n            while(st.top()!=\\'[\\' && !st.empty())\\n            {\\n                temp+=st.top();\\n                st.pop();\\n            }\\n\\n            st.pop();\\n            if(temp.length()>1)\\n            {\\n                reverse(temp.begin(),temp.end());\\n            }\\n            \\n            \\n            string num=\"\";\\n\\n            if(!st.empty())\\n            {\\n                num=num+st.top();\\n                st.pop();\\n                k_time= stoi(num);\\n            }\\n            \\n\\n            while(k_time>0)\\n            {\\n                res = res + temp;\\n                k_time--;\\n            }    \\n        }\\n        reverse(res.begin(),res.end());\\n        return res;    \\n    }\\n};\\n\\ncan somebody please explain what\\'s wrong with this code, I am getting a Runtime error indicating DEADLYSIGNAL with an error of SEGV on unknown address."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "please dont post your solutions in here ..\\n"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "[@ritikthakur09](/ritikthakur09) It didn\\'t work, but thanks for a new concept. "
                    },
                    {
                        "username": "ritikthakur09",
                        "content": "while(st.top()!=\\'[\\' && !st.empty()) \\nwrite it as while( !st.empty() && st.top()!=\\'[\\') instead since you need to check if it is empty first and not opposite."
                    },
                    {
                        "username": "dimitars",
                        "content": "Giving an input \"300[300[300[300[300[99[a]]]]]]\" returns an error reading \"The length of the output should not exceed 10^5.\"\\n\\nMaybe it would improve the description if this is mentioned there, considering I\\'m not missing some site-wide constraint."
                    },
                    {
                        "username": "d_e_v_i_l_07",
                        "content": "class Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<string> st;\\n        int ln= s.size();\\n        if(s.size()==1 && (s>=string(1,\\'0\\') && s<=string(1,\\'9\\')))\\n        return \"\";\\n        int check=0;\\n        for(int i=0;i<ln;i++){\\n            if(s[i]!= \\']\\') st.push(string(1,s[i]));\\n            else{\\n                //finding nested problem,ie string inside []\\n                string temp=\"\";\\n                while(st.top()!= string(1,\\'[\\')){\\n                    temp+= st.top();\\n                    st.pop();\\n                }\\n                reverse(temp.begin(),temp.end());\\n                st.pop();\\n                \\n                //finding number\\n                string num=\"\";\\n                while(!st.empty() && (st.top()>=string(1,\\'0\\') && st.top()<=string(1,\\'9\\'))){\\n                    num+=st.top();\\n                    st.pop();\\n                }\\n                reverse(num.begin(),num.end());\\n                \\n                int n= num.size()!=0? stoi(num): 1;\\n                string toPush= \"\";\\n                for(int i=0;i<n;i++)toPush+= temp;\\n                reverse(toPush.begin(),toPush.end());\\n                st.push(toPush);\\n                check = 1;\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans+= st.top();\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        // if(!check)\\n        // return \"\";\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Kaivalya",
                        "content": "Is  this valid input as a test case ? if yes then how it can be handled using stack ? 8th index of below input will try to get value from stack which is 2.\\n\\n2[[12[a]]bc] "
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "this is an invalid input."
                    },
                    {
                        "username": "keratonjava",
                        "content": "This is probably the hardest exercice so far, tips use recursion"
                    },
                    {
                        "username": "abhayx2910",
                        "content": "this is a pseudocode for this problem  for beginners\\n\\nfirst make a stack st,\\nrun a loop from 0->string length\\n       When \\']\\' is encountered, we need to start decoding\\n              run a while loop till we encounter \\'[\\'\\n                st.top() + temp makes sure that the string won\\'t be in reverse order eg, if the stack contains 12[abc temp = c + \"\" =>temp = b + \"c\"=>  temp = a + \"bc\"\\n        remove the [ from stack\\n         remove the digits from the stack\\n        if s[i] is not \\']\\', simply push s[i] to the stack\\n return the resultant string"
                    }
                ]
            },
            {
                "id": 1812859,
                "content": [
                    {
                        "username": "chandleryeh",
                        "content": "Here is the Hint\n1. push elements to the stack until meet ']'\n2. pop elements from the stack until meet '[' => contents\n3. pop elements digitals from the stack => number\n4. repeat \"contents\" by \"number\" times and push to the stack\nrepeat step 1 to 4"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "quite interesting problem"
                    },
                    {
                        "username": "puneet-yadav",
                        "content": "I am getting mle for this code,, can anyone tell why i am getting mle?\\n Stack<Character> encodedChar = new Stack<>();\\n        //Stack<Integer> times = new Stack<>();\\n        StringBuilder ans = new StringBuilder();\\n      //  int n = s.length();\\n        for(char c: s.toCharArray()){\\n                if(c==\\']\\'){\\n                StringBuilder toDecode = new StringBuilder();\\n                while(encodedChar.peek()!=\\'[\\'){\\n                    char x = encodedChar.peek();\\n                    encodedChar.pop();\\n                    //toDecode = x + toDecode;\\n                    toDecode.append(x);\\n                }\\n                toDecode = toDecode.reverse();\\n                encodedChar.pop();\\n                if(Character.isDigit(encodedChar.peek())){\\n                    int time = (int)encodedChar.peek();\\n                    encodedChar.pop();\\n                    for(int i=0;i<time;i++){\\n                        toDecode.append(toDecode);\\n                    }\\n                }\\n                else{\\n                    ans.append(toDecode);\\n                    continue;\\n                }\\n                ans.append(toDecode);\\n            }\\n            else{\\n                encodedChar.push(c);\\n                continue;\\n            }\\n        }\\n        if(!encodedChar.isEmpty()){\\n            StringBuilder remaining = new StringBuilder();\\n            while(!encodedChar.isEmpty()){\\n               // remaining = encodedChar.peek() + remaining;\\n            \\tremaining.append(encodedChar.peek());\\n                encodedChar.pop();\\n            }\\n            ans.append(remaining.reverse());\\n        }\\n        return ans.toString();"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Now this is what you call a sexy problem"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "class Solution {\\npublic:\\n\\n    string decodeString(string s) \\n    {\\n        if(s.length()==1 && isalpha(s[0])){return s;}\\n        stack<char> st;\\n        string temp=\"\",res=\"\";\\n        int i=0,k_time=0;\\n        for(i=0;i<s.length();i++)\\n        {\\n            temp=\"\";\\n            while(s[i]!=\\']\\' && i<s.length())\\n            {\\n                st.push(s[i]);\\n                i++;    \\n            }\\n            i++;\\n            temp=\"\";\\n            while(st.top()!=\\'[\\' && !st.empty())\\n            {\\n                temp+=st.top();\\n                st.pop();\\n            }\\n\\n            st.pop();\\n            if(temp.length()>1)\\n            {\\n                reverse(temp.begin(),temp.end());\\n            }\\n            \\n            \\n            string num=\"\";\\n\\n            if(!st.empty())\\n            {\\n                num=num+st.top();\\n                st.pop();\\n                k_time= stoi(num);\\n            }\\n            \\n\\n            while(k_time>0)\\n            {\\n                res = res + temp;\\n                k_time--;\\n            }    \\n        }\\n        reverse(res.begin(),res.end());\\n        return res;    \\n    }\\n};\\n\\ncan somebody please explain what\\'s wrong with this code, I am getting a Runtime error indicating DEADLYSIGNAL with an error of SEGV on unknown address."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "please dont post your solutions in here ..\\n"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "[@ritikthakur09](/ritikthakur09) It didn\\'t work, but thanks for a new concept. "
                    },
                    {
                        "username": "ritikthakur09",
                        "content": "while(st.top()!=\\'[\\' && !st.empty()) \\nwrite it as while( !st.empty() && st.top()!=\\'[\\') instead since you need to check if it is empty first and not opposite."
                    },
                    {
                        "username": "dimitars",
                        "content": "Giving an input \"300[300[300[300[300[99[a]]]]]]\" returns an error reading \"The length of the output should not exceed 10^5.\"\\n\\nMaybe it would improve the description if this is mentioned there, considering I\\'m not missing some site-wide constraint."
                    },
                    {
                        "username": "d_e_v_i_l_07",
                        "content": "class Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<string> st;\\n        int ln= s.size();\\n        if(s.size()==1 && (s>=string(1,\\'0\\') && s<=string(1,\\'9\\')))\\n        return \"\";\\n        int check=0;\\n        for(int i=0;i<ln;i++){\\n            if(s[i]!= \\']\\') st.push(string(1,s[i]));\\n            else{\\n                //finding nested problem,ie string inside []\\n                string temp=\"\";\\n                while(st.top()!= string(1,\\'[\\')){\\n                    temp+= st.top();\\n                    st.pop();\\n                }\\n                reverse(temp.begin(),temp.end());\\n                st.pop();\\n                \\n                //finding number\\n                string num=\"\";\\n                while(!st.empty() && (st.top()>=string(1,\\'0\\') && st.top()<=string(1,\\'9\\'))){\\n                    num+=st.top();\\n                    st.pop();\\n                }\\n                reverse(num.begin(),num.end());\\n                \\n                int n= num.size()!=0? stoi(num): 1;\\n                string toPush= \"\";\\n                for(int i=0;i<n;i++)toPush+= temp;\\n                reverse(toPush.begin(),toPush.end());\\n                st.push(toPush);\\n                check = 1;\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans+= st.top();\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        // if(!check)\\n        // return \"\";\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Kaivalya",
                        "content": "Is  this valid input as a test case ? if yes then how it can be handled using stack ? 8th index of below input will try to get value from stack which is 2.\\n\\n2[[12[a]]bc] "
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "this is an invalid input."
                    },
                    {
                        "username": "keratonjava",
                        "content": "This is probably the hardest exercice so far, tips use recursion"
                    },
                    {
                        "username": "abhayx2910",
                        "content": "this is a pseudocode for this problem  for beginners\\n\\nfirst make a stack st,\\nrun a loop from 0->string length\\n       When \\']\\' is encountered, we need to start decoding\\n              run a while loop till we encounter \\'[\\'\\n                st.top() + temp makes sure that the string won\\'t be in reverse order eg, if the stack contains 12[abc temp = c + \"\" =>temp = b + \"c\"=>  temp = a + \"bc\"\\n        remove the [ from stack\\n         remove the digits from the stack\\n        if s[i] is not \\']\\', simply push s[i] to the stack\\n return the resultant string"
                    }
                ]
            },
            {
                "id": 1801343,
                "content": [
                    {
                        "username": "chandleryeh",
                        "content": "Here is the Hint\n1. push elements to the stack until meet ']'\n2. pop elements from the stack until meet '[' => contents\n3. pop elements digitals from the stack => number\n4. repeat \"contents\" by \"number\" times and push to the stack\nrepeat step 1 to 4"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "quite interesting problem"
                    },
                    {
                        "username": "puneet-yadav",
                        "content": "I am getting mle for this code,, can anyone tell why i am getting mle?\\n Stack<Character> encodedChar = new Stack<>();\\n        //Stack<Integer> times = new Stack<>();\\n        StringBuilder ans = new StringBuilder();\\n      //  int n = s.length();\\n        for(char c: s.toCharArray()){\\n                if(c==\\']\\'){\\n                StringBuilder toDecode = new StringBuilder();\\n                while(encodedChar.peek()!=\\'[\\'){\\n                    char x = encodedChar.peek();\\n                    encodedChar.pop();\\n                    //toDecode = x + toDecode;\\n                    toDecode.append(x);\\n                }\\n                toDecode = toDecode.reverse();\\n                encodedChar.pop();\\n                if(Character.isDigit(encodedChar.peek())){\\n                    int time = (int)encodedChar.peek();\\n                    encodedChar.pop();\\n                    for(int i=0;i<time;i++){\\n                        toDecode.append(toDecode);\\n                    }\\n                }\\n                else{\\n                    ans.append(toDecode);\\n                    continue;\\n                }\\n                ans.append(toDecode);\\n            }\\n            else{\\n                encodedChar.push(c);\\n                continue;\\n            }\\n        }\\n        if(!encodedChar.isEmpty()){\\n            StringBuilder remaining = new StringBuilder();\\n            while(!encodedChar.isEmpty()){\\n               // remaining = encodedChar.peek() + remaining;\\n            \\tremaining.append(encodedChar.peek());\\n                encodedChar.pop();\\n            }\\n            ans.append(remaining.reverse());\\n        }\\n        return ans.toString();"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Now this is what you call a sexy problem"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "class Solution {\\npublic:\\n\\n    string decodeString(string s) \\n    {\\n        if(s.length()==1 && isalpha(s[0])){return s;}\\n        stack<char> st;\\n        string temp=\"\",res=\"\";\\n        int i=0,k_time=0;\\n        for(i=0;i<s.length();i++)\\n        {\\n            temp=\"\";\\n            while(s[i]!=\\']\\' && i<s.length())\\n            {\\n                st.push(s[i]);\\n                i++;    \\n            }\\n            i++;\\n            temp=\"\";\\n            while(st.top()!=\\'[\\' && !st.empty())\\n            {\\n                temp+=st.top();\\n                st.pop();\\n            }\\n\\n            st.pop();\\n            if(temp.length()>1)\\n            {\\n                reverse(temp.begin(),temp.end());\\n            }\\n            \\n            \\n            string num=\"\";\\n\\n            if(!st.empty())\\n            {\\n                num=num+st.top();\\n                st.pop();\\n                k_time= stoi(num);\\n            }\\n            \\n\\n            while(k_time>0)\\n            {\\n                res = res + temp;\\n                k_time--;\\n            }    \\n        }\\n        reverse(res.begin(),res.end());\\n        return res;    \\n    }\\n};\\n\\ncan somebody please explain what\\'s wrong with this code, I am getting a Runtime error indicating DEADLYSIGNAL with an error of SEGV on unknown address."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "please dont post your solutions in here ..\\n"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "[@ritikthakur09](/ritikthakur09) It didn\\'t work, but thanks for a new concept. "
                    },
                    {
                        "username": "ritikthakur09",
                        "content": "while(st.top()!=\\'[\\' && !st.empty()) \\nwrite it as while( !st.empty() && st.top()!=\\'[\\') instead since you need to check if it is empty first and not opposite."
                    },
                    {
                        "username": "dimitars",
                        "content": "Giving an input \"300[300[300[300[300[99[a]]]]]]\" returns an error reading \"The length of the output should not exceed 10^5.\"\\n\\nMaybe it would improve the description if this is mentioned there, considering I\\'m not missing some site-wide constraint."
                    },
                    {
                        "username": "d_e_v_i_l_07",
                        "content": "class Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<string> st;\\n        int ln= s.size();\\n        if(s.size()==1 && (s>=string(1,\\'0\\') && s<=string(1,\\'9\\')))\\n        return \"\";\\n        int check=0;\\n        for(int i=0;i<ln;i++){\\n            if(s[i]!= \\']\\') st.push(string(1,s[i]));\\n            else{\\n                //finding nested problem,ie string inside []\\n                string temp=\"\";\\n                while(st.top()!= string(1,\\'[\\')){\\n                    temp+= st.top();\\n                    st.pop();\\n                }\\n                reverse(temp.begin(),temp.end());\\n                st.pop();\\n                \\n                //finding number\\n                string num=\"\";\\n                while(!st.empty() && (st.top()>=string(1,\\'0\\') && st.top()<=string(1,\\'9\\'))){\\n                    num+=st.top();\\n                    st.pop();\\n                }\\n                reverse(num.begin(),num.end());\\n                \\n                int n= num.size()!=0? stoi(num): 1;\\n                string toPush= \"\";\\n                for(int i=0;i<n;i++)toPush+= temp;\\n                reverse(toPush.begin(),toPush.end());\\n                st.push(toPush);\\n                check = 1;\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans+= st.top();\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        // if(!check)\\n        // return \"\";\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Kaivalya",
                        "content": "Is  this valid input as a test case ? if yes then how it can be handled using stack ? 8th index of below input will try to get value from stack which is 2.\\n\\n2[[12[a]]bc] "
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "this is an invalid input."
                    },
                    {
                        "username": "keratonjava",
                        "content": "This is probably the hardest exercice so far, tips use recursion"
                    },
                    {
                        "username": "abhayx2910",
                        "content": "this is a pseudocode for this problem  for beginners\\n\\nfirst make a stack st,\\nrun a loop from 0->string length\\n       When \\']\\' is encountered, we need to start decoding\\n              run a while loop till we encounter \\'[\\'\\n                st.top() + temp makes sure that the string won\\'t be in reverse order eg, if the stack contains 12[abc temp = c + \"\" =>temp = b + \"c\"=>  temp = a + \"bc\"\\n        remove the [ from stack\\n         remove the digits from the stack\\n        if s[i] is not \\']\\', simply push s[i] to the stack\\n return the resultant string"
                    }
                ]
            },
            {
                "id": 1796261,
                "content": [
                    {
                        "username": "chandleryeh",
                        "content": "Here is the Hint\n1. push elements to the stack until meet ']'\n2. pop elements from the stack until meet '[' => contents\n3. pop elements digitals from the stack => number\n4. repeat \"contents\" by \"number\" times and push to the stack\nrepeat step 1 to 4"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "quite interesting problem"
                    },
                    {
                        "username": "puneet-yadav",
                        "content": "I am getting mle for this code,, can anyone tell why i am getting mle?\\n Stack<Character> encodedChar = new Stack<>();\\n        //Stack<Integer> times = new Stack<>();\\n        StringBuilder ans = new StringBuilder();\\n      //  int n = s.length();\\n        for(char c: s.toCharArray()){\\n                if(c==\\']\\'){\\n                StringBuilder toDecode = new StringBuilder();\\n                while(encodedChar.peek()!=\\'[\\'){\\n                    char x = encodedChar.peek();\\n                    encodedChar.pop();\\n                    //toDecode = x + toDecode;\\n                    toDecode.append(x);\\n                }\\n                toDecode = toDecode.reverse();\\n                encodedChar.pop();\\n                if(Character.isDigit(encodedChar.peek())){\\n                    int time = (int)encodedChar.peek();\\n                    encodedChar.pop();\\n                    for(int i=0;i<time;i++){\\n                        toDecode.append(toDecode);\\n                    }\\n                }\\n                else{\\n                    ans.append(toDecode);\\n                    continue;\\n                }\\n                ans.append(toDecode);\\n            }\\n            else{\\n                encodedChar.push(c);\\n                continue;\\n            }\\n        }\\n        if(!encodedChar.isEmpty()){\\n            StringBuilder remaining = new StringBuilder();\\n            while(!encodedChar.isEmpty()){\\n               // remaining = encodedChar.peek() + remaining;\\n            \\tremaining.append(encodedChar.peek());\\n                encodedChar.pop();\\n            }\\n            ans.append(remaining.reverse());\\n        }\\n        return ans.toString();"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Now this is what you call a sexy problem"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "class Solution {\\npublic:\\n\\n    string decodeString(string s) \\n    {\\n        if(s.length()==1 && isalpha(s[0])){return s;}\\n        stack<char> st;\\n        string temp=\"\",res=\"\";\\n        int i=0,k_time=0;\\n        for(i=0;i<s.length();i++)\\n        {\\n            temp=\"\";\\n            while(s[i]!=\\']\\' && i<s.length())\\n            {\\n                st.push(s[i]);\\n                i++;    \\n            }\\n            i++;\\n            temp=\"\";\\n            while(st.top()!=\\'[\\' && !st.empty())\\n            {\\n                temp+=st.top();\\n                st.pop();\\n            }\\n\\n            st.pop();\\n            if(temp.length()>1)\\n            {\\n                reverse(temp.begin(),temp.end());\\n            }\\n            \\n            \\n            string num=\"\";\\n\\n            if(!st.empty())\\n            {\\n                num=num+st.top();\\n                st.pop();\\n                k_time= stoi(num);\\n            }\\n            \\n\\n            while(k_time>0)\\n            {\\n                res = res + temp;\\n                k_time--;\\n            }    \\n        }\\n        reverse(res.begin(),res.end());\\n        return res;    \\n    }\\n};\\n\\ncan somebody please explain what\\'s wrong with this code, I am getting a Runtime error indicating DEADLYSIGNAL with an error of SEGV on unknown address."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "please dont post your solutions in here ..\\n"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "[@ritikthakur09](/ritikthakur09) It didn\\'t work, but thanks for a new concept. "
                    },
                    {
                        "username": "ritikthakur09",
                        "content": "while(st.top()!=\\'[\\' && !st.empty()) \\nwrite it as while( !st.empty() && st.top()!=\\'[\\') instead since you need to check if it is empty first and not opposite."
                    },
                    {
                        "username": "dimitars",
                        "content": "Giving an input \"300[300[300[300[300[99[a]]]]]]\" returns an error reading \"The length of the output should not exceed 10^5.\"\\n\\nMaybe it would improve the description if this is mentioned there, considering I\\'m not missing some site-wide constraint."
                    },
                    {
                        "username": "d_e_v_i_l_07",
                        "content": "class Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<string> st;\\n        int ln= s.size();\\n        if(s.size()==1 && (s>=string(1,\\'0\\') && s<=string(1,\\'9\\')))\\n        return \"\";\\n        int check=0;\\n        for(int i=0;i<ln;i++){\\n            if(s[i]!= \\']\\') st.push(string(1,s[i]));\\n            else{\\n                //finding nested problem,ie string inside []\\n                string temp=\"\";\\n                while(st.top()!= string(1,\\'[\\')){\\n                    temp+= st.top();\\n                    st.pop();\\n                }\\n                reverse(temp.begin(),temp.end());\\n                st.pop();\\n                \\n                //finding number\\n                string num=\"\";\\n                while(!st.empty() && (st.top()>=string(1,\\'0\\') && st.top()<=string(1,\\'9\\'))){\\n                    num+=st.top();\\n                    st.pop();\\n                }\\n                reverse(num.begin(),num.end());\\n                \\n                int n= num.size()!=0? stoi(num): 1;\\n                string toPush= \"\";\\n                for(int i=0;i<n;i++)toPush+= temp;\\n                reverse(toPush.begin(),toPush.end());\\n                st.push(toPush);\\n                check = 1;\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans+= st.top();\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        // if(!check)\\n        // return \"\";\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Kaivalya",
                        "content": "Is  this valid input as a test case ? if yes then how it can be handled using stack ? 8th index of below input will try to get value from stack which is 2.\\n\\n2[[12[a]]bc] "
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "this is an invalid input."
                    },
                    {
                        "username": "keratonjava",
                        "content": "This is probably the hardest exercice so far, tips use recursion"
                    },
                    {
                        "username": "abhayx2910",
                        "content": "this is a pseudocode for this problem  for beginners\\n\\nfirst make a stack st,\\nrun a loop from 0->string length\\n       When \\']\\' is encountered, we need to start decoding\\n              run a while loop till we encounter \\'[\\'\\n                st.top() + temp makes sure that the string won\\'t be in reverse order eg, if the stack contains 12[abc temp = c + \"\" =>temp = b + \"c\"=>  temp = a + \"bc\"\\n        remove the [ from stack\\n         remove the digits from the stack\\n        if s[i] is not \\']\\', simply push s[i] to the stack\\n return the resultant string"
                    }
                ]
            }
        ]
    }
]